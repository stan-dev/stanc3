program: WHILE
##
## Concrete syntax: while
##
## Ends in an error in state: 607.
##
## program' -> . program [ # ]
##
## The known suffix of the stack is as follows:
##
##

Expected "functions {" or "data {" or "transformed data {" or "parameters {" or "transformed parameters {" or "model {" or "generated quantities {".

program: DATABLOCK LBRACE CHOLESKYFACTORCORR LBRACK REALNUMERAL TILDE
## Concrete syntax: data { cholesky_factor_corr [ 3.1415 ~
program: DATABLOCK LBRACE CHOLESKYFACTORCORR LBRACK IDENTIFIER TILDE
## Concrete syntax: data { cholesky_factor_corr [ foo ~
program: DATABLOCK LBRACE CHOLESKYFACTORCORR LBRACK WHILE
## Concrete syntax: data { cholesky_factor_corr [ while
program: DATABLOCK LBRACE CHOLESKYFACTORCORR WHILE
##
## Concrete syntax: data { cholesky_factor_corr while
##
## Ends in an error in state: 799.
##
## top_var_type -> CHOLESKYFACTORCORR . LBRACK lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## top_var_type -> CHOLESKYFACTORCORR . LBRACK non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## CHOLESKYFACTORCORR
##

Expected "[" expression "]" for size of cholesky_factor_corr.

program: DATABLOCK LBRACE CHOLESKYFACTORCOV LBRACK DOTNUMERAL TILDE
## Concrete syntax: data { cholesky_factor_cov [ .2 ~
program: DATABLOCK LBRACE CHOLESKYFACTORCOV LBRACK IDENTIFIER COMMA DOTNUMERAL TILDE
## Concrete syntax: data { cholesky_factor_cov [ foo , .2 ~
program: DATABLOCK LBRACE CHOLESKYFACTORCOV LBRACK IDENTIFIER COMMA IDENTIFIER TILDE
## Concrete syntax: data { cholesky_factor_cov [ foo , foo ~
program: DATABLOCK LBRACE CHOLESKYFACTORCOV LBRACK IDENTIFIER COMMA WHILE
## Concrete syntax: data { cholesky_factor_cov [ foo , while
program: DATABLOCK LBRACE CHOLESKYFACTORCOV WHILE
## Concrete syntax: data { cholesky_factor_cov while
program: DATABLOCK LBRACE CHOLESKYFACTORCOV LBRACK IDENTIFIER TILDE
## Concrete syntax: data { cholesky_factor_cov [ foo ~
program: DATABLOCK LBRACE CHOLESKYFACTORCOV LBRACK WHILE
##
## Concrete syntax: data { cholesky_factor_cov [ while
##
## Ends in an error in state: 789.
##
## top_var_type -> CHOLESKYFACTORCOV LBRACK . lhs option(pair(COMMA,expression)) RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## top_var_type -> CHOLESKYFACTORCOV LBRACK . non_lhs option(pair(COMMA,expression)) RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## CHOLESKYFACTORCOV LBRACK
##

Expected "[" expression "]" or "[" expression "," expression "]" for size of cholesky_factor_cov.

program: DATABLOCK LBRACE CORRMATRIX LBRACK IDENTIFIER TILDE
## Concrete syntax: data { corr_matrix [ foo ~
program: DATABLOCK LBRACE CORRMATRIX LBRACK WHILE
## Concrete syntax: data { corr_matrix [ while
program: DATABLOCK LBRACE CORRMATRIX LBRACK DOTNUMERAL TILDE
## Concrete syntax: data { corr_matrix [ .2 ~
program: DATABLOCK LBRACE CORRMATRIX WHILE
##
## Concrete syntax: data { corr_matrix while
##
## Ends in an error in state: 751.
##
## top_var_type -> CORRMATRIX . LBRACK lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## top_var_type -> CORRMATRIX . LBRACK non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## CORRMATRIX
##

Expected "[" expression "]" for size of corr_matrix.

program: DATABLOCK LBRACE COVMATRIX LBRACK DOTNUMERAL TILDE
## Concrete syntax: data { cov_matrix [ .2 ~
program: DATABLOCK LBRACE COVMATRIX LBRACK IDENTIFIER TILDE
## Concrete syntax: data { cov_matrix [ foo ~
program: DATABLOCK LBRACE COVMATRIX LBRACK WHILE
## Concrete syntax: data { cov_matrix [ while
program: DATABLOCK LBRACE COVMATRIX WHILE
##
## Concrete syntax: data { cov_matrix while
##
## Ends in an error in state: 745.
##
## top_var_type -> COVMATRIX . LBRACK lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## top_var_type -> COVMATRIX . LBRACK non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## COVMATRIX
##

Expected "[" expression "]" for size of cov_matrix.

program: DATABLOCK LBRACE INT LABRACK WHILE
##
## Concrete syntax: data { int < while
##
## Ends in an error in state: 743.
##
## range_constraint -> LABRACK . range RABRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## LABRACK
##

Expected "lower = " expression or "upper = " expression for integer bounds.

program: DATABLOCK LBRACE INT LBRACE
##
## Concrete syntax: data { int {
##
## Ends in an error in state: 742.
##
## top_var_type -> INT . range_constraint [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## INT
##

Expected range constraint or identifier as part of top-level variable declaration.

program: DATABLOCK LBRACE ORDERED LBRACK IDENTIFIER TILDE
## Concrete syntax: data { ordered [ foo ~
program: DATABLOCK LBRACE ORDERED LBRACK WHILE
## Concrete syntax: data { ordered [ while
program: DATABLOCK LBRACE ORDERED LBRACK DOTNUMERAL TILDE
## Concrete syntax: data { ordered [ .2 ~
program: DATABLOCK LBRACE ORDERED WHILE
##
## Concrete syntax: data { ordered while
##
## Ends in an error in state: 721.
##
## top_var_type -> ORDERED . LBRACK lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## top_var_type -> ORDERED . LBRACK non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## ORDERED
##

Expected "[" expression "]" for size of ordered.

program: DATABLOCK LBRACE POSITIVEORDERED LBRACK DOTNUMERAL TILDE
## Concrete syntax: data { positive_ordered [ .2 ~
program: DATABLOCK LBRACE POSITIVEORDERED LBRACK IDENTIFIER TILDE
## Concrete syntax: data { positive_ordered [ foo ~
program: DATABLOCK LBRACE POSITIVEORDERED LBRACK WHILE
## Concrete syntax: data { positive_ordered [ while
program: DATABLOCK LBRACE POSITIVEORDERED WHILE
##
## Concrete syntax: data { positive_ordered while
##
## Ends in an error in state: 715.
##
## top_var_type -> POSITIVEORDERED . LBRACK lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## top_var_type -> POSITIVEORDERED . LBRACK non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## POSITIVEORDERED
##

Expected "[" expression "]" for size of positive_ordered.

program: DATABLOCK LBRACE RBRACE WHILE
##
## Concrete syntax: data { } while
##
## Ends in an error in state: 865.
##
## program -> option(function_block) option(data_block) . option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) option(model_block) option(generated_quantities_block) EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block) option(data_block)
##

Expected "transformed data {" or "parameters {" or "transformed parameters {" or "model {" or "generated quantities {".

program: DATABLOCK LBRACE REAL IDENTIFIER SEMICOLON WHILE
##
## Concrete syntax: data { real foo ; while
##
## Ends in an error in state: 856.
##
## list(top_var_decl_no_assign) -> top_var_decl_no_assign . list(top_var_decl_no_assign) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## top_var_decl_no_assign
##

Only top-level variable declarations allowed in data and parameters blocks.

program: DATABLOCK LBRACE REAL LBRACE
##
## Concrete syntax: data { real {
##
## Ends in an error in state: 713.
##
## top_var_type -> REAL . type_constraint [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## REAL
##

Identifier expected after type in top-level variable declaration.

program: DATABLOCK LBRACE ROWVECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER RABRACK WHILE
##
## Concrete syntax: data { row_vector < multiplier = foo > while
##
## Ends in an error in state: 707.
##
## top_var_type -> ROWVECTOR type_constraint . LBRACK lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## top_var_type -> ROWVECTOR type_constraint . LBRACK non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## ROWVECTOR type_constraint
##

Expected identifier as part of top-level variable declaration.

program: DATABLOCK LBRACE ROWVECTOR LBRACK IDENTIFIER TILDE
##
## Concrete syntax: data { row_vector [ foo ~
##
## Ends in an error in state: 711.
##
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## top_var_type -> ROWVECTOR type_constraint LBRACK lhs . RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## ROWVECTOR type_constraint LBRACK lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Expected "[" expression "]" for size declaration of row_vector.

program: DATABLOCK LBRACE ROWVECTOR LBRACK WHILE
##
## Concrete syntax: data { row_vector [ while
##
## Ends in an error in state: 708.
##
## top_var_type -> ROWVECTOR type_constraint LBRACK . lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## top_var_type -> ROWVECTOR type_constraint LBRACK . non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## ROWVECTOR type_constraint LBRACK
##

Expected "[" expression "]" for size declaration of row_vector.

program: DATABLOCK LBRACE ROWVECTOR WHILE
##
## Concrete syntax: data { row_vector while
##
## Ends in an error in state: 706.
##
## top_var_type -> ROWVECTOR . type_constraint LBRACK lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## top_var_type -> ROWVECTOR . type_constraint LBRACK non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## ROWVECTOR
##

Expected "[" expression "]" for size declaration of row_vector.

program: DATABLOCK LBRACE SIMPLEX LBRACK DOTNUMERAL TILDE
## Concrete syntax: data { simplex [ .2 ~
program: DATABLOCK LBRACE SIMPLEX LBRACK IDENTIFIER TILDE
## Concrete syntax: data { simplex [ foo ~
program: DATABLOCK LBRACE SIMPLEX LBRACK WHILE
## Concrete syntax: data { simplex [ while
program: DATABLOCK LBRACE SIMPLEX WHILE
##
## Concrete syntax: data { simplex while
##
## Ends in an error in state: 700.
##
## top_var_type -> SIMPLEX . LBRACK lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## top_var_type -> SIMPLEX . LBRACK non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## SIMPLEX
##

Expected "[" expression "]" for size of simplex.

program: DATABLOCK LBRACE UNITVECTOR LBRACK DOTNUMERAL TILDE
## Concrete syntax: data { unit_vector [ .2 ~
program: DATABLOCK LBRACE UNITVECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: data { unit_vector [ foo ~
program: DATABLOCK LBRACE UNITVECTOR LBRACK WHILE
## Concrete syntax: data { unit_vector [ while
program: DATABLOCK LBRACE UNITVECTOR WHILE
##
## Concrete syntax: data { unit_vector while
##
## Ends in an error in state: 692.
##
## top_var_type -> UNITVECTOR . LBRACK lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## top_var_type -> UNITVECTOR . LBRACK non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## UNITVECTOR
##

Expected "[" expression "]" for size of unit_vector.

program: DATABLOCK LBRACE VECTOR LABRACK OFFSET ASSIGN IDENTIFIER COMMA MULTIPLIER ASSIGN IDENTIFIER COMMA
##
## Concrete syntax: data { vector < offset = foo , multiplier = foo ,
##
## Ends in an error in state: 666.
##
## constr_expression -> constr_expression . PLUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MINUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . DIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . IDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MODULO constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . LDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTTIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . HAT constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTPOW constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TRANSPOSE [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . LBRACK indexes RBRACK [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## offset_mult -> OFFSET ASSIGN constr_expression COMMA MULTIPLIER ASSIGN constr_expression . [ RABRACK ]
##
## The known suffix of the stack is as follows:
## OFFSET ASSIGN constr_expression COMMA MULTIPLIER ASSIGN constr_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 623, spurious reduction of production constr_expression -> identifier
##

Expected ">" after "multiplier = " expression.

program: DATABLOCK LBRACE VECTOR LABRACK OFFSET ASSIGN IDENTIFIER COMMA MULTIPLIER ASSIGN WHILE
##
## Concrete syntax: data { vector < offset = foo , multiplier = while
##
## Ends in an error in state: 665.
##
## offset_mult -> OFFSET ASSIGN constr_expression COMMA MULTIPLIER ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## OFFSET ASSIGN constr_expression COMMA MULTIPLIER ASSIGN
##

Expected "multiplier = " expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK OFFSET ASSIGN IDENTIFIER COMMA MULTIPLIER WHILE
##
## Concrete syntax: data { vector < offset = foo , multiplier while
##
## Ends in an error in state: 664.
##
## offset_mult -> OFFSET ASSIGN constr_expression COMMA MULTIPLIER . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## OFFSET ASSIGN constr_expression COMMA MULTIPLIER
##

Expected "multiplier = " expression (not containing binary logical operators).

program: DATABLOCK LBRACE ROWVECTOR LABRACK OFFSET ASSIGN IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < offset = foo ' while
program: DATABLOCK LBRACE VECTOR LABRACK OFFSET ASSIGN IDENTIFIER COMMA WHILE
##
## Concrete syntax: data { vector < offset = foo , while
##
## Ends in an error in state: 663.
##
## offset_mult -> OFFSET ASSIGN constr_expression COMMA . MULTIPLIER ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## OFFSET ASSIGN constr_expression COMMA
##

Expected ">" or ", multiplier = " expression (not containing binary logical operators) ">" after "offset = " expression.

program: DATABLOCK LBRACE VECTOR LABRACK OFFSET ASSIGN WHILE
##
## Concrete syntax: data { vector < offset = while
##
## Ends in an error in state: 661.
##
## offset_mult -> OFFSET ASSIGN . constr_expression COMMA MULTIPLIER ASSIGN constr_expression [ RABRACK ]
## offset_mult -> OFFSET ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## OFFSET ASSIGN
##

Expected "offset = " expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK OFFSET WHILE
##
## Concrete syntax: data { vector < offset while
##
## Ends in an error in state: 660.
##
## offset_mult -> OFFSET . ASSIGN constr_expression COMMA MULTIPLIER ASSIGN constr_expression [ RABRACK ]
## offset_mult -> OFFSET . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## OFFSET
##

Expected "offset = " expression (not containing binary logical operators).


program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER DIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo / foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER ELTDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo ./ foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER ELTPOW IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo .^ foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER ELTTIMES IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo .* foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER HAT IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo ^ foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER IDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo %/% foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER LDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo \ foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER MINUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo - foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER MODULO IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo % foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER PLUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo + foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER TIMES IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo * foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN PLUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = + foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN MINUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = - foo ' while
program: DATABLOCK LBRACE VECTOR LABRACK LOWER ASSIGN IDENTIFIER COMMA UPPER ASSIGN IDENTIFIER COMMA
##
## Concrete syntax: data { vector < lower = foo , upper = foo ,
##
## Ends in an error in state: 680.
##
## constr_expression -> constr_expression . PLUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MINUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . DIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . IDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MODULO constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . LDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTTIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . HAT constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTPOW constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TRANSPOSE [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . LBRACK indexes RBRACK [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## range -> LOWER ASSIGN constr_expression COMMA UPPER ASSIGN constr_expression . [ RABRACK ]
##
## The known suffix of the stack is as follows:
## LOWER ASSIGN constr_expression COMMA UPPER ASSIGN constr_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 623, spurious reduction of production constr_expression -> identifier
##

Expected ">" after "upper = " expression.

program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN BANG IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = ! foo ' while
program: DATABLOCK LBRACE VECTOR LABRACK LOWER ASSIGN IDENTIFIER COMMA UPPER ASSIGN WHILE
##
## Concrete syntax: data { vector < lower = foo , upper = while
##
## Ends in an error in state: 679.
##
## range -> LOWER ASSIGN constr_expression COMMA UPPER ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## LOWER ASSIGN constr_expression COMMA UPPER ASSIGN
##

Expected expression (not containing binary logical operators) after "upper = ".

program: DATABLOCK LBRACE VECTOR LABRACK LOWER ASSIGN IDENTIFIER COMMA UPPER WHILE
##
## Concrete syntax: data { vector < lower = foo , upper while
##
## Ends in an error in state: 678.
##
## range -> LOWER ASSIGN constr_expression COMMA UPPER . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## LOWER ASSIGN constr_expression COMMA UPPER
##

Expected "=" expression (not containing binary logical operators) after "upper".

program: DATABLOCK LBRACE VECTOR LABRACK LOWER ASSIGN IDENTIFIER COMMA WHILE
##
## Concrete syntax: data { vector < lower = foo , while
##
## Ends in an error in state: 677.
##
## range -> LOWER ASSIGN constr_expression COMMA . UPPER ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## LOWER ASSIGN constr_expression COMMA
##

"upper =" expression (not containing binary logical operators) ">" expected after "<lower =" expression "," in top-level variable declaration.

program: DATABLOCK LBRACE VECTOR LABRACK LOWER ASSIGN WHILE
##
## Concrete syntax: data { vector < lower = while
##
## Ends in an error in state: 675.
##
## range -> LOWER ASSIGN . constr_expression COMMA UPPER ASSIGN constr_expression [ RABRACK ]
## range -> LOWER ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## LOWER ASSIGN
##

An expression (not containing binary logical operators) is expected for type lower bound.

program: DATABLOCK LBRACE VECTOR LABRACK LOWER WHILE
##
## Concrete syntax: data { vector < lower while
##
## Ends in an error in state: 674.
##
## range -> LOWER . ASSIGN constr_expression COMMA UPPER ASSIGN constr_expression [ RABRACK ]
## range -> LOWER . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## LOWER
##

Expected "=" expression (not containing binary logical operators), after "lower".

program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER ASSIGN WHILE
##
## Concrete syntax: data { vector < multiplier = while
##
## Ends in an error in state: 668.
##
## offset_mult -> MULTIPLIER ASSIGN . constr_expression COMMA OFFSET ASSIGN constr_expression [ RABRACK ]
## offset_mult -> MULTIPLIER ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## MULTIPLIER ASSIGN
##

Expected expression (not containing binary logical operators) after "multiplier =".

program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER WHILE
##
## Concrete syntax: data { vector < multiplier while
##
## Ends in an error in state: 667.
##
## offset_mult -> MULTIPLIER . ASSIGN constr_expression COMMA OFFSET ASSIGN constr_expression [ RABRACK ]
## offset_mult -> MULTIPLIER . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## MULTIPLIER
##

Expected "=" expression (not containing binary logical operators) ">" after "multiplier".

program: DATABLOCK LBRACE VECTOR LABRACK OFFSET ASSIGN REALNUMERAL WHILE
## Concrete syntax: data { vector < offset = 3.1415 while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN BANG WHILE
##
## Concrete syntax: data { vector < upper = ! while
##
## Ends in an error in state: 622.
##
## constr_expression -> BANG . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## BANG
##

Ill-formed expression. Expected expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN MINUS WHILE
##
## Concrete syntax: data { vector < upper = - while
##
## Ends in an error in state: 621.
##
## constr_expression -> MINUS . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## MINUS
##

Ill-formed expression. Expected expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN PLUS WHILE
##
## Concrete syntax: data { vector < upper = + while
##
## Ends in an error in state: 620.
##
## constr_expression -> PLUS . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## PLUS
##

Ill-formed expression. Expected expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER DIVIDE WHILE
##
## Concrete syntax: data { vector < upper = foo / while
##
## Ends in an error in state: 652.
##
## constr_expression -> constr_expression DIVIDE . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## constr_expression DIVIDE
##

Ill-formed expression. Expected expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER ELTDIVIDE WHILE
##
## Concrete syntax: data { vector < upper = foo ./ while
##
## Ends in an error in state: 650.
##
## constr_expression -> constr_expression ELTDIVIDE . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## constr_expression ELTDIVIDE
##

Ill-formed expression. Expected expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER ELTTIMES WHILE
##
## Concrete syntax: data { vector < upper = foo .* while
##
## Ends in an error in state: 648.
##
## constr_expression -> constr_expression ELTTIMES . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## constr_expression ELTTIMES
##

Ill-formed expression. Expected expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER HAT WHILE
##
## Concrete syntax: data { vector < upper = foo ^ while
##
## Ends in an error in state: 630.
##
## constr_expression -> constr_expression HAT . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## constr_expression HAT
##

Ill-formed expression. Expected expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER LBRACK WHILE
##
## Concrete syntax: data { vector < upper = foo [ while
##
## Ends in an error in state: 627.
##
## constr_expression -> constr_expression LBRACK . indexes RBRACK [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## constr_expression LBRACK
##

Ill-formed expression. Expected expression followed by "]".

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER LDIVIDE WHILE
##
## Concrete syntax: data { vector < upper = foo \ while
##
## Ends in an error in state: 640.
##
## constr_expression -> constr_expression LDIVIDE . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## constr_expression LDIVIDE
##

Ill-formed expression. Expected expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER MINUS WHILE
##
## Concrete syntax: data { vector < upper = foo - while
##
## Ends in an error in state: 654.
##
## constr_expression -> constr_expression MINUS . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## constr_expression MINUS
##

Ill-formed expression. Expected expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER MODULO WHILE
##
## Concrete syntax: data { vector < upper = foo % while
##
## Ends in an error in state: 646.
##
## constr_expression -> constr_expression MODULO . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## constr_expression MODULO
##

Ill-formed expression. Expected expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER PLUS WHILE
##
## Concrete syntax: data { vector < upper = foo + while
##
## Ends in an error in state: 644.
##
## constr_expression -> constr_expression PLUS . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## constr_expression PLUS
##

Ill-formed expression. Expected expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER TIMES WHILE
##
## Concrete syntax: data { vector < upper = foo * while
##
## Ends in an error in state: 638.
##
## constr_expression -> constr_expression TIMES . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## constr_expression TIMES
##

Ill-formed expression. Expected expression (not containing binary logical operators).

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER WHILE
##
## Concrete syntax: data { vector < upper = foo while
##
## Ends in an error in state: 623.
##
## common_expression -> identifier . LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA ]
## common_expression -> identifier . LPAREN lhs BAR loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA ]
## common_expression -> identifier . LPAREN non_lhs BAR loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA ]
## constr_expression -> identifier . DOTNUMERAL [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> identifier . [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## identifier
##

Expression expected. Ill-formed expression. Suggested alternatives: a standalone identifier, a function application, an identifier followed by an operator or an identifier followed by an index.

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN WHILE
##
## Concrete syntax: data { vector < upper = while
##
## Ends in an error in state: 619.
##
## range -> UPPER ASSIGN . constr_expression COMMA LOWER ASSIGN constr_expression [ RABRACK ]
## range -> UPPER ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## UPPER ASSIGN
##

Expression (not containing binary logical operators) expected after "upper =". Ill-formed expression.

program: DATABLOCK LBRACE VECTOR LABRACK UPPER WHILE
##
## Concrete syntax: data { vector < upper while
##
## Ends in an error in state: 618.
##
## range -> UPPER . ASSIGN constr_expression COMMA LOWER ASSIGN constr_expression [ RABRACK ]
## range -> UPPER . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## UPPER
##

Expect "=" expression ">" after seeing "upper".

program: DATABLOCK LBRACE VECTOR LABRACK WHILE
##
## Concrete syntax: data { vector < while
##
## Ends in an error in state: 617.
##
## range_constraint -> LABRACK . range RABRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER LBRACK INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## type_constraint -> LABRACK . offset_mult RABRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER LBRACK INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## LABRACK
##

We expect to see "lower =", "upper =", "offset =" or "multiplier =" followed by an expression after "<".

program: DATABLOCK LBRACE VECTOR LBRACK INTNUMERAL RBRACK HAT
##
## Concrete syntax: data { vector [ 24 ] ^
##
## Ends in an error in state: 848.
##
## decl(top_var_type,no_assign) -> top_var_type . decl_identifier dims optional_assignment(no_assign) SEMICOLON [ VECTOR UNITVECTOR TUPLE SIMPLEX SEMICOLON ROWVECTOR REAL RBRACE POSITIVEORDERED ORDERED MATRIX INT COVMATRIX CORRMATRIX COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR ARRAY ]
## decl(top_var_type,no_assign) -> top_var_type . id_and_optional_assignment(no_assign,decl_identifier) option(remaining_declarations(no_assign)) SEMICOLON [ VECTOR UNITVECTOR TUPLE SIMPLEX SEMICOLON ROWVECTOR REAL RBRACE POSITIVEORDERED ORDERED MATRIX INT COVMATRIX CORRMATRIX COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR ARRAY ]
##
## The known suffix of the stack is as follows:
## top_var_type
##

We expect to see an identifier after a sized type.

program: DATABLOCK LBRACE IDENTIFIER
##
## Concrete syntax: data { foo
##
## Ends in an error in state: 615.
##
## data_block -> DATABLOCK LBRACE . list(top_var_decl_no_assign) RBRACE [ TRANSFORMEDPARAMETERSBLOCK TRANSFORMEDDATABLOCK PARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## DATABLOCK LBRACE
##

Invalid type in declaration. Valid types:
  int, real, vector, row_vector, matrix,
  unit_vector, simplex, ordered, positive_ordered,
  corr_matrix, cov_matrix, cholesky_factor_corr, cholesky_factor_cov,
  tuple(...)
optionally preceded by a single array[...]

program: DATABLOCK WHILE
##
## Concrete syntax: data while
##
## Ends in an error in state: 614.
##
## data_block -> DATABLOCK . LBRACE list(top_var_decl_no_assign) RBRACE [ TRANSFORMEDPARAMETERSBLOCK TRANSFORMEDDATABLOCK PARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## DATABLOCK
##

"{" followed by a list of top-level variable declarations is expected after seeing "data".

program: FUNCTIONBLOCK LBRACE RBRACE COVMATRIX
##
## Concrete syntax: functions { } cov_matrix
##
## Ends in an error in state: 613.
##
## program -> option(function_block) . option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) option(model_block) option(generated_quantities_block) EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block)
##

Expected "data {" or "transformed data {" or "parameters {" or "transformed parameters {" or "model {" or "generated quantities {".

program: FUNCTIONBLOCK LBRACE VECTOR LBRACK COMMA WHILE
##
## Concrete syntax: functions { vector [ , while
##
## Ends in an error in state: 15.
##
## list(COMMA) -> COMMA . list(COMMA) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## COMMA
##

List of commas expected.

program: FUNCTIONBLOCK LBRACE VECTOR LBRACK WHILE
##
## Concrete syntax: functions { vector [ while
##
## Ends in an error in state: 14.
##
## unsized_dims -> LBRACK . list(COMMA) RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## LBRACK
##

"[" (list of commas) "]" expected in unsized return type of function definition.

program: FUNCTIONBLOCK LBRACE VECTOR LBRACE
##
## Concrete syntax: functions { vector {
##
## Ends in an error in state: 27.
##
## unsized_type -> basic_type . option(unsized_dims) [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## basic_type
##

Either a number of unsized dimensions is expected as part of a function return type or an identifier is expected as a function name.

program: FUNCTIONBLOCK LBRACE VOID WHILE LPAREN RPAREN SEMICOLON EOF
## Concrete syntax: functions { void while ( ) ;
program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN RPAREN SEMICOLON WHILE
##
## Concrete syntax: functions { void foo ( ) ; while
##
## Ends in an error in state: 605.
##
## list(function_def) -> function_def . list(function_def) [ RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## function_def
##

A "}" or a function definition/declaration is expected.

program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN DATABLOCK WHILE
##
## Concrete syntax: functions { void foo ( data while
##
## Ends in an error in state: 88.
##
## arg_decl -> option(DATABLOCK) . unsized_type decl_identifier [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## option(DATABLOCK)
##

An identifier is expected as a function argument name.

program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN RPAREN VOID
##
## Concrete syntax: functions { void foo ( ) void
##
## Ends in an error in state: 92.
##
## function_def -> return_type decl_identifier LPAREN loption(separated_nonempty_list(COMMA,arg_decl)) RPAREN . statement [ VOID VECTOR TUPLE ROWVECTOR REAL RBRACE MATRIX INT EOF COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX ARRAY ]
##
## The known suffix of the stack is as follows:
## return_type decl_identifier LPAREN loption(separated_nonempty_list(COMMA,arg_decl)) RPAREN
##

Either "{" statement "}" is expected for a function definition or ";" for a function forward declaration.

program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN WHILE
## Concrete syntax: functions { void foo ( while
program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN VECTOR IDENTIFIER COMMA WHILE
##
## Concrete syntax: functions { void foo ( vector foo , while
##
## Ends in an error in state: 600.
##
## separated_nonempty_list(COMMA,arg_decl) -> arg_decl COMMA . separated_nonempty_list(COMMA,arg_decl) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## arg_decl COMMA
##

An argument declaration (unsized and unconstrained type followed by identifier) is expected.

program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN VECTOR IDENTIFIER WHILE
##
## Concrete syntax: functions { void foo ( vector foo while
##
## Ends in an error in state: 599.
##
## separated_nonempty_list(COMMA,arg_decl) -> arg_decl . [ RPAREN ]
## separated_nonempty_list(COMMA,arg_decl) -> arg_decl . COMMA separated_nonempty_list(COMMA,arg_decl) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## arg_decl
##

"," or ")" expected after function argument declaration.

program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN VECTOR LBRACK RBRACK LBRACK
##
## Concrete syntax: functions { void foo ( vector [ ] [
##
## Ends in an error in state: 89.
##
## arg_decl -> option(DATABLOCK) unsized_type . decl_identifier [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## option(DATABLOCK) unsized_type
##

An identifier is expected as a function argument name.

program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER WHILE
##
## Concrete syntax: functions { void foo while
##
## Ends in an error in state: 84.
##
## function_def -> return_type decl_identifier . LPAREN loption(separated_nonempty_list(COMMA,arg_decl)) RPAREN statement [ VOID VECTOR TUPLE ROWVECTOR REAL RBRACE MATRIX INT EOF COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX ARRAY ]
##
## The known suffix of the stack is as follows:
## return_type decl_identifier
##

"(" expected after function name.

program: FUNCTIONBLOCK LBRACE VOID LBRACK
##
## Concrete syntax: functions { void [
##
## Ends in an error in state: 38.
##
## function_def -> return_type . decl_identifier LPAREN loption(separated_nonempty_list(COMMA,arg_decl)) RPAREN statement [ VOID VECTOR TUPLE ROWVECTOR REAL RBRACE MATRIX INT EOF COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX ARRAY ]
##
## The known suffix of the stack is as follows:
## return_type
##

An identifier is expected as a function name.

program: FUNCTIONBLOCK LBRACE WHILE
##
## Concrete syntax: functions { while
##
## Ends in an error in state: 609.
##
## function_block -> FUNCTIONBLOCK LBRACE . list(function_def) RBRACE [ TRANSFORMEDPARAMETERSBLOCK TRANSFORMEDDATABLOCK PARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF DATABLOCK ]
##
## The known suffix of the stack is as follows:
## FUNCTIONBLOCK LBRACE
##

Function forward declaration, definition or "}" expected after "functions {".

program: FUNCTIONBLOCK WHILE
##
## Concrete syntax: functions while
##
## Ends in an error in state: 608.
##
## function_block -> FUNCTIONBLOCK . LBRACE list(function_def) RBRACE [ TRANSFORMEDPARAMETERSBLOCK TRANSFORMEDDATABLOCK PARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF DATABLOCK ]
##
## The known suffix of the stack is as follows:
## FUNCTIONBLOCK
##

"{" expected after "functions".

program: GENERATEDQUANTITIESBLOCK LBRACE RBRACE ELTTIMESASSIGN
##
## Concrete syntax: generated quantities { } .*=
##
## Ends in an error in state: 914.
##
## program -> option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) option(model_block) option(generated_quantities_block) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) option(model_block) option(generated_quantities_block)
##

Expected end of file after end of generated quantities block.

program: GENERATEDQUANTITIESBLOCK LBRACE VOID
##
## Concrete syntax: generated quantities { void
##
## Ends in an error in state: 911.
##
## generated_quantities_block -> GENERATEDQUANTITIESBLOCK LBRACE . list(top_vardecl_or_statement) RBRACE [ EOF ]
##
## The known suffix of the stack is as follows:
## GENERATEDQUANTITIESBLOCK LBRACE
##

Variable declaration or statement or "}" expected in generated quantities block.

program: GENERATEDQUANTITIESBLOCK WHILE
##
## Concrete syntax: generated quantities while
##
## Ends in an error in state: 910.
##
## generated_quantities_block -> GENERATEDQUANTITIESBLOCK . LBRACE list(top_vardecl_or_statement) RBRACE [ EOF ]
##
## The known suffix of the stack is as follows:
## GENERATEDQUANTITIESBLOCK
##

Expected "{" after block keyword.

program: MODELBLOCK LBRACE MATRIX LBRACK DOTNUMERAL COMMA DOTNUMERAL TILDE
## Concrete syntax: model { matrix [ .2 , .2 ~
program: MODELBLOCK LBRACE MATRIX LBRACK DOTNUMERAL TILDE
## Concrete syntax: model { matrix [ .2 ~
program: MODELBLOCK LBRACE MATRIX LBRACK IDENTIFIER COMMA DOTNUMERAL TILDE
## Concrete syntax: model { matrix [ foo , .2 ~
program: DATABLOCK LBRACE MATRIX LBRACK DOTNUMERAL COMMA DOTNUMERAL TILDE
## Concrete syntax: data { matrix [ .2 , .2 ~
program: DATABLOCK LBRACE MATRIX LABRACK MULTIPLIER ASSIGN IDENTIFIER RABRACK WHILE
## Concrete syntax: data { matrix < multiplier = foo > while
program: DATABLOCK LBRACE MATRIX LBRACK REALNUMERAL COMMA IDENTIFIER TILDE
## Concrete syntax: data { matrix [ 3.1415 , foo ~
program: DATABLOCK LBRACE MATRIX LBRACK REALNUMERAL COMMA WHILE
## Concrete syntax: data { matrix [ 3.1415 , while
program: DATABLOCK LBRACE MATRIX LBRACK IDENTIFIER COMMA IDENTIFIER TILDE
## Concrete syntax: data { matrix [ foo , foo ~
program: DATABLOCK LBRACE MATRIX LBRACK IDENTIFIER COMMA WHILE
## Concrete syntax: data { matrix [ foo , while
program: DATABLOCK LBRACE MATRIX LBRACK IDENTIFIER TILDE
## Concrete syntax: data { matrix [ foo ~
program: DATABLOCK LBRACE MATRIX LBRACK WHILE
## Concrete syntax: data { matrix [ while
program: DATABLOCK LBRACE MATRIX WHILE
## Concrete syntax: data { matrix while
program: DATABLOCK LBRACE MATRIX LBRACK DOTNUMERAL TILDE
## Concrete syntax: data { matrix [ .2 ~
program: DATABLOCK LBRACE MATRIX LBRACK IDENTIFIER COMMA DOTNUMERAL TILDE
## Concrete syntax: data { matrix [ foo , .2 ~
program: DATABLOCK LBRACE COMPLEXMATRIX LABRACK OFFSET ASSIGN IDENTIFIER RABRACK WHILE
## Concrete syntax: data { complex_matrix < offset = foo > while
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL COMMA REALNUMERAL TILDE
## Concrete syntax: data { complex_matrix [ 3.1415 , 3.1415 ~
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL COMMA IDENTIFIER TILDE
## Concrete syntax: data { complex_matrix [ 3.1415 , foo ~
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL COMMA WHILE
## Concrete syntax: data { complex_matrix [ 3.1415 , while
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL TILDE
## Concrete syntax: data { complex_matrix [ 3.1415 ~
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK IDENTIFIER COMMA REALNUMERAL TILDE
## Concrete syntax: data { complex_matrix [ foo , 3.1415 ~
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK IDENTIFIER COMMA IDENTIFIER TILDE
## Concrete syntax: data { complex_matrix [ foo , foo ~
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK IDENTIFIER COMMA WHILE
## Concrete syntax: data { complex_matrix [ foo , while
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK IDENTIFIER TILDE
## Concrete syntax: data { complex_matrix [ foo ~
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK WHILE
## Concrete syntax: data { complex_matrix [ while
program: DATABLOCK LBRACE COMPLEXMATRIX WHILE
## Concrete syntax: data { complex_matrix while
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL COMMA REALNUMERAL TILDE
## Concrete syntax: model { complex_matrix [ 3.1415 , 3.1415 ~
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL COMMA IDENTIFIER TILDE
## Concrete syntax: model { complex_matrix [ 3.1415 , foo ~
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL COMMA WHILE
## Concrete syntax: model { complex_matrix [ 3.1415 , while
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL TILDE
## Concrete syntax: model { complex_matrix [ 3.1415 ~
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK IDENTIFIER COMMA REALNUMERAL TILDE
## Concrete syntax: model { complex_matrix [ foo , 3.1415 ~
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK IDENTIFIER COMMA IDENTIFIER TILDE
## Concrete syntax: model { complex_matrix [ foo , foo ~
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK IDENTIFIER COMMA WHILE
## Concrete syntax: model { complex_matrix [ foo , while
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK IDENTIFIER TILDE
## Concrete syntax: model { complex_matrix [ foo ~
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK WHILE
## Concrete syntax: model { complex_matrix [ while
program: MODELBLOCK LBRACE COMPLEXMATRIX WHILE
## Concrete syntax: model { complex_matrix while
program: MODELBLOCK LBRACE MATRIX LBRACK REALNUMERAL COMMA IDENTIFIER TILDE
## Concrete syntax: model { matrix [ 3.1415 , foo ~
program: MODELBLOCK LBRACE MATRIX LBRACK REALNUMERAL COMMA WHILE
## Concrete syntax: model { matrix [ 3.1415 , while
program: MODELBLOCK LBRACE MATRIX LBRACK IDENTIFIER COMMA IDENTIFIER TILDE
## Concrete syntax: model { matrix [ foo , foo ~
program: MODELBLOCK LBRACE MATRIX LBRACK IDENTIFIER COMMA WHILE
## Concrete syntax: model { matrix [ foo , while
program: MODELBLOCK LBRACE MATRIX LBRACK IDENTIFIER TILDE
## Concrete syntax: model { matrix [ foo ~
program: MODELBLOCK LBRACE MATRIX LBRACK WHILE
## Concrete syntax: model { matrix [ while
program: MODELBLOCK LBRACE MATRIX WHILE
##
## Concrete syntax: model { matrix while
##
## Ends in an error in state: 323.
##
## sized_basic_type -> MATRIX . LBRACK lhs COMMA lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## sized_basic_type -> MATRIX . LBRACK lhs COMMA non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## sized_basic_type -> MATRIX . LBRACK non_lhs COMMA lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## sized_basic_type -> MATRIX . LBRACK non_lhs COMMA non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## MATRIX
##

"[" expression "," expression "]" expected for matrix sizes.

program: MODELBLOCK LBRACE RBRACE ELTTIMESASSIGN
##
## Concrete syntax: model { } .*=
##
## Ends in an error in state: 909.
##
## program -> option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) option(model_block) . option(generated_quantities_block) EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) option(model_block)
##

Expected "generated quantities {" or end of file after end of model block.

program: MODELBLOCK LBRACE REAL WHILE ASSIGN DOTNUMERAL TILDE
## Concrete syntax: model { real while = .2 ~
program: MODELBLOCK LBRACE REAL IDENTIFIER ASSIGN IDENTIFIER TILDE
## Concrete syntax: model { real foo = foo ~
program: MODELBLOCK LBRACE REAL IDENTIFIER ASSIGN WHILE
##
## Concrete syntax: model { real foo = while
##
## Ends in an error in state: 462.
##
## option(pair(ASSIGN,expression)) -> ASSIGN . lhs [ SEMICOLON COMMA ]
## option(pair(ASSIGN,expression)) -> ASSIGN . non_lhs [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## ASSIGN
##

Ill-formed expression. Expression followed by ";" expected after "=".

program: MODELBLOCK LBRACE REAL IDENTIFIER LBRACK IDENTIFIER RBRACE
##
## Concrete syntax: model { real foo [ foo }
##
## Ends in an error in state: 479.
##
## dims -> LBRACK separated_nonempty_list(COMMA,expression) . RBRACK [ SEMICOLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## LBRACK separated_nonempty_list(COMMA,expression)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
## In state 255, spurious reduction of production separated_nonempty_list(COMMA,expression) -> lhs
##

Ill-formed array sizes. "[" (non-empty comma separated list of expressions) "]" expected to specify array sizes.

program: MODELBLOCK LBRACE REAL IDENTIFIER LBRACK WHILE
##
## Concrete syntax: model { real foo [ while
##
## Ends in an error in state: 478.
##
## dims -> LBRACK . separated_nonempty_list(COMMA,expression) RBRACK [ SEMICOLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## LBRACK
##

Ill-formed array sizes. "[" (non-empty comma separated list of expressions) "]" expected to specify array sizes.

program: MODELBLOCK LBRACE REAL LBRACK
##
## Concrete syntax: model { real [
##
## Ends in an error in state: 473.
##
## decl(sized_basic_type,expression) -> sized_basic_type . decl_identifier dims optional_assignment(expression) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## decl(sized_basic_type,expression) -> sized_basic_type . id_and_optional_assignment(expression,decl_identifier) option(remaining_declarations(expression)) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## sized_basic_type
##

Identifier expected after sized type in local (or model block) variable declaration. (No transformations/constraints allowed.)

program: DATABLOCK LBRACE COMPLEXROWVECTOR LABRACK OFFSET ASSIGN IDENTIFIER RABRACK WHILE
## Concrete syntax: data { complex_row_vector < offset = foo > while
program: DATABLOCK LBRACE COMPLEXROWVECTOR LBRACK REALNUMERAL TILDE
## Concrete syntax: data { complex_row_vector [ 3.1415 ~
program: DATABLOCK LBRACE COMPLEXROWVECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: data { complex_row_vector [ foo ~
program: DATABLOCK LBRACE COMPLEXROWVECTOR LBRACK WHILE
## Concrete syntax: data { complex_row_vector [ while
program: DATABLOCK LBRACE COMPLEXROWVECTOR WHILE
## Concrete syntax: data { complex_row_vector while
program: MODELBLOCK LBRACE ROWVECTOR LBRACK DOTNUMERAL TILDE
## Concrete syntax: model { row_vector [ .2 ~
program: MODELBLOCK LBRACE COMPLEXROWVECTOR LBRACK REALNUMERAL TILDE
## Concrete syntax: model { complex_row_vector [ 3.1415 ~
program: MODELBLOCK LBRACE COMPLEXROWVECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: model { complex_row_vector [ foo ~
program: MODELBLOCK LBRACE COMPLEXROWVECTOR LBRACK WHILE
## Concrete syntax: model { complex_row_vector [ while
program: MODELBLOCK LBRACE COMPLEXROWVECTOR WHILE
## Concrete syntax: model { complex_row_vector while
program: DATABLOCK LBRACE ROWVECTOR LBRACK DOTNUMERAL TILDE
## Concrete syntax: data { row_vector [ .2 ~
program: MODELBLOCK LBRACE ROWVECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: model { row_vector [ foo ~
program: MODELBLOCK LBRACE ROWVECTOR WHILE
## Concrete syntax: model { row_vector while
program: MODELBLOCK LBRACE ROWVECTOR LBRACK WHILE
##
## Concrete syntax: model { row_vector [ while
##
## Ends in an error in state: 317.
##
## sized_basic_type -> ROWVECTOR LBRACK . lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## sized_basic_type -> ROWVECTOR LBRACK . non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## ROWVECTOR LBRACK
##

"[" expression "]" expected for row_vector size.

program: MODELBLOCK LBRACE SEMICOLON VOID
##
## Concrete syntax: model { ; void
##
## Ends in an error in state: 586.
##
## list(vardecl_or_statement) -> vardecl_or_statement . list(vardecl_or_statement) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## vardecl_or_statement
##

Variable declaration, statement or "}" expected.

program: DATABLOCK LBRACE COMPLEXVECTOR LABRACK OFFSET ASSIGN IDENTIFIER RABRACK WHILE
## Concrete syntax: data { complex_vector < offset = foo > while
program: DATABLOCK LBRACE COMPLEXVECTOR LBRACK REALNUMERAL TILDE
## Concrete syntax: data { complex_vector [ 3.1415 ~
program: DATABLOCK LBRACE COMPLEXVECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: data { complex_vector [ foo ~
program: DATABLOCK LBRACE COMPLEXVECTOR LBRACK WHILE
## Concrete syntax: data { complex_vector [ while
program: DATABLOCK LBRACE COMPLEXVECTOR WHILE
## Concrete syntax: data { complex_vector while
program: MODELBLOCK LBRACE COMPLEXVECTOR LBRACK REALNUMERAL TILDE
## Concrete syntax: model { complex_vector [ 3.1415 ~
program: MODELBLOCK LBRACE COMPLEXVECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: model { complex_vector [ foo ~
program: DATABLOCK LBRACE VECTOR LBRACK DOTNUMERAL TILDE
## Concrete syntax: data { vector [ .2 ~
program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER RABRACK WHILE
## Concrete syntax: data { vector < multiplier = foo > while
program: DATABLOCK LBRACE VECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: data { vector [ foo ~
program: DATABLOCK LBRACE VECTOR LBRACK WHILE
## Concrete syntax: data { vector [ while
program: DATABLOCK LBRACE VECTOR WHILE
## Concrete syntax: data { vector while
program: MODELBLOCK LBRACE VECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: model { vector [ foo ~
program: MODELBLOCK LBRACE COMPLEXVECTOR LBRACK WHILE
## Concrete syntax: model { complex_vector [ while
program: MODELBLOCK LBRACE VECTOR LBRACK WHILE
## Concrete syntax: model { vector [ while
program: MODELBLOCK LBRACE COMPLEXVECTOR WHILE
## Concrete syntax: model { complex_vector while
program: MODELBLOCK LBRACE VECTOR LBRACK DOTNUMERAL TILDE
## Concrete syntax: model { vector [ .2 ~
program: MODELBLOCK LBRACE VECTOR WHILE
##
## Concrete syntax: model { vector while
##
## Ends in an error in state: 308.
##
## sized_basic_type -> VECTOR . LBRACK lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## sized_basic_type -> VECTOR . LBRACK non_lhs RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## VECTOR
##

Expected "[" expression "]" for vector size.

program: MODELBLOCK LBRACE VOID
##
## Concrete syntax: model { void
##
## Ends in an error in state: 906.
##
## model_block -> MODELBLOCK LBRACE . list(vardecl_or_statement) RBRACE [ GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## MODELBLOCK LBRACE
##

Variable declaration, statement or "}" expected.

program: MODELBLOCK WHILE
##
## Concrete syntax: model while
##
## Ends in an error in state: 905.
##
## model_block -> MODELBLOCK . LBRACE list(vardecl_or_statement) RBRACE [ GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## MODELBLOCK
##

Expected "{" after "model".

program: PARAMETERSBLOCK LBRACE RBRACE ELTTIMESASSIGN
##
## Concrete syntax: parameters { } .*=
##
## Ends in an error in state: 898.
##
## program -> option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) . option(transformed_parameters_block) option(model_block) option(generated_quantities_block) EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block) option(data_block) option(transformed_data_block) option(parameters_block)
##

"transformed parameters {", "model {" or "generated quantities {" expected after end of parameters block.

program: PARAMETERSBLOCK LBRACE WHILE
##
## Concrete syntax: parameters { while
##
## Ends in an error in state: 894.
##
## parameters_block -> PARAMETERSBLOCK LBRACE . list(top_var_decl_no_assign) RBRACE [ TRANSFORMEDPARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## PARAMETERSBLOCK LBRACE
##

Expected top-level variable declaration or "}".

program: PARAMETERSBLOCK WHILE
##
## Concrete syntax: parameters while
##
## Ends in an error in state: 893.
##
## parameters_block -> PARAMETERSBLOCK . LBRACE list(top_var_decl_no_assign) RBRACE [ TRANSFORMEDPARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## PARAMETERSBLOCK
##

Expected "{" after "parameters".

program: TRANSFORMEDDATABLOCK LBRACE BANG IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { ! foo ' while
program: TRANSFORMEDDATABLOCK LBRACE BANG IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { ! foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE BANG WHILE
##
## Concrete syntax: transformed data { ! while
##
## Ends in an error in state: 110.
##
## non_lhs -> BANG . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> BANG . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## BANG
##

Ill-formed expression. Expression expected after "!".

program: TRANSFORMEDDATABLOCK LBRACE BREAK WHILE
##
## Concrete syntax: transformed data { break while
##
## Ends in an error in state: 448.
##
## atomic_statement -> BREAK . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## BREAK
##

Expected ";" after "break".

program: TRANSFORMEDDATABLOCK LBRACE CONTINUE WHILE
##
## Concrete syntax: transformed data { continue while
##
## Ends in an error in state: 446.
##
## atomic_statement -> CONTINUE . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## CONTINUE
##

Expected ";" after "continue".

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN REALNUMERAL COLON REALNUMERAL RPAREN VOID
##
## Concrete syntax: transformed data { for ( foo in 3.1415 : 3.1415 ) void
##
## Ends in an error in state: 563.
##
## nested_statement -> FOR LPAREN identifier IN non_lhs COLON non_lhs RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN non_lhs COLON non_lhs RPAREN
##

Ill-formed statement. Expected statement after ")"  for the loop body of the for loop..

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN REALNUMERAL COLON IDENTIFIER RPAREN VOID
##
## Concrete syntax: transformed data { for ( foo in 3.1415 : foo ) void
##
## Ends in an error in state: 566.
##
## nested_statement -> FOR LPAREN identifier IN non_lhs COLON lhs RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN non_lhs COLON lhs RPAREN
##

Ill-formed statement. Expected statement after ")"  for the loop body of the for loop.

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN IDENTIFIER COLON DOTNUMERAL TILDE
## Concrete syntax: transformed data { for ( foo in foo : .2 ~
program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN DOTNUMERAL COLON DOTNUMERAL TILDE
## Concrete syntax: transformed data { for ( foo in .2 : .2 ~
program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN REALNUMERAL COLON IDENTIFIER TILDE
## Concrete syntax: transformed data { for ( foo in 3.1415 : foo ~
program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN REALNUMERAL COLON WHILE
##
## Concrete syntax: transformed data { for ( foo in 3.1415 : while
##
## Ends in an error in state: 561.
##
## nested_statement -> FOR LPAREN identifier IN non_lhs COLON . lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier IN non_lhs COLON . non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN non_lhs COLON
##

Ill-formed expression. Expected expression followed by ")" after "for (" identifier "in" expression ":".

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN REALNUMERAL RPAREN VOID
##
## Concrete syntax: transformed data { for ( foo in 3.1415 ) void
##
## Ends in an error in state: 445.
##
## nested_statement -> FOR LPAREN identifier IN non_lhs RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN non_lhs RPAREN
##

Ill-formed statement. Expected statement after ")" for the loop body of the foreach loop.

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN IDENTIFIER COLON REALNUMERAL RPAREN VOID
##
## Concrete syntax: transformed data { for ( foo in foo : 3.1415 ) void
##
## Ends in an error in state: 573.
##
## nested_statement -> FOR LPAREN identifier IN lhs COLON non_lhs RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN lhs COLON non_lhs RPAREN
##

Ill-formed statement. Expected statement after ")" for the loop body of the for loop.

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN IDENTIFIER COLON IDENTIFIER RPAREN VOID
##
## Concrete syntax: transformed data { for ( foo in foo : foo ) void
##
## Ends in an error in state: 576.
##
## nested_statement -> FOR LPAREN identifier IN lhs COLON lhs RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN lhs COLON lhs RPAREN
##

Ill-formed statement. Expected statement after ")" for the loop body of the for loop.

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN IDENTIFIER COLON IDENTIFIER TILDE
##
## Concrete syntax: transformed data { for ( foo in foo : foo ~
##
## Ends in an error in state: 575.
##
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## nested_statement -> FOR LPAREN identifier IN lhs COLON lhs . RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN lhs COLON lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed expression. Expected expression followed by ")" after "for (" identifier "in" expression ":".

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN IDENTIFIER COLON WHILE
##
## Concrete syntax: transformed data { for ( foo in foo : while
##
## Ends in an error in state: 571.
##
## nested_statement -> FOR LPAREN identifier IN lhs COLON . lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier IN lhs COLON . non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN lhs COLON
##

Ill-formed expression. Expected expression followed by ")" after "for (" identifier "in" expression ":".

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN IDENTIFIER RPAREN VOID
##
## Concrete syntax: transformed data { for ( foo in foo ) void
##
## Ends in an error in state: 569.
##
## nested_statement -> FOR LPAREN identifier IN lhs RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN lhs RPAREN
##

Ill-formed statement. Expected statement after ")" for the loop body of the foreach loop.

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN DOTNUMERAL TILDE
## Concrete syntax: transformed data { for ( foo in .2 ~
program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { for ( foo in foo ~
##
## Ends in an error in state: 568.
##
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COLON AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COLON AND ]
## nested_statement -> FOR LPAREN identifier IN lhs . COLON lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier IN lhs . COLON non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier IN lhs . RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed expression. Expected expression followed by ")" or ":" after "for (" identifier "in".

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN WHILE
##
## Concrete syntax: transformed data { for ( foo in while
##
## Ends in an error in state: 443.
##
## nested_statement -> FOR LPAREN identifier IN . lhs COLON lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier IN . lhs COLON non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier IN . non_lhs COLON lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier IN . non_lhs COLON non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier IN . lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier IN . non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN
##

Ill-formed expression. Expected expression followed by ")" or ":" after "for (" identifier "in".

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER WHILE
##
## Concrete syntax: transformed data { for ( foo while
##
## Ends in an error in state: 442.
##
## nested_statement -> FOR LPAREN identifier . IN lhs COLON lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier . IN lhs COLON non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier . IN non_lhs COLON lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier . IN non_lhs COLON non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier . IN lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier . IN non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier
##

Expected "in" after loop identifier.

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN WHILE
##
## Concrete syntax: transformed data { for ( while
##
## Ends in an error in state: 441.
##
## nested_statement -> FOR LPAREN . identifier IN lhs COLON lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN . identifier IN lhs COLON non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN . identifier IN non_lhs COLON lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN . identifier IN non_lhs COLON non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN . identifier IN lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN . identifier IN non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN
##

Expected (loop) identifier after "(".

program: TRANSFORMEDDATABLOCK LBRACE FOR WHILE
##
## Concrete syntax: transformed data { for while
##
## Ends in an error in state: 440.
##
## nested_statement -> FOR . LPAREN identifier IN lhs COLON lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR . LPAREN identifier IN lhs COLON non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR . LPAREN identifier IN non_lhs COLON lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR . LPAREN identifier IN non_lhs COLON non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR . LPAREN identifier IN lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR . LPAREN identifier IN non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR
##

Expected "(" after "for".

program: TRANSFORMEDDATABLOCK LBRACE GETLP LPAREN WHILE
##
## Concrete syntax: transformed data { get_lp ( while
##
## Ends in an error in state: 107.
##
## common_expression -> GETLP LPAREN . RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## GETLP LPAREN
##

Expected ")" after "get_lp(".

program: TRANSFORMEDDATABLOCK LBRACE GETLP WHILE
##
## Concrete syntax: transformed data { get_lp while
##
## Ends in an error in state: 106.
##
## common_expression -> GETLP . LPAREN RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## GETLP
##

Expected "()" after "get_lp".

program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN REALNUMERAL RPAREN SEMICOLON ELSE VOID
##
## Concrete syntax: transformed data { if ( 3.1415 ) ; else void
##
## Ends in an error in state: 579.
##
## nested_statement -> IF LPAREN non_lhs RPAREN vardecl_or_statement ELSE . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF LPAREN non_lhs RPAREN vardecl_or_statement ELSE
##

Ill-formed statement. Expected statement after "else".

program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN REALNUMERAL RPAREN SEMICOLON VOID
## Concrete syntax: transformed data { if ( 3.1415 ) ; void
program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN REALNUMERAL RPAREN SEMICOLON UNREACHABLE
##
## Concrete syntax: transformed data { if ( 3.1415 ) ; <<<<UNREACHABLE>>>
##
## Ends in an error in state: 578.
##
## nested_statement -> IF LPAREN non_lhs RPAREN vardecl_or_statement . ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF LPAREN non_lhs RPAREN vardecl_or_statement . [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF LPAREN non_lhs RPAREN vardecl_or_statement
##

Ill-formed block. Expected a statement, variable declaration, or just "}".

program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN REALNUMERAL RPAREN VOID
##
## Concrete syntax: transformed data { if ( 3.1415 ) void
##
## Ends in an error in state: 439.
##
## nested_statement -> IF LPAREN non_lhs RPAREN . vardecl_or_statement ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF LPAREN non_lhs RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF LPAREN non_lhs RPAREN
##

Ill-formed statement. Statement expected for true branch of conditional.

program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN IDENTIFIER RPAREN SEMICOLON ELSE VOID
##
## Concrete syntax: transformed data { if ( foo ) ; else void
##
## Ends in an error in state: 584.
##
## nested_statement -> IF LPAREN lhs RPAREN vardecl_or_statement ELSE . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF LPAREN lhs RPAREN vardecl_or_statement ELSE
##

Ill-formed statement. Expected statement after else.

program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN IDENTIFIER RPAREN VOID
##
## Concrete syntax: transformed data { if ( foo ) void
##
## Ends in an error in state: 582.
##
## nested_statement -> IF LPAREN lhs RPAREN . vardecl_or_statement ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF LPAREN lhs RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF LPAREN lhs RPAREN
##

Ill-formed statement. Expected statement after ")" for true branch of conditional.

program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN DOTNUMERAL TILDE
## Concrete syntax: transformed data { if ( .2 ~
program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { if ( foo ~
##
## Ends in an error in state: 581.
##
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## nested_statement -> IF LPAREN lhs . RPAREN vardecl_or_statement ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF LPAREN lhs . RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## IF LPAREN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed expression. Expression expected after "(", for test of conditional control flow construct.

program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN WHILE
##
## Concrete syntax: transformed data { if ( while
##
## Ends in an error in state: 437.
##
## nested_statement -> IF LPAREN . lhs RPAREN vardecl_or_statement ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF LPAREN . non_lhs RPAREN vardecl_or_statement ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF LPAREN . lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF LPAREN . non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF LPAREN
##

Expected expression for test of conditional control flow construct.

program: TRANSFORMEDDATABLOCK LBRACE IF WHILE
##
## Concrete syntax: transformed data { if while
##
## Ends in an error in state: 436.
##
## nested_statement -> IF . LPAREN lhs RPAREN vardecl_or_statement ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF . LPAREN non_lhs RPAREN vardecl_or_statement ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF . LPAREN lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF . LPAREN non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF
##

"(" expression ")" expected after "if".

program: TRANSFORMEDDATABLOCK LBRACE INCREMENTLOGPROB LPAREN REALNUMERAL RPAREN WHILE
##
## Concrete syntax: transformed data { increment_log_prob ( 3.1415 ) while
##
## Ends in an error in state: 431.
##
## atomic_statement -> INCREMENTLOGPROB LPAREN non_lhs RPAREN . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## INCREMENTLOGPROB LPAREN non_lhs RPAREN
##

Ill-formed statement. Expected ";" after ")".

program: TRANSFORMEDDATABLOCK LBRACE INCREMENTLOGPROB LPAREN IDENTIFIER RPAREN WHILE
##
## Concrete syntax: transformed data { increment_log_prob ( foo ) while
##
## Ends in an error in state: 434.
##
## atomic_statement -> INCREMENTLOGPROB LPAREN lhs RPAREN . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## INCREMENTLOGPROB LPAREN lhs RPAREN
##

Ill-formed statement. Expected ";" after ")".

program: TRANSFORMEDDATABLOCK LBRACE INCREMENTLOGPROB LPAREN DOTNUMERAL TILDE
## Concrete syntax: transformed data { increment_log_prob ( .2 ~
program: TRANSFORMEDDATABLOCK LBRACE INCREMENTLOGPROB LPAREN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { increment_log_prob ( foo ~
##
## Ends in an error in state: 433.
##
## atomic_statement -> INCREMENTLOGPROB LPAREN lhs . RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## INCREMENTLOGPROB LPAREN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed statement. Expected expression followed by ");" after "(".

program: TRANSFORMEDDATABLOCK LBRACE INCREMENTLOGPROB LPAREN WHILE
##
## Concrete syntax: transformed data { increment_log_prob ( while
##
## Ends in an error in state: 429.
##
## atomic_statement -> INCREMENTLOGPROB LPAREN . lhs RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> INCREMENTLOGPROB LPAREN . non_lhs RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## INCREMENTLOGPROB LPAREN
##

Ill-formed statement. Expected expression followed by ");" after "(".

program: TRANSFORMEDDATABLOCK LBRACE INCREMENTLOGPROB WHILE
##
## Concrete syntax: transformed data { increment_log_prob while
##
## Ends in an error in state: 428.
##
## atomic_statement -> INCREMENTLOGPROB . LPAREN lhs RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> INCREMENTLOGPROB . LPAREN non_lhs RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## INCREMENTLOGPROB
##

Ill-formed statement. Expected "(" followed by an expression and ");", after "increment_log_prob".

program: TRANSFORMEDDATABLOCK LBRACE LBRACE REALNUMERAL COMMA WHILE
##
## Concrete syntax: transformed data { { 3.1415 , while
##
## Ends in an error in state: 252.
##
## separated_nonempty_list(COMMA,expression) -> non_lhs COMMA . separated_nonempty_list(COMMA,expression) [ RPAREN RBRACK RBRACE ]
##
## The known suffix of the stack is as follows:
## non_lhs COMMA
##

Ill-formed expression. Expected a comma-separated list of expressions.

program: TRANSFORMEDDATABLOCK LBRACE LBRACE VOID
##
## Concrete syntax: transformed data { { void
##
## Ends in an error in state: 427.
##
## common_expression -> LBRACE . separated_nonempty_list(COMMA,expression) RBRACE [ TRANSPOSE TIMES TILDE RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## nested_statement -> LBRACE . list(vardecl_or_statement) RBRACE [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed phrase. "{" should be followed by a statement, variable declaration or expression.

program: TRANSFORMEDDATABLOCK LBRACE LBRACK IDENTIFIER COMMA WHILE
##
## Concrete syntax: transformed data { [ foo , while
##
## Ends in an error in state: 256.
##
## separated_nonempty_list(COMMA,expression) -> lhs COMMA . separated_nonempty_list(COMMA,expression) [ RPAREN RBRACK RBRACE ]
##
## The known suffix of the stack is as follows:
## lhs COMMA
##

Ill-formed expression. We expect a comma separated list of expressions.

program: DATABLOCK LBRACE ARRAY LBRACK IDENTIFIER RPAREN
## Concrete syntax: data { array [ foo )
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK IDENTIFIER TILDE
## Concrete syntax: transformed data { 3.1415 [ foo ~
program: TRANSFORMEDDATABLOCK LBRACE LBRACK IDENTIFIER RPAREN
##
## Concrete syntax: transformed data { [ foo )
##
## Ends in an error in state: 290.
##
## common_expression -> LBRACK loption(separated_nonempty_list(COMMA,expression)) . RBRACK [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## LBRACK loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
## In state 255, spurious reduction of production separated_nonempty_list(COMMA,expression) -> lhs
## In state 146, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

Ill-formed expression. We expect a comma separated list of expressions, followed by "]".

program: TRANSFORMEDDATABLOCK LBRACE LBRACK IDENTIFIER TILDE
##
## Concrete syntax: transformed data { [ foo ~
##
## Ends in an error in state: 255.
##
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## separated_nonempty_list(COMMA,expression) -> lhs . [ RPAREN RBRACK RBRACE ]
## separated_nonempty_list(COMMA,expression) -> lhs . COMMA separated_nonempty_list(COMMA,expression) [ RPAREN RBRACK RBRACE ]
##
## The known suffix of the stack is as follows:
## lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed phrase. We found an L-value. Parse failed on token after the L-value.

program: TRANSFORMEDDATABLOCK LBRACE LBRACK WHILE
##
## Concrete syntax: transformed data { [ while
##
## Ends in an error in state: 102.
##
## common_expression -> LBRACK . loption(separated_nonempty_list(COMMA,expression)) RBRACK [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## LBRACK
##

Comma separated list of expressions followed by "]" expected after "[".

program: TRANSFORMEDDATABLOCK LBRACE LPAREN IDENTIFIER COMMA IDENTIFIER RBRACK
## Concrete syntax: transformed data { ( foo , foo ]
program: TRANSFORMEDDATABLOCK LBRACE LPAREN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { ( foo ~
##
## Ends in an error in state: 297.
##
## common_expression -> LPAREN lhs . COMMA separated_nonempty_list(COMMA,expression) RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## common_expression -> LPAREN lhs . RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed phrase. Found "(" followed by expression. Expect a "[", "," or ")" or an infix or postfix operator.

program: TRANSFORMEDDATABLOCK LBRACE MINUS IDENTIFIER LBRACK RBRACK WHILE
##
## Concrete syntax: transformed data { - foo [ ] while
##
## Ends in an error in state: 303.
##
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> MINUS lhs . [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## MINUS lhs
##

Ill-formed expression. Found an expression. Expect an infix or postfix operator or "[" or "~" or "]" or ";".

program: TRANSFORMEDDATABLOCK LBRACE MINUS WHILE
##
## Concrete syntax: transformed data { - while
##
## Ends in an error in state: 100.
##
## non_lhs -> MINUS . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> MINUS . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## MINUS
##

Ill-formed expression. Expect an expression after "-".

program: TRANSFORMEDDATABLOCK LBRACE PLUS IDENTIFIER LBRACK RBRACK WHILE
##
## Concrete syntax: transformed data { + foo [ ] while
##
## Ends in an error in state: 305.
##
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> PLUS lhs . [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## PLUS lhs
##

Ill-formed expression. Found an expression. Expect an infix or postfix operator or "[" or "~" or "]" or ";".

program: TRANSFORMEDDATABLOCK LBRACE PLUS WHILE
##
## Concrete syntax: transformed data { + while
##
## Ends in an error in state: 99.
##
## non_lhs -> PLUS . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> PLUS . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## PLUS
##

Ill-formed expression. Expect an expression after "+".

program: TRANSFORMEDDATABLOCK LBRACE PRINT LPAREN STRINGLITERAL WHILE
##
## Concrete syntax: transformed data { print ( "hello world" while
##
## Ends in an error in state: 424.
##
## atomic_statement -> PRINT LPAREN printables . RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## printables -> printables . COMMA printables [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## PRINT LPAREN printables
##

Expected a comma-separated list of expressions or strings followed by ");" after "print(".

program: TRANSFORMEDDATABLOCK LBRACE PRINT LPAREN IDENTIFIER RPAREN WHILE
##
## Concrete syntax: transformed data { print ( foo ) while
##
## Ends in an error in state: 425.
##
## atomic_statement -> PRINT LPAREN printables RPAREN . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PRINT LPAREN printables RPAREN
##

Expected a ";" after "print(...)".

program: TRANSFORMEDDATABLOCK LBRACE PRINT LPAREN WHILE
##
## Concrete syntax: transformed data { print ( while
##
## Ends in an error in state: 423.
##
## atomic_statement -> PRINT LPAREN . printables RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PRINT LPAREN
##

Expected a comma-separated list of expressions or strings followed by ");" after "print(".

program: TRANSFORMEDDATABLOCK LBRACE PRINT WHILE
##
## Concrete syntax: transformed data { print while
##
## Ends in an error in state: 422.
##
## atomic_statement -> PRINT . LPAREN printables RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PRINT
##

Expected "(" followed by a comma-separated list of expressions or strings followed by ");" after "print".

program: TRANSFORMEDDATABLOCK LBRACE RBRACE ELTTIMESASSIGN
##
## Concrete syntax: transformed data { } .*=
##
## Ends in an error in state: 892.
##
## program -> option(function_block) option(data_block) option(transformed_data_block) . option(parameters_block) option(transformed_parameters_block) option(model_block) option(generated_quantities_block) EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block) option(data_block) option(transformed_data_block)
##

Expected "parameters {", "transformed parameters {", "model {", "generated quantities {" or end-of-file after end of transformed data block.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER QMARK IDENTIFIER COLON IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo ? foo : foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER QMARK DOTNUMERAL COLON IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo ? .2 : foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTPOW IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo .^ foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTTIMES IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo .* foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER RABRACK IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo > foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TIMES IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo * foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER EQUALS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo == foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER GEQ IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo >= foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER HAT IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo ^ foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER IDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo %/% foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo \ foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LABRACK IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo < foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LEQ IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo <= foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo ./ foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER AND IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo && foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL TIMES IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 * foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL QMARK IDENTIFIER COLON IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 ? foo : foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL RABRACK IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 > foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER MINUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo - foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER MINUSASSIGN DOTNUMERAL TILDE
## Concrete syntax: transformed data { foo -= .2 ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER MODULO IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo % foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER NEQUALS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo != foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER OR IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo || foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER PLUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo + foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL QMARK DOTNUMERAL COLON IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 ? .2 : foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL AND IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 && foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL DIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 / foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL ELTDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 ./ foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL ELTPOW IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 .^ foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER DIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo / foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL ELTTIMES IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 .* foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL EQUALS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 == foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL GEQ IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 >= foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL HAT IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 ^ foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL IDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 %/% foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL LABRACK IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 < foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL LDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 \ foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL LEQ IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 <= foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL MINUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 - foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL MODULO IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 % foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL NEQUALS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 != foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL OR IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 || foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL PLUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { .2 + foo ' while
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL SEMICOLON
## Concrete syntax: transformed data { .2 ;
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL AND IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 && foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL DIVIDE IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 / foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL ELTDIVIDE IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 ./ foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL ELTTIMES IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 .* foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL EQUALS IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 == foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL GEQ IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 >= foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL HAT IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 ^ foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LABRACK IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 < foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LDIVIDE IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 \ foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LEQ IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 <= foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL MINUS IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 - foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL MODULO IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 % foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL NEQUALS IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 != foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL OR IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 || foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL PLUS IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 + foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL QMARK REALNUMERAL COLON IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 ? 3.1415 : foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL QMARK IDENTIFIER COLON IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 ? foo : foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL RABRACK IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 > foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TIMES IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 * foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER AND IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo && foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER DIVIDE IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo / foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTDIVIDE IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo ./ foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTTIMES IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo .* foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER EQUALS IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo == foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER GEQ IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo >= foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER HAT IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo ^ foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LABRACK IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo < foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LDIVIDE IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo \ foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LEQ IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo <= foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER MINUS IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo - foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER MODULO IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo % foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER NEQUALS IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo != foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER OR IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo || foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER PLUS IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo + foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER QMARK IDENTIFIER COLON IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo ? foo : foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER RABRACK IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo > foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TIMES IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo * foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER QMARK REALNUMERAL COLON IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo ? 3.1415 : foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER IDIVIDE IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo %/% foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTPOW IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { foo .^ foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL IDIVIDE IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 %/% foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL ELTPOW IDENTIFIER LBRACK RBRACK WHILE
## Concrete syntax: transformed data { 3.1415 .^ foo [ ] while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK REALNUMERAL COLON IDENTIFIER TILDE
## Concrete syntax: transformed data { 3.1415 [ 3.1415 : foo ~
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK IDENTIFIER COLON IDENTIFIER TILDE
## Concrete syntax: transformed data { 3.1415 [ foo : foo ~
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK IDENTIFIER COLON WHILE
## Concrete syntax: transformed data { 3.1415 [ foo : while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK WHILE
##
## Concrete syntax: transformed data { 3.1415 [ while
##
## Ends in an error in state: 113.
##
## non_lhs -> non_lhs LBRACK . indexes RBRACK [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## non_lhs LBRACK
##

Found an ill-formed expression where we expected a statement. Is there a missing semi-colon here?
Or did you mean to use the preceding expression in:
* a function call
* a sampling statement
* the conditional in a for, while, or if statement
* assignment to a variable?

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LDIVIDE WHILE
## Concrete syntax: transformed data { 3.1415 \ while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL MINUS WHILE
## Concrete syntax: transformed data { 3.1415 - while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL PLUS WHILE
## Concrete syntax: transformed data { 3.1415 + while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL OR WHILE
## Concrete syntax: transformed data { 3.1415 || while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL NEQUALS WHILE
## Concrete syntax: transformed data { 3.1415 != while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL MODULO WHILE
## Concrete syntax: transformed data { 3.1415 % while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LEQ WHILE
## Concrete syntax: transformed data { 3.1415 <= while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL RABRACK WHILE
## Concrete syntax: transformed data { 3.1415 > while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TIMES WHILE
## Concrete syntax: transformed data { 3.1415 * while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER AND WHILE
## Concrete syntax: transformed data { foo && while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER DIVIDE WHILE
## Concrete syntax: transformed data { foo / while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTDIVIDE WHILE
## Concrete syntax: transformed data { foo ./ while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTTIMES WHILE
## Concrete syntax: transformed data { foo .* while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER EQUALS WHILE
## Concrete syntax: transformed data { foo == while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER GEQ WHILE
## Concrete syntax: transformed data { foo >= while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER HAT WHILE
## Concrete syntax: transformed data { foo ^ while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LABRACK WHILE
## Concrete syntax: transformed data { foo < while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LDIVIDE WHILE
## Concrete syntax: transformed data { foo \ while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LEQ WHILE
## Concrete syntax: transformed data { foo <= while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER MINUS WHILE
## Concrete syntax: transformed data { foo - while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER MODULO WHILE
## Concrete syntax: transformed data { foo % while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER NEQUALS WHILE
## Concrete syntax: transformed data { foo != while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTTIMESASSIGN WHILE
## Concrete syntax: transformed data { foo .*= while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER OR WHILE
## Concrete syntax: transformed data { foo || while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER PLUS WHILE
## Concrete syntax: transformed data { foo + while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER RABRACK WHILE
## Concrete syntax: transformed data { foo > while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TIMES WHILE
## Concrete syntax: transformed data { foo * while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER IDIVIDE WHILE
## Concrete syntax: data { vector < upper = foo %/% while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER ELTPOW WHILE
## Concrete syntax: data { vector < upper = foo .^ while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER IDIVIDE WHILE
## Concrete syntax: transformed data { foo %/% while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTPOW WHILE
## Concrete syntax: transformed data { foo .^ while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL ELTPOW WHILE
##
## Concrete syntax: transformed data { 3.1415 .^ while
##
## Ends in an error in state: 122.
##
## non_lhs -> non_lhs ELTPOW . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs ELTPOW . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## non_lhs ELTPOW
##

Found an incomplete binary expression - are you missing the right hand side?

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER QMARK DOTNUMERAL TILDE
## Concrete syntax: transformed data { foo ? .2 ~
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL QMARK DOTNUMERAL TILDE
## Concrete syntax: transformed data { .2 ? .2 ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER QMARK REALNUMERAL COLON WHILE
## Concrete syntax: transformed data { foo ? 3.1415 : while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER QMARK IDENTIFIER COLON WHILE
## Concrete syntax: transformed data { foo ? foo : while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER QMARK IDENTIFIER TILDE
## Concrete syntax: transformed data { foo ? foo ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER QMARK WHILE
## Concrete syntax: transformed data { foo ? while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL QMARK REALNUMERAL COLON WHILE
## Concrete syntax: transformed data { 3.1415 ? 3.1415 : while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL QMARK IDENTIFIER COLON WHILE
## Concrete syntax: transformed data { 3.1415 ? foo : while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL QMARK IDENTIFIER TILDE
## Concrete syntax: transformed data { 3.1415 ? foo ~
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL QMARK WHILE
##
## Concrete syntax: transformed data { 3.1415 ? while
##
## Ends in an error in state: 148.
##
## non_lhs -> non_lhs QMARK . lhs COLON lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs QMARK . lhs COLON non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs QMARK . non_lhs COLON lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs QMARK . non_lhs COLON non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## non_lhs QMARK
##

Found an incomplete ternary expression, should be "(condition) ? (true branch) : (false branch)".
Did you forget to add a colon or a false branch?
For example, this returns 3.0:
  1 ? 0.0 : 3.0

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL AND WHILE
##
## Concrete syntax: transformed data { 3.1415 && while
##
## Ends in an error in state: 220.
##
## non_lhs -> non_lhs AND . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs AND . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## non_lhs AND
##

Ill-formed expression. Expected expression after expression followed by "&&".




program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL IDIVIDE WHILE
##
## Concrete syntax: transformed data { 3.1415 %/% while
##
## Ends in an error in state: 134.
##
## non_lhs -> non_lhs IDIVIDE . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs IDIVIDE . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## non_lhs IDIVIDE
##

Ill-formed expression. Expected expression after expression followed by "%/%".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL DIVIDE WHILE
##
## Concrete syntax: transformed data { 3.1415 / while
##
## Ends in an error in state: 170.
##
## non_lhs -> non_lhs DIVIDE . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs DIVIDE . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## non_lhs DIVIDE
##

Ill-formed expression. Expected expression after expression followed by "/".


program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL ELTDIVIDE WHILE
##
## Concrete syntax: transformed data { 3.1415 ./ while
##
## Ends in an error in state: 167.
##
## non_lhs -> non_lhs ELTDIVIDE . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs ELTDIVIDE . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## non_lhs ELTDIVIDE
##

Ill-formed expression. Expected expression after expression followed by "./".



program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL ELTTIMES WHILE
##
## Concrete syntax: transformed data { 3.1415 .* while
##
## Ends in an error in state: 156.
##
## non_lhs -> non_lhs ELTTIMES . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs ELTTIMES . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## non_lhs ELTTIMES
##

Ill-formed expression. Expected expression after expression followed by ".*".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL EQUALS WHILE
##
## Concrete syntax: transformed data { 3.1415 == while
##
## Ends in an error in state: 217.
##
## non_lhs -> non_lhs EQUALS . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs EQUALS . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## non_lhs EQUALS
##

Ill-formed expression. Expected expression after expression followed by "==".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL GEQ WHILE
##
## Concrete syntax: transformed data { 3.1415 >= while
##
## Ends in an error in state: 201.
##
## non_lhs -> non_lhs GEQ . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs GEQ . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## non_lhs GEQ
##

Ill-formed expression. Expected expression after expression followed by ">=".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL HAT WHILE
##
## Concrete syntax: transformed data { 3.1415 ^ while
##
## Ends in an error in state: 120.
##
## non_lhs -> non_lhs HAT . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs HAT . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## non_lhs HAT
##

Ill-formed expression. Expected expression after expression followed by "^".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LABRACK WHILE
##
## Concrete syntax: transformed data { 3.1415 < while
##
## Ends in an error in state: 198.
##
## non_lhs -> non_lhs LABRACK . lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs LABRACK . non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## non_lhs LABRACK
##

Ill-formed expression. Expected expression after expression followed by "<".

program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL LBRACK COLON DOTNUMERAL TILDE
## Concrete syntax: transformed data { .2 [ : .2 ~
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK COLON IDENTIFIER TILDE
##
## Concrete syntax: transformed data { 3.1415 [ : foo ~
##
## Ends in an error in state: 284.
##
## indexes -> COLON lhs . [ RBRACK COMMA ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## COLON lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed phrase. Found ":" expression. We expect either an infix or postfix operator, or "," or or "[" or "]" next.

program: TRANSFORMEDDATABLOCK LBRACE MINUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { - foo ' while
program: TRANSFORMEDDATABLOCK LBRACE PLUS IDENTIFIER TRANSPOSE WHILE
##
## Concrete syntax: transformed data { + foo ' while
##
## Ends in an error in state: 304.
##
## non_lhs -> non_lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . PLUS lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . PLUS non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . MINUS lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . MINUS non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . TIMES lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . TIMES non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . DIVIDE lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . DIVIDE non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . IDIVIDE lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . MODULO lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . MODULO non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . LDIVIDE lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . ELTTIMES lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . HAT lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . HAT non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . ELTPOW lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . ELTPOW non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . OR lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . OR non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . AND lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . AND non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . EQUALS lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . EQUALS non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . NEQUALS lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . NEQUALS non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . LABRACK lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . LABRACK non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . LEQ lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . LEQ non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . RABRACK lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . RABRACK non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . GEQ lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . GEQ non_lhs [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> PLUS non_lhs . [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . TRANSPOSE [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## non_lhs -> non_lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## PLUS non_lhs
##

Ill-formed expression. Found an expression. Expect an infix or postfix operator or "["

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK COLON WHILE
##
## Concrete syntax: transformed data { 3.1415 [ : while
##
## Ends in an error in state: 114.
##
## indexes -> COLON . [ RBRACK COMMA ]
## indexes -> COLON . lhs [ RBRACK COMMA ]
## indexes -> COLON . non_lhs [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed expression. Expected expression or "]" or "," after ":".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK COMMA WHILE
##
## Concrete syntax: transformed data { 3.1415 [ , while
##
## Ends in an error in state: 279.
##
## indexes -> indexes COMMA . indexes [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## indexes COMMA
##

Expected index after indices followed by ",".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK REALNUMERAL COLON WHILE
##
## Concrete syntax: transformed data { 3.1415 [ 3.1415 : while
##
## Ends in an error in state: 270.
##
## indexes -> non_lhs COLON . [ RBRACK COMMA ]
## indexes -> non_lhs COLON . lhs [ RBRACK COMMA ]
## indexes -> non_lhs COLON . non_lhs [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## non_lhs COLON
##

Ill-formed expression. Expected expression or "]" or "," after ":".


program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK COMMA RBRACK MULTIPLIER
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T [ , ] multiplier
##
## Ends in an error in state: 499.
##
## atomic_statement -> non_lhs TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation) . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## non_lhs TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation)
##

Expected ";" after "~"-statement (with optional truncation).

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK COMMA IDENTIFIER COMMA
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T [ , foo ,
##
## Ends in an error in state: 494.
##
## truncation -> TRUNCATE LBRACK option(expression) COMMA option(expression) . RBRACK [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## TRUNCATE LBRACK option(expression) COMMA option(expression)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
## In state 497, spurious reduction of production option(expression) -> lhs
##

Ill-formed truncation. Expect the format "T[" optional expression "," optional expression "];".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK COMMA WHILE
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T [ , while
##
## Ends in an error in state: 493.
##
## truncation -> TRUNCATE LBRACK option(expression) COMMA . option(expression) RBRACK [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## TRUNCATE LBRACK option(expression) COMMA
##

Ill-formed truncation. Expect the format "T[" optional expression "," optional expression "];".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK IDENTIFIER RBRACK
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T [ foo ]
##
## Ends in an error in state: 492.
##
## truncation -> TRUNCATE LBRACK option(expression) . COMMA option(expression) RBRACK [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## TRUNCATE LBRACK option(expression)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
## In state 497, spurious reduction of production option(expression) -> lhs
##

Ill-formed truncation. Expect the format "T[" optional expression "," optional expression "];".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK IDENTIFIER TILDE
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T [ foo ~
##
## Ends in an error in state: 497.
##
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## option(expression) -> lhs . [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed expression. Found an expression. Expect a infix or postfix operator or "[" or "]" or "," next.

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK WHILE
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T [ while
##
## Ends in an error in state: 491.
##
## truncation -> TRUNCATE LBRACK . option(expression) COMMA option(expression) RBRACK [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## TRUNCATE LBRACK
##

Ill-formed truncation. Expect the format "T[" optional expression "," optional expression "];".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE WHILE
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T while
##
## Ends in an error in state: 490.
##
## truncation -> TRUNCATE . LBRACK option(expression) COMMA option(expression) RBRACK [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## TRUNCATE
##

Ill-formed truncation. Expect the format "T[" optional expression "," optional expression "];".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN WHILE
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) while
##
## Ends in an error in state: 489.
##
## atomic_statement -> non_lhs TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN . option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## non_lhs TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN
##

Ill-formed "~"-statement. Expect either ";" or a truncation with the format "T[" optional expression "," optional expression "];".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN IDENTIFIER RBRACK
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( foo ]
##
## Ends in an error in state: 488.
##
## atomic_statement -> non_lhs TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) . RPAREN option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## non_lhs TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
## In state 255, spurious reduction of production separated_nonempty_list(COMMA,expression) -> lhs
## In state 146, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

Ill-formed "~"-statement. Expect a comma separated list of expressions for arguments to the distribution, followed by ")".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN WHILE
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( while
##
## Ends in an error in state: 487.
##
## atomic_statement -> non_lhs TILDE identifier LPAREN . loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## non_lhs TILDE identifier LPAREN
##

Ill-formed "~"-statement. Expect a comma separated list of expressions for arguments to the distribution, followed by ")".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER WHILE
##
## Concrete syntax: transformed data { 3.1415 ~ foo while
##
## Ends in an error in state: 486.
##
## atomic_statement -> non_lhs TILDE identifier . LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## non_lhs TILDE identifier
##

Ill-formed "~"-statement. Expect "(" after distribution name, followed by a comma separated list of expressions for arguments to the distribution, followed by ")".

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE WHILE
##
## Concrete syntax: transformed data { 3.1415 ~ while
##
## Ends in an error in state: 485.
##
## atomic_statement -> non_lhs TILDE . identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## non_lhs TILDE
##

Ill-formed "~"-statement. Expect an distribution name after "~".

program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN IDENTIFIER COMMA STRINGLITERAL WHILE
##
## Concrete syntax: transformed data { reject ( foo , "hello world" while
##
## Ends in an error in state: 414.
##
## printables -> printables . COMMA printables [ RPAREN COMMA ]
## printables -> printables COMMA printables . [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## printables COMMA printables
##

Ill-formed printable. After "print(" and "reject(", we expect a comma separated list of either expressions or strings, followed by ");".

program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN IDENTIFIER COMMA WHILE
##
## Concrete syntax: transformed data { reject ( foo , while
##
## Ends in an error in state: 413.
##
## printables -> printables COMMA . printables [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## printables COMMA
##

Ill-formed printable. After "print(" and "reject(", we expect a comma separated list of either expressions or strings, followed by ");".

program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN DOTNUMERAL TILDE
## Concrete syntax: transformed data { reject ( .2 ~
program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN STRINGLITERAL WHILE
## Concrete syntax: transformed data { reject ( "hello world" while
program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN IDENTIFIER TILDE
## Concrete syntax: transformed data { reject ( foo ~
program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN IDENTIFIER RPAREN WHILE
## Concrete syntax: transformed data { reject ( foo ) while
program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN WHILE
##
## Concrete syntax: transformed data { reject ( while
##
## Ends in an error in state: 407.
##
## atomic_statement -> REJECT LPAREN . printables RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## REJECT LPAREN
##

Ill-formed reject statement. After "reject(", we expect a comma separated list of either expressions or strings, followed by ");".

program: TRANSFORMEDDATABLOCK LBRACE REJECT WHILE
##
## Concrete syntax: transformed data { reject while
##
## Ends in an error in state: 406.
##
## atomic_statement -> REJECT . LPAREN printables RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## REJECT
##

Ill-formed reject statement. After "reject(", we expect a comma separated list of either expressions or strings, followed by ");".

program: TRANSFORMEDDATABLOCK LBRACE RETURN LBRACE IDENTIFIER RPAREN
##
## Concrete syntax: transformed data { return { foo )
##
## Ends in an error in state: 288.
##
## common_expression -> LBRACE separated_nonempty_list(COMMA,expression) . RBRACE [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## LBRACE separated_nonempty_list(COMMA,expression)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
## In state 255, spurious reduction of production separated_nonempty_list(COMMA,expression) -> lhs
##

Expected either "," followed by expression or "}" next.

program: TRANSFORMEDDATABLOCK LBRACE RETURN LBRACE WHILE
##
## Concrete syntax: transformed data { return { while
##
## Ends in an error in state: 103.
##
## common_expression -> LBRACE . separated_nonempty_list(COMMA,expression) RBRACE [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Expression expected after "{" in array expression.

program: TRANSFORMEDDATABLOCK LBRACE RETURN TARGET WHILE
##
## Concrete syntax: transformed data { return target while
##
## Ends in an error in state: 95.
##
## common_expression -> TARGET . LPAREN RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## TARGET
##

Ill formed expression. After "target", we expect "()".

program: TRANSFORMEDDATABLOCK LBRACE RETURN IDENTIFIER LPAREN IDENTIFIER COMMA IDENTIFIER RBRACK
##
## Concrete syntax: transformed data { return foo ( foo , foo ]
##
## Ends in an error in state: 261.
##
## common_expression -> identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) . RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
## In state 255, spurious reduction of production separated_nonempty_list(COMMA,expression) -> lhs
## In state 257, spurious reduction of production separated_nonempty_list(COMMA,expression) -> lhs COMMA separated_nonempty_list(COMMA,expression)
## In state 146, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

Ill-formed expression. In function application, expect comma-separated list of expressions followed by ")", after "(".

program: TRANSFORMEDDATABLOCK LBRACE RETURN IDENTIFIER LPAREN WHILE
##
## Concrete syntax: transformed data { return foo ( while
##
## Ends in an error in state: 145.
##
## common_expression -> identifier LPAREN . loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## common_expression -> identifier LPAREN . lhs BAR loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## common_expression -> identifier LPAREN . non_lhs BAR loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN
##

Ill-formed expression. In function application, expect comma-separated list of expressions followed by ")", after "(".

program: TRANSFORMEDDATABLOCK LBRACE RETURN WHILE
## Concrete syntax: transformed data { return while
program: TRANSFORMEDDATABLOCK LBRACE RETURN DOTNUMERAL TILDE
## Concrete syntax: transformed data { return .2 ~
program: TRANSFORMEDDATABLOCK LBRACE RETURN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { return foo ~
##
## Ends in an error in state: 404.
##
## atomic_statement -> RETURN lhs . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## RETURN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed return statement. ";" or expression followed by ";" expected after "return".

program: TRANSFORMEDDATABLOCK LBRACE RETURN IDENTIFIER WHILE
##
## Concrete syntax: transformed data { return foo while
##
## Ends in an error in state: 144.
##
## common_expression -> identifier . LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## common_expression -> identifier . LPAREN lhs BAR loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## common_expression -> identifier . LPAREN non_lhs BAR loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## lhs -> identifier . [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## identifier
##

Ill-formed expression. Found identifier. There are many ways to complete this to a well-formed expression.

program: TRANSFORMEDDATABLOCK LBRACE TARGET LPAREN WHILE
##
## Concrete syntax: transformed data { target ( while
##
## Ends in an error in state: 96.
##
## common_expression -> TARGET LPAREN . RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## TARGET LPAREN
##

Ill-formed expression. Expected ")" after "target(".

program: TRANSFORMEDDATABLOCK LBRACE TARGET PLUSASSIGN WHILE
## Concrete syntax: transformed data { target += while
program: TRANSFORMEDDATABLOCK LBRACE TARGET PLUSASSIGN DOTNUMERAL TILDE
## Concrete syntax: transformed data { target += .2 ~
program: TRANSFORMEDDATABLOCK LBRACE TARGET PLUSASSIGN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { target += foo ~
##
## Ends in an error in state: 397.
##
## atomic_statement -> TARGET PLUSASSIGN lhs . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## TARGET PLUSASSIGN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed statement. Expression followed by ";" expected after "target +=".

program: TRANSFORMEDDATABLOCK LBRACE TARGET WHILE
##
## Concrete syntax: transformed data { target while
##
## Ends in an error in state: 393.
##
## atomic_statement -> TARGET . PLUSASSIGN lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> TARGET . PLUSASSIGN non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## common_expression -> TARGET . LPAREN RPAREN [ TRANSPOSE TIMES TILDE RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## TARGET
##

Ill-formed phrase. Expect either "+=" or "()" after "target".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ARROWASSIGN DOTNUMERAL TILDE
## Concrete syntax: transformed data { foo <- .2 ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ARROWASSIGN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { foo <- foo ~
##
## Ends in an error in state: 548.
##
## atomic_statement -> lhs ARROWASSIGN lhs . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## lhs ARROWASSIGN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed phrase. Found L-value "<-" expression. There are many ways in which this can be completed to a valid phrase.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ARROWASSIGN WHILE
##
## Concrete syntax: transformed data { foo <- while
##
## Ends in an error in state: 545.
##
## atomic_statement -> lhs ARROWASSIGN . lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs ARROWASSIGN . non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs ARROWASSIGN
##

Ill-formed expression. Found L-value "<-". Expect an expression followed by ";" next.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN DOTNUMERAL TILDE
## Concrete syntax: transformed data { foo = .2 ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { foo = foo ~
##
## Ends in an error in state: 543.
##
## atomic_statement -> lhs ASSIGN lhs . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## lhs ASSIGN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed phrase. Found L-value "=" expression. There are many ways in which this can be completed to a valid phrase.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN WHILE
##
## Concrete syntax: transformed data { foo = while
##
## Ends in an error in state: 540.
##
## atomic_statement -> lhs ASSIGN . lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs ASSIGN . non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs ASSIGN
##

Ill-formed expression. Found L-value "=". Expect an expression followed by ";" next.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER DIVIDEASSIGN DOTNUMERAL TILDE
## Concrete syntax: transformed data { foo /= .2 ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER DIVIDEASSIGN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { foo /= foo ~
##
## Ends in an error in state: 538.
##
## atomic_statement -> lhs DIVIDEASSIGN lhs . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## lhs DIVIDEASSIGN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed phrase. Found L-value "/=" expression. There are many ways in which this can be completed to a valid phrase.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER DIVIDEASSIGN WHILE
##
## Concrete syntax: transformed data { foo /= while
##
## Ends in an error in state: 535.
##
## atomic_statement -> lhs DIVIDEASSIGN . lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs DIVIDEASSIGN . non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs DIVIDEASSIGN
##

Ill-formed expression. Found L-value "/=". Expect an expression followed by ";" next.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTDIVIDEASSIGN DOTNUMERAL TILDE
## Concrete syntax: transformed data { foo ./= .2 ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTDIVIDEASSIGN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { foo ./= foo ~
##
## Ends in an error in state: 533.
##
## atomic_statement -> lhs ELTDIVIDEASSIGN lhs . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## lhs ELTDIVIDEASSIGN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed phrase. Found L-value "./=" expression. There are many ways in which this can be completed to a valid phrase.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTDIVIDEASSIGN WHILE
##
## Concrete syntax: transformed data { foo ./= while
##
## Ends in an error in state: 530.
##
## atomic_statement -> lhs ELTDIVIDEASSIGN . lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs ELTDIVIDEASSIGN . non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs ELTDIVIDEASSIGN
##

Ill-formed expression. Found L-value "./=". Expect an expression followed by ";" next.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTTIMESASSIGN DOTNUMERAL TILDE
## Concrete syntax: transformed data { foo .*= .2 ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTTIMESASSIGN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { foo .*= foo ~
##
## Ends in an error in state: 528.
##
## atomic_statement -> lhs ELTTIMESASSIGN lhs . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## lhs ELTTIMESASSIGN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed phrase. Found L-value ".*=" expression. There are many ways in which this can be completed to a valid phrase.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN REALNUMERAL BAR IDENTIFIER RBRACK
##
## Concrete syntax: transformed data { foo ( 3.1415 | foo ]
##
## Ends in an error in state: 259.
##
## common_expression -> identifier LPAREN non_lhs BAR loption(separated_nonempty_list(COMMA,expression)) . RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN non_lhs BAR loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
## In state 255, spurious reduction of production separated_nonempty_list(COMMA,expression) -> lhs
## In state 146, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

Ill-formed conditional distribution evaluation. Expect comma-separated list of expressions followed by ")" after "|".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN REALNUMERAL BAR WHILE
##
## Concrete syntax: transformed data { foo ( 3.1415 | while
##
## Ends in an error in state: 258.
##
## common_expression -> identifier LPAREN non_lhs BAR . loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN non_lhs BAR
##

Ill-formed conditional distribution evaluation. Expect comma-separated list of expressions followed by ")" after "|".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN RPAREN WHILE
##
## Concrete syntax: transformed data { foo ( ) while
##
## Ends in an error in state: 553.
##
## atomic_statement -> identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## common_expression -> identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN . [ TRANSPOSE TIMES TILDE RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN
##

Ill-formed phrase. Found a well-formed function application. After this, there are many legal completions of the phrase.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN IDENTIFIER BAR IDENTIFIER RBRACK
##
## Concrete syntax: transformed data { foo ( foo | foo ]
##
## Ends in an error in state: 265.
##
## common_expression -> identifier LPAREN lhs BAR loption(separated_nonempty_list(COMMA,expression)) . RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN lhs BAR loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
## In state 255, spurious reduction of production separated_nonempty_list(COMMA,expression) -> lhs
## In state 146, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

Ill-formed conditional distribution evaluation. Expect comma-separated list of expressions followed by ")" after "|".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN IDENTIFIER BAR WHILE
##
## Concrete syntax: transformed data { foo ( foo | while
##
## Ends in an error in state: 264.
##
## common_expression -> identifier LPAREN lhs BAR . loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN lhs BAR
##

Ill-formed conditional distribution evaluation. Expect comma-separated list of expressions followed by ")" after "|".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN DOTNUMERAL TILDE
## Concrete syntax: transformed data { foo ( .2 ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN IDENTIFIER COMMA IDENTIFIER RBRACK
##
## Concrete syntax: transformed data { foo ( foo , foo ]
##
## Ends in an error in state: 552.
##
## atomic_statement -> identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) . RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## common_expression -> identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) . RPAREN [ TRANSPOSE TIMES TILDE RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
## In state 255, spurious reduction of production separated_nonempty_list(COMMA,expression) -> lhs
## In state 257, spurious reduction of production separated_nonempty_list(COMMA,expression) -> lhs COMMA separated_nonempty_list(COMMA,expression)
## In state 146, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

Ill-formed function application. Expect comma-separated list of expressions followed by ")" after "(".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { foo ( foo ~
##
## Ends in an error in state: 263.
##
## common_expression -> identifier LPAREN lhs . BAR loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA BAR AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA BAR AND ]
## separated_nonempty_list(COMMA,expression) -> lhs . [ RPAREN ]
## separated_nonempty_list(COMMA,expression) -> lhs . COMMA separated_nonempty_list(COMMA,expression) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed function application. Expect comma-separated list of expressions followed by ")" after "(".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN WHILE
##
## Concrete syntax: transformed data { foo ( while
##
## Ends in an error in state: 551.
##
## atomic_statement -> identifier LPAREN . loption(separated_nonempty_list(COMMA,expression)) RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## common_expression -> identifier LPAREN . loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## common_expression -> identifier LPAREN . lhs BAR loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## common_expression -> identifier LPAREN . non_lhs BAR loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN
##

Ill-formed function application. Expect comma-separated list of expressions followed by ")" after "(".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER MINUSASSIGN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { foo -= foo ~
##
## Ends in an error in state: 523.
##
## atomic_statement -> lhs MINUSASSIGN lhs . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## lhs MINUSASSIGN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed phrase. Found L-value "-=" expression. There are many ways in which this can be completed to a valid phrase.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER MINUSASSIGN WHILE
##
## Concrete syntax: transformed data { foo -= while
##
## Ends in an error in state: 520.
##
## atomic_statement -> lhs MINUSASSIGN . lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs MINUSASSIGN . non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs MINUSASSIGN
##

Ill-formed expression. Found L-value "-=". Expect an expression followed by ";" next.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER PLUSASSIGN DOTNUMERAL TILDE
## Concrete syntax: transformed data { foo += .2 ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER PLUSASSIGN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { foo += foo ~
##
## Ends in an error in state: 518.
##
## atomic_statement -> lhs PLUSASSIGN lhs . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## lhs PLUSASSIGN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed phrase. Found L-value "+=" expression. There are many ways in which this can be completed to a valid phrase.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER PLUSASSIGN WHILE
##
## Concrete syntax: transformed data { foo += while
##
## Ends in an error in state: 515.
##
## atomic_statement -> lhs PLUSASSIGN . lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs PLUSASSIGN . non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs PLUSASSIGN
##

Ill-formed expression. Found L-value "+=". Expect an expression followed by ";" next.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER RBRACE
##
## Concrete syntax: transformed data { foo }
##
## Ends in an error in state: 502.
##
## atomic_statement -> lhs . ASSIGN lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . ASSIGN non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . ARROWASSIGN lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . ARROWASSIGN non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . PLUSASSIGN lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . PLUSASSIGN non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . MINUSASSIGN lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . MINUSASSIGN non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . TIMESASSIGN lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . TIMESASSIGN non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . DIVIDEASSIGN lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . DIVIDEASSIGN non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . ELTTIMESASSIGN lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . ELTTIMESASSIGN non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . ELTDIVIDEASSIGN lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . ELTDIVIDEASSIGN non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs . TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMESASSIGN TIMES TILDE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE ASSIGN ARROWASSIGN AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMESASSIGN TIMES TILDE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE ASSIGN ARROWASSIGN AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES TILDE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 550, spurious reduction of production lhs -> identifier
##

Ill-formed phrase. Found L-value. This can be completed in many ways.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK COMMA RBRACK MULTIPLIER
##
## Concrete syntax: transformed data { foo ~ foo ( ) T [ , ] multiplier
##
## Ends in an error in state: 513.
##
## atomic_statement -> lhs TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation) . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation)
##

Ill-formed "~"-statement. Expected ";".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TILDE IDENTIFIER LPAREN RPAREN WHILE
##
## Concrete syntax: transformed data { foo ~ foo ( ) while
##
## Ends in an error in state: 512.
##
## atomic_statement -> lhs TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN . option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN
##

Ill-formed "~"-statement. Expected ";" or "T[" optional expression "," optional expression "];".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TILDE IDENTIFIER LPAREN IDENTIFIER RBRACK
##
## Concrete syntax: transformed data { foo ~ foo ( foo ]
##
## Ends in an error in state: 511.
##
## atomic_statement -> lhs TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) . RPAREN option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
## In state 255, spurious reduction of production separated_nonempty_list(COMMA,expression) -> lhs
## In state 146, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

Ill-formed "~"-statement. Expected "," or ")".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TILDE IDENTIFIER LPAREN WHILE
##
## Concrete syntax: transformed data { foo ~ foo ( while
##
## Ends in an error in state: 510.
##
## atomic_statement -> lhs TILDE identifier LPAREN . loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs TILDE identifier LPAREN
##

Ill-formed "~"-statement. Expected comma-separated list of expressions followed by ")".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TILDE IDENTIFIER WHILE
##
## Concrete syntax: transformed data { foo ~ foo while
##
## Ends in an error in state: 509.
##
## atomic_statement -> lhs TILDE identifier . LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs TILDE identifier
##

Ill-formed "~"-statement. Expected "(" followed by a comma-separated list of expressions followed by ")" after distribution name.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TILDE WHILE
##
## Concrete syntax: transformed data { foo ~ while
##
## Ends in an error in state: 508.
##
## atomic_statement -> lhs TILDE . identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs TILDE
##

Ill-formed "~"-statement. Expected identifier for distribution name after "~".

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TIMESASSIGN DOTNUMERAL TILDE
## Concrete syntax: transformed data { foo *= .2 ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TIMESASSIGN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { foo *= foo ~
##
## Ends in an error in state: 506.
##
## atomic_statement -> lhs TIMESASSIGN lhs . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## lhs -> lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## lhs -> lhs . DOTNUMERAL [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . PLUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MINUS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . DIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . MODULO non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . HAT non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . ELTPOW non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . OR non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . AND non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . EQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . NEQUALS non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . LEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . RABRACK non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . GEQ non_lhs [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## non_lhs -> lhs . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## lhs TIMESASSIGN lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
##

Ill-formed phrase. Found L-value "*=" expression. There are many ways in which this can be completed to a valid phrase.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TIMESASSIGN WHILE
##
## Concrete syntax: transformed data { foo *= while
##
## Ends in an error in state: 503.
##
## atomic_statement -> lhs TIMESASSIGN . lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> lhs TIMESASSIGN . non_lhs SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## lhs TIMESASSIGN
##

Ill-formed expression. Found L-value "*=". Expect an expression followed by ";" next.

program: TRANSFORMEDDATABLOCK LBRACE VECTOR LBRACK INTNUMERAL RBRACK HAT
##
## Concrete syntax: transformed data { vector [ 24 ] ^
##
## Ends in an error in state: 873.
##
## decl(top_var_type,expression) -> top_var_type . decl_identifier dims optional_assignment(expression) SEMICOLON [ WHILE VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## decl(top_var_type,expression) -> top_var_type . id_and_optional_assignment(expression,decl_identifier) option(remaining_declarations(expression)) SEMICOLON [ WHILE VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## top_var_type
##

Ill-formed top-level variable declaration. Expect an identifier next.

program: TRANSFORMEDDATABLOCK LBRACE VOID
##
## Concrete syntax: transformed data { void
##
## Ends in an error in state: 867.
##
## transformed_data_block -> TRANSFORMEDDATABLOCK LBRACE . list(top_vardecl_or_statement) RBRACE [ TRANSFORMEDPARAMETERSBLOCK PARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## TRANSFORMEDDATABLOCK LBRACE
##

Expect a statement or top-level variable declaration.

program: TRANSFORMEDDATABLOCK LBRACE WHILE LPAREN REALNUMERAL RPAREN VOID
##
## Concrete syntax: transformed data { while ( 3.1415 ) void
##
## Ends in an error in state: 307.
##
## nested_statement -> WHILE LPAREN non_lhs RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## WHILE LPAREN non_lhs RPAREN
##

Ill-formed statement. We expect a statement after ")", for the body of the while-loop.

program: TRANSFORMEDDATABLOCK LBRACE WHILE LPAREN IDENTIFIER RPAREN VOID
##
## Concrete syntax: transformed data { while ( foo ) void
##
## Ends in an error in state: 596.
##
## nested_statement -> WHILE LPAREN lhs RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## WHILE LPAREN lhs RPAREN
##

Ill-formed statement. We expect a statement after ")", for the body of the while-loop.

program: TRANSFORMEDDATABLOCK LBRACE WHILE LPAREN DOTNUMERAL TILDE
## Concrete syntax: transformed data { while ( .2 ~
program: TRANSFORMEDDATABLOCK LBRACE WHILE LPAREN IDENTIFIER TILDE
## Concrete syntax: transformed data { while ( foo ~
program: TRANSFORMEDDATABLOCK LBRACE WHILE LPAREN WHILE
##
## Concrete syntax: transformed data { while ( while
##
## Ends in an error in state: 94.
##
## nested_statement -> WHILE LPAREN . lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> WHILE LPAREN . non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## WHILE LPAREN
##

Ill-formed expression. We expect an expression after "(" for the test of a while-loop.

program: TRANSFORMEDDATABLOCK LBRACE WHILE WHILE
##
## Concrete syntax: transformed data { while while
##
## Ends in an error in state: 93.
##
## nested_statement -> WHILE . LPAREN lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> WHILE . LPAREN non_lhs RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## WHILE
##

After "while", we expect "(" expression ")" statement.

program: TRANSFORMEDDATABLOCK WHILE
##
## Concrete syntax: transformed data while
##
## Ends in an error in state: 866.
##
## transformed_data_block -> TRANSFORMEDDATABLOCK . LBRACE list(top_vardecl_or_statement) RBRACE [ TRANSFORMEDPARAMETERSBLOCK PARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## TRANSFORMEDDATABLOCK
##

We expect "{" after "transformed data".

program: TRANSFORMEDPARAMETERSBLOCK LBRACE RBRACE ELTTIMESASSIGN
##
## Concrete syntax: transformed parameters { } .*=
##
## Ends in an error in state: 904.
##
## program -> option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) . option(model_block) option(generated_quantities_block) EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block)
##

"model {" or "generated quantities {" expected after end of transformed parameters block.

program: TRANSFORMEDPARAMETERSBLOCK LBRACE VOID
##
## Concrete syntax: transformed parameters { void
##
## Ends in an error in state: 900.
##
## transformed_parameters_block -> TRANSFORMEDPARAMETERSBLOCK LBRACE . list(top_vardecl_or_statement) RBRACE [ MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## TRANSFORMEDPARAMETERSBLOCK LBRACE
##

Expect a statement or top-level variable declaration.

program: TRANSFORMEDPARAMETERSBLOCK WHILE
##
## Concrete syntax: transformed parameters while
##
## Ends in an error in state: 899.
##
## transformed_parameters_block -> TRANSFORMEDPARAMETERSBLOCK . LBRACE list(top_vardecl_or_statement) RBRACE [ MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## TRANSFORMEDPARAMETERSBLOCK
##

We expect "{" after "transformed parameters".

program: MODELBLOCK LBRACE REAL IDENTIFIER LBRACK IDENTIFIER RBRACK ARROWASSIGN
##
## Concrete syntax: model { real foo [ foo ] <-
##
## Ends in an error in state: 481.
##
## decl(sized_basic_type,expression) -> sized_basic_type decl_identifier dims . optional_assignment(expression) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## sized_basic_type decl_identifier dims
##

Expected  ";" or assignment.

program: TRANSFORMEDDATABLOCK LBRACE REAL IDENTIFIER LBRACK IDENTIFIER RBRACK ARROWASSIGN
##
## Concrete syntax: transformed data { real foo [ foo ] <-
##
## Ends in an error in state: 878.
##
## decl(top_var_type,expression) -> top_var_type decl_identifier dims . optional_assignment(expression) SEMICOLON [ WHILE VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## top_var_type decl_identifier dims
##

Expected  ";" or assignment.

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER COMMA WHILE
##
## Concrete syntax: data { vector < upper = foo , while
##
## Ends in an error in state: 656.
##
## range -> UPPER ASSIGN constr_expression COMMA . LOWER ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## UPPER ASSIGN constr_expression COMMA
##

'>' or lower expression expected after upper expression.

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER COMMA LOWER WHILE
##
## Concrete syntax: data { vector < upper = foo , lower while
##
## Ends in an error in state: 657.
##
## range -> UPPER ASSIGN constr_expression COMMA LOWER . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## UPPER ASSIGN constr_expression COMMA LOWER
##

'=' expected after 'upper' keyword.

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER COMMA LOWER ASSIGN WHILE
##
## Concrete syntax: data { vector < upper = foo , lower = while
##
## Ends in an error in state: 658.
##
## range -> UPPER ASSIGN constr_expression COMMA LOWER ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## UPPER ASSIGN constr_expression COMMA LOWER ASSIGN
##

Numerical expression expected after '=' in a lower expression.

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER COMMA LOWER ASSIGN IDENTIFIER COMMA
##
## Concrete syntax: data { vector < upper = foo , lower = foo ,
##
## Ends in an error in state: 659.
##
## constr_expression -> constr_expression . PLUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MINUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . DIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . IDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MODULO constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . LDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTTIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . HAT constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTPOW constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TRANSPOSE [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . LBRACK indexes RBRACK [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## range -> UPPER ASSIGN constr_expression COMMA LOWER ASSIGN constr_expression . [ RABRACK ]
##
## The known suffix of the stack is as follows:
## UPPER ASSIGN constr_expression COMMA LOWER ASSIGN constr_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 623, spurious reduction of production constr_expression -> identifier
##

Expected '>' after lower expression.

program: DATABLOCK LBRACE ROWVECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < multiplier = foo ' while
program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER COMMA WHILE
##
## Concrete syntax: data { vector < multiplier = foo , while
##
## Ends in an error in state: 670.
##
## offset_mult -> MULTIPLIER ASSIGN constr_expression COMMA . OFFSET ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## MULTIPLIER ASSIGN constr_expression COMMA
##

Expected '>' or offset expression after multiplier expression.

program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER COMMA OFFSET WHILE
##
## Concrete syntax: data { vector < multiplier = foo , offset while
##
## Ends in an error in state: 671.
##
## offset_mult -> MULTIPLIER ASSIGN constr_expression COMMA OFFSET . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## MULTIPLIER ASSIGN constr_expression COMMA OFFSET
##

'=' expected after 'multiplier' keyword.

program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER COMMA OFFSET ASSIGN WHILE
##
## Concrete syntax: data { vector < multiplier = foo , offset = while
##
## Ends in an error in state: 672.
##
## offset_mult -> MULTIPLIER ASSIGN constr_expression COMMA OFFSET ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## MULTIPLIER ASSIGN constr_expression COMMA OFFSET ASSIGN
##

Numerical expression expected after '=' in a multiplier expression.

program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER COMMA OFFSET ASSIGN IDENTIFIER COMMA
##
## Concrete syntax: data { vector < multiplier = foo , offset = foo ,
##
## Ends in an error in state: 673.
##
## constr_expression -> constr_expression . PLUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MINUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . DIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . IDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MODULO constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . LDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTTIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . HAT constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTPOW constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TRANSPOSE [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . LBRACK indexes RBRACK [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## offset_mult -> MULTIPLIER ASSIGN constr_expression COMMA OFFSET ASSIGN constr_expression . [ RABRACK ]
##
## The known suffix of the stack is as follows:
## MULTIPLIER ASSIGN constr_expression COMMA OFFSET ASSIGN constr_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 623, spurious reduction of production constr_expression -> identifier
##

Expected '>' after multiplier expression.

program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN IDENTIFIER RPAREN SEMICOLON UNREACHABLE
##
## Concrete syntax: transformed data { if ( foo ) ; <<<<UNREACHABLE>>>
##
## Ends in an error in state: 583.
##
## nested_statement -> IF LPAREN lhs RPAREN vardecl_or_statement . ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF LPAREN lhs RPAREN vardecl_or_statement . [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF LPAREN lhs RPAREN vardecl_or_statement
##

'if (cond)' should be followed by '{' and statements to execute if true.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LBRACK WHILE
##
## Concrete syntax: transformed data { foo [ while
##
## Ends in an error in state: 126.
##
## lhs -> lhs LBRACK . indexes RBRACK [ TRANSPOSE TIMESASSIGN TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA COLON BAR ASSIGN ARROWASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lhs LBRACK
##

Expected an expression inside "[" and "]" but found a statement. Indexing should look like
  var[1 + i]
not
  var[for (n in 1:N) ...]

program: DATABLOCK LBRACE ARRAY LBRACK IDENTIFIER RBRACK REAL WHILE ASSIGN UNREACHABLE WHILE
## Concrete syntax: data { array [ foo ] real while = <<<<UNREACHABLE>>> while
program: DATABLOCK LBRACE REAL WHILE COMMA WHILE ASSIGN UNREACHABLE WHILE
## Concrete syntax: data { real while , while = <<<<UNREACHABLE>>> while
program: DATABLOCK LBRACE TUPLE LPAREN COMPLEX COMMA COMPLEX RPAREN WHILE ASSIGN UNREACHABLE WHILE
## Concrete syntax: data { tuple ( complex , complex ) while = <<<<UNREACHABLE>>> while
program: DATABLOCK LBRACE REAL IDENTIFIER ASSIGN WHILE
## Concrete syntax: data { real foo = while
program: DATABLOCK LBRACE REAL IDENTIFIER ASSIGN UNREACHABLE WHILE
## Concrete syntax: data { real foo = <<<<UNREACHABLE>>> while
program: DATABLOCK LBRACE REAL IDENTIFIER LBRACK IDENTIFIER RBRACK ASSIGN UNREACHABLE WHILE
##
## Concrete syntax: data { real foo [ foo ] = <<<<UNREACHABLE>>> while
##
## Ends in an error in state: 854.
##
## decl(top_var_type,no_assign) -> top_var_type decl_identifier dims optional_assignment(no_assign) . SEMICOLON [ VECTOR UNITVECTOR TUPLE SIMPLEX SEMICOLON ROWVECTOR REAL RBRACE POSITIVEORDERED ORDERED MATRIX INT COVMATRIX CORRMATRIX COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR ARRAY ]
##
## The known suffix of the stack is as follows:
## top_var_type decl_identifier dims optional_assignment(no_assign)
##

Cannot assign to variables in the `data` or `parameters` blocks; expected ';'
after variable declaration.

program: MODELBLOCK LBRACE REAL IDENTIFIER COMMA INT WHILE
## Concrete syntax: model { real foo , int while
program: DATABLOCK LBRACE REAL IDENTIFIER COMMA INT WHILE
## Concrete syntax: data { real foo , int while
program: DATABLOCK LBRACE REAL IDENTIFIER COMMA UNREACHABLE
## Concrete syntax: data { real foo , <<<<UNREACHABLE>>>
program: MODELBLOCK LBRACE REAL IDENTIFIER COMMA UNREACHABLE
##
## Concrete syntax: model { real foo , <<<<UNREACHABLE>>>
##
## Ends in an error in state: 454.
##
## remaining_declarations(expression) -> COMMA . separated_nonempty_list(COMMA,id_and_optional_assignment(expression,decl_identifier_after_comma)) [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## COMMA
##

Expected a new identifier after comma in declaration.
All variables declared must be of the same type, and any initializing assignment must follow the identifier before the next comma.

program: TRANSFORMEDDATABLOCK LBRACE REAL IDENTIFIER LBRACK IDENTIFIER RBRACK ASSIGN IDENTIFIER COMMA
## Concrete syntax: transformed data { real foo [ foo ] = foo ,
program: MODELBLOCK LBRACE REAL IDENTIFIER LBRACK IDENTIFIER RBRACK ASSIGN IDENTIFIER COMMA
##
## Concrete syntax: model { real foo [ foo ] = foo ,
##
## Ends in an error in state: 482.
##
## decl(sized_basic_type,expression) -> sized_basic_type decl_identifier dims optional_assignment(expression) . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## sized_basic_type decl_identifier dims optional_assignment(expression)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production lhs -> identifier
## In state 464, spurious reduction of production option(pair(ASSIGN,expression)) -> ASSIGN lhs
## In state 466, spurious reduction of production optional_assignment(expression) -> option(pair(ASSIGN,expression))
##

Multiple declarations are not allowed when array dimensions are given in TYPE IDENTIFIER[DIMENSIONS] form.
When all declarations share array dimensions, use 'array[DIMENSIONS] TYPE IDENTIFIER' form, otherwise use separate declarations.

program: TRANSFORMEDDATABLOCK LBRACE PROFILE WHILE
##
## Concrete syntax: transformed data { profile while
##
## Ends in an error in state: 417.
##
## nested_statement -> PROFILE . LPAREN string_literal RPAREN LBRACE list(vardecl_or_statement) RBRACE [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PROFILE
##

Expected profile name as string in parenthesis

program: TRANSFORMEDDATABLOCK LBRACE PROFILE LPAREN WHILE
##
## Concrete syntax: transformed data { profile ( while
##
## Ends in an error in state: 418.
##
## nested_statement -> PROFILE LPAREN . string_literal RPAREN LBRACE list(vardecl_or_statement) RBRACE [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PROFILE LPAREN
##

Expected profile name as string in parenthesis


program: TRANSFORMEDDATABLOCK LBRACE PROFILE LPAREN STRINGLITERAL WHILE
##
## Concrete syntax: transformed data { profile ( "hello world" while
##
## Ends in an error in state: 419.
##
## nested_statement -> PROFILE LPAREN string_literal . RPAREN LBRACE list(vardecl_or_statement) RBRACE [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PROFILE LPAREN string_literal
##

Expected ")" after profile name.

program: TRANSFORMEDDATABLOCK LBRACE PROFILE LPAREN STRINGLITERAL RPAREN WHILE
##
## Concrete syntax: transformed data { profile ( "hello world" ) while
##
## Ends in an error in state: 420.
##
## nested_statement -> PROFILE LPAREN string_literal RPAREN . LBRACE list(vardecl_or_statement) RBRACE [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PROFILE LPAREN string_literal RPAREN
##

Expected "{" after profile definition.

program: TRANSFORMEDDATABLOCK LBRACE PROFILE LPAREN STRINGLITERAL RPAREN LBRACE VOID
##
## Concrete syntax: transformed data { profile ( "hello world" ) { void
##
## Ends in an error in state: 421.
##
## nested_statement -> PROFILE LPAREN string_literal RPAREN LBRACE . list(vardecl_or_statement) RBRACE [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PROFILE LPAREN string_literal RPAREN LBRACE
##

Ill-formed phrase. "{" should be followed by a statement, variable declaration or expression.


program: DATABLOCK LBRACE COMPLEX UNREACHABLE
##
## Concrete syntax: data { complex <<<<UNREACHABLE>>>
##
## Ends in an error in state: 786.
##
## top_var_type -> COMPLEX . type_constraint [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## COMPLEX
##

Expected identifier as part of top-level variable declaration.


functions_only: WHILE
##
## Concrete syntax: while
##
## Ends in an error in state: 0.
##
## functions_only' -> . functions_only [ # ]
##
## The known suffix of the stack is as follows:
##
##

Function definitions/declarations expected in '.stanfunctions' file

functions_only: VOID ARRAY LPAREN RPAREN SEMICOLON RBRACE
##
## Concrete syntax: void array ( ) ; }
##
## Ends in an error in state: 602.
##
## functions_only -> list(function_def) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## list(function_def)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 605, spurious reduction of production list(function_def) ->
## In state 606, spurious reduction of production list(function_def) -> function_def list(function_def)
##

Only function definitions/declarations are expected in '.stanfunctions' file

functions_only: ARRAY IDENTIFIER
## Concrete syntax: array foo
program: TRANSFORMEDDATABLOCK LBRACE ARRAY IDENTIFIER
##
## Concrete syntax: transformed data { array foo
##
## Ends in an error in state: 365.
##
## arr_dims -> ARRAY . LBRACK separated_nonempty_list(COMMA,expression) RBRACK [ VECTOR UNITVECTOR TUPLE SIMPLEX ROWVECTOR REAL POSITIVEORDERED ORDERED MATRIX INT COVMATRIX CORRMATRIX COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR ]
##
## The known suffix of the stack is as follows:
## ARRAY
##

Expected "[" array sizes "]" followed by type after "array".


program: TRANSFORMEDDATABLOCK LBRACE ARRAY LBRACK IDENTIFIER RBRACK VECTOR LBRACK IMAGNUMERAL RBRACK AND
## Concrete syntax: transformed data { array [ foo ] vector [ 1i ] &&
program: MODELBLOCK LBRACE ARRAY LBRACK IDENTIFIER RBRACK REAL UNREACHABLE
## Concrete syntax: model { array [ foo ] real <<<<UNREACHABLE>>>
program: DATABLOCK LBRACE ARRAY LBRACK IDENTIFIER RBRACK VECTOR LBRACK INTNUMERAL RBRACK AND
##
## Concrete syntax: data { array [ foo ] vector [ 24 ] &&
##
## Ends in an error in state: 859.
##
## decl(top_var_type,no_assign) -> array_type(top_var_type) . id_and_optional_assignment(no_assign,decl_identifier) option(remaining_declarations(no_assign)) SEMICOLON [ VECTOR UNITVECTOR TUPLE SIMPLEX SEMICOLON ROWVECTOR REAL RBRACE POSITIVEORDERED ORDERED MATRIX INT COVMATRIX CORRMATRIX COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR ARRAY ]
##
## The known suffix of the stack is as follows:
## array_type(top_var_type)
##

Expected identifier after type in declaration.

program: TRANSFORMEDDATABLOCK LBRACE LBRACE IDENTIFIER DOTNUMERAL WHILE
## Concrete syntax: transformed data { { foo .2 while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER WHILE
##
## Concrete syntax: transformed data { foo while
##
## Ends in an error in state: 550.
##
## atomic_statement -> identifier . LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## common_expression -> identifier . LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## common_expression -> identifier . LPAREN lhs BAR loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## common_expression -> identifier . LPAREN non_lhs BAR loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TRANSPOSE TIMES TILDE RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA AND ]
## lhs -> identifier . [ TRANSPOSE TIMESASSIGN TIMES TILDE RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA ASSIGN ARROWASSIGN AND ]
##
## The known suffix of the stack is as follows:
## identifier
##

Ill-formed statement or expression. A statement or expression could be expected here.

program: MODELBLOCK LBRACE TUPLE LPAREN ARRAY LBRACK IDENTIFIER RBRACK REAL COMMA WHILE
## Concrete syntax: model { tuple ( array [ foo ] real , while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA REAL COMMA WHILE
## Concrete syntax: model { tuple ( real , real , while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA REAL COMMA WHILE
## Concrete syntax: data { tuple ( real , real , while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA TUPLE LPAREN COMPLEX COMMA COMPLEX RPAREN COMMA WHILE
## Concrete syntax: model { tuple ( real , tuple ( complex , complex ) , while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA TUPLE LPAREN COMPLEX COMMA COMPLEX RPAREN COMMA WHILE
## Concrete syntax: data { tuple ( real , tuple ( complex , complex ) , while
program: MODELBLOCK LBRACE TUPLE LPAREN TUPLE LPAREN REAL COMMA COMPLEX RPAREN COMMA WHILE
## Concrete syntax: model { tuple ( tuple ( real , complex ) , while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA ARRAY LBRACK IDENTIFIER RBRACK REAL COMMA WHILE
## Concrete syntax: model { tuple ( real , array [ foo ] real , while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA ARRAY LBRACK IDENTIFIER RBRACK REAL COMMA WHILE
## Concrete syntax: data { tuple ( real , array [ foo ] real , while
program: DATABLOCK LBRACE TUPLE LPAREN TUPLE LPAREN REAL COMMA COMPLEX RPAREN COMMA WHILE
## Concrete syntax: data { tuple ( tuple ( real , complex ) , while
program: DATABLOCK LBRACE TUPLE LPAREN ARRAY LBRACK IDENTIFIER RBRACK REAL COMMA WHILE
## Concrete syntax: data { tuple ( array [ foo ] real , while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA WHILE
## Concrete syntax: model { tuple ( real , while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA WHILE
##
## Concrete syntax: data { tuple ( real , while
##
## Ends in an error in state: 822.
##
## tuple_type(top_var_type) -> TUPLE LPAREN top_var_type COMMA . separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## TUPLE LPAREN top_var_type COMMA
##

Incomplete type specification, expected further types followed by ")" to complete tuple.

program: MODELBLOCK LBRACE TUPLE LPAREN TUPLE LPAREN REAL COMMA COMPLEX RPAREN WHILE
## Concrete syntax: model { tuple ( tuple ( real , complex ) while
program: MODELBLOCK LBRACE TUPLE LPAREN ARRAY LBRACK IDENTIFIER RBRACK REAL WHILE
## Concrete syntax: model { tuple ( array [ foo ] real while
program: DATABLOCK LBRACE TUPLE LPAREN TUPLE LPAREN REAL COMMA COMPLEX RPAREN WHILE
## Concrete syntax: data { tuple ( tuple ( real , complex ) while
program: DATABLOCK LBRACE TUPLE LPAREN ARRAY LBRACK IDENTIFIER RBRACK REAL IDENTIFIER
## Concrete syntax: data { tuple ( array [ foo ] real foo
program: MODELBLOCK LBRACE TUPLE LPAREN REAL WHILE
## Concrete syntax: model { tuple ( real while
program: DATABLOCK LBRACE TUPLE LPAREN REAL WHILE
##
## Concrete syntax: data { tuple ( real while
##
## Ends in an error in state: 821.
##
## tuple_type(top_var_type) -> TUPLE LPAREN top_var_type . COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## TUPLE LPAREN top_var_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 713, spurious reduction of production range_constraint ->
## In state 691, spurious reduction of production type_constraint -> range_constraint
## In state 714, spurious reduction of production top_var_type -> REAL type_constraint
##

Invalid type specification, unmatched "(".
Expected "," followed by further types and ")" to complete tuple.

program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA ARRAY LBRACK IDENTIFIER RBRACK REAL WHILE
## Concrete syntax: model { tuple ( real , array [ foo ] real while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA ARRAY LBRACK IDENTIFIER RBRACK REAL WHILE
## Concrete syntax: data { tuple ( real , array [ foo ] real while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA REAL WHILE
## Concrete syntax: model { tuple ( real , real while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA REAL WHILE
## Concrete syntax: data { tuple ( real , real while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA TUPLE LPAREN COMPLEX COMMA COMPLEX RPAREN WHILE
## Concrete syntax: model { tuple ( real , tuple ( complex , complex ) while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA TUPLE LPAREN COMPLEX COMMA COMPLEX RPAREN WHILE
##
## Concrete syntax: data { tuple ( real , tuple ( complex , complex ) while
##
## Ends in an error in state: 807.
##
## separated_nonempty_list(COMMA,higher_type(top_var_type)) -> tuple_type(top_var_type) . [ RPAREN ]
## separated_nonempty_list(COMMA,higher_type(top_var_type)) -> tuple_type(top_var_type) . COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## tuple_type(top_var_type)
##

Incomplete type specification. Expected either ")" or "," followed by
further types and ")" to complete tuple.

program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA TUPLE LPAREN WHILE
## Concrete syntax: model { tuple ( real , tuple ( while
program: DATABLOCK LBRACE TUPLE LPAREN WHILE
##
## Concrete syntax: data { tuple ( while
##
## Ends in an error in state: 699.
##
## tuple_type(top_var_type) -> TUPLE LPAREN . array_type(top_var_type) COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## tuple_type(top_var_type) -> TUPLE LPAREN . tuple_type(top_var_type) COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## tuple_type(top_var_type) -> TUPLE LPAREN . top_var_type COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## TUPLE LPAREN
##

Incomplete type declaration. Expected comma separated list of types between "("
and ")" to declare tuple variable.

program: TRANSFORMEDDATABLOCK LBRACE LBRACE DOTNUMERAL SEMICOLON
## Concrete syntax: transformed data { { .2 ;
program: TRANSFORMEDDATABLOCK LBRACE LBRACK DOTNUMERAL TILDE
##
## Concrete syntax: transformed data { [ .2 ~
##
## Ends in an error in state: 254.
##
## non_lhs -> non_lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . PLUS lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . PLUS non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . MINUS lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . MINUS non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . TIMES lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . TIMES non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . DIVIDE lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . IDIVIDE lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . MODULO lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . MODULO non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LDIVIDE lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTTIMES lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . HAT lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . HAT non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTPOW lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . OR lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . OR non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . AND lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . AND non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . EQUALS lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . EQUALS non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . NEQUALS lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LABRACK lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LABRACK non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LEQ lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LEQ non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . RABRACK lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . RABRACK non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . GEQ lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . GEQ non_lhs [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . TRANSPOSE [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## separated_nonempty_list(COMMA,expression) -> non_lhs . [ RPAREN RBRACK RBRACE ]
## separated_nonempty_list(COMMA,expression) -> non_lhs . COMMA separated_nonempty_list(COMMA,expression) [ RPAREN RBRACK RBRACE ]
##
## The known suffix of the stack is as follows:
## non_lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 162, spurious reduction of production non_lhs -> common_expression
##

Ill-formed phrase. Found an expression. This can be followed by a ",", a "}", a ")", a "]", a "[" or an infix or postfix operator.

program: TRANSFORMEDDATABLOCK LBRACE RETURN LPAREN WHILE
## Concrete syntax: transformed data { return ( while
program: TRANSFORMEDDATABLOCK LBRACE LPAREN DOTNUMERAL COMMA WHILE
## Concrete syntax: transformed data { ( .2 , while
program: TRANSFORMEDDATABLOCK LBRACE LPAREN DOTNUMERAL COMMA IDENTIFIER RBRACK
## Concrete syntax: transformed data { ( .2 , foo ]
program: TRANSFORMEDDATABLOCK LBRACE LPAREN DOTNUMERAL TILDE
## Concrete syntax: transformed data { ( .2 ~
program: TRANSFORMEDDATABLOCK LBRACE LPAREN IDENTIFIER COMMA WHILE
##
## Concrete syntax: transformed data { ( foo , while
##
## Ends in an error in state: 299.
##
## common_expression -> LPAREN lhs COMMA . separated_nonempty_list(COMMA,expression) RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN lhs COMMA
##

Expression or comma separated list of expressions followed by ")" expected after "(".

program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL LBRACK DOTNUMERAL COLON DOTNUMERAL TILDE
## Concrete syntax: transformed data { .2 [ .2 : .2 ~
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL LBRACK DOTNUMERAL TILDE
## Concrete syntax: transformed data { .2 [ .2 ~
program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL LBRACK IDENTIFIER COLON DOTNUMERAL TILDE
##
## Concrete syntax: transformed data { .2 [ foo : .2 ~
##
## Ends in an error in state: 275.
##
## indexes -> lhs COLON non_lhs . [ RBRACK COMMA ]
## non_lhs -> non_lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . PLUS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . PLUS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . MINUS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . MINUS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . TIMES lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . TIMES non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . DIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . IDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . MODULO lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . MODULO non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTTIMES lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . HAT lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . HAT non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTPOW lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . OR lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . OR non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . AND lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . AND non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . EQUALS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . EQUALS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . NEQUALS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LABRACK lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LABRACK non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LEQ lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LEQ non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . RABRACK lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . RABRACK non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . GEQ lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . GEQ non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . TRANSPOSE [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## lhs COLON non_lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 162, spurious reduction of production non_lhs -> common_expression
##

Found an ill-formed expression where we expected a statement. Did you forget to close your "["?

program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK DOTNUMERAL TILDE
##
## Concrete syntax: transformed data { .2 ~ foo ( ) T [ .2 ~
##
## Ends in an error in state: 496.
##
## non_lhs -> non_lhs . QMARK lhs COLON lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . QMARK lhs COLON non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . QMARK non_lhs COLON lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . QMARK non_lhs COLON non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . PLUS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . PLUS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . MINUS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . MINUS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . TIMES lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . TIMES non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . DIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . DIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . IDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . IDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . MODULO lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . MODULO non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTTIMES lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTTIMES non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTDIVIDE lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTDIVIDE non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . HAT lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . HAT non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTPOW lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . ELTPOW non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . OR lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . OR non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . AND lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . AND non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . EQUALS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . EQUALS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . NEQUALS lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . NEQUALS non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LABRACK lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LABRACK non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LEQ lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LEQ non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . RABRACK lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . RABRACK non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . GEQ lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . GEQ non_lhs [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . TRANSPOSE [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## non_lhs -> non_lhs . LBRACK indexes RBRACK [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## option(expression) -> non_lhs . [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## non_lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 162, spurious reduction of production non_lhs -> common_expression
##

Ill-formed expression. Found an expression. Expect a infix or postfix operator or "[" or "]" or "," next.

functions_only: ARRAY LBRACK RBRACK TUPLE LPAREN VECTOR COMMA WHILE
## Concrete syntax: array [ ] tuple ( vector , while
functions_only: ARRAY LBRACK RBRACK TUPLE LPAREN VECTOR WHILE
## Concrete syntax: array [ ] tuple ( vector while
functions_only: TUPLE LPAREN VECTOR COMMA VECTOR WHILE
## Concrete syntax: tuple ( vector , vector while
functions_only: TUPLE LPAREN VECTOR WHILE
## Concrete syntax: tuple ( vector while
functions_only: TUPLE LPAREN VECTOR COMMA WHILE
## Concrete syntax: tuple ( vector , while
functions_only: TUPLE LPAREN WHILE
## Concrete syntax: tuple ( while
functions_only: TUPLE LPAREN VECTOR COMMA VECTOR COMMA WHILE
## Concrete syntax: tuple ( vector , vector , while
functions_only: ARRAY LBRACK RBRACK TUPLE LPAREN WHILE
##
## Concrete syntax: array [ ] tuple ( while
##
## Ends in an error in state: 21.
##
## unsized_type -> ARRAY unsized_dims TUPLE LPAREN . unsized_type COMMA separated_nonempty_list(COMMA,unsized_type) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## ARRAY unsized_dims TUPLE LPAREN
##

Expected comma-separated list of types followed by ")" to declare tuple type.

program: TRANSFORMEDDATABLOCK LBRACE DOTNUMERAL WHILE
##
## Concrete syntax: transformed data { .2 while
##
## Ends in an error in state: 162.
##
## common_expression -> common_expression . DOTNUMERAL [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## non_lhs -> common_expression . [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## common_expression
##

Ill-formed expression. Found part of an expression, expected either an operator or the end of the expression.

functions_only: ARRAY LBRACK RBRACK WHILE
## Concrete syntax: array [ ] while
program: MODELBLOCK LBRACE ARRAY LBRACK INTNUMERAL RBRACK IDENTIFIER
## Concrete syntax: model { array [ 24 ] foo
program: DATABLOCK LBRACE ARRAY LBRACK INTNUMERAL RBRACK IDENTIFIER
##
## Concrete syntax: data { array [ 24 ] foo
##
## Ends in an error in state: 815.
##
## array_type(top_var_type) -> arr_dims . top_var_type [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## array_type(top_var_type) -> arr_dims . tuple_type(top_var_type) [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## arr_dims
##

Expected non-array type after "array" declaration.

program: DATABLOCK LBRACE ARRAY LBRACK WHILE
##
## Concrete syntax: data { array [ while
##
## Ends in an error in state: 366.
##
## arr_dims -> ARRAY LBRACK . separated_nonempty_list(COMMA,expression) RBRACK [ VECTOR UNITVECTOR TUPLE SIMPLEX ROWVECTOR REAL POSITIVEORDERED ORDERED MATRIX INT COVMATRIX CORRMATRIX COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR ]
##
## The known suffix of the stack is as follows:
## ARRAY LBRACK
##

Expected expressions for size of array.

program: DATABLOCK LBRACE ROWVECTOR LABRACK LOWER ASSIGN IDENTIFIER TRANSPOSE WHILE
##
## Concrete syntax: data { row_vector < lower = foo ' while
##
## Ends in an error in state: 676.
##
## constr_expression -> constr_expression . PLUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> constr_expression . MINUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> constr_expression . TIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> constr_expression . DIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> constr_expression . IDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> constr_expression . MODULO constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> constr_expression . LDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> constr_expression . ELTTIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> constr_expression . ELTDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> constr_expression . HAT constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> constr_expression . ELTPOW constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> constr_expression . TRANSPOSE [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## constr_expression -> constr_expression . LBRACK indexes RBRACK [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE LBRACK IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
## range -> LOWER ASSIGN constr_expression . COMMA UPPER ASSIGN constr_expression [ RABRACK ]
## range -> LOWER ASSIGN constr_expression . [ RABRACK ]
##
## The known suffix of the stack is as follows:
## LOWER ASSIGN constr_expression
##

Expected ">" or ", upper = expression>" (with expression not containing binary logical operators) expected after specifying lower bound for type.

program: DATABLOCK LBRACE REAL WHILE COMMA WHILE COMMA UNREACHABLE
## Concrete syntax: data { real while , while , <<<<UNREACHABLE>>>
program: TRANSFORMEDDATABLOCK LBRACE TUPLE LPAREN REAL COMMA COMPLEX RPAREN UNREACHABLE
## Concrete syntax: transformed data { tuple ( real , complex ) <<<<UNREACHABLE>>>
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA COMPLEX RPAREN UNREACHABLE
## Concrete syntax: data { tuple ( real , complex ) <<<<UNREACHABLE>>>
program: MODELBLOCK LBRACE TUPLE LPAREN COMPLEX COMMA COMPLEX RPAREN UNREACHABLE
##
## Concrete syntax: model { tuple ( complex , complex ) <<<<UNREACHABLE>>>
##
## Ends in an error in state: 452.
##
## decl(sized_basic_type,expression) -> tuple_type(sized_basic_type) . id_and_optional_assignment(expression,decl_identifier) option(remaining_declarations(expression)) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## tuple_type(sized_basic_type)
##

Expected identifier as part of top-level variable declaration.

functions_only: ARRAY LBRACK RBRACK TUPLE WHILE
## Concrete syntax: array [ ] tuple while
functions_only: TUPLE WHILE
## Concrete syntax: tuple while
program: MODELBLOCK LBRACE TUPLE WHILE
## Concrete syntax: model { tuple while
program: DATABLOCK LBRACE TUPLE WHILE
##
## Concrete syntax: data { tuple while
##
## Ends in an error in state: 698.
##
## tuple_type(top_var_type) -> TUPLE . LPAREN array_type(top_var_type) COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## tuple_type(top_var_type) -> TUPLE . LPAREN tuple_type(top_var_type) COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## tuple_type(top_var_type) -> TUPLE . LPAREN top_var_type COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER INT IN IF IDENTIFIER GETLP FUNCTIONBLOCK FOR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## TUPLE
##

Invalid type specification.
Expected "(" followed by further types and ")" to complete tuple.

program: MODELBLOCK LBRACE REAL IDENTIFIER COMMA IDENTIFIER COMMA UNREACHABLE
## Concrete syntax: model { real foo , foo , <<<<UNREACHABLE>>>
program: TRANSFORMEDDATABLOCK LBRACE REAL WHILE IDENTIFIER
## Concrete syntax: transformed data { real while foo
program: TRANSFORMEDDATABLOCK LBRACE ARRAY LBRACK IDENTIFIER RBRACK REAL WHILE IDENTIFIER
## Concrete syntax: transformed data { array [ foo ] real while foo
program: MODELBLOCK LBRACE REAL IDENTIFIER IDENTIFIER
##
## Concrete syntax: model { real foo foo
##
## Ends in an error in state: 477.
##
## decl(sized_basic_type,expression) -> sized_basic_type decl_identifier . dims optional_assignment(expression) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE INTNUMERAL INT INCREMENTLOGPROB IMAGNUMERAL IF IDENTIFIER GETLP FOR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## id_and_optional_assignment(expression,decl_identifier) -> decl_identifier . optional_assignment(expression) [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## sized_basic_type decl_identifier
##

";" or plain assignment expected after variable declaration.

program: DATABLOCK LBRACE REAL IDENTIFIER LBRACK IDENTIFIER RBRACK IDENTIFIER
## Concrete syntax: data { real foo [ foo ] foo
program: DATABLOCK LBRACE REAL WHILE IDENTIFIER
## Concrete syntax: data { real while foo
program: DATABLOCK LBRACE ARRAY LBRACK IDENTIFIER RBRACK REAL IDENTIFIER IDENTIFIER
##
## Concrete syntax: data { array [ foo ] real foo foo
##
## Ends in an error in state: 846.
##
## id_and_optional_assignment(no_assign,decl_identifier) -> decl_identifier . optional_assignment(no_assign) [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## decl_identifier
##

";" expected after variable declaration.
