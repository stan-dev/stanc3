# This file is used by Menhir to generate error messages for bad
# parser states.
#
# It is highly recommended to read the Menhir manual, section 11.1:
#  https://gallium.inria.fr/~fpottier/menhir/manual.html#sec73
# Notably, each example program below is just that -- ONE example of a
# program ending in that state.
#
# When the parser is updated, the command `dune build @update_messages` will
# automatically update this file, leaving new placeholder messages for new states.
#
# The messages below can use formatting indicators like OCaml's format strings,
# with the additional use of semantic tags for colors and text styling.
# In short, @{<red>Text@} will be red, @{<b>This @{<green>Text@}@} will be bold,
# with the second word also being green, etc.
# As a general rule, we start each message with a short description in red. Quoted
# examples are in green, and non-quoted examples like 'expression' are italicized.
# See the `styled_text` function in Syntax_error.ml for how this is done and the full
# list of styles.
#
program: WHILE
##
## Concrete syntax: while
##
## Ends in an error in state: 407.
##
## program' -> . program [ # ]
##
## The known suffix of the stack is as follows:
##
##

@{<light_red>Ill-formed program.@} Expected @{<green>"functions {"@}, @{<green>"transformed data {"@}, @{<green>"parameters {"@},
@{<green>"transformed parameters {"@}, @{<green>"model {"@}, or @{<green>"generated quantities {"@}.

functions_only: WHILE
## Concrete syntax: while
functions_only: VOID IDENTIFIER LPAREN RPAREN SEMICOLON RBRACE
##
## Concrete syntax: void foo ( ) ; }
##
## Ends in an error in state: 402.
##
## functions_only -> list(function_def) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## list(function_def)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 405, spurious reduction of production list(function_def) ->
## In state 406, spurious reduction of production list(function_def) -> function_def list(function_def)
##

@{<light_red>Ill-formed program.@} Only function definitions/declarations are expected in @{<light_blue>'.stanfunctions'@} files.

program: FUNCTIONBLOCK LBRACE RBRACE COVMATRIX
##
## Concrete syntax: functions { } cov_matrix
##
## Ends in an error in state: 413.
##
## program -> option(function_block) . option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) option(model_block) option(generated_quantities_block) EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block)
##

@{<light_red>Ill-formed program.@} Expected @{<green>"data {"@}, @{<green>"transformed data {"@}, @{<green>"parameters {"@},
@{<green>"transformed parameters {"@}, @{<green>"model {"@}, @{<green>"generated quantities {"@}, or end-of-file.

program: DATABLOCK LBRACE RBRACE WHILE
##
## Concrete syntax: data { } while
##
## Ends in an error in state: 640.
##
## program -> option(function_block) option(data_block) . option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) option(model_block) option(generated_quantities_block) EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block) option(data_block)
##

@{<light_red>Ill-formed program.@} Expected @{<green>"transformed data {"@}, @{<green>"parameters {"@},
@{<green>"transformed parameters {"@}, @{<green>"model {"@}, @{<green>"generated quantities {"@}, or end-of-file.

program: TRANSFORMEDDATABLOCK LBRACE RBRACE ELTTIMESASSIGN
##
## Concrete syntax: transformed data { } .*=
##
## Ends in an error in state: 667.
##
## program -> option(function_block) option(data_block) option(transformed_data_block) . option(parameters_block) option(transformed_parameters_block) option(model_block) option(generated_quantities_block) EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block) option(data_block) option(transformed_data_block)
##

@{<light_red>Ill-formed program.@} Expected @{<green>"parameters {"@}, @{<green>"transformed parameters {"@},
@{<green>"model {"@}, @{<green>"generated quantities {"@}, or end-of-file.

program: PARAMETERSBLOCK LBRACE RBRACE ELTTIMESASSIGN
##
## Concrete syntax: parameters { } .*=
##
## Ends in an error in state: 673.
##
## program -> option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) . option(transformed_parameters_block) option(model_block) option(generated_quantities_block) EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block) option(data_block) option(transformed_data_block) option(parameters_block)
##

@{<light_red>Ill-formed program.@} Expected @{<green>"transformed parameters {"@}, @{<green>"model {"@} or @{<green>"generated quantities {"@} after end of parameters block.

program: TRANSFORMEDPARAMETERSBLOCK LBRACE RBRACE ELTTIMESASSIGN
##
## Concrete syntax: transformed parameters { } .*=
##
## Ends in an error in state: 679.
##
## program -> option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) . option(model_block) option(generated_quantities_block) EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block)
##

@{<light_red>Ill-formed program.@} Expected @{<green>"model {"@} or @{<green>"generated quantities {"@} after end of transformed parameters block.

program: MODELBLOCK LBRACE RBRACE ELTTIMESASSIGN
##
## Concrete syntax: model { } .*=
##
## Ends in an error in state: 684.
##
## program -> option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) option(model_block) . option(generated_quantities_block) EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) option(model_block)
##

@{<light_red>Ill-formed program.@} Expected @{<green>"generated quantities {"@} or end of file after end of model block.

program: GENERATEDQUANTITIESBLOCK LBRACE RBRACE ELTTIMESASSIGN
##
## Concrete syntax: generated quantities { } .*=
##
## Ends in an error in state: 689.
##
## program -> option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) option(model_block) option(generated_quantities_block) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(function_block) option(data_block) option(transformed_data_block) option(parameters_block) option(transformed_parameters_block) option(model_block) option(generated_quantities_block)
##

@{<light_red>Ill-formed program.@} Expected end of file after end of generated quantities block.

program: DATABLOCK LBRACE CHOLESKYFACTORCORR LBRACK IDENTIFIER TILDE
## Concrete syntax: data { cholesky_factor_corr [ foo ~
program: DATABLOCK LBRACE CHOLESKYFACTORCORR LBRACK WHILE
## Concrete syntax: data { cholesky_factor_corr [ while
program: DATABLOCK LBRACE CHOLESKYFACTORCORR WHILE
##
## Concrete syntax: data { cholesky_factor_corr while
##
## Ends in an error in state: 576.
##
## top_var_type -> CHOLESKYFACTORCORR . LBRACK expression RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## CHOLESKYFACTORCORR
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>"]"@} for size of cholesky_factor_corr.

program: DATABLOCK LBRACE CHOLESKYFACTORCOV LBRACK IDENTIFIER COMMA IDENTIFIER TILDE
## Concrete syntax: data { cholesky_factor_cov [ foo , foo ~
program: DATABLOCK LBRACE CHOLESKYFACTORCOV LBRACK IDENTIFIER COMMA WHILE
## Concrete syntax: data { cholesky_factor_cov [ foo , while
program: DATABLOCK LBRACE CHOLESKYFACTORCOV WHILE
## Concrete syntax: data { cholesky_factor_cov while
program: DATABLOCK LBRACE CHOLESKYFACTORCOV LBRACK IDENTIFIER TILDE
## Concrete syntax: data { cholesky_factor_cov [ foo ~
program: DATABLOCK LBRACE CHOLESKYFACTORCOV LBRACK WHILE
##
## Concrete syntax: data { cholesky_factor_cov [ while
##
## Ends in an error in state: 570.
##
## top_var_type -> CHOLESKYFACTORCOV LBRACK . expression option(pair(COMMA,expression)) RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## CHOLESKYFACTORCOV LBRACK
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>"]"@} or @{<green>"["@} @{<i>expression@} @{<green>","@} @{<i>expression@} @{<green>"]"@} for size of cholesky_factor_cov.

program: DATABLOCK LBRACE CORRMATRIX LBRACK IDENTIFIER TILDE
## Concrete syntax: data { corr_matrix [ foo ~
program: DATABLOCK LBRACE CORRMATRIX LBRACK WHILE
## Concrete syntax: data { corr_matrix [ while
program: DATABLOCK LBRACE CORRMATRIX WHILE
##
## Concrete syntax: data { corr_matrix while
##
## Ends in an error in state: 546.
##
## top_var_type -> CORRMATRIX . LBRACK expression RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## CORRMATRIX
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>"]"@} for size of corr_matrix.

program: DATABLOCK LBRACE COVMATRIX LBRACK IDENTIFIER TILDE
## Concrete syntax: data { cov_matrix [ foo ~
program: DATABLOCK LBRACE COVMATRIX LBRACK WHILE
## Concrete syntax: data { cov_matrix [ while
program: DATABLOCK LBRACE COVMATRIX WHILE
##
## Concrete syntax: data { cov_matrix while
##
## Ends in an error in state: 542.
##
## top_var_type -> COVMATRIX . LBRACK expression RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## COVMATRIX
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>"]"@} for size of cov_matrix.

program: DATABLOCK LBRACE STOCHASTICROWMATRIX WHILE
## Concrete syntax: data { row_stochastic_matrix while
program: DATABLOCK LBRACE STOCHASTICROWMATRIX LBRACK WHILE
## Concrete syntax: data { row_stochastic_matrix [ while
program: DATABLOCK LBRACE STOCHASTICROWMATRIX LBRACK IDENTIFIER TILDE
## Concrete syntax: data { row_stochastic_matrix [ foo ~
program: DATABLOCK LBRACE STOCHASTICROWMATRIX LBRACK IDENTIFIER COMMA WHILE
## Concrete syntax: data { row_stochastic_matrix [ foo , while
program: DATABLOCK LBRACE STOCHASTICROWMATRIX LBRACK IDENTIFIER COMMA IDENTIFIER TILDE
##
## Concrete syntax: data { row_stochastic_matrix [ foo , foo ~
##
## Ends in an error in state: 505.
##
## expression -> expression . QMARK expression COLON expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . PLUS expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MINUS expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TIMES expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . DIVIDE expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . IDIVIDE expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MODULO expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LDIVIDE expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTTIMES expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTDIVIDE expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . HAT expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTPOW expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . OR expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . AND expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . EQUALS expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . NEQUALS expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LABRACK expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LEQ expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . RABRACK expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . GEQ expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TRANSPOSE [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## top_var_type -> STOCHASTICROWMATRIX LBRACK expression COMMA expression . RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## STOCHASTICROWMATRIX LBRACK expression COMMA expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 127, spurious reduction of production expression -> common_expression
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>","@} @{<i>expression@} @{<green>"]"@} for size of row_stochastic_matrix.

program: DATABLOCK LBRACE STOCHASTICCOLUMNMATRIX WHILE
## Concrete syntax: data { column_stochastic_matrix while
program: DATABLOCK LBRACE STOCHASTICCOLUMNMATRIX LBRACK WHILE
## Concrete syntax: data { column_stochastic_matrix [ while
program: DATABLOCK LBRACE STOCHASTICCOLUMNMATRIX LBRACK IDENTIFIER TILDE
## Concrete syntax: data { column_stochastic_matrix [ foo ~
program: DATABLOCK LBRACE STOCHASTICCOLUMNMATRIX LBRACK IDENTIFIER COMMA WHILE
## Concrete syntax: data { column_stochastic_matrix [ foo , while
program: DATABLOCK LBRACE STOCHASTICCOLUMNMATRIX LBRACK IDENTIFIER COMMA IDENTIFIER TILDE
##
## Concrete syntax: data { column_stochastic_matrix [ foo , foo ~
##
## Ends in an error in state: 511.
##
## expression -> expression . QMARK expression COLON expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . PLUS expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MINUS expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TIMES expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . DIVIDE expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . IDIVIDE expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MODULO expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LDIVIDE expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTTIMES expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTDIVIDE expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . HAT expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTPOW expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . OR expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . AND expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . EQUALS expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . NEQUALS expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LABRACK expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LEQ expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . RABRACK expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . GEQ expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TRANSPOSE [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## top_var_type -> STOCHASTICCOLUMNMATRIX LBRACK expression COMMA expression . RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## STOCHASTICCOLUMNMATRIX LBRACK expression COMMA expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 127, spurious reduction of production expression -> common_expression
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>","@} @{<i>expression@} @{<green>"]"@} for size of column_stochastic_matrix.

program: DATABLOCK LBRACE SUMTOZEROVEC LBRACK IDENTIFIER TILDE
## Concrete syntax: data { sum_to_zero_vector [ foo ~
program: DATABLOCK LBRACE SUMTOZEROVEC LBRACK WHILE
## Concrete syntax: data { sum_to_zero_vector [ while
program: DATABLOCK LBRACE SUMTOZEROVEC WHILE
##
## Concrete syntax: data { sum_to_zero_vector while
##
## Ends in an error in state: 491.
##
## top_var_type -> SUMTOZEROVEC . LBRACK expression RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## SUMTOZEROVEC
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>"]"@} for size of sum_to_zero_vector.

program: DATABLOCK LBRACE SUMTOZEROMAT LBRACK WHILE
## Concrete syntax: data { sum_to_zero_matrix [ while
program: DATABLOCK LBRACE SUMTOZEROMAT WHILE
## Concrete syntax: data { sum_to_zero_matrix while
program: DATABLOCK LBRACE SUMTOZEROMAT LBRACK IDENTIFIER TILDE
## Concrete syntax: data { sum_to_zero_matrix [ foo ~
program: DATABLOCK LBRACE SUMTOZEROMAT LBRACK IDENTIFIER COMMA IDENTIFIER TILDE
## Concrete syntax: data { sum_to_zero_matrix [ foo , foo ~
program: DATABLOCK LBRACE SUMTOZEROMAT LBRACK IDENTIFIER COMMA WHILE
##
## Concrete syntax: data { sum_to_zero_matrix [ foo , while
##
## Ends in an error in state: 498.
##
## top_var_type -> SUMTOZEROMAT LBRACK expression COMMA . expression RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## SUMTOZEROMAT LBRACK expression COMMA
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>","@} @{<i>expression@} @{<green>"]"@} for size of sum_to_zero_matrix.

program: DATABLOCK LBRACE INT LABRACK WHILE
##
## Concrete syntax: data { int < while
##
## Ends in an error in state: 540.
##
## range_constraint -> LABRACK . range RABRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## LABRACK
##

@{<light_red>Ill-formed type.@} Expected @{<green>"lower = "@} @{<i>expression@} or @{<green>"upper = "@} @{<i>expression@} for integer bounds.

program: DATABLOCK LBRACE ORDERED LBRACK IDENTIFIER TILDE
## Concrete syntax: data { ordered [ foo ~
program: DATABLOCK LBRACE ORDERED LBRACK WHILE
## Concrete syntax: data { ordered [ while
program: DATABLOCK LBRACE ORDERED WHILE
##
## Concrete syntax: data { ordered while
##
## Ends in an error in state: 528.
##
## top_var_type -> ORDERED . LBRACK expression RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## ORDERED
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>"]"@} for size of ordered.

program: DATABLOCK LBRACE POSITIVEORDERED LBRACK IDENTIFIER TILDE
## Concrete syntax: data { positive_ordered [ foo ~
program: DATABLOCK LBRACE POSITIVEORDERED LBRACK WHILE
## Concrete syntax: data { positive_ordered [ while
program: DATABLOCK LBRACE POSITIVEORDERED WHILE
##
## Concrete syntax: data { positive_ordered while
##
## Ends in an error in state: 524.
##
## top_var_type -> POSITIVEORDERED . LBRACK expression RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## POSITIVEORDERED
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>"]"@} for size of positive_ordered.

program: DATABLOCK LBRACE REAL IDENTIFIER SEMICOLON WHILE
##
## Concrete syntax: data { real foo ; while
##
## Ends in an error in state: 631.
##
## list(top_var_decl_no_assign) -> top_var_decl_no_assign . list(top_var_decl_no_assign) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## top_var_decl_no_assign
##

@{<light_red>Ill-formed statement.@} Only top-level variable declarations are allowed in the @{<green>"data"@} and @{<green>"parameters"@} blocks.

program: DATABLOCK LBRACE REAL LBRACE
## Concrete syntax: data { real {
program: DATABLOCK LBRACE INT LBRACE
##
## Concrete syntax: data { int {
##
## Ends in an error in state: 539.
##
## top_var_type -> INT . range_constraint [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## INT
##

@{<light_red>Ill-formed declaration.@} Expected @{<green>"<"@} @{<i>constraint@} @{<green>">"@} or identifier next as part of top-level variable declaration.

program: DATABLOCK LBRACE SIMPLEX LBRACK IDENTIFIER TILDE
## Concrete syntax: data { simplex [ foo ~
program: DATABLOCK LBRACE SIMPLEX LBRACK WHILE
## Concrete syntax: data { simplex [ while
program: DATABLOCK LBRACE SIMPLEX WHILE
##
## Concrete syntax: data { simplex while
##
## Ends in an error in state: 513.
##
## top_var_type -> SIMPLEX . LBRACK expression RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## SIMPLEX
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>"]"@} for size of simplex.

program: DATABLOCK LBRACE UNITVECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: data { unit_vector [ foo ~
program: DATABLOCK LBRACE UNITVECTOR LBRACK WHILE
## Concrete syntax: data { unit_vector [ while
program: DATABLOCK LBRACE UNITVECTOR WHILE
##
## Concrete syntax: data { unit_vector while
##
## Ends in an error in state: 485.
##
## top_var_type -> UNITVECTOR . LBRACK expression RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## UNITVECTOR
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>"]"@} for size of unit_vector.

program: DATABLOCK LBRACE VECTOR LABRACK OFFSET ASSIGN IDENTIFIER COMMA MULTIPLIER ASSIGN IDENTIFIER COMMA
##
## Concrete syntax: data { vector < offset = foo , multiplier = foo ,
##
## Ends in an error in state: 461.
##
## constr_expression -> constr_expression . PLUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MINUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . DIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . IDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MODULO constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . LDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTTIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . HAT constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTPOW constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TRANSPOSE [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## offset_mult -> OFFSET ASSIGN constr_expression COMMA MULTIPLIER ASSIGN constr_expression . [ RABRACK ]
##
## The known suffix of the stack is as follows:
## OFFSET ASSIGN constr_expression COMMA MULTIPLIER ASSIGN constr_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 429, spurious reduction of production constr_expression -> common_expression
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>">"@} after @{<green>"multiplier = "@} @{<i>expression@}.

program: DATABLOCK LBRACE VECTOR LABRACK OFFSET ASSIGN IDENTIFIER COMMA MULTIPLIER WHILE
## Concrete syntax: data { vector < offset = foo , multiplier while
program: DATABLOCK LBRACE VECTOR LABRACK OFFSET ASSIGN IDENTIFIER COMMA MULTIPLIER ASSIGN WHILE
##
## Concrete syntax: data { vector < offset = foo , multiplier = while
##
## Ends in an error in state: 460.
##
## offset_mult -> OFFSET ASSIGN constr_expression COMMA MULTIPLIER ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## OFFSET ASSIGN constr_expression COMMA MULTIPLIER ASSIGN
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>"multiplier = "@} @{<i>expression@} (not containing binary logical operators).

program: DATABLOCK LBRACE ROWVECTOR LABRACK OFFSET ASSIGN IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < offset = foo ' while
program: DATABLOCK LBRACE VECTOR LABRACK OFFSET ASSIGN IDENTIFIER COMMA WHILE
##
## Concrete syntax: data { vector < offset = foo , while
##
## Ends in an error in state: 458.
##
## offset_mult -> OFFSET ASSIGN constr_expression COMMA . MULTIPLIER ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## OFFSET ASSIGN constr_expression COMMA
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>">"@} or @{<green>", multiplier = "@} @{<i>expression@}
(not containing binary logical operators) @{<green>">"@} after @{<green>"offset = "@} @{<i>expression@}.

program: DATABLOCK LBRACE VECTOR LABRACK OFFSET ASSIGN WHILE
## Concrete syntax: data { vector < offset = while
program: DATABLOCK LBRACE VECTOR LABRACK OFFSET WHILE
##
## Concrete syntax: data { vector < offset while
##
## Ends in an error in state: 455.
##
## offset_mult -> OFFSET . ASSIGN constr_expression COMMA MULTIPLIER ASSIGN constr_expression [ RABRACK ]
## offset_mult -> OFFSET . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## OFFSET
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>"offset = "@} @{<i>expression@} (not containing binary logical operators).

program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER DIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo / foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER ELTDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo ./ foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER ELTPOW IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo .^ foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER ELTTIMES IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo .* foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER HAT IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo ^ foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER IDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo %/% foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER LDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo \ foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER MINUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo - foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER MODULO IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo % foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER PLUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo + foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER TIMES IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo * foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN PLUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = + foo ' while
program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN MINUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = - foo ' while
program: DATABLOCK LBRACE VECTOR LABRACK LOWER ASSIGN IDENTIFIER COMMA UPPER ASSIGN IDENTIFIER COMMA
##
## Concrete syntax: data { vector < lower = foo , upper = foo ,
##
## Ends in an error in state: 475.
##
## constr_expression -> constr_expression . PLUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MINUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . DIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . IDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MODULO constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . LDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTTIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . HAT constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTPOW constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TRANSPOSE [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## range -> LOWER ASSIGN constr_expression COMMA UPPER ASSIGN constr_expression . [ RABRACK ]
##
## The known suffix of the stack is as follows:
## LOWER ASSIGN constr_expression COMMA UPPER ASSIGN constr_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 429, spurious reduction of production constr_expression -> common_expression
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>">"@} after @{<green>"upper = "@} @{<i>expression@}.

program: DATABLOCK LBRACE VECTOR LABRACK LOWER ASSIGN IDENTIFIER COMMA UPPER WHILE
##
## Concrete syntax: data { vector < lower = foo , upper while
##
## Ends in an error in state: 473.
##
## range -> LOWER ASSIGN constr_expression COMMA UPPER . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## LOWER ASSIGN constr_expression COMMA UPPER
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>"="@} @{<i>expression@}
(not containing binary logical operators) after @{<green>"upper"@}.

program: DATABLOCK LBRACE VECTOR LABRACK LOWER ASSIGN IDENTIFIER COMMA WHILE
##
## Concrete syntax: data { vector < lower = foo , while
##
## Ends in an error in state: 472.
##
## range -> LOWER ASSIGN constr_expression COMMA . UPPER ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## LOWER ASSIGN constr_expression COMMA
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>"upper ="@} @{<i>expression@} (not containing binary logical operators) @{<green>">"@}
after @{<green>"<lower ="@} @{<i>expression@} @{<green>","@} in top-level variable declaration.

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER COMMA WHILE
##
## Concrete syntax: data { vector < upper = foo , while
##
## Ends in an error in state: 451.
##
## range -> UPPER ASSIGN constr_expression COMMA . LOWER ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## UPPER ASSIGN constr_expression COMMA
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>"lower ="@} @{<i>expression@} (not containing binary logical operators) @{<green>">"@}
after @{<green>"<upper ="@} @{<i>expression@} @{<green>","@} in top-level variable declaration.

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER COMMA LOWER WHILE
##
## Concrete syntax: data { vector < upper = foo , lower while
##
## Ends in an error in state: 452.
##
## range -> UPPER ASSIGN constr_expression COMMA LOWER . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## UPPER ASSIGN constr_expression COMMA LOWER
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>"="@} @{<i>expression@}
(not containing binary logical operators) after @{<green>"lower"@}.

program: DATABLOCK LBRACE ROWVECTOR LABRACK LOWER ASSIGN IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < lower = foo ' while
program: DATABLOCK LBRACE VECTOR LABRACK LOWER ASSIGN WHILE
## Concrete syntax: data { vector < lower = while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER COMMA LOWER ASSIGN WHILE
##
## Concrete syntax: data { vector < upper = foo , lower = while
##
## Ends in an error in state: 453.
##
## range -> UPPER ASSIGN constr_expression COMMA LOWER ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## UPPER ASSIGN constr_expression COMMA LOWER ASSIGN
##

@{<light_red>Ill-formed constraint.@} Expected an expression (not containing binary logical operators)
after @{<green>"lower ="@}.

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER COMMA LOWER ASSIGN IDENTIFIER COMMA
##
## Concrete syntax: data { vector < upper = foo , lower = foo ,
##
## Ends in an error in state: 454.
##
## constr_expression -> constr_expression . PLUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MINUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . DIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . IDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MODULO constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . LDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTTIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . HAT constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTPOW constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TRANSPOSE [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## range -> UPPER ASSIGN constr_expression COMMA LOWER ASSIGN constr_expression . [ RABRACK ]
##
## The known suffix of the stack is as follows:
## UPPER ASSIGN constr_expression COMMA LOWER ASSIGN constr_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 429, spurious reduction of production constr_expression -> common_expression
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>">"@} after @{<green>"lower = "@} @{<i>expression@}.

program: DATABLOCK LBRACE ROWVECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < multiplier = foo ' while
program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER COMMA WHILE
##
## Concrete syntax: data { vector < multiplier = foo , while
##
## Ends in an error in state: 465.
##
## offset_mult -> MULTIPLIER ASSIGN constr_expression COMMA . OFFSET ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## MULTIPLIER ASSIGN constr_expression COMMA
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>">"@} or @{<green>", offset = "@} @{<i>expression@}
(not containing binary logical operators) @{<green>">"@} after @{<green>"multiplier = "@} @{<i>expression@}.

program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER COMMA OFFSET WHILE
##
## Concrete syntax: data { vector < multiplier = foo , offset while
##
## Ends in an error in state: 466.
##
## offset_mult -> MULTIPLIER ASSIGN constr_expression COMMA OFFSET . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## MULTIPLIER ASSIGN constr_expression COMMA OFFSET
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>"="@} @{<i>expression@}
(not containing binary logical operators) after @{<green>"offset"@}.

program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER COMMA OFFSET ASSIGN WHILE
##
## Concrete syntax: data { vector < multiplier = foo , offset = while
##
## Ends in an error in state: 467.
##
## offset_mult -> MULTIPLIER ASSIGN constr_expression COMMA OFFSET ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## MULTIPLIER ASSIGN constr_expression COMMA OFFSET ASSIGN
##

@{<light_red>Ill-formed constraint.@} Expected an expression (not containing binary logical operators)
after @{<green>"offset ="@}.

program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER COMMA OFFSET ASSIGN IDENTIFIER COMMA
##
## Concrete syntax: data { vector < multiplier = foo , offset = foo ,
##
## Ends in an error in state: 468.
##
## constr_expression -> constr_expression . PLUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MINUS constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . DIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . IDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . MODULO constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . LDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTTIMES constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTDIVIDE constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . HAT constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . ELTPOW constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## constr_expression -> constr_expression . TRANSPOSE [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE ]
## offset_mult -> MULTIPLIER ASSIGN constr_expression COMMA OFFSET ASSIGN constr_expression . [ RABRACK ]
##
## The known suffix of the stack is as follows:
## MULTIPLIER ASSIGN constr_expression COMMA OFFSET ASSIGN constr_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 429, spurious reduction of production constr_expression -> common_expression
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>">"@} after @{<green>"offset = "@} @{<i>expression@}.

program: DATABLOCK LBRACE VECTOR LABRACK LOWER WHILE
##
## Concrete syntax: data { vector < lower while
##
## Ends in an error in state: 469.
##
## range -> LOWER . ASSIGN constr_expression COMMA UPPER ASSIGN constr_expression [ RABRACK ]
## range -> LOWER . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## LOWER
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>"="@} @{<i>expression@}
(not containing binary logical operators) after @{<green>"lower"@}.

program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER ASSIGN WHILE
##
## Concrete syntax: data { vector < multiplier = while
##
## Ends in an error in state: 463.
##
## offset_mult -> MULTIPLIER ASSIGN . constr_expression COMMA OFFSET ASSIGN constr_expression [ RABRACK ]
## offset_mult -> MULTIPLIER ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## MULTIPLIER ASSIGN
##

@{<light_red>Ill-formed constraint.@} Expected and expression (not containing binary logical operators)
after @{<green>"multiplier ="@}.

program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER WHILE
##
## Concrete syntax: data { vector < multiplier while
##
## Ends in an error in state: 462.
##
## offset_mult -> MULTIPLIER . ASSIGN constr_expression COMMA OFFSET ASSIGN constr_expression [ RABRACK ]
## offset_mult -> MULTIPLIER . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## MULTIPLIER
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>"="@} @{<i>expression@}
(not containing binary logical operators) @{<green>">"@} after @{<green>"multiplier"@}.

program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN MINUS WHILE
## Concrete syntax: data { vector < upper = - while
program: DATABLOCK LBRACE VECTOR LABRACK OFFSET ASSIGN REALNUMERAL WHILE
## Concrete syntax: data { vector < offset = 3.1415 while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN BANG WHILE
## Concrete syntax: data { vector < upper = ! while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN PLUS WHILE
## Concrete syntax: data { vector < upper = + while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER DIVIDE WHILE
## Concrete syntax: data { vector < upper = foo / while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER ELTDIVIDE WHILE
## Concrete syntax: data { vector < upper = foo ./ while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER ELTTIMES WHILE
## Concrete syntax: data { vector < upper = foo .* while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER HAT WHILE
## Concrete syntax: data { vector < upper = foo ^ while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER LDIVIDE WHILE
## Concrete syntax: data { vector < upper = foo \ while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER MINUS WHILE
## Concrete syntax: data { vector < upper = foo - while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER MODULO WHILE
## Concrete syntax: data { vector < upper = foo % while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER PLUS WHILE
## Concrete syntax: data { vector < upper = foo + while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER TIMES WHILE
##
## Concrete syntax: data { vector < upper = foo * while
##
## Ends in an error in state: 433.
##
## constr_expression -> constr_expression TIMES . constr_expression [ TRANSPOSE TIMES RABRACK PLUS MODULO MINUS LDIVIDE IDIVIDE HAT ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA ]
##
## The known suffix of the stack is as follows:
## constr_expression TIMES
##

@{<light_red>Ill-formed constraint.@} Expected an expression (not containing binary logical operators).

program: DATABLOCK LBRACE ROWVECTOR LABRACK UPPER ASSIGN BANG IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: data { row_vector < upper = ! foo ' while
program: DATABLOCK LBRACE VECTOR LABRACK LOWER ASSIGN IDENTIFIER COMMA UPPER ASSIGN WHILE
## Concrete syntax: data { vector < lower = foo , upper = while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN WHILE
##
## Concrete syntax: data { vector < upper = while
##
## Ends in an error in state: 419.
##
## range -> UPPER ASSIGN . constr_expression COMMA LOWER ASSIGN constr_expression [ RABRACK ]
## range -> UPPER ASSIGN . constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## UPPER ASSIGN
##

@{<light_red>Ill-formed constraint.@} Expected an expression (not containing binary logical operators)
after @{<green>"upper ="@}.

program: DATABLOCK LBRACE VECTOR LABRACK UPPER WHILE
##
## Concrete syntax: data { vector < upper while
##
## Ends in an error in state: 418.
##
## range -> UPPER . ASSIGN constr_expression COMMA LOWER ASSIGN constr_expression [ RABRACK ]
## range -> UPPER . ASSIGN constr_expression [ RABRACK ]
##
## The known suffix of the stack is as follows:
## UPPER
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>"="@} @{<i>expression@} @{<green>">"@} after seeing @{<green>"upper"@}.

program: DATABLOCK LBRACE VECTOR LABRACK WHILE
##
## Concrete syntax: data { vector < while
##
## Ends in an error in state: 417.
##
## range_constraint -> LABRACK . range RABRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER LBRACK JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## type_constraint -> LABRACK . offset_mult RABRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER LBRACK JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## LABRACK
##

@{<light_red>Ill-formed constraint.@} Expected @{<green>"lower ="@}, @{<green>"upper ="@}, @{<green>"offset ="@} or @{<green>"multiplier ="@} followed by an expression after @{<green>"<"@}.

program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA COMPLEX RPAREN UNREACHABLE
## Concrete syntax: data { tuple ( real , complex ) <<<<UNREACHABLE>>>
program: DATABLOCK LBRACE ARRAY LBRACK IDENTIFIER RBRACK VECTOR LBRACK INTNUMERAL RBRACK AND
## Concrete syntax: data { array [ foo ] vector [ 24 ] &&
program: DATABLOCK LBRACE COMPLEX UNREACHABLE
## Concrete syntax: data { complex <<<<UNREACHABLE>>>
program: DATABLOCK LBRACE VECTOR LBRACK INTNUMERAL RBRACK HAT
##
## Concrete syntax: data { vector [ 24 ] ^
##
## Ends in an error in state: 623.
##
## decl(top_var_type,no_assign) -> top_var_type . decl_identifier LBRACK separated_nonempty_list(COMMA,expression) RBRACK [ VECTOR UNITVECTOR TUPLE SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR REAL RBRACE POSITIVEORDERED ORDERED MATRIX INT COVMATRIX CORRMATRIX COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR ARRAY ]
## decl(top_var_type,no_assign) -> top_var_type . id_and_optional_assignment(no_assign,decl_identifier) option(remaining_declarations(no_assign)) SEMICOLON [ VECTOR UNITVECTOR TUPLE SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR REAL RBRACE POSITIVEORDERED ORDERED MATRIX INT COVMATRIX CORRMATRIX COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR ARRAY ]
##
## The known suffix of the stack is as follows:
## top_var_type
##

@{<light_red>Ill-formed declaration.@} Expected identifier after type in variable declaration.

program: TRANSFORMEDDATABLOCK LBRACE TUPLE LPAREN REAL COMMA COMPLEX RPAREN UNREACHABLE
## Concrete syntax: transformed data { tuple ( real , complex ) <<<<UNREACHABLE>>>
program: MODELBLOCK LBRACE TUPLE LPAREN COMPLEX COMMA COMPLEX RPAREN UNREACHABLE
## Concrete syntax: model { tuple ( complex , complex ) <<<<UNREACHABLE>>>
program: TRANSFORMEDDATABLOCK LBRACE ARRAY LBRACK IDENTIFIER RBRACK VECTOR LBRACK IMAGNUMERAL RBRACK AND
## Concrete syntax: transformed data { array [ foo ] vector [ 1i ] &&
program: MODELBLOCK LBRACE ARRAY LBRACK IDENTIFIER RBRACK REAL UNREACHABLE
## Concrete syntax: model { array [ foo ] real <<<<UNREACHABLE>>>
program: TRANSFORMEDDATABLOCK LBRACE VECTOR LBRACK INTNUMERAL RBRACK HAT
##
## Concrete syntax: transformed data { vector [ 24 ] ^
##
## Ends in an error in state: 648.
##
## decl(top_var_type,expression) -> top_var_type . decl_identifier LBRACK separated_nonempty_list(COMMA,expression) RBRACK [ WHILE VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## decl(top_var_type,expression) -> top_var_type . id_and_optional_assignment(expression,decl_identifier) option(remaining_declarations(expression)) SEMICOLON [ WHILE VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## top_var_type
##

@{<light_red>Ill-formed declaration.@} Expected an identifier and optional assignment after type in variable declaration.

program: DATABLOCK LBRACE ARRAY LBRACK IDENTIFIER RBRACK REAL WHILE ASSIGN UNREACHABLE WHILE
## Concrete syntax: data { array [ foo ] real while = <<<<UNREACHABLE>>> while
program: DATABLOCK LBRACE REAL WHILE COMMA WHILE ASSIGN UNREACHABLE WHILE
## Concrete syntax: data { real while , while = <<<<UNREACHABLE>>> while
program: DATABLOCK LBRACE TUPLE LPAREN COMPLEX COMMA COMPLEX RPAREN WHILE ASSIGN UNREACHABLE WHILE
## Concrete syntax: data { tuple ( complex , complex ) while = <<<<UNREACHABLE>>> while
program: DATABLOCK LBRACE REAL IDENTIFIER ASSIGN WHILE
## Concrete syntax: data { real foo = while
program: DATABLOCK LBRACE REAL IDENTIFIER ASSIGN UNREACHABLE WHILE
##
## Concrete syntax: data { real foo = <<<<UNREACHABLE>>> while
##
## Ends in an error in state: 624.
##
## decl(top_var_type,no_assign) -> top_var_type id_and_optional_assignment(no_assign,decl_identifier) . option(remaining_declarations(no_assign)) SEMICOLON [ VECTOR UNITVECTOR TUPLE SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR REAL RBRACE POSITIVEORDERED ORDERED MATRIX INT COVMATRIX CORRMATRIX COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR ARRAY ]
##
## The known suffix of the stack is as follows:
## top_var_type id_and_optional_assignment(no_assign,decl_identifier)
##

@{<light_red>Ill-formed declaration.@} Cannot assign to variables in the @{<green>"data"@} or @{<green>"parameters"@} blocks.
Expected @{<green>";"@} after variable declaration.

program: DATABLOCK LBRACE REAL WHILE COMMA WHILE COMMA UNREACHABLE
## Concrete syntax: data { real while , while , <<<<UNREACHABLE>>>
program: MODELBLOCK LBRACE REAL IDENTIFIER COMMA INT WHILE
## Concrete syntax: model { real foo , int while
program: DATABLOCK LBRACE REAL IDENTIFIER COMMA INT WHILE
## Concrete syntax: data { real foo , int while
program: DATABLOCK LBRACE REAL IDENTIFIER COMMA UNREACHABLE
## Concrete syntax: data { real foo , <<<<UNREACHABLE>>>
program: MODELBLOCK LBRACE REAL IDENTIFIER COMMA UNREACHABLE
##
## Concrete syntax: model { real foo , <<<<UNREACHABLE>>>
##
## Ends in an error in state: 307.
##
## remaining_declarations(expression) -> COMMA . separated_nonempty_list(COMMA,id_and_optional_assignment(expression,decl_identifier_after_comma)) [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## COMMA
##

@{<light_red>Ill-formed declaration.@} Expected a new identifier after comma in declaration.
All variables declared must be of the same type, and any initializing assignment must follow the identifier before the next comma.

program: DATABLOCK LBRACE IDENTIFIER
##
## Concrete syntax: data { foo
##
## Ends in an error in state: 415.
##
## data_block -> DATABLOCK LBRACE . list(top_var_decl_no_assign) RBRACE [ TRANSFORMEDPARAMETERSBLOCK TRANSFORMEDDATABLOCK PARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## DATABLOCK LBRACE
##

@{<light_red>Invalid type in declaration.@} @{<blue>Valid types:@}
  int, real, vector, row_vector, matrix,
  unit_vector, simplex, sum_to_zero_vector, ordered, positive_ordered,
  corr_matrix, cov_matrix, cholesky_factor_corr, cholesky_factor_cov,
  sum_to_zero_matrix, row_stochastic_matrix, column_stochastic_matrix,
  tuple(@{<f>...@})
optionally preceded by a @{<u>single@} array[@{<f>...@}]

program: TRANSFORMEDDATABLOCK LBRACE COMPLEX IDENTIFIER WHILE
## Concrete syntax: transformed data { complex foo while
program: TRANSFORMEDDATABLOCK LBRACE ARRAY LBRACK IDENTIFIER RBRACK COMPLEX IDENTIFIER WHILE
## Concrete syntax: transformed data { array [ foo ] complex foo while
program: MODELBLOCK LBRACE REAL IDENTIFIER COMMA IDENTIFIER COMMA UNREACHABLE
## Concrete syntax: model { real foo , foo , <<<<UNREACHABLE>>>
program: MODELBLOCK LBRACE REAL IDENTIFIER IDENTIFIER
##
## Concrete syntax: model { real foo foo
##
## Ends in an error in state: 329.
##
## decl(sized_basic_type,expression) -> sized_basic_type decl_identifier . LBRACK separated_nonempty_list(COMMA,expression) RBRACK [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## id_and_optional_assignment(expression,decl_identifier) -> decl_identifier . optional_assignment(expression) [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## sized_basic_type decl_identifier
##

@{<light_red>Ill-formed declaration.@} Expected @{<green>";"@} or plain assignment after variable declaration.

program: DATABLOCK LBRACE ARRAY LBRACK IDENTIFIER RBRACK COMPLEX IDENTIFIER WHILE
## Concrete syntax: data { array [ foo ] complex foo while
program: DATABLOCK LBRACE REAL IDENTIFIER IDENTIFIER
##
## Concrete syntax: data { real foo foo
##
## Ends in an error in state: 627.
##
## decl(top_var_type,no_assign) -> top_var_type decl_identifier . LBRACK separated_nonempty_list(COMMA,expression) RBRACK [ VECTOR UNITVECTOR TUPLE SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR REAL RBRACE POSITIVEORDERED ORDERED MATRIX INT COVMATRIX CORRMATRIX COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR ARRAY ]
## id_and_optional_assignment(no_assign,decl_identifier) -> decl_identifier . optional_assignment(no_assign) [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## top_var_type decl_identifier
##

@{<light_red>Ill-formed declaration.@} Expected @{<green>";"@} after variable declaration.

program: DATABLOCK WHILE
##
## Concrete syntax: data while
##
## Ends in an error in state: 414.
##
## data_block -> DATABLOCK . LBRACE list(top_var_decl_no_assign) RBRACE [ TRANSFORMEDPARAMETERSBLOCK TRANSFORMEDDATABLOCK PARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## DATABLOCK
##

@{<light_red>Ill-formed block.@} Expected @{<green>"{"@} followed by a list of top-level variable declarations after @{<green>"data"@}.

program: FUNCTIONBLOCK LBRACE VOID WHILE LPAREN RPAREN SEMICOLON EOF
## Concrete syntax: functions { void while ( ) ; <EOF>
program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN RPAREN SEMICOLON WHILE
##
## Concrete syntax: functions { void foo ( ) ; while
##
## Ends in an error in state: 405.
##
## list(function_def) -> function_def . list(function_def) [ RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## function_def
##

@{<light_red>Ill-formed block.@} Expected a @{<green>"}"@} or a function definition or declaration.

functions_only: COMPLEX IDENTIFIER LPAREN COMPLEX RPAREN
## Concrete syntax: complex foo ( complex )
functions_only: COMPLEX IDENTIFIER LPAREN COMPLEX UNREACHABLE
##
## Concrete syntax: complex foo ( complex <<<<UNREACHABLE>>>
##
## Ends in an error in state: 27.
##
## unsized_type -> basic_type . unsized_dims [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## unsized_type -> basic_type . [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## basic_type
##

@{<light_red>Ill-formed function argument.@} Expected an identifier after the type for the function argument name.

program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN DATABLOCK WHILE
##
## Concrete syntax: functions { void foo ( data while
##
## Ends in an error in state: 92.
##
## arg_decl -> option(DATABLOCK) . unsized_type decl_identifier [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## option(DATABLOCK)
##

@{<light_red>Ill-formed function argument.@} Expected a type after the @{<green>"data"@} specifier.

program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN RPAREN VOID
##
## Concrete syntax: functions { void foo ( ) void
##
## Ends in an error in state: 96.
##
## function_def -> return_type decl_identifier LPAREN loption(separated_nonempty_list(COMMA,arg_decl)) RPAREN . statement [ VOID VECTOR TUPLE ROWVECTOR REAL RBRACE MATRIX INT EOF COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX ARRAY ]
##
## The known suffix of the stack is as follows:
## return_type decl_identifier LPAREN loption(separated_nonempty_list(COMMA,arg_decl)) RPAREN
##

@{<light_red>Ill-formed function.@} Expected either @{<green>"{"@} @{<i>statement@} @{<green>"}"@} for a function definition or @{<green>";"@} for a function forward declaration.

program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN WHILE
## Concrete syntax: functions { void foo ( while
program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN VECTOR IDENTIFIER COMMA WHILE
##
## Concrete syntax: functions { void foo ( vector foo , while
##
## Ends in an error in state: 400.
##
## separated_nonempty_list(COMMA,arg_decl) -> arg_decl COMMA . separated_nonempty_list(COMMA,arg_decl) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## arg_decl COMMA
##

@{<light_red>Ill-formed function argument.@} Expected an argument declaration (unsized and unconstrained type followed by identifier).

program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER LPAREN VECTOR IDENTIFIER WHILE
##
## Concrete syntax: functions { void foo ( vector foo while
##
## Ends in an error in state: 399.
##
## separated_nonempty_list(COMMA,arg_decl) -> arg_decl . [ RPAREN ]
## separated_nonempty_list(COMMA,arg_decl) -> arg_decl . COMMA separated_nonempty_list(COMMA,arg_decl) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## arg_decl
##

@{<light_red>Ill-formed function argument.@} Expected @{<green>","@} or @{<green>")"@} after function argument declaration.

program: FUNCTIONBLOCK LBRACE VOID IDENTIFIER WHILE
##
## Concrete syntax: functions { void foo while
##
## Ends in an error in state: 88.
##
## function_def -> return_type decl_identifier . LPAREN loption(separated_nonempty_list(COMMA,arg_decl)) RPAREN statement [ VOID VECTOR TUPLE ROWVECTOR REAL RBRACE MATRIX INT EOF COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX ARRAY ]
##
## The known suffix of the stack is as follows:
## return_type decl_identifier
##

@{<light_red>Ill-formed function.@} Expected @{<green>"("@} after function name.

program: FUNCTIONBLOCK LBRACE VOID LBRACK
##
## Concrete syntax: functions { void [
##
## Ends in an error in state: 37.
##
## function_def -> return_type . decl_identifier LPAREN loption(separated_nonempty_list(COMMA,arg_decl)) RPAREN statement [ VOID VECTOR TUPLE ROWVECTOR REAL RBRACE MATRIX INT EOF COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX ARRAY ]
##
## The known suffix of the stack is as follows:
## return_type
##

@{<light_red>Ill-formed function.@} Expected an identifier as a function name.

program: FUNCTIONBLOCK LBRACE WHILE
##
## Concrete syntax: functions { while
##
## Ends in an error in state: 409.
##
## function_block -> FUNCTIONBLOCK LBRACE . list(function_def) RBRACE [ TRANSFORMEDPARAMETERSBLOCK TRANSFORMEDDATABLOCK PARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF DATABLOCK ]
##
## The known suffix of the stack is as follows:
## FUNCTIONBLOCK LBRACE
##

@{<light_red>Ill-formed block.@} Expected a function forward declaration, definition, or @{<green>"}"@} after @{<green>"functions {"@}.

program: FUNCTIONBLOCK WHILE
##
## Concrete syntax: functions while
##
## Ends in an error in state: 408.
##
## function_block -> FUNCTIONBLOCK . LBRACE list(function_def) RBRACE [ TRANSFORMEDPARAMETERSBLOCK TRANSFORMEDDATABLOCK PARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF DATABLOCK ]
##
## The known suffix of the stack is as follows:
## FUNCTIONBLOCK
##

@{<light_red>Ill-formed block.@} Expected @{<green>"{"@} after @{<green>"functions"@}.

program: GENERATEDQUANTITIESBLOCK WHILE
##
## Concrete syntax: generated quantities while
##
## Ends in an error in state: 685.
##
## generated_quantities_block -> GENERATEDQUANTITIESBLOCK . LBRACE list(top_vardecl_or_statement) RBRACE [ EOF ]
##
## The known suffix of the stack is as follows:
## GENERATEDQUANTITIESBLOCK
##

@{<light_red>Ill-formed block.@} Expected @{<green>"{"@} after @{<green>"generated quantities"@}.

program: DATABLOCK LBRACE MATRIX LABRACK MULTIPLIER ASSIGN IDENTIFIER RABRACK WHILE
## Concrete syntax: data { matrix < multiplier = foo > while
program: DATABLOCK LBRACE MATRIX LBRACK IDENTIFIER COMMA IDENTIFIER TILDE
## Concrete syntax: data { matrix [ foo , foo ~
program: DATABLOCK LBRACE MATRIX LBRACK IDENTIFIER COMMA WHILE
## Concrete syntax: data { matrix [ foo , while
program: DATABLOCK LBRACE MATRIX LBRACK IDENTIFIER TILDE
## Concrete syntax: data { matrix [ foo ~
program: DATABLOCK LBRACE MATRIX LBRACK WHILE
## Concrete syntax: data { matrix [ while
program: DATABLOCK LBRACE MATRIX WHILE
## Concrete syntax: data { matrix while
program: DATABLOCK LBRACE COMPLEXMATRIX LABRACK OFFSET ASSIGN IDENTIFIER RABRACK WHILE
## Concrete syntax: data { complex_matrix < offset = foo > while
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL COMMA REALNUMERAL TILDE
## Concrete syntax: data { complex_matrix [ 3.1415 , 3.1415 ~
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL COMMA WHILE
## Concrete syntax: data { complex_matrix [ 3.1415 , while
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL TILDE
## Concrete syntax: data { complex_matrix [ 3.1415 ~
program: DATABLOCK LBRACE COMPLEXMATRIX LBRACK WHILE
## Concrete syntax: data { complex_matrix [ while
program: DATABLOCK LBRACE COMPLEXMATRIX WHILE
## Concrete syntax: data { complex_matrix while
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL COMMA REALNUMERAL TILDE
## Concrete syntax: model { complex_matrix [ 3.1415 , 3.1415 ~
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL COMMA WHILE
## Concrete syntax: model { complex_matrix [ 3.1415 , while
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK REALNUMERAL TILDE
## Concrete syntax: model { complex_matrix [ 3.1415 ~
program: MODELBLOCK LBRACE COMPLEXMATRIX LBRACK WHILE
## Concrete syntax: model { complex_matrix [ while
program: MODELBLOCK LBRACE COMPLEXMATRIX WHILE
## Concrete syntax: model { complex_matrix while
program: MODELBLOCK LBRACE MATRIX LBRACK REALNUMERAL COMMA IDENTIFIER TILDE
## Concrete syntax: model { matrix [ 3.1415 , foo ~
program: MODELBLOCK LBRACE MATRIX LBRACK REALNUMERAL COMMA WHILE
## Concrete syntax: model { matrix [ 3.1415 , while
program: MODELBLOCK LBRACE MATRIX LBRACK IDENTIFIER TILDE
## Concrete syntax: model { matrix [ foo ~
program: MODELBLOCK LBRACE MATRIX LBRACK WHILE
## Concrete syntax: model { matrix [ while
program: MODELBLOCK LBRACE MATRIX WHILE
##
## Concrete syntax: model { matrix while
##
## Ends in an error in state: 204.
##
## sized_basic_type -> MATRIX . LBRACK expression COMMA expression RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## MATRIX
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>","@} @{<i>expression@} @{<green>"]"@} for matrix sizes.

program: MODELBLOCK LBRACE REAL IDENTIFIER ASSIGN IDENTIFIER TILDE
## Concrete syntax: model { real foo = foo ~
program: MODELBLOCK LBRACE REAL IDENTIFIER ASSIGN WHILE
##
## Concrete syntax: model { real foo = while
##
## Ends in an error in state: 315.
##
## option(pair(ASSIGN,expression)) -> ASSIGN . expression [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## ASSIGN
##

@{<light_red>Ill-formed statement.@} Expected an expression followed by @{<green>";"@} after @{<green>"="@}.

program: MODELBLOCK LBRACE REAL LBRACK
##
## Concrete syntax: model { real [
##
## Ends in an error in state: 325.
##
## decl(sized_basic_type,expression) -> sized_basic_type . decl_identifier LBRACK separated_nonempty_list(COMMA,expression) RBRACK [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## decl(sized_basic_type,expression) -> sized_basic_type . id_and_optional_assignment(expression,decl_identifier) option(remaining_declarations(expression)) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## sized_basic_type
##

@{<light_red>Ill-formed declaration.@} Expected an identifier after sized type in local (or model block) variable declaration.
(No transformations/constraints allowed.)

program: DATABLOCK LBRACE ROWVECTOR LBRACK WHILE
## Concrete syntax: data { row_vector [ while
program: DATABLOCK LBRACE ROWVECTOR WHILE
## Concrete syntax: data { row_vector while
program: DATABLOCK LBRACE ROWVECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER RABRACK WHILE
## Concrete syntax: data { row_vector < multiplier = foo > while
program: DATABLOCK LBRACE COMPLEXROWVECTOR LABRACK OFFSET ASSIGN IDENTIFIER RABRACK WHILE
## Concrete syntax: data { complex_row_vector < offset = foo > while
program: DATABLOCK LBRACE COMPLEXROWVECTOR LBRACK REALNUMERAL TILDE
## Concrete syntax: data { complex_row_vector [ 3.1415 ~
program: DATABLOCK LBRACE COMPLEXROWVECTOR LBRACK WHILE
## Concrete syntax: data { complex_row_vector [ while
program: DATABLOCK LBRACE COMPLEXROWVECTOR WHILE
## Concrete syntax: data { complex_row_vector while
program: MODELBLOCK LBRACE COMPLEXROWVECTOR LBRACK REALNUMERAL TILDE
## Concrete syntax: model { complex_row_vector [ 3.1415 ~
program: MODELBLOCK LBRACE COMPLEXROWVECTOR LBRACK WHILE
## Concrete syntax: model { complex_row_vector [ while
program: MODELBLOCK LBRACE COMPLEXROWVECTOR WHILE
## Concrete syntax: model { complex_row_vector while
program: DATABLOCK LBRACE ROWVECTOR LBRACK DOTNUMERAL TILDE
## Concrete syntax: data { row_vector [ .2 ~
program: MODELBLOCK LBRACE ROWVECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: model { row_vector [ foo ~
program: MODELBLOCK LBRACE ROWVECTOR WHILE
## Concrete syntax: model { row_vector while
program: MODELBLOCK LBRACE ROWVECTOR LBRACK WHILE
##
## Concrete syntax: model { row_vector [ while
##
## Ends in an error in state: 200.
##
## sized_basic_type -> ROWVECTOR LBRACK . expression RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## ROWVECTOR LBRACK
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>"]"@} for row_vector size.

program: TRANSFORMEDDATABLOCK LBRACE PROFILE LPAREN STRINGLITERAL RPAREN LBRACE VOID
## Concrete syntax: transformed data { profile ( "hello world" ) { void
program: MODELBLOCK LBRACE VOID
## Concrete syntax: model { void
program: GENERATEDQUANTITIESBLOCK LBRACE VOID
## Concrete syntax: generated quantities { void
program: MODELBLOCK LBRACE SEMICOLON VOID
##
## Concrete syntax: model { ; void
##
## Ends in an error in state: 390.
##
## list(vardecl_or_statement) -> vardecl_or_statement . list(vardecl_or_statement) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## vardecl_or_statement
##

@{<light_red>Ill-formed block.@} Expected variable declaration, statement or @{<green>"}"@}.

program: DATABLOCK LBRACE COMPLEXVECTOR LABRACK OFFSET ASSIGN IDENTIFIER RABRACK WHILE
## Concrete syntax: data { complex_vector < offset = foo > while
program: DATABLOCK LBRACE COMPLEXVECTOR LBRACK REALNUMERAL TILDE
## Concrete syntax: data { complex_vector [ 3.1415 ~
program: DATABLOCK LBRACE COMPLEXVECTOR LBRACK WHILE
## Concrete syntax: data { complex_vector [ while
program: DATABLOCK LBRACE COMPLEXVECTOR WHILE
## Concrete syntax: data { complex_vector while
program: MODELBLOCK LBRACE COMPLEXVECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: model { complex_vector [ foo ~
program: DATABLOCK LBRACE VECTOR LABRACK MULTIPLIER ASSIGN IDENTIFIER RABRACK WHILE
## Concrete syntax: data { vector < multiplier = foo > while
program: DATABLOCK LBRACE VECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: data { vector [ foo ~
program: DATABLOCK LBRACE VECTOR LBRACK WHILE
## Concrete syntax: data { vector [ while
program: DATABLOCK LBRACE VECTOR WHILE
## Concrete syntax: data { vector while
program: MODELBLOCK LBRACE VECTOR LBRACK IDENTIFIER TILDE
## Concrete syntax: model { vector [ foo ~
program: MODELBLOCK LBRACE COMPLEXVECTOR LBRACK WHILE
## Concrete syntax: model { complex_vector [ while
program: MODELBLOCK LBRACE VECTOR LBRACK WHILE
## Concrete syntax: model { vector [ while
program: MODELBLOCK LBRACE COMPLEXVECTOR WHILE
## Concrete syntax: model { complex_vector while
program: MODELBLOCK LBRACE VECTOR WHILE
##
## Concrete syntax: model { vector while
##
## Ends in an error in state: 193.
##
## sized_basic_type -> VECTOR . LBRACK expression RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## VECTOR
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>expression@} @{<green>"]"@} for vector size.

program: MODELBLOCK WHILE
##
## Concrete syntax: model while
##
## Ends in an error in state: 680.
##
## model_block -> MODELBLOCK . LBRACE list(vardecl_or_statement) RBRACE [ GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## MODELBLOCK
##

@{<light_red>Ill-formed block.@} Expected @{<green>"{"@} after @{<green>"model"@}.

program: PARAMETERSBLOCK LBRACE WHILE
##
## Concrete syntax: parameters { while
##
## Ends in an error in state: 669.
##
## parameters_block -> PARAMETERSBLOCK LBRACE . list(top_var_decl_no_assign) RBRACE [ TRANSFORMEDPARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## PARAMETERSBLOCK LBRACE
##

@{<light_red>Ill-formed block.@} Expected top-level variable declaration or @{<green>"}"@}.

program: PARAMETERSBLOCK WHILE
##
## Concrete syntax: parameters while
##
## Ends in an error in state: 668.
##
## parameters_block -> PARAMETERSBLOCK . LBRACE list(top_var_decl_no_assign) RBRACE [ TRANSFORMEDPARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## PARAMETERSBLOCK
##

@{<light_red>Ill-formed block.@} Expected @{<green>"{"@} after @{<green>"parameters"@}.

program: TRANSFORMEDDATABLOCK LBRACE BANG IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { ! foo ' while
program: TRANSFORMEDDATABLOCK LBRACE BANG WHILE
##
## Concrete syntax: transformed data { ! while
##
## Ends in an error in state: 111.
##
## expression -> BANG . expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## BANG
##

@{<light_red>Ill-formed expression.@} Expected an expression after @{<green>"!"@}.

program: TRANSFORMEDDATABLOCK LBRACE BREAK WHILE
##
## Concrete syntax: transformed data { break while
##
## Ends in an error in state: 301.
##
## atomic_statement -> BREAK . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## BREAK
##

@{<light_red>Ill-formed statement.@} Expected @{<green>";"@} after @{<green>"break"@}.

program: TRANSFORMEDDATABLOCK LBRACE CONTINUE WHILE
##
## Concrete syntax: transformed data { continue while
##
## Ends in an error in state: 299.
##
## atomic_statement -> CONTINUE . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## CONTINUE
##

@{<light_red>Ill-formed statement.@} Expected @{<green>";"@} after @{<green>"continue"@}.

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN REALNUMERAL RPAREN VOID
## Concrete syntax: transformed data { for ( foo in 3.1415 ) void
program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN REALNUMERAL COLON IDENTIFIER RPAREN VOID
##
## Concrete syntax: transformed data { for ( foo in 3.1415 : foo ) void
##
## Ends in an error in state: 385.
##
## nested_statement -> FOR LPAREN identifier IN expression COLON expression RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN expression COLON expression RPAREN
##

@{<light_red>Ill-formed statement.@} Expected a statement after @{<green>")"@} for the loop body of the @{<green>"for"@} loop.

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN IDENTIFIER COLON DOTNUMERAL TILDE
## Concrete syntax: transformed data { for ( foo in foo : .2 ~
program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN REALNUMERAL COLON WHILE
##
## Concrete syntax: transformed data { for ( foo in 3.1415 : while
##
## Ends in an error in state: 383.
##
## nested_statement -> FOR LPAREN identifier IN expression COLON . expression RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN expression COLON
##

@{<light_red>Ill-formed expression.@} Expected an expression followed by @{<green>")"@} after @{<green>"for ("@} @{<i>identifier@} @{<green>"in"@} @{<i>expression@} @{<green>":"@}.

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN WHILE
## Concrete syntax: transformed data { for ( foo in while
program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER IN DOTNUMERAL TILDE
##
## Concrete syntax: transformed data { for ( foo in .2 ~
##
## Ends in an error in state: 292.
##
## expression -> expression . QMARK expression COLON expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . PLUS expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . MINUS expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . TIMES expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . DIVIDE expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . IDIVIDE expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . MODULO expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . LDIVIDE expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . ELTTIMES expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . ELTDIVIDE expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . HAT expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . ELTPOW expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . OR expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . AND expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . EQUALS expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . NEQUALS expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . LABRACK expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . LEQ expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . RABRACK expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . GEQ expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## expression -> expression . TRANSPOSE [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COLON AND ]
## nested_statement -> FOR LPAREN identifier IN expression . COLON expression RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier IN expression . RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier IN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production expression -> common_expression
##

@{<light_red>Ill-formed expression.@} Expected an expression followed by @{<green>")"@} or @{<green>":"@} after @{<green>"for ("@} @{<i>identifier@} @{<green>"in"@}.

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN IDENTIFIER WHILE
##
## Concrete syntax: transformed data { for ( foo while
##
## Ends in an error in state: 290.
##
## nested_statement -> FOR LPAREN identifier . IN expression COLON expression RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN identifier . IN expression RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN identifier
##

@{<light_red>Ill-formed statement.@} Expected @{<green>"in"@} after loop identifier.

program: TRANSFORMEDDATABLOCK LBRACE FOR LPAREN WHILE
##
## Concrete syntax: transformed data { for ( while
##
## Ends in an error in state: 289.
##
## nested_statement -> FOR LPAREN . identifier IN expression COLON expression RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR LPAREN . identifier IN expression RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR LPAREN
##

@{<light_red>Ill-formed statement.@} Expected (loop) identifier after @{<green>"("@}.

program: TRANSFORMEDDATABLOCK LBRACE FOR WHILE
##
## Concrete syntax: transformed data { for while
##
## Ends in an error in state: 288.
##
## nested_statement -> FOR . LPAREN identifier IN expression COLON expression RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> FOR . LPAREN identifier IN expression RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FOR
##

@{<light_red>Ill-formed statement.@} Expected @{<green>"("@} after @{<green>"for"@}.

program: TRANSFORMEDDATABLOCK LBRACE SEMICOLON VOID
## Concrete syntax: transformed data { ; void
program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN IDENTIFIER RPAREN SEMICOLON UNREACHABLE
##
## Concrete syntax: transformed data { if ( foo ) ; <<<<UNREACHABLE>>>
##
## Ends in an error in state: 387.
##
## nested_statement -> IF LPAREN expression RPAREN vardecl_or_statement . ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF LPAREN expression RPAREN vardecl_or_statement . [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF LPAREN expression RPAREN vardecl_or_statement
##

@{<light_red>Ill-formed block.@} Expected a statement, variable declaration, or just @{<green>"}"@}.

program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN REALNUMERAL RPAREN VOID
##
## Concrete syntax: transformed data { if ( 3.1415 ) void
##
## Ends in an error in state: 287.
##
## nested_statement -> IF LPAREN expression RPAREN . vardecl_or_statement ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF LPAREN expression RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF LPAREN expression RPAREN
##

@{<light_red>Ill-formed statement.@} Expected a statement for the true branch of conditional.

program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN IDENTIFIER RPAREN SEMICOLON ELSE VOID
##
## Concrete syntax: transformed data { if ( foo ) ; else void
##
## Ends in an error in state: 388.
##
## nested_statement -> IF LPAREN expression RPAREN vardecl_or_statement ELSE . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF LPAREN expression RPAREN vardecl_or_statement ELSE
##

@{<light_red>Ill-formed statement.@} Expected a statement after @{<green>"else"@}.

program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN IDENTIFIER LPAREN RPAREN TILDE
##
## Concrete syntax: transformed data { if ( foo ( ) ~
##
## Ends in an error in state: 286.
##
## expression -> expression . QMARK expression COLON expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . PLUS expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MINUS expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TIMES expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . DIVIDE expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . IDIVIDE expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MODULO expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LDIVIDE expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTTIMES expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTDIVIDE expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . HAT expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTPOW expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . OR expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . AND expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . EQUALS expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . NEQUALS expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LABRACK expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LEQ expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . RABRACK expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . GEQ expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TRANSPOSE [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## nested_statement -> IF LPAREN expression . RPAREN vardecl_or_statement ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF LPAREN expression . RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF LPAREN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production expression -> common_expression
##

@{<light_red>Ill-formed statement.@} Expected @{<green>"("@} @{<i>expression@} @{<green>")"@} for the test of the if statement.
A valid expression was found, but it was not followed by a closing parenthesis.

program: TRANSFORMEDDATABLOCK LBRACE IF WHILE
## Concrete syntax: transformed data { if while
program: TRANSFORMEDDATABLOCK LBRACE IF LPAREN WHILE
##
## Concrete syntax: transformed data { if ( while
##
## Ends in an error in state: 285.
##
## nested_statement -> IF LPAREN . expression RPAREN vardecl_or_statement ELSE vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## nested_statement -> IF LPAREN . expression RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## IF LPAREN
##

@{<light_red>Ill-formed statement.@} Expected @{<green>"("@} @{<i>expression@} @{<green>")"@} for the test of the if statement.

program: TRANSFORMEDDATABLOCK LBRACE LBRACE VOID
##
## Concrete syntax: transformed data { { void
##
## Ends in an error in state: 283.
##
## common_expression -> LBRACE . separated_nonempty_list(COMMA,expression) RBRACE [ TRANSPOSE TIMESASSIGN TIMES TILDE RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA ASSIGN AND ]
## nested_statement -> LBRACE . list(vardecl_or_statement) RBRACE [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

@{<light_red>Ill-formed block.@} Expected a statement, variable declaration, or just @{<green>"}"@} after @{<green>"{"@}.

program: TRANSFORMEDDATABLOCK LBRACE LBRACK IDENTIFIER COMMA WHILE
##
## Concrete syntax: transformed data { [ foo , while
##
## Ends in an error in state: 173.
##
## separated_nonempty_list(COMMA,expression) -> expression COMMA . separated_nonempty_list(COMMA,expression) [ RPAREN RBRACK RBRACE ]
##
## The known suffix of the stack is as follows:
## expression COMMA
##

@{<light_red>Ill-formed expression.@} Expected a comma separated list of expressions.

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK WHILE
## Concrete syntax: transformed data { 3.1415 [ while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK IDENTIFIER TILDE
## Concrete syntax: transformed data { 3.1415 [ foo ~
program: TRANSFORMEDDATABLOCK LBRACE LBRACK IDENTIFIER RPAREN
##
## Concrete syntax: transformed data { [ foo )
##
## Ends in an error in state: 182.
##
## common_expression -> LBRACK loption(separated_nonempty_list(COMMA,expression)) . RBRACK [ TRANSPOSE TIMESASSIGN TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA COLON BAR ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## LBRACK loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 127, spurious reduction of production expression -> common_expression
## In state 175, spurious reduction of production separated_nonempty_list(COMMA,expression) -> expression
## In state 114, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

@{<light_red>Ill-formed expression.@} Expected a comma separated list of expressions, followed by @{<green>"]"@}.

program: TRANSFORMEDDATABLOCK LBRACE LBRACK WHILE
##
## Concrete syntax: transformed data { [ while
##
## Ends in an error in state: 106.
##
## common_expression -> LBRACK . loption(separated_nonempty_list(COMMA,expression)) RBRACK [ TRANSPOSE TIMESASSIGN TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA COLON BAR ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## LBRACK
##

@{<light_red>Ill-formed expression.@} Expected a comma separated list of expressions followed by @{<green>"]"@} after @{<green>"["@}.

program: TRANSFORMEDDATABLOCK LBRACE LPAREN IDENTIFIER COMMA IDENTIFIER RBRACK
## Concrete syntax: transformed data { ( foo , foo ]
program: TRANSFORMEDDATABLOCK LBRACE LPAREN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { ( foo ~
##
## Ends in an error in state: 184.
##
## common_expression -> LPAREN expression . COMMA separated_nonempty_list(COMMA,expression) RPAREN [ TRANSPOSE TIMESASSIGN TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA COLON BAR ASSIGN AND ]
## common_expression -> LPAREN expression . RPAREN [ TRANSPOSE TIMESASSIGN TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA COLON BAR ASSIGN AND ]
## expression -> expression . QMARK expression COLON expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . PLUS expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . MINUS expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . TIMES expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . DIVIDE expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . IDIVIDE expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . MODULO expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . LDIVIDE expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . ELTTIMES expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . ELTDIVIDE expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . HAT expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . ELTPOW expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . OR expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . AND expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . EQUALS expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . NEQUALS expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . LABRACK expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . LEQ expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . RABRACK expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . GEQ expression [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . TRANSPOSE [ TRANSPOSE TIMES RPAREN RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 127, spurious reduction of production expression -> common_expression
##

@{<light_red>Ill-formed phrase.@} Found @{<green>"("@} followed by expression. Expected a @{<green>"["@}, @{<green>","@} or @{<green>")"@} or an infix or postfix operator.

program: TRANSFORMEDDATABLOCK LBRACE MINUS WHILE
##
## Concrete syntax: transformed data { - while
##
## Ends in an error in state: 104.
##
## expression -> MINUS . expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## MINUS
##

@{<light_red>Ill-formed expression.@} Expected an expression after @{<green>"-"@}.

program: TRANSFORMEDDATABLOCK LBRACE PLUS WHILE
##
## Concrete syntax: transformed data { + while
##
## Ends in an error in state: 103.
##
## expression -> PLUS . expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## PLUS
##

@{<light_red>Ill-formed expression.@} Expected an expression after @{<green>"+"@}.

program: TRANSFORMEDDATABLOCK LBRACE PRINT LPAREN IDENTIFIER RPAREN WHILE
##
## Concrete syntax: transformed data { print ( foo ) while
##
## Ends in an error in state: 281.
##
## atomic_statement -> PRINT LPAREN printables RPAREN . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PRINT LPAREN printables RPAREN
##

@{<light_red>Ill-formed statement.@} Expected a @{<green>";"@} after @{<green>"print(@{<r>@{<f>...@}@})"@}.

program: TRANSFORMEDDATABLOCK LBRACE PRINT LPAREN STRINGLITERAL WHILE
## Concrete syntax: transformed data { print ( "hello world" while
program: TRANSFORMEDDATABLOCK LBRACE PRINT LPAREN WHILE
##
## Concrete syntax: transformed data { print ( while
##
## Ends in an error in state: 279.
##
## atomic_statement -> PRINT LPAREN . printables RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PRINT LPAREN
##

@{<light_red>Ill-formed statement.@} Expected a comma separated list of expressions or
strings followed by @{<green>");"@} after @{<green>"print("@}.

program: TRANSFORMEDDATABLOCK LBRACE PRINT WHILE
##
## Concrete syntax: transformed data { print while
##
## Ends in an error in state: 278.
##
## atomic_statement -> PRINT . LPAREN printables RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PRINT
##

@{<light_red>Ill-formed statement.@} Expected @{<green>"("@} followed by a comma separated list of expressions or
strings followed by @{<green>");"@} after @{<green>"print"@}.

program: TRANSFORMEDDATABLOCK LBRACE RETURN LBRACE IDENTIFIER RPAREN
## Concrete syntax: transformed data { return { foo )
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER WHILE
## Concrete syntax: data { vector < upper = foo while
program: TRANSFORMEDDATABLOCK LBRACE LBRACK IDENTIFIER TILDE
## Concrete syntax: transformed data { [ foo ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER QMARK IDENTIFIER COLON IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo ? foo : foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER ELTPOW IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo .^ foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER ELTTIMES IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo .* foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER RABRACK IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo > foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER TIMES IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo * foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER EQUALS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo == foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER GEQ IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo >= foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER HAT IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo ^ foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER IDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo %/% foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER LDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo \ foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER LABRACK IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo < foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER LEQ IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo <= foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER ELTDIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo ./ foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER AND IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo && foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER MINUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo - foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER MODULO IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo % foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER NEQUALS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo != foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER OR IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo || foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER PLUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo + foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER DIVIDE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { foo = foo / foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER AND IDENTIFIER LBRACK RBRACK WHILE
##
## Concrete syntax: transformed data { foo = foo && foo [ ] while
##
## Ends in an error in state: 127.
##
## common_expression -> common_expression . DOTNUMERAL [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## common_expression -> common_expression . LBRACK indexes RBRACK [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
## expression -> common_expression . [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## common_expression
##

@{<light_red>Ill-formed expression.@} Unexpected input after the conclusion of a valid expression.
You may be missing a @{<green>","@} between expressions, an operator, or a terminating @{<green>"}"@}, @{<green>")"@}, @{<green>"]"@}, or @{<green>";"@}.

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LDIVIDE WHILE
## Concrete syntax: transformed data { 3.1415 \ while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL MINUS WHILE
## Concrete syntax: transformed data { 3.1415 - while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL PLUS WHILE
## Concrete syntax: transformed data { 3.1415 + while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL OR WHILE
## Concrete syntax: transformed data { 3.1415 || while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL NEQUALS WHILE
## Concrete syntax: transformed data { 3.1415 != while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL MODULO WHILE
## Concrete syntax: transformed data { 3.1415 % while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LEQ WHILE
## Concrete syntax: transformed data { 3.1415 <= while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL RABRACK WHILE
## Concrete syntax: transformed data { 3.1415 > while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TIMES WHILE
## Concrete syntax: transformed data { 3.1415 * while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER AND WHILE
## Concrete syntax: transformed data { foo && while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER DIVIDE WHILE
## Concrete syntax: transformed data { foo / while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTDIVIDE WHILE
## Concrete syntax: transformed data { foo ./ while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTTIMES WHILE
## Concrete syntax: transformed data { foo .* while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER EQUALS WHILE
## Concrete syntax: transformed data { foo == while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER GEQ WHILE
## Concrete syntax: transformed data { foo >= while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER HAT WHILE
## Concrete syntax: transformed data { foo ^ while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LABRACK WHILE
## Concrete syntax: transformed data { foo < while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTTIMESASSIGN WHILE
## Concrete syntax: transformed data { foo .*= while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER IDIVIDE WHILE
## Concrete syntax: data { vector < upper = foo %/% while
program: DATABLOCK LBRACE VECTOR LABRACK UPPER ASSIGN IDENTIFIER ELTPOW WHILE
## Concrete syntax: data { vector < upper = foo .^ while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER IDIVIDE WHILE
## Concrete syntax: transformed data { foo %/% while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL ELTPOW WHILE
##
## Concrete syntax: transformed data { 3.1415 .^ while
##
## Ends in an error in state: 125.
##
## expression -> expression ELTPOW . expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## expression ELTPOW
##

@{<light_red>Ill-formed expression.@} Found an incomplete binary expression.
Are you missing the right hand side?

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER QMARK IDENTIFIER COLON WHILE
## Concrete syntax: transformed data { foo ? foo : while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER QMARK IDENTIFIER TILDE
## Concrete syntax: transformed data { foo ? foo ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER QMARK WHILE
##
## Concrete syntax: transformed data { foo ? while
##
## Ends in an error in state: 147.
##
## expression -> expression QMARK . expression COLON expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## expression QMARK
##

@{<light_red>Ill-formed expression.@} Found an incomplete ternary expression, should be @{<green>"(@{<r>@{<f>condition@}@}) ? (@{<r>@{<f>true branch@}@}) : (@{<r>@{<f>false branch@}@})"@}.
Did you forget to add a colon or a false branch?
For example, this returns @{<b>@{<green>3.0@}@}:
  @{<green>1 ? 3.0 : 0.0@}

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK COLON IDENTIFIER TILDE
##
## Concrete syntax: transformed data { 3.1415 [ : foo ~
##
## Ends in an error in state: 130.
##
## expression -> expression . QMARK expression COLON expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . PLUS expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . MINUS expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . TIMES expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . DIVIDE expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . IDIVIDE expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . MODULO expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . LDIVIDE expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . ELTTIMES expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . ELTDIVIDE expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . HAT expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . ELTPOW expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . OR expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . AND expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . EQUALS expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . NEQUALS expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . LABRACK expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . LEQ expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . RABRACK expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . GEQ expression [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## expression -> expression . TRANSPOSE [ TRANSPOSE TIMES RBRACK RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
## indexes -> COLON expression . [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## COLON expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 127, spurious reduction of production expression -> common_expression
##

@{<light_red>Ill-formed phrase.@} Found @{<green>":"@} @{<i>expression@}. Expected either an infix or postfix operator, or @{<green>","@} or @{<green>"["@} or @{<green>"]"@} next.

program: TRANSFORMEDDATABLOCK LBRACE MINUS IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { - foo ' while
program: TRANSFORMEDDATABLOCK LBRACE PLUS IDENTIFIER TRANSPOSE WHILE
##
## Concrete syntax: transformed data { + foo ' while
##
## Ends in an error in state: 190.
##
## expression -> expression . QMARK expression COLON expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . PLUS expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . MINUS expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . TIMES expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . DIVIDE expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . IDIVIDE expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . MODULO expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . LDIVIDE expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . ELTTIMES expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . ELTDIVIDE expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . HAT expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . ELTPOW expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . OR expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . AND expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . EQUALS expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . NEQUALS expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . LABRACK expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . LEQ expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . RABRACK expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . GEQ expression [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> PLUS expression . [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
## expression -> expression . TRANSPOSE [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## PLUS expression
##

@{<light_red>Ill-formed expression.@} Found an expression. Expected an infix or postfix operator or @{<green>"["@}

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK COLON WHILE
##
## Concrete syntax: transformed data { 3.1415 [ : while
##
## Ends in an error in state: 129.
##
## indexes -> COLON . [ RBRACK COMMA ]
## indexes -> COLON . expression [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## COLON
##

@{<light_red>Ill-formed expression.@} Expected an expression or @{<green>"]"@} or @{<green>","@} after @{<green>":"@}.

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK COMMA WHILE
##
## Concrete syntax: transformed data { 3.1415 [ , while
##
## Ends in an error in state: 167.
##
## indexes -> indexes COMMA . indexes [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## indexes COMMA
##

@{<light_red>Ill-formed index.@} Expected index after indices followed by @{<green>","@}.

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL LBRACK IDENTIFIER COLON IDENTIFIER TILDE
## Concrete syntax: transformed data { 3.1415 [ foo : foo ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LBRACK REALNUMERAL COLON WHILE
##
## Concrete syntax: transformed data { foo [ 3.1415 : while
##
## Ends in an error in state: 170.
##
## indexes -> expression COLON . [ RBRACK COMMA ]
## indexes -> expression COLON . expression [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## expression COLON
##

@{<light_red>Ill-formed index.@} Expected an expression or @{<green>"]"@} or @{<green>","@} after @{<green>":"@}.

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK COMMA RBRACK MULTIPLIER
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T [ , ] multiplier
##
## Ends in an error in state: 353.
##
## atomic_statement -> expression TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation) . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## expression TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation)
##

@{<light_red>Ill-formed statement.@} Expected @{<green>";"@} after truncated @{<green>"~"@}-statement.

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK COMMA WHILE
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T [ , while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK COMMA IDENTIFIER COMMA
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T [ , foo ,
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK IDENTIFIER RBRACK
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T [ foo ]
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE WHILE
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK IDENTIFIER TILDE
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T [ foo ~
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN TRUNCATE LBRACK WHILE
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) T [ while
##
## Ends in an error in state: 346.
##
## truncation -> TRUNCATE LBRACK . option(expression) COMMA option(expression) RBRACK [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## TRUNCATE LBRACK
##

@{<light_red>Ill-formed truncation.@} Expected @{<green>"T["@} @{<i>optional expression@} @{<green>","@} @{<i>optional expression@} @{<green>"];"@}.

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN RPAREN WHILE
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( ) while
##
## Ends in an error in state: 344.
##
## atomic_statement -> expression TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN . option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## expression TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN
##

@{<light_red>Ill-formed @{<green>"~"@}-statement@}. Expected either @{<green>";"@} or a truncation with the format @{<green>"T["@} @{<i>optional expression@} @{<green>","@} @{<i>optional expression@} @{<green>"];"@}.

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN WHILE
## Concrete syntax: transformed data { 3.1415 ~ foo ( while
program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER LPAREN IDENTIFIER RBRACK
##
## Concrete syntax: transformed data { 3.1415 ~ foo ( foo ]
##
## Ends in an error in state: 343.
##
## atomic_statement -> expression TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) . RPAREN option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## expression TILDE identifier LPAREN loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 127, spurious reduction of production expression -> common_expression
## In state 175, spurious reduction of production separated_nonempty_list(COMMA,expression) -> expression
## In state 114, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

@{<light_red>Ill-formed @{<green>"~"@}-statement.@} Expected a comma separated list of expressions for arguments to the distribution, followed by @{<green>")"@}.

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE IDENTIFIER WHILE
##
## Concrete syntax: transformed data { 3.1415 ~ foo while
##
## Ends in an error in state: 341.
##
## atomic_statement -> expression TILDE identifier . LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## expression TILDE identifier
##

@{<light_red>Ill-formed @{<green>"~"@}-statement.@} Expected @{<green>"("@} after distribution name, followed by a comma separated list of expressions for arguments to the distribution, followed by @{<green>")"@}.

program: TRANSFORMEDDATABLOCK LBRACE REALNUMERAL TILDE WHILE
##
## Concrete syntax: transformed data { 3.1415 ~ while
##
## Ends in an error in state: 340.
##
## atomic_statement -> expression TILDE . identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN option(truncation) SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## expression TILDE
##

@{<light_red>Ill-formed @{<green>"~"@}-statement.@} Expected an distribution name after @{<green>"~"@}.

program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN IDENTIFIER COMMA WHILE
## Concrete syntax: transformed data { reject ( foo , while
program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN IDENTIFIER COMMA STRINGLITERAL WHILE
##
## Concrete syntax: transformed data { reject ( foo , "hello world" while
##
## Ends in an error in state: 271.
##
## printables -> printables . COMMA printables [ RPAREN COMMA ]
## printables -> printables COMMA printables . [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## printables COMMA printables
##

@{<light_red>Ill-formed statement.@} Expected a comma separated list of either expressions or strings, followed by @{<green>");"@}.

program: TRANSFORMEDDATABLOCK LBRACE REJECT WHILE
## Concrete syntax: transformed data { reject while
program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN STRINGLITERAL WHILE
## Concrete syntax: transformed data { reject ( "hello world" while
program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN IDENTIFIER TILDE
## Concrete syntax: transformed data { reject ( foo ~
program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN IDENTIFIER RPAREN WHILE
## Concrete syntax: transformed data { reject ( foo ) while
program: TRANSFORMEDDATABLOCK LBRACE REJECT LPAREN WHILE
##
## Concrete syntax: transformed data { reject ( while
##
## Ends in an error in state: 264.
##
## atomic_statement -> REJECT LPAREN . printables RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## REJECT LPAREN
##

@{<light_red>Ill-formed statement.@} Expected a comma separated list of either expressions or strings followed by @{<green>");"@} after @{<green>"reject("@},.

program: TRANSFORMEDDATABLOCK LBRACE FATAL_ERROR LPAREN IDENTIFIER RPAREN WHILE
## Concrete syntax: transformed data { fatal_error ( foo ) while
program: TRANSFORMEDDATABLOCK LBRACE FATAL_ERROR LPAREN STRINGLITERAL WHILE
## Concrete syntax: transformed data { fatal_error ( "hello world" while
program: TRANSFORMEDDATABLOCK LBRACE FATAL_ERROR LPAREN WHILE
## Concrete syntax: transformed data { fatal_error ( while
program: TRANSFORMEDDATABLOCK LBRACE FATAL_ERROR WHILE
##
## Concrete syntax: transformed data { fatal_error while
##
## Ends in an error in state: 294.
##
## atomic_statement -> FATAL_ERROR . LPAREN printables RPAREN SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## FATAL_ERROR
##

@{<light_red>Ill-formed statement.@} Expected a comma separated list of either expressions or strings followed by @{<green>");"@} after @{<green>"fatal_error("@}.

program: TRANSFORMEDDATABLOCK LBRACE RETURN LBRACE WHILE
##
## Concrete syntax: transformed data { return { while
##
## Ends in an error in state: 107.
##
## common_expression -> LBRACE . separated_nonempty_list(COMMA,expression) RBRACE [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

@{<light_red>Ill-formed expression.@} Expected an expression after @{<green>"{"@} in array expression.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN WHILE
## Concrete syntax: transformed data { foo ( while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN DOTNUMERAL TILDE
## Concrete syntax: transformed data { foo ( .2 ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN IDENTIFIER COMMA IDENTIFIER RBRACK
## Concrete syntax: transformed data { foo ( foo , foo ]
program: TRANSFORMEDDATABLOCK LBRACE RETURN IDENTIFIER LPAREN WHILE
## Concrete syntax: transformed data { return foo ( while
program: TRANSFORMEDDATABLOCK LBRACE RETURN IDENTIFIER LPAREN IDENTIFIER COMMA IDENTIFIER RBRACK
##
## Concrete syntax: transformed data { return foo ( foo , foo ]
##
## Ends in an error in state: 115.
##
## common_expression -> identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) . RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 127, spurious reduction of production expression -> common_expression
## In state 175, spurious reduction of production separated_nonempty_list(COMMA,expression) -> expression
## In state 174, spurious reduction of production separated_nonempty_list(COMMA,expression) -> expression COMMA separated_nonempty_list(COMMA,expression)
## In state 114, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

@{<light_red>Ill-formed function application.@} Expected a comma separated list of expressions followed by @{<green>")"@} after @{<green>"("@}.

program: TRANSFORMEDDATABLOCK LBRACE RETURN WHILE
## Concrete syntax: transformed data { return while
program: TRANSFORMEDDATABLOCK LBRACE RETURN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { return foo ~
##
## Ends in an error in state: 261.
##
## atomic_statement -> RETURN expression . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## expression -> expression . QMARK expression COLON expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . PLUS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MINUS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TIMES expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . DIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . IDIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MODULO expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LDIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTTIMES expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTDIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . HAT expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTPOW expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . OR expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . AND expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . EQUALS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . NEQUALS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LABRACK expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LEQ expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . RABRACK expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . GEQ expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## RETURN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 127, spurious reduction of production expression -> common_expression
##

@{<light_red>Ill-formed statement.@} Expected @{<green>";"@} or expression followed by @{<green>";"@} after @{<green>"return"@}.

program: TRANSFORMEDDATABLOCK LBRACE TARGET LPAREN WHILE
## Concrete syntax: transformed data { target ( while
program: TRANSFORMEDDATABLOCK LBRACE RETURN TARGET WHILE
##
## Concrete syntax: transformed data { return target while
##
## Ends in an error in state: 99.
##
## common_expression -> TARGET . LPAREN RPAREN [ TRANSPOSE TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DOTNUMERAL DIVIDE COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## TARGET
##

@{<light_red>Ill-formed expression.@} Expected @{<green>"()"@} after @{<green>"target"@}.

program: TRANSFORMEDDATABLOCK LBRACE TARGET PLUSASSIGN WHILE
## Concrete syntax: transformed data { target += while
program: TRANSFORMEDDATABLOCK LBRACE TARGET PLUSASSIGN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { target += foo ~
##
## Ends in an error in state: 256.
##
## atomic_statement -> TARGET PLUSASSIGN expression . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## expression -> expression . QMARK expression COLON expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . PLUS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MINUS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TIMES expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . DIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . IDIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MODULO expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LDIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTTIMES expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTDIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . HAT expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTPOW expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . OR expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . AND expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . EQUALS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . NEQUALS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LABRACK expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LEQ expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . RABRACK expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . GEQ expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## TARGET PLUSASSIGN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 127, spurious reduction of production expression -> common_expression
##

@{<light_red>Ill-formed statement.@} Expected an expression followed by @{<green>";"@} after @{<green>"target +="@}.

program: TRANSFORMEDDATABLOCK LBRACE TARGET WHILE
##
## Concrete syntax: transformed data { target while
##
## Ends in an error in state: 254.
##
## atomic_statement -> TARGET . PLUSASSIGN expression SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## common_expression -> TARGET . LPAREN RPAREN [ TRANSPOSE TIMESASSIGN TIMES TILDE RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## TARGET
##

@{<light_red>Ill-formed phrase.@} Expected either @{<green>"+="@} @{<i>expression@} or @{<green>"()"@} after @{<green>"target"@}.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN REALNUMERAL BAR WHILE
## Concrete syntax: transformed data { foo ( 3.1415 | while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN REALNUMERAL BAR IDENTIFIER RBRACK
##
## Concrete syntax: transformed data { foo ( 3.1415 | foo ]
##
## Ends in an error in state: 177.
##
## common_expression -> identifier LPAREN expression BAR loption(separated_nonempty_list(COMMA,expression)) . RPAREN [ TRANSPOSE TIMESASSIGN TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA COLON BAR ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN expression BAR loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 127, spurious reduction of production expression -> common_expression
## In state 175, spurious reduction of production separated_nonempty_list(COMMA,expression) -> expression
## In state 114, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

@{<light_red>Ill-formed conditional distribution evaluation.@} Expected a comma separated list of expressions followed by @{<green>")"@} after @{<green>"|"@}.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER LPAREN RPAREN WHILE
##
## Concrete syntax: transformed data { foo ( ) while
##
## Ends in an error in state: 337.
##
## atomic_statement -> identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## common_expression -> identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN . [ TRANSPOSE TIMESASSIGN TIMES TILDE RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## identifier LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN
##

@{<light_red>Ill-formed phrase.@} Found a well-formed function application. Expected either a @{<green>";"@} or a valid continuation of the expression.

# This one is a bit weird due to the way we over-parse expressions
# as the starting point of assignments. Depending on the rest of
# the phrase, it could be a ~, or an assignment.
# Unfortunately, the same error will be used in both cases, even though
# "3" is a valid start of a ~ but not of an assignment.
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER SEMICOLON
## Concrete syntax: transformed data { foo ;
program: TRANSFORMEDDATABLOCK LBRACE LBRACE IDENTIFIER TRANSPOSE WHILE
## Concrete syntax: transformed data { { foo ' while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER RBRACE
## Concrete syntax: transformed data { foo }
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER DOTNUMERAL SEMICOLON
##
## Concrete syntax: transformed data { foo .2 ;
##
## Ends in an error in state: 356.
##
## atomic_statement -> common_expression . ASSIGN expression SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> common_expression . PLUSASSIGN expression SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> common_expression . MINUSASSIGN expression SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> common_expression . TIMESASSIGN expression SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> common_expression . DIVIDEASSIGN expression SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> common_expression . ELTTIMESASSIGN expression SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## atomic_statement -> common_expression . ELTDIVIDEASSIGN expression SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## common_expression -> common_expression . DOTNUMERAL [ TRANSPOSE TIMESASSIGN TIMES TILDE RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA ASSIGN AND ]
## common_expression -> common_expression . LBRACK indexes RBRACK [ TRANSPOSE TIMESASSIGN TIMES TILDE RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA ASSIGN AND ]
## expression -> common_expression . [ TRANSPOSE TIMES TILDE RBRACE RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE COMMA AND ]
##
## The known suffix of the stack is as follows:
## common_expression
##

@{<light_red>Ill-formed phrase.@} Expected a statement, but found a partial value before this point.
Did you mean for this to be the start of an assignment or @{<green>"~"@}-statement?

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER PLUSASSIGN IDENTIFIER TILDE
## Concrete syntax: transformed data { foo += foo ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER MINUSASSIGN IDENTIFIER TILDE
## Concrete syntax: transformed data { foo -= foo ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTDIVIDEASSIGN IDENTIFIER TILDE
## Concrete syntax: transformed data { foo ./= foo ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTTIMESASSIGN IDENTIFIER TILDE
## Concrete syntax: transformed data { foo .*= foo ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER DIVIDEASSIGN IDENTIFIER TILDE
## Concrete syntax: transformed data { foo /= foo ~
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TIMESASSIGN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { foo *= foo ~
##
## Ends in an error in state: 358.
##
## atomic_statement -> common_expression TIMESASSIGN expression . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## expression -> expression . QMARK expression COLON expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . PLUS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MINUS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TIMES expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . DIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . IDIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MODULO expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LDIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTTIMES expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTDIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . HAT expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTPOW expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . OR expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . AND expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . EQUALS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . NEQUALS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LABRACK expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LEQ expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . RABRACK expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . GEQ expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## common_expression TIMESASSIGN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 127, spurious reduction of production expression -> common_expression
##

@{<light_red>Ill-formed compound assignment statement.@} Expected a @{<green>";"@} after the value being assigned.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER MINUSASSIGN WHILE
## Concrete syntax: transformed data { foo -= while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER PLUSASSIGN WHILE
## Concrete syntax: transformed data { foo += while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER DIVIDEASSIGN WHILE
## Concrete syntax: transformed data { foo /= while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ELTDIVIDEASSIGN WHILE
## Concrete syntax: transformed data { foo ./= while
program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER TIMESASSIGN WHILE
##
## Concrete syntax: transformed data { foo *= while
##
## Ends in an error in state: 357.
##
## atomic_statement -> common_expression TIMESASSIGN . expression SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## common_expression TIMESASSIGN
##

@{<light_red>Ill-formed compound assignment statement.@} Expected an expression followed by @{<green>";"@} next.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN IDENTIFIER TILDE
##
## Concrete syntax: transformed data { foo = foo ~
##
## Ends in an error in state: 376.
##
## atomic_statement -> common_expression ASSIGN expression . SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
## expression -> expression . QMARK expression COLON expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . PLUS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MINUS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TIMES expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . DIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . IDIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . MODULO expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LDIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTTIMES expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTDIVIDE expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . HAT expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . ELTPOW expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . OR expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . AND expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . EQUALS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . NEQUALS expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LABRACK expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . LEQ expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . RABRACK expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . GEQ expression [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
## expression -> expression . TRANSPOSE [ TRANSPOSE TIMES SEMICOLON RABRACK QMARK PLUS OR NEQUALS MODULO MINUS LEQ LDIVIDE LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMES ELTPOW ELTDIVIDE DIVIDE AND ]
##
## The known suffix of the stack is as follows:
## common_expression ASSIGN expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 112, spurious reduction of production common_expression -> identifier
## In state 127, spurious reduction of production expression -> common_expression
##

@{<light_red>Ill-formed assignment statement.@} Expected a @{<green>";"@} after the value being assigned.

program: TRANSFORMEDDATABLOCK LBRACE IDENTIFIER ASSIGN WHILE
##
## Concrete syntax: transformed data { foo = while
##
## Ends in an error in state: 375.
##
## atomic_statement -> common_expression ASSIGN . expression SEMICOLON [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## common_expression ASSIGN
##

@{<light_red>Ill-formed assignment statement.@} Expected an expression followed by @{<green>";"@} next.

program: TRANSFORMEDPARAMETERSBLOCK LBRACE VOID
## Concrete syntax: transformed parameters { void
program: TRANSFORMEDDATABLOCK LBRACE VOID
##
## Concrete syntax: transformed data { void
##
## Ends in an error in state: 642.
##
## transformed_data_block -> TRANSFORMEDDATABLOCK LBRACE . list(top_vardecl_or_statement) RBRACE [ TRANSFORMEDPARAMETERSBLOCK PARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## TRANSFORMEDDATABLOCK LBRACE
##

@{<light_red>Ill-formed block.@} Expected a statement or top-level variable declaration.

program: TRANSFORMEDDATABLOCK LBRACE WHILE LPAREN IDENTIFIER RPAREN VOID
##
## Concrete syntax: transformed data { while ( foo ) void
##
## Ends in an error in state: 192.
##
## nested_statement -> WHILE LPAREN expression RPAREN . vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## WHILE LPAREN expression RPAREN
##

@{<light_red>Ill-formed statement.@} Expected a statement after @{<green>")"@} for the body of the @{<green>"while"@} loop.

program: TRANSFORMEDDATABLOCK LBRACE WHILE LPAREN IDENTIFIER TILDE
## Concrete syntax: transformed data { while ( foo ~
program: TRANSFORMEDDATABLOCK LBRACE WHILE LPAREN WHILE
##
## Concrete syntax: transformed data { while ( while
##
## Ends in an error in state: 98.
##
## nested_statement -> WHILE LPAREN . expression RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## WHILE LPAREN
##

@{<light_red>Ill-formed expression.@} Expected an expression after @{<green>"("@} for the test of a @{<green>"while"@} loop.

program: TRANSFORMEDDATABLOCK LBRACE WHILE WHILE
##
## Concrete syntax: transformed data { while while
##
## Ends in an error in state: 97.
##
## nested_statement -> WHILE . LPAREN expression RPAREN vardecl_or_statement [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## WHILE
##

@{<light_red>Ill-formed statement.@} Expected @{<green>"("@} @{<i>expression@} @{<green>")"@} @{<i>statement@} after @{<green>"while"@}.

program: TRANSFORMEDDATABLOCK WHILE
##
## Concrete syntax: transformed data while
##
## Ends in an error in state: 641.
##
## transformed_data_block -> TRANSFORMEDDATABLOCK . LBRACE list(top_vardecl_or_statement) RBRACE [ TRANSFORMEDPARAMETERSBLOCK PARAMETERSBLOCK MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## TRANSFORMEDDATABLOCK
##

@{<light_red>Ill-formed statement.@} Expected @{<green>"{"@} after @{<green>"transformed data"@}.

program: TRANSFORMEDPARAMETERSBLOCK WHILE
##
## Concrete syntax: transformed parameters while
##
## Ends in an error in state: 674.
##
## transformed_parameters_block -> TRANSFORMEDPARAMETERSBLOCK . LBRACE list(top_vardecl_or_statement) RBRACE [ MODELBLOCK GENERATEDQUANTITIESBLOCK EOF ]
##
## The known suffix of the stack is as follows:
## TRANSFORMEDPARAMETERSBLOCK
##

@{<light_red>Ill-formed block.@} Expected @{<green>"{"@} after @{<green>"transformed parameters"@}.

program: TRANSFORMEDDATABLOCK LBRACE PROFILE LPAREN WHILE
## Concrete syntax: transformed data { profile ( while
program: TRANSFORMEDDATABLOCK LBRACE PROFILE WHILE
##
## Concrete syntax: transformed data { profile while
##
## Ends in an error in state: 273.
##
## nested_statement -> PROFILE . LPAREN string_literal RPAREN LBRACE list(vardecl_or_statement) RBRACE [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PROFILE
##

@{<light_red>Ill-formed statement.@} Expected profile name as string in parenthesis

program: TRANSFORMEDDATABLOCK LBRACE PROFILE LPAREN STRINGLITERAL WHILE
##
## Concrete syntax: transformed data { profile ( "hello world" while
##
## Ends in an error in state: 275.
##
## nested_statement -> PROFILE LPAREN string_literal . RPAREN LBRACE list(vardecl_or_statement) RBRACE [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PROFILE LPAREN string_literal
##

@{<light_red>Ill-formed statement.@} Expected @{<green>")"@} after profile name.

program: TRANSFORMEDDATABLOCK LBRACE PROFILE LPAREN STRINGLITERAL RPAREN WHILE
##
## Concrete syntax: transformed data { profile ( "hello world" ) while
##
## Ends in an error in state: 276.
##
## nested_statement -> PROFILE LPAREN string_literal RPAREN . LBRACE list(vardecl_or_statement) RBRACE [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## PROFILE LPAREN string_literal RPAREN
##

@{<light_red>Ill-formed statement.@} Expected @{<green>"{"@} to begin profile block.

program: DATABLOCK LBRACE ARRAY LBRACK IDENTIFIER RPAREN
## Concrete syntax: data { array [ foo )
functions_only: ARRAY IDENTIFIER
## Concrete syntax: array foo
program: TRANSFORMEDDATABLOCK LBRACE ARRAY IDENTIFIER
##
## Concrete syntax: transformed data { array foo
##
## Ends in an error in state: 226.
##
## arr_dims -> ARRAY . LBRACK separated_nonempty_list(COMMA,expression) RBRACK [ VECTOR UNITVECTOR TUPLE SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX ROWVECTOR REAL POSITIVEORDERED ORDERED MATRIX INT COVMATRIX CORRMATRIX COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR ]
##
## The known suffix of the stack is as follows:
## ARRAY
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>array sizes@} @{<green>"]"@} followed by type after @{<green>"array"@}.

program: MODELBLOCK LBRACE TUPLE LPAREN ARRAY LBRACK IDENTIFIER RBRACK REAL COMMA WHILE
## Concrete syntax: model { tuple ( array [ foo ] real , while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA REAL COMMA WHILE
## Concrete syntax: model { tuple ( real , real , while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA REAL COMMA WHILE
## Concrete syntax: data { tuple ( real , real , while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA TUPLE LPAREN COMPLEX COMMA COMPLEX RPAREN COMMA WHILE
## Concrete syntax: model { tuple ( real , tuple ( complex , complex ) , while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA TUPLE LPAREN COMPLEX COMMA COMPLEX RPAREN COMMA WHILE
## Concrete syntax: data { tuple ( real , tuple ( complex , complex ) , while
program: MODELBLOCK LBRACE TUPLE LPAREN TUPLE LPAREN REAL COMMA COMPLEX RPAREN COMMA WHILE
## Concrete syntax: model { tuple ( tuple ( real , complex ) , while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA ARRAY LBRACK IDENTIFIER RBRACK REAL COMMA WHILE
## Concrete syntax: model { tuple ( real , array [ foo ] real , while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA ARRAY LBRACK IDENTIFIER RBRACK REAL COMMA WHILE
## Concrete syntax: data { tuple ( real , array [ foo ] real , while
program: DATABLOCK LBRACE TUPLE LPAREN TUPLE LPAREN REAL COMMA COMPLEX RPAREN COMMA WHILE
## Concrete syntax: data { tuple ( tuple ( real , complex ) , while
program: DATABLOCK LBRACE TUPLE LPAREN ARRAY LBRACK IDENTIFIER RBRACK REAL COMMA WHILE
## Concrete syntax: data { tuple ( array [ foo ] real , while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA WHILE
## Concrete syntax: model { tuple ( real , while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA WHILE
##
## Concrete syntax: data { tuple ( real , while
##
## Ends in an error in state: 597.
##
## tuple_type(top_var_type) -> TUPLE LPAREN top_var_type COMMA . separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## TUPLE LPAREN top_var_type COMMA
##

@{<light_red>Ill-formed type.@} Incomplete type specification, expected further types followed by @{<green>")"@} to complete tuple.

program: MODELBLOCK LBRACE TUPLE LPAREN TUPLE LPAREN REAL COMMA COMPLEX RPAREN WHILE
## Concrete syntax: model { tuple ( tuple ( real , complex ) while
program: MODELBLOCK LBRACE TUPLE LPAREN ARRAY LBRACK IDENTIFIER RBRACK REAL WHILE
## Concrete syntax: model { tuple ( array [ foo ] real while
program: DATABLOCK LBRACE TUPLE LPAREN TUPLE LPAREN REAL COMMA COMPLEX RPAREN WHILE
## Concrete syntax: data { tuple ( tuple ( real , complex ) while
program: DATABLOCK LBRACE TUPLE LPAREN ARRAY LBRACK IDENTIFIER RBRACK REAL IDENTIFIER
## Concrete syntax: data { tuple ( array [ foo ] real foo
program: MODELBLOCK LBRACE TUPLE LPAREN REAL WHILE
## Concrete syntax: model { tuple ( real while
program: DATABLOCK LBRACE TUPLE LPAREN REAL WHILE
##
## Concrete syntax: data { tuple ( real while
##
## Ends in an error in state: 596.
##
## tuple_type(top_var_type) -> TUPLE LPAREN top_var_type . COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## TUPLE LPAREN top_var_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 522, spurious reduction of production range_constraint ->
## In state 484, spurious reduction of production type_constraint -> range_constraint
## In state 523, spurious reduction of production top_var_type -> REAL type_constraint
##

@{<light_red>Ill-formed type.@} Expected @{<green>","@} followed by further types and @{<green>")"@} to complete tuple.

program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA ARRAY LBRACK IDENTIFIER RBRACK REAL WHILE
## Concrete syntax: model { tuple ( real , array [ foo ] real while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA ARRAY LBRACK IDENTIFIER RBRACK REAL WHILE
## Concrete syntax: data { tuple ( real , array [ foo ] real while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA REAL WHILE
## Concrete syntax: model { tuple ( real , real while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA REAL WHILE
## Concrete syntax: data { tuple ( real , real while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA TUPLE LPAREN COMPLEX COMMA COMPLEX RPAREN WHILE
## Concrete syntax: model { tuple ( real , tuple ( complex , complex ) while
program: DATABLOCK LBRACE TUPLE LPAREN REAL COMMA TUPLE LPAREN COMPLEX COMMA COMPLEX RPAREN WHILE
##
## Concrete syntax: data { tuple ( real , tuple ( complex , complex ) while
##
## Ends in an error in state: 582.
##
## separated_nonempty_list(COMMA,higher_type(top_var_type)) -> tuple_type(top_var_type) . [ RPAREN ]
## separated_nonempty_list(COMMA,higher_type(top_var_type)) -> tuple_type(top_var_type) . COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## tuple_type(top_var_type)
##

@{<light_red>Ill-formed type.@} Expected either @{<green>")"@} or @{<green>","@} followed by
further types and @{<green>")"@} to complete tuple.

functions_only: ARRAY LBRACK RBRACK TUPLE WHILE
## Concrete syntax: array [ ] tuple while
functions_only: TUPLE WHILE
## Concrete syntax: tuple while
program: MODELBLOCK LBRACE TUPLE WHILE
## Concrete syntax: model { tuple while
program: DATABLOCK LBRACE TUPLE WHILE
## Concrete syntax: data { tuple while
functions_only: ARRAY LBRACK RBRACK TUPLE LPAREN VECTOR COMMA WHILE
## Concrete syntax: array [ ] tuple ( vector , while
functions_only: ARRAY LBRACK RBRACK TUPLE LPAREN VECTOR WHILE
## Concrete syntax: array [ ] tuple ( vector while
functions_only: TUPLE LPAREN VECTOR COMMA VECTOR WHILE
## Concrete syntax: tuple ( vector , vector while
functions_only: TUPLE LPAREN VECTOR WHILE
## Concrete syntax: tuple ( vector while
functions_only: TUPLE LPAREN VECTOR COMMA WHILE
## Concrete syntax: tuple ( vector , while
functions_only: TUPLE LPAREN WHILE
## Concrete syntax: tuple ( while
functions_only: TUPLE LPAREN VECTOR COMMA VECTOR COMMA WHILE
## Concrete syntax: tuple ( vector , vector , while
functions_only: ARRAY LBRACK RBRACK TUPLE LPAREN WHILE
## Concrete syntax: array [ ] tuple ( while
program: MODELBLOCK LBRACE TUPLE LPAREN REAL COMMA TUPLE LPAREN WHILE
## Concrete syntax: model { tuple ( real , tuple ( while
program: DATABLOCK LBRACE TUPLE LPAREN WHILE
##
## Concrete syntax: data { tuple ( while
##
## Ends in an error in state: 490.
##
## tuple_type(top_var_type) -> TUPLE LPAREN . array_type(top_var_type) COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## tuple_type(top_var_type) -> TUPLE LPAREN . tuple_type(top_var_type) COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## tuple_type(top_var_type) -> TUPLE LPAREN . top_var_type COMMA separated_nonempty_list(COMMA,higher_type(top_var_type)) RPAREN [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## TUPLE LPAREN
##

@{<light_red>Ill-formed type.@} Expected a comma separated list of types between @{<green>"("@} and @{<green>")"@} to declare tuple variable.

program: TRANSFORMEDDATABLOCK LBRACE RETURN LPAREN WHILE
## Concrete syntax: transformed data { return ( while
program: TRANSFORMEDDATABLOCK LBRACE LPAREN IDENTIFIER COMMA WHILE
##
## Concrete syntax: transformed data { ( foo , while
##
## Ends in an error in state: 186.
##
## common_expression -> LPAREN expression COMMA . separated_nonempty_list(COMMA,expression) RPAREN [ TRANSPOSE TIMESASSIGN TIMES TILDE SEMICOLON RPAREN RBRACK RBRACE RABRACK QMARK PLUSASSIGN PLUS OR NEQUALS MODULO MINUSASSIGN MINUS LEQ LDIVIDE LBRACK LABRACK IDIVIDE HAT GEQ EQUALS ELTTIMESASSIGN ELTTIMES ELTPOW ELTDIVIDEASSIGN ELTDIVIDE DOTNUMERAL DIVIDEASSIGN DIVIDE COMMA COLON BAR ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## LPAREN expression COMMA
##

@{<light_red>Ill-formed expression.@} Expected an expression or comma separated list of expressions followed by @{<green>")"@} after @{<green>"("@}.

functions_only: ARRAY LBRACK RBRACK WHILE
## Concrete syntax: array [ ] while
program: MODELBLOCK LBRACE ARRAY LBRACK INTNUMERAL RBRACK IDENTIFIER
## Concrete syntax: model { array [ 24 ] foo
program: DATABLOCK LBRACE ARRAY LBRACK INTNUMERAL RBRACK IDENTIFIER
##
## Concrete syntax: data { array [ 24 ] foo
##
## Ends in an error in state: 590.
##
## array_type(top_var_type) -> arr_dims . top_var_type [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
## array_type(top_var_type) -> arr_dims . tuple_type(top_var_type) [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## arr_dims
##

@{<light_red>Ill-formed type.@} Expected non-array type after @{<green>"array"@} declaration.

program: DATABLOCK LBRACE ARRAY LBRACK WHILE
##
## Concrete syntax: data { array [ while
##
## Ends in an error in state: 227.
##
## arr_dims -> ARRAY LBRACK . separated_nonempty_list(COMMA,expression) RBRACK [ VECTOR UNITVECTOR TUPLE SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX ROWVECTOR REAL POSITIVEORDERED ORDERED MATRIX INT COVMATRIX CORRMATRIX COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR ]
##
## The known suffix of the stack is as follows:
## ARRAY LBRACK
##

@{<light_red>Ill-formed type.@} Expected expressions for size of array.

functions_only: ARRAY LBRACK COMMA WHILE
## Concrete syntax: array [ , while
functions_only: ARRAY LBRACK WHILE
##
## Concrete syntax: array [ while
##
## Ends in an error in state: 14.
##
## unsized_dims -> LBRACK . list(COMMA) RBRACK [ WHILE VOID VECTOR UPPER UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX RPAREN ROWVECTOR RETURN REJECT REAL PROFILE PRINT POSITIVEORDERED PARAMETERSBLOCK ORDERED OFFSET MULTIPLIER MODELBLOCK MATRIX LOWER JACOBIAN INT IN IF IDENTIFIER FUNCTIONBLOCK FOR FATAL_ERROR ELSE DATABLOCK COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX COMMA CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK ARRAY ]
##
## The known suffix of the stack is as follows:
## LBRACK
##

@{<light_red>Ill-formed type.@} Expected @{<green>"["@} @{<i>(list of commas)@} @{<green>"]"@} in unsized return type of function definition.

program: TRANSFORMEDDATABLOCK LBRACE COMPLEX IDENTIFIER LBRACK IDENTIFIER RPAREN
## Concrete syntax: transformed data { complex foo [ foo )
program: TRANSFORMEDDATABLOCK LBRACE COMPLEX IDENTIFIER LBRACK WHILE
## Concrete syntax: transformed data { complex foo [ while
program: DATABLOCK LBRACE COMPLEX IDENTIFIER LBRACK IDENTIFIER RPAREN
## Concrete syntax: data { complex foo [ foo )
program: DATABLOCK LBRACE COMPLEX IDENTIFIER LBRACK WHILE
## Concrete syntax: data { complex foo [ while
program: MODELBLOCK LBRACE COMPLEX IDENTIFIER LBRACK IDENTIFIER RPAREN
## Concrete syntax: model { complex foo [ foo )
program: MODELBLOCK LBRACE COMPLEX IDENTIFIER LBRACK WHILE
##
## Concrete syntax: model { complex foo [ while
##
## Ends in an error in state: 330.
##
## decl(sized_basic_type,expression) -> sized_basic_type decl_identifier LBRACK . separated_nonempty_list(COMMA,expression) RBRACK [ WHILE VOID VECTOR UNITVECTOR TUPLE TRUNCATE TARGET SUMTOZEROVEC SUMTOZEROMAT STOCHASTICROWMATRIX STOCHASTICCOLUMNMATRIX SIMPLEX SEMICOLON ROWVECTOR RETURN REJECT REALNUMERAL REAL RBRACE PROFILE PRINT POSITIVEORDERED PLUS ORDERED MINUS MATRIX LPAREN LBRACK LBRACE JACOBIAN INTNUMERAL INT IMAGNUMERAL IF IDENTIFIER FOR FATAL_ERROR EOF ELSE DOTNUMERAL COVMATRIX CORRMATRIX CONTINUE COMPLEXVECTOR COMPLEXROWVECTOR COMPLEXMATRIX COMPLEX CHOLESKYFACTORCOV CHOLESKYFACTORCORR BREAK BANG ARRAY ]
##
## The known suffix of the stack is as follows:
## sized_basic_type decl_identifier LBRACK
##

@{<light_red>Ill-formed declaration.@} Expected @{<green>";"@} after variable declaration.
@{<light_yellow>It looks like you are trying to use the old array syntax.
Please use the new syntax:@}
https://mc-stan.org/docs/reference-manual/types.html#array-data-types.section
