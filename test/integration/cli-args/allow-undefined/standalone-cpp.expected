  $ ../../../../../install/default/bin/stanc --standalone-functions --allow-undefined --print-cpp external.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace external_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 3> locations_array__ =
  {" (found before start of program)",
  " (in 'external.stan', line 10, column 4 to column 66)",
  " (in 'external.stan', line 9, column 63 to line 11, column 3)"};
double
internal_fun(const std::vector<std::vector<double>>& a,
             const std::vector<std::vector<int>>& d, std::ostream* pstream__);
struct external_map_rectable_functor__ {
  template <typename T0__, typename T1__,
            stan::require_all_t<stan::is_col_vector<T0__>,
                                stan::is_vt_not_complex<T0__>,
                                stan::is_col_vector<T1__>,
                                stan::is_vt_not_complex<T1__>>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                  stan::base_type_t<T1__>>,-1,1>
  operator()(const T0__& phi, const T1__& theta, const std::vector<double>&
             x_r, const std::vector<int>& x_i, std::ostream* pstream__) const {
    return external_map_rectable(phi, theta, x_r, x_i, pstream__);
  }
};
// real internal_fun(data array[,] real, data array[,] int)
double
internal_fun(const std::vector<std::vector<double>>& a,
             const std::vector<std::vector<int>>& d, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 1;
    return stan::math::sum(
             stan::math::map_rect<1, external_map_rectable_functor__>(
               Eigen::Matrix<double,-1,1>(0),
               std::vector<Eigen::Matrix<double,-1,1>>{Eigen::Matrix<double,-1,1>(0)},
               a, d, pstream__));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
}
// [[stan::function]]
double external_fun(const double& a, std::ostream* pstream__ = nullptr) {
  return external_model_namespace::external_fun(a, pstream__);
}
// [[stan::function]]
Eigen::Matrix<double,-1,1>
external_map_rectable(const Eigen::Matrix<double,-1,1>& phi,
                      const Eigen::Matrix<double,-1,1>& theta,
                      const std::vector<double>& x_r, const std::vector<int>&
                      x_i, std::ostream* pstream__ = nullptr) {
  return external_model_namespace::external_map_rectable(phi, theta, x_r,
           x_i, pstream__);
}
// [[stan::function]]
double
internal_fun(const std::vector<std::vector<double>>& a,
             const std::vector<std::vector<int>>& d, std::ostream*
             pstream__ = nullptr) {
  return external_model_namespace::internal_fun(a, d, pstream__);
}
Warning in 'external.stan', line 7, column 7: Functions do not need to be
    declared before definition; all user defined function names are always in
    scope regardless of definition order.
