  $ ../../../../../install/default/bin/stanc --print-cpp 8_schools_ncp.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace _8_schools_ncp_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 16> locations_array__ =
  {" (found before start of program)",
  " (in '8_schools_ncp.stan', line 7, column 2 to column 10)",
  " (in '8_schools_ncp.stan', line 8, column 2 to column 20)",
  " (in '8_schools_ncp.stan', line 9, column 2 to column 24)",
  " (in '8_schools_ncp.stan', line 12, column 2 to column 43)",
  " (in '8_schools_ncp.stan', line 15, column 2 to column 20)",
  " (in '8_schools_ncp.stan', line 16, column 2 to column 21)",
  " (in '8_schools_ncp.stan', line 17, column 2 to column 29)",
  " (in '8_schools_ncp.stan', line 18, column 2 to column 27)",
  " (in '8_schools_ncp.stan', line 2, column 2 to column 17)",
  " (in '8_schools_ncp.stan', line 3, column 8 to column 9)",
  " (in '8_schools_ncp.stan', line 3, column 2 to column 18)",
  " (in '8_schools_ncp.stan', line 4, column 8 to column 9)",
  " (in '8_schools_ncp.stan', line 4, column 2 to column 31)",
  " (in '8_schools_ncp.stan', line 9, column 9 to column 10)",
  " (in '8_schools_ncp.stan', line 12, column 9 to column 10)"};
class _8_schools_ncp_model final : public model_base_crtp<_8_schools_ncp_model> {
 private:
  int J;
  std::vector<double> y;
  std::vector<double> sigma;
 public:
  ~_8_schools_ncp_model() {}
  _8_schools_ncp_model(stan::io::var_context& context__, unsigned int
                       random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "_8_schools_ncp_model_namespace::_8_schools_ncp_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 9;
      context__.validate_dims("data initialization", "J", "int",
        std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      current_statement__ = 9;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 9;
      stan::math::check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 10;
      stan::math::validate_non_negative_index("y", "J", J);
      current_statement__ = 11;
      context__.validate_dims("data initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(J)});
      y = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 11;
      y = context__.vals_r("y");
      current_statement__ = 12;
      stan::math::validate_non_negative_index("sigma", "J", J);
      current_statement__ = 13;
      context__.validate_dims("data initialization", "sigma", "double",
        std::vector<size_t>{static_cast<size_t>(J)});
      sigma = std::vector<double>(J,
                std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 13;
      sigma = context__.vals_r("sigma");
      current_statement__ = 13;
      stan::math::check_greater_or_equal(function__, "sigma", sigma, 0);
      current_statement__ = 14;
      stan::math::validate_non_negative_index("theta_tilde", "J", J);
      current_statement__ = 15;
      stan::math::validate_non_negative_index("theta", "J", J);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + J;
  }
  inline std::string model_name() const final {
    return "_8_schools_ncp_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "_8_schools_ncp_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      local_scalar_t__ tau = DUMMY_VAR__;
      current_statement__ = 2;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> theta_tilde =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      current_statement__ = 3;
      theta_tilde = in__.template read<
                      Eigen::Matrix<local_scalar_t__,-1,1>>(J);
      Eigen::Matrix<local_scalar_t__,-1,1> theta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(theta,
        stan::math::add(mu, stan::math::multiply(tau, theta_tilde)),
        "assigning variable theta");
      {
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu, 0, 5));
        current_statement__ = 6;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(tau, 0, 5));
        current_statement__ = 7;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(theta_tilde, 0, 1));
        current_statement__ = 8;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, theta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "_8_schools_ncp_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      local_scalar_t__ tau = DUMMY_VAR__;
      current_statement__ = 2;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> theta_tilde =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      current_statement__ = 3;
      theta_tilde = in__.template read<
                      Eigen::Matrix<local_scalar_t__,-1,1>>(J);
      Eigen::Matrix<local_scalar_t__,-1,1> theta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(theta,
        stan::math::add(mu, stan::math::multiply(tau, theta_tilde)),
        "assigning variable theta");
      {
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu, 0, 5));
        current_statement__ = 6;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(tau, 0, 5));
        current_statement__ = 7;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(theta_tilde, 0, 1));
        current_statement__ = 8;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, theta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "_8_schools_ncp_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double mu = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      double tau = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      Eigen::Matrix<double,-1,1> theta_tilde =
        Eigen::Matrix<double,-1,1>::Constant(J,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      theta_tilde = in__.template read<
                      Eigen::Matrix<local_scalar_t__,-1,1>>(J);
      Eigen::Matrix<double,-1,1> theta =
        Eigen::Matrix<double,-1,1>::Constant(J,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(mu);
      out__.write(tau);
      out__.write(theta_tilde);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 4;
      stan::model::assign(theta,
        stan::math::add(mu, stan::math::multiply(tau, theta_tilde)),
        "assigning variable theta");
      if (emit_transformed_parameters__) {
        out__.write(theta);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.read<local_scalar_t__>();
      out__.write(mu);
      local_scalar_t__ tau = DUMMY_VAR__;
      current_statement__ = 2;
      tau = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau);
      Eigen::Matrix<local_scalar_t__,-1,1> theta_tilde =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(theta_tilde,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(J),
        "assigning variable theta_tilde");
      out__.write(theta_tilde);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mu", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "tau", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "theta_tilde",
        "double", std::vector<size_t>{static_cast<size_t>(J)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = context__.vals_r("mu")[(1 - 1)];
      out__.write(mu);
      local_scalar_t__ tau = DUMMY_VAR__;
      current_statement__ = 2;
      tau = context__.vals_r("tau")[(1 - 1)];
      out__.write_free_lb(0, tau);
      Eigen::Matrix<local_scalar_t__,-1,1> theta_tilde =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> theta_tilde_flat__;
        current_statement__ = 3;
        theta_tilde_flat__ = context__.vals_r("theta_tilde");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
          stan::model::assign(theta_tilde, theta_tilde_flat__[(pos__ - 1)],
            "assigning variable theta_tilde", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(theta_tilde);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mu", "tau", "theta_tilde"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"theta"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(J)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(J)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mu");
    param_names__.emplace_back(std::string() + "tau");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      param_names__.emplace_back(std::string() + "theta_tilde" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mu");
    param_names__.emplace_back(std::string() + "tau");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      param_names__.emplace_back(std::string() + "theta_tilde" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_tilde\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_tilde\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((1 + 1) + J);
    const size_t num_transformed = emit_transformed_parameters * (J);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((1 + 1) + J);
    const size_t num_transformed = emit_transformed_parameters * (J);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = _8_schools_ncp_model_namespace::_8_schools_ncp_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return _8_schools_ncp_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp 8start_with_number.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace _8start_with_number_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 3> locations_array__ =
  {" (found before start of program)",
  " (in '8start_with_number.stan', line 6, column 3 to column 12)",
  " (in '8start_with_number.stan', line 3, column 2 to column 17)"};
class _8start_with_number_model final : public model_base_crtp<_8start_with_number_model> {
 private:
  int good_model;
 public:
  ~_8start_with_number_model() {}
  _8start_with_number_model(stan::io::var_context& context__, unsigned int
                            random_seed__ = 0, std::ostream*
                            pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "_8start_with_number_model_namespace::_8start_with_number_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 2;
      context__.validate_dims("data initialization", "good_model", "int",
        std::vector<size_t>{});
      good_model = std::numeric_limits<int>::min();
      current_statement__ = 2;
      good_model = context__.vals_i("good_model")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1;
  }
  inline std::string model_name() const final {
    return "_8start_with_number_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "_8start_with_number_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ bar = DUMMY_VAR__;
      current_statement__ = 1;
      bar = in__.template read<local_scalar_t__>();
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "_8start_with_number_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ bar = DUMMY_VAR__;
      current_statement__ = 1;
      bar = in__.template read<local_scalar_t__>();
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "_8start_with_number_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double bar = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      bar = in__.template read<local_scalar_t__>();
      out__.write(bar);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ bar = DUMMY_VAR__;
      current_statement__ = 1;
      bar = in__.read<local_scalar_t__>();
      out__.write(bar);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "bar", "double",
        std::vector<size_t>{});
      local_scalar_t__ bar = DUMMY_VAR__;
      current_statement__ = 1;
      bar = context__.vals_r("bar")[(1 - 1)];
      out__.write(bar);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"bar"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "bar");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "bar");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"bar\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"bar\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = _8start_with_number_model_namespace::_8start_with_number_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return _8start_with_number_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp complex-tuples.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace complex_tuples_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 11> locations_array__ =
  {" (found before start of program)",
  " (in 'complex-tuples.stan', line 7, column 2 to column 21)",
  " (in 'complex-tuples.stan', line 8, column 2 to column 31)",
  " (in 'complex-tuples.stan', line 9, column 2 to column 67)",
  " (in 'complex-tuples.stan', line 10, column 2 to column 10)",
  " (in 'complex-tuples.stan', line 11, column 2 to column 16)",
  " (in 'complex-tuples.stan', line 12, column 2 to column 14)",
  " (in 'complex-tuples.stan', line 13, column 2 to column 31)",
  " (in 'complex-tuples.stan', line 15, column 2 to column 74)",
  " (in 'complex-tuples.stan', line 3, column 4 to column 27)",
  " (in 'complex-tuples.stan', line 2, column 105 to line 4, column 3)"};
template <typename T0__, typename T1__0__0__, typename T1__0__1__,
          typename T1__1__,
          stan::require_all_t<std::is_integral<T0__>,
                              std::is_integral<T1__0__0__>,
                              std::is_integral<T1__0__1__>,
                              stan::is_std_vector<T1__1__>,
                              stan::is_std_vector<stan::value_type_t<T1__1__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T1__1__>>>>* = nullptr>
std::tuple<int, std::vector<std::tuple<int, double>>>
f(const T0__& x,
  const std::vector<
          std::vector<
            std::tuple<std::vector<std::tuple<T1__0__0__, T1__0__1__>>,
              T1__1__>>>& x2, std::ostream* pstream__);
/* tuple(int, array[] tuple(int, real))
   f(int, array[,] tuple(array[] tuple(int, int), array[,] int))
 */
template <typename T0__, typename T1__0__0__, typename T1__0__1__,
          typename T1__1__,
          stan::require_all_t<std::is_integral<T0__>,
                              std::is_integral<T1__0__0__>,
                              std::is_integral<T1__0__1__>,
                              stan::is_std_vector<T1__1__>,
                              stan::is_std_vector<stan::value_type_t<T1__1__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T1__1__>>>>*>
std::tuple<int, std::vector<std::tuple<int, double>>>
f(const T0__& x,
  const std::vector<
          std::vector<
            std::tuple<std::vector<std::tuple<T1__0__0__, T1__0__1__>>,
              T1__1__>>>& x2, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 9;
    return std::tuple<int, std::vector<std::tuple<int, local_scalar_t__>>>(1,
             std::vector<std::tuple<int, local_scalar_t__>>{std::tuple<int,
                                                              local_scalar_t__>(2,
                                                              3.4)});
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class complex_tuples_model final : public model_base_crtp<complex_tuples_model> {
 private:
  std::tuple<int, double> x;
  std::tuple<std::vector<int>, double> y;
  std::vector<
    std::tuple<
      std::vector<
        std::tuple<int, std::vector<std::vector<std::vector<double>>>>>,
      double>> y2;
  int z;
  int b;
  double c;
  std::tuple<int, double, std::vector<std::tuple<int, int>>> d;
 public:
  ~complex_tuples_model() {}
  complex_tuples_model(stan::io::var_context& context__, unsigned int
                       random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "complex_tuples_model_namespace::complex_tuples_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 1;
      x = std::tuple<int, double>{std::numeric_limits<int>::min(),
            std::numeric_limits<double>::quiet_NaN()};
      current_statement__ = 2;
      y = std::tuple<std::vector<int>, double>{std::vector<int>(10,
                                                 std::numeric_limits<int>::min(
                                                   )),
            std::numeric_limits<double>::quiet_NaN()};
      current_statement__ = 3;
      y2 = std::vector<
             std::tuple<
               std::vector<
                 std::tuple<int,
                   std::vector<std::vector<std::vector<double>>>>>,
               double>>(5,
             std::tuple<
               std::vector<
                 std::tuple<int,
                   std::vector<std::vector<std::vector<double>>>>>,
               double>{std::vector<
                         std::tuple<int,
                           std::vector<std::vector<std::vector<double>>>>>(10,
                         std::tuple<int,
                           std::vector<std::vector<std::vector<double>>>>{
                           std::numeric_limits<int>::min(),
                           std::vector<std::vector<std::vector<double>>>(1,
                             std::vector<std::vector<double>>(2,
                               std::vector<double>(3,
                                 std::numeric_limits<double>::quiet_NaN())))}),
               std::numeric_limits<double>::quiet_NaN()});
      current_statement__ = 4;
      std::get<0>(x) = 1;
      current_statement__ = 5;
      z = std::numeric_limits<int>::min();
      current_statement__ = 5;
      z = std::get<0>(x);
      current_statement__ = 6;
      b = std::numeric_limits<int>::min();
      current_statement__ = 6;
      b = std::get<0>(x);
      current_statement__ = 7;
      c = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 7;
      c = stan::model::rvalue(
            std::get<1>(
              stan::model::rvalue(
                std::get<0>(
                  stan::model::rvalue(y2, "y2", stan::model::index_uni(1))),
                "y2[1].1", stan::model::index_uni(1))), "y2[1].1[1].2",
            stan::model::index_uni(1), stan::model::index_uni(1),
            stan::model::index_uni(1));
      current_statement__ = 8;
      d = std::tuple<int, double, std::vector<std::tuple<int, int>>>{
            std::numeric_limits<int>::min(),
            std::numeric_limits<double>::quiet_NaN(),
            std::vector<std::tuple<int, int>>(2,
              std::tuple<int, int>{std::numeric_limits<int>::min(),
                std::numeric_limits<int>::min()})};
      current_statement__ = 8;
      stan::model::assign(d,
        std::tuple<int, double, std::vector<std::tuple<int, int>>>(1, 2.5,
          std::vector<std::tuple<int, int>>{std::tuple<int, int>(1, 2),
            std::tuple<int, int>(3, 4)}), "assigning variable d");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "complex_tuples_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "complex_tuples_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "complex_tuples_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "complex_tuples_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = complex_tuples_model_namespace::complex_tuples_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return complex_tuples_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp container-promotion.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace container_promotion_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 16> locations_array__ =
  {" (found before start of program)",
  " (in 'container-promotion.stan', line 6, column 2 to column 9)",
  " (in 'container-promotion.stan', line 9, column 2 to column 14)",
  " (in 'container-promotion.stan', line 12, column 2 to column 30)",
  " (in 'container-promotion.stan', line 15, column 2 to column 23)",
  " (in 'container-promotion.stan', line 18, column 2 to column 17)",
  " (in 'container-promotion.stan', line 21, column 2 to column 31)",
  " (in 'container-promotion.stan', line 24, column 2 to column 31)",
  " (in 'container-promotion.stan', line 10, column 2 to column 14)",
  " (in 'container-promotion.stan', line 13, column 2 to column 26)",
  " (in 'container-promotion.stan', line 16, column 2 to column 25)",
  " (in 'container-promotion.stan', line 19, column 2 to column 23)",
  " (in 'container-promotion.stan', line 22, column 2 to column 50)",
  " (in 'container-promotion.stan', line 25, column 2 to column 48)",
  " (in 'container-promotion.stan', line 2, column 2 to column 23)",
  " (in 'container-promotion.stan', line 3, column 2 to column 27)"};
class container_promotion_model final : public model_base_crtp<container_promotion_model> {
 private:
  std::vector<std::vector<double>> Arr;
 public:
  ~container_promotion_model() {}
  container_promotion_model(stan::io::var_context& context__, unsigned int
                            random_seed__ = 0, std::ostream*
                            pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "container_promotion_model_namespace::container_promotion_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 14;
      Arr = std::vector<std::vector<double>>(2,
              std::vector<double>(2,
                std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 15;
      stan::model::assign(Arr,
        std::vector<std::vector<double>>{std::vector<double>{1, 2},
          std::vector<double>{3, 4.5}}, "assigning variable Arr");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1;
  }
  inline std::string model_name() const final {
    return "container_promotion_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "container_promotion_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 1;
      y = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> V =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(V,
        (Eigen::Matrix<local_scalar_t__,-1,1>(2) << 1, y).finished(),
        "assigning variable V");
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> arRV =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(2,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(2, DUMMY_VAR__));
      current_statement__ = 9;
      stan::model::assign(arRV,
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                             1, 2).finished(),
          (Eigen::Matrix<local_scalar_t__,1,-1>(2) << 3, y).finished()},
        "assigning variable arRV");
      std::vector<std::vector<local_scalar_t__>> Mar =
        std::vector<std::vector<local_scalar_t__>>(2,
          std::vector<local_scalar_t__>(2, DUMMY_VAR__));
      current_statement__ = 10;
      stan::model::assign(Mar,
        std::vector<std::vector<local_scalar_t__>>{std::vector<
                                                     local_scalar_t__>{1, 2},
          std::vector<local_scalar_t__>{3, y}}, "assigning variable Mar");
      Eigen::Matrix<local_scalar_t__,-1,-1> M =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__);
      current_statement__ = 11;
      stan::model::assign(M,
        stan::math::to_matrix(
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                               1, 2).finished(),
            (Eigen::Matrix<local_scalar_t__,1,-1>(2) << 3, y).finished()}),
        "assigning variable M");
      std::vector<std::vector<std::vector<local_scalar_t__>>> deep_Mar =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(2,
          std::vector<std::vector<local_scalar_t__>>(2,
            std::vector<local_scalar_t__>(2, DUMMY_VAR__)));
      current_statement__ = 12;
      stan::model::assign(deep_Mar,
        std::vector<std::vector<std::vector<local_scalar_t__>>>{std::vector<
                                                                  std::vector<
                                                                    local_scalar_t__>>{
                                                                  std::vector<
                                                                    local_scalar_t__>{0,
                                                                    0},
                                                                  std::vector<
                                                                    local_scalar_t__>{0,
                                                                    0}},
          std::vector<std::vector<local_scalar_t__>>{std::vector<
                                                       local_scalar_t__>{1,
                                                       2},
            std::vector<local_scalar_t__>{3, y}}},
        "assigning variable deep_Mar");
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> deep_M =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(2,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__));
      current_statement__ = 13;
      stan::model::assign(deep_M,
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>{stan::math::to_matrix(
                                                             std::vector<
                                                               Eigen::Matrix<local_scalar_t__,1,-1>>{
                                                               (Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                                  0, 0).finished(),
                                                               (Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                                  0, 0).finished()}),
          stan::math::to_matrix(
            std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                                 1, 2).finished(),
              (Eigen::Matrix<local_scalar_t__,1,-1>(2) << y, 4).finished()})},
        "assigning variable deep_M");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "container_promotion_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 1;
      y = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> V =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(V,
        (Eigen::Matrix<local_scalar_t__,-1,1>(2) << 1, y).finished(),
        "assigning variable V");
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> arRV =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(2,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(2, DUMMY_VAR__));
      current_statement__ = 9;
      stan::model::assign(arRV,
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                             1, 2).finished(),
          (Eigen::Matrix<local_scalar_t__,1,-1>(2) << 3, y).finished()},
        "assigning variable arRV");
      std::vector<std::vector<local_scalar_t__>> Mar =
        std::vector<std::vector<local_scalar_t__>>(2,
          std::vector<local_scalar_t__>(2, DUMMY_VAR__));
      current_statement__ = 10;
      stan::model::assign(Mar,
        std::vector<std::vector<local_scalar_t__>>{std::vector<
                                                     local_scalar_t__>{1, 2},
          std::vector<local_scalar_t__>{3, y}}, "assigning variable Mar");
      Eigen::Matrix<local_scalar_t__,-1,-1> M =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__);
      current_statement__ = 11;
      stan::model::assign(M,
        stan::math::to_matrix(
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                               1, 2).finished(),
            (Eigen::Matrix<local_scalar_t__,1,-1>(2) << 3, y).finished()}),
        "assigning variable M");
      std::vector<std::vector<std::vector<local_scalar_t__>>> deep_Mar =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(2,
          std::vector<std::vector<local_scalar_t__>>(2,
            std::vector<local_scalar_t__>(2, DUMMY_VAR__)));
      current_statement__ = 12;
      stan::model::assign(deep_Mar,
        std::vector<std::vector<std::vector<local_scalar_t__>>>{std::vector<
                                                                  std::vector<
                                                                    local_scalar_t__>>{
                                                                  std::vector<
                                                                    local_scalar_t__>{0,
                                                                    0},
                                                                  std::vector<
                                                                    local_scalar_t__>{0,
                                                                    0}},
          std::vector<std::vector<local_scalar_t__>>{std::vector<
                                                       local_scalar_t__>{1,
                                                       2},
            std::vector<local_scalar_t__>{3, y}}},
        "assigning variable deep_Mar");
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> deep_M =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(2,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__));
      current_statement__ = 13;
      stan::model::assign(deep_M,
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>{stan::math::to_matrix(
                                                             std::vector<
                                                               Eigen::Matrix<local_scalar_t__,1,-1>>{
                                                               (Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                                  0, 0).finished(),
                                                               (Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                                  0, 0).finished()}),
          stan::math::to_matrix(
            std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                                 1, 2).finished(),
              (Eigen::Matrix<local_scalar_t__,1,-1>(2) << y, 4).finished()})},
        "assigning variable deep_M");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "container_promotion_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double y = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      y = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,1> V =
        Eigen::Matrix<double,-1,1>::Constant(2,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,1,-1>> arRV =
        std::vector<Eigen::Matrix<double,1,-1>>(2,
          Eigen::Matrix<double,1,-1>::Constant(2,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<double>> Mar =
        std::vector<std::vector<double>>(2,
          std::vector<double>(2, std::numeric_limits<double>::quiet_NaN()));
      Eigen::Matrix<double,-1,-1> M =
        Eigen::Matrix<double,-1,-1>::Constant(2, 2,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<std::vector<std::vector<double>>> deep_Mar =
        std::vector<std::vector<std::vector<double>>>(2,
          std::vector<std::vector<double>>(2,
            std::vector<double>(2, std::numeric_limits<double>::quiet_NaN())));
      std::vector<Eigen::Matrix<double,-1,-1>> deep_M =
        std::vector<Eigen::Matrix<double,-1,-1>>(2,
          Eigen::Matrix<double,-1,-1>::Constant(2, 2,
            std::numeric_limits<double>::quiet_NaN()));
      out__.write(y);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 8;
      stan::model::assign(V,
        (Eigen::Matrix<local_scalar_t__,-1,1>(2) << 1, y).finished(),
        "assigning variable V");
      current_statement__ = 9;
      stan::model::assign(arRV,
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                             1, 2).finished(),
          (Eigen::Matrix<local_scalar_t__,1,-1>(2) << 3, y).finished()},
        "assigning variable arRV");
      current_statement__ = 10;
      stan::model::assign(Mar,
        std::vector<std::vector<local_scalar_t__>>{std::vector<
                                                     local_scalar_t__>{1, 2},
          std::vector<local_scalar_t__>{3, y}}, "assigning variable Mar");
      current_statement__ = 11;
      stan::model::assign(M,
        stan::math::to_matrix(
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                               1, 2).finished(),
            (Eigen::Matrix<local_scalar_t__,1,-1>(2) << 3, y).finished()}),
        "assigning variable M");
      current_statement__ = 12;
      stan::model::assign(deep_Mar,
        std::vector<std::vector<std::vector<local_scalar_t__>>>{std::vector<
                                                                  std::vector<
                                                                    local_scalar_t__>>{
                                                                  std::vector<
                                                                    local_scalar_t__>{0,
                                                                    0},
                                                                  std::vector<
                                                                    local_scalar_t__>{0,
                                                                    0}},
          std::vector<std::vector<local_scalar_t__>>{std::vector<
                                                       local_scalar_t__>{1,
                                                       2},
            std::vector<local_scalar_t__>{3, y}}},
        "assigning variable deep_Mar");
      current_statement__ = 13;
      stan::model::assign(deep_M,
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>{stan::math::to_matrix(
                                                             std::vector<
                                                               Eigen::Matrix<local_scalar_t__,1,-1>>{
                                                               (Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                                  0, 0).finished(),
                                                               (Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                                  0, 0).finished()}),
          stan::math::to_matrix(
            std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                                 1, 2).finished(),
              (Eigen::Matrix<local_scalar_t__,1,-1>(2) << y, 4).finished()})},
        "assigning variable deep_M");
      if (emit_transformed_parameters__) {
        out__.write(V);
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            out__.write(arRV[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            out__.write(Mar[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        out__.write(M);
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
              out__.write(deep_Mar[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
            }
          }
        }
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
              out__.write(stan::model::rvalue(deep_M, "deep_M",
                            stan::model::index_uni(sym3__),
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(sym1__)));
            }
          }
        }
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 1;
      y = in__.read<local_scalar_t__>();
      out__.write(y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "y", "double",
        std::vector<size_t>{});
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 1;
      y = context__.vals_r("y")[(1 - 1)];
      out__.write(y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"y"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"V", "arRV", "Mar", "M", "deep_Mar", "deep_M"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(2)},
             std::vector<size_t>{static_cast<size_t>(2),
               static_cast<size_t>(2)},
             std::vector<size_t>{static_cast<size_t>(2),
               static_cast<size_t>(2)},
             std::vector<size_t>{static_cast<size_t>(2),
               static_cast<size_t>(2)},
             std::vector<size_t>{static_cast<size_t>(2),
               static_cast<size_t>(2), static_cast<size_t>(2)},
             std::vector<size_t>{static_cast<size_t>(2),
               static_cast<size_t>(2), static_cast<size_t>(2)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "y");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "V" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          param_names__.emplace_back(std::string() + "arRV" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          param_names__.emplace_back(std::string() + "Mar" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          param_names__.emplace_back(std::string() + "M" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            param_names__.emplace_back(std::string() + "deep_Mar" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            param_names__.emplace_back(std::string() + "deep_M" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "y");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "V" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          param_names__.emplace_back(std::string() + "arRV" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          param_names__.emplace_back(std::string() + "Mar" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          param_names__.emplace_back(std::string() + "M" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            param_names__.emplace_back(std::string() + "deep_Mar" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            param_names__.emplace_back(std::string() + "deep_M" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"V\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"arRV\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"Mar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"M\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"deep_Mar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"deep_M\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(2) + "}},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"V\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"arRV\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"Mar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"M\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"deep_Mar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"deep_M\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(2) + "}},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * ((((((2 + (2
      * 2)) + (2 * 2)) + (2 * 2)) + (2 * (2 * 2))) + (2 * (2 * 2))));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * ((((((2 + (2
      * 2)) + (2 * 2)) + (2 * 2)) + (2 * (2 * 2))) + (2 * (2 * 2))));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = container_promotion_model_namespace::container_promotion_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return container_promotion_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp cpp-reserved-words.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace cpp_reserved_words_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 79> locations_array__ =
  {" (found before start of program)",
  " (in 'cpp-reserved-words.stan', line 35, column 2 to column 16)",
  " (in 'cpp-reserved-words.stan', line 36, column 2 to column 13)",
  " (in 'cpp-reserved-words.stan', line 37, column 2 to column 14)",
  " (in 'cpp-reserved-words.stan', line 38, column 2 to column 12)",
  " (in 'cpp-reserved-words.stan', line 39, column 2 to column 14)",
  " (in 'cpp-reserved-words.stan', line 40, column 2 to column 12)",
  " (in 'cpp-reserved-words.stan', line 41, column 2 to column 15)",
  " (in 'cpp-reserved-words.stan', line 42, column 2 to column 17)",
  " (in 'cpp-reserved-words.stan', line 43, column 2 to column 11)",
  " (in 'cpp-reserved-words.stan', line 44, column 2 to column 16)",
  " (in 'cpp-reserved-words.stan', line 45, column 2 to column 11)",
  " (in 'cpp-reserved-words.stan', line 46, column 2 to column 14)",
  " (in 'cpp-reserved-words.stan', line 47, column 2 to column 15)",
  " (in 'cpp-reserved-words.stan', line 48, column 2 to column 16)",
  " (in 'cpp-reserved-words.stan', line 49, column 2 to column 10)",
  " (in 'cpp-reserved-words.stan', line 71, column 2 to column 13)",
  " (in 'cpp-reserved-words.stan', line 72, column 2 to column 11)",
  " (in 'cpp-reserved-words.stan', line 73, column 2 to column 14)",
  " (in 'cpp-reserved-words.stan', line 74, column 2 to column 16)",
  " (in 'cpp-reserved-words.stan', line 75, column 2 to column 13)",
  " (in 'cpp-reserved-words.stan', line 76, column 2 to column 16)",
  " (in 'cpp-reserved-words.stan', line 77, column 2 to column 13)",
  " (in 'cpp-reserved-words.stan', line 78, column 2 to column 15)",
  " (in 'cpp-reserved-words.stan', line 79, column 2 to column 16)",
  " (in 'cpp-reserved-words.stan', line 80, column 2 to column 15)",
  " (in 'cpp-reserved-words.stan', line 81, column 2 to column 11)",
  " (in 'cpp-reserved-words.stan', line 82, column 2 to column 14)",
  " (in 'cpp-reserved-words.stan', line 83, column 2 to column 12)",
  " (in 'cpp-reserved-words.stan', line 84, column 2 to column 23)",
  " (in 'cpp-reserved-words.stan', line 85, column 2 to column 23)",
  " (in 'cpp-reserved-words.stan', line 86, column 2 to column 23)",
  " (in 'cpp-reserved-words.stan', line 89, column 4 to column 23)",
  " (in 'cpp-reserved-words.stan', line 90, column 4 to column 32)",
  " (in 'cpp-reserved-words.stan', line 91, column 4 to column 24)",
  " (in 'cpp-reserved-words.stan', line 92, column 4 to column 31)",
  " (in 'cpp-reserved-words.stan', line 88, column 24 to line 93, column 3)",
  " (in 'cpp-reserved-words.stan', line 88, column 2 to line 93, column 3)",
  " (in 'cpp-reserved-words.stan', line 53, column 2 to column 13)",
  " (in 'cpp-reserved-words.stan', line 54, column 2 to column 15)",
  " (in 'cpp-reserved-words.stan', line 55, column 2 to column 17)",
  " (in 'cpp-reserved-words.stan', line 56, column 2 to column 14)",
  " (in 'cpp-reserved-words.stan', line 57, column 2 to column 16)",
  " (in 'cpp-reserved-words.stan', line 58, column 2 to column 24)",
  " (in 'cpp-reserved-words.stan', line 59, column 2 to column 13)",
  " (in 'cpp-reserved-words.stan', line 60, column 2 to column 14)",
  " (in 'cpp-reserved-words.stan', line 61, column 2 to column 14)",
  " (in 'cpp-reserved-words.stan', line 62, column 2 to column 21)",
  " (in 'cpp-reserved-words.stan', line 63, column 2 to column 19)",
  " (in 'cpp-reserved-words.stan', line 64, column 2 to column 14)",
  " (in 'cpp-reserved-words.stan', line 65, column 2 to column 16)",
  " (in 'cpp-reserved-words.stan', line 66, column 2 to column 12)",
  " (in 'cpp-reserved-words.stan', line 67, column 2 to column 20)",
  " (in 'cpp-reserved-words.stan', line 20, column 2 to column 13)",
  " (in 'cpp-reserved-words.stan', line 21, column 2 to column 13)",
  " (in 'cpp-reserved-words.stan', line 22, column 2 to column 13)",
  " (in 'cpp-reserved-words.stan', line 23, column 2 to column 17)",
  " (in 'cpp-reserved-words.stan', line 24, column 2 to column 18)",
  " (in 'cpp-reserved-words.stan', line 25, column 2 to column 16)",
  " (in 'cpp-reserved-words.stan', line 26, column 2 to column 15)",
  " (in 'cpp-reserved-words.stan', line 27, column 2 to column 14)",
  " (in 'cpp-reserved-words.stan', line 28, column 2 to column 10)",
  " (in 'cpp-reserved-words.stan', line 29, column 2 to column 14)",
  " (in 'cpp-reserved-words.stan', line 30, column 2 to column 20)",
  " (in 'cpp-reserved-words.stan', line 31, column 2 to column 12)",
  " (in 'cpp-reserved-words.stan', line 2, column 23 to column 25)",
  " (in 'cpp-reserved-words.stan', line 3, column 24 to column 26)",
  " (in 'cpp-reserved-words.stan', line 5, column 4 to column 22)",
  " (in 'cpp-reserved-words.stan', line 4, column 25 to line 6, column 3)",
  " (in 'cpp-reserved-words.stan', line 7, column 30 to column 32)",
  " (in 'cpp-reserved-words.stan', line 8, column 24 to column 26)",
  " (in 'cpp-reserved-words.stan', line 9, column 28 to column 30)",
  " (in 'cpp-reserved-words.stan', line 10, column 14 to column 16)",
  " (in 'cpp-reserved-words.stan', line 11, column 13 to column 15)",
  " (in 'cpp-reserved-words.stan', line 12, column 13 to column 15)",
  " (in 'cpp-reserved-words.stan', line 13, column 14 to column 16)",
  " (in 'cpp-reserved-words.stan', line 14, column 13 to column 15)",
  " (in 'cpp-reserved-words.stan', line 15, column 17 to column 19)",
  " (in 'cpp-reserved-words.stan', line 16, column 17 to column 19)"};
template <typename T0__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
void _stan_alignas(const T0__& _stan_asm, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
void _stan_alignof(const T0__& _stan_char, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
int _stan_and(const T0__& _stan_STAN_MAJOR, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
void _stan_and_eq(const T0__& _stan_STAN_MINOR, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
void _stan_asm(const T0__& _stan_class_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
void _stan_bitand(const T0__& _stan_constexpr, std::ostream* pstream__);
void _stan_bitor(std::ostream* pstream__);
void _stan_bool(std::ostream* pstream__);
void _stan_case(std::ostream* pstream__);
void _stan_catch(std::ostream* pstream__);
void _stan_char(std::ostream* pstream__);
void _stan_char16_t(std::ostream* pstream__);
void _stan_char32_t(std::ostream* pstream__);
// void _stan_alignas(int)
template <typename T0__, stan::require_all_t<std::is_integral<T0__>>*> void
_stan_alignas(const T0__& _stan_asm, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
}
// void _stan_alignof(int)
template <typename T0__, stan::require_all_t<std::is_integral<T0__>>*> void
_stan_alignof(const T0__& _stan_char, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
}
// int _stan_and(int)
template <typename T0__, stan::require_all_t<std::is_integral<T0__>>*> int
_stan_and(const T0__& _stan_STAN_MAJOR, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 67;
    return _stan_STAN_MAJOR;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// void _stan_and_eq(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
void _stan_and_eq(const T0__& _stan_STAN_MINOR, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
}
// void _stan_asm(vector)
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
void _stan_asm(const T0__& _stan_class_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& _stan_class = stan::math::to_ref(_stan_class_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
}
// void _stan_bitand(int)
template <typename T0__, stan::require_all_t<std::is_integral<T0__>>*> void
_stan_bitand(const T0__& _stan_constexpr, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
}
// void _stan_bitor()
void _stan_bitor(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
}
// void _stan_bool()
void _stan_bool(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
}
// void _stan_case()
void _stan_case(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
}
// void _stan_catch()
void _stan_catch(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
}
// void _stan_char()
void _stan_char(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
}
// void _stan_char16_t()
void _stan_char16_t(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
}
// void _stan_char32_t()
void _stan_char32_t(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
}
class cpp_reserved_words_model final : public model_base_crtp<cpp_reserved_words_model> {
 private:
  double _stan_class;
  double _stan_compl;
  double _stan_const;
  double _stan_constexpr;
  double _stan_const_cast;
  double _stan_decltype;
  double _stan_default;
  double _stan_delete;
  double _stan_do;
  double _stan_double;
  double _stan_dynamic_cast;
  double _stan_enum;
 public:
  ~cpp_reserved_words_model() {}
  cpp_reserved_words_model(stan::io::var_context& context__, unsigned int
                           random_seed__ = 0, std::ostream*
                           pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "cpp_reserved_words_model_namespace::cpp_reserved_words_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 53;
      context__.validate_dims("data initialization", "class", "double",
        std::vector<size_t>{});
      _stan_class = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 53;
      _stan_class = context__.vals_r("class")[(1 - 1)];
      current_statement__ = 54;
      context__.validate_dims("data initialization", "compl", "double",
        std::vector<size_t>{});
      _stan_compl = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 54;
      _stan_compl = context__.vals_r("compl")[(1 - 1)];
      current_statement__ = 55;
      context__.validate_dims("data initialization", "const", "double",
        std::vector<size_t>{});
      _stan_const = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 55;
      _stan_const = context__.vals_r("const")[(1 - 1)];
      current_statement__ = 56;
      context__.validate_dims("data initialization", "constexpr", "double",
        std::vector<size_t>{});
      _stan_constexpr = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 56;
      _stan_constexpr = context__.vals_r("constexpr")[(1 - 1)];
      current_statement__ = 57;
      context__.validate_dims("data initialization", "const_cast", "double",
        std::vector<size_t>{});
      _stan_const_cast = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 57;
      _stan_const_cast = context__.vals_r("const_cast")[(1 - 1)];
      current_statement__ = 58;
      context__.validate_dims("data initialization", "decltype", "double",
        std::vector<size_t>{});
      _stan_decltype = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 58;
      _stan_decltype = context__.vals_r("decltype")[(1 - 1)];
      current_statement__ = 59;
      context__.validate_dims("data initialization", "default", "double",
        std::vector<size_t>{});
      _stan_default = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 59;
      _stan_default = context__.vals_r("default")[(1 - 1)];
      current_statement__ = 60;
      context__.validate_dims("data initialization", "delete", "double",
        std::vector<size_t>{});
      _stan_delete = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 60;
      _stan_delete = context__.vals_r("delete")[(1 - 1)];
      current_statement__ = 61;
      context__.validate_dims("data initialization", "do", "double",
        std::vector<size_t>{});
      _stan_do = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 61;
      _stan_do = context__.vals_r("do")[(1 - 1)];
      current_statement__ = 62;
      context__.validate_dims("data initialization", "double", "double",
        std::vector<size_t>{});
      _stan_double = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 62;
      _stan_double = context__.vals_r("double")[(1 - 1)];
      current_statement__ = 63;
      context__.validate_dims("data initialization", "dynamic_cast",
        "double", std::vector<size_t>{});
      _stan_dynamic_cast = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 63;
      _stan_dynamic_cast = context__.vals_r("dynamic_cast")[(1 - 1)];
      current_statement__ = 64;
      context__.validate_dims("data initialization", "enum", "double",
        std::vector<size_t>{});
      _stan_enum = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 64;
      _stan_enum = context__.vals_r("enum")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +
      1;
  }
  inline std::string model_name() const final {
    return "cpp_reserved_words_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "cpp_reserved_words_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ _stan_explicit = DUMMY_VAR__;
      current_statement__ = 1;
      _stan_explicit = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_float = DUMMY_VAR__;
      current_statement__ = 2;
      _stan_float = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_friend = DUMMY_VAR__;
      current_statement__ = 3;
      _stan_friend = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_goto = DUMMY_VAR__;
      current_statement__ = 4;
      _stan_goto = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_inline = DUMMY_VAR__;
      current_statement__ = 5;
      _stan_inline = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_long = DUMMY_VAR__;
      current_statement__ = 6;
      _stan_long = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_mutable = DUMMY_VAR__;
      current_statement__ = 7;
      _stan_mutable = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_namespace = DUMMY_VAR__;
      current_statement__ = 8;
      _stan_namespace = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_new = DUMMY_VAR__;
      current_statement__ = 9;
      _stan_new = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_noexcept = DUMMY_VAR__;
      current_statement__ = 10;
      _stan_noexcept = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_not = DUMMY_VAR__;
      current_statement__ = 11;
      _stan_not = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_not_eq = DUMMY_VAR__;
      current_statement__ = 12;
      _stan_not_eq = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_nullptr = DUMMY_VAR__;
      current_statement__ = 13;
      _stan_nullptr = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_operator = DUMMY_VAR__;
      current_statement__ = 14;
      _stan_operator = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_or = DUMMY_VAR__;
      current_statement__ = 15;
      _stan_or = in__.template read<local_scalar_t__>();
      {
        local_scalar_t__ _stan_or_eq = DUMMY_VAR__;
        local_scalar_t__ _stan_private = DUMMY_VAR__;
        local_scalar_t__ _stan_protected = DUMMY_VAR__;
        local_scalar_t__ _stan_public = DUMMY_VAR__;
        local_scalar_t__ _stan_register = DUMMY_VAR__;
        local_scalar_t__ _stan_reinterpret_cast = DUMMY_VAR__;
        local_scalar_t__ _stan_short = DUMMY_VAR__;
        local_scalar_t__ _stan_signed = DUMMY_VAR__;
        local_scalar_t__ _stan_sizeof = DUMMY_VAR__;
        local_scalar_t__ _stan_static_assert = DUMMY_VAR__;
        local_scalar_t__ _stan_static_cast = DUMMY_VAR__;
        local_scalar_t__ _stan_switch = DUMMY_VAR__;
        local_scalar_t__ _stan_template = DUMMY_VAR__;
        local_scalar_t__ _stan_this = DUMMY_VAR__;
        local_scalar_t__ _stan_thread_local = DUMMY_VAR__;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "cpp_reserved_words_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ _stan_explicit = DUMMY_VAR__;
      current_statement__ = 1;
      _stan_explicit = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_float = DUMMY_VAR__;
      current_statement__ = 2;
      _stan_float = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_friend = DUMMY_VAR__;
      current_statement__ = 3;
      _stan_friend = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_goto = DUMMY_VAR__;
      current_statement__ = 4;
      _stan_goto = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_inline = DUMMY_VAR__;
      current_statement__ = 5;
      _stan_inline = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_long = DUMMY_VAR__;
      current_statement__ = 6;
      _stan_long = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_mutable = DUMMY_VAR__;
      current_statement__ = 7;
      _stan_mutable = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_namespace = DUMMY_VAR__;
      current_statement__ = 8;
      _stan_namespace = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_new = DUMMY_VAR__;
      current_statement__ = 9;
      _stan_new = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_noexcept = DUMMY_VAR__;
      current_statement__ = 10;
      _stan_noexcept = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_not = DUMMY_VAR__;
      current_statement__ = 11;
      _stan_not = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_not_eq = DUMMY_VAR__;
      current_statement__ = 12;
      _stan_not_eq = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_nullptr = DUMMY_VAR__;
      current_statement__ = 13;
      _stan_nullptr = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_operator = DUMMY_VAR__;
      current_statement__ = 14;
      _stan_operator = in__.template read<local_scalar_t__>();
      local_scalar_t__ _stan_or = DUMMY_VAR__;
      current_statement__ = 15;
      _stan_or = in__.template read<local_scalar_t__>();
      {
        local_scalar_t__ _stan_or_eq = DUMMY_VAR__;
        local_scalar_t__ _stan_private = DUMMY_VAR__;
        local_scalar_t__ _stan_protected = DUMMY_VAR__;
        local_scalar_t__ _stan_public = DUMMY_VAR__;
        local_scalar_t__ _stan_register = DUMMY_VAR__;
        local_scalar_t__ _stan_reinterpret_cast = DUMMY_VAR__;
        local_scalar_t__ _stan_short = DUMMY_VAR__;
        local_scalar_t__ _stan_signed = DUMMY_VAR__;
        local_scalar_t__ _stan_sizeof = DUMMY_VAR__;
        local_scalar_t__ _stan_static_assert = DUMMY_VAR__;
        local_scalar_t__ _stan_static_cast = DUMMY_VAR__;
        local_scalar_t__ _stan_switch = DUMMY_VAR__;
        local_scalar_t__ _stan_template = DUMMY_VAR__;
        local_scalar_t__ _stan_this = DUMMY_VAR__;
        local_scalar_t__ _stan_thread_local = DUMMY_VAR__;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "cpp_reserved_words_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double _stan_explicit = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      _stan_explicit = in__.template read<local_scalar_t__>();
      double _stan_float = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      _stan_float = in__.template read<local_scalar_t__>();
      double _stan_friend = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      _stan_friend = in__.template read<local_scalar_t__>();
      double _stan_goto = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      _stan_goto = in__.template read<local_scalar_t__>();
      double _stan_inline = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      _stan_inline = in__.template read<local_scalar_t__>();
      double _stan_long = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 6;
      _stan_long = in__.template read<local_scalar_t__>();
      double _stan_mutable = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 7;
      _stan_mutable = in__.template read<local_scalar_t__>();
      double _stan_namespace = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 8;
      _stan_namespace = in__.template read<local_scalar_t__>();
      double _stan_new = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 9;
      _stan_new = in__.template read<local_scalar_t__>();
      double _stan_noexcept = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 10;
      _stan_noexcept = in__.template read<local_scalar_t__>();
      double _stan_not = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 11;
      _stan_not = in__.template read<local_scalar_t__>();
      double _stan_not_eq = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 12;
      _stan_not_eq = in__.template read<local_scalar_t__>();
      double _stan_nullptr = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 13;
      _stan_nullptr = in__.template read<local_scalar_t__>();
      double _stan_operator = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 14;
      _stan_operator = in__.template read<local_scalar_t__>();
      double _stan_or = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 15;
      _stan_or = in__.template read<local_scalar_t__>();
      out__.write(_stan_explicit);
      out__.write(_stan_float);
      out__.write(_stan_friend);
      out__.write(_stan_goto);
      out__.write(_stan_inline);
      out__.write(_stan_long);
      out__.write(_stan_mutable);
      out__.write(_stan_namespace);
      out__.write(_stan_new);
      out__.write(_stan_noexcept);
      out__.write(_stan_not);
      out__.write(_stan_not_eq);
      out__.write(_stan_nullptr);
      out__.write(_stan_operator);
      out__.write(_stan_or);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      double _stan_throw = std::numeric_limits<double>::quiet_NaN();
      double _stan_try = std::numeric_limits<double>::quiet_NaN();
      double _stan_typeid = std::numeric_limits<double>::quiet_NaN();
      double _stan_typename = std::numeric_limits<double>::quiet_NaN();
      double _stan_union = std::numeric_limits<double>::quiet_NaN();
      double _stan_unsigned = std::numeric_limits<double>::quiet_NaN();
      double _stan_using = std::numeric_limits<double>::quiet_NaN();
      double _stan_virtual = std::numeric_limits<double>::quiet_NaN();
      double _stan_volatile = std::numeric_limits<double>::quiet_NaN();
      double _stan_wchar_t = std::numeric_limits<double>::quiet_NaN();
      double _stan_xor = std::numeric_limits<double>::quiet_NaN();
      double _stan_xor_eq = std::numeric_limits<double>::quiet_NaN();
      double _stan_fvar = std::numeric_limits<double>::quiet_NaN();
      double _stan_STAN_MATH_MAJOR = std::numeric_limits<double>::quiet_NaN();
      double _stan_STAN_MATH_MINOR = std::numeric_limits<double>::quiet_NaN();
      double _stan_STAN_MATH_PATCH = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 37;
      for (int _stan_STAN_MAJOR = 1; _stan_STAN_MAJOR <=
           2; ++_stan_STAN_MAJOR) {
        int _stan_STAN_MINOR = std::numeric_limits<int>::min();
        current_statement__ = 32;
        _stan_STAN_MINOR = 3;
        int _stan_STAN_PATCH = std::numeric_limits<int>::min();
        current_statement__ = 33;
        _stan_STAN_PATCH = _stan_STAN_MINOR;
        current_statement__ = 34;
        _stan_alignas(_stan_STAN_PATCH, pstream__);
        current_statement__ = 35;
        _stan_STAN_MINOR = _stan_and(_stan_STAN_PATCH, pstream__);
      }
      out__.write(_stan_throw);
      out__.write(_stan_try);
      out__.write(_stan_typeid);
      out__.write(_stan_typename);
      out__.write(_stan_union);
      out__.write(_stan_unsigned);
      out__.write(_stan_using);
      out__.write(_stan_virtual);
      out__.write(_stan_volatile);
      out__.write(_stan_wchar_t);
      out__.write(_stan_xor);
      out__.write(_stan_xor_eq);
      out__.write(_stan_fvar);
      out__.write(_stan_STAN_MATH_MAJOR);
      out__.write(_stan_STAN_MATH_MINOR);
      out__.write(_stan_STAN_MATH_PATCH);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ _stan_explicit = DUMMY_VAR__;
      current_statement__ = 1;
      _stan_explicit = in__.read<local_scalar_t__>();
      out__.write(_stan_explicit);
      local_scalar_t__ _stan_float = DUMMY_VAR__;
      current_statement__ = 2;
      _stan_float = in__.read<local_scalar_t__>();
      out__.write(_stan_float);
      local_scalar_t__ _stan_friend = DUMMY_VAR__;
      current_statement__ = 3;
      _stan_friend = in__.read<local_scalar_t__>();
      out__.write(_stan_friend);
      local_scalar_t__ _stan_goto = DUMMY_VAR__;
      current_statement__ = 4;
      _stan_goto = in__.read<local_scalar_t__>();
      out__.write(_stan_goto);
      local_scalar_t__ _stan_inline = DUMMY_VAR__;
      current_statement__ = 5;
      _stan_inline = in__.read<local_scalar_t__>();
      out__.write(_stan_inline);
      local_scalar_t__ _stan_long = DUMMY_VAR__;
      current_statement__ = 6;
      _stan_long = in__.read<local_scalar_t__>();
      out__.write(_stan_long);
      local_scalar_t__ _stan_mutable = DUMMY_VAR__;
      current_statement__ = 7;
      _stan_mutable = in__.read<local_scalar_t__>();
      out__.write(_stan_mutable);
      local_scalar_t__ _stan_namespace = DUMMY_VAR__;
      current_statement__ = 8;
      _stan_namespace = in__.read<local_scalar_t__>();
      out__.write(_stan_namespace);
      local_scalar_t__ _stan_new = DUMMY_VAR__;
      current_statement__ = 9;
      _stan_new = in__.read<local_scalar_t__>();
      out__.write(_stan_new);
      local_scalar_t__ _stan_noexcept = DUMMY_VAR__;
      current_statement__ = 10;
      _stan_noexcept = in__.read<local_scalar_t__>();
      out__.write(_stan_noexcept);
      local_scalar_t__ _stan_not = DUMMY_VAR__;
      current_statement__ = 11;
      _stan_not = in__.read<local_scalar_t__>();
      out__.write(_stan_not);
      local_scalar_t__ _stan_not_eq = DUMMY_VAR__;
      current_statement__ = 12;
      _stan_not_eq = in__.read<local_scalar_t__>();
      out__.write(_stan_not_eq);
      local_scalar_t__ _stan_nullptr = DUMMY_VAR__;
      current_statement__ = 13;
      _stan_nullptr = in__.read<local_scalar_t__>();
      out__.write(_stan_nullptr);
      local_scalar_t__ _stan_operator = DUMMY_VAR__;
      current_statement__ = 14;
      _stan_operator = in__.read<local_scalar_t__>();
      out__.write(_stan_operator);
      local_scalar_t__ _stan_or = DUMMY_VAR__;
      current_statement__ = 15;
      _stan_or = in__.read<local_scalar_t__>();
      out__.write(_stan_or);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "explicit",
        "double", std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "float", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "friend", "double",
        std::vector<size_t>{});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "goto", "double",
        std::vector<size_t>{});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "inline", "double",
        std::vector<size_t>{});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "long", "double",
        std::vector<size_t>{});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "mutable",
        "double", std::vector<size_t>{});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization", "namespace",
        "double", std::vector<size_t>{});
      current_statement__ = 9;
      context__.validate_dims("parameter initialization", "new", "double",
        std::vector<size_t>{});
      current_statement__ = 10;
      context__.validate_dims("parameter initialization", "noexcept",
        "double", std::vector<size_t>{});
      current_statement__ = 11;
      context__.validate_dims("parameter initialization", "not", "double",
        std::vector<size_t>{});
      current_statement__ = 12;
      context__.validate_dims("parameter initialization", "not_eq", "double",
        std::vector<size_t>{});
      current_statement__ = 13;
      context__.validate_dims("parameter initialization", "nullptr",
        "double", std::vector<size_t>{});
      current_statement__ = 14;
      context__.validate_dims("parameter initialization", "operator",
        "double", std::vector<size_t>{});
      current_statement__ = 15;
      context__.validate_dims("parameter initialization", "or", "double",
        std::vector<size_t>{});
      local_scalar_t__ _stan_explicit = DUMMY_VAR__;
      current_statement__ = 1;
      _stan_explicit = context__.vals_r("explicit")[(1 - 1)];
      out__.write(_stan_explicit);
      local_scalar_t__ _stan_float = DUMMY_VAR__;
      current_statement__ = 2;
      _stan_float = context__.vals_r("float")[(1 - 1)];
      out__.write(_stan_float);
      local_scalar_t__ _stan_friend = DUMMY_VAR__;
      current_statement__ = 3;
      _stan_friend = context__.vals_r("friend")[(1 - 1)];
      out__.write(_stan_friend);
      local_scalar_t__ _stan_goto = DUMMY_VAR__;
      current_statement__ = 4;
      _stan_goto = context__.vals_r("goto")[(1 - 1)];
      out__.write(_stan_goto);
      local_scalar_t__ _stan_inline = DUMMY_VAR__;
      current_statement__ = 5;
      _stan_inline = context__.vals_r("inline")[(1 - 1)];
      out__.write(_stan_inline);
      local_scalar_t__ _stan_long = DUMMY_VAR__;
      current_statement__ = 6;
      _stan_long = context__.vals_r("long")[(1 - 1)];
      out__.write(_stan_long);
      local_scalar_t__ _stan_mutable = DUMMY_VAR__;
      current_statement__ = 7;
      _stan_mutable = context__.vals_r("mutable")[(1 - 1)];
      out__.write(_stan_mutable);
      local_scalar_t__ _stan_namespace = DUMMY_VAR__;
      current_statement__ = 8;
      _stan_namespace = context__.vals_r("namespace")[(1 - 1)];
      out__.write(_stan_namespace);
      local_scalar_t__ _stan_new = DUMMY_VAR__;
      current_statement__ = 9;
      _stan_new = context__.vals_r("new")[(1 - 1)];
      out__.write(_stan_new);
      local_scalar_t__ _stan_noexcept = DUMMY_VAR__;
      current_statement__ = 10;
      _stan_noexcept = context__.vals_r("noexcept")[(1 - 1)];
      out__.write(_stan_noexcept);
      local_scalar_t__ _stan_not = DUMMY_VAR__;
      current_statement__ = 11;
      _stan_not = context__.vals_r("not")[(1 - 1)];
      out__.write(_stan_not);
      local_scalar_t__ _stan_not_eq = DUMMY_VAR__;
      current_statement__ = 12;
      _stan_not_eq = context__.vals_r("not_eq")[(1 - 1)];
      out__.write(_stan_not_eq);
      local_scalar_t__ _stan_nullptr = DUMMY_VAR__;
      current_statement__ = 13;
      _stan_nullptr = context__.vals_r("nullptr")[(1 - 1)];
      out__.write(_stan_nullptr);
      local_scalar_t__ _stan_operator = DUMMY_VAR__;
      current_statement__ = 14;
      _stan_operator = context__.vals_r("operator")[(1 - 1)];
      out__.write(_stan_operator);
      local_scalar_t__ _stan_or = DUMMY_VAR__;
      current_statement__ = 15;
      _stan_or = context__.vals_r("or")[(1 - 1)];
      out__.write(_stan_or);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"explicit", "float", "friend", "goto",
                "inline", "long", "mutable", "namespace", "new", "noexcept",
                "not", "not_eq", "nullptr", "operator", "or"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      std::vector<std::string>
        temp{"throw", "try", "typeid", "typename", "union", "unsigned",
             "using", "virtual", "volatile", "wchar_t", "xor", "xor_eq",
             "fvar", "STAN_MATH_MAJOR", "STAN_MATH_MINOR", "STAN_MATH_PATCH"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "explicit");
    param_names__.emplace_back(std::string() + "float");
    param_names__.emplace_back(std::string() + "friend");
    param_names__.emplace_back(std::string() + "goto");
    param_names__.emplace_back(std::string() + "inline");
    param_names__.emplace_back(std::string() + "long");
    param_names__.emplace_back(std::string() + "mutable");
    param_names__.emplace_back(std::string() + "namespace");
    param_names__.emplace_back(std::string() + "new");
    param_names__.emplace_back(std::string() + "noexcept");
    param_names__.emplace_back(std::string() + "not");
    param_names__.emplace_back(std::string() + "not_eq");
    param_names__.emplace_back(std::string() + "nullptr");
    param_names__.emplace_back(std::string() + "operator");
    param_names__.emplace_back(std::string() + "or");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "throw");
      param_names__.emplace_back(std::string() + "try");
      param_names__.emplace_back(std::string() + "typeid");
      param_names__.emplace_back(std::string() + "typename");
      param_names__.emplace_back(std::string() + "union");
      param_names__.emplace_back(std::string() + "unsigned");
      param_names__.emplace_back(std::string() + "using");
      param_names__.emplace_back(std::string() + "virtual");
      param_names__.emplace_back(std::string() + "volatile");
      param_names__.emplace_back(std::string() + "wchar_t");
      param_names__.emplace_back(std::string() + "xor");
      param_names__.emplace_back(std::string() + "xor_eq");
      param_names__.emplace_back(std::string() + "fvar");
      param_names__.emplace_back(std::string() + "STAN_MATH_MAJOR");
      param_names__.emplace_back(std::string() + "STAN_MATH_MINOR");
      param_names__.emplace_back(std::string() + "STAN_MATH_PATCH");
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "explicit");
    param_names__.emplace_back(std::string() + "float");
    param_names__.emplace_back(std::string() + "friend");
    param_names__.emplace_back(std::string() + "goto");
    param_names__.emplace_back(std::string() + "inline");
    param_names__.emplace_back(std::string() + "long");
    param_names__.emplace_back(std::string() + "mutable");
    param_names__.emplace_back(std::string() + "namespace");
    param_names__.emplace_back(std::string() + "new");
    param_names__.emplace_back(std::string() + "noexcept");
    param_names__.emplace_back(std::string() + "not");
    param_names__.emplace_back(std::string() + "not_eq");
    param_names__.emplace_back(std::string() + "nullptr");
    param_names__.emplace_back(std::string() + "operator");
    param_names__.emplace_back(std::string() + "or");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "throw");
      param_names__.emplace_back(std::string() + "try");
      param_names__.emplace_back(std::string() + "typeid");
      param_names__.emplace_back(std::string() + "typename");
      param_names__.emplace_back(std::string() + "union");
      param_names__.emplace_back(std::string() + "unsigned");
      param_names__.emplace_back(std::string() + "using");
      param_names__.emplace_back(std::string() + "virtual");
      param_names__.emplace_back(std::string() + "volatile");
      param_names__.emplace_back(std::string() + "wchar_t");
      param_names__.emplace_back(std::string() + "xor");
      param_names__.emplace_back(std::string() + "xor_eq");
      param_names__.emplace_back(std::string() + "fvar");
      param_names__.emplace_back(std::string() + "STAN_MATH_MAJOR");
      param_names__.emplace_back(std::string() + "STAN_MATH_MINOR");
      param_names__.emplace_back(std::string() + "STAN_MATH_PATCH");
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"explicit\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"float\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"friend\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"goto\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"inline\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"long\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mutable\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"namespace\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"new\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"noexcept\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"not\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"not_eq\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"nullptr\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"operator\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"or\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"throw\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"try\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"typeid\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"typename\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"union\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"unsigned\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"using\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"virtual\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"volatile\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"wchar_t\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"xor\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"xor_eq\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"fvar\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"STAN_MATH_MAJOR\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"STAN_MATH_MINOR\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"STAN_MATH_PATCH\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"explicit\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"float\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"friend\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"goto\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"inline\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"long\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mutable\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"namespace\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"new\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"noexcept\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"not\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"not_eq\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"nullptr\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"operator\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"or\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"throw\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"try\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"typeid\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"typename\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"union\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"unsigned\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"using\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"virtual\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"volatile\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"wchar_t\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"xor\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"xor_eq\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"fvar\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"STAN_MATH_MAJOR\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"STAN_MATH_MINOR\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"STAN_MATH_PATCH\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((((((((1 + 1) + 1) + 1) + 1) + 1) + 1)
      + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities *
      ((((((((((((((((1 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
      1) + 1) + 1) + 1) + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((((((((1 + 1) + 1) + 1) + 1) + 1) + 1)
      + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities *
      ((((((((((((((((1 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
      1) + 1) + 1) + 1) + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = cpp_reserved_words_model_namespace::cpp_reserved_words_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return cpp_reserved_words_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp data_only_functions.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace data_only_functions_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 26> locations_array__ =
  {" (found before start of program)",
  " (in 'data_only_functions.stan', line 31, column 2 to column 17)",
  " (in 'data_only_functions.stan', line 34, column 2 to column 19)",
  " (in 'data_only_functions.stan', line 35, column 2 to column 24)",
  " (in 'data_only_functions.stan', line 36, column 2 to column 37)",
  " (in 'data_only_functions.stan', line 38, column 2 to column 25)",
  " (in 'data_only_functions.stan', line 39, column 2 to column 30)",
  " (in 'data_only_functions.stan', line 40, column 2 to column 43)",
  " (in 'data_only_functions.stan', line 27, column 2 to column 8)",
  " (in 'data_only_functions.stan', line 28, column 9 to column 10)",
  " (in 'data_only_functions.stan', line 28, column 12 to column 13)",
  " (in 'data_only_functions.stan', line 28, column 2 to column 17)",
  " (in 'data_only_functions.stan', line 31, column 9 to column 10)",
  " (in 'data_only_functions.stan', line 31, column 12 to column 13)",
  " (in 'data_only_functions.stan', line 3, column 4 to column 19)",
  " (in 'data_only_functions.stan', line 2, column 26 to line 4, column 3)",
  " (in 'data_only_functions.stan', line 7, column 4 to column 22)",
  " (in 'data_only_functions.stan', line 6, column 34 to line 8, column 3)",
  " (in 'data_only_functions.stan', line 11, column 4 to column 22)",
  " (in 'data_only_functions.stan', line 10, column 55 to line 12, column 3)",
  " (in 'data_only_functions.stan', line 15, column 4 to column 19)",
  " (in 'data_only_functions.stan', line 14, column 27 to line 16, column 3)",
  " (in 'data_only_functions.stan', line 19, column 4 to column 22)",
  " (in 'data_only_functions.stan', line 18, column 35 to line 20, column 3)",
  " (in 'data_only_functions.stan', line 23, column 4 to column 22)",
  " (in 'data_only_functions.stan', line 22, column 51 to line 24, column 3)"};
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
baz(const T0__& y_arg__, std::ostream* pstream__);
double
bar(const std::vector<Eigen::Matrix<double,-1,-1>>& z, std::ostream*
    pstream__);
double
foo(const std::vector<std::vector<std::vector<double>>>& x,
    const std::vector<std::vector<int>>& y, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
baz_param(const T0__& y_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
bar_param(const T0__& z, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T0__>>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T0__>>>>>,
                              stan::is_std_vector<T1__>,
                              stan::is_std_vector<stan::value_type_t<T1__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T1__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo_param(const T0__& x, const T1__& y, std::ostream* pstream__);
// real baz(data matrix)
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
baz(const T0__& y_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& y = stan::math::to_ref(y_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 14;
    return stan::model::rvalue(y, "y", stan::model::index_uni(1),
             stan::model::index_uni(1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real bar(data array[] matrix)
double
bar(const std::vector<Eigen::Matrix<double,-1,-1>>& z, std::ostream*
    pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 16;
    return stan::model::rvalue(
             stan::model::rvalue(z, "z", stan::model::index_uni(1)), "z[1]",
             stan::model::index_uni(1), stan::model::index_uni(1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(data array[,,] real, data array[,] int)
double
foo(const std::vector<std::vector<std::vector<double>>>& x,
    const std::vector<std::vector<int>>& y, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 18;
    return stan::model::rvalue(x, "x", stan::model::index_uni(1),
             stan::model::index_uni(1), stan::model::index_uni(1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real baz_param(matrix)
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
baz_param(const T0__& y_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& y = stan::math::to_ref(y_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 20;
    return stan::model::rvalue(y, "y", stan::model::index_uni(1),
             stan::model::index_uni(1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real bar_param(array[] matrix)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
bar_param(const T0__& z, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 22;
    return stan::model::rvalue(
             stan::model::rvalue(z, "z", stan::model::index_uni(1)), "z[1]",
             stan::model::index_uni(1), stan::model::index_uni(1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo_param(array[,,] real, array[,] int)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T0__>>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T0__>>>>>,
                              stan::is_std_vector<T1__>,
                              stan::is_std_vector<stan::value_type_t<T1__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T1__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo_param(const T0__& x, const T1__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 24;
    return stan::model::rvalue(x, "x", stan::model::index_uni(1),
             stan::model::index_uni(1), stan::model::index_uni(1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class data_only_functions_model final : public model_base_crtp<data_only_functions_model> {
 private:
  int N;
  Eigen::Matrix<double,-1,-1> d_data__;
  Eigen::Map<Eigen::Matrix<double,-1,-1>> d{nullptr, 0, 0};
 public:
  ~data_only_functions_model() {}
  data_only_functions_model(stan::io::var_context& context__, unsigned int
                            random_seed__ = 0, std::ostream*
                            pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "data_only_functions_model_namespace::data_only_functions_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 8;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 8;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 9;
      stan::math::validate_non_negative_index("d", "N", N);
      current_statement__ = 10;
      stan::math::validate_non_negative_index("d", "N", N);
      current_statement__ = 11;
      context__.validate_dims("data initialization", "d", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      d_data__ = Eigen::Matrix<double,-1,-1>::Constant(N, N,
                   std::numeric_limits<double>::quiet_NaN());
      new (&d) Eigen::Map<Eigen::Matrix<double,-1,-1>>(d_data__.data(), N, N);
      {
        std::vector<local_scalar_t__> d_flat__;
        current_statement__ = 11;
        d_flat__ = context__.vals_r("d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(d, d_flat__[(pos__ - 1)],
              "assigning variable d", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 12;
      stan::math::validate_non_negative_index("p", "N", N);
      current_statement__ = 13;
      stan::math::validate_non_negative_index("p", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (N * N);
  }
  inline std::string model_name() const final {
    return "data_only_functions_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "data_only_functions_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      current_statement__ = 1;
      p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N);
      {
        current_statement__ = 2;
        lp_accum__.add(baz(d, pstream__));
        current_statement__ = 3;
        lp_accum__.add(bar(std::vector<Eigen::Matrix<double,-1,-1>>{d, d},
                         pstream__));
        current_statement__ = 4;
        lp_accum__.add(foo(
                         std::vector<std::vector<std::vector<double>>>{
                           std::vector<std::vector<double>>{std::vector<
                                                              double>{1.5}}},
                         std::vector<std::vector<int>>{std::vector<int>{1, 2}},
                         pstream__));
        current_statement__ = 5;
        lp_accum__.add(baz_param(d, pstream__));
        current_statement__ = 6;
        lp_accum__.add(bar_param(
                         std::vector<Eigen::Matrix<double,-1,-1>>{d, d},
                         pstream__));
        current_statement__ = 7;
        lp_accum__.add(foo_param(
                         std::vector<std::vector<std::vector<double>>>{
                           std::vector<std::vector<double>>{std::vector<
                                                              double>{1.5}}},
                         std::vector<std::vector<int>>{std::vector<int>{1, 2}},
                         pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "data_only_functions_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      current_statement__ = 1;
      p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N);
      {
        current_statement__ = 2;
        lp_accum__.add(baz(d, pstream__));
        current_statement__ = 3;
        lp_accum__.add(bar(std::vector<Eigen::Matrix<double,-1,-1>>{d, d},
                         pstream__));
        current_statement__ = 4;
        lp_accum__.add(foo(
                         std::vector<std::vector<std::vector<double>>>{
                           std::vector<std::vector<double>>{std::vector<
                                                              double>{1.5}}},
                         std::vector<std::vector<int>>{std::vector<int>{1, 2}},
                         pstream__));
        current_statement__ = 5;
        lp_accum__.add(baz_param(d, pstream__));
        current_statement__ = 6;
        lp_accum__.add(bar_param(
                         std::vector<Eigen::Matrix<double,-1,-1>>{d, d},
                         pstream__));
        current_statement__ = 7;
        lp_accum__.add(foo_param(
                         std::vector<std::vector<std::vector<double>>>{
                           std::vector<std::vector<double>>{std::vector<
                                                              double>{1.5}}},
                         std::vector<std::vector<int>>{std::vector<int>{1, 2}},
                         pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "data_only_functions_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> p =
        Eigen::Matrix<double,-1,-1>::Constant(N, N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N);
      out__.write(p);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(p,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N),
        "assigning variable p");
      out__.write(p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "p", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_flat__;
        current_statement__ = 1;
        p_flat__ = context__.vals_r("p");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p, p_flat__[(pos__ - 1)],
              "assigning variable p", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"p"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(N),
                                                 static_cast<size_t>(N)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (N * N);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (N * N);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = data_only_functions_model_namespace::data_only_functions_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return data_only_functions_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp eight_schools_ncp.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace eight_schools_ncp_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 16> locations_array__ =
  {" (found before start of program)",
  " (in 'eight_schools_ncp.stan', line 7, column 2 to column 10)",
  " (in 'eight_schools_ncp.stan', line 8, column 2 to column 20)",
  " (in 'eight_schools_ncp.stan', line 9, column 2 to column 24)",
  " (in 'eight_schools_ncp.stan', line 12, column 2 to column 43)",
  " (in 'eight_schools_ncp.stan', line 15, column 2 to column 20)",
  " (in 'eight_schools_ncp.stan', line 16, column 2 to column 21)",
  " (in 'eight_schools_ncp.stan', line 17, column 2 to column 29)",
  " (in 'eight_schools_ncp.stan', line 18, column 2 to column 27)",
  " (in 'eight_schools_ncp.stan', line 2, column 2 to column 17)",
  " (in 'eight_schools_ncp.stan', line 3, column 8 to column 9)",
  " (in 'eight_schools_ncp.stan', line 3, column 2 to column 18)",
  " (in 'eight_schools_ncp.stan', line 4, column 8 to column 9)",
  " (in 'eight_schools_ncp.stan', line 4, column 2 to column 31)",
  " (in 'eight_schools_ncp.stan', line 9, column 9 to column 10)",
  " (in 'eight_schools_ncp.stan', line 12, column 9 to column 10)"};
class eight_schools_ncp_model final : public model_base_crtp<eight_schools_ncp_model> {
 private:
  int J;
  std::vector<double> y;
  std::vector<double> sigma;
 public:
  ~eight_schools_ncp_model() {}
  eight_schools_ncp_model(stan::io::var_context& context__, unsigned int
                          random_seed__ = 0, std::ostream*
                          pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "eight_schools_ncp_model_namespace::eight_schools_ncp_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 9;
      context__.validate_dims("data initialization", "J", "int",
        std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      current_statement__ = 9;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 9;
      stan::math::check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 10;
      stan::math::validate_non_negative_index("y", "J", J);
      current_statement__ = 11;
      context__.validate_dims("data initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(J)});
      y = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 11;
      y = context__.vals_r("y");
      current_statement__ = 12;
      stan::math::validate_non_negative_index("sigma", "J", J);
      current_statement__ = 13;
      context__.validate_dims("data initialization", "sigma", "double",
        std::vector<size_t>{static_cast<size_t>(J)});
      sigma = std::vector<double>(J,
                std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 13;
      sigma = context__.vals_r("sigma");
      current_statement__ = 13;
      stan::math::check_greater_or_equal(function__, "sigma", sigma, 0);
      current_statement__ = 14;
      stan::math::validate_non_negative_index("theta_tilde", "J", J);
      current_statement__ = 15;
      stan::math::validate_non_negative_index("theta", "J", J);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + J;
  }
  inline std::string model_name() const final {
    return "eight_schools_ncp_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "eight_schools_ncp_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      local_scalar_t__ tau = DUMMY_VAR__;
      current_statement__ = 2;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> theta_tilde =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      current_statement__ = 3;
      theta_tilde = in__.template read<
                      Eigen::Matrix<local_scalar_t__,-1,1>>(J);
      Eigen::Matrix<local_scalar_t__,-1,1> theta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(theta,
        stan::math::add(mu, stan::math::multiply(tau, theta_tilde)),
        "assigning variable theta");
      {
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu, 0, 5));
        current_statement__ = 6;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(tau, 0, 5));
        current_statement__ = 7;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(theta_tilde, 0, 1));
        current_statement__ = 8;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, theta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "eight_schools_ncp_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      local_scalar_t__ tau = DUMMY_VAR__;
      current_statement__ = 2;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> theta_tilde =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      current_statement__ = 3;
      theta_tilde = in__.template read<
                      Eigen::Matrix<local_scalar_t__,-1,1>>(J);
      Eigen::Matrix<local_scalar_t__,-1,1> theta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(theta,
        stan::math::add(mu, stan::math::multiply(tau, theta_tilde)),
        "assigning variable theta");
      {
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu, 0, 5));
        current_statement__ = 6;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(tau, 0, 5));
        current_statement__ = 7;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(theta_tilde, 0, 1));
        current_statement__ = 8;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, theta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "eight_schools_ncp_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double mu = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      double tau = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      Eigen::Matrix<double,-1,1> theta_tilde =
        Eigen::Matrix<double,-1,1>::Constant(J,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      theta_tilde = in__.template read<
                      Eigen::Matrix<local_scalar_t__,-1,1>>(J);
      Eigen::Matrix<double,-1,1> theta =
        Eigen::Matrix<double,-1,1>::Constant(J,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(mu);
      out__.write(tau);
      out__.write(theta_tilde);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 4;
      stan::model::assign(theta,
        stan::math::add(mu, stan::math::multiply(tau, theta_tilde)),
        "assigning variable theta");
      if (emit_transformed_parameters__) {
        out__.write(theta);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.read<local_scalar_t__>();
      out__.write(mu);
      local_scalar_t__ tau = DUMMY_VAR__;
      current_statement__ = 2;
      tau = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau);
      Eigen::Matrix<local_scalar_t__,-1,1> theta_tilde =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(theta_tilde,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(J),
        "assigning variable theta_tilde");
      out__.write(theta_tilde);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mu", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "tau", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "theta_tilde",
        "double", std::vector<size_t>{static_cast<size_t>(J)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = context__.vals_r("mu")[(1 - 1)];
      out__.write(mu);
      local_scalar_t__ tau = DUMMY_VAR__;
      current_statement__ = 2;
      tau = context__.vals_r("tau")[(1 - 1)];
      out__.write_free_lb(0, tau);
      Eigen::Matrix<local_scalar_t__,-1,1> theta_tilde =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> theta_tilde_flat__;
        current_statement__ = 3;
        theta_tilde_flat__ = context__.vals_r("theta_tilde");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
          stan::model::assign(theta_tilde, theta_tilde_flat__[(pos__ - 1)],
            "assigning variable theta_tilde", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(theta_tilde);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mu", "tau", "theta_tilde"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"theta"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(J)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(J)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mu");
    param_names__.emplace_back(std::string() + "tau");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      param_names__.emplace_back(std::string() + "theta_tilde" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mu");
    param_names__.emplace_back(std::string() + "tau");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      param_names__.emplace_back(std::string() + "theta_tilde" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_tilde\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_tilde\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((1 + 1) + J);
    const size_t num_transformed = emit_transformed_parameters * (J);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((1 + 1) + J);
    const size_t num_transformed = emit_transformed_parameters * (J);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = eight_schools_ncp_model_namespace::eight_schools_ncp_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return eight_schools_ncp_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp funcall-type-promotion.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace funcall_type_promotion_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 11> locations_array__ =
  {" (found before start of program)",
  " (in 'funcall-type-promotion.stan', line 16, column 2 to column 22)",
  " (in 'funcall-type-promotion.stan', line 17, column 2 to column 21)",
  " (in 'funcall-type-promotion.stan', line 18, column 2 to column 12)",
  " (in 'funcall-type-promotion.stan', line 11, column 2 to column 21)",
  " (in 'funcall-type-promotion.stan', line 12, column 2 to column 19)",
  " (in 'funcall-type-promotion.stan', line 13, column 2 to column 12)",
  " (in 'funcall-type-promotion.stan', line 3, column 4 to column 17)",
  " (in 'funcall-type-promotion.stan', line 2, column 27 to line 4, column 3)",
  " (in 'funcall-type-promotion.stan', line 7, column 4 to column 17)",
  " (in 'funcall-type-promotion.stan', line 6, column 27 to line 8, column 3)"};
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>* = nullptr>
stan::promote_args_t<T0__, T1__>
foo(const T0__& x, const T1__& y, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>* = nullptr>
void bar(const T0__& x, const T1__& y, std::ostream* pstream__);
// real foo(real, real)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>*>
stan::promote_args_t<T0__, T1__>
foo(const T0__& x, const T1__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 7;
    return (x / y);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// void bar(real, real)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>*>
void bar(const T0__& x, const T1__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 9;
    if (pstream__) {
      stan::math::stan_print(pstream__, (x / y));
      *(pstream__) << std::endl;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class funcall_type_promotion_model final : public model_base_crtp<funcall_type_promotion_model> {
 private:
  double x;
 public:
  ~funcall_type_promotion_model() {}
  funcall_type_promotion_model(stan::io::var_context& context__, unsigned int
                               random_seed__ = 0, std::ostream*
                               pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "funcall_type_promotion_model_namespace::funcall_type_promotion_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 4;
      x = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      x = foo(static_cast<double>(1), static_cast<double>(2), pstream__);
      current_statement__ = 5;
      if (pstream__) {
        stan::math::stan_print(pstream__, "x = ");
        stan::math::stan_print(pstream__, x);
        *(pstream__) << std::endl;
      }
      current_statement__ = 6;
      bar(static_cast<double>(1), static_cast<double>(2), pstream__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "funcall_type_promotion_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "funcall_type_promotion_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ x2 = DUMMY_VAR__;
      current_statement__ = 1;
      x2 = foo(static_cast<double>(1), static_cast<double>(2), pstream__);
      current_statement__ = 2;
      if (pstream__) {
        stan::math::stan_print(pstream__, "x2 = ");
        stan::math::stan_print(pstream__, x2);
        *(pstream__) << std::endl;
      }
      current_statement__ = 3;
      bar(static_cast<double>(1), static_cast<double>(2), pstream__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "funcall_type_promotion_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ x2 = DUMMY_VAR__;
      current_statement__ = 1;
      x2 = foo(static_cast<double>(1), static_cast<double>(2), pstream__);
      current_statement__ = 2;
      if (pstream__) {
        stan::math::stan_print(pstream__, "x2 = ");
        stan::math::stan_print(pstream__, x2);
        *(pstream__) << std::endl;
      }
      current_statement__ = 3;
      bar(static_cast<double>(1), static_cast<double>(2), pstream__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "funcall_type_promotion_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = funcall_type_promotion_model_namespace::funcall_type_promotion_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return funcall_type_promotion_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp mixed_type_arrays.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace mixed_type_arrays_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 6> locations_array__ =
  {" (found before start of program)",
  " (in 'mixed_type_arrays.stan', line 5, column 2 to column 19)",
  " (in 'mixed_type_arrays.stan', line 8, column 2 to column 35)",
  " (in 'mixed_type_arrays.stan', line 9, column 2 to column 45)",
  " (in 'mixed_type_arrays.stan', line 10, column 2 to column 67)",
  " (in 'mixed_type_arrays.stan', line 2, column 2 to column 18)"};
class mixed_type_arrays_model final : public model_base_crtp<mixed_type_arrays_model> {
 private:
  std::vector<double> x;
 public:
  ~mixed_type_arrays_model() {}
  mixed_type_arrays_model(stan::io::var_context& context__, unsigned int
                          random_seed__ = 0, std::ostream*
                          pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "mixed_type_arrays_model_namespace::mixed_type_arrays_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 5;
      x = std::vector<double>(3, std::numeric_limits<double>::quiet_NaN());
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 3;
  }
  inline std::string model_name() const final {
    return "mixed_type_arrays_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "mixed_type_arrays_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<local_scalar_t__> xx =
        std::vector<local_scalar_t__>(3, DUMMY_VAR__);
      current_statement__ = 1;
      xx = in__.template read<std::vector<local_scalar_t__>>(3);
      std::vector<std::vector<local_scalar_t__>> y =
        std::vector<std::vector<local_scalar_t__>>(3,
          std::vector<local_scalar_t__>(3, DUMMY_VAR__));
      current_statement__ = 2;
      stan::model::assign(y,
        std::vector<std::vector<local_scalar_t__>>{stan::math::promote_scalar<
                                                     local_scalar_t__>(x),
          xx, xx}, "assigning variable y");
      std::vector<std::vector<local_scalar_t__>> w =
        std::vector<std::vector<local_scalar_t__>>(3,
          std::vector<local_scalar_t__>(3, DUMMY_VAR__));
      current_statement__ = 3;
      stan::model::assign(w,
        std::vector<std::vector<local_scalar_t__>>{std::vector<
                                                     local_scalar_t__>{1.0,
                                                     2, 3}, xx, xx},
        "assigning variable w");
      std::vector<std::vector<local_scalar_t__>> td_arr33 =
        std::vector<std::vector<local_scalar_t__>>(3,
          std::vector<local_scalar_t__>(3, DUMMY_VAR__));
      current_statement__ = 4;
      stan::model::assign(td_arr33,
        std::vector<std::vector<double>>{std::vector<double>{1, 2, 3},
          std::vector<double>{1, 2., 3}, std::vector<double>{1., 2., 3}},
        "assigning variable td_arr33");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "mixed_type_arrays_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<local_scalar_t__> xx =
        std::vector<local_scalar_t__>(3, DUMMY_VAR__);
      current_statement__ = 1;
      xx = in__.template read<std::vector<local_scalar_t__>>(3);
      std::vector<std::vector<local_scalar_t__>> y =
        std::vector<std::vector<local_scalar_t__>>(3,
          std::vector<local_scalar_t__>(3, DUMMY_VAR__));
      current_statement__ = 2;
      stan::model::assign(y,
        std::vector<std::vector<local_scalar_t__>>{stan::math::promote_scalar<
                                                     local_scalar_t__>(x),
          xx, xx}, "assigning variable y");
      std::vector<std::vector<local_scalar_t__>> w =
        std::vector<std::vector<local_scalar_t__>>(3,
          std::vector<local_scalar_t__>(3, DUMMY_VAR__));
      current_statement__ = 3;
      stan::model::assign(w,
        std::vector<std::vector<local_scalar_t__>>{std::vector<
                                                     local_scalar_t__>{1.0,
                                                     2, 3}, xx, xx},
        "assigning variable w");
      std::vector<std::vector<local_scalar_t__>> td_arr33 =
        std::vector<std::vector<local_scalar_t__>>(3,
          std::vector<local_scalar_t__>(3, DUMMY_VAR__));
      current_statement__ = 4;
      stan::model::assign(td_arr33,
        std::vector<std::vector<double>>{std::vector<double>{1, 2, 3},
          std::vector<double>{1, 2., 3}, std::vector<double>{1., 2., 3}},
        "assigning variable td_arr33");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "mixed_type_arrays_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<double> xx =
        std::vector<double>(3, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      xx = in__.template read<std::vector<local_scalar_t__>>(3);
      std::vector<std::vector<double>> y =
        std::vector<std::vector<double>>(3,
          std::vector<double>(3, std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<double>> w =
        std::vector<std::vector<double>>(3,
          std::vector<double>(3, std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<double>> td_arr33 =
        std::vector<std::vector<double>>(3,
          std::vector<double>(3, std::numeric_limits<double>::quiet_NaN()));
      out__.write(xx);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 2;
      stan::model::assign(y,
        std::vector<std::vector<local_scalar_t__>>{stan::math::promote_scalar<
                                                     local_scalar_t__>(x),
          xx, xx}, "assigning variable y");
      current_statement__ = 3;
      stan::model::assign(w,
        std::vector<std::vector<local_scalar_t__>>{std::vector<
                                                     local_scalar_t__>{1.0,
                                                     2, 3}, xx, xx},
        "assigning variable w");
      current_statement__ = 4;
      stan::model::assign(td_arr33,
        std::vector<std::vector<double>>{std::vector<double>{1, 2, 3},
          std::vector<double>{1, 2., 3}, std::vector<double>{1., 2., 3}},
        "assigning variable td_arr33");
      if (emit_transformed_parameters__) {
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            out__.write(y[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            out__.write(w[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            out__.write(td_arr33[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      std::vector<local_scalar_t__> xx =
        std::vector<local_scalar_t__>(3, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(xx, in__.read<std::vector<local_scalar_t__>>(3),
        "assigning variable xx");
      out__.write(xx);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "xx", "double",
        std::vector<size_t>{static_cast<size_t>(3)});
      std::vector<local_scalar_t__> xx =
        std::vector<local_scalar_t__>(3, DUMMY_VAR__);
      current_statement__ = 1;
      xx = context__.vals_r("xx");
      out__.write(xx);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"xx"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"y", "w", "td_arr33"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(3)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(3),
               static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(3),
               static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(3),
               static_cast<size_t>(3)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      param_names__.emplace_back(std::string() + "xx" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          param_names__.emplace_back(std::string() + "y" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          param_names__.emplace_back(std::string() + "w" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          param_names__.emplace_back(std::string() + "td_arr33" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      param_names__.emplace_back(std::string() + "xx" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          param_names__.emplace_back(std::string() + "y" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          param_names__.emplace_back(std::string() + "w" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          param_names__.emplace_back(std::string() + "td_arr33" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"xx\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"w\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"td_arr33\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"xx\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"w\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"td_arr33\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 3;
    const size_t num_transformed = emit_transformed_parameters * ((((3 * 3) +
      (3 * 3)) + (3 * 3)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 3;
    const size_t num_transformed = emit_transformed_parameters * ((((3 * 3) +
      (3 * 3)) + (3 * 3)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = mixed_type_arrays_model_namespace::mixed_type_arrays_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return mixed_type_arrays_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp mother.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace mother_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 788> locations_array__ =
  {" (found before start of program)",
  " (in 'mother.stan', line 599, column 2 to column 14)",
  " (in 'mother.stan', line 600, column 2 to column 29)",
  " (in 'mother.stan', line 601, column 2 to column 30)",
  " (in 'mother.stan', line 602, column 2 to column 58)",
  " (in 'mother.stan', line 603, column 2 to column 51)",
  " (in 'mother.stan', line 604, column 2 to column 47)",
  " (in 'mother.stan', line 605, column 2 to column 38)",
  " (in 'mother.stan', line 606, column 2 to column 44)",
  " (in 'mother.stan', line 607, column 2 to column 27)",
  " (in 'mother.stan', line 608, column 2 to column 30)",
  " (in 'mother.stan', line 609, column 2 to column 36)",
  " (in 'mother.stan', line 610, column 2 to column 26)",
  " (in 'mother.stan', line 611, column 2 to column 38)",
  " (in 'mother.stan', line 612, column 2 to column 44)",
  " (in 'mother.stan', line 613, column 2 to column 21)",
  " (in 'mother.stan', line 614, column 2 to column 54)",
  " (in 'mother.stan', line 615, column 2 to column 23)",
  " (in 'mother.stan', line 616, column 2 to column 35)",
  " (in 'mother.stan', line 617, column 2 to column 41)",
  " (in 'mother.stan', line 618, column 2 to column 39)",
  " (in 'mother.stan', line 619, column 2 to column 36)",
  " (in 'mother.stan', line 620, column 2 to column 48)",
  " (in 'mother.stan', line 621, column 2 to column 16)",
  " (in 'mother.stan', line 622, column 2 to column 16)",
  " (in 'mother.stan', line 625, column 2 to column 39)",
  " (in 'mother.stan', line 626, column 2 to column 45)",
  " (in 'mother.stan', line 627, column 2 to column 28)",
  " (in 'mother.stan', line 628, column 2 to column 31)",
  " (in 'mother.stan', line 629, column 2 to column 37)",
  " (in 'mother.stan', line 630, column 2 to column 27)",
  " (in 'mother.stan', line 631, column 2 to column 39)",
  " (in 'mother.stan', line 632, column 2 to column 45)",
  " (in 'mother.stan', line 633, column 2 to column 22)",
  " (in 'mother.stan', line 634, column 2 to column 55)",
  " (in 'mother.stan', line 635, column 2 to column 24)",
  " (in 'mother.stan', line 636, column 2 to column 36)",
  " (in 'mother.stan', line 637, column 2 to column 42)",
  " (in 'mother.stan', line 638, column 2 to column 40)",
  " (in 'mother.stan', line 639, column 2 to column 37)",
  " (in 'mother.stan', line 640, column 2 to column 49)",
  " (in 'mother.stan', line 641, column 2 to column 20)",
  " (in 'mother.stan', line 642, column 2 to column 15)",
  " (in 'mother.stan', line 733, column 2 to column 32)",
  " (in 'mother.stan', line 734, column 2 to column 27)",
  " (in 'mother.stan', line 735, column 2 to column 39)",
  " (in 'mother.stan', line 736, column 2 to column 45)",
  " (in 'mother.stan', line 737, column 2 to column 28)",
  " (in 'mother.stan', line 738, column 2 to column 31)",
  " (in 'mother.stan', line 739, column 2 to column 37)",
  " (in 'mother.stan', line 740, column 2 to column 27)",
  " (in 'mother.stan', line 741, column 2 to column 39)",
  " (in 'mother.stan', line 742, column 2 to column 45)",
  " (in 'mother.stan', line 743, column 2 to column 55)",
  " (in 'mother.stan', line 744, column 2 to column 24)",
  " (in 'mother.stan', line 745, column 2 to column 36)",
  " (in 'mother.stan', line 746, column 2 to column 42)",
  " (in 'mother.stan', line 747, column 2 to column 40)",
  " (in 'mother.stan', line 748, column 2 to column 37)",
  " (in 'mother.stan', line 749, column 2 to column 49)",
  " (in 'mother.stan', line 750, column 2 to column 35)",
  " (in 'mother.stan', line 751, column 2 to column 37)",
  " (in 'mother.stan', line 752, column 2 to column 33)",
  " (in 'mother.stan', line 753, column 2 to column 33)",
  " (in 'mother.stan', line 754, column 2 to column 33)",
  " (in 'mother.stan', line 755, column 2 to column 34)",
  " (in 'mother.stan', line 756, column 2 to column 34)",
  " (in 'mother.stan', line 757, column 2 to column 34)",
  " (in 'mother.stan', line 758, column 2 to column 34)",
  " (in 'mother.stan', line 759, column 2 to column 30)",
  " (in 'mother.stan', line 644, column 2 to column 31)",
  " (in 'mother.stan', line 645, column 2 to column 31)",
  " (in 'mother.stan', line 646, column 2 to column 23)",
  " (in 'mother.stan', line 647, column 2 to column 23)",
  " (in 'mother.stan', line 649, column 2 to column 25)",
  " (in 'mother.stan', line 650, column 2 to column 31)",
  " (in 'mother.stan', line 651, column 2 to column 31)",
  " (in 'mother.stan', line 653, column 2 to column 27)",
  " (in 'mother.stan', line 654, column 2 to column 27)",
  " (in 'mother.stan', line 655, column 2 to column 33)",
  " (in 'mother.stan', line 657, column 2 to column 41)",
  " (in 'mother.stan', line 658, column 2 to column 36)",
  " (in 'mother.stan', line 664, column 10 to column 38)",
  " (in 'mother.stan', line 663, column 25 to line 665, column 9)",
  " (in 'mother.stan', line 663, column 8 to line 665, column 9)",
  " (in 'mother.stan', line 662, column 23 to line 666, column 7)",
  " (in 'mother.stan', line 662, column 6 to line 666, column 7)",
  " (in 'mother.stan', line 661, column 21 to line 667, column 5)",
  " (in 'mother.stan', line 661, column 4 to line 667, column 5)",
  " (in 'mother.stan', line 660, column 19 to line 668, column 3)",
  " (in 'mother.stan', line 660, column 2 to line 668, column 3)",
  " (in 'mother.stan', line 671, column 4 to column 32)",
  " (in 'mother.stan', line 670, column 2 to line 671, column 32)",
  " (in 'mother.stan', line 672, column 2 to column 29)",
  " (in 'mother.stan', line 673, column 2 to column 31)",
  " (in 'mother.stan', line 674, column 2 to column 31)",
  " (in 'mother.stan', line 676, column 2 to column 63)",
  " (in 'mother.stan', line 677, column 2 to line 678, column 31)",
  " (in 'mother.stan', line 679, column 2 to line 680, column 31)",
  " (in 'mother.stan', line 681, column 2 to column 65)",
  " (in 'mother.stan', line 682, column 2 to line 683, column 31)",
  " (in 'mother.stan', line 684, column 2 to column 67)",
  " (in 'mother.stan', line 685, column 2 to line 686, column 37)",
  " (in 'mother.stan', line 688, column 2 to column 29)",
  " (in 'mother.stan', line 689, column 2 to column 29)",
  " (in 'mother.stan', line 761, column 2 to column 39)",
  " (in 'mother.stan', line 762, column 2 to column 31)",
  " (in 'mother.stan', line 763, column 2 to column 23)",
  " (in 'mother.stan', line 764, column 2 to column 23)",
  " (in 'mother.stan', line 765, column 2 to column 25)",
  " (in 'mother.stan', line 766, column 2 to column 31)",
  " (in 'mother.stan', line 767, column 2 to column 31)",
  " (in 'mother.stan', line 769, column 2 to column 38)",
  " (in 'mother.stan', line 770, column 2 to column 31)",
  " (in 'mother.stan', line 771, column 2 to column 31)",
  " (in 'mother.stan', line 773, column 2 to column 27)",
  " (in 'mother.stan', line 774, column 2 to column 27)",
  " (in 'mother.stan', line 775, column 2 to column 33)",
  " (in 'mother.stan', line 781, column 10 to column 38)",
  " (in 'mother.stan', line 780, column 25 to line 782, column 9)",
  " (in 'mother.stan', line 780, column 8 to line 782, column 9)",
  " (in 'mother.stan', line 779, column 23 to line 783, column 7)",
  " (in 'mother.stan', line 779, column 6 to line 783, column 7)",
  " (in 'mother.stan', line 778, column 21 to line 784, column 5)",
  " (in 'mother.stan', line 778, column 4 to line 784, column 5)",
  " (in 'mother.stan', line 777, column 19 to line 785, column 3)",
  " (in 'mother.stan', line 777, column 2 to line 785, column 3)",
  " (in 'mother.stan', line 788, column 4 to column 32)",
  " (in 'mother.stan', line 787, column 2 to line 788, column 32)",
  " (in 'mother.stan', line 794, column 8 to column 49)",
  " (in 'mother.stan', line 793, column 6 to line 794, column 49)",
  " (in 'mother.stan', line 792, column 4 to line 794, column 49)",
  " (in 'mother.stan', line 791, column 2 to line 794, column 49)",
  " (in 'mother.stan', line 799, column 6 to column 60)",
  " (in 'mother.stan', line 798, column 4 to line 799, column 60)",
  " (in 'mother.stan', line 797, column 2 to line 799, column 60)",
  " (in 'mother.stan', line 801, column 2 to column 45)",
  " (in 'mother.stan', line 803, column 4 to column 37)",
  " (in 'mother.stan', line 802, column 2 to line 803, column 37)",
  " (in 'mother.stan', line 808, column 6 to column 51)",
  " (in 'mother.stan', line 807, column 4 to line 808, column 51)",
  " (in 'mother.stan', line 806, column 2 to line 808, column 51)",
  " (in 'mother.stan', line 809, column 2 to column 41)",
  " (in 'mother.stan', line 812, column 4 to column 37)",
  " (in 'mother.stan', line 811, column 2 to line 812, column 37)",
  " (in 'mother.stan', line 818, column 8 to column 68)",
  " (in 'mother.stan', line 817, column 6 to line 818, column 68)",
  " (in 'mother.stan', line 816, column 4 to line 818, column 68)",
  " (in 'mother.stan', line 815, column 2 to line 818, column 68)",
  " (in 'mother.stan', line 819, column 2 to column 50)",
  " (in 'mother.stan', line 821, column 4 to column 37)",
  " (in 'mother.stan', line 820, column 2 to line 821, column 37)",
  " (in 'mother.stan', line 823, column 2 to column 40)",
  " (in 'mother.stan', line 824, column 2 to column 42)",
  " (in 'mother.stan', line 692, column 2 to column 16)",
  " (in 'mother.stan', line 693, column 2 to column 26)",
  " (in 'mother.stan', line 694, column 2 to column 29)",
  " (in 'mother.stan', line 695, column 2 to column 24)",
  " (in 'mother.stan', line 696, column 2 to column 24)",
  " (in 'mother.stan', line 697, column 2 to column 35)",
  " (in 'mother.stan', line 699, column 2 to column 38)",
  " (in 'mother.stan', line 700, column 2 to column 38)",
  " (in 'mother.stan', line 702, column 2 to column 41)",
  " (in 'mother.stan', line 704, column 4 to column 42)",
  " (in 'mother.stan', line 705, column 4 to column 46)",
  " (in 'mother.stan', line 706, column 4 to column 46)",
  " (in 'mother.stan', line 709, column 8 to column 68)",
  " (in 'mother.stan', line 710, column 8 to column 76)",
  " (in 'mother.stan', line 711, column 8 to column 76)",
  " (in 'mother.stan', line 712, column 8 to column 65)",
  " (in 'mother.stan', line 708, column 23 to line 713, column 7)",
  " (in 'mother.stan', line 708, column 6 to line 713, column 7)",
  " (in 'mother.stan', line 707, column 21 to line 714, column 5)",
  " (in 'mother.stan', line 707, column 4 to line 714, column 5)",
  " (in 'mother.stan', line 703, column 19 to line 715, column 3)",
  " (in 'mother.stan', line 703, column 2 to line 715, column 3)",
  " (in 'mother.stan', line 718, column 6 to column 47)",
  " (in 'mother.stan', line 717, column 21 to line 719, column 5)",
  " (in 'mother.stan', line 717, column 4 to line 719, column 5)",
  " (in 'mother.stan', line 716, column 19 to line 720, column 3)",
  " (in 'mother.stan', line 716, column 2 to line 720, column 3)",
  " (in 'mother.stan', line 722, column 4 to column 47)",
  " (in 'mother.stan', line 721, column 19 to line 723, column 3)",
  " (in 'mother.stan', line 721, column 2 to line 723, column 3)",
  " (in 'mother.stan', line 724, column 2 to column 38)",
  " (in 'mother.stan', line 725, column 2 to column 38)",
  " (in 'mother.stan', line 726, column 2 to column 38)",
  " (in 'mother.stan', line 727, column 2 to column 39)",
  " (in 'mother.stan', line 728, column 2 to column 39)",
  " (in 'mother.stan', line 730, column 2 to column 53)",
  " (in 'mother.stan', line 348, column 2 to column 17)",
  " (in 'mother.stan', line 349, column 2 to column 17)",
  " (in 'mother.stan', line 350, column 2 to column 30)",
  " (in 'mother.stan', line 351, column 8 to column 9)",
  " (in 'mother.stan', line 351, column 2 to column 36)",
  " (in 'mother.stan', line 352, column 8 to column 9)",
  " (in 'mother.stan', line 352, column 11 to column 12)",
  " (in 'mother.stan', line 352, column 14 to column 15)",
  " (in 'mother.stan', line 352, column 2 to column 42)",
  " (in 'mother.stan', line 353, column 2 to column 32)",
  " (in 'mother.stan', line 354, column 8 to column 9)",
  " (in 'mother.stan', line 354, column 2 to column 29)",
  " (in 'mother.stan', line 355, column 8 to column 9)",
  " (in 'mother.stan', line 355, column 11 to column 12)",
  " (in 'mother.stan', line 355, column 14 to column 15)",
  " (in 'mother.stan', line 355, column 2 to column 35)",
  " (in 'mother.stan', line 356, column 9 to column 10)",
  " (in 'mother.stan', line 356, column 2 to column 18)",
  " (in 'mother.stan', line 357, column 8 to column 9)",
  " (in 'mother.stan', line 357, column 18 to column 19)",
  " (in 'mother.stan', line 357, column 2 to column 30)",
  " (in 'mother.stan', line 358, column 8 to column 9)",
  " (in 'mother.stan', line 358, column 11 to column 12)",
  " (in 'mother.stan', line 358, column 14 to column 15)",
  " (in 'mother.stan', line 358, column 24 to column 25)",
  " (in 'mother.stan', line 358, column 2 to column 36)",
  " (in 'mother.stan', line 359, column 13 to column 14)",
  " (in 'mother.stan', line 359, column 2 to column 26)",
  " (in 'mother.stan', line 360, column 8 to column 9)",
  " (in 'mother.stan', line 360, column 22 to column 23)",
  " (in 'mother.stan', line 360, column 2 to column 38)",
  " (in 'mother.stan', line 361, column 8 to column 9)",
  " (in 'mother.stan', line 361, column 11 to column 12)",
  " (in 'mother.stan', line 361, column 14 to column 15)",
  " (in 'mother.stan', line 361, column 28 to column 29)",
  " (in 'mother.stan', line 361, column 2 to column 44)",
  " (in 'mother.stan', line 362, column 2 to column 54)",
  " (in 'mother.stan', line 363, column 10 to column 11)",
  " (in 'mother.stan', line 363, column 2 to column 23)",
  " (in 'mother.stan', line 364, column 8 to column 9)",
  " (in 'mother.stan', line 364, column 19 to column 20)",
  " (in 'mother.stan', line 364, column 2 to column 35)",
  " (in 'mother.stan', line 365, column 8 to column 9)",
  " (in 'mother.stan', line 365, column 11 to column 12)",
  " (in 'mother.stan', line 365, column 14 to column 15)",
  " (in 'mother.stan', line 365, column 25 to column 26)",
  " (in 'mother.stan', line 365, column 2 to column 41)",
  " (in 'mother.stan', line 366, column 2 to column 39)",
  " (in 'mother.stan', line 367, column 2 to column 36)",
  " (in 'mother.stan', line 368, column 8 to column 9)",
  " (in 'mother.stan', line 368, column 2 to column 48)",
  " (in 'mother.stan', line 369, column 2 to column 12)",
  " (in 'mother.stan', line 370, column 8 to column 13)",
  " (in 'mother.stan', line 370, column 2 to column 31)",
  " (in 'mother.stan', line 371, column 8 to column 13)",
  " (in 'mother.stan', line 371, column 2 to column 37)",
  " (in 'mother.stan', line 372, column 8 to column 13)",
  " (in 'mother.stan', line 372, column 2 to column 40)",
  " (in 'mother.stan', line 373, column 2 to column 14)",
  " (in 'mother.stan', line 374, column 8 to column 13)",
  " (in 'mother.stan', line 374, column 2 to column 33)",
  " (in 'mother.stan', line 375, column 8 to column 13)",
  " (in 'mother.stan', line 375, column 2 to column 39)",
  " (in 'mother.stan', line 376, column 8 to column 13)",
  " (in 'mother.stan', line 376, column 2 to column 42)",
  " (in 'mother.stan', line 377, column 9 to column 14)",
  " (in 'mother.stan', line 377, column 16 to column 21)",
  " (in 'mother.stan', line 377, column 2 to column 32)",
  " (in 'mother.stan', line 378, column 8 to column 13)",
  " (in 'mother.stan', line 378, column 22 to column 27)",
  " (in 'mother.stan', line 378, column 29 to column 34)",
  " (in 'mother.stan', line 378, column 2 to column 51)",
  " (in 'mother.stan', line 379, column 8 to column 13)",
  " (in 'mother.stan', line 379, column 25 to column 30)",
  " (in 'mother.stan', line 379, column 32 to column 37)",
  " (in 'mother.stan', line 379, column 2 to column 57)",
  " (in 'mother.stan', line 380, column 8 to column 13)",
  " (in 'mother.stan', line 380, column 28 to column 33)",
  " (in 'mother.stan', line 380, column 35 to column 40)",
  " (in 'mother.stan', line 380, column 2 to column 60)",
  " (in 'mother.stan', line 381, column 9 to column 14)",
  " (in 'mother.stan', line 381, column 2 to column 25)",
  " (in 'mother.stan', line 382, column 8 to column 13)",
  " (in 'mother.stan', line 382, column 22 to column 27)",
  " (in 'mother.stan', line 382, column 2 to column 44)",
  " (in 'mother.stan', line 383, column 8 to column 13)",
  " (in 'mother.stan', line 383, column 25 to column 30)",
  " (in 'mother.stan', line 383, column 2 to column 50)",
  " (in 'mother.stan', line 384, column 8 to column 13)",
  " (in 'mother.stan', line 384, column 28 to column 33)",
  " (in 'mother.stan', line 384, column 2 to column 53)",
  " (in 'mother.stan', line 385, column 13 to column 18)",
  " (in 'mother.stan', line 385, column 2 to column 33)",
  " (in 'mother.stan', line 386, column 8 to column 13)",
  " (in 'mother.stan', line 386, column 26 to column 31)",
  " (in 'mother.stan', line 386, column 2 to column 52)",
  " (in 'mother.stan', line 387, column 8 to column 13)",
  " (in 'mother.stan', line 387, column 29 to column 34)",
  " (in 'mother.stan', line 387, column 2 to column 58)",
  " (in 'mother.stan', line 388, column 8 to column 13)",
  " (in 'mother.stan', line 388, column 32 to column 37)",
  " (in 'mother.stan', line 388, column 2 to column 61)",
  " (in 'mother.stan', line 391, column 2 to column 13)",
  " (in 'mother.stan', line 392, column 8 to column 9)",
  " (in 'mother.stan', line 392, column 2 to column 21)",
  " (in 'mother.stan', line 393, column 8 to column 9)",
  " (in 'mother.stan', line 393, column 2 to column 40)",
  " (in 'mother.stan', line 394, column 2 to column 15)",
  " (in 'mother.stan', line 395, column 2 to column 20)",
  " (in 'mother.stan', line 396, column 2 to column 29)",
  " (in 'mother.stan', line 397, column 2 to column 55)",
  " (in 'mother.stan', line 398, column 10 to column 11)",
  " (in 'mother.stan', line 398, column 2 to column 24)",
  " (in 'mother.stan', line 399, column 8 to column 9)",
  " (in 'mother.stan', line 399, column 19 to column 20)",
  " (in 'mother.stan', line 399, column 2 to column 36)",
  " (in 'mother.stan', line 400, column 8 to column 9)",
  " (in 'mother.stan', line 400, column 11 to column 12)",
  " (in 'mother.stan', line 400, column 14 to column 15)",
  " (in 'mother.stan', line 400, column 25 to column 26)",
  " (in 'mother.stan', line 400, column 2 to column 42)",
  " (in 'mother.stan', line 401, column 2 to column 40)",
  " (in 'mother.stan', line 402, column 2 to column 37)",
  " (in 'mother.stan', line 403, column 2 to column 14)",
  " (in 'mother.stan', line 404, column 2 to column 14)",
  " (in 'mother.stan', line 405, column 2 to column 20)",
  " (in 'mother.stan', line 406, column 2 to column 23)",
  " (in 'mother.stan', line 407, column 2 to column 23)",
  " (in 'mother.stan', line 408, column 2 to column 22)",
  " (in 'mother.stan', line 409, column 2 to column 18)",
  " (in 'mother.stan', line 410, column 2 to column 18)",
  " (in 'mother.stan', line 415, column 10 to column 38)",
  " (in 'mother.stan', line 414, column 25 to line 416, column 9)",
  " (in 'mother.stan', line 414, column 8 to line 416, column 9)",
  " (in 'mother.stan', line 413, column 23 to line 417, column 7)",
  " (in 'mother.stan', line 413, column 6 to line 417, column 7)",
  " (in 'mother.stan', line 412, column 21 to line 418, column 5)",
  " (in 'mother.stan', line 412, column 4 to line 418, column 5)",
  " (in 'mother.stan', line 411, column 19 to line 419, column 3)",
  " (in 'mother.stan', line 411, column 2 to line 419, column 3)",
  " (in 'mother.stan', line 421, column 4 to column 28)",
  " (in 'mother.stan', line 423, column 6 to column 36)",
  " (in 'mother.stan', line 426, column 10 to column 46)",
  " (in 'mother.stan', line 425, column 25 to line 427, column 9)",
  " (in 'mother.stan', line 425, column 8 to line 427, column 9)",
  " (in 'mother.stan', line 424, column 23 to line 428, column 7)",
  " (in 'mother.stan', line 424, column 6 to line 428, column 7)",
  " (in 'mother.stan', line 422, column 21 to line 429, column 5)",
  " (in 'mother.stan', line 422, column 4 to line 429, column 5)",
  " (in 'mother.stan', line 420, column 19 to line 430, column 3)",
  " (in 'mother.stan', line 420, column 2 to line 430, column 3)",
  " (in 'mother.stan', line 433, column 6 to column 42)",
  " (in 'mother.stan', line 434, column 6 to column 65)",
  " (in 'mother.stan', line 432, column 21 to line 435, column 5)",
  " (in 'mother.stan', line 432, column 4 to line 435, column 5)",
  " (in 'mother.stan', line 431, column 19 to line 436, column 3)",
  " (in 'mother.stan', line 431, column 2 to line 436, column 3)",
  " (in 'mother.stan', line 437, column 2 to column 62)",
  " (in 'mother.stan', line 438, column 2 to column 62)",
  " (in 'mother.stan', line 440, column 4 to column 11)",
  " (in 'mother.stan', line 441, column 4 to column 35)",
  " (in 'mother.stan', line 442, column 4 to line 444, column 5)",
  " (in 'mother.stan', line 443, column 6 to column 12)",
  " (in 'mother.stan', line 445, column 4 to column 40)",
  " (in 'mother.stan', line 446, column 14 to column 28)",
  " (in 'mother.stan', line 446, column 4 to line 448, column 5)",
  " (in 'mother.stan', line 447, column 6 to column 12)",
  " (in 'mother.stan', line 439, column 2 to line 449, column 3)",
  " (in 'mother.stan', line 451, column 2 to column 25)",
  " (in 'mother.stan', line 452, column 2 to column 37)",
  " (in 'mother.stan', line 453, column 2 to column 37)",
  " (in 'mother.stan', line 454, column 2 to column 39)",
  " (in 'mother.stan', line 456, column 2 to column 30)",
  " (in 'mother.stan', line 457, column 2 to column 33)",
  " (in 'mother.stan', line 459, column 2 to column 35)",
  " (in 'mother.stan', line 461, column 2 to column 29)",
  " (in 'mother.stan', line 462, column 8 to column 13)",
  " (in 'mother.stan', line 462, column 2 to column 48)",
  " (in 'mother.stan', line 463, column 8 to column 13)",
  " (in 'mother.stan', line 463, column 2 to column 54)",
  " (in 'mother.stan', line 464, column 8 to column 13)",
  " (in 'mother.stan', line 464, column 2 to column 57)",
  " (in 'mother.stan', line 465, column 9 to column 14)",
  " (in 'mother.stan', line 465, column 16 to column 21)",
  " (in 'mother.stan', line 465, column 2 to column 47)",
  " (in 'mother.stan', line 466, column 8 to column 13)",
  " (in 'mother.stan', line 466, column 22 to column 27)",
  " (in 'mother.stan', line 466, column 29 to column 34)",
  " (in 'mother.stan', line 466, column 2 to column 66)",
  " (in 'mother.stan', line 467, column 8 to column 13)",
  " (in 'mother.stan', line 467, column 25 to column 30)",
  " (in 'mother.stan', line 467, column 32 to column 37)",
  " (in 'mother.stan', line 467, column 2 to column 72)",
  " (in 'mother.stan', line 468, column 8 to column 13)",
  " (in 'mother.stan', line 468, column 28 to column 33)",
  " (in 'mother.stan', line 468, column 35 to column 40)",
  " (in 'mother.stan', line 468, column 2 to column 75)",
  " (in 'mother.stan', line 469, column 9 to column 14)",
  " (in 'mother.stan', line 469, column 2 to column 40)",
  " (in 'mother.stan', line 470, column 8 to column 13)",
  " (in 'mother.stan', line 470, column 22 to column 27)",
  " (in 'mother.stan', line 470, column 2 to column 59)",
  " (in 'mother.stan', line 471, column 8 to column 13)",
  " (in 'mother.stan', line 471, column 25 to column 30)",
  " (in 'mother.stan', line 471, column 2 to column 65)",
  " (in 'mother.stan', line 472, column 8 to column 13)",
  " (in 'mother.stan', line 472, column 28 to column 33)",
  " (in 'mother.stan', line 472, column 2 to column 68)",
  " (in 'mother.stan', line 473, column 13 to column 18)",
  " (in 'mother.stan', line 473, column 2 to column 48)",
  " (in 'mother.stan', line 474, column 8 to column 13)",
  " (in 'mother.stan', line 474, column 26 to column 31)",
  " (in 'mother.stan', line 474, column 2 to column 67)",
  " (in 'mother.stan', line 475, column 8 to column 13)",
  " (in 'mother.stan', line 475, column 29 to column 34)",
  " (in 'mother.stan', line 475, column 2 to column 73)",
  " (in 'mother.stan', line 476, column 8 to column 13)",
  " (in 'mother.stan', line 476, column 32 to column 37)",
  " (in 'mother.stan', line 476, column 2 to column 76)",
  " (in 'mother.stan', line 478, column 2 to column 41)",
  " (in 'mother.stan', line 479, column 2 to column 42)",
  " (in 'mother.stan', line 480, column 2 to column 42)",
  " (in 'mother.stan', line 481, column 2 to column 43)",
  " (in 'mother.stan', line 482, column 2 to column 53)",
  " (in 'mother.stan', line 483, column 2 to column 54)",
  " (in 'mother.stan', line 484, column 2 to column 59)",
  " (in 'mother.stan', line 485, column 2 to column 60)",
  " (in 'mother.stan', line 486, column 2 to column 59)",
  " (in 'mother.stan', line 487, column 2 to column 60)",
  " (in 'mother.stan', line 488, column 2 to column 53)",
  " (in 'mother.stan', line 489, column 2 to column 54)",
  " (in 'mother.stan', line 490, column 2 to column 59)",
  " (in 'mother.stan', line 491, column 2 to column 60)",
  " (in 'mother.stan', line 492, column 2 to column 59)",
  " (in 'mother.stan', line 493, column 2 to column 60)",
  " (in 'mother.stan', line 495, column 2 to column 54)",
  " (in 'mother.stan', line 496, column 2 to column 55)",
  " (in 'mother.stan', line 497, column 2 to column 60)",
  " (in 'mother.stan', line 498, column 2 to column 61)",
  " (in 'mother.stan', line 499, column 2 to column 60)",
  " (in 'mother.stan', line 500, column 2 to column 61)",
  " (in 'mother.stan', line 502, column 2 to column 54)",
  " (in 'mother.stan', line 503, column 2 to column 55)",
  " (in 'mother.stan', line 504, column 2 to column 60)",
  " (in 'mother.stan', line 505, column 2 to column 61)",
  " (in 'mother.stan', line 506, column 2 to column 60)",
  " (in 'mother.stan', line 507, column 2 to column 61)",
  " (in 'mother.stan', line 509, column 2 to column 59)",
  " (in 'mother.stan', line 510, column 2 to column 61)",
  " (in 'mother.stan', line 511, column 2 to column 68)",
  " (in 'mother.stan', line 512, column 2 to column 70)",
  " (in 'mother.stan', line 513, column 2 to column 68)",
  " (in 'mother.stan', line 514, column 2 to column 70)",
  " (in 'mother.stan', line 516, column 2 to column 46)",
  " (in 'mother.stan', line 517, column 2 to column 47)",
  " (in 'mother.stan', line 518, column 2 to column 62)",
  " (in 'mother.stan', line 519, column 2 to column 60)",
  " (in 'mother.stan', line 520, column 2 to column 58)",
  " (in 'mother.stan', line 521, column 2 to column 58)",
  " (in 'mother.stan', line 522, column 2 to column 59)",
  " (in 'mother.stan', line 523, column 2 to column 64)",
  " (in 'mother.stan', line 524, column 2 to column 65)",
  " (in 'mother.stan', line 525, column 2 to column 64)",
  " (in 'mother.stan', line 526, column 2 to column 65)",
  " (in 'mother.stan', line 528, column 2 to column 46)",
  " (in 'mother.stan', line 529, column 2 to column 47)",
  " (in 'mother.stan', line 530, column 2 to column 58)",
  " (in 'mother.stan', line 531, column 2 to column 59)",
  " (in 'mother.stan', line 532, column 2 to column 64)",
  " (in 'mother.stan', line 533, column 2 to column 65)",
  " (in 'mother.stan', line 534, column 2 to column 64)",
  " (in 'mother.stan', line 535, column 2 to column 65)",
  " (in 'mother.stan', line 537, column 2 to column 49)",
  " (in 'mother.stan', line 538, column 2 to column 62)",
  " (in 'mother.stan', line 539, column 2 to column 60)",
  " (in 'mother.stan', line 540, column 2 to column 67)",
  " (in 'mother.stan', line 541, column 2 to column 76)",
  " (in 'mother.stan', line 542, column 2 to column 76)",
  " (in 'mother.stan', line 544, column 2 to column 54)",
  " (in 'mother.stan', line 545, column 2 to column 55)",
  " (in 'mother.stan', line 546, column 2 to column 66)",
  " (in 'mother.stan', line 547, column 2 to column 67)",
  " (in 'mother.stan', line 548, column 2 to column 72)",
  " (in 'mother.stan', line 549, column 2 to column 73)",
  " (in 'mother.stan', line 550, column 2 to column 72)",
  " (in 'mother.stan', line 551, column 2 to column 73)",
  " (in 'mother.stan', line 553, column 2 to column 54)",
  " (in 'mother.stan', line 554, column 2 to column 55)",
  " (in 'mother.stan', line 555, column 2 to column 66)",
  " (in 'mother.stan', line 556, column 2 to column 67)",
  " (in 'mother.stan', line 557, column 2 to column 72)",
  " (in 'mother.stan', line 558, column 2 to column 73)",
  " (in 'mother.stan', line 559, column 2 to column 72)",
  " (in 'mother.stan', line 560, column 2 to column 73)",
  " (in 'mother.stan', line 562, column 2 to column 61)",
  " (in 'mother.stan', line 563, column 2 to line 564, column 60)",
  " (in 'mother.stan', line 565, column 2 to line 566, column 66)",
  " (in 'mother.stan', line 567, column 2 to line 568, column 66)",
  " (in 'mother.stan', line 570, column 2 to column 46)",
  " (in 'mother.stan', line 571, column 2 to column 47)",
  " (in 'mother.stan', line 572, column 2 to column 62)",
  " (in 'mother.stan', line 573, column 2 to column 60)",
  " (in 'mother.stan', line 574, column 2 to column 58)",
  " (in 'mother.stan', line 575, column 2 to column 59)",
  " (in 'mother.stan', line 576, column 2 to column 64)",
  " (in 'mother.stan', line 577, column 2 to column 65)",
  " (in 'mother.stan', line 578, column 2 to column 64)",
  " (in 'mother.stan', line 579, column 2 to column 65)",
  " (in 'mother.stan', line 581, column 2 to column 46)",
  " (in 'mother.stan', line 582, column 2 to column 47)",
  " (in 'mother.stan', line 583, column 2 to column 58)",
  " (in 'mother.stan', line 584, column 2 to column 59)",
  " (in 'mother.stan', line 585, column 2 to column 64)",
  " (in 'mother.stan', line 586, column 2 to column 65)",
  " (in 'mother.stan', line 587, column 2 to column 64)",
  " (in 'mother.stan', line 588, column 2 to column 65)",
  " (in 'mother.stan', line 590, column 2 to column 49)",
  " (in 'mother.stan', line 591, column 2 to column 67)",
  " (in 'mother.stan', line 592, column 2 to column 76)",
  " (in 'mother.stan', line 593, column 2 to column 76)",
  " (in 'mother.stan', line 595, column 2 to column 26)",
  " (in 'mother.stan', line 596, column 2 to column 43)",
  " (in 'mother.stan', line 605, column 8 to column 9)",
  " (in 'mother.stan', line 606, column 8 to column 9)",
  " (in 'mother.stan', line 606, column 11 to column 12)",
  " (in 'mother.stan', line 606, column 14 to column 15)",
  " (in 'mother.stan', line 607, column 18 to column 19)",
  " (in 'mother.stan', line 608, column 8 to column 9)",
  " (in 'mother.stan', line 608, column 18 to column 19)",
  " (in 'mother.stan', line 609, column 8 to column 9)",
  " (in 'mother.stan', line 609, column 11 to column 12)",
  " (in 'mother.stan', line 609, column 14 to column 15)",
  " (in 'mother.stan', line 609, column 24 to column 25)",
  " (in 'mother.stan', line 610, column 13 to column 14)",
  " (in 'mother.stan', line 611, column 8 to column 9)",
  " (in 'mother.stan', line 611, column 22 to column 23)",
  " (in 'mother.stan', line 612, column 8 to column 9)",
  " (in 'mother.stan', line 612, column 11 to column 12)",
  " (in 'mother.stan', line 612, column 14 to column 15)",
  " (in 'mother.stan', line 612, column 28 to column 29)",
  " (in 'mother.stan', line 615, column 10 to column 11)",
  " (in 'mother.stan', line 616, column 8 to column 9)",
  " (in 'mother.stan', line 616, column 19 to column 20)",
  " (in 'mother.stan', line 617, column 8 to column 9)",
  " (in 'mother.stan', line 617, column 11 to column 12)",
  " (in 'mother.stan', line 617, column 14 to column 15)",
  " (in 'mother.stan', line 617, column 25 to column 26)",
  " (in 'mother.stan', line 618, column 22 to column 23)",
  " (in 'mother.stan', line 619, column 22 to column 23)",
  " (in 'mother.stan', line 620, column 8 to column 9)",
  " (in 'mother.stan', line 620, column 31 to column 32)",
  " (in 'mother.stan', line 625, column 8 to column 9)",
  " (in 'mother.stan', line 626, column 8 to column 9)",
  " (in 'mother.stan', line 626, column 11 to column 12)",
  " (in 'mother.stan', line 626, column 14 to column 15)",
  " (in 'mother.stan', line 627, column 18 to column 19)",
  " (in 'mother.stan', line 628, column 8 to column 9)",
  " (in 'mother.stan', line 628, column 18 to column 19)",
  " (in 'mother.stan', line 629, column 8 to column 9)",
  " (in 'mother.stan', line 629, column 11 to column 12)",
  " (in 'mother.stan', line 629, column 14 to column 15)",
  " (in 'mother.stan', line 629, column 24 to column 25)",
  " (in 'mother.stan', line 630, column 13 to column 14)",
  " (in 'mother.stan', line 631, column 8 to column 9)",
  " (in 'mother.stan', line 631, column 22 to column 23)",
  " (in 'mother.stan', line 632, column 8 to column 9)",
  " (in 'mother.stan', line 632, column 11 to column 12)",
  " (in 'mother.stan', line 632, column 14 to column 15)",
  " (in 'mother.stan', line 632, column 28 to column 29)",
  " (in 'mother.stan', line 635, column 10 to column 11)",
  " (in 'mother.stan', line 636, column 8 to column 9)",
  " (in 'mother.stan', line 636, column 19 to column 20)",
  " (in 'mother.stan', line 637, column 8 to column 9)",
  " (in 'mother.stan', line 637, column 11 to column 12)",
  " (in 'mother.stan', line 637, column 14 to column 15)",
  " (in 'mother.stan', line 637, column 25 to column 26)",
  " (in 'mother.stan', line 640, column 8 to column 9)",
  " (in 'mother.stan', line 735, column 8 to column 9)",
  " (in 'mother.stan', line 736, column 8 to column 9)",
  " (in 'mother.stan', line 736, column 11 to column 12)",
  " (in 'mother.stan', line 736, column 14 to column 15)",
  " (in 'mother.stan', line 737, column 18 to column 19)",
  " (in 'mother.stan', line 738, column 8 to column 9)",
  " (in 'mother.stan', line 738, column 18 to column 19)",
  " (in 'mother.stan', line 739, column 8 to column 9)",
  " (in 'mother.stan', line 739, column 11 to column 12)",
  " (in 'mother.stan', line 739, column 14 to column 15)",
  " (in 'mother.stan', line 739, column 24 to column 25)",
  " (in 'mother.stan', line 740, column 13 to column 14)",
  " (in 'mother.stan', line 741, column 8 to column 9)",
  " (in 'mother.stan', line 741, column 22 to column 23)",
  " (in 'mother.stan', line 742, column 8 to column 9)",
  " (in 'mother.stan', line 742, column 11 to column 12)",
  " (in 'mother.stan', line 742, column 14 to column 15)",
  " (in 'mother.stan', line 742, column 28 to column 29)",
  " (in 'mother.stan', line 744, column 10 to column 11)",
  " (in 'mother.stan', line 745, column 8 to column 9)",
  " (in 'mother.stan', line 745, column 19 to column 20)",
  " (in 'mother.stan', line 746, column 8 to column 9)",
  " (in 'mother.stan', line 746, column 11 to column 12)",
  " (in 'mother.stan', line 746, column 14 to column 15)",
  " (in 'mother.stan', line 746, column 25 to column 26)",
  " (in 'mother.stan', line 749, column 8 to column 9)",
  " (in 'mother.stan', line 12, column 6 to column 15)",
  " (in 'mother.stan', line 11, column 4 to line 12, column 15)",
  " (in 'mother.stan', line 13, column 4 to column 26)",
  " (in 'mother.stan', line 10, column 17 to line 14, column 3)",
  " (in 'mother.stan', line 18, column 4 to column 23)",
  " (in 'mother.stan', line 19, column 4 to column 19)",
  " (in 'mother.stan', line 20, column 4 to column 38)",
  " (in 'mother.stan', line 21, column 4 to column 16)",
  " (in 'mother.stan', line 17, column 64 to line 22, column 3)",
  " (in 'mother.stan', line 25, column 4 to column 15)",
  " (in 'mother.stan', line 24, column 18 to line 26, column 3)",
  " (in 'mother.stan', line 29, column 4 to column 15)",
  " (in 'mother.stan', line 28, column 24 to line 30, column 3)",
  " (in 'mother.stan', line 33, column 4 to column 15)",
  " (in 'mother.stan', line 32, column 32 to line 34, column 3)",
  " (in 'mother.stan', line 37, column 4 to column 15)",
  " (in 'mother.stan', line 36, column 36 to line 38, column 3)",
  " (in 'mother.stan', line 41, column 4 to column 15)",
  " (in 'mother.stan', line 40, column 36 to line 42, column 3)",
  " (in 'mother.stan', line 45, column 4 to column 15)",
  " (in 'mother.stan', line 44, column 37 to line 46, column 3)",
  " (in 'mother.stan', line 48, column 4 to column 33)",
  " (in 'mother.stan', line 47, column 36 to line 49, column 3)",
  " (in 'mother.stan', line 52, column 4 to column 36)",
  " (in 'mother.stan', line 53, column 4 to column 27)",
  " (in 'mother.stan', line 51, column 30 to line 54, column 3)",
  " (in 'mother.stan', line 58, column 14 to column 20)",
  " (in 'mother.stan', line 58, column 4 to column 20)",
  " (in 'mother.stan', line 59, column 14 to column 23)",
  " (in 'mother.stan', line 59, column 4 to column 23)",
  " (in 'mother.stan', line 63, column 6 to column 12)",
  " (in 'mother.stan', line 62, column 4 to line 63, column 12)",
  " (in 'mother.stan', line 65, column 6 to column 15)",
  " (in 'mother.stan', line 64, column 4 to line 65, column 15)",
  " (in 'mother.stan', line 69, column 6 to column 12)",
  " (in 'mother.stan', line 70, column 6 to column 12)",
  " (in 'mother.stan', line 71, column 6 to column 12)",
  " (in 'mother.stan', line 68, column 14 to line 72, column 5)",
  " (in 'mother.stan', line 68, column 4 to line 72, column 5)",
  " (in 'mother.stan', line 81, column 8 to column 14)",
  " (in 'mother.stan', line 79, column 8 to column 14)",
  " (in 'mother.stan', line 78, column 11 to line 81, column 14)",
  " (in 'mother.stan', line 77, column 8 to column 14)",
  " (in 'mother.stan', line 76, column 6 to line 81, column 14)",
  " (in 'mother.stan', line 75, column 14 to line 82, column 5)",
  " (in 'mother.stan', line 75, column 4 to line 82, column 5)",
  " (in 'mother.stan', line 85, column 24 to column 30)",
  " (in 'mother.stan', line 85, column 14 to column 30)",
  " (in 'mother.stan', line 85, column 4 to column 30)",
  " (in 'mother.stan', line 90, column 8 to column 14)",
  " (in 'mother.stan', line 89, column 6 to line 90, column 14)",
  " (in 'mother.stan', line 88, column 14 to line 91, column 5)",
  " (in 'mother.stan', line 88, column 4 to line 91, column 5)",
  " (in 'mother.stan', line 95, column 6 to column 25)",
  " (in 'mother.stan', line 96, column 6 to column 12)",
  " (in 'mother.stan', line 97, column 6 to line 100, column 7)",
  " (in 'mother.stan', line 98, column 8 to column 14)",
  " (in 'mother.stan', line 99, column 8 to column 14)",
  " (in 'mother.stan', line 101, column 6 to line 104, column 7)",
  " (in 'mother.stan', line 102, column 8 to column 14)",
  " (in 'mother.stan', line 103, column 8 to column 17)",
  " (in 'mother.stan', line 105, column 6 to line 111, column 7)",
  " (in 'mother.stan', line 106, column 8 to line 109, column 9)",
  " (in 'mother.stan', line 107, column 10 to column 16)",
  " (in 'mother.stan', line 108, column 10 to column 16)",
  " (in 'mother.stan', line 110, column 8 to column 14)",
  " (in 'mother.stan', line 94, column 14 to line 112, column 5)",
  " (in 'mother.stan', line 94, column 4 to line 112, column 5)",
  " (in 'mother.stan', line 116, column 6 to column 13)",
  " (in 'mother.stan', line 117, column 6 to column 22)",
  " (in 'mother.stan', line 118, column 6 to line 121, column 7)",
  " (in 'mother.stan', line 119, column 8 to column 14)",
  " (in 'mother.stan', line 120, column 8 to column 14)",
  " (in 'mother.stan', line 122, column 6 to line 125, column 7)",
  " (in 'mother.stan', line 123, column 8 to column 16)",
  " (in 'mother.stan', line 124, column 8 to column 17)",
  " (in 'mother.stan', line 115, column 14 to line 126, column 5)",
  " (in 'mother.stan', line 115, column 4 to line 126, column 5)",
  " (in 'mother.stan', line 130, column 6 to column 13)",
  " (in 'mother.stan', line 131, column 6 to column 19)",
  " (in 'mother.stan', line 132, column 6 to line 135, column 7)",
  " (in 'mother.stan', line 133, column 8 to column 14)",
  " (in 'mother.stan', line 134, column 8 to column 14)",
  " (in 'mother.stan', line 136, column 6 to line 139, column 7)",
  " (in 'mother.stan', line 137, column 8 to column 16)",
  " (in 'mother.stan', line 138, column 8 to column 17)",
  " (in 'mother.stan', line 129, column 14 to line 140, column 5)",
  " (in 'mother.stan', line 129, column 4 to line 140, column 5)",
  " (in 'mother.stan', line 144, column 6 to column 13)",
  " (in 'mother.stan', line 145, column 6 to column 23)",
  " (in 'mother.stan', line 146, column 6 to line 149, column 7)",
  " (in 'mother.stan', line 147, column 8 to column 14)",
  " (in 'mother.stan', line 148, column 8 to column 14)",
  " (in 'mother.stan', line 150, column 6 to line 153, column 7)",
  " (in 'mother.stan', line 151, column 8 to column 16)",
  " (in 'mother.stan', line 152, column 8 to column 17)",
  " (in 'mother.stan', line 143, column 14 to line 154, column 5)",
  " (in 'mother.stan', line 143, column 4 to line 154, column 5)",
  " (in 'mother.stan', line 158, column 6 to column 12)",
  " (in 'mother.stan', line 159, column 6 to column 12)",
  " (in 'mother.stan', line 161, column 8 to column 14)",
  " (in 'mother.stan', line 162, column 8 to column 14)",
  " (in 'mother.stan', line 163, column 8 to column 14)",
  " (in 'mother.stan', line 160, column 6 to line 164, column 7)",
  " (in 'mother.stan', line 157, column 14 to line 165, column 5)",
  " (in 'mother.stan', line 157, column 4 to line 165, column 5)",
  " (in 'mother.stan', line 167, column 4 to column 13)",
  " (in 'mother.stan', line 56, column 19 to line 168, column 3)",
  " (in 'mother.stan', line 171, column 4 to column 20)",
  " (in 'mother.stan', line 172, column 4 to column 10)",
  " (in 'mother.stan', line 173, column 4 to line 174, column 12)",
  " (in 'mother.stan', line 174, column 6 to column 12)",
  " (in 'mother.stan', line 175, column 4 to column 13)",
  " (in 'mother.stan', line 170, column 19 to line 176, column 3)",
  " (in 'mother.stan', line 179, column 4 to column 27)",
  " (in 'mother.stan', line 178, column 36 to line 180, column 3)",
  " (in 'mother.stan', line 183, column 4 to column 24)",
  " (in 'mother.stan', line 182, column 22 to line 184, column 3)",
  " (in 'mother.stan', line 187, column 4 to column 54)",
  " (in 'mother.stan', line 186, column 29 to line 188, column 3)",
  " (in 'mother.stan', line 191, column 4 to column 18)",
  " (in 'mother.stan', line 192, column 4 to column 19)",
  " (in 'mother.stan', line 193, column 4 to column 26)",
  " (in 'mother.stan', line 194, column 4 to column 38)",
  " (in 'mother.stan', line 196, column 6 to line 197, column 23)",
  " (in 'mother.stan', line 195, column 4 to line 197, column 23)",
  " (in 'mother.stan', line 199, column 6 to line 200, column 23)",
  " (in 'mother.stan', line 198, column 4 to line 200, column 23)",
  " (in 'mother.stan', line 201, column 4 to column 32)",
  " (in 'mother.stan', line 190, column 59 to line 202, column 3)",
  " (in 'mother.stan', line 206, column 4 to column 22)",
  " (in 'mother.stan', line 205, column 66 to line 207, column 3)",
  " (in 'mother.stan', line 210, column 4 to column 14)",
  " (in 'mother.stan', line 209, column 66 to line 211, column 3)",
  " (in 'mother.stan', line 213, column 4 to column 14)",
  " (in 'mother.stan', line 212, column 78 to line 214, column 3)",
  " (in 'mother.stan', line 217, column 11 to column 20)",
  " (in 'mother.stan', line 217, column 22 to column 31)",
  " (in 'mother.stan', line 217, column 4 to column 35)",
  " (in 'mother.stan', line 218, column 4 to column 12)",
  " (in 'mother.stan', line 219, column 4 to column 16)",
  " (in 'mother.stan', line 220, column 4 to column 24)",
  " (in 'mother.stan', line 221, column 4 to column 13)",
  " (in 'mother.stan', line 216, column 49 to line 222, column 3)",
  " (in 'mother.stan', line 226, column 4 to column 16)",
  " (in 'mother.stan', line 225, column 63 to line 227, column 3)",
  " (in 'mother.stan', line 232, column 4 to column 14)",
  " (in 'mother.stan', line 231, column 62 to line 233, column 3)",
  " (in 'mother.stan', line 239, column 4 to column 14)",
  " (in 'mother.stan', line 238, column 58 to line 240, column 3)",
  " (in 'mother.stan', line 246, column 4 to column 14)",
  " (in 'mother.stan', line 245, column 59 to line 247, column 3)",
  " (in 'mother.stan', line 252, column 4 to column 14)",
  " (in 'mother.stan', line 251, column 63 to line 253, column 3)",
  " (in 'mother.stan', line 259, column 4 to column 14)",
  " (in 'mother.stan', line 258, column 59 to line 260, column 3)",
  " (in 'mother.stan', line 266, column 4 to column 14)",
  " (in 'mother.stan', line 265, column 60 to line 267, column 3)",
  " (in 'mother.stan', line 273, column 4 to column 14)",
  " (in 'mother.stan', line 272, column 33 to line 274, column 3)",
  " (in 'mother.stan', line 280, column 4 to column 14)",
  " (in 'mother.stan', line 279, column 61 to line 281, column 3)",
  " (in 'mother.stan', line 287, column 4 to column 14)",
  " (in 'mother.stan', line 286, column 62 to line 288, column 3)",
  " (in 'mother.stan', line 294, column 4 to column 15)",
  " (in 'mother.stan', line 293, column 34 to line 295, column 3)",
  " (in 'mother.stan', line 301, column 4 to column 15)",
  " (in 'mother.stan', line 300, column 62 to line 302, column 3)",
  " (in 'mother.stan', line 308, column 4 to column 15)",
  " (in 'mother.stan', line 307, column 63 to line 309, column 3)",
  " (in 'mother.stan', line 311, column 4 to column 10)",
  " (in 'mother.stan', line 312, column 4 to column 11)",
  " (in 'mother.stan', line 313, column 4 to column 25)",
  " (in 'mother.stan', line 314, column 4 to column 40)",
  " (in 'mother.stan', line 315, column 4 to column 27)",
  " (in 'mother.stan', line 310, column 15 to line 316, column 3)",
  " (in 'mother.stan', line 318, column 4 to line 319, column 45)",
  " (in 'mother.stan', line 317, column 18 to line 320, column 3)",
  " (in 'mother.stan', line 322, column 4 to column 44)",
  " (in 'mother.stan', line 321, column 18 to line 323, column 3)",
  " (in 'mother.stan', line 325, column 4 to column 33)",
  " (in 'mother.stan', line 326, column 4 to column 13)",
  " (in 'mother.stan', line 324, column 27 to line 327, column 3)",
  " (in 'mother.stan', line 329, column 4 to column 57)",
  " (in 'mother.stan', line 330, column 4 to column 30)",
  " (in 'mother.stan', line 328, column 27 to line 331, column 3)",
  " (in 'mother.stan', line 334, column 4 to column 18)",
  " (in 'mother.stan', line 335, column 4 to column 25)",
  " (in 'mother.stan', line 336, column 4 to column 25)",
  " (in 'mother.stan', line 337, column 4 to column 15)",
  " (in 'mother.stan', line 333, column 45 to line 338, column 3)",
  " (in 'mother.stan', line 342, column 4 to column 19)",
  " (in 'mother.stan', line 343, column 4 to column 18)",
  " (in 'mother.stan', line 344, column 4 to column 16)",
  " (in 'mother.stan', line 341, column 41 to line 345, column 3)"};
template <typename T0__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
int foo(const T0__& n, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_std_vector<T1__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T1__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T1__>>>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>>* = nullptr>
std::vector<
  stan::promote_args_t<T0__, stan::base_type_t<T1__>,
    stan::base_type_t<T2__>>>
sho(const T0__& t, const T1__& y, const T2__& theta,
    const std::vector<double>& x, const std::vector<int>& x_int,
    std::ostream* pstream__);
double foo_bar0(std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__> foo_bar1(const T0__& x, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>* = nullptr>
stan::promote_args_t<T0__, T1__>
foo_bar2(const T0__& x, const T1__& y, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>* = nullptr>
stan::promote_args_t<T1__>
foo_lpmf(const T0__& y, const T1__& lambda, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>* = nullptr>
stan::promote_args_t<T1__>
foo_lcdf(const T0__& y, const T1__& lambda, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>* = nullptr>
stan::promote_args_t<T1__>
foo_lccdf(const T0__& y, const T1__& lambda, std::ostream* pstream__);
template <typename T0__, typename T1__, typename RNG,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>* = nullptr>
stan::promote_args_t<T0__, T1__>
foo_rng(const T0__& mu, const T1__& sigma, RNG& base_rng__, std::ostream*
        pstream__);
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
void
unit_normal_lp(const T0__& u, T_lp__& lp__, T_lp_accum__& lp_accum__,
               std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
int foo_1(const T0__& a, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
int foo_2(const T0__& a, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              std::is_integral<T1__>>* = nullptr>
std::vector<stan::promote_args_t<T0__>>
foo_3(const T0__& t, const T1__& n, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__>
foo_lp(const T0__& x, T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream*
       pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>>* = nullptr>
void foo_4(const T0__& x, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>>* = nullptr>
stan::promote_args_t<T0__, T1__, T2__, T3__>
relative_diff(const T0__& x, const T1__& y, const T2__& max_, const T3__&
              min_, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,1>
foo_5(const T0__& shared_params_arg__, const T1__& job_params_arg__,
      const std::vector<double>& data_r, const std::vector<int>& data_i,
      std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::math::disjunction<stan::is_autodiff<T4__>,
                                                      std::is_floating_point<T4__>>>* = nullptr>
stan::promote_args_t<T0__, T1__, T2__, T3__, T4__>
foo_five_args(const T0__& x1, const T1__& x2, const T2__& x3, const T3__& x4,
              const T4__& x5, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T1__, typename T2__,
          typename T3__, typename T4__, typename T5__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::math::disjunction<stan::is_autodiff<T4__>,
                                                      std::is_floating_point<T4__>>,
                              stan::math::disjunction<stan::is_autodiff<T5__>,
                                                      std::is_floating_point<T5__>>>* = nullptr>
stan::promote_args_t<T0__, T1__, T2__, T3__, T4__,
  stan::promote_args_t<T5__>>
foo_five_args_lp(const T0__& x1, const T1__& x2, const T2__& x3, const T3__&
                 x4, const T4__& x5, const T5__& x6, T_lp__& lp__,
                 T_lp_accum__& lp_accum__, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              std::is_integral<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
covsqrt2corsqrt(const T0__& mat_arg__, const T1__& invert, std::ostream*
                pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
void
f0(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
int
f1(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
std::vector<int>
f2(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
std::vector<std::vector<int>>
f3(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
stan::promote_args_t<T3__, stan::base_type_t<T4__>, stan::base_type_t<T5__>,
  stan::base_type_t<T6__>, stan::base_type_t<T7__>,
  stan::promote_args_t<stan::base_type_t<T8__>, stan::base_type_t<T9__>,
    stan::base_type_t<T10__>, stan::base_type_t<T11__>>>
f4(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
std::vector<
  stan::promote_args_t<T3__, stan::base_type_t<T4__>,
    stan::base_type_t<T5__>, stan::base_type_t<T6__>,
    stan::base_type_t<T7__>,
    stan::promote_args_t<stan::base_type_t<T8__>, stan::base_type_t<T9__>,
      stan::base_type_t<T10__>, stan::base_type_t<T11__>>>>
f5(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
std::vector<
  std::vector<
    stan::promote_args_t<T3__, stan::base_type_t<T4__>,
      stan::base_type_t<T5__>, stan::base_type_t<T6__>,
      stan::base_type_t<T7__>,
      stan::promote_args_t<stan::base_type_t<T8__>, stan::base_type_t<T9__>,
        stan::base_type_t<T10__>, stan::base_type_t<T11__>>>>>
f6(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T3__, stan::base_type_t<T4__>,
                stan::base_type_t<T5__>, stan::base_type_t<T6__>,
                stan::base_type_t<T7__>,
                stan::promote_args_t<stan::base_type_t<T8__>,
                  stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                  stan::base_type_t<T11__>>>,-1,1>
f7(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
std::vector<
  Eigen::Matrix<stan::promote_args_t<T3__, stan::base_type_t<T4__>,
                  stan::base_type_t<T5__>, stan::base_type_t<T6__>,
                  stan::base_type_t<T7__>,
                  stan::promote_args_t<stan::base_type_t<T8__>,
                    stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                    stan::base_type_t<T11__>>>,-1,1>>
f8(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
std::vector<
  std::vector<
    Eigen::Matrix<stan::promote_args_t<T3__, stan::base_type_t<T4__>,
                    stan::base_type_t<T5__>, stan::base_type_t<T6__>,
                    stan::base_type_t<T7__>,
                    stan::promote_args_t<stan::base_type_t<T8__>,
                      stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                      stan::base_type_t<T11__>>>,-1,1>>>
f9(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T3__, stan::base_type_t<T4__>,
                stan::base_type_t<T5__>, stan::base_type_t<T6__>,
                stan::base_type_t<T7__>,
                stan::promote_args_t<stan::base_type_t<T8__>,
                  stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                  stan::base_type_t<T11__>>>,-1,-1>
f10(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
    const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
    const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__&
    a12, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
std::vector<
  Eigen::Matrix<stan::promote_args_t<T3__, stan::base_type_t<T4__>,
                  stan::base_type_t<T5__>, stan::base_type_t<T6__>,
                  stan::base_type_t<T7__>,
                  stan::promote_args_t<stan::base_type_t<T8__>,
                    stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                    stan::base_type_t<T11__>>>,-1,-1>>
f11(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
    const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
    const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__&
    a12, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>* = nullptr>
std::vector<
  std::vector<
    Eigen::Matrix<stan::promote_args_t<T3__, stan::base_type_t<T4__>,
                    stan::base_type_t<T5__>, stan::base_type_t<T6__>,
                    stan::base_type_t<T7__>,
                    stan::promote_args_t<stan::base_type_t<T8__>,
                      stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                      stan::base_type_t<T11__>>>,-1,-1>>>
f12(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
    const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
    const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__&
    a12, std::ostream* pstream__);
void foo_6(std::ostream* pstream__);
Eigen::Matrix<double,-1,-1> matfoo(std::ostream* pstream__);
Eigen::Matrix<double,-1,1> vecfoo(std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T0__>,-1,1>
vecmufoo(const T0__& mu, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T0__>,-1,1>
vecmubar(const T0__& mu, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              std::is_integral<stan::value_type_t<T3__>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>, stan::base_type_t<T2__>>,-1,1>
algebra_system(const T0__& x_arg__, const T1__& y_arg__, const T2__& dat,
               const T3__& dat_int, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,1>
binomialf(const T0__& phi_arg__, const T1__& theta_arg__,
          const std::vector<double>& x_r, const std::vector<int>& x_i,
          std::ostream* pstream__);
struct algebra_system_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_col_vector<T0__>,
                                stan::is_vt_not_complex<T0__>,
                                stan::is_col_vector<T1__>,
                                stan::is_vt_not_complex<T1__>,
                                stan::is_std_vector<T2__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T2__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T2__>>>,
                                stan::is_std_vector<T3__>,
                                std::is_integral<stan::value_type_t<T3__>>>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                  stan::base_type_t<T1__>, stan::base_type_t<T2__>>,-1,1>
  operator()(const T0__& x, const T1__& y, const T2__& dat, const T3__&
             dat_int, std::ostream* pstream__) const {
    return algebra_system(x, y, dat, dat_int, pstream__);
  }
};
struct binomialf_functor__ {
  template <typename T0__, typename T1__,
            stan::require_all_t<stan::is_col_vector<T0__>,
                                stan::is_vt_not_complex<T0__>,
                                stan::is_col_vector<T1__>,
                                stan::is_vt_not_complex<T1__>>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                  stan::base_type_t<T1__>>,-1,1>
  operator()(const T0__& phi, const T1__& theta, const std::vector<double>&
             x_r, const std::vector<int>& x_i, std::ostream* pstream__) const {
    return binomialf(phi, theta, x_r, x_i, pstream__);
  }
};
// int foo(int)
template <typename T0__, stan::require_all_t<std::is_integral<T0__>>*> int
foo(const T0__& n, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 594;
    if (stan::math::logical_eq(n, 0)) {
      current_statement__ = 593;
      return 1;
    }
    current_statement__ = 595;
    return (n * foo((n - 1), pstream__));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* array[] real
   sho(real, array[] real, array[] real, data array[] real, data array[] int)
 */
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_std_vector<T1__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T1__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T1__>>>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>>*>
std::vector<
  stan::promote_args_t<T0__, stan::base_type_t<T1__>,
    stan::base_type_t<T2__>>>
sho(const T0__& t, const T1__& y, const T2__& theta,
    const std::vector<double>& x, const std::vector<int>& x_int,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
                             stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    std::vector<local_scalar_t__> dydt =
      std::vector<local_scalar_t__>(2, DUMMY_VAR__);
    current_statement__ = 598;
    stan::model::assign(dydt,
      stan::model::rvalue(y, "y", stan::model::index_uni(2)),
      "assigning variable dydt", stan::model::index_uni(1));
    current_statement__ = 599;
    stan::model::assign(dydt,
      (-(stan::model::rvalue(y, "y", stan::model::index_uni(1))) -
      (stan::model::rvalue(theta, "theta", stan::model::index_uni(1)) *
      stan::model::rvalue(y, "y", stan::model::index_uni(2)))),
      "assigning variable dydt", stan::model::index_uni(2));
    current_statement__ = 600;
    return dydt;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo_bar0()
double foo_bar0(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 602;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo_bar1(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__> foo_bar1(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 604;
    return 1.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo_bar2(real, real)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>*>
stan::promote_args_t<T0__, T1__>
foo_bar2(const T0__& x, const T1__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 606;
    return 2.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo_lpmf(int, real)
template <bool propto__, typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>*>
stan::promote_args_t<T1__>
foo_lpmf(const T0__& y, const T1__& lambda, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 608;
    return 1.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo_lcdf(int, real)
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>*>
stan::promote_args_t<T1__>
foo_lcdf(const T0__& y, const T1__& lambda, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 610;
    return 1.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo_lccdf(int, real)
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>*>
stan::promote_args_t<T1__>
foo_lccdf(const T0__& y, const T1__& lambda, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 612;
    return 1.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo_rng(real, real)
template <typename T0__, typename T1__, typename RNG,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>*>
stan::promote_args_t<T0__, T1__>
foo_rng(const T0__& mu, const T1__& sigma, RNG& base_rng__, std::ostream*
        pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 614;
    return stan::math::normal_rng(mu, sigma, base_rng__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// void unit_normal_lp(real)
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
void
unit_normal_lp(const T0__& u, T_lp__& lp__, T_lp_accum__& lp_accum__,
               std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 616;
    lp_accum__.add(stan::math::normal_lpdf<false>(u, 0, 1));
    current_statement__ = 617;
    lp_accum__.add(stan::math::uniform_lpdf<propto__>(u, -(100), 100));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// int foo_1(int)
template <typename T0__, stan::require_all_t<std::is_integral<T0__>>*> int
foo_1(const T0__& a, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 620;
    while (1) {
      break;
    }
    current_statement__ = 622;
    while (0) {
      continue;
    }
    current_statement__ = 624;
    for (int i = 1; i <= 10; ++i) {
      break;
    }
    current_statement__ = 626;
    for (int i = 1; i <= 10; ++i) {
      continue;
    }
    current_statement__ = 631;
    while (1) {
      int b = std::numeric_limits<int>::min();
      current_statement__ = 628;
      b = 5;
      break;
    }
    current_statement__ = 638;
    while (1) {
      current_statement__ = 636;
      if (0) {
        break;
      } else {
        current_statement__ = 634;
        if (1) {
          break;
        } else {
          break;
        }
      }
    }
    current_statement__ = 641;
    while (1) {
      current_statement__ = 640;
      while (0) {
        break;
      }
    }
    current_statement__ = 645;
    while (1) {
      current_statement__ = 643;
      for (int i = 1; i <= 10; ++i) {
        break;
      }
    }
    current_statement__ = 660;
    while (1) {
      std::vector<std::vector<int>> vs =
        std::vector<std::vector<int>>(2,
          std::vector<int>(3, std::numeric_limits<int>::min()));
      int z = std::numeric_limits<int>::min();
      current_statement__ = 648;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        std::vector<int> v;
        current_statement__ = 648;
        stan::model::assign(v, vs[(sym1__ - 1)], "assigning variable v");
        current_statement__ = 649;
        z = 0;
        break;
      }
      current_statement__ = 651;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        std::vector<int> v;
        current_statement__ = 651;
        stan::model::assign(v, vs[(sym1__ - 1)], "assigning variable v");
        current_statement__ = 652;
        z = 0;
        continue;
      }
      current_statement__ = 654;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        std::vector<int> v;
        current_statement__ = 654;
        stan::model::assign(v, vs[(sym1__ - 1)], "assigning variable v");
        current_statement__ = 655;
        for (int sym1__ = 1; sym1__ <= stan::math::size(v); ++sym1__) {
          int vv;
          current_statement__ = 655;
          vv = v[(sym1__ - 1)];
          current_statement__ = 656;
          z = 0;
          break;
        }
        current_statement__ = 658;
        z = 1;
      }
    }
    current_statement__ = 670;
    while (1) {
      local_scalar_t__ z = DUMMY_VAR__;
      Eigen::Matrix<local_scalar_t__,-1,-1> vs =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 3, DUMMY_VAR__);
      current_statement__ = 663;
      for (int sym1__ = 1; sym1__ <= stan::math::rows(vs); ++sym1__) {
        current_statement__ = 663;
        for (int sym2__ = 1; sym2__ <=
             stan::math::size(
               stan::model::rvalue(vs, "vs", stan::model::index_uni(sym1__))); ++sym2__) {
          local_scalar_t__ v;
          current_statement__ = 663;
          v = stan::model::rvalue(vs, "vs", stan::model::index_uni(sym1__),
                stan::model::index_uni(sym2__));
          current_statement__ = 664;
          z = 0;
          break;
        }
      }
      current_statement__ = 666;
      for (int sym1__ = 1; sym1__ <= stan::math::rows(vs); ++sym1__) {
        current_statement__ = 666;
        for (int sym2__ = 1; sym2__ <=
             stan::math::size(
               stan::model::rvalue(vs, "vs", stan::model::index_uni(sym1__))); ++sym2__) {
          local_scalar_t__ v;
          current_statement__ = 666;
          v = stan::model::rvalue(vs, "vs", stan::model::index_uni(sym1__),
                stan::model::index_uni(sym2__));
          current_statement__ = 667;
          z = 3.1;
          continue;
        }
      }
    }
    current_statement__ = 680;
    while (1) {
      local_scalar_t__ z = DUMMY_VAR__;
      Eigen::Matrix<local_scalar_t__,-1,1> vs =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 673;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        local_scalar_t__ v;
        current_statement__ = 673;
        v = vs[(sym1__ - 1)];
        current_statement__ = 674;
        z = 0;
        break;
      }
      current_statement__ = 676;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        local_scalar_t__ v;
        current_statement__ = 676;
        v = vs[(sym1__ - 1)];
        current_statement__ = 677;
        z = 3.2;
        continue;
      }
    }
    current_statement__ = 690;
    while (1) {
      local_scalar_t__ z = DUMMY_VAR__;
      Eigen::Matrix<local_scalar_t__,1,-1> vs =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 683;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        local_scalar_t__ v;
        current_statement__ = 683;
        v = vs[(sym1__ - 1)];
        current_statement__ = 684;
        z = 0;
        break;
      }
      current_statement__ = 686;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        local_scalar_t__ v;
        current_statement__ = 686;
        v = vs[(sym1__ - 1)];
        current_statement__ = 687;
        z = 3.3;
        continue;
      }
    }
    current_statement__ = 698;
    while (1) {
      int b = std::numeric_limits<int>::min();
      current_statement__ = 692;
      b = 5;
      {
        int c = std::numeric_limits<int>::min();
        current_statement__ = 694;
        c = 6;
        break;
      }
    }
    current_statement__ = 699;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// int foo_2(int)
template <typename T0__, stan::require_all_t<std::is_integral<T0__>>*> int
foo_2(const T0__& a, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    std::vector<int> vs =
      std::vector<int>(2, std::numeric_limits<int>::min());
    int y = std::numeric_limits<int>::min();
    current_statement__ = 703;
    for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
      int v;
      current_statement__ = 703;
      v = vs[(sym1__ - 1)];
      current_statement__ = 704;
      y = v;
    }
    current_statement__ = 705;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// array[] real foo_3(real, int)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              std::is_integral<T1__>>*>
std::vector<stan::promote_args_t<T0__>>
foo_3(const T0__& t, const T1__& n, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 707;
    return stan::math::rep_array(t, n);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo_lp(real)
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__>
foo_lp(const T0__& x, T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream*
       pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 709;
    return (x + stan::math::get_lp(lp__, lp_accum__));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// void foo_4(array[] real)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>>*>
void foo_4(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 711;
    std::stringstream errmsg_stream__;
    stan::math::stan_print(&errmsg_stream__, "user-specified rejection");
    stan::math::stan_print(&errmsg_stream__,
      stan::model::rvalue(x, "x", stan::model::index_uni(1)));
    stan::math::stan_print(&errmsg_stream__, "; ");
    stan::math::stan_print(&errmsg_stream__, x);
    throw std::domain_error(errmsg_stream__.str());
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real relative_diff(real, real, real, real)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>>*>
stan::promote_args_t<T0__, T1__, T2__, T3__>
relative_diff(const T0__& x, const T1__& y, const T2__& max_, const T3__&
              min_, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ abs_diff = DUMMY_VAR__;
    local_scalar_t__ avg_scale = DUMMY_VAR__;
    current_statement__ = 715;
    abs_diff = stan::math::abs((x - y));
    current_statement__ = 716;
    avg_scale = ((stan::math::abs(x) + stan::math::abs(y)) / 2);
    current_statement__ = 718;
    if (stan::math::logical_gt((abs_diff / avg_scale), max_)) {
      current_statement__ = 717;
      std::stringstream errmsg_stream__;
      stan::math::stan_print(&errmsg_stream__,
        "user-specified rejection, difference above ");
      stan::math::stan_print(&errmsg_stream__, max_);
      stan::math::stan_print(&errmsg_stream__, " x:");
      stan::math::stan_print(&errmsg_stream__, x);
      stan::math::stan_print(&errmsg_stream__, " y:");
      stan::math::stan_print(&errmsg_stream__, y);
      throw std::domain_error(errmsg_stream__.str());
    }
    current_statement__ = 720;
    if (stan::math::logical_lt((abs_diff / avg_scale), min_)) {
      current_statement__ = 719;
      std::stringstream errmsg_stream__;
      stan::math::stan_print(&errmsg_stream__,
        "user-specified rejection, difference below ");
      stan::math::stan_print(&errmsg_stream__, min_);
      stan::math::stan_print(&errmsg_stream__, " x:");
      stan::math::stan_print(&errmsg_stream__, x);
      stan::math::stan_print(&errmsg_stream__, " y:");
      stan::math::stan_print(&errmsg_stream__, y);
      throw std::domain_error(errmsg_stream__.str());
    }
    current_statement__ = 721;
    return (abs_diff / avg_scale);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector foo_5(vector, vector, data array[] real, data array[] int)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,1>
foo_5(const T0__& shared_params_arg__, const T1__& job_params_arg__,
      const std::vector<double>& data_r, const std::vector<int>& data_i,
      std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& shared_params = stan::math::to_ref(shared_params_arg__);
  const auto& job_params = stan::math::to_ref(job_params_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 723;
    return stan::math::promote_scalar<local_scalar_t__>(
             (Eigen::Matrix<double,-1,1>(3) << 1, 2, 3).finished());
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo_five_args(real, real, real, real, real)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::math::disjunction<stan::is_autodiff<T4__>,
                                                      std::is_floating_point<T4__>>>*>
stan::promote_args_t<T0__, T1__, T2__, T3__, T4__>
foo_five_args(const T0__& x1, const T1__& x2, const T2__& x3, const T3__& x4,
              const T4__& x5, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__, T4__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 725;
    return x1;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo_five_args_lp(real, real, real, real, real, real)
template <bool propto__, typename T0__, typename T1__, typename T2__,
          typename T3__, typename T4__, typename T5__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::math::disjunction<stan::is_autodiff<T4__>,
                                                      std::is_floating_point<T4__>>,
                              stan::math::disjunction<stan::is_autodiff<T5__>,
                                                      std::is_floating_point<T5__>>>*>
stan::promote_args_t<T0__, T1__, T2__, T3__, T4__,
  stan::promote_args_t<T5__>>
foo_five_args_lp(const T0__& x1, const T1__& x2, const T2__& x3, const T3__&
                 x4, const T4__& x5, const T5__& x6, T_lp__& lp__,
                 T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__, T4__,
                             stan::promote_args_t<T5__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 727;
    return x1;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// matrix covsqrt2corsqrt(matrix, int)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              std::is_integral<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
covsqrt2corsqrt(const T0__& mat_arg__, const T1__& invert, std::ostream*
                pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& mat = stan::math::to_ref(mat_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 729;
    stan::math::validate_non_negative_index("o", "rows(mat)",
      stan::math::rows(mat));
    current_statement__ = 730;
    stan::math::validate_non_negative_index("o", "cols(mat)",
      stan::math::cols(mat));
    Eigen::Matrix<local_scalar_t__,-1,-1> o =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(stan::math::rows(mat),
        stan::math::cols(mat), DUMMY_VAR__);
    current_statement__ = 732;
    stan::model::assign(o, mat, "assigning variable o");
    current_statement__ = 733;
    stan::model::assign(o,
      stan::model::deep_copy(
        stan::model::rvalue(o, "o", stan::model::index_uni(2))),
      "assigning variable o", stan::model::index_uni(1));
    current_statement__ = 734;
    stan::model::assign(o,
      stan::model::deep_copy(
        stan::model::rvalue(o, "o", stan::model::index_min_max(1, 2))),
      "assigning variable o", stan::model::index_min_max(3, 4));
    current_statement__ = 735;
    return o;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* void
   f0(int, array[] int, array[,] int, real, array[] real, array[,] real,
      vector, array[] vector, array[,] vector, matrix, array[] matrix,
      array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
void
f0(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 737;
    if (pstream__) {
      stan::math::stan_print(pstream__, "hi");
      *(pstream__) << std::endl;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* int
   f1(int, array[] int, array[,] int, real, array[] real, array[,] real,
      vector, array[] vector, array[,] vector, matrix, array[] matrix,
      array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
int
f1(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 739;
    return a1;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* array[] int
   f2(int, array[] int, array[,] int, real, array[] real, array[,] real,
      vector, array[] vector, array[,] vector, matrix, array[] matrix,
      array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
std::vector<int>
f2(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 741;
    return a2;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* array[,] int
   f3(int, array[] int, array[,] int, real, array[] real, array[,] real,
      vector, array[] vector, array[,] vector, matrix, array[] matrix,
      array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
std::vector<std::vector<int>>
f3(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 743;
    return a3;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* real
   f4(int, array[] int, array[,] int, real, array[] real, array[,] real,
      vector, array[] vector, array[,] vector, matrix, array[] matrix,
      array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
stan::promote_args_t<T3__, stan::base_type_t<T4__>, stan::base_type_t<T5__>,
  stan::base_type_t<T6__>, stan::base_type_t<T7__>,
  stan::promote_args_t<stan::base_type_t<T8__>, stan::base_type_t<T9__>,
    stan::base_type_t<T10__>, stan::base_type_t<T11__>>>
f4(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 745;
    return a4;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* array[] real
   f5(int, array[] int, array[,] int, real, array[] real, array[,] real,
      vector, array[] vector, array[,] vector, matrix, array[] matrix,
      array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
std::vector<
  stan::promote_args_t<T3__, stan::base_type_t<T4__>,
    stan::base_type_t<T5__>, stan::base_type_t<T6__>,
    stan::base_type_t<T7__>,
    stan::promote_args_t<stan::base_type_t<T8__>, stan::base_type_t<T9__>,
      stan::base_type_t<T10__>, stan::base_type_t<T11__>>>>
f5(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 747;
    return a5;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* array[,] real
   f6(int, array[] int, array[,] int, real, array[] real, array[,] real,
      vector, array[] vector, array[,] vector, matrix, array[] matrix,
      array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
std::vector<
  std::vector<
    stan::promote_args_t<T3__, stan::base_type_t<T4__>,
      stan::base_type_t<T5__>, stan::base_type_t<T6__>,
      stan::base_type_t<T7__>,
      stan::promote_args_t<stan::base_type_t<T8__>, stan::base_type_t<T9__>,
        stan::base_type_t<T10__>, stan::base_type_t<T11__>>>>>
f6(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 749;
    return a6;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* vector
   f7(int, array[] int, array[,] int, real, array[] real, array[,] real,
      vector, array[] vector, array[,] vector, matrix, array[] matrix,
      array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
Eigen::Matrix<stan::promote_args_t<T3__, stan::base_type_t<T4__>,
                stan::base_type_t<T5__>, stan::base_type_t<T6__>,
                stan::base_type_t<T7__>,
                stan::promote_args_t<stan::base_type_t<T8__>,
                  stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                  stan::base_type_t<T11__>>>,-1,1>
f7(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 751;
    return a7;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* array[] vector
   f8(int, array[] int, array[,] int, real, array[] real, array[,] real,
      vector, array[] vector, array[,] vector, matrix, array[] matrix,
      array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
std::vector<
  Eigen::Matrix<stan::promote_args_t<T3__, stan::base_type_t<T4__>,
                  stan::base_type_t<T5__>, stan::base_type_t<T6__>,
                  stan::base_type_t<T7__>,
                  stan::promote_args_t<stan::base_type_t<T8__>,
                    stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                    stan::base_type_t<T11__>>>,-1,1>>
f8(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 753;
    return a8;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* array[,] vector
   f9(int, array[] int, array[,] int, real, array[] real, array[,] real,
      vector, array[] vector, array[,] vector, matrix, array[] matrix,
      array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
std::vector<
  std::vector<
    Eigen::Matrix<stan::promote_args_t<T3__, stan::base_type_t<T4__>,
                    stan::base_type_t<T5__>, stan::base_type_t<T6__>,
                    stan::base_type_t<T7__>,
                    stan::promote_args_t<stan::base_type_t<T8__>,
                      stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                      stan::base_type_t<T11__>>>,-1,1>>>
f9(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
   const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
   const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 755;
    return a9;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* matrix
   f10(int, array[] int, array[,] int, real, array[] real, array[,] real,
       vector, array[] vector, array[,] vector, matrix, array[] matrix,
       array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
Eigen::Matrix<stan::promote_args_t<T3__, stan::base_type_t<T4__>,
                stan::base_type_t<T5__>, stan::base_type_t<T6__>,
                stan::base_type_t<T7__>,
                stan::promote_args_t<stan::base_type_t<T8__>,
                  stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                  stan::base_type_t<T11__>>>,-1,-1>
f10(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
    const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
    const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__&
    a12, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 757;
    return a10;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* array[] matrix
   f11(int, array[] int, array[,] int, real, array[] real, array[,] real,
       vector, array[] vector, array[,] vector, matrix, array[] matrix,
       array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
std::vector<
  Eigen::Matrix<stan::promote_args_t<T3__, stan::base_type_t<T4__>,
                  stan::base_type_t<T5__>, stan::base_type_t<T6__>,
                  stan::base_type_t<T7__>,
                  stan::promote_args_t<stan::base_type_t<T8__>,
                    stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                    stan::base_type_t<T11__>>>,-1,-1>>
f11(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
    const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
    const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__&
    a12, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 759;
    return a11;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* array[,] matrix
   f12(int, array[] int, array[,] int, real, array[] real, array[,] real,
       vector, array[] vector, array[,] vector, matrix, array[] matrix,
       array[,] matrix)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::is_std_vector<T1__>,
                              std::is_integral<stan::value_type_t<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::is_std_vector<stan::value_type_t<T2__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T2__>>>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>,
                              stan::is_std_vector<T4__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T4__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T4__>>>,
                              stan::is_std_vector<T5__>,
                              stan::is_std_vector<stan::value_type_t<T5__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T5__>>>>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_std_vector<T7__>,
                              stan::is_col_vector<stan::value_type_t<T7__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T7__>>,
                              stan::is_std_vector<T8__>,
                              stan::is_std_vector<stan::value_type_t<T8__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T8__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T8__>>>,
                              stan::is_eigen_matrix_dynamic<T9__>,
                              stan::is_vt_not_complex<T9__>,
                              stan::is_std_vector<T10__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>>*>
std::vector<
  std::vector<
    Eigen::Matrix<stan::promote_args_t<T3__, stan::base_type_t<T4__>,
                    stan::base_type_t<T5__>, stan::base_type_t<T6__>,
                    stan::base_type_t<T7__>,
                    stan::promote_args_t<stan::base_type_t<T8__>,
                      stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                      stan::base_type_t<T11__>>>,-1,-1>>>
f12(const T0__& a1, const T1__& a2, const T2__& a3, const T3__& a4,
    const T4__& a5, const T5__& a6, const T6__& a7_arg__, const T7__& a8,
    const T8__& a9, const T9__& a10_arg__, const T10__& a11, const T11__&
    a12, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a7 = stan::math::to_ref(a7_arg__);
  const auto& a10 = stan::math::to_ref(a10_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 761;
    return a12;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// void foo_6()
void foo_6(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int a = std::numeric_limits<int>::min();
    local_scalar_t__ b = DUMMY_VAR__;
    std::vector<std::vector<local_scalar_t__>> c =
      std::vector<std::vector<local_scalar_t__>>(20,
        std::vector<local_scalar_t__>(30, DUMMY_VAR__));
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> ar_mat =
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(60,
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(70,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(40, 50,
            DUMMY_VAR__)));
    current_statement__ = 767;
    stan::model::assign(ar_mat, b, "assigning variable ar_mat",
      stan::model::index_uni(1), stan::model::index_uni(1),
      stan::model::index_uni(1), stan::model::index_uni(1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// matrix matfoo()
Eigen::Matrix<double,-1,-1> matfoo(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 769;
    return stan::math::to_matrix(
             std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(10) <<
                                                                  1, 2, 3, 4,
                                                                 5, 6, 7, 8,
                                                                 9, 10).finished(),
               (Eigen::Matrix<local_scalar_t__,1,-1>(10) << 1, 2, 3, 4, 5, 6,
                                                           7, 8, 9, 10).finished(),
               (Eigen::Matrix<local_scalar_t__,1,-1>(10) << 1, 2, 3, 4, 5, 6,
                                                           7, 8, 9, 10).finished()});
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector vecfoo()
Eigen::Matrix<double,-1,1> vecfoo(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 771;
    return stan::math::promote_scalar<local_scalar_t__>(
             (Eigen::Matrix<double,-1,1>(10) << 1, 2, 3, 4, 5, 6, 7, 8, 9, 10).finished());
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector vecmufoo(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
Eigen::Matrix<stan::promote_args_t<T0__>,-1,1>
vecmufoo(const T0__& mu, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    Eigen::Matrix<local_scalar_t__,-1,1> l =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(10, DUMMY_VAR__);
    current_statement__ = 773;
    stan::model::assign(l, stan::math::multiply(mu, vecfoo(pstream__)),
      "assigning variable l");
    current_statement__ = 774;
    return l;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector vecmubar(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
Eigen::Matrix<stan::promote_args_t<T0__>,-1,1>
vecmubar(const T0__& mu, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    Eigen::Matrix<local_scalar_t__,-1,1> l =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(10, DUMMY_VAR__);
    current_statement__ = 776;
    stan::model::assign(l,
      stan::math::multiply(mu,
        (Eigen::Matrix<double,-1,1>(10) << 1, 2, 3, 4, 5, 6, 7, 8, 9, 10).finished()),
      "assigning variable l");
    current_statement__ = 777;
    return stan::model::rvalue(l, "l",
             stan::model::index_multi(std::vector<int>{1, 2, 3, 4, 5}));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector algebra_system(vector, vector, array[] real, array[] int)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              std::is_integral<stan::value_type_t<T3__>>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>, stan::base_type_t<T2__>>,-1,1>
algebra_system(const T0__& x_arg__, const T1__& y_arg__, const T2__& dat,
               const T3__& dat_int, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& x = stan::math::to_ref(x_arg__);
  const auto& y = stan::math::to_ref(y_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    Eigen::Matrix<local_scalar_t__,-1,1> f_x =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
    current_statement__ = 780;
    stan::model::assign(f_x,
      (stan::model::rvalue(x, "x", stan::model::index_uni(1)) -
      stan::model::rvalue(y, "y", stan::model::index_uni(1))),
      "assigning variable f_x", stan::model::index_uni(1));
    current_statement__ = 781;
    stan::model::assign(f_x,
      (stan::model::rvalue(x, "x", stan::model::index_uni(2)) -
      stan::model::rvalue(y, "y", stan::model::index_uni(2))),
      "assigning variable f_x", stan::model::index_uni(2));
    current_statement__ = 782;
    return f_x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector binomialf(vector, vector, data array[] real, data array[] int)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,1>
binomialf(const T0__& phi_arg__, const T1__& theta_arg__,
          const std::vector<double>& x_r, const std::vector<int>& x_i,
          std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& phi = stan::math::to_ref(phi_arg__);
  const auto& theta = stan::math::to_ref(theta_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    Eigen::Matrix<local_scalar_t__,-1,1> lpmf =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(1, DUMMY_VAR__);
    current_statement__ = 785;
    stan::model::assign(lpmf, 0.0, "assigning variable lpmf",
      stan::model::index_uni(1));
    current_statement__ = 786;
    return lpmf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class mother_model final : public model_base_crtp<mother_model> {
 private:
  int N;
  int M;
  int K;
  std::vector<int> d_int_1d_ar;
  std::vector<std::vector<std::vector<int>>> d_int_3d_ar;
  double J;
  std::vector<double> d_real_1d_ar;
  std::vector<std::vector<std::vector<double>>> d_real_3d_ar;
  Eigen::Matrix<double,-1,1> d_vec_data__;
  std::vector<Eigen::Matrix<double,-1,1>> d_1d_vec;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>> d_3d_vec;
  Eigen::Matrix<double,1,-1> d_row_vec_data__;
  std::vector<Eigen::Matrix<double,1,-1>> d_1d_row_vec;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,1,-1>>>>
    d_3d_row_vec;
  std::vector<std::vector<Eigen::Matrix<double,-1,-1>>> d_ar_mat;
  Eigen::Matrix<double,-1,1> d_simplex_data__;
  std::vector<Eigen::Matrix<double,-1,1>> d_1d_simplex;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>
    d_3d_simplex;
  Eigen::Matrix<double,-1,-1> d_cfcov_54_data__;
  Eigen::Matrix<double,-1,-1> d_cfcov_33_data__;
  std::vector<Eigen::Matrix<double,-1,-1>> d_cfcov_33_ar;
  int d_int;
  std::vector<int> d_int_array;
  std::vector<std::vector<int>> d_int_array_2d;
  std::vector<std::vector<std::vector<int>>> d_int_array_3d;
  double d_real;
  std::vector<double> d_real_array;
  std::vector<std::vector<double>> d_real_array_2d;
  std::vector<std::vector<std::vector<double>>> d_real_array_3d;
  Eigen::Matrix<double,-1,-1> d_matrix_data__;
  std::vector<Eigen::Matrix<double,-1,-1>> d_matrix_array;
  std::vector<std::vector<Eigen::Matrix<double,-1,-1>>> d_matrix_array_2d;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>>
    d_matrix_array_3d;
  Eigen::Matrix<double,-1,1> d_vector_data__;
  std::vector<Eigen::Matrix<double,-1,1>> d_vector_array;
  std::vector<std::vector<Eigen::Matrix<double,-1,1>>> d_vector_array_2d;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>
    d_vector_array_3d;
  Eigen::Matrix<double,1,-1> d_row_vector_data__;
  std::vector<Eigen::Matrix<double,1,-1>> d_row_vector_array;
  std::vector<std::vector<Eigen::Matrix<double,1,-1>>> d_row_vector_array_2d;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,1,-1>>>>
    d_row_vector_array_3d;
  int td_int;
  std::vector<int> td_1d;
  std::vector<int> td_1dk;
  int td_a;
  double td_b;
  double td_c;
  std::vector<std::vector<Eigen::Matrix<double,-1,-1>>> td_ar_mat;
  Eigen::Matrix<double,-1,1> td_simplex_data__;
  std::vector<Eigen::Matrix<double,-1,1>> td_1d_simplex;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>
    td_3d_simplex;
  Eigen::Matrix<double,-1,-1> td_cfcov_54_data__;
  Eigen::Matrix<double,-1,-1> td_cfcov_33_data__;
  Eigen::Matrix<double,-1,1> x_data__;
  Eigen::Matrix<double,-1,1> y_data__;
  std::vector<double> dat;
  std::vector<int> dat_int;
  std::vector<std::vector<double>> x_r;
  std::vector<std::vector<int>> x_i;
  std::vector<std::vector<int>> arr_mul_ind;
  std::vector<double> x_mul_ind;
  double transformed_data_real;
  std::vector<double> transformed_data_real_array;
  std::vector<std::vector<double>> transformed_data_real_array_2d;
  std::vector<std::vector<std::vector<double>>>
    transformed_data_real_array_3d;
  Eigen::Matrix<double,-1,-1> transformed_data_matrix_data__;
  std::vector<Eigen::Matrix<double,-1,-1>> transformed_data_matrix_array;
  std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>
    transformed_data_matrix_array_2d;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>>
    transformed_data_matrix_array_3d;
  Eigen::Matrix<double,-1,1> transformed_data_vector_data__;
  std::vector<Eigen::Matrix<double,-1,1>> transformed_data_vector_array;
  std::vector<std::vector<Eigen::Matrix<double,-1,1>>>
    transformed_data_vector_array_2d;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>
    transformed_data_vector_array_3d;
  Eigen::Matrix<double,1,-1> transformed_data_row_vector_data__;
  std::vector<Eigen::Matrix<double,1,-1>> transformed_data_row_vector_array;
  std::vector<std::vector<Eigen::Matrix<double,1,-1>>>
    transformed_data_row_vector_array_2d;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,1,-1>>>>
    transformed_data_row_vector_array_3d;
  Eigen::Map<Eigen::Matrix<double,-1,1>> d_vec{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,1,-1>> d_row_vec{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> d_simplex{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> d_cfcov_54{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> d_cfcov_33{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> d_matrix{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> d_vector{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,1,-1>> d_row_vector{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> td_simplex{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> td_cfcov_54{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> td_cfcov_33{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> x{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> y{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>>
    transformed_data_matrix{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> transformed_data_vector{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,1,-1>>
    transformed_data_row_vector{nullptr, 0};
 public:
  ~mother_model() {}
  mother_model(stan::io::var_context& context__, unsigned int
               random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "mother_model_namespace::mother_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 190;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 190;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 190;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 191;
      context__.validate_dims("data initialization", "M", "int",
        std::vector<size_t>{});
      M = std::numeric_limits<int>::min();
      current_statement__ = 191;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 191;
      stan::math::check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 192;
      context__.validate_dims("data initialization", "K", "int",
        std::vector<size_t>{});
      K = std::numeric_limits<int>::min();
      current_statement__ = 192;
      K = context__.vals_i("K")[(1 - 1)];
      current_statement__ = 192;
      stan::math::check_greater_or_equal(function__, "K", K, 0);
      current_statement__ = 192;
      stan::math::check_less_or_equal(function__, "K", K, (N * M));
      current_statement__ = 193;
      stan::math::validate_non_negative_index("d_int_1d_ar", "N", N);
      current_statement__ = 194;
      context__.validate_dims("data initialization", "d_int_1d_ar", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      d_int_1d_ar = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 194;
      d_int_1d_ar = context__.vals_i("d_int_1d_ar");
      current_statement__ = 194;
      stan::math::check_less_or_equal(function__, "d_int_1d_ar", d_int_1d_ar,
        N);
      current_statement__ = 195;
      stan::math::validate_non_negative_index("d_int_3d_ar", "N", N);
      current_statement__ = 196;
      stan::math::validate_non_negative_index("d_int_3d_ar", "M", M);
      current_statement__ = 197;
      stan::math::validate_non_negative_index("d_int_3d_ar", "K", K);
      current_statement__ = 198;
      context__.validate_dims("data initialization", "d_int_3d_ar", "int",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M),
          static_cast<size_t>(K)});
      d_int_3d_ar = std::vector<std::vector<std::vector<int>>>(N,
                      std::vector<std::vector<int>>(M,
                        std::vector<int>(K, std::numeric_limits<int>::min())));
      {
        std::vector<int> d_int_3d_ar_flat__;
        current_statement__ = 198;
        d_int_3d_ar_flat__ = context__.vals_i("d_int_3d_ar");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(d_int_3d_ar, d_int_3d_ar_flat__[(pos__ -
                1)], "assigning variable d_int_3d_ar",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 198;
      stan::math::check_less_or_equal(function__, "d_int_3d_ar", d_int_3d_ar,
        N);
      current_statement__ = 199;
      context__.validate_dims("data initialization", "J", "double",
        std::vector<size_t>{});
      J = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 199;
      J = context__.vals_r("J")[(1 - 1)];
      current_statement__ = 199;
      stan::math::check_greater_or_equal(function__, "J", J, -(2.0));
      current_statement__ = 199;
      stan::math::check_less_or_equal(function__, "J", J, 2.0);
      current_statement__ = 200;
      stan::math::validate_non_negative_index("d_real_1d_ar", "N", N);
      current_statement__ = 201;
      context__.validate_dims("data initialization", "d_real_1d_ar",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      d_real_1d_ar = std::vector<double>(N,
                       std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 201;
      d_real_1d_ar = context__.vals_r("d_real_1d_ar");
      current_statement__ = 202;
      stan::math::validate_non_negative_index("d_real_3d_ar", "N", N);
      current_statement__ = 203;
      stan::math::validate_non_negative_index("d_real_3d_ar", "M", M);
      current_statement__ = 204;
      stan::math::validate_non_negative_index("d_real_3d_ar", "K", K);
      current_statement__ = 205;
      context__.validate_dims("data initialization", "d_real_3d_ar",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M),
          static_cast<size_t>(K)});
      d_real_3d_ar = std::vector<std::vector<std::vector<double>>>(N,
                       std::vector<std::vector<double>>(M,
                         std::vector<double>(K,
                           std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> d_real_3d_ar_flat__;
        current_statement__ = 205;
        d_real_3d_ar_flat__ = context__.vals_r("d_real_3d_ar");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(d_real_3d_ar, d_real_3d_ar_flat__[(pos__ -
                1)], "assigning variable d_real_3d_ar",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 206;
      stan::math::validate_non_negative_index("d_vec", "N", N);
      current_statement__ = 207;
      context__.validate_dims("data initialization", "d_vec", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      d_vec_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                       std::numeric_limits<double>::quiet_NaN());
      new (&d_vec)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(d_vec_data__.data(), N);
      {
        std::vector<local_scalar_t__> d_vec_flat__;
        current_statement__ = 207;
        d_vec_flat__ = context__.vals_r("d_vec");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(d_vec, d_vec_flat__[(pos__ - 1)],
            "assigning variable d_vec", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 208;
      stan::math::validate_non_negative_index("d_1d_vec", "N", N);
      current_statement__ = 209;
      stan::math::validate_non_negative_index("d_1d_vec", "N", N);
      current_statement__ = 210;
      context__.validate_dims("data initialization", "d_1d_vec", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      d_1d_vec = std::vector<Eigen::Matrix<double,-1,1>>(N,
                   Eigen::Matrix<double,-1,1>::Constant(N,
                     std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> d_1d_vec_flat__;
        current_statement__ = 210;
        d_1d_vec_flat__ = context__.vals_r("d_1d_vec");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(d_1d_vec, d_1d_vec_flat__[(pos__ - 1)],
              "assigning variable d_1d_vec", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 211;
      stan::math::validate_non_negative_index("d_3d_vec", "N", N);
      current_statement__ = 212;
      stan::math::validate_non_negative_index("d_3d_vec", "M", M);
      current_statement__ = 213;
      stan::math::validate_non_negative_index("d_3d_vec", "K", K);
      current_statement__ = 214;
      stan::math::validate_non_negative_index("d_3d_vec", "N", N);
      current_statement__ = 215;
      context__.validate_dims("data initialization", "d_3d_vec", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M),
          static_cast<size_t>(K), static_cast<size_t>(N)});
      d_3d_vec = std::vector<
                   std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>(N,
                   std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(M,
                     std::vector<Eigen::Matrix<double,-1,1>>(K,
                       Eigen::Matrix<double,-1,1>::Constant(N,
                         std::numeric_limits<double>::quiet_NaN()))));
      {
        std::vector<local_scalar_t__> d_3d_vec_flat__;
        current_statement__ = 215;
        d_3d_vec_flat__ = context__.vals_r("d_3d_vec");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                stan::model::assign(d_3d_vec, d_3d_vec_flat__[(pos__ - 1)],
                  "assigning variable d_3d_vec",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 216;
      stan::math::validate_non_negative_index("d_row_vec", "N", N);
      current_statement__ = 217;
      context__.validate_dims("data initialization", "d_row_vec", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      d_row_vec_data__ = Eigen::Matrix<double,1,-1>::Constant(N,
                           std::numeric_limits<double>::quiet_NaN());
      new (&d_row_vec)
        Eigen::Map<Eigen::Matrix<double,1,-1>>(d_row_vec_data__.data(), N);
      {
        std::vector<local_scalar_t__> d_row_vec_flat__;
        current_statement__ = 217;
        d_row_vec_flat__ = context__.vals_r("d_row_vec");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(d_row_vec, d_row_vec_flat__[(pos__ - 1)],
            "assigning variable d_row_vec", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 218;
      stan::math::validate_non_negative_index("d_1d_row_vec", "N", N);
      current_statement__ = 219;
      stan::math::validate_non_negative_index("d_1d_row_vec", "N", N);
      current_statement__ = 220;
      context__.validate_dims("data initialization", "d_1d_row_vec",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      d_1d_row_vec = std::vector<Eigen::Matrix<double,1,-1>>(N,
                       Eigen::Matrix<double,1,-1>::Constant(N,
                         std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> d_1d_row_vec_flat__;
        current_statement__ = 220;
        d_1d_row_vec_flat__ = context__.vals_r("d_1d_row_vec");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(d_1d_row_vec, d_1d_row_vec_flat__[(pos__ -
              1)], "assigning variable d_1d_row_vec",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 221;
      stan::math::validate_non_negative_index("d_3d_row_vec", "N", N);
      current_statement__ = 222;
      stan::math::validate_non_negative_index("d_3d_row_vec", "M", M);
      current_statement__ = 223;
      stan::math::validate_non_negative_index("d_3d_row_vec", "K", K);
      current_statement__ = 224;
      stan::math::validate_non_negative_index("d_3d_row_vec", "N", N);
      current_statement__ = 225;
      context__.validate_dims("data initialization", "d_3d_row_vec",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M),
          static_cast<size_t>(K), static_cast<size_t>(N)});
      d_3d_row_vec = std::vector<
                       std::vector<std::vector<Eigen::Matrix<double,1,-1>>>>(N,
                       std::vector<std::vector<Eigen::Matrix<double,1,-1>>>(M,
                         std::vector<Eigen::Matrix<double,1,-1>>(K,
                           Eigen::Matrix<double,1,-1>::Constant(N,
                             std::numeric_limits<double>::quiet_NaN()))));
      {
        std::vector<local_scalar_t__> d_3d_row_vec_flat__;
        current_statement__ = 225;
        d_3d_row_vec_flat__ = context__.vals_r("d_3d_row_vec");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                stan::model::assign(d_3d_row_vec, d_3d_row_vec_flat__[(pos__
                  - 1)], "assigning variable d_3d_row_vec",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 226;
      context__.validate_dims("data initialization", "d_ar_mat", "double",
        std::vector<size_t>{static_cast<size_t>(4), static_cast<size_t>(5),
          static_cast<size_t>(2), static_cast<size_t>(3)});
      d_ar_mat = std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>(4,
                   std::vector<Eigen::Matrix<double,-1,-1>>(5,
                     Eigen::Matrix<double,-1,-1>::Constant(2, 3,
                       std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> d_ar_mat_flat__;
        current_statement__ = 226;
        d_ar_mat_flat__ = context__.vals_r("d_ar_mat");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
                stan::model::assign(d_ar_mat, d_ar_mat_flat__[(pos__ - 1)],
                  "assigning variable d_ar_mat",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 226;
      stan::math::check_greater_or_equal(function__, "d_ar_mat", d_ar_mat, 0);
      current_statement__ = 226;
      stan::math::check_less_or_equal(function__, "d_ar_mat", d_ar_mat, 1);
      current_statement__ = 227;
      stan::math::validate_non_negative_index("d_simplex", "N", N);
      current_statement__ = 228;
      context__.validate_dims("data initialization", "d_simplex", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      d_simplex_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                           std::numeric_limits<double>::quiet_NaN());
      new (&d_simplex)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(d_simplex_data__.data(), N);
      {
        std::vector<local_scalar_t__> d_simplex_flat__;
        current_statement__ = 228;
        d_simplex_flat__ = context__.vals_r("d_simplex");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(d_simplex, d_simplex_flat__[(pos__ - 1)],
            "assigning variable d_simplex", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 228;
      stan::math::check_simplex(function__, "d_simplex", d_simplex);
      current_statement__ = 229;
      stan::math::validate_non_negative_index("d_1d_simplex", "N", N);
      current_statement__ = 230;
      stan::math::validate_non_negative_index("d_1d_simplex", "N", N);
      current_statement__ = 231;
      context__.validate_dims("data initialization", "d_1d_simplex",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      d_1d_simplex = std::vector<Eigen::Matrix<double,-1,1>>(N,
                       Eigen::Matrix<double,-1,1>::Constant(N,
                         std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> d_1d_simplex_flat__;
        current_statement__ = 231;
        d_1d_simplex_flat__ = context__.vals_r("d_1d_simplex");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(d_1d_simplex, d_1d_simplex_flat__[(pos__ -
              1)], "assigning variable d_1d_simplex",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 231;
      stan::math::check_simplex(function__, "d_1d_simplex", d_1d_simplex);
      current_statement__ = 232;
      stan::math::validate_non_negative_index("d_3d_simplex", "N", N);
      current_statement__ = 233;
      stan::math::validate_non_negative_index("d_3d_simplex", "M", M);
      current_statement__ = 234;
      stan::math::validate_non_negative_index("d_3d_simplex", "K", K);
      current_statement__ = 235;
      stan::math::validate_non_negative_index("d_3d_simplex", "N", N);
      current_statement__ = 236;
      context__.validate_dims("data initialization", "d_3d_simplex",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M),
          static_cast<size_t>(K), static_cast<size_t>(N)});
      d_3d_simplex = std::vector<
                       std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>(N,
                       std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(M,
                         std::vector<Eigen::Matrix<double,-1,1>>(K,
                           Eigen::Matrix<double,-1,1>::Constant(N,
                             std::numeric_limits<double>::quiet_NaN()))));
      {
        std::vector<local_scalar_t__> d_3d_simplex_flat__;
        current_statement__ = 236;
        d_3d_simplex_flat__ = context__.vals_r("d_3d_simplex");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                stan::model::assign(d_3d_simplex, d_3d_simplex_flat__[(pos__
                  - 1)], "assigning variable d_3d_simplex",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 236;
      stan::math::check_simplex(function__, "d_3d_simplex", d_3d_simplex);
      current_statement__ = 237;
      context__.validate_dims("data initialization", "d_cfcov_54", "double",
        std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(4)});
      d_cfcov_54_data__ = Eigen::Matrix<double,-1,-1>::Constant(5, 4,
                            std::numeric_limits<double>::quiet_NaN());
      new (&d_cfcov_54)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(d_cfcov_54_data__.data(), 5,
        4);
      {
        std::vector<local_scalar_t__> d_cfcov_54_flat__;
        current_statement__ = 237;
        d_cfcov_54_flat__ = context__.vals_r("d_cfcov_54");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            stan::model::assign(d_cfcov_54, d_cfcov_54_flat__[(pos__ - 1)],
              "assigning variable d_cfcov_54",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 237;
      stan::math::check_cholesky_factor(function__, "d_cfcov_54", d_cfcov_54);
      current_statement__ = 238;
      context__.validate_dims("data initialization", "d_cfcov_33", "double",
        std::vector<size_t>{static_cast<size_t>(3), static_cast<size_t>(3)});
      d_cfcov_33_data__ = Eigen::Matrix<double,-1,-1>::Constant(3, 3,
                            std::numeric_limits<double>::quiet_NaN());
      new (&d_cfcov_33)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(d_cfcov_33_data__.data(), 3,
        3);
      {
        std::vector<local_scalar_t__> d_cfcov_33_flat__;
        current_statement__ = 238;
        d_cfcov_33_flat__ = context__.vals_r("d_cfcov_33");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            stan::model::assign(d_cfcov_33, d_cfcov_33_flat__[(pos__ - 1)],
              "assigning variable d_cfcov_33",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 238;
      stan::math::check_cholesky_factor(function__, "d_cfcov_33", d_cfcov_33);
      current_statement__ = 239;
      stan::math::validate_non_negative_index("d_cfcov_33_ar", "K", K);
      current_statement__ = 240;
      context__.validate_dims("data initialization", "d_cfcov_33_ar",
        "double",
        std::vector<size_t>{static_cast<size_t>(K), static_cast<size_t>(3),
          static_cast<size_t>(3)});
      d_cfcov_33_ar = std::vector<Eigen::Matrix<double,-1,-1>>(K,
                        Eigen::Matrix<double,-1,-1>::Constant(3, 3,
                          std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> d_cfcov_33_ar_flat__;
        current_statement__ = 240;
        d_cfcov_33_ar_flat__ = context__.vals_r("d_cfcov_33_ar");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
              stan::model::assign(d_cfcov_33_ar, d_cfcov_33_ar_flat__[(pos__
                - 1)], "assigning variable d_cfcov_33_ar",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 240;
      stan::math::check_cholesky_factor(function__, "d_cfcov_33_ar",
        d_cfcov_33_ar);
      current_statement__ = 241;
      context__.validate_dims("data initialization", "d_int", "int",
        std::vector<size_t>{});
      d_int = std::numeric_limits<int>::min();
      current_statement__ = 241;
      d_int = context__.vals_i("d_int")[(1 - 1)];
      current_statement__ = 242;
      stan::math::validate_non_negative_index("d_int_array", "d_int", d_int);
      current_statement__ = 243;
      context__.validate_dims("data initialization", "d_int_array", "int",
        std::vector<size_t>{static_cast<size_t>(d_int)});
      d_int_array = std::vector<int>(d_int, std::numeric_limits<int>::min());
      current_statement__ = 243;
      d_int_array = context__.vals_i("d_int_array");
      current_statement__ = 244;
      stan::math::validate_non_negative_index("d_int_array_2d", "d_int",
        d_int);
      current_statement__ = 245;
      context__.validate_dims("data initialization", "d_int_array_2d", "int",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(2)});
      d_int_array_2d = std::vector<std::vector<int>>(d_int,
                         std::vector<int>(2, std::numeric_limits<int>::min()));
      {
        std::vector<int> d_int_array_2d_flat__;
        current_statement__ = 245;
        d_int_array_2d_flat__ = context__.vals_i("d_int_array_2d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= d_int; ++sym2__) {
            stan::model::assign(d_int_array_2d, d_int_array_2d_flat__[(pos__
              - 1)], "assigning variable d_int_array_2d",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 246;
      stan::math::validate_non_negative_index("d_int_array_3d", "d_int",
        d_int);
      current_statement__ = 247;
      context__.validate_dims("data initialization", "d_int_array_3d", "int",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(2), static_cast<size_t>(3)});
      d_int_array_3d = std::vector<std::vector<std::vector<int>>>(d_int,
                         std::vector<std::vector<int>>(2,
                           std::vector<int>(3,
                             std::numeric_limits<int>::min())));
      {
        std::vector<int> d_int_array_3d_flat__;
        current_statement__ = 247;
        d_int_array_3d_flat__ = context__.vals_i("d_int_array_3d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= d_int; ++sym3__) {
              stan::model::assign(d_int_array_3d,
                d_int_array_3d_flat__[(pos__ - 1)],
                "assigning variable d_int_array_3d",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 248;
      context__.validate_dims("data initialization", "d_real", "double",
        std::vector<size_t>{});
      d_real = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 248;
      d_real = context__.vals_r("d_real")[(1 - 1)];
      current_statement__ = 249;
      stan::math::validate_non_negative_index("d_real_array", "d_int", d_int);
      current_statement__ = 250;
      context__.validate_dims("data initialization", "d_real_array",
        "double", std::vector<size_t>{static_cast<size_t>(d_int)});
      d_real_array = std::vector<double>(d_int,
                       std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 250;
      d_real_array = context__.vals_r("d_real_array");
      current_statement__ = 251;
      stan::math::validate_non_negative_index("d_real_array_2d", "d_int",
        d_int);
      current_statement__ = 252;
      context__.validate_dims("data initialization", "d_real_array_2d",
        "double",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(2)});
      d_real_array_2d = std::vector<std::vector<double>>(d_int,
                          std::vector<double>(2,
                            std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> d_real_array_2d_flat__;
        current_statement__ = 252;
        d_real_array_2d_flat__ = context__.vals_r("d_real_array_2d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= d_int; ++sym2__) {
            stan::model::assign(d_real_array_2d,
              d_real_array_2d_flat__[(pos__ - 1)],
              "assigning variable d_real_array_2d",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 253;
      stan::math::validate_non_negative_index("d_real_array_3d", "d_int",
        d_int);
      current_statement__ = 254;
      context__.validate_dims("data initialization", "d_real_array_3d",
        "double",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(2), static_cast<size_t>(3)});
      d_real_array_3d = std::vector<std::vector<std::vector<double>>>(d_int,
                          std::vector<std::vector<double>>(2,
                            std::vector<double>(3,
                              std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> d_real_array_3d_flat__;
        current_statement__ = 254;
        d_real_array_3d_flat__ = context__.vals_r("d_real_array_3d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= d_int; ++sym3__) {
              stan::model::assign(d_real_array_3d,
                d_real_array_3d_flat__[(pos__ - 1)],
                "assigning variable d_real_array_3d",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 255;
      stan::math::validate_non_negative_index("d_matrix", "d_int", d_int);
      current_statement__ = 256;
      stan::math::validate_non_negative_index("d_matrix", "d_int", d_int);
      current_statement__ = 257;
      context__.validate_dims("data initialization", "d_matrix", "double",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(d_int)});
      d_matrix_data__ = Eigen::Matrix<double,-1,-1>::Constant(d_int, d_int,
                          std::numeric_limits<double>::quiet_NaN());
      new (&d_matrix)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(d_matrix_data__.data(),
        d_int, d_int);
      {
        std::vector<local_scalar_t__> d_matrix_flat__;
        current_statement__ = 257;
        d_matrix_flat__ = context__.vals_r("d_matrix");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= d_int; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= d_int; ++sym2__) {
            stan::model::assign(d_matrix, d_matrix_flat__[(pos__ - 1)],
              "assigning variable d_matrix", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 258;
      stan::math::validate_non_negative_index("d_matrix_array", "d_int",
        d_int);
      current_statement__ = 259;
      stan::math::validate_non_negative_index("d_matrix_array", "d_int",
        d_int);
      current_statement__ = 260;
      stan::math::validate_non_negative_index("d_matrix_array", "d_int",
        d_int);
      current_statement__ = 261;
      context__.validate_dims("data initialization", "d_matrix_array",
        "double",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(d_int), static_cast<size_t>(d_int)});
      d_matrix_array = std::vector<Eigen::Matrix<double,-1,-1>>(d_int,
                         Eigen::Matrix<double,-1,-1>::Constant(d_int, d_int,
                           std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> d_matrix_array_flat__;
        current_statement__ = 261;
        d_matrix_array_flat__ = context__.vals_r("d_matrix_array");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= d_int; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= d_int; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= d_int; ++sym3__) {
              stan::model::assign(d_matrix_array,
                d_matrix_array_flat__[(pos__ - 1)],
                "assigning variable d_matrix_array",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 262;
      stan::math::validate_non_negative_index("d_matrix_array_2d", "d_int",
        d_int);
      current_statement__ = 263;
      stan::math::validate_non_negative_index("d_matrix_array_2d", "d_int",
        d_int);
      current_statement__ = 264;
      stan::math::validate_non_negative_index("d_matrix_array_2d", "d_int",
        d_int);
      current_statement__ = 265;
      context__.validate_dims("data initialization", "d_matrix_array_2d",
        "double",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(2), static_cast<size_t>(d_int),
          static_cast<size_t>(d_int)});
      d_matrix_array_2d = std::vector<
                            std::vector<Eigen::Matrix<double,-1,-1>>>(d_int,
                            std::vector<Eigen::Matrix<double,-1,-1>>(2,
                              Eigen::Matrix<double,-1,-1>::Constant(d_int,
                                d_int,
                                std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> d_matrix_array_2d_flat__;
        current_statement__ = 265;
        d_matrix_array_2d_flat__ = context__.vals_r("d_matrix_array_2d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= d_int; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= d_int; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= d_int; ++sym4__) {
                stan::model::assign(d_matrix_array_2d,
                  d_matrix_array_2d_flat__[(pos__ - 1)],
                  "assigning variable d_matrix_array_2d",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 266;
      stan::math::validate_non_negative_index("d_matrix_array_3d", "d_int",
        d_int);
      current_statement__ = 267;
      stan::math::validate_non_negative_index("d_matrix_array_3d", "d_int",
        d_int);
      current_statement__ = 268;
      stan::math::validate_non_negative_index("d_matrix_array_3d", "d_int",
        d_int);
      current_statement__ = 269;
      context__.validate_dims("data initialization", "d_matrix_array_3d",
        "double",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(2), static_cast<size_t>(3),
          static_cast<size_t>(d_int), static_cast<size_t>(d_int)});
      d_matrix_array_3d = std::vector<
                            std::vector<
                              std::vector<Eigen::Matrix<double,-1,-1>>>>(d_int,
                            std::vector<
                              std::vector<Eigen::Matrix<double,-1,-1>>>(2,
                              std::vector<Eigen::Matrix<double,-1,-1>>(3,
                                Eigen::Matrix<double,-1,-1>::Constant(d_int,
                                  d_int,
                                  std::numeric_limits<double>::quiet_NaN()))));
      {
        std::vector<local_scalar_t__> d_matrix_array_3d_flat__;
        current_statement__ = 269;
        d_matrix_array_3d_flat__ = context__.vals_r("d_matrix_array_3d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= d_int; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= d_int; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= 2; ++sym4__) {
                for (int sym5__ = 1; sym5__ <= d_int; ++sym5__) {
                  stan::model::assign(d_matrix_array_3d,
                    d_matrix_array_3d_flat__[(pos__ - 1)],
                    "assigning variable d_matrix_array_3d",
                    stan::model::index_uni(sym5__),
                    stan::model::index_uni(sym4__),
                    stan::model::index_uni(sym3__),
                    stan::model::index_uni(sym2__),
                    stan::model::index_uni(sym1__));
                  pos__ = (pos__ + 1);
                }
              }
            }
          }
        }
      }
      current_statement__ = 270;
      stan::math::validate_non_negative_index("d_vector", "d_int", d_int);
      current_statement__ = 271;
      context__.validate_dims("data initialization", "d_vector", "double",
        std::vector<size_t>{static_cast<size_t>(d_int)});
      d_vector_data__ = Eigen::Matrix<double,-1,1>::Constant(d_int,
                          std::numeric_limits<double>::quiet_NaN());
      new (&d_vector)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(d_vector_data__.data(), d_int);
      {
        std::vector<local_scalar_t__> d_vector_flat__;
        current_statement__ = 271;
        d_vector_flat__ = context__.vals_r("d_vector");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= d_int; ++sym1__) {
          stan::model::assign(d_vector, d_vector_flat__[(pos__ - 1)],
            "assigning variable d_vector", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 272;
      stan::math::validate_non_negative_index("d_vector_array", "d_int",
        d_int);
      current_statement__ = 273;
      stan::math::validate_non_negative_index("d_vector_array", "d_int",
        d_int);
      current_statement__ = 274;
      context__.validate_dims("data initialization", "d_vector_array",
        "double",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(d_int)});
      d_vector_array = std::vector<Eigen::Matrix<double,-1,1>>(d_int,
                         Eigen::Matrix<double,-1,1>::Constant(d_int,
                           std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> d_vector_array_flat__;
        current_statement__ = 274;
        d_vector_array_flat__ = context__.vals_r("d_vector_array");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= d_int; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= d_int; ++sym2__) {
            stan::model::assign(d_vector_array, d_vector_array_flat__[(pos__
              - 1)], "assigning variable d_vector_array",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 275;
      stan::math::validate_non_negative_index("d_vector_array_2d", "d_int",
        d_int);
      current_statement__ = 276;
      stan::math::validate_non_negative_index("d_vector_array_2d", "d_int",
        d_int);
      current_statement__ = 277;
      context__.validate_dims("data initialization", "d_vector_array_2d",
        "double",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(2), static_cast<size_t>(d_int)});
      d_vector_array_2d = std::vector<
                            std::vector<Eigen::Matrix<double,-1,1>>>(d_int,
                            std::vector<Eigen::Matrix<double,-1,1>>(2,
                              Eigen::Matrix<double,-1,1>::Constant(d_int,
                                std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> d_vector_array_2d_flat__;
        current_statement__ = 277;
        d_vector_array_2d_flat__ = context__.vals_r("d_vector_array_2d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= d_int; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= d_int; ++sym3__) {
              stan::model::assign(d_vector_array_2d,
                d_vector_array_2d_flat__[(pos__ - 1)],
                "assigning variable d_vector_array_2d",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 278;
      stan::math::validate_non_negative_index("d_vector_array_3d", "d_int",
        d_int);
      current_statement__ = 279;
      stan::math::validate_non_negative_index("d_vector_array_3d", "d_int",
        d_int);
      current_statement__ = 280;
      context__.validate_dims("data initialization", "d_vector_array_3d",
        "double",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(2), static_cast<size_t>(3),
          static_cast<size_t>(d_int)});
      d_vector_array_3d = std::vector<
                            std::vector<
                              std::vector<Eigen::Matrix<double,-1,1>>>>(d_int,
                            std::vector<
                              std::vector<Eigen::Matrix<double,-1,1>>>(2,
                              std::vector<Eigen::Matrix<double,-1,1>>(3,
                                Eigen::Matrix<double,-1,1>::Constant(d_int,
                                  std::numeric_limits<double>::quiet_NaN()))));
      {
        std::vector<local_scalar_t__> d_vector_array_3d_flat__;
        current_statement__ = 280;
        d_vector_array_3d_flat__ = context__.vals_r("d_vector_array_3d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= d_int; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= d_int; ++sym4__) {
                stan::model::assign(d_vector_array_3d,
                  d_vector_array_3d_flat__[(pos__ - 1)],
                  "assigning variable d_vector_array_3d",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 281;
      stan::math::validate_non_negative_index("d_row_vector", "d_int", d_int);
      current_statement__ = 282;
      context__.validate_dims("data initialization", "d_row_vector",
        "double", std::vector<size_t>{static_cast<size_t>(d_int)});
      d_row_vector_data__ = Eigen::Matrix<double,1,-1>::Constant(d_int,
                              std::numeric_limits<double>::quiet_NaN());
      new (&d_row_vector)
        Eigen::Map<Eigen::Matrix<double,1,-1>>(d_row_vector_data__.data(),
        d_int);
      {
        std::vector<local_scalar_t__> d_row_vector_flat__;
        current_statement__ = 282;
        d_row_vector_flat__ = context__.vals_r("d_row_vector");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= d_int; ++sym1__) {
          stan::model::assign(d_row_vector, d_row_vector_flat__[(pos__ - 1)],
            "assigning variable d_row_vector", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 283;
      stan::math::validate_non_negative_index("d_row_vector_array", "d_int",
        d_int);
      current_statement__ = 284;
      stan::math::validate_non_negative_index("d_row_vector_array", "d_int",
        d_int);
      current_statement__ = 285;
      context__.validate_dims("data initialization", "d_row_vector_array",
        "double",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(d_int)});
      d_row_vector_array = std::vector<Eigen::Matrix<double,1,-1>>(d_int,
                             Eigen::Matrix<double,1,-1>::Constant(d_int,
                               std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> d_row_vector_array_flat__;
        current_statement__ = 285;
        d_row_vector_array_flat__ = context__.vals_r("d_row_vector_array");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= d_int; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= d_int; ++sym2__) {
            stan::model::assign(d_row_vector_array,
              d_row_vector_array_flat__[(pos__ - 1)],
              "assigning variable d_row_vector_array",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 286;
      stan::math::validate_non_negative_index("d_row_vector_array_2d",
        "d_int", d_int);
      current_statement__ = 287;
      stan::math::validate_non_negative_index("d_row_vector_array_2d",
        "d_int", d_int);
      current_statement__ = 288;
      context__.validate_dims("data initialization", "d_row_vector_array_2d",
        "double",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(2), static_cast<size_t>(d_int)});
      d_row_vector_array_2d = std::vector<
                                std::vector<Eigen::Matrix<double,1,-1>>>(d_int,
                                std::vector<Eigen::Matrix<double,1,-1>>(2,
                                  Eigen::Matrix<double,1,-1>::Constant(d_int,
                                    std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> d_row_vector_array_2d_flat__;
        current_statement__ = 288;
        d_row_vector_array_2d_flat__ = context__.vals_r("d_row_vector_array_2d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= d_int; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= d_int; ++sym3__) {
              stan::model::assign(d_row_vector_array_2d,
                d_row_vector_array_2d_flat__[(pos__ - 1)],
                "assigning variable d_row_vector_array_2d",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 289;
      stan::math::validate_non_negative_index("d_row_vector_array_3d",
        "d_int", d_int);
      current_statement__ = 290;
      stan::math::validate_non_negative_index("d_row_vector_array_3d",
        "d_int", d_int);
      current_statement__ = 291;
      context__.validate_dims("data initialization", "d_row_vector_array_3d",
        "double",
        std::vector<size_t>{static_cast<size_t>(d_int),
          static_cast<size_t>(2), static_cast<size_t>(3),
          static_cast<size_t>(d_int)});
      d_row_vector_array_3d = std::vector<
                                std::vector<
                                  std::vector<Eigen::Matrix<double,1,-1>>>>(d_int,
                                std::vector<
                                  std::vector<Eigen::Matrix<double,1,-1>>>(2,
                                  std::vector<Eigen::Matrix<double,1,-1>>(3,
                                    Eigen::Matrix<double,1,-1>::Constant(d_int,
                                      std::numeric_limits<double>::quiet_NaN()))));
      {
        std::vector<local_scalar_t__> d_row_vector_array_3d_flat__;
        current_statement__ = 291;
        d_row_vector_array_3d_flat__ = context__.vals_r("d_row_vector_array_3d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= d_int; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= d_int; ++sym4__) {
                stan::model::assign(d_row_vector_array_3d,
                  d_row_vector_array_3d_flat__[(pos__ - 1)],
                  "assigning variable d_row_vector_array_3d",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 292;
      td_int = std::numeric_limits<int>::min();
      current_statement__ = 293;
      stan::math::validate_non_negative_index("td_1d", "N", N);
      current_statement__ = 294;
      td_1d = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 295;
      stan::math::validate_non_negative_index("td_1dk", "M", M);
      current_statement__ = 296;
      td_1dk = std::vector<int>(M, std::numeric_limits<int>::min());
      current_statement__ = 296;
      stan::model::assign(td_1dk, stan::math::rep_array(1, M),
        "assigning variable td_1dk");
      current_statement__ = 297;
      td_a = std::numeric_limits<int>::min();
      current_statement__ = 297;
      td_a = N;
      current_statement__ = 298;
      td_b = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 298;
      td_b = (N * J);
      current_statement__ = 299;
      td_c = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 299;
      td_c = foo_bar1(td_b, pstream__);
      current_statement__ = 300;
      td_ar_mat = std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>(4,
                    std::vector<Eigen::Matrix<double,-1,-1>>(5,
                      Eigen::Matrix<double,-1,-1>::Constant(2, 3,
                        std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 301;
      stan::math::validate_non_negative_index("td_simplex", "N", N);
      current_statement__ = 302;
      td_simplex_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                            std::numeric_limits<double>::quiet_NaN());
      new (&td_simplex)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(td_simplex_data__.data(), N);
      current_statement__ = 303;
      stan::math::validate_non_negative_index("td_1d_simplex", "N", N);
      current_statement__ = 304;
      stan::math::validate_non_negative_index("td_1d_simplex", "N", N);
      current_statement__ = 305;
      td_1d_simplex = std::vector<Eigen::Matrix<double,-1,1>>(N,
                        Eigen::Matrix<double,-1,1>::Constant(N,
                          std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 306;
      stan::math::validate_non_negative_index("td_3d_simplex", "N", N);
      current_statement__ = 307;
      stan::math::validate_non_negative_index("td_3d_simplex", "M", M);
      current_statement__ = 308;
      stan::math::validate_non_negative_index("td_3d_simplex", "K", K);
      current_statement__ = 309;
      stan::math::validate_non_negative_index("td_3d_simplex", "N", N);
      current_statement__ = 310;
      td_3d_simplex = std::vector<
                        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>(N,
                        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(M,
                          std::vector<Eigen::Matrix<double,-1,1>>(K,
                            Eigen::Matrix<double,-1,1>::Constant(N,
                              std::numeric_limits<double>::quiet_NaN()))));
      current_statement__ = 311;
      td_cfcov_54_data__ = Eigen::Matrix<double,-1,-1>::Constant(5, 5,
                             std::numeric_limits<double>::quiet_NaN());
      new (&td_cfcov_54)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(td_cfcov_54_data__.data(), 5,
        5);
      current_statement__ = 312;
      td_cfcov_33_data__ = Eigen::Matrix<double,-1,-1>::Constant(3, 3,
                             std::numeric_limits<double>::quiet_NaN());
      new (&td_cfcov_33)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(td_cfcov_33_data__.data(), 3,
        3);
      current_statement__ = 313;
      x_data__ = Eigen::Matrix<double,-1,1>::Constant(2,
                   std::numeric_limits<double>::quiet_NaN());
      new (&x) Eigen::Map<Eigen::Matrix<double,-1,1>>(x_data__.data(), 2);
      current_statement__ = 314;
      y_data__ = Eigen::Matrix<double,-1,1>::Constant(2,
                   std::numeric_limits<double>::quiet_NaN());
      new (&y) Eigen::Map<Eigen::Matrix<double,-1,1>>(y_data__.data(), 2);
      current_statement__ = 315;
      dat = std::vector<double>(0, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 316;
      dat_int = std::vector<int>(0, std::numeric_limits<int>::min());
      current_statement__ = 317;
      x_r = std::vector<std::vector<double>>(0,
              std::vector<double>(0,
                std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 318;
      x_i = std::vector<std::vector<int>>(0,
              std::vector<int>(0, std::numeric_limits<int>::min()));
      current_statement__ = 319;
      td_int = (stan::math::primitive_value(1) ||
        stan::math::primitive_value(2));
      current_statement__ = 320;
      td_int = (stan::math::primitive_value(1) &&
        stan::math::primitive_value(2));
      current_statement__ = 329;
      for (int i = 1; i <= 2; ++i) {
        current_statement__ = 327;
        for (int j = 1; j <= 3; ++j) {
          current_statement__ = 325;
          for (int m = 1; m <= 4; ++m) {
            current_statement__ = 323;
            for (int n = 1; n <= 5; ++n) {
              current_statement__ = 321;
              stan::model::assign(td_ar_mat, 0.4,
                "assigning variable td_ar_mat", stan::model::index_uni(m),
                stan::model::index_uni(n), stan::model::index_uni(i),
                stan::model::index_uni(j));
            }
          }
        }
      }
      current_statement__ = 340;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 330;
        stan::model::assign(td_simplex, (1.0 / N),
          "assigning variable td_simplex", stan::model::index_uni(i));
        current_statement__ = 338;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 331;
          stan::model::assign(td_1d_simplex, (1.0 / N),
            "assigning variable td_1d_simplex", stan::model::index_uni(n),
            stan::model::index_uni(i));
          current_statement__ = 336;
          for (int m = 1; m <= M; ++m) {
            current_statement__ = 334;
            for (int k = 1; k <= K; ++k) {
              current_statement__ = 332;
              stan::model::assign(td_3d_simplex, (1.0 / N),
                "assigning variable td_3d_simplex",
                stan::model::index_uni(n), stan::model::index_uni(m),
                stan::model::index_uni(k), stan::model::index_uni(i));
            }
          }
        }
      }
      current_statement__ = 346;
      for (int i = 1; i <= 4; ++i) {
        current_statement__ = 344;
        for (int j = 1; j <= 5; ++j) {
          Eigen::Matrix<double,-1,-1> l_mat =
            Eigen::Matrix<double,-1,-1>::Constant(2, 3,
              std::numeric_limits<double>::quiet_NaN());
          current_statement__ = 341;
          stan::model::assign(l_mat,
            stan::model::rvalue(d_ar_mat, "d_ar_mat",
              stan::model::index_uni(i), stan::model::index_uni(j)),
            "assigning variable l_mat");
          current_statement__ = 342;
          if (pstream__) {
            stan::math::stan_print(pstream__, "ar dim1: ");
            stan::math::stan_print(pstream__, i);
            stan::math::stan_print(pstream__, " ar dim2: ");
            stan::math::stan_print(pstream__, j);
            stan::math::stan_print(pstream__, " matrix: ");
            stan::math::stan_print(pstream__, l_mat);
            *(pstream__) << std::endl;
          }
        }
      }
      current_statement__ = 347;
      stan::model::assign(td_cfcov_54,
        stan::math::diag_matrix(
          stan::math::rep_vector(1, stan::math::rows(td_cfcov_54))),
        "assigning variable td_cfcov_54");
      current_statement__ = 348;
      stan::model::assign(td_cfcov_33,
        stan::math::diag_matrix(
          stan::math::rep_vector(1, stan::math::rows(td_cfcov_33))),
        "assigning variable td_cfcov_33");
      {
        double z = std::numeric_limits<double>::quiet_NaN();
        Eigen::Matrix<double,1,-1> blocked_tdata_vs =
          Eigen::Matrix<double,1,-1>::Constant(2,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 351;
        for (int sym1__ = 1; sym1__ <=
             stan::math::size(blocked_tdata_vs); ++sym1__) {
          double v;
          current_statement__ = 351;
          v = blocked_tdata_vs[(sym1__ - 1)];
          current_statement__ = 352;
          z = 0;
        }
        std::vector<int> indices =
          std::vector<int>(4, std::numeric_limits<int>::min());
        current_statement__ = 353;
        stan::model::assign(indices, std::vector<int>{1, 2, 3, 4},
          "assigning variable indices");
        {
          std::vector<int> sym1__;
          current_statement__ = 354;
          stan::model::assign(sym1__,
            stan::model::rvalue(indices, "indices",
              stan::model::index_min_max(1, 3)), "assigning variable sym1__");
          current_statement__ = 355;
          for (int sym3__ = 1; sym3__ <= stan::math::size(sym1__); ++sym3__) {
            int i;
            current_statement__ = 355;
            i = sym1__[(sym3__ - 1)];
            current_statement__ = 356;
            z = i;
          }
        }
      }
      current_statement__ = 358;
      stan::model::assign(td_1dk,
        stan::model::rvalue(td_1d, "td_1d",
          stan::model::index_multi(stan::model::deep_copy(td_1dk))),
        "assigning variable td_1dk");
      current_statement__ = 359;
      stan::model::assign(td_simplex,
        stan::model::rvalue(td_1d_simplex, "td_1d_simplex",
          stan::model::index_uni(1), stan::model::index_omni()),
        "assigning variable td_simplex");
      current_statement__ = 360;
      stan::model::assign(td_simplex,
        stan::model::rvalue(td_1d_simplex, "td_1d_simplex",
          stan::model::index_uni(1), stan::model::index_omni()),
        "assigning variable td_simplex");
      current_statement__ = 361;
      stan::model::assign(td_simplex,
        stan::model::rvalue(td_1d_simplex, "td_1d_simplex",
          stan::model::index_uni(1), stan::model::index_min_max(1, N)),
        "assigning variable td_simplex");
      current_statement__ = 362;
      arr_mul_ind = std::vector<std::vector<int>>(2,
                      std::vector<int>(2, std::numeric_limits<int>::min()));
      current_statement__ = 363;
      stan::model::assign(arr_mul_ind, std::vector<int>{1, 1},
        "assigning variable arr_mul_ind", stan::model::index_uni(1),
        stan::model::index_min_max(1, 2));
      current_statement__ = 364;
      x_mul_ind = std::vector<double>(2,
                    std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 364;
      stan::model::assign(x_mul_ind, std::vector<double>{1, 2},
        "assigning variable x_mul_ind");
      current_statement__ = 365;
      transformed_data_real = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 366;
      stan::math::validate_non_negative_index("transformed_data_real_array",
        "d_int", d_int);
      current_statement__ = 367;
      transformed_data_real_array = std::vector<double>(d_int,
                                      std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 368;
      stan::math::validate_non_negative_index(
        "transformed_data_real_array_2d", "d_int", d_int);
      current_statement__ = 369;
      transformed_data_real_array_2d = std::vector<std::vector<double>>(d_int,
                                         std::vector<double>(2,
                                           std::numeric_limits<double>::quiet_NaN(
                                             )));
      current_statement__ = 370;
      stan::math::validate_non_negative_index(
        "transformed_data_real_array_3d", "d_int", d_int);
      current_statement__ = 371;
      transformed_data_real_array_3d = std::vector<
                                         std::vector<std::vector<double>>>(d_int,
                                         std::vector<std::vector<double>>(2,
                                           std::vector<double>(3,
                                             std::numeric_limits<double>::quiet_NaN(
                                               ))));
      current_statement__ = 372;
      stan::math::validate_non_negative_index("transformed_data_matrix",
        "d_int", d_int);
      current_statement__ = 373;
      stan::math::validate_non_negative_index("transformed_data_matrix",
        "d_int", d_int);
      current_statement__ = 374;
      transformed_data_matrix_data__ = Eigen::Matrix<double,-1,-1>::Constant(d_int,
                                         d_int,
                                         std::numeric_limits<double>::quiet_NaN(
                                           ));
      new (&transformed_data_matrix)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(transformed_data_matrix_data__.data(),
        d_int, d_int);
      current_statement__ = 375;
      stan::math::validate_non_negative_index(
        "transformed_data_matrix_array", "d_int", d_int);
      current_statement__ = 376;
      stan::math::validate_non_negative_index(
        "transformed_data_matrix_array", "d_int", d_int);
      current_statement__ = 377;
      stan::math::validate_non_negative_index(
        "transformed_data_matrix_array", "d_int", d_int);
      current_statement__ = 378;
      transformed_data_matrix_array = std::vector<
                                        Eigen::Matrix<double,-1,-1>>(d_int,
                                        Eigen::Matrix<double,-1,-1>::Constant(d_int,
                                          d_int,
                                          std::numeric_limits<double>::quiet_NaN(
                                            )));
      current_statement__ = 379;
      stan::math::validate_non_negative_index(
        "transformed_data_matrix_array_2d", "d_int", d_int);
      current_statement__ = 380;
      stan::math::validate_non_negative_index(
        "transformed_data_matrix_array_2d", "d_int", d_int);
      current_statement__ = 381;
      stan::math::validate_non_negative_index(
        "transformed_data_matrix_array_2d", "d_int", d_int);
      current_statement__ = 382;
      transformed_data_matrix_array_2d = std::vector<
                                           std::vector<
                                             Eigen::Matrix<double,-1,-1>>>(d_int,
                                           std::vector<
                                             Eigen::Matrix<double,-1,-1>>(2,
                                             Eigen::Matrix<double,-1,-1>::Constant(d_int,
                                               d_int,
                                               std::numeric_limits<double>::quiet_NaN(
                                                 ))));
      current_statement__ = 383;
      stan::math::validate_non_negative_index(
        "transformed_data_matrix_array_3d", "d_int", d_int);
      current_statement__ = 384;
      stan::math::validate_non_negative_index(
        "transformed_data_matrix_array_3d", "d_int", d_int);
      current_statement__ = 385;
      stan::math::validate_non_negative_index(
        "transformed_data_matrix_array_3d", "d_int", d_int);
      current_statement__ = 386;
      transformed_data_matrix_array_3d = std::vector<
                                           std::vector<
                                             std::vector<
                                               Eigen::Matrix<double,-1,-1>>>>(d_int,
                                           std::vector<
                                             std::vector<
                                               Eigen::Matrix<double,-1,-1>>>(2,
                                             std::vector<
                                               Eigen::Matrix<double,-1,-1>>(3,
                                               Eigen::Matrix<double,-1,-1>::Constant(d_int,
                                                 d_int,
                                                 std::numeric_limits<double>::quiet_NaN(
                                                   )))));
      current_statement__ = 387;
      stan::math::validate_non_negative_index("transformed_data_vector",
        "d_int", d_int);
      current_statement__ = 388;
      transformed_data_vector_data__ = Eigen::Matrix<double,-1,1>::Constant(d_int,
                                         std::numeric_limits<double>::quiet_NaN(
                                           ));
      new (&transformed_data_vector)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(transformed_data_vector_data__.data(),
        d_int);
      current_statement__ = 389;
      stan::math::validate_non_negative_index(
        "transformed_data_vector_array", "d_int", d_int);
      current_statement__ = 390;
      stan::math::validate_non_negative_index(
        "transformed_data_vector_array", "d_int", d_int);
      current_statement__ = 391;
      transformed_data_vector_array = std::vector<Eigen::Matrix<double,-1,1>>(d_int,
                                        Eigen::Matrix<double,-1,1>::Constant(d_int,
                                          std::numeric_limits<double>::quiet_NaN(
                                            )));
      current_statement__ = 392;
      stan::math::validate_non_negative_index(
        "transformed_data_vector_array_2d", "d_int", d_int);
      current_statement__ = 393;
      stan::math::validate_non_negative_index(
        "transformed_data_vector_array_2d", "d_int", d_int);
      current_statement__ = 394;
      transformed_data_vector_array_2d = std::vector<
                                           std::vector<
                                             Eigen::Matrix<double,-1,1>>>(d_int,
                                           std::vector<
                                             Eigen::Matrix<double,-1,1>>(2,
                                             Eigen::Matrix<double,-1,1>::Constant(d_int,
                                               std::numeric_limits<double>::quiet_NaN(
                                                 ))));
      current_statement__ = 395;
      stan::math::validate_non_negative_index(
        "transformed_data_vector_array_3d", "d_int", d_int);
      current_statement__ = 396;
      stan::math::validate_non_negative_index(
        "transformed_data_vector_array_3d", "d_int", d_int);
      current_statement__ = 397;
      transformed_data_vector_array_3d = std::vector<
                                           std::vector<
                                             std::vector<
                                               Eigen::Matrix<double,-1,1>>>>(d_int,
                                           std::vector<
                                             std::vector<
                                               Eigen::Matrix<double,-1,1>>>(2,
                                             std::vector<
                                               Eigen::Matrix<double,-1,1>>(3,
                                               Eigen::Matrix<double,-1,1>::Constant(d_int,
                                                 std::numeric_limits<double>::quiet_NaN(
                                                   )))));
      current_statement__ = 398;
      stan::math::validate_non_negative_index("transformed_data_row_vector",
        "d_int", d_int);
      current_statement__ = 399;
      transformed_data_row_vector_data__ = Eigen::Matrix<double,1,-1>::Constant(d_int,
                                             std::numeric_limits<double>::quiet_NaN(
                                               ));
      new (&transformed_data_row_vector)
        Eigen::Map<Eigen::Matrix<double,1,-1>>(transformed_data_row_vector_data__.data(),
        d_int);
      current_statement__ = 400;
      stan::math::validate_non_negative_index(
        "transformed_data_row_vector_array", "d_int", d_int);
      current_statement__ = 401;
      stan::math::validate_non_negative_index(
        "transformed_data_row_vector_array", "d_int", d_int);
      current_statement__ = 402;
      transformed_data_row_vector_array = std::vector<
                                            Eigen::Matrix<double,1,-1>>(d_int,
                                            Eigen::Matrix<double,1,-1>::Constant(d_int,
                                              std::numeric_limits<double>::quiet_NaN(
                                                )));
      current_statement__ = 403;
      stan::math::validate_non_negative_index(
        "transformed_data_row_vector_array_2d", "d_int", d_int);
      current_statement__ = 404;
      stan::math::validate_non_negative_index(
        "transformed_data_row_vector_array_2d", "d_int", d_int);
      current_statement__ = 405;
      transformed_data_row_vector_array_2d = std::vector<
                                               std::vector<
                                                 Eigen::Matrix<double,1,-1>>>(d_int,
                                               std::vector<
                                                 Eigen::Matrix<double,1,-1>>(2,
                                                 Eigen::Matrix<double,1,-1>::Constant(d_int,
                                                   std::numeric_limits<double>::quiet_NaN(
                                                     ))));
      current_statement__ = 406;
      stan::math::validate_non_negative_index(
        "transformed_data_row_vector_array_3d", "d_int", d_int);
      current_statement__ = 407;
      stan::math::validate_non_negative_index(
        "transformed_data_row_vector_array_3d", "d_int", d_int);
      current_statement__ = 408;
      transformed_data_row_vector_array_3d = std::vector<
                                               std::vector<
                                                 std::vector<
                                                   Eigen::Matrix<double,1,-1>>>>(d_int,
                                               std::vector<
                                                 std::vector<
                                                   Eigen::Matrix<double,1,-1>>>(2,
                                                 std::vector<
                                                   Eigen::Matrix<double,1,-1>>(3,
                                                   Eigen::Matrix<double,1,-1>::Constant(d_int,
                                                     std::numeric_limits<double>::quiet_NaN(
                                                       )))));
      current_statement__ = 409;
      transformed_data_real = stan::math::pow(d_int, d_int);
      current_statement__ = 410;
      transformed_data_real = stan::math::pow(d_real, d_int);
      current_statement__ = 411;
      transformed_data_real = stan::math::pow(d_int, d_real);
      current_statement__ = 412;
      transformed_data_real = stan::math::pow(d_real, d_real);
      current_statement__ = 413;
      stan::model::assign(transformed_data_real_array,
        stan::math::pow(d_int_array, d_int),
        "assigning variable transformed_data_real_array");
      current_statement__ = 414;
      stan::model::assign(transformed_data_real_array,
        stan::math::pow(d_int_array, d_real),
        "assigning variable transformed_data_real_array");
      current_statement__ = 415;
      stan::model::assign(transformed_data_real_array_2d,
        stan::math::pow(d_int_array_2d, d_int),
        "assigning variable transformed_data_real_array_2d");
      current_statement__ = 416;
      stan::model::assign(transformed_data_real_array_2d,
        stan::math::pow(d_int_array_2d, d_real),
        "assigning variable transformed_data_real_array_2d");
      current_statement__ = 417;
      stan::model::assign(transformed_data_real_array_3d,
        stan::math::pow(d_int_array_3d, d_int),
        "assigning variable transformed_data_real_array_3d");
      current_statement__ = 418;
      stan::model::assign(transformed_data_real_array_3d,
        stan::math::pow(d_int_array_3d, d_real),
        "assigning variable transformed_data_real_array_3d");
      current_statement__ = 419;
      stan::model::assign(transformed_data_real_array,
        stan::math::pow(d_int, d_int_array),
        "assigning variable transformed_data_real_array");
      current_statement__ = 420;
      stan::model::assign(transformed_data_real_array,
        stan::math::pow(d_real, d_int_array),
        "assigning variable transformed_data_real_array");
      current_statement__ = 421;
      stan::model::assign(transformed_data_real_array_2d,
        stan::math::pow(d_int, d_int_array_2d),
        "assigning variable transformed_data_real_array_2d");
      current_statement__ = 422;
      stan::model::assign(transformed_data_real_array_2d,
        stan::math::pow(d_real, d_int_array_2d),
        "assigning variable transformed_data_real_array_2d");
      current_statement__ = 423;
      stan::model::assign(transformed_data_real_array_3d,
        stan::math::pow(d_int, d_int_array_3d),
        "assigning variable transformed_data_real_array_3d");
      current_statement__ = 424;
      stan::model::assign(transformed_data_real_array_3d,
        stan::math::pow(d_real, d_int_array_3d),
        "assigning variable transformed_data_real_array_3d");
      current_statement__ = 425;
      stan::model::assign(transformed_data_real_array,
        stan::math::pow(d_int, d_real_array),
        "assigning variable transformed_data_real_array");
      current_statement__ = 426;
      stan::model::assign(transformed_data_real_array,
        stan::math::pow(d_real, d_real_array),
        "assigning variable transformed_data_real_array");
      current_statement__ = 427;
      stan::model::assign(transformed_data_real_array_2d,
        stan::math::pow(d_int, d_real_array_2d),
        "assigning variable transformed_data_real_array_2d");
      current_statement__ = 428;
      stan::model::assign(transformed_data_real_array_2d,
        stan::math::pow(d_real, d_real_array_2d),
        "assigning variable transformed_data_real_array_2d");
      current_statement__ = 429;
      stan::model::assign(transformed_data_real_array_3d,
        stan::math::pow(d_int, d_real_array_3d),
        "assigning variable transformed_data_real_array_3d");
      current_statement__ = 430;
      stan::model::assign(transformed_data_real_array_3d,
        stan::math::pow(d_real, d_real_array_3d),
        "assigning variable transformed_data_real_array_3d");
      current_statement__ = 431;
      stan::model::assign(transformed_data_real_array,
        stan::math::pow(d_real_array, d_int),
        "assigning variable transformed_data_real_array");
      current_statement__ = 432;
      stan::model::assign(transformed_data_real_array,
        stan::math::pow(d_real_array, d_real),
        "assigning variable transformed_data_real_array");
      current_statement__ = 433;
      stan::model::assign(transformed_data_real_array_2d,
        stan::math::pow(d_real_array_2d, d_int),
        "assigning variable transformed_data_real_array_2d");
      current_statement__ = 434;
      stan::model::assign(transformed_data_real_array_2d,
        stan::math::pow(d_real_array_2d, d_real),
        "assigning variable transformed_data_real_array_2d");
      current_statement__ = 435;
      stan::model::assign(transformed_data_real_array_3d,
        stan::math::pow(d_real_array_3d, d_int),
        "assigning variable transformed_data_real_array_3d");
      current_statement__ = 436;
      stan::model::assign(transformed_data_real_array_3d,
        stan::math::pow(d_real_array_3d, d_real),
        "assigning variable transformed_data_real_array_3d");
      current_statement__ = 437;
      stan::model::assign(transformed_data_real_array,
        stan::math::pow(d_int_array, d_int_array),
        "assigning variable transformed_data_real_array");
      current_statement__ = 438;
      stan::model::assign(transformed_data_real_array,
        stan::math::pow(d_real_array, d_real_array),
        "assigning variable transformed_data_real_array");
      current_statement__ = 439;
      stan::model::assign(transformed_data_real_array_2d,
        stan::math::pow(d_int_array_2d, d_int_array_2d),
        "assigning variable transformed_data_real_array_2d");
      current_statement__ = 440;
      stan::model::assign(transformed_data_real_array_2d,
        stan::math::pow(d_real_array_2d, d_real_array_2d),
        "assigning variable transformed_data_real_array_2d");
      current_statement__ = 441;
      stan::model::assign(transformed_data_real_array_3d,
        stan::math::pow(d_int_array_3d, d_int_array_3d),
        "assigning variable transformed_data_real_array_3d");
      current_statement__ = 442;
      stan::model::assign(transformed_data_real_array_3d,
        stan::math::pow(d_real_array_3d, d_real_array_3d),
        "assigning variable transformed_data_real_array_3d");
      current_statement__ = 443;
      stan::model::assign(transformed_data_vector,
        stan::math::pow(d_vector, d_int),
        "assigning variable transformed_data_vector");
      current_statement__ = 444;
      stan::model::assign(transformed_data_vector,
        stan::math::pow(d_vector, d_real),
        "assigning variable transformed_data_vector");
      current_statement__ = 445;
      stan::model::assign(transformed_data_vector,
        stan::math::fma(d_vector, d_vector, d_vector),
        "assigning variable transformed_data_vector");
      current_statement__ = 446;
      stan::model::assign(transformed_data_vector,
        stan::math::fma(d_vector, d_vector, d_real),
        "assigning variable transformed_data_vector");
      current_statement__ = 447;
      stan::model::assign(transformed_data_vector,
        stan::math::fma(d_real, d_vector, d_real),
        "assigning variable transformed_data_vector");
      current_statement__ = 448;
      stan::model::assign(transformed_data_vector_array,
        stan::math::pow(d_vector_array, d_int),
        "assigning variable transformed_data_vector_array");
      current_statement__ = 449;
      stan::model::assign(transformed_data_vector_array,
        stan::math::pow(d_vector_array, d_real),
        "assigning variable transformed_data_vector_array");
      current_statement__ = 450;
      stan::model::assign(transformed_data_vector_array_2d,
        stan::math::pow(d_vector_array_2d, d_int),
        "assigning variable transformed_data_vector_array_2d");
      current_statement__ = 451;
      stan::model::assign(transformed_data_vector_array_2d,
        stan::math::pow(d_vector_array_2d, d_real),
        "assigning variable transformed_data_vector_array_2d");
      current_statement__ = 452;
      stan::model::assign(transformed_data_vector_array_3d,
        stan::math::pow(d_vector_array_3d, d_int),
        "assigning variable transformed_data_vector_array_3d");
      current_statement__ = 453;
      stan::model::assign(transformed_data_vector_array_3d,
        stan::math::pow(d_vector_array_3d, d_real),
        "assigning variable transformed_data_vector_array_3d");
      current_statement__ = 454;
      stan::model::assign(transformed_data_vector,
        stan::math::pow(d_int, d_vector),
        "assigning variable transformed_data_vector");
      current_statement__ = 455;
      stan::model::assign(transformed_data_vector,
        stan::math::pow(d_real, d_vector),
        "assigning variable transformed_data_vector");
      current_statement__ = 456;
      stan::model::assign(transformed_data_vector_array,
        stan::math::pow(d_int, d_vector_array),
        "assigning variable transformed_data_vector_array");
      current_statement__ = 457;
      stan::model::assign(transformed_data_vector_array,
        stan::math::pow(d_real, d_vector_array),
        "assigning variable transformed_data_vector_array");
      current_statement__ = 458;
      stan::model::assign(transformed_data_vector_array_2d,
        stan::math::pow(d_int, d_vector_array_2d),
        "assigning variable transformed_data_vector_array_2d");
      current_statement__ = 459;
      stan::model::assign(transformed_data_vector_array_2d,
        stan::math::pow(d_real, d_vector_array_2d),
        "assigning variable transformed_data_vector_array_2d");
      current_statement__ = 460;
      stan::model::assign(transformed_data_vector_array_3d,
        stan::math::pow(d_int, d_vector_array_3d),
        "assigning variable transformed_data_vector_array_3d");
      current_statement__ = 461;
      stan::model::assign(transformed_data_vector_array_3d,
        stan::math::pow(d_real, d_vector_array_3d),
        "assigning variable transformed_data_vector_array_3d");
      current_statement__ = 462;
      stan::model::assign(transformed_data_vector,
        stan::math::pow(d_vector, d_vector),
        "assigning variable transformed_data_vector");
      current_statement__ = 463;
      stan::model::assign(transformed_data_vector,
        stan::math::fma(d_vector, d_vector, d_vector),
        "assigning variable transformed_data_vector");
      current_statement__ = 464;
      stan::model::assign(transformed_data_vector,
        stan::math::fma(d_vector, d_vector, d_real),
        "assigning variable transformed_data_vector");
      current_statement__ = 465;
      stan::model::assign(transformed_data_vector_array,
        stan::math::pow(d_vector_array, d_vector_array),
        "assigning variable transformed_data_vector_array");
      current_statement__ = 466;
      stan::model::assign(transformed_data_vector_array_2d,
        stan::math::pow(d_vector_array_2d, d_vector_array_2d),
        "assigning variable transformed_data_vector_array_2d");
      current_statement__ = 467;
      stan::model::assign(transformed_data_vector_array_3d,
        stan::math::pow(d_vector_array_3d, d_vector_array_3d),
        "assigning variable transformed_data_vector_array_3d");
      current_statement__ = 468;
      stan::model::assign(transformed_data_row_vector,
        stan::math::pow(d_row_vector, d_int),
        "assigning variable transformed_data_row_vector");
      current_statement__ = 469;
      stan::model::assign(transformed_data_row_vector,
        stan::math::pow(d_row_vector, d_real),
        "assigning variable transformed_data_row_vector");
      current_statement__ = 470;
      stan::model::assign(transformed_data_row_vector_array,
        stan::math::pow(d_row_vector_array, d_int),
        "assigning variable transformed_data_row_vector_array");
      current_statement__ = 471;
      stan::model::assign(transformed_data_row_vector_array,
        stan::math::pow(d_row_vector_array, d_real),
        "assigning variable transformed_data_row_vector_array");
      current_statement__ = 472;
      stan::model::assign(transformed_data_row_vector_array_2d,
        stan::math::pow(d_row_vector_array_2d, d_int),
        "assigning variable transformed_data_row_vector_array_2d");
      current_statement__ = 473;
      stan::model::assign(transformed_data_row_vector_array_2d,
        stan::math::pow(d_row_vector_array_2d, d_real),
        "assigning variable transformed_data_row_vector_array_2d");
      current_statement__ = 474;
      stan::model::assign(transformed_data_row_vector_array_3d,
        stan::math::pow(d_row_vector_array_3d, d_int),
        "assigning variable transformed_data_row_vector_array_3d");
      current_statement__ = 475;
      stan::model::assign(transformed_data_row_vector_array_3d,
        stan::math::pow(d_row_vector_array_3d, d_real),
        "assigning variable transformed_data_row_vector_array_3d");
      current_statement__ = 476;
      stan::model::assign(transformed_data_row_vector,
        stan::math::pow(d_int, d_row_vector),
        "assigning variable transformed_data_row_vector");
      current_statement__ = 477;
      stan::model::assign(transformed_data_row_vector,
        stan::math::pow(d_real, d_row_vector),
        "assigning variable transformed_data_row_vector");
      current_statement__ = 478;
      stan::model::assign(transformed_data_row_vector_array,
        stan::math::pow(d_int, d_row_vector_array),
        "assigning variable transformed_data_row_vector_array");
      current_statement__ = 479;
      stan::model::assign(transformed_data_row_vector_array,
        stan::math::pow(d_real, d_row_vector_array),
        "assigning variable transformed_data_row_vector_array");
      current_statement__ = 480;
      stan::model::assign(transformed_data_row_vector_array_2d,
        stan::math::pow(d_int, d_row_vector_array_2d),
        "assigning variable transformed_data_row_vector_array_2d");
      current_statement__ = 481;
      stan::model::assign(transformed_data_row_vector_array_2d,
        stan::math::pow(d_real, d_row_vector_array_2d),
        "assigning variable transformed_data_row_vector_array_2d");
      current_statement__ = 482;
      stan::model::assign(transformed_data_row_vector_array_3d,
        stan::math::pow(d_int, d_row_vector_array_3d),
        "assigning variable transformed_data_row_vector_array_3d");
      current_statement__ = 483;
      stan::model::assign(transformed_data_row_vector_array_3d,
        stan::math::pow(d_real, d_row_vector_array_3d),
        "assigning variable transformed_data_row_vector_array_3d");
      current_statement__ = 484;
      stan::model::assign(transformed_data_row_vector,
        stan::math::pow(d_row_vector, d_row_vector),
        "assigning variable transformed_data_row_vector");
      current_statement__ = 485;
      stan::model::assign(transformed_data_row_vector_array,
        stan::math::pow(d_row_vector_array, d_row_vector_array),
        "assigning variable transformed_data_row_vector_array");
      current_statement__ = 486;
      stan::model::assign(transformed_data_row_vector_array_2d,
        stan::math::pow(d_row_vector_array_2d, d_row_vector_array_2d),
        "assigning variable transformed_data_row_vector_array_2d");
      current_statement__ = 487;
      stan::model::assign(transformed_data_row_vector_array_3d,
        stan::math::pow(d_row_vector_array_3d, d_row_vector_array_3d),
        "assigning variable transformed_data_row_vector_array_3d");
      current_statement__ = 488;
      stan::model::assign(transformed_data_matrix,
        stan::math::pow(d_matrix, d_int),
        "assigning variable transformed_data_matrix");
      current_statement__ = 489;
      stan::model::assign(transformed_data_matrix,
        stan::math::pow(d_matrix, d_real),
        "assigning variable transformed_data_matrix");
      current_statement__ = 490;
      stan::model::assign(transformed_data_matrix,
        stan::math::fma(d_matrix, d_matrix, d_matrix),
        "assigning variable transformed_data_matrix");
      current_statement__ = 491;
      stan::model::assign(transformed_data_matrix,
        stan::math::fma(d_matrix, d_matrix, d_real),
        "assigning variable transformed_data_matrix");
      current_statement__ = 492;
      stan::model::assign(transformed_data_matrix_array,
        stan::math::pow(d_matrix_array, d_int),
        "assigning variable transformed_data_matrix_array");
      current_statement__ = 493;
      stan::model::assign(transformed_data_matrix_array,
        stan::math::pow(d_matrix_array, d_real),
        "assigning variable transformed_data_matrix_array");
      current_statement__ = 494;
      stan::model::assign(transformed_data_matrix_array_2d,
        stan::math::pow(d_matrix_array_2d, d_int),
        "assigning variable transformed_data_matrix_array_2d");
      current_statement__ = 495;
      stan::model::assign(transformed_data_matrix_array_2d,
        stan::math::pow(d_matrix_array_2d, d_real),
        "assigning variable transformed_data_matrix_array_2d");
      current_statement__ = 496;
      stan::model::assign(transformed_data_matrix_array_3d,
        stan::math::pow(d_matrix_array_3d, d_int),
        "assigning variable transformed_data_matrix_array_3d");
      current_statement__ = 497;
      stan::model::assign(transformed_data_matrix_array_3d,
        stan::math::pow(d_matrix_array_3d, d_real),
        "assigning variable transformed_data_matrix_array_3d");
      current_statement__ = 498;
      stan::model::assign(transformed_data_matrix,
        stan::math::pow(d_int, d_matrix),
        "assigning variable transformed_data_matrix");
      current_statement__ = 499;
      stan::model::assign(transformed_data_matrix,
        stan::math::pow(d_real, d_matrix),
        "assigning variable transformed_data_matrix");
      current_statement__ = 500;
      stan::model::assign(transformed_data_matrix_array,
        stan::math::pow(d_int, d_matrix_array),
        "assigning variable transformed_data_matrix_array");
      current_statement__ = 501;
      stan::model::assign(transformed_data_matrix_array,
        stan::math::pow(d_real, d_matrix_array),
        "assigning variable transformed_data_matrix_array");
      current_statement__ = 502;
      stan::model::assign(transformed_data_matrix_array_2d,
        stan::math::pow(d_int, d_matrix_array_2d),
        "assigning variable transformed_data_matrix_array_2d");
      current_statement__ = 503;
      stan::model::assign(transformed_data_matrix_array_2d,
        stan::math::pow(d_real, d_matrix_array_2d),
        "assigning variable transformed_data_matrix_array_2d");
      current_statement__ = 504;
      stan::model::assign(transformed_data_matrix_array_3d,
        stan::math::pow(d_int, d_matrix_array_3d),
        "assigning variable transformed_data_matrix_array_3d");
      current_statement__ = 505;
      stan::model::assign(transformed_data_matrix_array_3d,
        stan::math::pow(d_real, d_matrix_array_3d),
        "assigning variable transformed_data_matrix_array_3d");
      current_statement__ = 506;
      stan::model::assign(transformed_data_matrix,
        stan::math::pow(d_matrix, d_matrix),
        "assigning variable transformed_data_matrix");
      current_statement__ = 507;
      stan::model::assign(transformed_data_matrix_array,
        stan::math::pow(d_matrix_array, d_matrix_array),
        "assigning variable transformed_data_matrix_array");
      current_statement__ = 508;
      stan::model::assign(transformed_data_matrix_array_2d,
        stan::math::pow(d_matrix_array_2d, d_matrix_array_2d),
        "assigning variable transformed_data_matrix_array_2d");
      current_statement__ = 509;
      stan::model::assign(transformed_data_matrix_array_3d,
        stan::math::pow(d_matrix_array_3d, d_matrix_array_3d),
        "assigning variable transformed_data_matrix_array_3d");
      current_statement__ = 510;
      td_int = (d_int * d_int);
      current_statement__ = 511;
      transformed_data_real = (d_real * d_real);
      current_statement__ = 300;
      stan::math::check_greater_or_equal(function__, "td_ar_mat", td_ar_mat,
        0);
      current_statement__ = 300;
      stan::math::check_less_or_equal(function__, "td_ar_mat", td_ar_mat, 1);
      current_statement__ = 302;
      stan::math::check_simplex(function__, "td_simplex", td_simplex);
      current_statement__ = 305;
      stan::math::check_simplex(function__, "td_1d_simplex", td_1d_simplex);
      current_statement__ = 310;
      stan::math::check_simplex(function__, "td_3d_simplex", td_3d_simplex);
      current_statement__ = 311;
      stan::math::check_cholesky_factor(function__, "td_cfcov_54",
        td_cfcov_54);
      current_statement__ = 312;
      stan::math::check_cholesky_factor(function__, "td_cfcov_33",
        td_cfcov_33);
      current_statement__ = 512;
      stan::math::validate_non_negative_index("p_real_1d_ar", "N", N);
      current_statement__ = 513;
      stan::math::validate_non_negative_index("p_real_3d_ar", "N", N);
      current_statement__ = 514;
      stan::math::validate_non_negative_index("p_real_3d_ar", "M", M);
      current_statement__ = 515;
      stan::math::validate_non_negative_index("p_real_3d_ar", "K", K);
      current_statement__ = 516;
      stan::math::validate_non_negative_index("p_vec", "N", N);
      current_statement__ = 517;
      stan::math::validate_non_negative_index("p_1d_vec", "N", N);
      current_statement__ = 518;
      stan::math::validate_non_negative_index("p_1d_vec", "N", N);
      current_statement__ = 519;
      stan::math::validate_non_negative_index("p_3d_vec", "N", N);
      current_statement__ = 520;
      stan::math::validate_non_negative_index("p_3d_vec", "M", M);
      current_statement__ = 521;
      stan::math::validate_non_negative_index("p_3d_vec", "K", K);
      current_statement__ = 522;
      stan::math::validate_non_negative_index("p_3d_vec", "N", N);
      current_statement__ = 523;
      stan::math::validate_non_negative_index("p_row_vec", "N", N);
      current_statement__ = 524;
      stan::math::validate_non_negative_index("p_1d_row_vec", "N", N);
      current_statement__ = 525;
      stan::math::validate_non_negative_index("p_1d_row_vec", "N", N);
      current_statement__ = 526;
      stan::math::validate_non_negative_index("p_3d_row_vec", "N", N);
      current_statement__ = 527;
      stan::math::validate_non_negative_index("p_3d_row_vec", "M", M);
      current_statement__ = 528;
      stan::math::validate_non_negative_index("p_3d_row_vec", "K", K);
      current_statement__ = 529;
      stan::math::validate_non_negative_index("p_3d_row_vec", "N", N);
      current_statement__ = 530;
      stan::math::validate_positive_index("p_simplex", "N", N);
      current_statement__ = 531;
      stan::math::validate_non_negative_index("p_1d_simplex", "N", N);
      current_statement__ = 532;
      stan::math::validate_positive_index("p_1d_simplex", "N", N);
      current_statement__ = 533;
      stan::math::validate_non_negative_index("p_3d_simplex", "N", N);
      current_statement__ = 534;
      stan::math::validate_non_negative_index("p_3d_simplex", "M", M);
      current_statement__ = 535;
      stan::math::validate_non_negative_index("p_3d_simplex", "K", K);
      current_statement__ = 536;
      stan::math::validate_positive_index("p_3d_simplex", "N", N);
      current_statement__ = 537;
      stan::math::check_greater_or_equal("cholesky_factor_cov p_cfcov_54",
        "num rows (must be greater or equal to num cols)", 5, 4);
      current_statement__ = 538;
      stan::math::check_greater_or_equal("cholesky_factor_cov p_cfcov_33",
        "num rows (must be greater or equal to num cols)", 3, 3);
      current_statement__ = 539;
      stan::math::validate_non_negative_index("p_cfcov_33_ar", "K", K);
      current_statement__ = 540;
      stan::math::check_greater_or_equal("cholesky_factor_cov p_cfcov_33_ar",
        "num rows (must be greater or equal to num cols)", 3, 3);
      current_statement__ = 541;
      stan::math::validate_non_negative_index("tp_real_1d_ar", "N", N);
      current_statement__ = 542;
      stan::math::validate_non_negative_index("tp_real_3d_ar", "N", N);
      current_statement__ = 543;
      stan::math::validate_non_negative_index("tp_real_3d_ar", "M", M);
      current_statement__ = 544;
      stan::math::validate_non_negative_index("tp_real_3d_ar", "K", K);
      current_statement__ = 545;
      stan::math::validate_non_negative_index("tp_vec", "N", N);
      current_statement__ = 546;
      stan::math::validate_non_negative_index("tp_1d_vec", "N", N);
      current_statement__ = 547;
      stan::math::validate_non_negative_index("tp_1d_vec", "N", N);
      current_statement__ = 548;
      stan::math::validate_non_negative_index("tp_3d_vec", "N", N);
      current_statement__ = 549;
      stan::math::validate_non_negative_index("tp_3d_vec", "M", M);
      current_statement__ = 550;
      stan::math::validate_non_negative_index("tp_3d_vec", "K", K);
      current_statement__ = 551;
      stan::math::validate_non_negative_index("tp_3d_vec", "N", N);
      current_statement__ = 552;
      stan::math::validate_non_negative_index("tp_row_vec", "N", N);
      current_statement__ = 553;
      stan::math::validate_non_negative_index("tp_1d_row_vec", "N", N);
      current_statement__ = 554;
      stan::math::validate_non_negative_index("tp_1d_row_vec", "N", N);
      current_statement__ = 555;
      stan::math::validate_non_negative_index("tp_3d_row_vec", "N", N);
      current_statement__ = 556;
      stan::math::validate_non_negative_index("tp_3d_row_vec", "M", M);
      current_statement__ = 557;
      stan::math::validate_non_negative_index("tp_3d_row_vec", "K", K);
      current_statement__ = 558;
      stan::math::validate_non_negative_index("tp_3d_row_vec", "N", N);
      current_statement__ = 559;
      stan::math::validate_non_negative_index("tp_simplex", "N", N);
      current_statement__ = 560;
      stan::math::validate_non_negative_index("tp_1d_simplex", "N", N);
      current_statement__ = 561;
      stan::math::validate_non_negative_index("tp_1d_simplex", "N", N);
      current_statement__ = 562;
      stan::math::validate_non_negative_index("tp_3d_simplex", "N", N);
      current_statement__ = 563;
      stan::math::validate_non_negative_index("tp_3d_simplex", "M", M);
      current_statement__ = 564;
      stan::math::validate_non_negative_index("tp_3d_simplex", "K", K);
      current_statement__ = 565;
      stan::math::validate_non_negative_index("tp_3d_simplex", "N", N);
      current_statement__ = 566;
      stan::math::validate_non_negative_index("tp_cfcov_33_ar", "K", K);
      current_statement__ = 567;
      stan::math::validate_non_negative_index("gq_real_1d_ar", "N", N);
      current_statement__ = 568;
      stan::math::validate_non_negative_index("gq_real_3d_ar", "N", N);
      current_statement__ = 569;
      stan::math::validate_non_negative_index("gq_real_3d_ar", "M", M);
      current_statement__ = 570;
      stan::math::validate_non_negative_index("gq_real_3d_ar", "K", K);
      current_statement__ = 571;
      stan::math::validate_non_negative_index("gq_vec", "N", N);
      current_statement__ = 572;
      stan::math::validate_non_negative_index("gq_1d_vec", "N", N);
      current_statement__ = 573;
      stan::math::validate_non_negative_index("gq_1d_vec", "N", N);
      current_statement__ = 574;
      stan::math::validate_non_negative_index("gq_3d_vec", "N", N);
      current_statement__ = 575;
      stan::math::validate_non_negative_index("gq_3d_vec", "M", M);
      current_statement__ = 576;
      stan::math::validate_non_negative_index("gq_3d_vec", "K", K);
      current_statement__ = 577;
      stan::math::validate_non_negative_index("gq_3d_vec", "N", N);
      current_statement__ = 578;
      stan::math::validate_non_negative_index("gq_row_vec", "N", N);
      current_statement__ = 579;
      stan::math::validate_non_negative_index("gq_1d_row_vec", "N", N);
      current_statement__ = 580;
      stan::math::validate_non_negative_index("gq_1d_row_vec", "N", N);
      current_statement__ = 581;
      stan::math::validate_non_negative_index("gq_3d_row_vec", "N", N);
      current_statement__ = 582;
      stan::math::validate_non_negative_index("gq_3d_row_vec", "M", M);
      current_statement__ = 583;
      stan::math::validate_non_negative_index("gq_3d_row_vec", "K", K);
      current_statement__ = 584;
      stan::math::validate_non_negative_index("gq_3d_row_vec", "N", N);
      current_statement__ = 585;
      stan::math::validate_non_negative_index("gq_simplex", "N", N);
      current_statement__ = 586;
      stan::math::validate_non_negative_index("gq_1d_simplex", "N", N);
      current_statement__ = 587;
      stan::math::validate_non_negative_index("gq_1d_simplex", "N", N);
      current_statement__ = 588;
      stan::math::validate_non_negative_index("gq_3d_simplex", "N", N);
      current_statement__ = 589;
      stan::math::validate_non_negative_index("gq_3d_simplex", "M", M);
      current_statement__ = 590;
      stan::math::validate_non_negative_index("gq_3d_simplex", "K", K);
      current_statement__ = 591;
      stan::math::validate_non_negative_index("gq_3d_simplex", "N", N);
      current_statement__ = 592;
      stan::math::validate_non_negative_index("gq_cfcov_33_ar", "K", K);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 5 + 5 + 5 + N + (N * (M * K)) + N + (N * N)
      + (N * (M * (K * N))) + N + (N * N) + (N * (M * (K * N))) + (5 * 4) +
      (4 * (5 * (2 * 3))) + (N - 1) + (N * (N - 1)) + (N * (M * (K * (N -
      1)))) + ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4)) + ((((3 * (3 - 1))
      / 2) + 3) + ((3 - 3) * 3)) + (K * ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3)
      * 3))) + 2 + 2;
  }
  inline std::string model_name() const final {
    return "mother_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "mother_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ p_real = DUMMY_VAR__;
      current_statement__ = 1;
      p_real = in__.template read<local_scalar_t__>();
      local_scalar_t__ p_upper = DUMMY_VAR__;
      current_statement__ = 2;
      p_upper = in__.template read_constrain_lb<local_scalar_t__,
                  jacobian__>(p_real, lp__);
      local_scalar_t__ p_lower = DUMMY_VAR__;
      current_statement__ = 3;
      p_lower = in__.template read_constrain_ub<local_scalar_t__,
                  jacobian__>(p_upper, lp__);
      std::vector<local_scalar_t__> offset_multiplier =
        std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      current_statement__ = 4;
      offset_multiplier = in__.template read_constrain_offset_multiplier<
                            std::vector<local_scalar_t__>, jacobian__>(1, 2,
                            lp__, 5);
      std::vector<local_scalar_t__> no_offset_multiplier =
        std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      current_statement__ = 5;
      no_offset_multiplier = in__.template read_constrain_offset_multiplier<
                               std::vector<local_scalar_t__>, jacobian__>(0,
                               2, lp__, 5);
      std::vector<local_scalar_t__> offset_no_multiplier =
        std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      current_statement__ = 6;
      offset_no_multiplier = in__.template read_constrain_offset_multiplier<
                               std::vector<local_scalar_t__>, jacobian__>(3,
                               1, lp__, 5);
      std::vector<local_scalar_t__> p_real_1d_ar =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 7;
      p_real_1d_ar = in__.template read_constrain_lb<
                       std::vector<local_scalar_t__>, jacobian__>(0, lp__, N);
      std::vector<std::vector<std::vector<local_scalar_t__>>> p_real_3d_ar =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(N,
          std::vector<std::vector<local_scalar_t__>>(M,
            std::vector<local_scalar_t__>(K, DUMMY_VAR__)));
      current_statement__ = 8;
      p_real_3d_ar = in__.template read_constrain_lb<
                       std::vector<
                         std::vector<std::vector<local_scalar_t__>>>,
                       jacobian__>(0, lp__, N, M, K);
      Eigen::Matrix<local_scalar_t__,-1,1> p_vec =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 9;
      p_vec = in__.template read_constrain_lb<
                Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__, N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> p_1d_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 10;
      p_1d_vec = in__.template read<
                   std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N, N);
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>
        p_3d_vec =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__))));
      current_statement__ = 11;
      p_3d_vec = in__.template read<
                   std::vector<
                     std::vector<
                       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>>(N,
                   M, K, N);
      Eigen::Matrix<local_scalar_t__,1,-1> p_row_vec =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 12;
      p_row_vec = in__.template read<Eigen::Matrix<local_scalar_t__,1,-1>>(N);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> p_1d_row_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 13;
      p_1d_row_vec = in__.template read<
                       std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
                       N);
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>
        p_3d_row_vec =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(K,
              Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__))));
      current_statement__ = 14;
      p_3d_row_vec = in__.template read<
                       std::vector<
                         std::vector<
                           std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>>(N,
                       M, K, N);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 4, DUMMY_VAR__);
      current_statement__ = 15;
      p_mat = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 4);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>
        p_ar_mat =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(4,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 3,
              DUMMY_VAR__)));
      current_statement__ = 16;
      p_ar_mat = in__.template read_constrain_lub<
                   std::vector<
                     std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>,
                   jacobian__>(0, 1, lp__, 4, 5, 2, 3);
      Eigen::Matrix<local_scalar_t__,-1,1> p_simplex =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 17;
      p_simplex = in__.template read_constrain_simplex<
                    Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lp__,
                    N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> p_1d_simplex =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 18;
      p_1d_simplex = in__.template read_constrain_simplex<
                       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>,
                       jacobian__>(lp__, N, N);
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>
        p_3d_simplex =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__))));
      current_statement__ = 19;
      p_3d_simplex = in__.template read_constrain_simplex<
                       std::vector<
                         std::vector<
                           std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>,
                       jacobian__>(lp__, N, M, K, N);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_cfcov_54 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 4, DUMMY_VAR__);
      current_statement__ = 20;
      p_cfcov_54 = in__.template read_constrain_cholesky_factor_cov<
                     Eigen::Matrix<local_scalar_t__,-1,-1>, jacobian__>(lp__,
                     5, 4);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_cfcov_33 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 3, DUMMY_VAR__);
      current_statement__ = 21;
      p_cfcov_33 = in__.template read_constrain_cholesky_factor_cov<
                     Eigen::Matrix<local_scalar_t__,-1,-1>, jacobian__>(lp__,
                     3, 3);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> p_cfcov_33_ar =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(K,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 3, DUMMY_VAR__));
      current_statement__ = 22;
      p_cfcov_33_ar = in__.template read_constrain_cholesky_factor_cov<
                        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
                        jacobian__>(lp__, K, 3, 3);
      Eigen::Matrix<local_scalar_t__,-1,1> x_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 23;
      x_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      Eigen::Matrix<local_scalar_t__,-1,1> y_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 24;
      y_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      std::vector<local_scalar_t__> tp_real_1d_ar =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      std::vector<std::vector<std::vector<local_scalar_t__>>> tp_real_3d_ar =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(N,
          std::vector<std::vector<local_scalar_t__>>(M,
            std::vector<local_scalar_t__>(K, DUMMY_VAR__)));
      Eigen::Matrix<local_scalar_t__,-1,1> tp_vec =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> tp_1d_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>
        tp_3d_vec =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__))));
      Eigen::Matrix<local_scalar_t__,1,-1> tp_row_vec =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> tp_1d_row_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>
        tp_3d_row_vec =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(K,
              Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__))));
      Eigen::Matrix<local_scalar_t__,-1,-1> tp_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 4, DUMMY_VAR__);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>
        tp_ar_mat =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(4,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 3,
              DUMMY_VAR__)));
      Eigen::Matrix<local_scalar_t__,-1,1> tp_simplex =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> tp_1d_simplex =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>
        tp_3d_simplex =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__))));
      Eigen::Matrix<local_scalar_t__,-1,-1> tp_cfcov_54 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 4, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> tp_cfcov_33 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 3, DUMMY_VAR__);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> tp_cfcov_33_ar =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(K,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 3, DUMMY_VAR__));
      Eigen::Matrix<local_scalar_t__,-1,1> theta_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      local_scalar_t__ tp_real = DUMMY_VAR__;
      current_statement__ = 70;
      stan::model::assign(tp_real_1d_ar, p_real_1d_ar,
        "assigning variable tp_real_1d_ar");
      current_statement__ = 71;
      stan::model::assign(tp_real_3d_ar, p_real_3d_ar,
        "assigning variable tp_real_3d_ar");
      current_statement__ = 72;
      stan::model::assign(tp_1d_vec, p_1d_vec, "assigning variable tp_1d_vec");
      current_statement__ = 73;
      stan::model::assign(tp_3d_vec, p_3d_vec, "assigning variable tp_3d_vec");
      current_statement__ = 74;
      stan::model::assign(tp_simplex, p_simplex,
        "assigning variable tp_simplex");
      current_statement__ = 75;
      stan::model::assign(tp_1d_simplex, p_1d_simplex,
        "assigning variable tp_1d_simplex");
      current_statement__ = 76;
      stan::model::assign(tp_3d_simplex, p_3d_simplex,
        "assigning variable tp_3d_simplex");
      current_statement__ = 77;
      stan::model::assign(tp_cfcov_54, p_cfcov_54,
        "assigning variable tp_cfcov_54");
      current_statement__ = 78;
      stan::model::assign(tp_cfcov_33, p_cfcov_33,
        "assigning variable tp_cfcov_33");
      current_statement__ = 79;
      stan::model::assign(tp_cfcov_33_ar, p_cfcov_33_ar,
        "assigning variable tp_cfcov_33_ar");
      current_statement__ = 80;
      stan::model::assign(tp_mat, stan::math::fma(d_cfcov_54, p_mat, p_mat),
        "assigning variable tp_mat");
      current_statement__ = 81;
      stan::model::assign(tp_vec, stan::math::fma(d_vec, p_vec, p_vec),
        "assigning variable tp_vec");
      current_statement__ = 90;
      for (int i = 1; i <= 2; ++i) {
        current_statement__ = 88;
        for (int j = 1; j <= 3; ++j) {
          current_statement__ = 86;
          for (int m = 1; m <= 4; ++m) {
            current_statement__ = 84;
            for (int n = 1; n <= 5; ++n) {
              current_statement__ = 82;
              stan::model::assign(tp_ar_mat, 0.4,
                "assigning variable tp_ar_mat", stan::model::index_uni(m),
                stan::model::index_uni(n), stan::model::index_uni(i),
                stan::model::index_uni(j));
            }
          }
        }
      }
      current_statement__ = 92;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 91;
        stan::model::assign(tp_vec, (-(1.0) *
          stan::model::rvalue(p_vec, "p_vec", stan::model::index_uni(i))),
          "assigning variable tp_vec", stan::model::index_uni(i));
      }
      current_statement__ = 93;
      stan::model::assign(tp_row_vec,
        stan::math::transpose(
          stan::model::rvalue(tp_1d_vec, "tp_1d_vec",
            stan::model::index_uni(1))), "assigning variable tp_row_vec");
      current_statement__ = 94;
      stan::model::assign(tp_1d_row_vec, p_1d_row_vec,
        "assigning variable tp_1d_row_vec");
      current_statement__ = 95;
      stan::model::assign(tp_3d_row_vec, p_3d_row_vec,
        "assigning variable tp_3d_row_vec");
      current_statement__ = 96;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x, y, dat,
          dat_int, pstream__), "assigning variable theta_p");
      current_statement__ = 97;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x, y, dat,
          dat_int, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p");
      current_statement__ = 98;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x, y_p, dat,
          dat_int, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p");
      current_statement__ = 99;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x_p, y, dat,
          dat_int, pstream__), "assigning variable theta_p");
      current_statement__ = 100;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x_p, y, dat,
          dat_int, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p");
      current_statement__ = 101;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x_p, y_p, dat,
          dat_int, pstream__), "assigning variable theta_p");
      current_statement__ = 102;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x_p, y_p, dat,
          dat_int, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p");
      current_statement__ = 103;
      tp_real = (p_real * p_real);
      current_statement__ = 104;
      tp_real = (p_real / p_real);
      current_statement__ = 25;
      stan::math::check_greater_or_equal(function__, "tp_real_1d_ar",
        tp_real_1d_ar, 0);
      current_statement__ = 26;
      stan::math::check_greater_or_equal(function__, "tp_real_3d_ar",
        tp_real_3d_ar, 0);
      current_statement__ = 27;
      stan::math::check_less_or_equal(function__, "tp_vec", tp_vec, 0);
      current_statement__ = 34;
      stan::math::check_greater_or_equal(function__, "tp_ar_mat", tp_ar_mat,
        0);
      current_statement__ = 34;
      stan::math::check_less_or_equal(function__, "tp_ar_mat", tp_ar_mat, 1);
      current_statement__ = 35;
      stan::math::check_simplex(function__, "tp_simplex", tp_simplex);
      current_statement__ = 36;
      stan::math::check_simplex(function__, "tp_1d_simplex", tp_1d_simplex);
      current_statement__ = 37;
      stan::math::check_simplex(function__, "tp_3d_simplex", tp_3d_simplex);
      current_statement__ = 38;
      stan::math::check_cholesky_factor(function__, "tp_cfcov_54",
        tp_cfcov_54);
      current_statement__ = 39;
      stan::math::check_cholesky_factor(function__, "tp_cfcov_33",
        tp_cfcov_33);
      current_statement__ = 40;
      stan::math::check_cholesky_factor(function__, "tp_cfcov_33_ar",
        tp_cfcov_33_ar);
      {
        Eigen::Matrix<local_scalar_t__,-1,1> tmp =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(0, DUMMY_VAR__);
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> tmp2 =
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(0,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(0, DUMMY_VAR__));
        local_scalar_t__ r1 = DUMMY_VAR__;
        current_statement__ = 156;
        r1 = foo_bar1(p_real, pstream__);
        local_scalar_t__ r2 = DUMMY_VAR__;
        current_statement__ = 157;
        r2 = foo_bar1(J, pstream__);
        current_statement__ = 158;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(p_real, 0, 1));
        current_statement__ = 159;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(offset_multiplier,
                         0, 1));
        current_statement__ = 160;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         no_offset_multiplier, 0, 1));
        current_statement__ = 161;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         offset_no_multiplier, 0, 1));
        current_statement__ = 162;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::to_vector(p_real_1d_ar), 0, 1));
        current_statement__ = 175;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 163;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::math::to_vector(
                             stan::model::rvalue(p_1d_vec, "p_1d_vec",
                               stan::model::index_uni(n))), 0, 1));
          current_statement__ = 164;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::math::to_vector(
                             stan::model::rvalue(p_1d_row_vec,
                               "p_1d_row_vec", stan::model::index_uni(n))),
                           0, 1));
          current_statement__ = 165;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::math::to_vector(
                             stan::model::rvalue(p_1d_simplex,
                               "p_1d_simplex", stan::model::index_uni(n))),
                           0, 1));
          current_statement__ = 173;
          for (int m = 1; m <= M; ++m) {
            current_statement__ = 171;
            for (int k = 1; k <= K; ++k) {
              current_statement__ = 166;
              lp_accum__.add(stan::math::normal_lpdf<propto__>(
                               stan::math::to_vector(
                                 stan::model::rvalue(p_3d_vec, "p_3d_vec",
                                   stan::model::index_uni(n),
                                   stan::model::index_uni(m),
                                   stan::model::index_uni(k))),
                               stan::model::rvalue(d_3d_vec, "d_3d_vec",
                                 stan::model::index_uni(n),
                                 stan::model::index_uni(m),
                                 stan::model::index_uni(k)), 1));
              current_statement__ = 167;
              lp_accum__.add(stan::math::normal_lpdf<propto__>(
                               stan::math::to_vector(
                                 stan::model::rvalue(p_3d_row_vec,
                                   "p_3d_row_vec", stan::model::index_uni(n),
                                   stan::model::index_uni(m),
                                   stan::model::index_uni(k))),
                               stan::model::rvalue(d_3d_row_vec,
                                 "d_3d_row_vec", stan::model::index_uni(n),
                                 stan::model::index_uni(m),
                                 stan::model::index_uni(k)), 1));
              current_statement__ = 168;
              lp_accum__.add(stan::math::normal_lpdf<propto__>(
                               stan::math::to_vector(
                                 stan::model::rvalue(p_3d_simplex,
                                   "p_3d_simplex", stan::model::index_uni(n),
                                   stan::model::index_uni(m),
                                   stan::model::index_uni(k))),
                               stan::model::rvalue(d_3d_simplex,
                                 "d_3d_simplex", stan::model::index_uni(n),
                                 stan::model::index_uni(m),
                                 stan::model::index_uni(k)), 1));
              current_statement__ = 169;
              lp_accum__.add(stan::math::normal_lpdf<propto__>(
                               stan::model::rvalue(p_real_3d_ar,
                                 "p_real_3d_ar", stan::model::index_uni(n),
                                 stan::model::index_uni(m),
                                 stan::model::index_uni(k)),
                               stan::model::rvalue(p_real_3d_ar,
                                 "p_real_3d_ar", stan::model::index_uni(n),
                                 stan::model::index_uni(m),
                                 stan::model::index_uni(k)), 1));
            }
          }
        }
        current_statement__ = 180;
        for (int i = 1; i <= 4; ++i) {
          current_statement__ = 178;
          for (int j = 1; j <= 5; ++j) {
            current_statement__ = 176;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(
                             stan::math::to_vector(
                               stan::model::rvalue(p_ar_mat, "p_ar_mat",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(j))), 0, 1));
          }
        }
        current_statement__ = 183;
        for (int k = 1; k <= K; ++k) {
          current_statement__ = 181;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::math::to_vector(
                             stan::model::rvalue(p_cfcov_33_ar,
                               "p_cfcov_33_ar", stan::model::index_uni(k))),
                           0, 1));
        }
        current_statement__ = 184;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::to_vector(p_vec), d_vec, 1));
        current_statement__ = 185;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::to_vector(p_row_vec), 0, 1));
        current_statement__ = 186;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::to_vector(p_simplex), 0, 1));
        current_statement__ = 187;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::to_vector(p_cfcov_54), 0, 1));
        current_statement__ = 188;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::to_vector(p_cfcov_33), 0, 1));
        current_statement__ = 189;
        lp_accum__.add(stan::math::map_rect<2, binomialf_functor__>(tmp,
                         tmp2, x_r, x_i, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "mother_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ p_real = DUMMY_VAR__;
      current_statement__ = 1;
      p_real = in__.template read<local_scalar_t__>();
      local_scalar_t__ p_upper = DUMMY_VAR__;
      current_statement__ = 2;
      p_upper = in__.template read_constrain_lb<local_scalar_t__,
                  jacobian__>(p_real, lp__);
      local_scalar_t__ p_lower = DUMMY_VAR__;
      current_statement__ = 3;
      p_lower = in__.template read_constrain_ub<local_scalar_t__,
                  jacobian__>(p_upper, lp__);
      std::vector<local_scalar_t__> offset_multiplier =
        std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      current_statement__ = 4;
      offset_multiplier = in__.template read_constrain_offset_multiplier<
                            std::vector<local_scalar_t__>, jacobian__>(1, 2,
                            lp__, 5);
      std::vector<local_scalar_t__> no_offset_multiplier =
        std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      current_statement__ = 5;
      no_offset_multiplier = in__.template read_constrain_offset_multiplier<
                               std::vector<local_scalar_t__>, jacobian__>(0,
                               2, lp__, 5);
      std::vector<local_scalar_t__> offset_no_multiplier =
        std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      current_statement__ = 6;
      offset_no_multiplier = in__.template read_constrain_offset_multiplier<
                               std::vector<local_scalar_t__>, jacobian__>(3,
                               1, lp__, 5);
      std::vector<local_scalar_t__> p_real_1d_ar =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 7;
      p_real_1d_ar = in__.template read_constrain_lb<
                       std::vector<local_scalar_t__>, jacobian__>(0, lp__, N);
      std::vector<std::vector<std::vector<local_scalar_t__>>> p_real_3d_ar =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(N,
          std::vector<std::vector<local_scalar_t__>>(M,
            std::vector<local_scalar_t__>(K, DUMMY_VAR__)));
      current_statement__ = 8;
      p_real_3d_ar = in__.template read_constrain_lb<
                       std::vector<
                         std::vector<std::vector<local_scalar_t__>>>,
                       jacobian__>(0, lp__, N, M, K);
      Eigen::Matrix<local_scalar_t__,-1,1> p_vec =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 9;
      p_vec = in__.template read_constrain_lb<
                Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__, N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> p_1d_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 10;
      p_1d_vec = in__.template read<
                   std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N, N);
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>
        p_3d_vec =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__))));
      current_statement__ = 11;
      p_3d_vec = in__.template read<
                   std::vector<
                     std::vector<
                       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>>(N,
                   M, K, N);
      Eigen::Matrix<local_scalar_t__,1,-1> p_row_vec =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 12;
      p_row_vec = in__.template read<Eigen::Matrix<local_scalar_t__,1,-1>>(N);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> p_1d_row_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 13;
      p_1d_row_vec = in__.template read<
                       std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
                       N);
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>
        p_3d_row_vec =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(K,
              Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__))));
      current_statement__ = 14;
      p_3d_row_vec = in__.template read<
                       std::vector<
                         std::vector<
                           std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>>(N,
                       M, K, N);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 4, DUMMY_VAR__);
      current_statement__ = 15;
      p_mat = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 4);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>
        p_ar_mat =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(4,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 3,
              DUMMY_VAR__)));
      current_statement__ = 16;
      p_ar_mat = in__.template read_constrain_lub<
                   std::vector<
                     std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>,
                   jacobian__>(0, 1, lp__, 4, 5, 2, 3);
      Eigen::Matrix<local_scalar_t__,-1,1> p_simplex =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 17;
      p_simplex = in__.template read_constrain_simplex<
                    Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lp__,
                    N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> p_1d_simplex =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 18;
      p_1d_simplex = in__.template read_constrain_simplex<
                       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>,
                       jacobian__>(lp__, N, N);
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>
        p_3d_simplex =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__))));
      current_statement__ = 19;
      p_3d_simplex = in__.template read_constrain_simplex<
                       std::vector<
                         std::vector<
                           std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>,
                       jacobian__>(lp__, N, M, K, N);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_cfcov_54 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 4, DUMMY_VAR__);
      current_statement__ = 20;
      p_cfcov_54 = in__.template read_constrain_cholesky_factor_cov<
                     Eigen::Matrix<local_scalar_t__,-1,-1>, jacobian__>(lp__,
                     5, 4);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_cfcov_33 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 3, DUMMY_VAR__);
      current_statement__ = 21;
      p_cfcov_33 = in__.template read_constrain_cholesky_factor_cov<
                     Eigen::Matrix<local_scalar_t__,-1,-1>, jacobian__>(lp__,
                     3, 3);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> p_cfcov_33_ar =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(K,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 3, DUMMY_VAR__));
      current_statement__ = 22;
      p_cfcov_33_ar = in__.template read_constrain_cholesky_factor_cov<
                        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
                        jacobian__>(lp__, K, 3, 3);
      Eigen::Matrix<local_scalar_t__,-1,1> x_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 23;
      x_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      Eigen::Matrix<local_scalar_t__,-1,1> y_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 24;
      y_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      std::vector<local_scalar_t__> tp_real_1d_ar =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      std::vector<std::vector<std::vector<local_scalar_t__>>> tp_real_3d_ar =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(N,
          std::vector<std::vector<local_scalar_t__>>(M,
            std::vector<local_scalar_t__>(K, DUMMY_VAR__)));
      Eigen::Matrix<local_scalar_t__,-1,1> tp_vec =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> tp_1d_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>
        tp_3d_vec =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__))));
      Eigen::Matrix<local_scalar_t__,1,-1> tp_row_vec =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> tp_1d_row_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>
        tp_3d_row_vec =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(K,
              Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__))));
      Eigen::Matrix<local_scalar_t__,-1,-1> tp_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 4, DUMMY_VAR__);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>
        tp_ar_mat =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(4,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 3,
              DUMMY_VAR__)));
      Eigen::Matrix<local_scalar_t__,-1,1> tp_simplex =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> tp_1d_simplex =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>
        tp_3d_simplex =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__))));
      Eigen::Matrix<local_scalar_t__,-1,-1> tp_cfcov_54 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 4, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> tp_cfcov_33 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 3, DUMMY_VAR__);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> tp_cfcov_33_ar =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(K,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 3, DUMMY_VAR__));
      Eigen::Matrix<local_scalar_t__,-1,1> theta_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      local_scalar_t__ tp_real = DUMMY_VAR__;
      current_statement__ = 70;
      stan::model::assign(tp_real_1d_ar, p_real_1d_ar,
        "assigning variable tp_real_1d_ar");
      current_statement__ = 71;
      stan::model::assign(tp_real_3d_ar, p_real_3d_ar,
        "assigning variable tp_real_3d_ar");
      current_statement__ = 72;
      stan::model::assign(tp_1d_vec, p_1d_vec, "assigning variable tp_1d_vec");
      current_statement__ = 73;
      stan::model::assign(tp_3d_vec, p_3d_vec, "assigning variable tp_3d_vec");
      current_statement__ = 74;
      stan::model::assign(tp_simplex, p_simplex,
        "assigning variable tp_simplex");
      current_statement__ = 75;
      stan::model::assign(tp_1d_simplex, p_1d_simplex,
        "assigning variable tp_1d_simplex");
      current_statement__ = 76;
      stan::model::assign(tp_3d_simplex, p_3d_simplex,
        "assigning variable tp_3d_simplex");
      current_statement__ = 77;
      stan::model::assign(tp_cfcov_54, p_cfcov_54,
        "assigning variable tp_cfcov_54");
      current_statement__ = 78;
      stan::model::assign(tp_cfcov_33, p_cfcov_33,
        "assigning variable tp_cfcov_33");
      current_statement__ = 79;
      stan::model::assign(tp_cfcov_33_ar, p_cfcov_33_ar,
        "assigning variable tp_cfcov_33_ar");
      current_statement__ = 80;
      stan::model::assign(tp_mat, stan::math::fma(d_cfcov_54, p_mat, p_mat),
        "assigning variable tp_mat");
      current_statement__ = 81;
      stan::model::assign(tp_vec, stan::math::fma(d_vec, p_vec, p_vec),
        "assigning variable tp_vec");
      current_statement__ = 90;
      for (int i = 1; i <= 2; ++i) {
        current_statement__ = 88;
        for (int j = 1; j <= 3; ++j) {
          current_statement__ = 86;
          for (int m = 1; m <= 4; ++m) {
            current_statement__ = 84;
            for (int n = 1; n <= 5; ++n) {
              current_statement__ = 82;
              stan::model::assign(tp_ar_mat, 0.4,
                "assigning variable tp_ar_mat", stan::model::index_uni(m),
                stan::model::index_uni(n), stan::model::index_uni(i),
                stan::model::index_uni(j));
            }
          }
        }
      }
      current_statement__ = 92;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 91;
        stan::model::assign(tp_vec, (-(1.0) *
          stan::model::rvalue(p_vec, "p_vec", stan::model::index_uni(i))),
          "assigning variable tp_vec", stan::model::index_uni(i));
      }
      current_statement__ = 93;
      stan::model::assign(tp_row_vec,
        stan::math::transpose(
          stan::model::rvalue(tp_1d_vec, "tp_1d_vec",
            stan::model::index_uni(1))), "assigning variable tp_row_vec");
      current_statement__ = 94;
      stan::model::assign(tp_1d_row_vec, p_1d_row_vec,
        "assigning variable tp_1d_row_vec");
      current_statement__ = 95;
      stan::model::assign(tp_3d_row_vec, p_3d_row_vec,
        "assigning variable tp_3d_row_vec");
      current_statement__ = 96;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x, y, dat,
          dat_int, pstream__), "assigning variable theta_p");
      current_statement__ = 97;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x, y, dat,
          dat_int, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p");
      current_statement__ = 98;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x, y_p, dat,
          dat_int, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p");
      current_statement__ = 99;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x_p, y, dat,
          dat_int, pstream__), "assigning variable theta_p");
      current_statement__ = 100;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x_p, y, dat,
          dat_int, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p");
      current_statement__ = 101;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x_p, y_p, dat,
          dat_int, pstream__), "assigning variable theta_p");
      current_statement__ = 102;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x_p, y_p, dat,
          dat_int, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p");
      current_statement__ = 103;
      tp_real = (p_real * p_real);
      current_statement__ = 104;
      tp_real = (p_real / p_real);
      current_statement__ = 25;
      stan::math::check_greater_or_equal(function__, "tp_real_1d_ar",
        tp_real_1d_ar, 0);
      current_statement__ = 26;
      stan::math::check_greater_or_equal(function__, "tp_real_3d_ar",
        tp_real_3d_ar, 0);
      current_statement__ = 27;
      stan::math::check_less_or_equal(function__, "tp_vec", tp_vec, 0);
      current_statement__ = 34;
      stan::math::check_greater_or_equal(function__, "tp_ar_mat", tp_ar_mat,
        0);
      current_statement__ = 34;
      stan::math::check_less_or_equal(function__, "tp_ar_mat", tp_ar_mat, 1);
      current_statement__ = 35;
      stan::math::check_simplex(function__, "tp_simplex", tp_simplex);
      current_statement__ = 36;
      stan::math::check_simplex(function__, "tp_1d_simplex", tp_1d_simplex);
      current_statement__ = 37;
      stan::math::check_simplex(function__, "tp_3d_simplex", tp_3d_simplex);
      current_statement__ = 38;
      stan::math::check_cholesky_factor(function__, "tp_cfcov_54",
        tp_cfcov_54);
      current_statement__ = 39;
      stan::math::check_cholesky_factor(function__, "tp_cfcov_33",
        tp_cfcov_33);
      current_statement__ = 40;
      stan::math::check_cholesky_factor(function__, "tp_cfcov_33_ar",
        tp_cfcov_33_ar);
      {
        Eigen::Matrix<local_scalar_t__,-1,1> tmp =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(0, DUMMY_VAR__);
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> tmp2 =
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(0,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(0, DUMMY_VAR__));
        local_scalar_t__ r1 = DUMMY_VAR__;
        current_statement__ = 156;
        r1 = foo_bar1(p_real, pstream__);
        local_scalar_t__ r2 = DUMMY_VAR__;
        current_statement__ = 157;
        r2 = foo_bar1(J, pstream__);
        current_statement__ = 158;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(p_real, 0, 1));
        current_statement__ = 159;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(offset_multiplier,
                         0, 1));
        current_statement__ = 160;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         no_offset_multiplier, 0, 1));
        current_statement__ = 161;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         offset_no_multiplier, 0, 1));
        current_statement__ = 162;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::to_vector(p_real_1d_ar), 0, 1));
        current_statement__ = 175;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 163;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::math::to_vector(
                             stan::model::rvalue(p_1d_vec, "p_1d_vec",
                               stan::model::index_uni(n))), 0, 1));
          current_statement__ = 164;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::math::to_vector(
                             stan::model::rvalue(p_1d_row_vec,
                               "p_1d_row_vec", stan::model::index_uni(n))),
                           0, 1));
          current_statement__ = 165;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::math::to_vector(
                             stan::model::rvalue(p_1d_simplex,
                               "p_1d_simplex", stan::model::index_uni(n))),
                           0, 1));
          current_statement__ = 173;
          for (int m = 1; m <= M; ++m) {
            current_statement__ = 171;
            for (int k = 1; k <= K; ++k) {
              current_statement__ = 166;
              lp_accum__.add(stan::math::normal_lpdf<propto__>(
                               stan::math::to_vector(
                                 stan::model::rvalue(p_3d_vec, "p_3d_vec",
                                   stan::model::index_uni(n),
                                   stan::model::index_uni(m),
                                   stan::model::index_uni(k))),
                               stan::model::rvalue(d_3d_vec, "d_3d_vec",
                                 stan::model::index_uni(n),
                                 stan::model::index_uni(m),
                                 stan::model::index_uni(k)), 1));
              current_statement__ = 167;
              lp_accum__.add(stan::math::normal_lpdf<propto__>(
                               stan::math::to_vector(
                                 stan::model::rvalue(p_3d_row_vec,
                                   "p_3d_row_vec", stan::model::index_uni(n),
                                   stan::model::index_uni(m),
                                   stan::model::index_uni(k))),
                               stan::model::rvalue(d_3d_row_vec,
                                 "d_3d_row_vec", stan::model::index_uni(n),
                                 stan::model::index_uni(m),
                                 stan::model::index_uni(k)), 1));
              current_statement__ = 168;
              lp_accum__.add(stan::math::normal_lpdf<propto__>(
                               stan::math::to_vector(
                                 stan::model::rvalue(p_3d_simplex,
                                   "p_3d_simplex", stan::model::index_uni(n),
                                   stan::model::index_uni(m),
                                   stan::model::index_uni(k))),
                               stan::model::rvalue(d_3d_simplex,
                                 "d_3d_simplex", stan::model::index_uni(n),
                                 stan::model::index_uni(m),
                                 stan::model::index_uni(k)), 1));
              current_statement__ = 169;
              lp_accum__.add(stan::math::normal_lpdf<propto__>(
                               stan::model::rvalue(p_real_3d_ar,
                                 "p_real_3d_ar", stan::model::index_uni(n),
                                 stan::model::index_uni(m),
                                 stan::model::index_uni(k)),
                               stan::model::rvalue(p_real_3d_ar,
                                 "p_real_3d_ar", stan::model::index_uni(n),
                                 stan::model::index_uni(m),
                                 stan::model::index_uni(k)), 1));
            }
          }
        }
        current_statement__ = 180;
        for (int i = 1; i <= 4; ++i) {
          current_statement__ = 178;
          for (int j = 1; j <= 5; ++j) {
            current_statement__ = 176;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(
                             stan::math::to_vector(
                               stan::model::rvalue(p_ar_mat, "p_ar_mat",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(j))), 0, 1));
          }
        }
        current_statement__ = 183;
        for (int k = 1; k <= K; ++k) {
          current_statement__ = 181;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::math::to_vector(
                             stan::model::rvalue(p_cfcov_33_ar,
                               "p_cfcov_33_ar", stan::model::index_uni(k))),
                           0, 1));
        }
        current_statement__ = 184;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::to_vector(p_vec), d_vec, 1));
        current_statement__ = 185;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::to_vector(p_row_vec), 0, 1));
        current_statement__ = 186;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::to_vector(p_simplex), 0, 1));
        current_statement__ = 187;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::to_vector(p_cfcov_54), 0, 1));
        current_statement__ = 188;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::to_vector(p_cfcov_33), 0, 1));
        current_statement__ = 189;
        lp_accum__.add(stan::math::map_rect<1, binomialf_functor__>(tmp,
                         tmp2, x_r, x_i, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "mother_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double p_real = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      p_real = in__.template read<local_scalar_t__>();
      double p_upper = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      p_upper = in__.template read_constrain_lb<local_scalar_t__,
                  jacobian__>(p_real, lp__);
      double p_lower = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      p_lower = in__.template read_constrain_ub<local_scalar_t__,
                  jacobian__>(p_upper, lp__);
      std::vector<double> offset_multiplier =
        std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 4;
      offset_multiplier = in__.template read_constrain_offset_multiplier<
                            std::vector<local_scalar_t__>, jacobian__>(1, 2,
                            lp__, 5);
      std::vector<double> no_offset_multiplier =
        std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      no_offset_multiplier = in__.template read_constrain_offset_multiplier<
                               std::vector<local_scalar_t__>, jacobian__>(0,
                               2, lp__, 5);
      std::vector<double> offset_no_multiplier =
        std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 6;
      offset_no_multiplier = in__.template read_constrain_offset_multiplier<
                               std::vector<local_scalar_t__>, jacobian__>(3,
                               1, lp__, 5);
      std::vector<double> p_real_1d_ar =
        std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 7;
      p_real_1d_ar = in__.template read_constrain_lb<
                       std::vector<local_scalar_t__>, jacobian__>(0, lp__, N);
      std::vector<std::vector<std::vector<double>>> p_real_3d_ar =
        std::vector<std::vector<std::vector<double>>>(N,
          std::vector<std::vector<double>>(M,
            std::vector<double>(K, std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 8;
      p_real_3d_ar = in__.template read_constrain_lb<
                       std::vector<
                         std::vector<std::vector<local_scalar_t__>>>,
                       jacobian__>(0, lp__, N, M, K);
      Eigen::Matrix<double,-1,1> p_vec =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 9;
      p_vec = in__.template read_constrain_lb<
                Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__, N);
      std::vector<Eigen::Matrix<double,-1,1>> p_1d_vec =
        std::vector<Eigen::Matrix<double,-1,1>>(N,
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 10;
      p_1d_vec = in__.template read<
                   std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N, N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>
        p_3d_vec =
        std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(M,
            std::vector<Eigen::Matrix<double,-1,1>>(K,
              Eigen::Matrix<double,-1,1>::Constant(N,
                std::numeric_limits<double>::quiet_NaN()))));
      current_statement__ = 11;
      p_3d_vec = in__.template read<
                   std::vector<
                     std::vector<
                       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>>(N,
                   M, K, N);
      Eigen::Matrix<double,1,-1> p_row_vec =
        Eigen::Matrix<double,1,-1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 12;
      p_row_vec = in__.template read<Eigen::Matrix<local_scalar_t__,1,-1>>(N);
      std::vector<Eigen::Matrix<double,1,-1>> p_1d_row_vec =
        std::vector<Eigen::Matrix<double,1,-1>>(N,
          Eigen::Matrix<double,1,-1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 13;
      p_1d_row_vec = in__.template read<
                       std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
                       N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double,1,-1>>>>
        p_3d_row_vec =
        std::vector<std::vector<std::vector<Eigen::Matrix<double,1,-1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<double,1,-1>>>(M,
            std::vector<Eigen::Matrix<double,1,-1>>(K,
              Eigen::Matrix<double,1,-1>::Constant(N,
                std::numeric_limits<double>::quiet_NaN()))));
      current_statement__ = 14;
      p_3d_row_vec = in__.template read<
                       std::vector<
                         std::vector<
                           std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>>(N,
                       M, K, N);
      Eigen::Matrix<double,-1,-1> p_mat =
        Eigen::Matrix<double,-1,-1>::Constant(5, 4,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 15;
      p_mat = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 4);
      std::vector<std::vector<Eigen::Matrix<double,-1,-1>>> p_ar_mat =
        std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>(4,
          std::vector<Eigen::Matrix<double,-1,-1>>(5,
            Eigen::Matrix<double,-1,-1>::Constant(2, 3,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 16;
      p_ar_mat = in__.template read_constrain_lub<
                   std::vector<
                     std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>,
                   jacobian__>(0, 1, lp__, 4, 5, 2, 3);
      Eigen::Matrix<double,-1,1> p_simplex =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 17;
      p_simplex = in__.template read_constrain_simplex<
                    Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lp__,
                    N);
      std::vector<Eigen::Matrix<double,-1,1>> p_1d_simplex =
        std::vector<Eigen::Matrix<double,-1,1>>(N,
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 18;
      p_1d_simplex = in__.template read_constrain_simplex<
                       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>,
                       jacobian__>(lp__, N, N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>
        p_3d_simplex =
        std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(M,
            std::vector<Eigen::Matrix<double,-1,1>>(K,
              Eigen::Matrix<double,-1,1>::Constant(N,
                std::numeric_limits<double>::quiet_NaN()))));
      current_statement__ = 19;
      p_3d_simplex = in__.template read_constrain_simplex<
                       std::vector<
                         std::vector<
                           std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>,
                       jacobian__>(lp__, N, M, K, N);
      Eigen::Matrix<double,-1,-1> p_cfcov_54 =
        Eigen::Matrix<double,-1,-1>::Constant(5, 4,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 20;
      p_cfcov_54 = in__.template read_constrain_cholesky_factor_cov<
                     Eigen::Matrix<local_scalar_t__,-1,-1>, jacobian__>(lp__,
                     5, 4);
      Eigen::Matrix<double,-1,-1> p_cfcov_33 =
        Eigen::Matrix<double,-1,-1>::Constant(3, 3,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 21;
      p_cfcov_33 = in__.template read_constrain_cholesky_factor_cov<
                     Eigen::Matrix<local_scalar_t__,-1,-1>, jacobian__>(lp__,
                     3, 3);
      std::vector<Eigen::Matrix<double,-1,-1>> p_cfcov_33_ar =
        std::vector<Eigen::Matrix<double,-1,-1>>(K,
          Eigen::Matrix<double,-1,-1>::Constant(3, 3,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 22;
      p_cfcov_33_ar = in__.template read_constrain_cholesky_factor_cov<
                        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
                        jacobian__>(lp__, K, 3, 3);
      Eigen::Matrix<double,-1,1> x_p =
        Eigen::Matrix<double,-1,1>::Constant(2,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 23;
      x_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      Eigen::Matrix<double,-1,1> y_p =
        Eigen::Matrix<double,-1,1>::Constant(2,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 24;
      y_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      std::vector<double> tp_real_1d_ar =
        std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      std::vector<std::vector<std::vector<double>>> tp_real_3d_ar =
        std::vector<std::vector<std::vector<double>>>(N,
          std::vector<std::vector<double>>(M,
            std::vector<double>(K, std::numeric_limits<double>::quiet_NaN())));
      Eigen::Matrix<double,-1,1> tp_vec =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,-1,1>> tp_1d_vec =
        std::vector<Eigen::Matrix<double,-1,1>>(N,
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>
        tp_3d_vec =
        std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(M,
            std::vector<Eigen::Matrix<double,-1,1>>(K,
              Eigen::Matrix<double,-1,1>::Constant(N,
                std::numeric_limits<double>::quiet_NaN()))));
      Eigen::Matrix<double,1,-1> tp_row_vec =
        Eigen::Matrix<double,1,-1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,1,-1>> tp_1d_row_vec =
        std::vector<Eigen::Matrix<double,1,-1>>(N,
          Eigen::Matrix<double,1,-1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<std::vector<Eigen::Matrix<double,1,-1>>>>
        tp_3d_row_vec =
        std::vector<std::vector<std::vector<Eigen::Matrix<double,1,-1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<double,1,-1>>>(M,
            std::vector<Eigen::Matrix<double,1,-1>>(K,
              Eigen::Matrix<double,1,-1>::Constant(N,
                std::numeric_limits<double>::quiet_NaN()))));
      Eigen::Matrix<double,-1,-1> tp_mat =
        Eigen::Matrix<double,-1,-1>::Constant(5, 4,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<std::vector<Eigen::Matrix<double,-1,-1>>> tp_ar_mat =
        std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>(4,
          std::vector<Eigen::Matrix<double,-1,-1>>(5,
            Eigen::Matrix<double,-1,-1>::Constant(2, 3,
              std::numeric_limits<double>::quiet_NaN())));
      Eigen::Matrix<double,-1,1> tp_simplex =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,-1,1>> tp_1d_simplex =
        std::vector<Eigen::Matrix<double,-1,1>>(N,
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>
        tp_3d_simplex =
        std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(M,
            std::vector<Eigen::Matrix<double,-1,1>>(K,
              Eigen::Matrix<double,-1,1>::Constant(N,
                std::numeric_limits<double>::quiet_NaN()))));
      Eigen::Matrix<double,-1,-1> tp_cfcov_54 =
        Eigen::Matrix<double,-1,-1>::Constant(5, 4,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> tp_cfcov_33 =
        Eigen::Matrix<double,-1,-1>::Constant(3, 3,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,-1,-1>> tp_cfcov_33_ar =
        std::vector<Eigen::Matrix<double,-1,-1>>(K,
          Eigen::Matrix<double,-1,-1>::Constant(3, 3,
            std::numeric_limits<double>::quiet_NaN()));
      Eigen::Matrix<double,-1,1> theta_p =
        Eigen::Matrix<double,-1,1>::Constant(2,
          std::numeric_limits<double>::quiet_NaN());
      double tp_real = std::numeric_limits<double>::quiet_NaN();
      out__.write(p_real);
      out__.write(p_upper);
      out__.write(p_lower);
      out__.write(offset_multiplier);
      out__.write(no_offset_multiplier);
      out__.write(offset_no_multiplier);
      out__.write(p_real_1d_ar);
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            out__.write(p_real_3d_ar[(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
              1)]);
          }
        }
      }
      out__.write(p_vec);
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(p_1d_vec[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              out__.write(p_3d_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ -
                1)][(sym1__ - 1)]);
            }
          }
        }
      }
      out__.write(p_row_vec);
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(p_1d_row_vec[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              out__.write(p_3d_row_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ -
                1)][(sym1__ - 1)]);
            }
          }
        }
      }
      out__.write(p_mat);
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
              out__.write(stan::model::rvalue(p_ar_mat, "p_ar_mat",
                            stan::model::index_uni(sym4__),
                            stan::model::index_uni(sym3__),
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(sym1__)));
            }
          }
        }
      }
      out__.write(p_simplex);
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(p_1d_simplex[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              out__.write(p_3d_simplex[(sym4__ - 1)][(sym3__ - 1)][(sym2__ -
                1)][(sym1__ - 1)]);
            }
          }
        }
      }
      out__.write(p_cfcov_54);
      out__.write(p_cfcov_33);
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            out__.write(stan::model::rvalue(p_cfcov_33_ar, "p_cfcov_33_ar",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      out__.write(x_p);
      out__.write(y_p);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 70;
      stan::model::assign(tp_real_1d_ar, p_real_1d_ar,
        "assigning variable tp_real_1d_ar");
      current_statement__ = 71;
      stan::model::assign(tp_real_3d_ar, p_real_3d_ar,
        "assigning variable tp_real_3d_ar");
      current_statement__ = 72;
      stan::model::assign(tp_1d_vec, p_1d_vec, "assigning variable tp_1d_vec");
      current_statement__ = 73;
      stan::model::assign(tp_3d_vec, p_3d_vec, "assigning variable tp_3d_vec");
      current_statement__ = 74;
      stan::model::assign(tp_simplex, p_simplex,
        "assigning variable tp_simplex");
      current_statement__ = 75;
      stan::model::assign(tp_1d_simplex, p_1d_simplex,
        "assigning variable tp_1d_simplex");
      current_statement__ = 76;
      stan::model::assign(tp_3d_simplex, p_3d_simplex,
        "assigning variable tp_3d_simplex");
      current_statement__ = 77;
      stan::model::assign(tp_cfcov_54, p_cfcov_54,
        "assigning variable tp_cfcov_54");
      current_statement__ = 78;
      stan::model::assign(tp_cfcov_33, p_cfcov_33,
        "assigning variable tp_cfcov_33");
      current_statement__ = 79;
      stan::model::assign(tp_cfcov_33_ar, p_cfcov_33_ar,
        "assigning variable tp_cfcov_33_ar");
      current_statement__ = 80;
      stan::model::assign(tp_mat, stan::math::fma(d_cfcov_54, p_mat, p_mat),
        "assigning variable tp_mat");
      current_statement__ = 81;
      stan::model::assign(tp_vec, stan::math::fma(d_vec, p_vec, p_vec),
        "assigning variable tp_vec");
      current_statement__ = 90;
      for (int i = 1; i <= 2; ++i) {
        current_statement__ = 88;
        for (int j = 1; j <= 3; ++j) {
          current_statement__ = 86;
          for (int m = 1; m <= 4; ++m) {
            current_statement__ = 84;
            for (int n = 1; n <= 5; ++n) {
              current_statement__ = 82;
              stan::model::assign(tp_ar_mat, 0.4,
                "assigning variable tp_ar_mat", stan::model::index_uni(m),
                stan::model::index_uni(n), stan::model::index_uni(i),
                stan::model::index_uni(j));
            }
          }
        }
      }
      current_statement__ = 92;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 91;
        stan::model::assign(tp_vec, (-(1.0) *
          stan::model::rvalue(p_vec, "p_vec", stan::model::index_uni(i))),
          "assigning variable tp_vec", stan::model::index_uni(i));
      }
      current_statement__ = 93;
      stan::model::assign(tp_row_vec,
        stan::math::transpose(
          stan::model::rvalue(tp_1d_vec, "tp_1d_vec",
            stan::model::index_uni(1))), "assigning variable tp_row_vec");
      current_statement__ = 94;
      stan::model::assign(tp_1d_row_vec, p_1d_row_vec,
        "assigning variable tp_1d_row_vec");
      current_statement__ = 95;
      stan::model::assign(tp_3d_row_vec, p_3d_row_vec,
        "assigning variable tp_3d_row_vec");
      current_statement__ = 96;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x, y, dat,
          dat_int, pstream__), "assigning variable theta_p");
      current_statement__ = 97;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x, y, dat,
          dat_int, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p");
      current_statement__ = 98;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x, y_p, dat,
          dat_int, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p");
      current_statement__ = 99;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x_p, y, dat,
          dat_int, pstream__), "assigning variable theta_p");
      current_statement__ = 100;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x_p, y, dat,
          dat_int, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p");
      current_statement__ = 101;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x_p, y_p, dat,
          dat_int, pstream__), "assigning variable theta_p");
      current_statement__ = 102;
      stan::model::assign(theta_p,
        stan::math::algebra_solver(algebra_system_functor__(), x_p, y_p, dat,
          dat_int, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p");
      current_statement__ = 103;
      tp_real = (p_real * p_real);
      current_statement__ = 104;
      tp_real = (p_real / p_real);
      current_statement__ = 25;
      stan::math::check_greater_or_equal(function__, "tp_real_1d_ar",
        tp_real_1d_ar, 0);
      current_statement__ = 26;
      stan::math::check_greater_or_equal(function__, "tp_real_3d_ar",
        tp_real_3d_ar, 0);
      current_statement__ = 27;
      stan::math::check_less_or_equal(function__, "tp_vec", tp_vec, 0);
      current_statement__ = 34;
      stan::math::check_greater_or_equal(function__, "tp_ar_mat", tp_ar_mat,
        0);
      current_statement__ = 34;
      stan::math::check_less_or_equal(function__, "tp_ar_mat", tp_ar_mat, 1);
      current_statement__ = 35;
      stan::math::check_simplex(function__, "tp_simplex", tp_simplex);
      current_statement__ = 36;
      stan::math::check_simplex(function__, "tp_1d_simplex", tp_1d_simplex);
      current_statement__ = 37;
      stan::math::check_simplex(function__, "tp_3d_simplex", tp_3d_simplex);
      current_statement__ = 38;
      stan::math::check_cholesky_factor(function__, "tp_cfcov_54",
        tp_cfcov_54);
      current_statement__ = 39;
      stan::math::check_cholesky_factor(function__, "tp_cfcov_33",
        tp_cfcov_33);
      current_statement__ = 40;
      stan::math::check_cholesky_factor(function__, "tp_cfcov_33_ar",
        tp_cfcov_33_ar);
      if (emit_transformed_parameters__) {
        out__.write(tp_real_1d_ar);
        current_statement__ = 26;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              out__.write(tp_real_3d_ar[(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
                1)]);
            }
          }
        }
        out__.write(tp_vec);
        current_statement__ = 28;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            out__.write(tp_1d_vec[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        current_statement__ = 29;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                out__.write(tp_3d_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ -
                  1)][(sym1__ - 1)]);
              }
            }
          }
        }
        out__.write(tp_row_vec);
        current_statement__ = 31;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            out__.write(tp_1d_row_vec[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        current_statement__ = 32;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                out__.write(tp_3d_row_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__
                  - 1)][(sym1__ - 1)]);
              }
            }
          }
        }
        out__.write(tp_mat);
        current_statement__ = 34;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
                out__.write(stan::model::rvalue(tp_ar_mat, "tp_ar_mat",
                              stan::model::index_uni(sym4__),
                              stan::model::index_uni(sym3__),
                              stan::model::index_uni(sym2__),
                              stan::model::index_uni(sym1__)));
              }
            }
          }
        }
        out__.write(tp_simplex);
        current_statement__ = 36;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            out__.write(tp_1d_simplex[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        current_statement__ = 37;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                out__.write(tp_3d_simplex[(sym4__ - 1)][(sym3__ - 1)][(sym2__
                  - 1)][(sym1__ - 1)]);
              }
            }
          }
        }
        out__.write(tp_cfcov_54);
        out__.write(tp_cfcov_33);
        current_statement__ = 40;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
              out__.write(stan::model::rvalue(tp_cfcov_33_ar,
                            "tp_cfcov_33_ar", stan::model::index_uni(sym3__),
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(sym1__)));
            }
          }
        }
        out__.write(theta_p);
        out__.write(tp_real);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      double gq_r1 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 43;
      gq_r1 = foo_bar1(p_real, pstream__);
      double gq_r2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 44;
      gq_r2 = foo_bar1(J, pstream__);
      std::vector<double> gq_real_1d_ar =
        std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      std::vector<std::vector<std::vector<double>>> gq_real_3d_ar =
        std::vector<std::vector<std::vector<double>>>(N,
          std::vector<std::vector<double>>(M,
            std::vector<double>(K, std::numeric_limits<double>::quiet_NaN())));
      Eigen::Matrix<double,-1,1> gq_vec =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,-1,1>> gq_1d_vec =
        std::vector<Eigen::Matrix<double,-1,1>>(N,
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>
        gq_3d_vec =
        std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(M,
            std::vector<Eigen::Matrix<double,-1,1>>(K,
              Eigen::Matrix<double,-1,1>::Constant(N,
                std::numeric_limits<double>::quiet_NaN()))));
      Eigen::Matrix<double,1,-1> gq_row_vec =
        Eigen::Matrix<double,1,-1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,1,-1>> gq_1d_row_vec =
        std::vector<Eigen::Matrix<double,1,-1>>(N,
          Eigen::Matrix<double,1,-1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<std::vector<Eigen::Matrix<double,1,-1>>>>
        gq_3d_row_vec =
        std::vector<std::vector<std::vector<Eigen::Matrix<double,1,-1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<double,1,-1>>>(M,
            std::vector<Eigen::Matrix<double,1,-1>>(K,
              Eigen::Matrix<double,1,-1>::Constant(N,
                std::numeric_limits<double>::quiet_NaN()))));
      std::vector<std::vector<Eigen::Matrix<double,-1,-1>>> gq_ar_mat =
        std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>(4,
          std::vector<Eigen::Matrix<double,-1,-1>>(5,
            Eigen::Matrix<double,-1,-1>::Constant(2, 3,
              std::numeric_limits<double>::quiet_NaN())));
      Eigen::Matrix<double,-1,1> gq_simplex =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,-1,1>> gq_1d_simplex =
        std::vector<Eigen::Matrix<double,-1,1>>(N,
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>
        gq_3d_simplex =
        std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(M,
            std::vector<Eigen::Matrix<double,-1,1>>(K,
              Eigen::Matrix<double,-1,1>::Constant(N,
                std::numeric_limits<double>::quiet_NaN()))));
      Eigen::Matrix<double,-1,-1> gq_cfcov_54 =
        Eigen::Matrix<double,-1,-1>::Constant(5, 4,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> gq_cfcov_33 =
        Eigen::Matrix<double,-1,-1>::Constant(3, 3,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,-1,-1>> gq_cfcov_33_ar =
        std::vector<Eigen::Matrix<double,-1,-1>>(K,
          Eigen::Matrix<double,-1,-1>::Constant(3, 3,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<int> indices =
        std::vector<int>(3, std::numeric_limits<int>::min());
      current_statement__ = 60;
      stan::model::assign(indices, std::vector<int>{2, 3, 1},
        "assigning variable indices");
      std::vector<Eigen::Matrix<double,-1,-1>> indexing_mat =
        std::vector<Eigen::Matrix<double,-1,-1>>(5,
          Eigen::Matrix<double,-1,-1>::Constant(3, 4,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<Eigen::Matrix<double,-1,-1>> idx_res1 =
        std::vector<Eigen::Matrix<double,-1,-1>>(3,
          Eigen::Matrix<double,-1,-1>::Constant(3, 4,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<Eigen::Matrix<double,-1,-1>> idx_res2 =
        std::vector<Eigen::Matrix<double,-1,-1>>(5,
          Eigen::Matrix<double,-1,-1>::Constant(3, 4,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<Eigen::Matrix<double,-1,-1>> idx_res3 =
        std::vector<Eigen::Matrix<double,-1,-1>>(3,
          Eigen::Matrix<double,-1,-1>::Constant(3, 3,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<Eigen::Matrix<double,-1,-1>> idx_res11 =
        std::vector<Eigen::Matrix<double,-1,-1>>(3,
          Eigen::Matrix<double,-1,-1>::Constant(3, 4,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<Eigen::Matrix<double,-1,-1>> idx_res21 =
        std::vector<Eigen::Matrix<double,-1,-1>>(5,
          Eigen::Matrix<double,-1,-1>::Constant(3, 4,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<Eigen::Matrix<double,-1,-1>> idx_res31 =
        std::vector<Eigen::Matrix<double,-1,-1>>(3,
          Eigen::Matrix<double,-1,-1>::Constant(3, 3,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<Eigen::Matrix<double,1,-1>> idx_res4 =
        std::vector<Eigen::Matrix<double,1,-1>>(3,
          Eigen::Matrix<double,1,-1>::Constant(4,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<Eigen::Matrix<double,-1,1>> idx_res5 =
        std::vector<Eigen::Matrix<double,-1,1>>(2,
          Eigen::Matrix<double,-1,1>::Constant(2,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 105;
      stan::model::assign(gq_real_1d_ar,
        stan::model::rvalue(p_1d_simplex, "p_1d_simplex",
          stan::model::index_omni(), stan::model::index_uni(1)),
        "assigning variable gq_real_1d_ar");
      current_statement__ = 106;
      stan::model::assign(gq_real_3d_ar, p_real_3d_ar,
        "assigning variable gq_real_3d_ar");
      current_statement__ = 107;
      stan::model::assign(gq_1d_vec, p_1d_vec, "assigning variable gq_1d_vec");
      current_statement__ = 108;
      stan::model::assign(gq_3d_vec, p_3d_vec, "assigning variable gq_3d_vec");
      current_statement__ = 109;
      stan::model::assign(gq_row_vec, p_row_vec,
        "assigning variable gq_row_vec");
      current_statement__ = 110;
      stan::model::assign(gq_1d_row_vec, p_1d_row_vec,
        "assigning variable gq_1d_row_vec");
      current_statement__ = 111;
      stan::model::assign(gq_3d_row_vec, p_3d_row_vec,
        "assigning variable gq_3d_row_vec");
      current_statement__ = 112;
      stan::model::assign(gq_simplex,
        stan::model::rvalue(p_1d_simplex, "p_1d_simplex",
          stan::model::index_uni(1), stan::model::index_min_max(1, N)),
        "assigning variable gq_simplex");
      current_statement__ = 113;
      stan::model::assign(gq_1d_simplex, p_1d_simplex,
        "assigning variable gq_1d_simplex");
      current_statement__ = 114;
      stan::model::assign(gq_3d_simplex, p_3d_simplex,
        "assigning variable gq_3d_simplex");
      current_statement__ = 115;
      stan::model::assign(gq_cfcov_54, p_cfcov_54,
        "assigning variable gq_cfcov_54");
      current_statement__ = 116;
      stan::model::assign(gq_cfcov_33, p_cfcov_33,
        "assigning variable gq_cfcov_33");
      current_statement__ = 117;
      stan::model::assign(gq_cfcov_33_ar, p_cfcov_33_ar,
        "assigning variable gq_cfcov_33_ar");
      current_statement__ = 126;
      for (int i = 1; i <= 2; ++i) {
        current_statement__ = 124;
        for (int j = 1; j <= 3; ++j) {
          current_statement__ = 122;
          for (int m = 1; m <= 4; ++m) {
            current_statement__ = 120;
            for (int n = 1; n <= 5; ++n) {
              current_statement__ = 118;
              stan::model::assign(gq_ar_mat, 0.4,
                "assigning variable gq_ar_mat", stan::model::index_uni(m),
                stan::model::index_uni(n), stan::model::index_uni(i),
                stan::model::index_uni(j));
            }
          }
        }
      }
      current_statement__ = 128;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 127;
        stan::model::assign(gq_vec, (-(1.0) *
          stan::model::rvalue(p_vec, "p_vec", stan::model::index_uni(i))),
          "assigning variable gq_vec", stan::model::index_uni(i));
      }
      current_statement__ = 132;
      for (int i = 1; i <= 3; ++i) {
        current_statement__ = 131;
        for (int j = 1; j <= 4; ++j) {
          current_statement__ = 130;
          for (int k = 1; k <= 5; ++k) {
            current_statement__ = 129;
            stan::model::assign(indexing_mat,
              stan::math::normal_rng(0, 1, base_rng__),
              "assigning variable indexing_mat", stan::model::index_uni(k),
              stan::model::index_uni(i), stan::model::index_uni(j));
          }
        }
      }
      current_statement__ = 135;
      for (int i = 1; i <= stan::math::size(indices); ++i) {
        current_statement__ = 134;
        for (int j = 1; j <= stan::math::size(indices); ++j) {
          current_statement__ = 133;
          stan::model::assign(idx_res1,
            stan::model::rvalue(indexing_mat, "indexing_mat",
              stan::model::index_uni(
                stan::model::rvalue(indices, "indices",
                  stan::model::index_uni(i))),
              stan::model::index_uni(
                stan::model::rvalue(indices, "indices",
                  stan::model::index_uni(j)))),
            "assigning variable idx_res1", stan::model::index_uni(i),
            stan::model::index_uni(j));
        }
      }
      current_statement__ = 136;
      stan::model::assign(idx_res11,
        stan::model::rvalue(indexing_mat, "indexing_mat",
          stan::model::index_multi(indices),
          stan::model::index_multi(indices)), "assigning variable idx_res11");
      current_statement__ = 138;
      if (stan::math::logical_neq(
            stan::model::rvalue(
              stan::model::rvalue(indexing_mat, "indexing_mat",
                stan::model::index_multi(indices),
                stan::model::index_multi(indices)),
              "indexing_mat[indices, indices]", stan::model::index_uni(2),
              stan::model::index_uni(1), stan::model::index_uni(1)),
            stan::model::rvalue(idx_res1, "idx_res1",
              stan::model::index_uni(2), stan::model::index_uni(1),
              stan::model::index_uni(1)))) {
        current_statement__ = 137;
        std::stringstream errmsg_stream__;
        stan::math::stan_print(&errmsg_stream__, "indexing test 1 failed");
        throw std::domain_error(errmsg_stream__.str());
      }
      current_statement__ = 141;
      for (int i = 1; i <= 5; ++i) {
        current_statement__ = 140;
        for (int j = 1; j <= stan::math::size(indices); ++j) {
          current_statement__ = 139;
          stan::model::assign(idx_res2,
            stan::model::rvalue(indexing_mat, "indexing_mat",
              stan::model::index_uni(i),
              stan::model::index_uni(
                stan::model::rvalue(indices, "indices",
                  stan::model::index_uni(j)))),
            "assigning variable idx_res2", stan::model::index_uni(i),
            stan::model::index_uni(j));
        }
      }
      current_statement__ = 142;
      stan::model::assign(idx_res21,
        stan::model::rvalue(indexing_mat, "indexing_mat",
          stan::model::index_omni(), stan::model::index_multi(indices)),
        "assigning variable idx_res21");
      current_statement__ = 144;
      if (stan::math::logical_neq(
            stan::model::rvalue(
              stan::model::rvalue(indexing_mat, "indexing_mat",
                stan::model::index_omni(), stan::model::index_multi(indices)),
              "indexing_mat[:, indices]", stan::model::index_uni(2),
              stan::model::index_uni(1), stan::model::index_uni(1)),
            stan::model::rvalue(idx_res2, "idx_res2",
              stan::model::index_uni(2), stan::model::index_uni(1),
              stan::model::index_uni(1)))) {
        current_statement__ = 143;
        std::stringstream errmsg_stream__;
        stan::math::stan_print(&errmsg_stream__, "indexing test 2 failed");
        throw std::domain_error(errmsg_stream__.str());
      }
      current_statement__ = 148;
      for (int i = 1; i <= stan::math::size(indices); ++i) {
        current_statement__ = 147;
        for (int j = 1; j <= 3; ++j) {
          current_statement__ = 146;
          for (int k = 1; k <= stan::math::size(indices); ++k) {
            current_statement__ = 145;
            stan::model::assign(idx_res3,
              stan::model::rvalue(indexing_mat, "indexing_mat",
                stan::model::index_uni(
                  stan::model::rvalue(indices, "indices",
                    stan::model::index_uni(i))), stan::model::index_uni(j),
                stan::model::index_uni(
                  stan::model::rvalue(indices, "indices",
                    stan::model::index_uni(k)))),
              "assigning variable idx_res3", stan::model::index_uni(i),
              stan::model::index_uni(j), stan::model::index_uni(k));
          }
        }
      }
      current_statement__ = 149;
      stan::model::assign(idx_res31,
        stan::model::rvalue(indexing_mat, "indexing_mat",
          stan::model::index_multi(indices), stan::model::index_omni(),
          stan::model::index_multi(indices)), "assigning variable idx_res31");
      current_statement__ = 151;
      if (stan::math::logical_neq(
            stan::model::rvalue(
              stan::model::rvalue(indexing_mat, "indexing_mat",
                stan::model::index_multi(indices), stan::model::index_omni(),
                stan::model::index_multi(indices)),
              "indexing_mat[indices, :, indices]", stan::model::index_uni(2),
              stan::model::index_uni(1), stan::model::index_uni(1)),
            stan::model::rvalue(idx_res3, "idx_res3",
              stan::model::index_uni(2), stan::model::index_uni(1),
              stan::model::index_uni(1)))) {
        current_statement__ = 150;
        std::stringstream errmsg_stream__;
        stan::math::stan_print(&errmsg_stream__, "indexing test 3 failed");
        throw std::domain_error(errmsg_stream__.str());
      }
      current_statement__ = 152;
      stan::model::assign(idx_res4,
        stan::model::rvalue(indexing_mat, "indexing_mat",
          stan::model::index_min_max(1, 3), stan::model::index_uni(1),
          stan::model::index_omni()), "assigning variable idx_res4");
      current_statement__ = 153;
      stan::model::assign(idx_res5,
        stan::model::rvalue(indexing_mat, "indexing_mat",
          stan::model::index_min(4), stan::model::index_min_max(2, 3),
          stan::model::index_uni(1)), "assigning variable idx_res5");
      current_statement__ = 45;
      stan::math::check_greater_or_equal(function__, "gq_real_1d_ar",
        gq_real_1d_ar, 0);
      current_statement__ = 46;
      stan::math::check_greater_or_equal(function__, "gq_real_3d_ar",
        gq_real_3d_ar, 0);
      current_statement__ = 47;
      stan::math::check_less_or_equal(function__, "gq_vec", gq_vec, 1);
      current_statement__ = 53;
      stan::math::check_greater_or_equal(function__, "gq_ar_mat", gq_ar_mat,
        0);
      current_statement__ = 53;
      stan::math::check_less_or_equal(function__, "gq_ar_mat", gq_ar_mat, 1);
      current_statement__ = 54;
      stan::math::check_simplex(function__, "gq_simplex", gq_simplex);
      current_statement__ = 55;
      stan::math::check_simplex(function__, "gq_1d_simplex", gq_1d_simplex);
      current_statement__ = 56;
      stan::math::check_simplex(function__, "gq_3d_simplex", gq_3d_simplex);
      current_statement__ = 57;
      stan::math::check_cholesky_factor(function__, "gq_cfcov_54",
        gq_cfcov_54);
      current_statement__ = 58;
      stan::math::check_cholesky_factor(function__, "gq_cfcov_33",
        gq_cfcov_33);
      current_statement__ = 59;
      stan::math::check_cholesky_factor(function__, "gq_cfcov_33_ar",
        gq_cfcov_33_ar);
      out__.write(gq_r1);
      out__.write(gq_r2);
      out__.write(gq_real_1d_ar);
      current_statement__ = 46;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            out__.write(gq_real_3d_ar[(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
              1)]);
          }
        }
      }
      out__.write(gq_vec);
      current_statement__ = 48;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(gq_1d_vec[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 49;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              out__.write(gq_3d_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ -
                1)][(sym1__ - 1)]);
            }
          }
        }
      }
      out__.write(gq_row_vec);
      current_statement__ = 51;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(gq_1d_row_vec[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 52;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              out__.write(gq_3d_row_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ -
                1)][(sym1__ - 1)]);
            }
          }
        }
      }
      current_statement__ = 53;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
              out__.write(stan::model::rvalue(gq_ar_mat, "gq_ar_mat",
                            stan::model::index_uni(sym4__),
                            stan::model::index_uni(sym3__),
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(sym1__)));
            }
          }
        }
      }
      out__.write(gq_simplex);
      current_statement__ = 55;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(gq_1d_simplex[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 56;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              out__.write(gq_3d_simplex[(sym4__ - 1)][(sym3__ - 1)][(sym2__ -
                1)][(sym1__ - 1)]);
            }
          }
        }
      }
      out__.write(gq_cfcov_54);
      out__.write(gq_cfcov_33);
      current_statement__ = 59;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            out__.write(stan::model::rvalue(gq_cfcov_33_ar, "gq_cfcov_33_ar",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      out__.write(indices);
      current_statement__ = 61;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            out__.write(stan::model::rvalue(indexing_mat, "indexing_mat",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      current_statement__ = 62;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            out__.write(stan::model::rvalue(idx_res1, "idx_res1",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      current_statement__ = 63;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            out__.write(stan::model::rvalue(idx_res2, "idx_res2",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      current_statement__ = 64;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            out__.write(stan::model::rvalue(idx_res3, "idx_res3",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      current_statement__ = 65;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            out__.write(stan::model::rvalue(idx_res11, "idx_res11",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      current_statement__ = 66;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            out__.write(stan::model::rvalue(idx_res21, "idx_res21",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      current_statement__ = 67;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            out__.write(stan::model::rvalue(idx_res31, "idx_res31",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      current_statement__ = 68;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          out__.write(idx_res4[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 69;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          out__.write(idx_res5[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ p_real = DUMMY_VAR__;
      current_statement__ = 1;
      p_real = in__.read<local_scalar_t__>();
      out__.write(p_real);
      local_scalar_t__ p_upper = DUMMY_VAR__;
      current_statement__ = 2;
      p_upper = in__.read<local_scalar_t__>();
      out__.write_free_lb(p_real, p_upper);
      local_scalar_t__ p_lower = DUMMY_VAR__;
      current_statement__ = 3;
      p_lower = in__.read<local_scalar_t__>();
      out__.write_free_ub(p_upper, p_lower);
      std::vector<local_scalar_t__> offset_multiplier =
        std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(offset_multiplier,
        in__.read<std::vector<local_scalar_t__>>(5),
        "assigning variable offset_multiplier");
      out__.write_free_offset_multiplier(1, 2, offset_multiplier);
      std::vector<local_scalar_t__> no_offset_multiplier =
        std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(no_offset_multiplier,
        in__.read<std::vector<local_scalar_t__>>(5),
        "assigning variable no_offset_multiplier");
      out__.write_free_offset_multiplier(0, 2, no_offset_multiplier);
      std::vector<local_scalar_t__> offset_no_multiplier =
        std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(offset_no_multiplier,
        in__.read<std::vector<local_scalar_t__>>(5),
        "assigning variable offset_no_multiplier");
      out__.write_free_offset_multiplier(3, 1, offset_no_multiplier);
      std::vector<local_scalar_t__> p_real_1d_ar =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(p_real_1d_ar,
        in__.read<std::vector<local_scalar_t__>>(N),
        "assigning variable p_real_1d_ar");
      out__.write_free_lb(0, p_real_1d_ar);
      std::vector<std::vector<std::vector<local_scalar_t__>>> p_real_3d_ar =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(N,
          std::vector<std::vector<local_scalar_t__>>(M,
            std::vector<local_scalar_t__>(K, DUMMY_VAR__)));
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 8;
            p_real_3d_ar[(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
              1)] = in__.read<local_scalar_t__>();
          }
        }
      }
      out__.write_free_lb(0, p_real_3d_ar);
      Eigen::Matrix<local_scalar_t__,-1,1> p_vec =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 9;
      stan::model::assign(p_vec,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable p_vec");
      out__.write_free_lb(0, p_vec);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> p_1d_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 10;
          stan::model::assign(p_1d_vec, in__.read<local_scalar_t__>(),
            "assigning variable p_1d_vec", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_1d_vec);
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>
        p_3d_vec =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__))));
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              current_statement__ = 11;
              stan::model::assign(p_3d_vec, in__.read<local_scalar_t__>(),
                "assigning variable p_3d_vec",
                stan::model::index_uni(sym4__),
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
            }
          }
        }
      }
      out__.write(p_3d_vec);
      Eigen::Matrix<local_scalar_t__,1,-1> p_row_vec =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 12;
      stan::model::assign(p_row_vec,
        in__.read<Eigen::Matrix<local_scalar_t__,1,-1>>(N),
        "assigning variable p_row_vec");
      out__.write(p_row_vec);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> p_1d_row_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 13;
          stan::model::assign(p_1d_row_vec, in__.read<local_scalar_t__>(),
            "assigning variable p_1d_row_vec",
            stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_1d_row_vec);
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>
        p_3d_row_vec =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(K,
              Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__))));
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              current_statement__ = 14;
              stan::model::assign(p_3d_row_vec,
                in__.read<local_scalar_t__>(),
                "assigning variable p_3d_row_vec",
                stan::model::index_uni(sym4__),
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
            }
          }
        }
      }
      out__.write(p_3d_row_vec);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 4, DUMMY_VAR__);
      current_statement__ = 15;
      stan::model::assign(p_mat,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 4),
        "assigning variable p_mat");
      out__.write(p_mat);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>
        p_ar_mat =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(4,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 3,
              DUMMY_VAR__)));
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
              current_statement__ = 16;
              stan::model::assign(p_ar_mat, in__.read<local_scalar_t__>(),
                "assigning variable p_ar_mat",
                stan::model::index_uni(sym4__),
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
            }
          }
        }
      }
      out__.write_free_lub(0, 1, p_ar_mat);
      Eigen::Matrix<local_scalar_t__,-1,1> p_simplex =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 17;
      stan::model::assign(p_simplex,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable p_simplex");
      out__.write_free_simplex(p_simplex);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> p_1d_simplex =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 18;
          stan::model::assign(p_1d_simplex, in__.read<local_scalar_t__>(),
            "assigning variable p_1d_simplex",
            stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
        }
      }
      out__.write_free_simplex(p_1d_simplex);
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>
        p_3d_simplex =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__))));
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              current_statement__ = 19;
              stan::model::assign(p_3d_simplex,
                in__.read<local_scalar_t__>(),
                "assigning variable p_3d_simplex",
                stan::model::index_uni(sym4__),
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
            }
          }
        }
      }
      out__.write_free_simplex(p_3d_simplex);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_cfcov_54 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 4, DUMMY_VAR__);
      current_statement__ = 20;
      stan::model::assign(p_cfcov_54,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 4),
        "assigning variable p_cfcov_54");
      out__.write_free_cholesky_factor_cov(p_cfcov_54);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_cfcov_33 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 3, DUMMY_VAR__);
      current_statement__ = 21;
      stan::model::assign(p_cfcov_33,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(3, 3),
        "assigning variable p_cfcov_33");
      out__.write_free_cholesky_factor_cov(p_cfcov_33);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> p_cfcov_33_ar =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(K,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 3, DUMMY_VAR__));
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 22;
            stan::model::assign(p_cfcov_33_ar, in__.read<local_scalar_t__>(),
              "assigning variable p_cfcov_33_ar",
              stan::model::index_uni(sym3__), stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write_free_cholesky_factor_cov(p_cfcov_33_ar);
      Eigen::Matrix<local_scalar_t__,-1,1> x_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 23;
      stan::model::assign(x_p,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(2),
        "assigning variable x_p");
      out__.write(x_p);
      Eigen::Matrix<local_scalar_t__,-1,1> y_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 24;
      stan::model::assign(y_p,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(2),
        "assigning variable y_p");
      out__.write(y_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "p_real", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "p_upper",
        "double", std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "p_lower",
        "double", std::vector<size_t>{});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization",
        "offset_multiplier", "double",
        std::vector<size_t>{static_cast<size_t>(5)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization",
        "no_offset_multiplier", "double",
        std::vector<size_t>{static_cast<size_t>(5)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization",
        "offset_no_multiplier", "double",
        std::vector<size_t>{static_cast<size_t>(5)});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "p_real_1d_ar",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization", "p_real_3d_ar",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M),
          static_cast<size_t>(K)});
      current_statement__ = 9;
      context__.validate_dims("parameter initialization", "p_vec", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 10;
      context__.validate_dims("parameter initialization", "p_1d_vec",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 11;
      context__.validate_dims("parameter initialization", "p_3d_vec",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M),
          static_cast<size_t>(K), static_cast<size_t>(N)});
      current_statement__ = 12;
      context__.validate_dims("parameter initialization", "p_row_vec",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 13;
      context__.validate_dims("parameter initialization", "p_1d_row_vec",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 14;
      context__.validate_dims("parameter initialization", "p_3d_row_vec",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M),
          static_cast<size_t>(K), static_cast<size_t>(N)});
      current_statement__ = 15;
      context__.validate_dims("parameter initialization", "p_mat", "double",
        std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(4)});
      current_statement__ = 16;
      context__.validate_dims("parameter initialization", "p_ar_mat",
        "double",
        std::vector<size_t>{static_cast<size_t>(4), static_cast<size_t>(5),
          static_cast<size_t>(2), static_cast<size_t>(3)});
      current_statement__ = 17;
      context__.validate_dims("parameter initialization", "p_simplex",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 18;
      context__.validate_dims("parameter initialization", "p_1d_simplex",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 19;
      context__.validate_dims("parameter initialization", "p_3d_simplex",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M),
          static_cast<size_t>(K), static_cast<size_t>(N)});
      current_statement__ = 20;
      context__.validate_dims("parameter initialization", "p_cfcov_54",
        "double",
        std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(4)});
      current_statement__ = 21;
      context__.validate_dims("parameter initialization", "p_cfcov_33",
        "double",
        std::vector<size_t>{static_cast<size_t>(3), static_cast<size_t>(3)});
      current_statement__ = 22;
      context__.validate_dims("parameter initialization", "p_cfcov_33_ar",
        "double",
        std::vector<size_t>{static_cast<size_t>(K), static_cast<size_t>(3),
          static_cast<size_t>(3)});
      current_statement__ = 23;
      context__.validate_dims("parameter initialization", "x_p", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      current_statement__ = 24;
      context__.validate_dims("parameter initialization", "y_p", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ p_real = DUMMY_VAR__;
      current_statement__ = 1;
      p_real = context__.vals_r("p_real")[(1 - 1)];
      out__.write(p_real);
      local_scalar_t__ p_upper = DUMMY_VAR__;
      current_statement__ = 2;
      p_upper = context__.vals_r("p_upper")[(1 - 1)];
      out__.write_free_lb(p_real, p_upper);
      local_scalar_t__ p_lower = DUMMY_VAR__;
      current_statement__ = 3;
      p_lower = context__.vals_r("p_lower")[(1 - 1)];
      out__.write_free_ub(p_upper, p_lower);
      std::vector<local_scalar_t__> offset_multiplier =
        std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      current_statement__ = 4;
      offset_multiplier = context__.vals_r("offset_multiplier");
      out__.write_free_offset_multiplier(1, 2, offset_multiplier);
      std::vector<local_scalar_t__> no_offset_multiplier =
        std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      current_statement__ = 5;
      no_offset_multiplier = context__.vals_r("no_offset_multiplier");
      out__.write_free_offset_multiplier(0, 2, no_offset_multiplier);
      std::vector<local_scalar_t__> offset_no_multiplier =
        std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      current_statement__ = 6;
      offset_no_multiplier = context__.vals_r("offset_no_multiplier");
      out__.write_free_offset_multiplier(3, 1, offset_no_multiplier);
      std::vector<local_scalar_t__> p_real_1d_ar =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 7;
      p_real_1d_ar = context__.vals_r("p_real_1d_ar");
      out__.write_free_lb(0, p_real_1d_ar);
      std::vector<std::vector<std::vector<local_scalar_t__>>> p_real_3d_ar =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(N,
          std::vector<std::vector<local_scalar_t__>>(M,
            std::vector<local_scalar_t__>(K, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> p_real_3d_ar_flat__;
        current_statement__ = 8;
        p_real_3d_ar_flat__ = context__.vals_r("p_real_3d_ar");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(p_real_3d_ar, p_real_3d_ar_flat__[(pos__ -
                1)], "assigning variable p_real_3d_ar",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write_free_lb(0, p_real_3d_ar);
      Eigen::Matrix<local_scalar_t__,-1,1> p_vec =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_vec_flat__;
        current_statement__ = 9;
        p_vec_flat__ = context__.vals_r("p_vec");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(p_vec, p_vec_flat__[(pos__ - 1)],
            "assigning variable p_vec", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lb(0, p_vec);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> p_1d_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> p_1d_vec_flat__;
        current_statement__ = 10;
        p_1d_vec_flat__ = context__.vals_r("p_1d_vec");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_1d_vec, p_1d_vec_flat__[(pos__ - 1)],
              "assigning variable p_1d_vec", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_1d_vec);
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>
        p_3d_vec =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__))));
      {
        std::vector<local_scalar_t__> p_3d_vec_flat__;
        current_statement__ = 11;
        p_3d_vec_flat__ = context__.vals_r("p_3d_vec");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                stan::model::assign(p_3d_vec, p_3d_vec_flat__[(pos__ - 1)],
                  "assigning variable p_3d_vec",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      out__.write(p_3d_vec);
      Eigen::Matrix<local_scalar_t__,1,-1> p_row_vec =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_row_vec_flat__;
        current_statement__ = 12;
        p_row_vec_flat__ = context__.vals_r("p_row_vec");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(p_row_vec, p_row_vec_flat__[(pos__ - 1)],
            "assigning variable p_row_vec", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(p_row_vec);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> p_1d_row_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> p_1d_row_vec_flat__;
        current_statement__ = 13;
        p_1d_row_vec_flat__ = context__.vals_r("p_1d_row_vec");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_1d_row_vec, p_1d_row_vec_flat__[(pos__ -
              1)], "assigning variable p_1d_row_vec",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_1d_row_vec);
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>
        p_3d_row_vec =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(K,
              Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__))));
      {
        std::vector<local_scalar_t__> p_3d_row_vec_flat__;
        current_statement__ = 14;
        p_3d_row_vec_flat__ = context__.vals_r("p_3d_row_vec");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                stan::model::assign(p_3d_row_vec, p_3d_row_vec_flat__[(pos__
                  - 1)], "assigning variable p_3d_row_vec",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      out__.write(p_3d_row_vec);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 4, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_mat_flat__;
        current_statement__ = 15;
        p_mat_flat__ = context__.vals_r("p_mat");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            stan::model::assign(p_mat, p_mat_flat__[(pos__ - 1)],
              "assigning variable p_mat", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_mat);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>
        p_ar_mat =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(4,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 3,
              DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> p_ar_mat_flat__;
        current_statement__ = 16;
        p_ar_mat_flat__ = context__.vals_r("p_ar_mat");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
                stan::model::assign(p_ar_mat, p_ar_mat_flat__[(pos__ - 1)],
                  "assigning variable p_ar_mat",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      out__.write_free_lub(0, 1, p_ar_mat);
      Eigen::Matrix<local_scalar_t__,-1,1> p_simplex =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_simplex_flat__;
        current_statement__ = 17;
        p_simplex_flat__ = context__.vals_r("p_simplex");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(p_simplex, p_simplex_flat__[(pos__ - 1)],
            "assigning variable p_simplex", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_simplex(p_simplex);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> p_1d_simplex =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> p_1d_simplex_flat__;
        current_statement__ = 18;
        p_1d_simplex_flat__ = context__.vals_r("p_1d_simplex");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_1d_simplex, p_1d_simplex_flat__[(pos__ -
              1)], "assigning variable p_1d_simplex",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_simplex(p_1d_simplex);
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>
        p_3d_simplex =
        std::vector<
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
          std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(M,
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__))));
      {
        std::vector<local_scalar_t__> p_3d_simplex_flat__;
        current_statement__ = 19;
        p_3d_simplex_flat__ = context__.vals_r("p_3d_simplex");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                stan::model::assign(p_3d_simplex, p_3d_simplex_flat__[(pos__
                  - 1)], "assigning variable p_3d_simplex",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      out__.write_free_simplex(p_3d_simplex);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_cfcov_54 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 4, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_cfcov_54_flat__;
        current_statement__ = 20;
        p_cfcov_54_flat__ = context__.vals_r("p_cfcov_54");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            stan::model::assign(p_cfcov_54, p_cfcov_54_flat__[(pos__ - 1)],
              "assigning variable p_cfcov_54",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_cholesky_factor_cov(p_cfcov_54);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_cfcov_33 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 3, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_cfcov_33_flat__;
        current_statement__ = 21;
        p_cfcov_33_flat__ = context__.vals_r("p_cfcov_33");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            stan::model::assign(p_cfcov_33, p_cfcov_33_flat__[(pos__ - 1)],
              "assigning variable p_cfcov_33",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_cholesky_factor_cov(p_cfcov_33);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> p_cfcov_33_ar =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(K,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 3, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> p_cfcov_33_ar_flat__;
        current_statement__ = 22;
        p_cfcov_33_ar_flat__ = context__.vals_r("p_cfcov_33_ar");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
              stan::model::assign(p_cfcov_33_ar, p_cfcov_33_ar_flat__[(pos__
                - 1)], "assigning variable p_cfcov_33_ar",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write_free_cholesky_factor_cov(p_cfcov_33_ar);
      Eigen::Matrix<local_scalar_t__,-1,1> x_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> x_p_flat__;
        current_statement__ = 23;
        x_p_flat__ = context__.vals_r("x_p");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          stan::model::assign(x_p, x_p_flat__[(pos__ - 1)],
            "assigning variable x_p", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(x_p);
      Eigen::Matrix<local_scalar_t__,-1,1> y_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> y_p_flat__;
        current_statement__ = 24;
        y_p_flat__ = context__.vals_r("y_p");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          stan::model::assign(y_p, y_p_flat__[(pos__ - 1)],
            "assigning variable y_p", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(y_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"p_real", "p_upper", "p_lower",
                "offset_multiplier", "no_offset_multiplier",
                "offset_no_multiplier", "p_real_1d_ar", "p_real_3d_ar",
                "p_vec", "p_1d_vec", "p_3d_vec", "p_row_vec", "p_1d_row_vec",
                "p_3d_row_vec", "p_mat", "p_ar_mat", "p_simplex",
                "p_1d_simplex", "p_3d_simplex", "p_cfcov_54", "p_cfcov_33",
                "p_cfcov_33_ar", "x_p", "y_p"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"tp_real_1d_ar", "tp_real_3d_ar", "tp_vec", "tp_1d_vec",
             "tp_3d_vec", "tp_row_vec", "tp_1d_row_vec", "tp_3d_row_vec",
             "tp_mat", "tp_ar_mat", "tp_simplex", "tp_1d_simplex",
             "tp_3d_simplex", "tp_cfcov_54", "tp_cfcov_33", "tp_cfcov_33_ar",
             "theta_p", "tp_real"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string>
        temp{"gq_r1", "gq_r2", "gq_real_1d_ar", "gq_real_3d_ar", "gq_vec",
             "gq_1d_vec", "gq_3d_vec", "gq_row_vec", "gq_1d_row_vec",
             "gq_3d_row_vec", "gq_ar_mat", "gq_simplex", "gq_1d_simplex",
             "gq_3d_simplex", "gq_cfcov_54", "gq_cfcov_33", "gq_cfcov_33_ar",
             "indices", "indexing_mat", "idx_res1", "idx_res2", "idx_res3",
             "idx_res11", "idx_res21", "idx_res31", "idx_res4", "idx_res5"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(5)},
                std::vector<size_t>{static_cast<size_t>(5)},
                std::vector<size_t>{static_cast<size_t>(5)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M), static_cast<size_t>(K)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M), static_cast<size_t>(K),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M), static_cast<size_t>(K),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(5),
                  static_cast<size_t>(4)},
                std::vector<size_t>{static_cast<size_t>(4),
                  static_cast<size_t>(5), static_cast<size_t>(2),
                  static_cast<size_t>(3)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M), static_cast<size_t>(K),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(5),
                  static_cast<size_t>(4)},
                std::vector<size_t>{static_cast<size_t>(3),
                  static_cast<size_t>(3)},
                std::vector<size_t>{static_cast<size_t>(K),
                  static_cast<size_t>(3), static_cast<size_t>(3)},
                std::vector<size_t>{static_cast<size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(2)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(M), static_cast<size_t>(K)},
             std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(M), static_cast<size_t>(K),
               static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(M), static_cast<size_t>(K),
               static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(5),
               static_cast<size_t>(4)},
             std::vector<size_t>{static_cast<size_t>(4),
               static_cast<size_t>(5), static_cast<size_t>(2),
               static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(M), static_cast<size_t>(K),
               static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(5),
               static_cast<size_t>(4)},
             std::vector<size_t>{static_cast<size_t>(3),
               static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(K),
               static_cast<size_t>(3), static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(2)},
             std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(M), static_cast<size_t>(K)},
             std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(M), static_cast<size_t>(K),
               static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(M), static_cast<size_t>(K),
               static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(4),
               static_cast<size_t>(5), static_cast<size_t>(2),
               static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(M), static_cast<size_t>(K),
               static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(5),
               static_cast<size_t>(4)},
             std::vector<size_t>{static_cast<size_t>(3),
               static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(K),
               static_cast<size_t>(3), static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(5),
               static_cast<size_t>(3), static_cast<size_t>(4)},
             std::vector<size_t>{static_cast<size_t>(3),
               static_cast<size_t>(3), static_cast<size_t>(4)},
             std::vector<size_t>{static_cast<size_t>(5),
               static_cast<size_t>(3), static_cast<size_t>(4)},
             std::vector<size_t>{static_cast<size_t>(3),
               static_cast<size_t>(3), static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(3),
               static_cast<size_t>(3), static_cast<size_t>(4)},
             std::vector<size_t>{static_cast<size_t>(5),
               static_cast<size_t>(3), static_cast<size_t>(4)},
             std::vector<size_t>{static_cast<size_t>(3),
               static_cast<size_t>(3), static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(3),
               static_cast<size_t>(4)},
             std::vector<size_t>{static_cast<size_t>(2),
               static_cast<size_t>(2)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "p_real");
    param_names__.emplace_back(std::string() + "p_upper");
    param_names__.emplace_back(std::string() + "p_lower");
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      param_names__.emplace_back(std::string() + "offset_multiplier" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      param_names__.emplace_back(std::string() + "no_offset_multiplier" + '.'
        + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      param_names__.emplace_back(std::string() + "offset_no_multiplier" + '.'
        + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_real_1d_ar" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "p_real_3d_ar" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_vec" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_1d_vec" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
            param_names__.emplace_back(std::string() + "p_3d_vec" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_row_vec" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_1d_row_vec" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
            param_names__.emplace_back(std::string() + "p_3d_row_vec" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_mat" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
            param_names__.emplace_back(std::string() + "p_ar_mat" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_simplex" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_1d_simplex" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
            param_names__.emplace_back(std::string() + "p_3d_simplex" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_cfcov_54" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_cfcov_33" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
          param_names__.emplace_back(std::string() + "p_cfcov_33_ar" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "x_p" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "y_p" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_real_1d_ar" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            param_names__.emplace_back(std::string() + "tp_real_3d_ar" + '.'
              + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_vec" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_1d_vec" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              param_names__.emplace_back(std::string() + "tp_3d_vec" + '.' +
                std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
                std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_row_vec" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_1d_row_vec" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              param_names__.emplace_back(std::string() + "tp_3d_row_vec" +
                '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) +
                '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_mat" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
              param_names__.emplace_back(std::string() + "tp_ar_mat" + '.' +
                std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
                std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_simplex" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_1d_simplex" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              param_names__.emplace_back(std::string() + "tp_3d_simplex" +
                '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) +
                '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_cfcov_54" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_cfcov_33" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            param_names__.emplace_back(std::string() + "tp_cfcov_33_ar" + '.'
              + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta_p" + '.' +
          std::to_string(sym1__));
      }
      param_names__.emplace_back(std::string() + "tp_real");
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "gq_r1");
      param_names__.emplace_back(std::string() + "gq_r2");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "gq_real_1d_ar" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            param_names__.emplace_back(std::string() + "gq_real_3d_ar" + '.'
              + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "gq_vec" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "gq_1d_vec" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              param_names__.emplace_back(std::string() + "gq_3d_vec" + '.' +
                std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
                std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "gq_row_vec" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "gq_1d_row_vec" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              param_names__.emplace_back(std::string() + "gq_3d_row_vec" +
                '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) +
                '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
              param_names__.emplace_back(std::string() + "gq_ar_mat" + '.' +
                std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
                std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "gq_simplex" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "gq_1d_simplex" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              param_names__.emplace_back(std::string() + "gq_3d_simplex" +
                '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) +
                '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          param_names__.emplace_back(std::string() + "gq_cfcov_54" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          param_names__.emplace_back(std::string() + "gq_cfcov_33" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            param_names__.emplace_back(std::string() + "gq_cfcov_33_ar" + '.'
              + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "indices" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            param_names__.emplace_back(std::string() + "indexing_mat" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            param_names__.emplace_back(std::string() + "idx_res1" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            param_names__.emplace_back(std::string() + "idx_res2" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            param_names__.emplace_back(std::string() + "idx_res3" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            param_names__.emplace_back(std::string() + "idx_res11" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            param_names__.emplace_back(std::string() + "idx_res21" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            param_names__.emplace_back(std::string() + "idx_res31" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          param_names__.emplace_back(std::string() + "idx_res4" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          param_names__.emplace_back(std::string() + "idx_res5" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "p_real");
    param_names__.emplace_back(std::string() + "p_upper");
    param_names__.emplace_back(std::string() + "p_lower");
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      param_names__.emplace_back(std::string() + "offset_multiplier" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      param_names__.emplace_back(std::string() + "no_offset_multiplier" + '.'
        + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      param_names__.emplace_back(std::string() + "offset_no_multiplier" + '.'
        + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_real_1d_ar" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "p_real_3d_ar" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_vec" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_1d_vec" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
            param_names__.emplace_back(std::string() + "p_3d_vec" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_row_vec" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_1d_row_vec" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
            param_names__.emplace_back(std::string() + "p_3d_row_vec" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_mat" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
            param_names__.emplace_back(std::string() + "p_ar_mat" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
      param_names__.emplace_back(std::string() + "p_simplex" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_1d_simplex" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
      for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
            param_names__.emplace_back(std::string() + "p_3d_simplex" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) *
         4)); ++sym1__) {
      param_names__.emplace_back(std::string() + "p_cfcov_54" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) *
         3)); ++sym1__) {
      param_names__.emplace_back(std::string() + "p_cfcov_33" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) *
         3)); ++sym1__) {
      for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_cfcov_33_ar" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "x_p" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "y_p" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_real_1d_ar" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            param_names__.emplace_back(std::string() + "tp_real_3d_ar" + '.'
              + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_vec" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_1d_vec" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              param_names__.emplace_back(std::string() + "tp_3d_vec" + '.' +
                std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
                std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_row_vec" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_1d_row_vec" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              param_names__.emplace_back(std::string() + "tp_3d_row_vec" +
                '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) +
                '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_mat" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
              param_names__.emplace_back(std::string() + "tp_ar_mat" + '.' +
                std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
                std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_simplex" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_1d_simplex" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              param_names__.emplace_back(std::string() + "tp_3d_simplex" +
                '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) +
                '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) *
           4)); ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_cfcov_54" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) *
           3)); ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_cfcov_33" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) *
           3)); ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_cfcov_33_ar" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta_p" + '.' +
          std::to_string(sym1__));
      }
      param_names__.emplace_back(std::string() + "tp_real");
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "gq_r1");
      param_names__.emplace_back(std::string() + "gq_r2");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "gq_real_1d_ar" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            param_names__.emplace_back(std::string() + "gq_real_3d_ar" + '.'
              + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "gq_vec" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "gq_1d_vec" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              param_names__.emplace_back(std::string() + "gq_3d_vec" + '.' +
                std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
                std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "gq_row_vec" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "gq_1d_row_vec" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              param_names__.emplace_back(std::string() + "gq_3d_row_vec" +
                '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) +
                '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
              param_names__.emplace_back(std::string() + "gq_ar_mat" + '.' +
                std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
                std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        param_names__.emplace_back(std::string() + "gq_simplex" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "gq_1d_simplex" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              param_names__.emplace_back(std::string() + "gq_3d_simplex" +
                '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) +
                '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) *
           4)); ++sym1__) {
        param_names__.emplace_back(std::string() + "gq_cfcov_54" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) *
           3)); ++sym1__) {
        param_names__.emplace_back(std::string() + "gq_cfcov_33" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) *
           3)); ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          param_names__.emplace_back(std::string() + "gq_cfcov_33_ar" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "indices" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            param_names__.emplace_back(std::string() + "indexing_mat" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            param_names__.emplace_back(std::string() + "idx_res1" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            param_names__.emplace_back(std::string() + "idx_res2" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            param_names__.emplace_back(std::string() + "idx_res3" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            param_names__.emplace_back(std::string() + "idx_res11" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            param_names__.emplace_back(std::string() + "idx_res21" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            param_names__.emplace_back(std::string() + "idx_res31" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          param_names__.emplace_back(std::string() + "idx_res4" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          param_names__.emplace_back(std::string() + "idx_res5" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"p_real\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"p_upper\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"p_lower\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"offset_multiplier\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"no_offset_multiplier\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"offset_no_multiplier\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_real_1d_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_real_3d_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"parameters\"},{\"name\":\"p_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_1d_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"p_3d_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"parameters\"},{\"name\":\"p_row_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_1d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"p_3d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"parameters\"},{\"name\":\"p_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(4) + "},\"block\":\"parameters\"},{\"name\":\"p_ar_mat\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(3) + "}}},\"block\":\"parameters\"},{\"name\":\"p_simplex\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_1d_simplex\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"p_3d_simplex\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"parameters\"},{\"name\":\"p_cfcov_54\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(4) + "},\"block\":\"parameters\"},{\"name\":\"p_cfcov_33\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(3) + "},\"block\":\"parameters\"},{\"name\":\"p_cfcov_33_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(3) + "}},\"block\":\"parameters\"},{\"name\":\"x_p\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"y_p\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_1d_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_real_3d_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_1d_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3d_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_row_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_1d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(4) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_ar_mat\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(3) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_simplex\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_1d_simplex\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3d_simplex\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_cfcov_54\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(4) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_cfcov_33\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(3) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_cfcov_33_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(3) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"theta_p\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_real\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"gq_r1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"gq_r2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"gq_real_1d_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"gq_real_3d_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"gq_1d_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"generated_quantities\"},{\"name\":\"gq_3d_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_row_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"gq_1d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"generated_quantities\"},{\"name\":\"gq_3d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_ar_mat\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(3) + "}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_simplex\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"gq_1d_simplex\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"generated_quantities\"},{\"name\":\"gq_3d_simplex\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_cfcov_54\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(4) + "},\"block\":\"generated_quantities\"},{\"name\":\"gq_cfcov_33\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(3) + "},\"block\":\"generated_quantities\"},{\"name\":\"gq_cfcov_33_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(3) + "}},\"block\":\"generated_quantities\"},{\"name\":\"indices\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"indexing_mat\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(4) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(4) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(4) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(3) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res11\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(4) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res21\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(4) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res31\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(3) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res4\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(4) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res5\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"p_real\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"p_upper\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"p_lower\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"offset_multiplier\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"no_offset_multiplier\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"offset_no_multiplier\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_real_1d_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_real_3d_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"parameters\"},{\"name\":\"p_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_1d_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"p_3d_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"parameters\"},{\"name\":\"p_row_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_1d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"p_3d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"parameters\"},{\"name\":\"p_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(4) + "},\"block\":\"parameters\"},{\"name\":\"p_ar_mat\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(3) + "}}},\"block\":\"parameters\"},{\"name\":\"p_simplex\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((N -1)) + "},\"block\":\"parameters\"},{\"name\":\"p_1d_simplex\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string((N -1)) + "}},\"block\":\"parameters\"},{\"name\":\"p_3d_simplex\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string((N -1)) + "}}}},\"block\":\"parameters\"},{\"name\":\"p_cfcov_54\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) *4))) + "},\"block\":\"parameters\"},{\"name\":\"p_cfcov_33\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) *3))) + "},\"block\":\"parameters\"},{\"name\":\"p_cfcov_33_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) *3))) + "}},\"block\":\"parameters\"},{\"name\":\"x_p\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"y_p\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_1d_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_real_3d_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_1d_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3d_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_row_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_1d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(4) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_ar_mat\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(3) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_simplex\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((N -1)) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_1d_simplex\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string((N -1)) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3d_simplex\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string((N -1)) + "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_cfcov_54\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) *4))) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_cfcov_33\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) *3))) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_cfcov_33_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) *3))) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"theta_p\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_real\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"gq_r1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"gq_r2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"gq_real_1d_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"gq_real_3d_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"gq_1d_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"generated_quantities\"},{\"name\":\"gq_3d_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_row_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"gq_1d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"generated_quantities\"},{\"name\":\"gq_3d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_ar_mat\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(3) + "}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_simplex\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((N -1)) + "},\"block\":\"generated_quantities\"},{\"name\":\"gq_1d_simplex\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string((N -1)) + "}},\"block\":\"generated_quantities\"},{\"name\":\"gq_3d_simplex\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string((N -1)) + "}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_cfcov_54\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) *4))) + "},\"block\":\"generated_quantities\"},{\"name\":\"gq_cfcov_33\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) *3))) + "},\"block\":\"generated_quantities\"},{\"name\":\"gq_cfcov_33_ar\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) *3))) + "}},\"block\":\"generated_quantities\"},{\"name\":\"indices\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"indexing_mat\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(4) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(4) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(4) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(3) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res11\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(4) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res21\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(4) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res31\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(3) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res4\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(4) + "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res5\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((((((((((((((((((1 + 1) + 1) + 5) + 5)
      + 5) + N) + (N * (M * K))) + N) + (N * N)) + (N * (M * (K * N)))) + N)
      + (N * N)) + (N * (M * (K * N)))) + (5 * 4)) + (4 * (5 * (2 * 3)))) +
      N) + (N * N)) + (N * (M * (K * N)))) + (5 * 4)) + (3 * 3)) + (K * (3 *
      3))) + 2) + 2);
    const size_t num_transformed = emit_transformed_parameters *
      ((((((((((((((((((N + (N * (M * K))) + N) + (N * N)) + (N * (M * (K *
      N)))) + N) + (N * N)) + (N * (M * (K * N)))) + (5 * 4)) + (4 * (5 * (2
      * 3)))) + N) + (N * N)) + (N * (M * (K * N)))) + (5 * 4)) + (3 * 3)) +
      (K * (3 * 3))) + 2) + 1));
    const size_t num_gen_quantities = emit_generated_quantities *
      (((((((((((((((((((((((((((1 + 1) + N) + (N * (M * K))) + N) + (N * N))
      + (N * (M * (K * N)))) + N) + (N * N)) + (N * (M * (K * N)))) + (4 * (5
      * (2 * 3)))) + N) + (N * N)) + (N * (M * (K * N)))) + (5 * 4)) + (3 *
      3)) + (K * (3 * 3))) + 3) + (5 * (3 * 4))) + (3 * (3 * 4))) + (5 * (3 *
      4))) + (3 * (3 * 3))) + (3 * (3 * 4))) + (5 * (3 * 4))) + (3 * (3 *
      3))) + (3 * 4)) + (2 * 2)));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((((((((((((((((((1 + 1) + 1) + 5) + 5)
      + 5) + N) + (N * (M * K))) + N) + (N * N)) + (N * (M * (K * N)))) + N)
      + (N * N)) + (N * (M * (K * N)))) + (5 * 4)) + (4 * (5 * (2 * 3)))) +
      N) + (N * N)) + (N * (M * (K * N)))) + (5 * 4)) + (3 * 3)) + (K * (3 *
      3))) + 2) + 2);
    const size_t num_transformed = emit_transformed_parameters *
      ((((((((((((((((((N + (N * (M * K))) + N) + (N * N)) + (N * (M * (K *
      N)))) + N) + (N * N)) + (N * (M * (K * N)))) + (5 * 4)) + (4 * (5 * (2
      * 3)))) + N) + (N * N)) + (N * (M * (K * N)))) + (5 * 4)) + (3 * 3)) +
      (K * (3 * 3))) + 2) + 1));
    const size_t num_gen_quantities = emit_generated_quantities *
      (((((((((((((((((((((((((((1 + 1) + N) + (N * (M * K))) + N) + (N * N))
      + (N * (M * (K * N)))) + N) + (N * N)) + (N * (M * (K * N)))) + (4 * (5
      * (2 * 3)))) + N) + (N * N)) + (N * (M * (K * N)))) + (5 * 4)) + (3 *
      3)) + (K * (3 * 3))) + 3) + (5 * (3 * 4))) + (3 * (3 * 4))) + (5 * (3 *
      4))) + (3 * (3 * 3))) + (3 * (3 * 4))) + (5 * (3 * 4))) + (3 * (3 *
      3))) + (3 * 4)) + (2 * 2)));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = mother_model_namespace::mother_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return mother_model_namespace::profiles__;
}
#endif
STAN_REGISTER_MAP_RECT(1, mother_model_namespace::binomialf_functor__)
STAN_REGISTER_MAP_RECT(2, mother_model_namespace::binomialf_functor__)
  $ ../../../../../install/default/bin/stanc --print-cpp motherHOF.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace motherHOF_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 158> locations_array__ =
  {" (found before start of program)",
  " (in 'motherHOF.stan', line 48, column 2 to column 21)",
  " (in 'motherHOF.stan', line 49, column 2 to column 24)",
  " (in 'motherHOF.stan', line 50, column 2 to column 20)",
  " (in 'motherHOF.stan', line 51, column 2 to column 18)",
  " (in 'motherHOF.stan', line 52, column 2 to column 28)",
  " (in 'motherHOF.stan', line 53, column 2 to column 34)",
  " (in 'motherHOF.stan', line 54, column 2 to column 11)",
  " (in 'motherHOF.stan', line 57, column 2 to column 18)",
  " (in 'motherHOF.stan', line 58, column 2 to column 37)",
  " (in 'motherHOF.stan', line 59, column 2 to column 33)",
  " (in 'motherHOF.stan', line 60, column 2 to line 61, column 41)",
  " (in 'motherHOF.stan', line 62, column 2 to line 63, column 41)",
  " (in 'motherHOF.stan', line 64, column 2 to line 65, column 41)",
  " (in 'motherHOF.stan', line 66, column 2 to column 23)",
  " (in 'motherHOF.stan', line 67, column 2 to column 16)",
  " (in 'motherHOF.stan', line 68, column 2 to column 16)",
  " (in 'motherHOF.stan', line 69, column 2 to column 16)",
  " (in 'motherHOF.stan', line 157, column 2 to column 25)",
  " (in 'motherHOF.stan', line 191, column 2 to column 61)",
  " (in 'motherHOF.stan', line 196, column 2 to column 67)",
  " (in 'motherHOF.stan', line 201, column 2 to column 34)",
  " (in 'motherHOF.stan', line 202, column 2 to column 38)",
  " (in 'motherHOF.stan', line 203, column 2 to line 206, column 42)",
  " (in 'motherHOF.stan', line 208, column 2 to line 209, column 41)",
  " (in 'motherHOF.stan', line 211, column 2 to column 22)",
  " (in 'motherHOF.stan', line 70, column 2 to column 70)",
  " (in 'motherHOF.stan', line 71, column 2 to line 72, column 40)",
  " (in 'motherHOF.stan', line 73, column 2 to line 74, column 40)",
  " (in 'motherHOF.stan', line 75, column 2 to column 72)",
  " (in 'motherHOF.stan', line 77, column 2 to line 78, column 40)",
  " (in 'motherHOF.stan', line 79, column 2 to column 72)",
  " (in 'motherHOF.stan', line 80, column 2 to line 81, column 40)",
  " (in 'motherHOF.stan', line 83, column 2 to column 77)",
  " (in 'motherHOF.stan', line 84, column 2 to line 85, column 53)",
  " (in 'motherHOF.stan', line 86, column 2 to line 87, column 53)",
  " (in 'motherHOF.stan', line 88, column 2 to line 89, column 44)",
  " (in 'motherHOF.stan', line 91, column 2 to line 92, column 60)",
  " (in 'motherHOF.stan', line 93, column 2 to line 94, column 44)",
  " (in 'motherHOF.stan', line 95, column 2 to line 96, column 60)",
  " (in 'motherHOF.stan', line 158, column 2 to column 68)",
  " (in 'motherHOF.stan', line 159, column 2 to column 68)",
  " (in 'motherHOF.stan', line 160, column 2 to column 68)",
  " (in 'motherHOF.stan', line 161, column 2 to column 68)",
  " (in 'motherHOF.stan', line 163, column 2 to line 164, column 42)",
  " (in 'motherHOF.stan', line 165, column 2 to line 166, column 42)",
  " (in 'motherHOF.stan', line 167, column 2 to line 168, column 42)",
  " (in 'motherHOF.stan', line 169, column 2 to line 170, column 42)",
  " (in 'motherHOF.stan', line 172, column 2 to column 66)",
  " (in 'motherHOF.stan', line 173, column 2 to column 66)",
  " (in 'motherHOF.stan', line 174, column 2 to column 66)",
  " (in 'motherHOF.stan', line 175, column 2 to column 66)",
  " (in 'motherHOF.stan', line 177, column 2 to line 178, column 40)",
  " (in 'motherHOF.stan', line 179, column 2 to line 180, column 40)",
  " (in 'motherHOF.stan', line 181, column 2 to line 182, column 40)",
  " (in 'motherHOF.stan', line 183, column 2 to line 184, column 40)",
  " (in 'motherHOF.stan', line 186, column 2 to column 67)",
  " (in 'motherHOF.stan', line 187, column 2 to column 67)",
  " (in 'motherHOF.stan', line 188, column 2 to column 67)",
  " (in 'motherHOF.stan', line 189, column 2 to column 67)",
  " (in 'motherHOF.stan', line 192, column 2 to column 58)",
  " (in 'motherHOF.stan', line 193, column 2 to column 58)",
  " (in 'motherHOF.stan', line 194, column 2 to column 60)",
  " (in 'motherHOF.stan', line 197, column 2 to column 64)",
  " (in 'motherHOF.stan', line 198, column 2 to column 64)",
  " (in 'motherHOF.stan', line 199, column 2 to column 66)",
  " (in 'motherHOF.stan', line 212, column 2 to column 69)",
  " (in 'motherHOF.stan', line 213, column 2 to line 214, column 39)",
  " (in 'motherHOF.stan', line 215, column 2 to line 216, column 39)",
  " (in 'motherHOF.stan', line 217, column 2 to column 71)",
  " (in 'motherHOF.stan', line 219, column 2 to line 220, column 39)",
  " (in 'motherHOF.stan', line 221, column 2 to column 71)",
  " (in 'motherHOF.stan', line 222, column 2 to line 223, column 39)",
  " (in 'motherHOF.stan', line 225, column 2 to column 76)",
  " (in 'motherHOF.stan', line 226, column 2 to line 227, column 52)",
  " (in 'motherHOF.stan', line 228, column 2 to line 229, column 52)",
  " (in 'motherHOF.stan', line 230, column 2 to column 78)",
  " (in 'motherHOF.stan', line 232, column 2 to line 233, column 52)",
  " (in 'motherHOF.stan', line 234, column 2 to column 78)",
  " (in 'motherHOF.stan', line 235, column 2 to line 236, column 52)",
  " (in 'motherHOF.stan', line 99, column 8 to column 9)",
  " (in 'motherHOF.stan', line 99, column 2 to column 25)",
  " (in 'motherHOF.stan', line 100, column 2 to column 68)",
  " (in 'motherHOF.stan', line 101, column 2 to column 68)",
  " (in 'motherHOF.stan', line 102, column 2 to column 68)",
  " (in 'motherHOF.stan', line 104, column 2 to line 105, column 42)",
  " (in 'motherHOF.stan', line 106, column 2 to line 107, column 42)",
  " (in 'motherHOF.stan', line 108, column 2 to line 109, column 42)",
  " (in 'motherHOF.stan', line 111, column 2 to column 66)",
  " (in 'motherHOF.stan', line 112, column 2 to column 66)",
  " (in 'motherHOF.stan', line 113, column 2 to column 66)",
  " (in 'motherHOF.stan', line 114, column 2 to column 66)",
  " (in 'motherHOF.stan', line 116, column 2 to line 117, column 40)",
  " (in 'motherHOF.stan', line 118, column 2 to line 119, column 40)",
  " (in 'motherHOF.stan', line 120, column 2 to line 121, column 40)",
  " (in 'motherHOF.stan', line 122, column 2 to line 123, column 40)",
  " (in 'motherHOF.stan', line 125, column 2 to column 67)",
  " (in 'motherHOF.stan', line 126, column 2 to column 67)",
  " (in 'motherHOF.stan', line 127, column 2 to column 67)",
  " (in 'motherHOF.stan', line 128, column 2 to column 67)",
  " (in 'motherHOF.stan', line 130, column 2 to column 61)",
  " (in 'motherHOF.stan', line 131, column 2 to column 58)",
  " (in 'motherHOF.stan', line 132, column 2 to column 58)",
  " (in 'motherHOF.stan', line 133, column 2 to column 60)",
  " (in 'motherHOF.stan', line 134, column 2 to column 56)",
  " (in 'motherHOF.stan', line 135, column 2 to column 58)",
  " (in 'motherHOF.stan', line 136, column 2 to column 58)",
  " (in 'motherHOF.stan', line 137, column 2 to column 60)",
  " (in 'motherHOF.stan', line 138, column 2 to column 62)",
  " (in 'motherHOF.stan', line 139, column 2 to column 62)",
  " (in 'motherHOF.stan', line 140, column 2 to column 64)",
  " (in 'motherHOF.stan', line 142, column 2 to column 67)",
  " (in 'motherHOF.stan', line 143, column 2 to column 64)",
  " (in 'motherHOF.stan', line 144, column 2 to column 64)",
  " (in 'motherHOF.stan', line 145, column 2 to column 66)",
  " (in 'motherHOF.stan', line 146, column 2 to column 62)",
  " (in 'motherHOF.stan', line 147, column 2 to column 64)",
  " (in 'motherHOF.stan', line 148, column 2 to column 64)",
  " (in 'motherHOF.stan', line 149, column 2 to column 66)",
  " (in 'motherHOF.stan', line 150, column 2 to column 68)",
  " (in 'motherHOF.stan', line 151, column 2 to column 68)",
  " (in 'motherHOF.stan', line 152, column 2 to column 70)",
  " (in 'motherHOF.stan', line 154, column 2 to column 36)",
  " (in 'motherHOF.stan', line 33, column 2 to column 17)",
  " (in 'motherHOF.stan', line 34, column 2 to column 21)",
  " (in 'motherHOF.stan', line 35, column 2 to column 10)",
  " (in 'motherHOF.stan', line 36, column 8 to column 9)",
  " (in 'motherHOF.stan', line 36, column 2 to column 19)",
  " (in 'motherHOF.stan', line 37, column 2 to column 24)",
  " (in 'motherHOF.stan', line 38, column 2 to column 18)",
  " (in 'motherHOF.stan', line 39, column 2 to column 21)",
  " (in 'motherHOF.stan', line 40, column 2 to column 22)",
  " (in 'motherHOF.stan', line 41, column 2 to column 21)",
  " (in 'motherHOF.stan', line 42, column 2 to column 28)",
  " (in 'motherHOF.stan', line 43, column 2 to column 34)",
  " (in 'motherHOF.stan', line 44, column 2 to column 26)",
  " (in 'motherHOF.stan', line 45, column 2 to column 25)",
  " (in 'motherHOF.stan', line 49, column 8 to column 9)",
  " (in 'motherHOF.stan', line 50, column 8 to column 9)",
  " (in 'motherHOF.stan', line 157, column 8 to column 9)",
  " (in 'motherHOF.stan', line 4, column 4 to column 23)",
  " (in 'motherHOF.stan', line 5, column 4 to column 19)",
  " (in 'motherHOF.stan', line 6, column 4 to column 38)",
  " (in 'motherHOF.stan', line 7, column 4 to column 16)",
  " (in 'motherHOF.stan', line 3, column 54 to line 8, column 3)",
  " (in 'motherHOF.stan', line 11, column 4 to column 15)",
  " (in 'motherHOF.stan', line 10, column 34 to line 12, column 3)",
  " (in 'motherHOF.stan', line 15, column 4 to column 22)",
  " (in 'motherHOF.stan', line 14, column 33 to line 16, column 3)",
  " (in 'motherHOF.stan', line 19, column 4 to column 22)",
  " (in 'motherHOF.stan', line 18, column 33 to line 20, column 3)",
  " (in 'motherHOF.stan', line 22, column 4 to column 17)",
  " (in 'motherHOF.stan', line 21, column 28 to line 23, column 3)",
  " (in 'motherHOF.stan', line 26, column 4 to column 18)",
  " (in 'motherHOF.stan', line 27, column 4 to column 25)",
  " (in 'motherHOF.stan', line 28, column 4 to column 25)",
  " (in 'motherHOF.stan', line 29, column 4 to column 15)",
  " (in 'motherHOF.stan', line 25, column 45 to line 30, column 3)"};
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_std_vector<T1__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T1__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T1__>>>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>,
                              stan::is_std_vector<T4__>,
                              std::is_integral<stan::value_type_t<T4__>>>* = nullptr>
std::vector<
  stan::promote_args_t<T0__, stan::base_type_t<T1__>,
    stan::base_type_t<T2__>, stan::base_type_t<T3__>>>
sho(const T0__& t, const T1__& y, const T2__& theta, const T3__& x,
    const T4__& x_int, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>,
                              stan::is_std_vector<T4__>,
                              std::is_integral<stan::value_type_t<T4__>>>* = nullptr>
stan::promote_args_t<T0__, T1__, stan::base_type_t<T2__>,
  stan::base_type_t<T3__>>
integrand(const T0__& x, const T1__& xc, const T2__& theta, const T3__& x_r,
          const T4__& x_i, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              std::is_integral<stan::value_type_t<T3__>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>, stan::base_type_t<T2__>>,-1,1>
foo(const T0__& shared_params_arg__, const T1__& job_params_arg__,
    const T2__& data_r, const T3__& data_i, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              std::is_integral<stan::value_type_t<T3__>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>, stan::base_type_t<T2__>>,-1,1>
goo(const T0__& shared_params_arg__, const T1__& job_params_arg__,
    const T2__& data_r, const T3__& data_i, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__>
map_rectfake(const T0__& x, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              std::is_integral<stan::value_type_t<T3__>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>, stan::base_type_t<T2__>>,-1,1>
algebra_system(const T0__& x_arg__, const T1__& y_arg__, const T2__& dat,
               const T3__& dat_int, std::ostream* pstream__);
struct goo_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_col_vector<T0__>,
                                stan::is_vt_not_complex<T0__>,
                                stan::is_col_vector<T1__>,
                                stan::is_vt_not_complex<T1__>,
                                stan::is_std_vector<T2__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T2__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T2__>>>,
                                stan::is_std_vector<T3__>,
                                std::is_integral<stan::value_type_t<T3__>>>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                  stan::base_type_t<T1__>, stan::base_type_t<T2__>>,-1,1>
  operator()(const T0__& shared_params, const T1__& job_params, const T2__&
             data_r, const T3__& data_i, std::ostream* pstream__) const {
    return goo(shared_params, job_params, data_r, data_i, pstream__);
  }
};
struct foo_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_col_vector<T0__>,
                                stan::is_vt_not_complex<T0__>,
                                stan::is_col_vector<T1__>,
                                stan::is_vt_not_complex<T1__>,
                                stan::is_std_vector<T2__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T2__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T2__>>>,
                                stan::is_std_vector<T3__>,
                                std::is_integral<stan::value_type_t<T3__>>>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                  stan::base_type_t<T1__>, stan::base_type_t<T2__>>,-1,1>
  operator()(const T0__& shared_params, const T1__& job_params, const T2__&
             data_r, const T3__& data_i, std::ostream* pstream__) const {
    return foo(shared_params, job_params, data_r, data_i, pstream__);
  }
};
struct integrand_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            typename T4__,
            stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                        std::is_floating_point<T0__>>,
                                stan::math::disjunction<stan::is_autodiff<T1__>,
                                                        std::is_floating_point<T1__>>,
                                stan::is_std_vector<T2__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T2__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T2__>>>,
                                stan::is_std_vector<T3__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T3__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T3__>>>,
                                stan::is_std_vector<T4__>,
                                std::is_integral<stan::value_type_t<T4__>>>* = nullptr>
  stan::promote_args_t<T0__, T1__, stan::base_type_t<T2__>,
    stan::base_type_t<T3__>>
  operator()(const T0__& x, const T1__& xc, const T2__& theta, const T3__&
             x_r, const T4__& x_i, std::ostream* pstream__) const {
    return integrand(x, xc, theta, x_r, x_i, pstream__);
  }
};
struct algebra_system_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_col_vector<T0__>,
                                stan::is_vt_not_complex<T0__>,
                                stan::is_col_vector<T1__>,
                                stan::is_vt_not_complex<T1__>,
                                stan::is_std_vector<T2__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T2__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T2__>>>,
                                stan::is_std_vector<T3__>,
                                std::is_integral<stan::value_type_t<T3__>>>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                  stan::base_type_t<T1__>, stan::base_type_t<T2__>>,-1,1>
  operator()(const T0__& x, const T1__& y, const T2__& dat, const T3__&
             dat_int, std::ostream* pstream__) const {
    return algebra_system(x, y, dat, dat_int, pstream__);
  }
};
struct sho_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            typename T4__,
            stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                        std::is_floating_point<T0__>>,
                                stan::is_std_vector<T1__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T1__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T1__>>>,
                                stan::is_std_vector<T2__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T2__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T2__>>>,
                                stan::is_std_vector<T3__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T3__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T3__>>>,
                                stan::is_std_vector<T4__>,
                                std::is_integral<stan::value_type_t<T4__>>>* = nullptr>
  std::vector<
    stan::promote_args_t<T0__, stan::base_type_t<T1__>,
      stan::base_type_t<T2__>, stan::base_type_t<T3__>>>
  operator()(const T0__& t, const T1__& y, const T2__& theta, const T3__& x,
             const T4__& x_int, std::ostream* pstream__) const {
    return sho(t, y, theta, x, x_int, pstream__);
  }
};
// array[] real sho(real, array[] real, array[] real, array[] real, array[] int)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_std_vector<T1__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T1__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T1__>>>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>,
                              stan::is_std_vector<T4__>,
                              std::is_integral<stan::value_type_t<T4__>>>*>
std::vector<
  stan::promote_args_t<T0__, stan::base_type_t<T1__>,
    stan::base_type_t<T2__>, stan::base_type_t<T3__>>>
sho(const T0__& t, const T1__& y, const T2__& theta, const T3__& x,
    const T4__& x_int, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
                             stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    std::vector<local_scalar_t__> dydt =
      std::vector<local_scalar_t__>(2, DUMMY_VAR__);
    current_statement__ = 141;
    stan::model::assign(dydt,
      stan::model::rvalue(y, "y", stan::model::index_uni(2)),
      "assigning variable dydt", stan::model::index_uni(1));
    current_statement__ = 142;
    stan::model::assign(dydt,
      (-(stan::model::rvalue(y, "y", stan::model::index_uni(1))) -
      (stan::model::rvalue(theta, "theta", stan::model::index_uni(1)) *
      stan::model::rvalue(y, "y", stan::model::index_uni(2)))),
      "assigning variable dydt", stan::model::index_uni(2));
    current_statement__ = 143;
    return dydt;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real integrand(real, real, array[] real, array[] real, array[] int)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>,
                              stan::is_std_vector<T4__>,
                              std::is_integral<stan::value_type_t<T4__>>>*>
stan::promote_args_t<T0__, T1__, stan::base_type_t<T2__>,
  stan::base_type_t<T3__>>
integrand(const T0__& x, const T1__& xc, const T2__& theta, const T3__& x_r,
          const T4__& x_i, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__,
                             stan::base_type_t<T2__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 145;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector foo(vector, vector, array[] real, array[] int)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              std::is_integral<stan::value_type_t<T3__>>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>, stan::base_type_t<T2__>>,-1,1>
foo(const T0__& shared_params_arg__, const T1__& job_params_arg__,
    const T2__& data_r, const T3__& data_i, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& shared_params = stan::math::to_ref(shared_params_arg__);
  const auto& job_params = stan::math::to_ref(job_params_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 147;
    return stan::math::promote_scalar<local_scalar_t__>(
             (Eigen::Matrix<double,-1,1>(3) << 1, 2, 3).finished());
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector goo(vector, vector, array[] real, array[] int)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              std::is_integral<stan::value_type_t<T3__>>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>, stan::base_type_t<T2__>>,-1,1>
goo(const T0__& shared_params_arg__, const T1__& job_params_arg__,
    const T2__& data_r, const T3__& data_i, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& shared_params = stan::math::to_ref(shared_params_arg__);
  const auto& job_params = stan::math::to_ref(job_params_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 149;
    return stan::math::promote_scalar<local_scalar_t__>(
             (Eigen::Matrix<double,-1,1>(3) << 4, 5, 6).finished());
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real map_rectfake(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__>
map_rectfake(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 151;
    return (2 * x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector algebra_system(vector, vector, array[] real, array[] int)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              std::is_integral<stan::value_type_t<T3__>>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>, stan::base_type_t<T2__>>,-1,1>
algebra_system(const T0__& x_arg__, const T1__& y_arg__, const T2__& dat,
               const T3__& dat_int, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& x = stan::math::to_ref(x_arg__);
  const auto& y = stan::math::to_ref(y_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    Eigen::Matrix<local_scalar_t__,-1,1> f_x =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
    current_statement__ = 154;
    stan::model::assign(f_x,
      (stan::model::rvalue(x, "x", stan::model::index_uni(1)) -
      stan::model::rvalue(y, "y", stan::model::index_uni(1))),
      "assigning variable f_x", stan::model::index_uni(1));
    current_statement__ = 155;
    stan::model::assign(f_x,
      (stan::model::rvalue(x, "x", stan::model::index_uni(2)) -
      stan::model::rvalue(y, "y", stan::model::index_uni(2))),
      "assigning variable f_x", stan::model::index_uni(2));
    current_statement__ = 156;
    return f_x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class motherHOF_model final : public model_base_crtp<motherHOF_model> {
 private:
  int T;
  std::vector<double> y0_d;
  double t0;
  std::vector<double> ts;
  std::vector<double> theta_d;
  std::vector<double> x;
  std::vector<int> x_int;
  std::vector<double> x_d_r;
  std::vector<int> x_d_i;
  Eigen::Matrix<double,-1,1> shared_params_d_data__;
  std::vector<Eigen::Matrix<double,-1,1>> job_params_d;
  std::vector<std::vector<double>> data_r;
  std::vector<std::vector<int>> data_i;
  Eigen::Map<Eigen::Matrix<double,-1,1>> shared_params_d{nullptr, 0};
 public:
  ~motherHOF_model() {}
  motherHOF_model(stan::io::var_context& context__, unsigned int
                  random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "motherHOF_model_namespace::motherHOF_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 123;
      context__.validate_dims("data initialization", "T", "int",
        std::vector<size_t>{});
      T = std::numeric_limits<int>::min();
      current_statement__ = 123;
      T = context__.vals_i("T")[(1 - 1)];
      current_statement__ = 123;
      stan::math::check_greater_or_equal(function__, "T", T, 1);
      current_statement__ = 124;
      context__.validate_dims("data initialization", "y0_d", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      y0_d = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 124;
      y0_d = context__.vals_r("y0_d");
      current_statement__ = 125;
      context__.validate_dims("data initialization", "t0", "double",
        std::vector<size_t>{});
      t0 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 125;
      t0 = context__.vals_r("t0")[(1 - 1)];
      current_statement__ = 126;
      stan::math::validate_non_negative_index("ts", "T", T);
      current_statement__ = 127;
      context__.validate_dims("data initialization", "ts", "double",
        std::vector<size_t>{static_cast<size_t>(T)});
      ts = std::vector<double>(T, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 127;
      ts = context__.vals_r("ts");
      current_statement__ = 128;
      context__.validate_dims("data initialization", "theta_d", "double",
        std::vector<size_t>{static_cast<size_t>(1)});
      theta_d = std::vector<double>(1,
                  std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 128;
      theta_d = context__.vals_r("theta_d");
      current_statement__ = 129;
      context__.validate_dims("data initialization", "x", "double",
        std::vector<size_t>{static_cast<size_t>(0)});
      x = std::vector<double>(0, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 129;
      x = context__.vals_r("x");
      current_statement__ = 130;
      context__.validate_dims("data initialization", "x_int", "int",
        std::vector<size_t>{static_cast<size_t>(0)});
      x_int = std::vector<int>(0, std::numeric_limits<int>::min());
      current_statement__ = 130;
      x_int = context__.vals_i("x_int");
      current_statement__ = 131;
      context__.validate_dims("data initialization", "x_d_r", "double",
        std::vector<size_t>{static_cast<size_t>(0)});
      x_d_r = std::vector<double>(0,
                std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 131;
      x_d_r = context__.vals_r("x_d_r");
      current_statement__ = 132;
      context__.validate_dims("data initialization", "x_d_i", "int",
        std::vector<size_t>{static_cast<size_t>(0)});
      x_d_i = std::vector<int>(0, std::numeric_limits<int>::min());
      current_statement__ = 132;
      x_d_i = context__.vals_i("x_d_i");
      current_statement__ = 133;
      context__.validate_dims("data initialization", "shared_params_d",
        "double", std::vector<size_t>{static_cast<size_t>(3)});
      shared_params_d_data__ = Eigen::Matrix<double,-1,1>::Constant(3,
                                 std::numeric_limits<double>::quiet_NaN());
      new (&shared_params_d)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(shared_params_d_data__.data(),
        3);
      {
        std::vector<local_scalar_t__> shared_params_d_flat__;
        current_statement__ = 133;
        shared_params_d_flat__ = context__.vals_r("shared_params_d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          stan::model::assign(shared_params_d, shared_params_d_flat__[(pos__
            - 1)], "assigning variable shared_params_d",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 134;
      context__.validate_dims("data initialization", "job_params_d",
        "double",
        std::vector<size_t>{static_cast<size_t>(3), static_cast<size_t>(3)});
      job_params_d = std::vector<Eigen::Matrix<double,-1,1>>(3,
                       Eigen::Matrix<double,-1,1>::Constant(3,
                         std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> job_params_d_flat__;
        current_statement__ = 134;
        job_params_d_flat__ = context__.vals_r("job_params_d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            stan::model::assign(job_params_d, job_params_d_flat__[(pos__ -
              1)], "assigning variable job_params_d",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 135;
      context__.validate_dims("data initialization", "data_r", "double",
        std::vector<size_t>{static_cast<size_t>(3), static_cast<size_t>(3)});
      data_r = std::vector<std::vector<double>>(3,
                 std::vector<double>(3,
                   std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> data_r_flat__;
        current_statement__ = 135;
        data_r_flat__ = context__.vals_r("data_r");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            stan::model::assign(data_r, data_r_flat__[(pos__ - 1)],
              "assigning variable data_r", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 136;
      context__.validate_dims("data initialization", "data_i", "int",
        std::vector<size_t>{static_cast<size_t>(3), static_cast<size_t>(3)});
      data_i = std::vector<std::vector<int>>(3,
                 std::vector<int>(3, std::numeric_limits<int>::min()));
      {
        std::vector<int> data_i_flat__;
        current_statement__ = 136;
        data_i_flat__ = context__.vals_i("data_i");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            stan::model::assign(data_i, data_i_flat__[(pos__ - 1)],
              "assigning variable data_i", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 137;
      stan::math::validate_non_negative_index("theta_p", "1", 1);
      current_statement__ = 138;
      stan::math::validate_non_negative_index("x_p", "1", 1);
      current_statement__ = 139;
      stan::math::validate_non_negative_index("y_hat", "T", T);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 2 + 1 + 1 + 2 + 3 + (3 * 3) + 1;
  }
  inline std::string model_name() const final {
    return "motherHOF_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "motherHOF_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<local_scalar_t__> y0_p =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 1;
      y0_p = in__.template read<std::vector<local_scalar_t__>>(2);
      std::vector<local_scalar_t__> theta_p =
        std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      current_statement__ = 2;
      theta_p = in__.template read<std::vector<local_scalar_t__>>(1);
      std::vector<local_scalar_t__> x_p =
        std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      current_statement__ = 3;
      x_p = in__.template read<std::vector<local_scalar_t__>>(1);
      Eigen::Matrix<local_scalar_t__,-1,1> x_p_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 4;
      x_p_v = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      Eigen::Matrix<local_scalar_t__,-1,1> shared_params_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      current_statement__ = 5;
      shared_params_p = in__.template read<
                          Eigen::Matrix<local_scalar_t__,-1,1>>(3);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> job_params_p =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(3,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__));
      current_statement__ = 6;
      job_params_p = in__.template read<
                       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(3,
                       3);
      local_scalar_t__ x_r = DUMMY_VAR__;
      current_statement__ = 7;
      x_r = in__.template read<local_scalar_t__>();
      local_scalar_t__ abc1_p = DUMMY_VAR__;
      current_statement__ = 8;
      abc1_p = 3;
      local_scalar_t__ abc2_p = DUMMY_VAR__;
      current_statement__ = 9;
      abc2_p = map_rectfake(abc1_p, pstream__);
      local_scalar_t__ abc3_p = DUMMY_VAR__;
      current_statement__ = 10;
      abc3_p = map_rectfake(static_cast<double>(12), pstream__);
      Eigen::Matrix<local_scalar_t__,-1,1> y_hat_tp1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      current_statement__ = 11;
      stan::model::assign(y_hat_tp1,
        stan::math::map_rect<10, foo_functor__>(shared_params_p,
          job_params_d, data_r, data_i, pstream__),
        "assigning variable y_hat_tp1");
      Eigen::Matrix<local_scalar_t__,-1,1> y_hat_tp2 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      current_statement__ = 12;
      stan::model::assign(y_hat_tp2,
        stan::math::map_rect<11, foo_functor__>(shared_params_d,
          job_params_p, data_r, data_i, pstream__),
        "assigning variable y_hat_tp2");
      Eigen::Matrix<local_scalar_t__,-1,1> y_hat_tp3 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      current_statement__ = 13;
      stan::model::assign(y_hat_tp3,
        stan::math::map_rect<12, foo_functor__>(shared_params_p,
          job_params_d, data_r, data_i, pstream__),
        "assigning variable y_hat_tp3");
      Eigen::Matrix<local_scalar_t__,-1,1> theta_p_as =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> x_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> y_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> y_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 26;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_v, y_v,
          x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 27;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_v, y_v,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 28;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_v, y_p,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 29;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_v,
          x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 30;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_v,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 31;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_p,
          x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 32;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_p,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 33;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_v,
          y_v, x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 34;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_v,
          y_v, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 35;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_v,
          y_p, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 36;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_v, x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 37;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_v, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 38;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_p, x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 39;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_p, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      {
        current_statement__ = 80;
        stan::math::validate_non_negative_index("y_hat", "T", T);
        std::vector<std::vector<local_scalar_t__>> y_hat =
          std::vector<std::vector<local_scalar_t__>>(T,
            std::vector<local_scalar_t__>(2, DUMMY_VAR__));
        current_statement__ = 82;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_adams(sho_functor__(), y0_d, t0, ts,
            theta_p, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 83;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_adams(sho_functor__(), y0_p, t0, ts,
            theta_d, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 84;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_adams(sho_functor__(), y0_p, t0, ts,
            theta_p, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 85;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_adams(sho_functor__(), y0_d, t0, ts,
            theta_p, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 86;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_adams(sho_functor__(), y0_p, t0, ts,
            theta_d, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 87;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_adams(sho_functor__(), y0_p, t0, ts,
            theta_p, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 88;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_d, t0, ts,
            theta_d, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 89;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_d, t0, ts,
            theta_p, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 90;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_p, t0, ts,
            theta_d, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 91;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_p, t0, ts,
            theta_p, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 92;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_d, t0, ts,
            theta_d, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 93;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_d, t0, ts,
            theta_p, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 94;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_p, t0, ts,
            theta_d, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 95;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_p, t0, ts,
            theta_p, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 96;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_rk45(sho_functor__(), y0_d, t0, ts,
            theta_d, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 97;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_rk45(sho_functor__(), y0_d, t0, ts,
            theta_p, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 98;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_rk45(sho_functor__(), y0_p, t0, ts,
            theta_d, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 99;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_rk45(sho_functor__(), y0_p, t0, ts,
            theta_p, x, x_int, pstream__), "assigning variable y_hat");
        local_scalar_t__ y_1d = DUMMY_VAR__;
        current_statement__ = 100;
        y_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), static_cast<double>(1), x, x_d_r,
                 x_d_i, pstream__);
        current_statement__ = 101;
        y_1d = stan::math::integrate_1d(integrand_functor__(), 0.0,
                 static_cast<double>(1), x, x_d_r, x_d_i, pstream__);
        current_statement__ = 102;
        y_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), 1.0, x, x_d_r, x_d_i, pstream__);
        current_statement__ = 103;
        y_1d = stan::math::integrate_1d(integrand_functor__(), 0.0, 1.0, x,
                 x_d_r, x_d_i, pstream__);
        current_statement__ = 104;
        y_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), static_cast<double>(1), x, x_d_r,
                 x_d_i, pstream__);
        current_statement__ = 105;
        y_1d = stan::math::integrate_1d(integrand_functor__(), x_r,
                 static_cast<double>(1), x, x_d_r, x_d_i, pstream__);
        current_statement__ = 106;
        y_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), x_r, x, x_d_r, x_d_i, pstream__);
        current_statement__ = 107;
        y_1d = stan::math::integrate_1d(integrand_functor__(), x_r, x_r, x,
                 x_d_r, x_d_i, pstream__);
        current_statement__ = 108;
        y_1d = stan::math::integrate_1d(integrand_functor__(), x_r,
                 static_cast<double>(1), x_d_r, x_d_r, x_d_i, pstream__);
        current_statement__ = 109;
        y_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), x_r, x_d_r, x_d_r, x_d_i, pstream__);
        current_statement__ = 110;
        y_1d = stan::math::integrate_1d(integrand_functor__(), x_r, x_r,
                 x_d_r, x_d_r, x_d_i, pstream__);
        local_scalar_t__ z_1d = DUMMY_VAR__;
        current_statement__ = 111;
        z_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), static_cast<double>(1), x, x_d_r,
                 x_d_i, pstream__, 1e-8);
        current_statement__ = 112;
        z_1d = stan::math::integrate_1d(integrand_functor__(), 0.0,
                 static_cast<double>(1), x, x_d_r, x_d_i, pstream__, 1e-8);
        current_statement__ = 113;
        z_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), 1.0, x, x_d_r, x_d_i, pstream__,
                 1e-8);
        current_statement__ = 114;
        z_1d = stan::math::integrate_1d(integrand_functor__(), 0.0, 1.0, x,
                 x_d_r, x_d_i, pstream__, 1e-8);
        current_statement__ = 115;
        z_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), static_cast<double>(1), x, x_d_r,
                 x_d_i, pstream__, 1e-8);
        current_statement__ = 116;
        z_1d = stan::math::integrate_1d(integrand_functor__(), x_r,
                 static_cast<double>(1), x, x_d_r, x_d_i, pstream__, 1e-8);
        current_statement__ = 117;
        z_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), x_r, x, x_d_r, x_d_i, pstream__,
                 1e-8);
        current_statement__ = 118;
        z_1d = stan::math::integrate_1d(integrand_functor__(), x_r, x_r, x,
                 x_d_r, x_d_i, pstream__, 1e-8);
        current_statement__ = 119;
        z_1d = stan::math::integrate_1d(integrand_functor__(), x_r,
                 static_cast<double>(1), x_d_r, x_d_r, x_d_i, pstream__, 1e-8);
        current_statement__ = 120;
        z_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), x_r, x_d_r, x_d_r, x_d_i, pstream__,
                 1e-8);
        current_statement__ = 121;
        z_1d = stan::math::integrate_1d(integrand_functor__(), x_r, x_r,
                 x_d_r, x_d_r, x_d_i, pstream__, 1e-8);
        local_scalar_t__ abc_m = DUMMY_VAR__;
        current_statement__ = 122;
        abc_m = map_rectfake(abc1_p, pstream__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "motherHOF_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<local_scalar_t__> y0_p =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 1;
      y0_p = in__.template read<std::vector<local_scalar_t__>>(2);
      std::vector<local_scalar_t__> theta_p =
        std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      current_statement__ = 2;
      theta_p = in__.template read<std::vector<local_scalar_t__>>(1);
      std::vector<local_scalar_t__> x_p =
        std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      current_statement__ = 3;
      x_p = in__.template read<std::vector<local_scalar_t__>>(1);
      Eigen::Matrix<local_scalar_t__,-1,1> x_p_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 4;
      x_p_v = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      Eigen::Matrix<local_scalar_t__,-1,1> shared_params_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      current_statement__ = 5;
      shared_params_p = in__.template read<
                          Eigen::Matrix<local_scalar_t__,-1,1>>(3);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> job_params_p =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(3,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__));
      current_statement__ = 6;
      job_params_p = in__.template read<
                       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(3,
                       3);
      local_scalar_t__ x_r = DUMMY_VAR__;
      current_statement__ = 7;
      x_r = in__.template read<local_scalar_t__>();
      local_scalar_t__ abc1_p = DUMMY_VAR__;
      current_statement__ = 8;
      abc1_p = 3;
      local_scalar_t__ abc2_p = DUMMY_VAR__;
      current_statement__ = 9;
      abc2_p = map_rectfake(abc1_p, pstream__);
      local_scalar_t__ abc3_p = DUMMY_VAR__;
      current_statement__ = 10;
      abc3_p = map_rectfake(static_cast<double>(12), pstream__);
      Eigen::Matrix<local_scalar_t__,-1,1> y_hat_tp1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      current_statement__ = 11;
      stan::model::assign(y_hat_tp1,
        stan::math::map_rect<7, foo_functor__>(shared_params_p, job_params_d,
          data_r, data_i, pstream__), "assigning variable y_hat_tp1");
      Eigen::Matrix<local_scalar_t__,-1,1> y_hat_tp2 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      current_statement__ = 12;
      stan::model::assign(y_hat_tp2,
        stan::math::map_rect<8, foo_functor__>(shared_params_d, job_params_p,
          data_r, data_i, pstream__), "assigning variable y_hat_tp2");
      Eigen::Matrix<local_scalar_t__,-1,1> y_hat_tp3 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      current_statement__ = 13;
      stan::model::assign(y_hat_tp3,
        stan::math::map_rect<9, foo_functor__>(shared_params_p, job_params_d,
          data_r, data_i, pstream__), "assigning variable y_hat_tp3");
      Eigen::Matrix<local_scalar_t__,-1,1> theta_p_as =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> x_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> y_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> y_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 26;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_v, y_v,
          x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 27;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_v, y_v,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 28;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_v, y_p,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 29;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_v,
          x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 30;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_v,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 31;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_p,
          x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 32;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_p,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 33;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_v,
          y_v, x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 34;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_v,
          y_v, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 35;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_v,
          y_p, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 36;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_v, x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 37;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_v, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 38;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_p, x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 39;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_p, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      {
        current_statement__ = 80;
        stan::math::validate_non_negative_index("y_hat", "T", T);
        std::vector<std::vector<local_scalar_t__>> y_hat =
          std::vector<std::vector<local_scalar_t__>>(T,
            std::vector<local_scalar_t__>(2, DUMMY_VAR__));
        current_statement__ = 82;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_adams(sho_functor__(), y0_d, t0, ts,
            theta_p, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 83;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_adams(sho_functor__(), y0_p, t0, ts,
            theta_d, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 84;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_adams(sho_functor__(), y0_p, t0, ts,
            theta_p, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 85;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_adams(sho_functor__(), y0_d, t0, ts,
            theta_p, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 86;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_adams(sho_functor__(), y0_p, t0, ts,
            theta_d, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 87;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_adams(sho_functor__(), y0_p, t0, ts,
            theta_p, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 88;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_d, t0, ts,
            theta_d, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 89;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_d, t0, ts,
            theta_p, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 90;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_p, t0, ts,
            theta_d, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 91;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_p, t0, ts,
            theta_p, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 92;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_d, t0, ts,
            theta_d, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 93;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_d, t0, ts,
            theta_p, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 94;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_p, t0, ts,
            theta_d, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 95;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_bdf(sho_functor__(), y0_p, t0, ts,
            theta_p, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
          "assigning variable y_hat");
        current_statement__ = 96;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_rk45(sho_functor__(), y0_d, t0, ts,
            theta_d, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 97;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_rk45(sho_functor__(), y0_d, t0, ts,
            theta_p, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 98;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_rk45(sho_functor__(), y0_p, t0, ts,
            theta_d, x, x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 99;
        stan::model::assign(y_hat,
          stan::math::integrate_ode_rk45(sho_functor__(), y0_p, t0, ts,
            theta_p, x, x_int, pstream__), "assigning variable y_hat");
        local_scalar_t__ y_1d = DUMMY_VAR__;
        current_statement__ = 100;
        y_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), static_cast<double>(1), x, x_d_r,
                 x_d_i, pstream__);
        current_statement__ = 101;
        y_1d = stan::math::integrate_1d(integrand_functor__(), 0.0,
                 static_cast<double>(1), x, x_d_r, x_d_i, pstream__);
        current_statement__ = 102;
        y_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), 1.0, x, x_d_r, x_d_i, pstream__);
        current_statement__ = 103;
        y_1d = stan::math::integrate_1d(integrand_functor__(), 0.0, 1.0, x,
                 x_d_r, x_d_i, pstream__);
        current_statement__ = 104;
        y_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), static_cast<double>(1), x, x_d_r,
                 x_d_i, pstream__);
        current_statement__ = 105;
        y_1d = stan::math::integrate_1d(integrand_functor__(), x_r,
                 static_cast<double>(1), x, x_d_r, x_d_i, pstream__);
        current_statement__ = 106;
        y_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), x_r, x, x_d_r, x_d_i, pstream__);
        current_statement__ = 107;
        y_1d = stan::math::integrate_1d(integrand_functor__(), x_r, x_r, x,
                 x_d_r, x_d_i, pstream__);
        current_statement__ = 108;
        y_1d = stan::math::integrate_1d(integrand_functor__(), x_r,
                 static_cast<double>(1), x_d_r, x_d_r, x_d_i, pstream__);
        current_statement__ = 109;
        y_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), x_r, x_d_r, x_d_r, x_d_i, pstream__);
        current_statement__ = 110;
        y_1d = stan::math::integrate_1d(integrand_functor__(), x_r, x_r,
                 x_d_r, x_d_r, x_d_i, pstream__);
        local_scalar_t__ z_1d = DUMMY_VAR__;
        current_statement__ = 111;
        z_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), static_cast<double>(1), x, x_d_r,
                 x_d_i, pstream__, 1e-8);
        current_statement__ = 112;
        z_1d = stan::math::integrate_1d(integrand_functor__(), 0.0,
                 static_cast<double>(1), x, x_d_r, x_d_i, pstream__, 1e-8);
        current_statement__ = 113;
        z_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), 1.0, x, x_d_r, x_d_i, pstream__,
                 1e-8);
        current_statement__ = 114;
        z_1d = stan::math::integrate_1d(integrand_functor__(), 0.0, 1.0, x,
                 x_d_r, x_d_i, pstream__, 1e-8);
        current_statement__ = 115;
        z_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), static_cast<double>(1), x, x_d_r,
                 x_d_i, pstream__, 1e-8);
        current_statement__ = 116;
        z_1d = stan::math::integrate_1d(integrand_functor__(), x_r,
                 static_cast<double>(1), x, x_d_r, x_d_i, pstream__, 1e-8);
        current_statement__ = 117;
        z_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), x_r, x, x_d_r, x_d_i, pstream__,
                 1e-8);
        current_statement__ = 118;
        z_1d = stan::math::integrate_1d(integrand_functor__(), x_r, x_r, x,
                 x_d_r, x_d_i, pstream__, 1e-8);
        current_statement__ = 119;
        z_1d = stan::math::integrate_1d(integrand_functor__(), x_r,
                 static_cast<double>(1), x_d_r, x_d_r, x_d_i, pstream__, 1e-8);
        current_statement__ = 120;
        z_1d = stan::math::integrate_1d(integrand_functor__(),
                 static_cast<double>(0), x_r, x_d_r, x_d_r, x_d_i, pstream__,
                 1e-8);
        current_statement__ = 121;
        z_1d = stan::math::integrate_1d(integrand_functor__(), x_r, x_r,
                 x_d_r, x_d_r, x_d_i, pstream__, 1e-8);
        local_scalar_t__ abc_m = DUMMY_VAR__;
        current_statement__ = 122;
        abc_m = map_rectfake(abc1_p, pstream__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "motherHOF_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<double> y0_p =
        std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      y0_p = in__.template read<std::vector<local_scalar_t__>>(2);
      std::vector<double> theta_p =
        std::vector<double>(1, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      theta_p = in__.template read<std::vector<local_scalar_t__>>(1);
      std::vector<double> x_p =
        std::vector<double>(1, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      x_p = in__.template read<std::vector<local_scalar_t__>>(1);
      Eigen::Matrix<double,-1,1> x_p_v =
        Eigen::Matrix<double,-1,1>::Constant(2,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 4;
      x_p_v = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      Eigen::Matrix<double,-1,1> shared_params_p =
        Eigen::Matrix<double,-1,1>::Constant(3,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      shared_params_p = in__.template read<
                          Eigen::Matrix<local_scalar_t__,-1,1>>(3);
      std::vector<Eigen::Matrix<double,-1,1>> job_params_p =
        std::vector<Eigen::Matrix<double,-1,1>>(3,
          Eigen::Matrix<double,-1,1>::Constant(3,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 6;
      job_params_p = in__.template read<
                       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(3,
                       3);
      double x_r = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 7;
      x_r = in__.template read<local_scalar_t__>();
      double abc1_p = std::numeric_limits<double>::quiet_NaN();
      double abc2_p = std::numeric_limits<double>::quiet_NaN();
      double abc3_p = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double,-1,1> y_hat_tp1 =
        Eigen::Matrix<double,-1,1>::Constant(3,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> y_hat_tp2 =
        Eigen::Matrix<double,-1,1>::Constant(3,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> y_hat_tp3 =
        Eigen::Matrix<double,-1,1>::Constant(3,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> theta_p_as =
        Eigen::Matrix<double,-1,1>::Constant(2,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> x_v =
        Eigen::Matrix<double,-1,1>::Constant(2,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> y_v =
        Eigen::Matrix<double,-1,1>::Constant(2,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> y_p =
        Eigen::Matrix<double,-1,1>::Constant(2,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(y0_p);
      out__.write(theta_p);
      out__.write(x_p);
      out__.write(x_p_v);
      out__.write(shared_params_p);
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          out__.write(job_params_p[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      out__.write(x_r);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 8;
      abc1_p = 3;
      current_statement__ = 9;
      abc2_p = map_rectfake(abc1_p, pstream__);
      current_statement__ = 10;
      abc3_p = map_rectfake(static_cast<double>(12), pstream__);
      current_statement__ = 11;
      stan::model::assign(y_hat_tp1,
        stan::math::map_rect<1, foo_functor__>(shared_params_p, job_params_d,
          data_r, data_i, pstream__), "assigning variable y_hat_tp1");
      current_statement__ = 12;
      stan::model::assign(y_hat_tp2,
        stan::math::map_rect<2, foo_functor__>(shared_params_d, job_params_p,
          data_r, data_i, pstream__), "assigning variable y_hat_tp2");
      current_statement__ = 13;
      stan::model::assign(y_hat_tp3,
        stan::math::map_rect<3, foo_functor__>(shared_params_p, job_params_d,
          data_r, data_i, pstream__), "assigning variable y_hat_tp3");
      current_statement__ = 26;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_v, y_v,
          x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 27;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_v, y_v,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 28;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_v, y_p,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 29;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_v,
          x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 30;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_v,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 31;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_p,
          x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 32;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_p,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 33;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_v,
          y_v, x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 34;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_v,
          y_v, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 35;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_v,
          y_p, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 36;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_v, x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 37;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_v, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      current_statement__ = 38;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_p, x_d_r, x_d_i, pstream__), "assigning variable theta_p_as");
      current_statement__ = 39;
      stan::model::assign(theta_p_as,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_p, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_p_as");
      if (emit_transformed_parameters__) {
        out__.write(abc1_p);
        out__.write(abc2_p);
        out__.write(abc3_p);
        out__.write(y_hat_tp1);
        out__.write(y_hat_tp2);
        out__.write(y_hat_tp3);
        out__.write(theta_p_as);
        out__.write(x_v);
        out__.write(y_v);
        out__.write(y_p);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      std::vector<std::vector<double>> y_hat =
        std::vector<std::vector<double>>(T,
          std::vector<double>(2, std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 40;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_adams(sho_functor__(), y0_d, t0, ts,
          theta_d, x, x_int, pstream__), "assigning variable y_hat");
      current_statement__ = 41;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_adams(sho_functor__(), y0_d, t0, ts,
          theta_p, x, x_int, pstream__), "assigning variable y_hat");
      current_statement__ = 42;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_adams(sho_functor__(), y0_p, t0, ts,
          theta_d, x, x_int, pstream__), "assigning variable y_hat");
      current_statement__ = 43;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_adams(sho_functor__(), y0_p, t0, ts,
          theta_p, x, x_int, pstream__), "assigning variable y_hat");
      current_statement__ = 44;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_adams(sho_functor__(), y0_d, t0, ts,
          theta_d, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
        "assigning variable y_hat");
      current_statement__ = 45;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_adams(sho_functor__(), y0_d, t0, ts,
          theta_p, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
        "assigning variable y_hat");
      current_statement__ = 46;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_adams(sho_functor__(), y0_p, t0, ts,
          theta_d, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
        "assigning variable y_hat");
      current_statement__ = 47;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_adams(sho_functor__(), y0_p, t0, ts,
          theta_p, x, x_int, pstream__, 1e-10, 1e-10, 1e8),
        "assigning variable y_hat");
      current_statement__ = 48;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_bdf(sho_functor__(), y0_d, t0, ts, theta_d,
          x, x_int, pstream__), "assigning variable y_hat");
      current_statement__ = 49;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_bdf(sho_functor__(), y0_d, t0, ts, theta_p,
          x, x_int, pstream__), "assigning variable y_hat");
      current_statement__ = 50;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_bdf(sho_functor__(), y0_p, t0, ts, theta_d,
          x, x_int, pstream__), "assigning variable y_hat");
      current_statement__ = 51;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_bdf(sho_functor__(), y0_p, t0, ts, theta_p,
          x, x_int, pstream__), "assigning variable y_hat");
      current_statement__ = 52;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_bdf(sho_functor__(), y0_d, t0, ts, theta_d,
          x, x_int, pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
      current_statement__ = 53;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_bdf(sho_functor__(), y0_d, t0, ts, theta_p,
          x, x_int, pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
      current_statement__ = 54;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_bdf(sho_functor__(), y0_p, t0, ts, theta_d,
          x, x_int, pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
      current_statement__ = 55;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_bdf(sho_functor__(), y0_p, t0, ts, theta_p,
          x, x_int, pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
      current_statement__ = 56;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_rk45(sho_functor__(), y0_d, t0, ts,
          theta_d, x, x_int, pstream__), "assigning variable y_hat");
      current_statement__ = 57;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_rk45(sho_functor__(), y0_d, t0, ts,
          theta_p, x, x_int, pstream__), "assigning variable y_hat");
      current_statement__ = 58;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_rk45(sho_functor__(), y0_p, t0, ts,
          theta_d, x, x_int, pstream__), "assigning variable y_hat");
      current_statement__ = 59;
      stan::model::assign(y_hat,
        stan::math::integrate_ode_rk45(sho_functor__(), y0_p, t0, ts,
          theta_p, x, x_int, pstream__), "assigning variable y_hat");
      double y_1d = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 19;
      y_1d = stan::math::integrate_1d(integrand_functor__(),
               static_cast<double>(0), static_cast<double>(1), x, x_d_r,
               x_d_i, pstream__);
      current_statement__ = 60;
      y_1d = stan::math::integrate_1d(integrand_functor__(), 0.0,
               static_cast<double>(1), x, x_d_r, x_d_i, pstream__);
      current_statement__ = 61;
      y_1d = stan::math::integrate_1d(integrand_functor__(),
               static_cast<double>(0), 1.0, x, x_d_r, x_d_i, pstream__);
      current_statement__ = 62;
      y_1d = stan::math::integrate_1d(integrand_functor__(), 0.0, 1.0, x,
               x_d_r, x_d_i, pstream__);
      double z_1d = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 20;
      z_1d = stan::math::integrate_1d(integrand_functor__(),
               static_cast<double>(0), static_cast<double>(1), x, x_d_r,
               x_d_i, pstream__, 1e-8);
      current_statement__ = 63;
      z_1d = stan::math::integrate_1d(integrand_functor__(), 0.0,
               static_cast<double>(1), x, x_d_r, x_d_i, pstream__, 1e-8);
      current_statement__ = 64;
      z_1d = stan::math::integrate_1d(integrand_functor__(),
               static_cast<double>(0), 1.0, x, x_d_r, x_d_i, pstream__, 1e-8);
      current_statement__ = 65;
      z_1d = stan::math::integrate_1d(integrand_functor__(), 0.0, 1.0, x,
               x_d_r, x_d_i, pstream__, 1e-8);
      double abc1_gq = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 21;
      abc1_gq = map_rectfake(static_cast<double>(12), pstream__);
      double abc2_gq = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 22;
      abc2_gq = map_rectfake(abc1_p, pstream__);
      Eigen::Matrix<double,-1,1> y_hat_gq =
        Eigen::Matrix<double,-1,1>::Constant(3,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 23;
      stan::model::assign(y_hat_gq,
        stan::math::add(
          stan::math::map_rect<4, foo_functor__>(shared_params_d,
            job_params_d, data_r, data_i, pstream__),
          stan::math::map_rect<5, goo_functor__>(shared_params_d,
            job_params_d, data_r, data_i, pstream__)),
        "assigning variable y_hat_gq");
      Eigen::Matrix<double,-1,1> yy_hat_gq =
        Eigen::Matrix<double,-1,1>::Constant(3,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 24;
      stan::model::assign(yy_hat_gq,
        stan::math::map_rect<6, goo_functor__>(shared_params_d, job_params_d,
          data_r, data_i, pstream__), "assigning variable yy_hat_gq");
      Eigen::Matrix<double,-1,1> theta_dbl =
        Eigen::Matrix<double,-1,1>::Constant(2,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 66;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver(algebra_system_functor__(), x_v, y_v,
          x_d_r, x_d_i, pstream__), "assigning variable theta_dbl");
      current_statement__ = 67;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver(algebra_system_functor__(), x_v, y_v,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_dbl");
      current_statement__ = 68;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver(algebra_system_functor__(), x_v, y_p,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_dbl");
      current_statement__ = 69;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_v,
          x_d_r, x_d_i, pstream__), "assigning variable theta_dbl");
      current_statement__ = 70;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_v,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_dbl");
      current_statement__ = 71;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_p,
          x_d_r, x_d_i, pstream__), "assigning variable theta_dbl");
      current_statement__ = 72;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver(algebra_system_functor__(), x_p_v, y_p,
          x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_dbl");
      current_statement__ = 73;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_v,
          y_v, x_d_r, x_d_i, pstream__), "assigning variable theta_dbl");
      current_statement__ = 74;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_v,
          y_v, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_dbl");
      current_statement__ = 75;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_v,
          y_p, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_dbl");
      current_statement__ = 76;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_v, x_d_r, x_d_i, pstream__), "assigning variable theta_dbl");
      current_statement__ = 77;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_v, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_dbl");
      current_statement__ = 78;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_p, x_d_r, x_d_i, pstream__), "assigning variable theta_dbl");
      current_statement__ = 79;
      stan::model::assign(theta_dbl,
        stan::math::algebra_solver_newton(algebra_system_functor__(), x_p_v,
          y_p, x_d_r, x_d_i, pstream__, 0.01, 0.01, static_cast<double>(10)),
        "assigning variable theta_dbl");
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= T; ++sym2__) {
          out__.write(y_hat[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      out__.write(y_1d);
      out__.write(z_1d);
      out__.write(abc1_gq);
      out__.write(abc2_gq);
      out__.write(y_hat_gq);
      out__.write(yy_hat_gq);
      out__.write(theta_dbl);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      std::vector<local_scalar_t__> y0_p =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(y0_p, in__.read<std::vector<local_scalar_t__>>(2),
        "assigning variable y0_p");
      out__.write(y0_p);
      std::vector<local_scalar_t__> theta_p =
        std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(theta_p,
        in__.read<std::vector<local_scalar_t__>>(1),
        "assigning variable theta_p");
      out__.write(theta_p);
      std::vector<local_scalar_t__> x_p =
        std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(x_p, in__.read<std::vector<local_scalar_t__>>(1),
        "assigning variable x_p");
      out__.write(x_p);
      Eigen::Matrix<local_scalar_t__,-1,1> x_p_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(x_p_v,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(2),
        "assigning variable x_p_v");
      out__.write(x_p_v);
      Eigen::Matrix<local_scalar_t__,-1,1> shared_params_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(shared_params_p,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(3),
        "assigning variable shared_params_p");
      out__.write(shared_params_p);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> job_params_p =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(3,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__));
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          current_statement__ = 6;
          stan::model::assign(job_params_p, in__.read<local_scalar_t__>(),
            "assigning variable job_params_p",
            stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
        }
      }
      out__.write(job_params_p);
      local_scalar_t__ x_r = DUMMY_VAR__;
      current_statement__ = 7;
      x_r = in__.read<local_scalar_t__>();
      out__.write(x_r);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "y0_p", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "theta_p",
        "double", std::vector<size_t>{static_cast<size_t>(1)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "x_p", "double",
        std::vector<size_t>{static_cast<size_t>(1)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "x_p_v", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "shared_params_p",
        "double", std::vector<size_t>{static_cast<size_t>(3)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "job_params_p",
        "double",
        std::vector<size_t>{static_cast<size_t>(3), static_cast<size_t>(3)});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "x_r", "double",
        std::vector<size_t>{});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      std::vector<local_scalar_t__> y0_p =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 1;
      y0_p = context__.vals_r("y0_p");
      out__.write(y0_p);
      std::vector<local_scalar_t__> theta_p =
        std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      current_statement__ = 2;
      theta_p = context__.vals_r("theta_p");
      out__.write(theta_p);
      std::vector<local_scalar_t__> x_p =
        std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      current_statement__ = 3;
      x_p = context__.vals_r("x_p");
      out__.write(x_p);
      Eigen::Matrix<local_scalar_t__,-1,1> x_p_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> x_p_v_flat__;
        current_statement__ = 4;
        x_p_v_flat__ = context__.vals_r("x_p_v");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          stan::model::assign(x_p_v, x_p_v_flat__[(pos__ - 1)],
            "assigning variable x_p_v", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(x_p_v);
      Eigen::Matrix<local_scalar_t__,-1,1> shared_params_p =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> shared_params_p_flat__;
        current_statement__ = 5;
        shared_params_p_flat__ = context__.vals_r("shared_params_p");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          stan::model::assign(shared_params_p, shared_params_p_flat__[(pos__
            - 1)], "assigning variable shared_params_p",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(shared_params_p);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> job_params_p =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(3,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> job_params_p_flat__;
        current_statement__ = 6;
        job_params_p_flat__ = context__.vals_r("job_params_p");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            stan::model::assign(job_params_p, job_params_p_flat__[(pos__ -
              1)], "assigning variable job_params_p",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(job_params_p);
      local_scalar_t__ x_r = DUMMY_VAR__;
      current_statement__ = 7;
      x_r = context__.vals_r("x_r")[(1 - 1)];
      out__.write(x_r);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"y0_p", "theta_p", "x_p", "x_p_v",
                "shared_params_p", "job_params_p", "x_r"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"abc1_p", "abc2_p", "abc3_p", "y_hat_tp1", "y_hat_tp2",
             "y_hat_tp3", "theta_p_as", "x_v", "y_v", "y_p"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string>
        temp{"y_hat", "y_1d", "z_1d", "abc1_gq", "abc2_gq", "y_hat_gq",
             "yy_hat_gq", "theta_dbl"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(1)},
                std::vector<size_t>{static_cast<size_t>(1)},
                std::vector<size_t>{static_cast<size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(3)},
                std::vector<size_t>{static_cast<size_t>(3),
                  static_cast<size_t>(3)}, std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(2)},
             std::vector<size_t>{static_cast<size_t>(2)},
             std::vector<size_t>{static_cast<size_t>(2)},
             std::vector<size_t>{static_cast<size_t>(2)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(T),
               static_cast<size_t>(2)}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(3)},
             std::vector<size_t>{static_cast<size_t>(2)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "y0_p" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      param_names__.emplace_back(std::string() + "theta_p" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      param_names__.emplace_back(std::string() + "x_p" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "x_p_v" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      param_names__.emplace_back(std::string() + "shared_params_p" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
        param_names__.emplace_back(std::string() + "job_params_p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    param_names__.emplace_back(std::string() + "x_r");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "abc1_p");
      param_names__.emplace_back(std::string() + "abc2_p");
      param_names__.emplace_back(std::string() + "abc3_p");
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "y_hat_tp1" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "y_hat_tp2" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "y_hat_tp3" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta_p_as" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "x_v" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "y_v" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "y_p" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= T; ++sym2__) {
          param_names__.emplace_back(std::string() + "y_hat" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      param_names__.emplace_back(std::string() + "y_1d");
      param_names__.emplace_back(std::string() + "z_1d");
      param_names__.emplace_back(std::string() + "abc1_gq");
      param_names__.emplace_back(std::string() + "abc2_gq");
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "y_hat_gq" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "yy_hat_gq" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta_dbl" + '.' +
          std::to_string(sym1__));
      }
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "y0_p" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      param_names__.emplace_back(std::string() + "theta_p" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      param_names__.emplace_back(std::string() + "x_p" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "x_p_v" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      param_names__.emplace_back(std::string() + "shared_params_p" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
        param_names__.emplace_back(std::string() + "job_params_p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    param_names__.emplace_back(std::string() + "x_r");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "abc1_p");
      param_names__.emplace_back(std::string() + "abc2_p");
      param_names__.emplace_back(std::string() + "abc3_p");
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "y_hat_tp1" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "y_hat_tp2" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "y_hat_tp3" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta_p_as" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "x_v" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "y_v" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "y_p" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= T; ++sym2__) {
          param_names__.emplace_back(std::string() + "y_hat" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      param_names__.emplace_back(std::string() + "y_1d");
      param_names__.emplace_back(std::string() + "z_1d");
      param_names__.emplace_back(std::string() + "abc1_gq");
      param_names__.emplace_back(std::string() + "abc2_gq");
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "y_hat_gq" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "yy_hat_gq" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta_dbl" + '.' +
          std::to_string(sym1__));
      }
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"y0_p\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta_p\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(1) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_p\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(1) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_p_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"shared_params_p\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"parameters\"},{\"name\":\"job_params_p\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "}},\"block\":\"parameters\"},{\"name\":\"x_r\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"abc1_p\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"abc2_p\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"abc3_p\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat_tp1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat_tp2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat_tp3\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"transformed_parameters\"},{\"name\":\"theta_p_as\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"x_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_p\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(T) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"generated_quantities\"},{\"name\":\"y_1d\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"z_1d\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"abc1_gq\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"abc2_gq\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"y_hat_gq\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"generated_quantities\"},{\"name\":\"yy_hat_gq\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"generated_quantities\"},{\"name\":\"theta_dbl\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"y0_p\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta_p\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(1) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_p\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(1) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_p_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"shared_params_p\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"parameters\"},{\"name\":\"job_params_p\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "}},\"block\":\"parameters\"},{\"name\":\"x_r\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"abc1_p\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"abc2_p\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"abc3_p\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat_tp1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat_tp2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat_tp3\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"transformed_parameters\"},{\"name\":\"theta_p_as\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"x_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_p\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(T) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"generated_quantities\"},{\"name\":\"y_1d\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"z_1d\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"abc1_gq\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"abc2_gq\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"y_hat_gq\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"generated_quantities\"},{\"name\":\"yy_hat_gq\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"generated_quantities\"},{\"name\":\"theta_dbl\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((2 + 1) + 1) + 2) + 3) + (3 * 3)) + 1);
    const size_t num_transformed = emit_transformed_parameters * ((((((((((1
      + 1) + 1) + 3) + 3) + 3) + 2) + 2) + 2) + 2));
    const size_t num_gen_quantities = emit_generated_quantities * (((((((((T
      * 2) + 1) + 1) + 1) + 1) + 3) + 3) + 2));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((2 + 1) + 1) + 2) + 3) + (3 * 3)) + 1);
    const size_t num_transformed = emit_transformed_parameters * ((((((((((1
      + 1) + 1) + 3) + 3) + 3) + 2) + 2) + 2) + 2));
    const size_t num_gen_quantities = emit_generated_quantities * (((((((((T
      * 2) + 1) + 1) + 1) + 1) + 3) + 3) + 2));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = motherHOF_model_namespace::motherHOF_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return motherHOF_model_namespace::profiles__;
}
#endif
STAN_REGISTER_MAP_RECT(1, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(2, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(3, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(4, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(5, motherHOF_model_namespace::goo_functor__)
STAN_REGISTER_MAP_RECT(6, motherHOF_model_namespace::goo_functor__)
STAN_REGISTER_MAP_RECT(7, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(8, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(9, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(10, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(11, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(12, motherHOF_model_namespace::foo_functor__)
Warning in 'motherHOF.stan', line 100, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 101, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 102, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 104, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 106, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 108, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 111, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 112, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 113, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 114, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 116, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 118, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 120, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 122, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 125, column 10: integrate_ode_rk45 is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 126, column 10: integrate_ode_rk45 is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 127, column 10: integrate_ode_rk45 is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 128, column 10: integrate_ode_rk45 is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 158, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 159, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 160, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 161, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 163, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 165, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 167, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 169, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 172, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 173, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 174, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 175, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 177, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 179, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 181, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 183, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 186, column 10: integrate_ode_rk45 is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 187, column 10: integrate_ode_rk45 is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 188, column 10: integrate_ode_rk45 is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'motherHOF.stan', line 189, column 10: integrate_ode_rk45 is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../../install/default/bin/stanc --print-cpp new_integrate_interface.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace new_integrate_interface_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 630> locations_array__ =
  {" (found before start of program)",
  " (in 'new_integrate_interface.stan', line 29, column 2 to column 9)",
  " (in 'new_integrate_interface.stan', line 30, column 2 to column 19)",
  " (in 'new_integrate_interface.stan', line 31, column 2 to column 14)",
  " (in 'new_integrate_interface.stan', line 34, column 2 to column 78)",
  " (in 'new_integrate_interface.stan', line 438, column 2 to line 439, column 42)",
  " (in 'new_integrate_interface.stan', line 36, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 37, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 38, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 39, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 40, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 41, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 42, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 43, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 44, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 45, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 46, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 47, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 48, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 49, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 50, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 51, column 2 to column 55)",
  " (in 'new_integrate_interface.stan', line 52, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 53, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 54, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 55, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 56, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 57, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 58, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 59, column 2 to column 55)",
  " (in 'new_integrate_interface.stan', line 60, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 61, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 62, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 63, column 2 to column 55)",
  " (in 'new_integrate_interface.stan', line 64, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 65, column 2 to column 55)",
  " (in 'new_integrate_interface.stan', line 66, column 2 to column 55)",
  " (in 'new_integrate_interface.stan', line 67, column 2 to column 54)",
  " (in 'new_integrate_interface.stan', line 68, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 69, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 70, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 71, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 72, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 73, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 74, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 75, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 76, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 77, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 78, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 79, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 80, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 81, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 82, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 83, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 84, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 85, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 86, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 87, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 88, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 89, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 90, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 91, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 92, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 93, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 94, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 95, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 96, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 97, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 98, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 99, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 100, column 2 to column 55)",
  " (in 'new_integrate_interface.stan', line 101, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 102, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 103, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 104, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 105, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 106, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 107, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 108, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 109, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 110, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 111, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 112, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 113, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 114, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 115, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 116, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 117, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 118, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 119, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 120, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 121, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 122, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 123, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 124, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 125, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 126, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 127, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 128, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 129, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 130, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 131, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 132, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 133, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 134, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 135, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 136, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 137, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 138, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 139, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 140, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 141, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 142, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 143, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 144, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 145, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 146, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 147, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 148, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 149, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 150, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 151, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 152, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 153, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 154, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 155, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 156, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 157, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 158, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 159, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 160, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 161, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 162, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 163, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 164, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 165, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 166, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 167, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 168, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 169, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 170, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 171, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 172, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 173, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 174, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 175, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 176, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 177, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 178, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 179, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 180, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 181, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 182, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 183, column 2 to column 34)",
  " (in 'new_integrate_interface.stan', line 184, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 185, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 186, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 187, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 188, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 189, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 190, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 191, column 2 to column 34)",
  " (in 'new_integrate_interface.stan', line 192, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 193, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 194, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 195, column 2 to column 34)",
  " (in 'new_integrate_interface.stan', line 196, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 197, column 2 to column 34)",
  " (in 'new_integrate_interface.stan', line 198, column 2 to column 34)",
  " (in 'new_integrate_interface.stan', line 199, column 2 to column 33)",
  " (in 'new_integrate_interface.stan', line 200, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 201, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 202, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 203, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 204, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 205, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 206, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 207, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 208, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 209, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 210, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 211, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 212, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 213, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 214, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 215, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 216, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 217, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 218, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 219, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 220, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 221, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 222, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 223, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 224, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 225, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 226, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 227, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 228, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 229, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 230, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 231, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 232, column 2 to column 34)",
  " (in 'new_integrate_interface.stan', line 440, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 441, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 442, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 443, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 444, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 445, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 446, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 447, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 448, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 449, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 450, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 451, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 452, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 453, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 454, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 455, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 456, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 457, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 458, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 459, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 460, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 461, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 462, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 463, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 464, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 465, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 466, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 467, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 468, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 469, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 470, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 471, column 2 to column 55)",
  " (in 'new_integrate_interface.stan', line 472, column 2 to column 62)",
  " (in 'new_integrate_interface.stan', line 473, column 2 to column 62)",
  " (in 'new_integrate_interface.stan', line 474, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 475, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 476, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 477, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 478, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 479, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 480, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 481, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 482, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 483, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 484, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 485, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 486, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 487, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 488, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 489, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 490, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 491, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 492, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 493, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 494, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 495, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 496, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 497, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 498, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 499, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 500, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 501, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 502, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 503, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 504, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 505, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 506, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 507, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 508, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 509, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 510, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 511, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 512, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 513, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 514, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 515, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 516, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 517, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 518, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 519, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 520, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 521, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 522, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 523, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 524, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 525, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 526, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 527, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 528, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 529, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 530, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 531, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 532, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 533, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 534, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 535, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 536, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 537, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 538, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 539, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 540, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 541, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 542, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 543, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 544, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 545, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 546, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 547, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 548, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 549, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 550, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 551, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 552, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 553, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 554, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 555, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 556, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 557, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 558, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 559, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 560, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 561, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 562, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 563, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 564, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 565, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 566, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 567, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 568, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 569, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 570, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 571, column 2 to column 41)",
  " (in 'new_integrate_interface.stan', line 572, column 2 to column 41)",
  " (in 'new_integrate_interface.stan', line 573, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 574, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 575, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 576, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 577, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 578, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 579, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 580, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 581, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 582, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 583, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 584, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 585, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 586, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 587, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 588, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 589, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 590, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 591, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 592, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 593, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 594, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 595, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 596, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 597, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 598, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 599, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 600, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 601, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 602, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 603, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 604, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 605, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 606, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 607, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 608, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 609, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 610, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 611, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 612, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 613, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 614, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 615, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 616, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 617, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 618, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 619, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 620, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 621, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 622, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 623, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 624, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 625, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 626, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 627, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 628, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 629, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 630, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 631, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 632, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 633, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 634, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 635, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 636, column 2 to column 34)",
  " (in 'new_integrate_interface.stan', line 235, column 8 to column 9)",
  " (in 'new_integrate_interface.stan', line 235, column 18 to column 19)",
  " (in 'new_integrate_interface.stan', line 235, column 2 to line 236, column 42)",
  " (in 'new_integrate_interface.stan', line 238, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 239, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 240, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 241, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 242, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 243, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 244, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 245, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 246, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 247, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 248, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 249, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 250, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 251, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 252, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 253, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 254, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 255, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 256, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 257, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 258, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 259, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 260, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 261, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 262, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 263, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 264, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 265, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 266, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 267, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 268, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 269, column 2 to column 55)",
  " (in 'new_integrate_interface.stan', line 270, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 271, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 272, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 273, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 274, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 275, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 276, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 277, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 278, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 279, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 280, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 281, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 282, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 283, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 284, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 285, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 286, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 287, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 288, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 289, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 290, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 291, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 292, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 293, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 294, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 295, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 296, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 297, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 298, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 299, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 300, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 301, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 302, column 2 to column 56)",
  " (in 'new_integrate_interface.stan', line 303, column 2 to column 62)",
  " (in 'new_integrate_interface.stan', line 304, column 2 to column 62)",
  " (in 'new_integrate_interface.stan', line 305, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 306, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 307, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 308, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 309, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 310, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 311, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 312, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 313, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 314, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 315, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 316, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 317, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 318, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 319, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 320, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 321, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 322, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 323, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 324, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 325, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 326, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 327, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 328, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 329, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 330, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 331, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 332, column 2 to column 59)",
  " (in 'new_integrate_interface.stan', line 333, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 334, column 2 to column 58)",
  " (in 'new_integrate_interface.stan', line 335, column 2 to column 57)",
  " (in 'new_integrate_interface.stan', line 336, column 2 to column 41)",
  " (in 'new_integrate_interface.stan', line 337, column 2 to column 41)",
  " (in 'new_integrate_interface.stan', line 338, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 339, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 340, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 341, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 342, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 343, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 344, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 345, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 346, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 347, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 348, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 349, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 350, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 351, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 352, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 353, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 354, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 355, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 356, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 357, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 358, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 359, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 360, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 361, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 362, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 363, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 364, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 365, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 366, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 367, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 368, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 369, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 370, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 371, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 372, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 373, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 374, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 375, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 376, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 377, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 378, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 379, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 380, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 381, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 382, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 383, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 384, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 385, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 386, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 387, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 388, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 389, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 390, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 391, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 392, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 393, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 394, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 395, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 396, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 397, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 398, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 399, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 400, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 401, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 402, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 403, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 404, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 405, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 406, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 407, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 408, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 409, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 410, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 411, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 412, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 413, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 414, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 415, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 416, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 417, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 418, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 419, column 2 to column 38)",
  " (in 'new_integrate_interface.stan', line 420, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 421, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 422, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 423, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 424, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 425, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 426, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 427, column 2 to column 37)",
  " (in 'new_integrate_interface.stan', line 428, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 429, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 430, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 431, column 2 to column 36)",
  " (in 'new_integrate_interface.stan', line 432, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 433, column 2 to column 35)",
  " (in 'new_integrate_interface.stan', line 434, column 2 to column 34)",
  " (in 'new_integrate_interface.stan', line 435, column 2 to column 19)",
  " (in 'new_integrate_interface.stan', line 7, column 2 to column 8)",
  " (in 'new_integrate_interface.stan', line 8, column 2 to column 9)",
  " (in 'new_integrate_interface.stan', line 9, column 2 to column 10)",
  " (in 'new_integrate_interface.stan', line 10, column 8 to column 9)",
  " (in 'new_integrate_interface.stan', line 10, column 2 to column 20)",
  " (in 'new_integrate_interface.stan', line 11, column 9 to column 10)",
  " (in 'new_integrate_interface.stan', line 11, column 2 to column 15)",
  " (in 'new_integrate_interface.stan', line 14, column 8 to column 9)",
  " (in 'new_integrate_interface.stan', line 14, column 18 to column 19)",
  " (in 'new_integrate_interface.stan', line 14, column 2 to line 15, column 42)",
  " (in 'new_integrate_interface.stan', line 16, column 2 to column 60)",
  " (in 'new_integrate_interface.stan', line 17, column 2 to column 62)",
  " (in 'new_integrate_interface.stan', line 18, column 2 to column 62)",
  " (in 'new_integrate_interface.stan', line 19, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 20, column 2 to column 61)",
  " (in 'new_integrate_interface.stan', line 21, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 22, column 2 to column 39)",
  " (in 'new_integrate_interface.stan', line 23, column 2 to column 41)",
  " (in 'new_integrate_interface.stan', line 24, column 2 to column 41)",
  " (in 'new_integrate_interface.stan', line 25, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 26, column 2 to column 40)",
  " (in 'new_integrate_interface.stan', line 30, column 8 to column 9)",
  " (in 'new_integrate_interface.stan', line 31, column 9 to column 10)",
  " (in 'new_integrate_interface.stan', line 34, column 8 to column 9)",
  " (in 'new_integrate_interface.stan', line 34, column 18 to column 19)",
  " (in 'new_integrate_interface.stan', line 438, column 8 to column 9)",
  " (in 'new_integrate_interface.stan', line 438, column 18 to column 19)",
  " (in 'new_integrate_interface.stan', line 3, column 4 to column 13)",
  " (in 'new_integrate_interface.stan', line 2, column 47 to line 4, column 3)"};
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>,
                              stan::is_col_vector<T3__>,
                              stan::is_vt_not_complex<T3__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>, T2__,
                stan::base_type_t<T3__>>,-1,1>
f(const T0__& t, const T1__& z_arg__, const T2__& a, const T3__& b_arg__,
  std::ostream* pstream__);
struct f_variadic2_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                        std::is_floating_point<T0__>>,
                                stan::is_col_vector<T1__>,
                                stan::is_vt_not_complex<T1__>,
                                stan::math::disjunction<stan::is_autodiff<T2__>,
                                                        std::is_floating_point<T2__>>,
                                stan::is_col_vector<T3__>,
                                stan::is_vt_not_complex<T3__>>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>, T2__,
                  stan::base_type_t<T3__>>,-1,1>
  operator()(const T0__& t, const T1__& z, std::ostream* pstream__,
             const T2__& a, const T3__& b) const {
    return f(t, z, a, b, pstream__);
  }
};
// vector f(real, vector, real, vector)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>,
                              stan::is_col_vector<T3__>,
                              stan::is_vt_not_complex<T3__>>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>, T2__,
                stan::base_type_t<T3__>>,-1,1>
f(const T0__& t, const T1__& z_arg__, const T2__& a, const T3__& b_arg__,
  std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
                             stan::base_type_t<T1__>, T2__,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& z = stan::math::to_ref(z_arg__);
  const auto& b = stan::math::to_ref(b_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 628;
    return z;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class new_integrate_interface_model final : public model_base_crtp<new_integrate_interface_model> {
 private:
  int N;
  int id;
  double rd;
  std::vector<double> rad;
  Eigen::Matrix<double,-1,1> vd_data__;
  std::vector<Eigen::Matrix<double,-1,1>> zd;
  Eigen::Map<Eigen::Matrix<double,-1,1>> vd{nullptr, 0};
 public:
  ~new_integrate_interface_model() {}
  new_integrate_interface_model(stan::io::var_context& context__,
                                unsigned int random_seed__ = 0, std::ostream*
                                pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "new_integrate_interface_model_namespace::new_integrate_interface_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 601;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 601;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 602;
      context__.validate_dims("data initialization", "id", "int",
        std::vector<size_t>{});
      id = std::numeric_limits<int>::min();
      current_statement__ = 602;
      id = context__.vals_i("id")[(1 - 1)];
      current_statement__ = 603;
      context__.validate_dims("data initialization", "rd", "double",
        std::vector<size_t>{});
      rd = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 603;
      rd = context__.vals_r("rd")[(1 - 1)];
      current_statement__ = 604;
      stan::math::validate_non_negative_index("rad", "N", N);
      current_statement__ = 605;
      context__.validate_dims("data initialization", "rad", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      rad = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 605;
      rad = context__.vals_r("rad");
      current_statement__ = 606;
      stan::math::validate_non_negative_index("vd", "N", N);
      current_statement__ = 607;
      context__.validate_dims("data initialization", "vd", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      vd_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                    std::numeric_limits<double>::quiet_NaN());
      new (&vd) Eigen::Map<Eigen::Matrix<double,-1,1>>(vd_data__.data(), N);
      {
        std::vector<local_scalar_t__> vd_flat__;
        current_statement__ = 607;
        vd_flat__ = context__.vals_r("vd");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(vd, vd_flat__[(pos__ - 1)],
            "assigning variable vd", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 608;
      stan::math::validate_non_negative_index("zd", "N", N);
      current_statement__ = 609;
      stan::math::validate_non_negative_index("zd", "N", N);
      current_statement__ = 610;
      zd = std::vector<Eigen::Matrix<double,-1,1>>(N,
             Eigen::Matrix<double,-1,1>::Constant(N,
               std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 610;
      stan::model::assign(zd,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zd");
      current_statement__ = 611;
      stan::model::assign(zd,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable zd");
      current_statement__ = 612;
      stan::model::assign(zd,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zd");
      current_statement__ = 613;
      stan::model::assign(zd,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable zd");
      current_statement__ = 614;
      stan::model::assign(zd,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zd");
      current_statement__ = 615;
      stan::model::assign(zd,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable zd");
      current_statement__ = 616;
      stan::model::assign(zd,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, vd), "assigning variable zd");
      current_statement__ = 617;
      stan::model::assign(zd,
        stan::math::ode_bdf(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable zd");
      current_statement__ = 618;
      stan::model::assign(zd,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, rd, vd), "assigning variable zd");
      current_statement__ = 619;
      stan::model::assign(zd,
        stan::math::ode_adams(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable zd");
      current_statement__ = 620;
      stan::model::assign(zd,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, vd), "assigning variable zd");
      current_statement__ = 621;
      stan::model::assign(zd,
        stan::math::ode_rk45(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable zd");
      current_statement__ = 622;
      stan::math::validate_non_negative_index("ra", "N", N);
      current_statement__ = 623;
      stan::math::validate_non_negative_index("v", "N", N);
      current_statement__ = 624;
      stan::math::validate_non_negative_index("z", "N", N);
      current_statement__ = 625;
      stan::math::validate_non_negative_index("z", "N", N);
      current_statement__ = 626;
      stan::math::validate_non_negative_index("zg", "N", N);
      current_statement__ = 627;
      stan::math::validate_non_negative_index("zg", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + N + N;
  }
  inline std::string model_name() const final {
    return "new_integrate_interface_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "new_integrate_interface_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ r = DUMMY_VAR__;
      current_statement__ = 1;
      r = in__.template read<local_scalar_t__>();
      std::vector<local_scalar_t__> ra =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 2;
      ra = in__.template read<std::vector<local_scalar_t__>>(N);
      Eigen::Matrix<local_scalar_t__,-1,1> v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 3;
      v = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> z =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 4;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 6;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 7;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 8;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 9;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 10;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 11;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 12;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 13;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 14;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 15;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 16;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 17;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 18;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 19;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 20;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 21;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 22;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 23;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 24;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 25;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 26;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 27;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 28;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 29;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 30;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 31;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 32;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 33;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 34;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 35;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 36;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 37;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 38;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 39;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 40;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 41;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 42;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 43;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 44;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 45;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 46;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 47;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 48;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 49;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 50;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 51;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 52;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 53;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 54;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 55;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 56;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 57;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 58;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 59;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 60;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 61;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 62;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 63;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 64;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 65;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 66;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 67;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 68;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 69;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 70;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 71;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 72;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 73;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 74;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 75;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 76;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 77;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 78;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 79;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 80;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 81;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 82;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 83;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 84;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 85;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 86;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 87;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 88;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 89;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 90;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 91;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 92;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 93;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 94;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 95;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 96;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 97;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 98;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 99;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 100;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 101;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 102;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 103;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 104;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 105;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, rd, vd), "assigning variable z");
      current_statement__ = 106;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, rd, v), "assigning variable z");
      current_statement__ = 107;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, r, vd), "assigning variable z");
      current_statement__ = 108;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, r, v), "assigning variable z");
      current_statement__ = 109;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 110;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 111;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 112;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 113;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 114;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 115;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 116;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 117;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 118;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 119;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 120;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 121;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 122;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 123;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 124;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 125;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 126;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 127;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 128;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 129;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 130;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 131;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 132;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 133;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 134;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 135;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 136;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 137;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 138;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 139;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 140;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 141;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 142;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 143;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 144;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 145;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 146;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 147;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 148;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 149;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 150;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 151;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 152;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 153;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__, r,
          v), "assigning variable z");
      current_statement__ = 154;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 155;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 156;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 157;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 158;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 159;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 160;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 161;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__, r,
          v), "assigning variable z");
      current_statement__ = 162;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 163;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 164;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 165;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__, r,
          v), "assigning variable z");
      current_statement__ = 166;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, rd,
          vd), "assigning variable z");
      current_statement__ = 167;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, rd,
          v), "assigning variable z");
      current_statement__ = 168;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 169;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, r,
          v), "assigning variable z");
      current_statement__ = 170;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 171;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 172;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 173;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 174;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 175;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 176;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 177;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 178;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 179;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 180;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 181;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 182;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 183;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 184;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 185;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 186;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 187;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 188;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 189;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 190;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 191;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 192;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 193;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 194;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 195;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 196;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 197;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 198;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 199;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 200;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 201;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 202;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__, r,
          v), "assigning variable z");
      {
        current_statement__ = 400;
        stan::math::validate_non_negative_index("zm", "N", N);
        current_statement__ = 401;
        stan::math::validate_non_negative_index("zm", "N", N);
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> zm =
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
        current_statement__ = 402;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd,
            static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
          "assigning variable zm");
        current_statement__ = 403;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 404;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 405;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 406;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 407;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 408;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 409;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 410;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 411;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 412;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 413;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 414;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 415;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 416;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 417;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 418;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 419;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 420;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 421;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 422;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 423;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 424;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 425;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 426;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 427;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 428;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 429;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 430;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 431;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 432;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 433;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 434;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 435;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd,
            static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
          "assigning variable zm");
        current_statement__ = 436;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 437;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 438;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 439;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 440;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 441;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 442;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 443;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 444;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 445;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 446;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 447;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 448;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 449;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 450;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 451;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 452;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 453;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 454;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 455;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 456;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 457;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 458;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 459;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 460;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 461;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 462;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 463;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 464;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 465;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 466;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 467;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 468;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd,
            static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
          "assigning variable zm");
        current_statement__ = 469;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 470;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 471;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 472;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 473;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra,
            1e-6, 1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 474;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra,
            1e-6, 1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 475;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra,
            1e-6, 1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 476;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra,
            1e-6, 1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 477;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad,
            1e-6, 1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 478;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad,
            1e-6, 1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 479;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad,
            1e-6, 1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 480;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad,
            1e-6, 1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 481;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 482;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 483;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 484;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 485;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad,
            1e-6, 1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 486;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad,
            1e-6, 1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 487;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad,
            1e-6, 1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 488;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad,
            1e-6, 1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 489;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 490;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 491;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 492;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 493;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 494;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 495;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 496;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 497;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 498;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 499;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 500;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 501;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd,
            static_cast<double>(id), rad, pstream__, rd, vd),
          "assigning variable zm");
        current_statement__ = 502;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 503;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 504;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 505;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 506;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 507;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 508;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 509;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 510;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 511;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 512;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 513;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 514;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 515;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 516;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 517;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 518;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 519;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 520;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 521;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 522;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 523;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 524;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 525;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 526;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 527;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 528;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 529;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 530;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 531;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 532;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 533;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 534;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd,
            static_cast<double>(id), rad, pstream__, rd, vd),
          "assigning variable zm");
        current_statement__ = 535;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 536;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 537;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 538;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 539;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 540;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 541;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 542;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 543;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 544;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 545;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 546;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 547;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 548;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 549;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 550;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 551;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 552;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 553;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 554;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 555;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 556;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 557;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 558;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 559;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 560;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 561;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 562;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 563;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 564;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 565;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 566;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 567;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd,
            static_cast<double>(id), rad, pstream__, rd, vd),
          "assigning variable zm");
        current_statement__ = 568;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 569;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 570;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 571;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 572;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 573;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 574;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 575;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 576;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 577;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 578;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 579;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 580;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 581;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 582;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 583;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 584;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 585;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 586;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 587;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 588;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 589;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 590;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 591;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 592;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 593;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 594;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 595;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 596;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 597;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 598;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 599;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 600;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(r, 0, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "new_integrate_interface_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ r = DUMMY_VAR__;
      current_statement__ = 1;
      r = in__.template read<local_scalar_t__>();
      std::vector<local_scalar_t__> ra =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 2;
      ra = in__.template read<std::vector<local_scalar_t__>>(N);
      Eigen::Matrix<local_scalar_t__,-1,1> v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 3;
      v = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> z =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 4;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 6;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 7;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 8;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 9;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 10;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 11;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 12;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 13;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 14;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 15;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 16;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 17;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 18;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 19;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 20;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 21;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 22;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 23;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 24;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 25;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 26;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 27;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 28;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 29;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 30;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 31;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 32;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 33;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 34;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 35;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 36;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 37;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 38;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 39;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 40;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 41;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 42;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 43;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 44;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 45;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 46;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 47;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 48;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 49;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 50;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 51;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 52;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 53;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 54;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 55;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 56;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 57;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 58;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 59;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 60;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 61;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 62;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 63;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 64;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 65;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 66;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 67;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 68;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 69;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 70;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 71;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 72;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 73;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 74;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 75;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 76;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 77;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 78;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 79;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 80;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 81;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 82;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 83;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 84;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 85;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 86;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 87;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 88;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 89;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 90;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 91;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 92;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 93;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 94;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 95;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 96;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 97;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 98;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 99;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 100;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 101;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 102;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 103;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 104;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 105;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, rd, vd), "assigning variable z");
      current_statement__ = 106;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, rd, v), "assigning variable z");
      current_statement__ = 107;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, r, vd), "assigning variable z");
      current_statement__ = 108;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, r, v), "assigning variable z");
      current_statement__ = 109;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 110;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 111;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 112;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 113;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 114;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 115;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 116;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 117;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 118;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 119;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 120;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 121;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 122;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 123;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 124;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 125;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 126;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 127;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 128;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 129;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 130;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 131;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 132;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 133;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 134;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 135;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 136;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 137;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 138;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 139;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 140;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 141;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 142;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 143;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 144;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 145;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 146;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 147;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 148;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 149;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 150;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 151;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 152;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 153;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__, r,
          v), "assigning variable z");
      current_statement__ = 154;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 155;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 156;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 157;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 158;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 159;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 160;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 161;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__, r,
          v), "assigning variable z");
      current_statement__ = 162;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 163;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 164;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 165;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__, r,
          v), "assigning variable z");
      current_statement__ = 166;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, rd,
          vd), "assigning variable z");
      current_statement__ = 167;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, rd,
          v), "assigning variable z");
      current_statement__ = 168;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 169;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, r,
          v), "assigning variable z");
      current_statement__ = 170;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 171;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 172;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 173;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 174;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 175;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 176;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 177;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 178;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 179;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 180;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 181;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 182;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 183;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 184;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 185;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 186;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 187;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 188;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 189;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 190;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 191;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 192;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 193;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 194;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 195;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 196;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 197;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 198;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 199;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 200;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 201;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 202;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__, r,
          v), "assigning variable z");
      {
        current_statement__ = 400;
        stan::math::validate_non_negative_index("zm", "N", N);
        current_statement__ = 401;
        stan::math::validate_non_negative_index("zm", "N", N);
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> zm =
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
        current_statement__ = 402;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd,
            static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
          "assigning variable zm");
        current_statement__ = 403;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 404;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 405;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 406;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 407;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 408;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 409;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 410;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 411;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 412;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 413;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 414;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 415;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 416;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 417;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 418;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 419;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 420;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 421;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 422;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 423;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 424;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 425;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 426;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 427;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 428;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 429;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 430;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 431;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 432;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 433;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 434;
        stan::model::assign(zm,
          stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 435;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd,
            static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
          "assigning variable zm");
        current_statement__ = 436;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 437;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 438;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 439;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 440;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 441;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 442;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 443;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 444;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 445;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 446;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 447;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 448;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 449;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 450;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 451;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 452;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 453;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 454;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 455;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 456;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 457;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 458;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 459;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 460;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 461;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 462;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 463;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 464;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 465;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 466;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 467;
        stan::model::assign(zm,
          stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 468;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd,
            static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
          "assigning variable zm");
        current_statement__ = 469;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 470;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 471;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 472;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad,
            1e-6, 1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 473;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra,
            1e-6, 1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 474;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra,
            1e-6, 1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 475;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra,
            1e-6, 1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 476;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra,
            1e-6, 1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 477;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad,
            1e-6, 1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 478;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad,
            1e-6, 1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 479;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad,
            1e-6, 1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 480;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad,
            1e-6, 1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 481;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 482;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 483;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 484;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 485;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad,
            1e-6, 1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 486;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad,
            1e-6, 1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 487;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad,
            1e-6, 1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 488;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad,
            1e-6, 1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 489;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 490;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 491;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 492;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 493;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 494;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 495;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 496;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 497;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 498;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, rd, v), "assigning variable zm");
        current_statement__ = 499;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, r, vd), "assigning variable zm");
        current_statement__ = 500;
        stan::model::assign(zm,
          stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
            1e-6, 100, pstream__, r, v), "assigning variable zm");
        current_statement__ = 501;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd,
            static_cast<double>(id), rad, pstream__, rd, vd),
          "assigning variable zm");
        current_statement__ = 502;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 503;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 504;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 505;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 506;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 507;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 508;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 509;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 510;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 511;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 512;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 513;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 514;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 515;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 516;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 517;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 518;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 519;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 520;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 521;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 522;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 523;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 524;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 525;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 526;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 527;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 528;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 529;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 530;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 531;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 532;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 533;
        stan::model::assign(zm,
          stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 534;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd,
            static_cast<double>(id), rad, pstream__, rd, vd),
          "assigning variable zm");
        current_statement__ = 535;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 536;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 537;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 538;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 539;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 540;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 541;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 542;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 543;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 544;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 545;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 546;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 547;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 548;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 549;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 550;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 551;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 552;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 553;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 554;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 555;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 556;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 557;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 558;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 559;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 560;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 561;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 562;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 563;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 564;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 565;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 566;
        stan::model::assign(zm,
          stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 567;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd,
            static_cast<double>(id), rad, pstream__, rd, vd),
          "assigning variable zm");
        current_statement__ = 568;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad,
            pstream__, rd, vd), "assigning variable zm");
        current_statement__ = 569;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad,
            pstream__, rd, v), "assigning variable zm");
        current_statement__ = 570;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad,
            pstream__, r, vd), "assigning variable zm");
        current_statement__ = 571;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad,
            pstream__, r, v), "assigning variable zm");
        current_statement__ = 572;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 573;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 574;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 575;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 576;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 577;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 578;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 579;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 580;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 581;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 582;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 583;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 584;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 585;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 586;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 587;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 588;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 589;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 590;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 591;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 592;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 593;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 594;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 595;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 596;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__,
            rd, vd), "assigning variable zm");
        current_statement__ = 597;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__,
            rd, v), "assigning variable zm");
        current_statement__ = 598;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__,
            r, vd), "assigning variable zm");
        current_statement__ = 599;
        stan::model::assign(zm,
          stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__,
            r, v), "assigning variable zm");
        current_statement__ = 600;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(r, 0, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "new_integrate_interface_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double r = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      r = in__.template read<local_scalar_t__>();
      std::vector<double> ra =
        std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      ra = in__.template read<std::vector<local_scalar_t__>>(N);
      Eigen::Matrix<double,-1,1> v =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      v = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      std::vector<Eigen::Matrix<double,-1,1>> z =
        std::vector<Eigen::Matrix<double,-1,1>>(N,
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      out__.write(r);
      out__.write(ra);
      out__.write(v);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 4;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 6;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 7;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 8;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 9;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 10;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 11;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 12;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 13;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 14;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 15;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 16;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 17;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 18;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 19;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 20;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 21;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 22;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 23;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 24;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 25;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 26;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 27;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 28;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 29;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 30;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 31;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 32;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 33;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 34;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 35;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 36;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 37;
      stan::model::assign(z,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 38;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 39;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 40;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 41;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 42;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 43;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 44;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 45;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 46;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 47;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 48;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 49;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 50;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 51;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 52;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 53;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 54;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 55;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 56;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 57;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 58;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 59;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 60;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 61;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 62;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 63;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 64;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 65;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 66;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 67;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 68;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 69;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 70;
      stan::model::assign(z,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 71;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 72;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 73;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 74;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 75;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 76;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 77;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 78;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 79;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 80;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 81;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 82;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 83;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 84;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 85;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 86;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 87;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 88;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 89;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 90;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 91;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 92;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 93;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 94;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 95;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 96;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 97;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 98;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 99;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 100;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable z");
      current_statement__ = 101;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable z");
      current_statement__ = 102;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable z");
      current_statement__ = 103;
      stan::model::assign(z,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable z");
      current_statement__ = 104;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 105;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, rd, vd), "assigning variable z");
      current_statement__ = 106;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, rd, v), "assigning variable z");
      current_statement__ = 107;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, r, vd), "assigning variable z");
      current_statement__ = 108;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, r, v), "assigning variable z");
      current_statement__ = 109;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 110;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 111;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 112;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 113;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 114;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 115;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 116;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 117;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 118;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 119;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 120;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 121;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 122;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 123;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 124;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 125;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 126;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 127;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 128;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 129;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 130;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 131;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 132;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 133;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 134;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 135;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 136;
      stan::model::assign(z,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 137;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 138;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 139;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 140;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 141;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 142;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 143;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 144;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 145;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 146;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 147;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 148;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 149;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 150;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 151;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 152;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 153;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__, r,
          v), "assigning variable z");
      current_statement__ = 154;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 155;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 156;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 157;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 158;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 159;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 160;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 161;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__, r,
          v), "assigning variable z");
      current_statement__ = 162;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 163;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 164;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 165;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__, r,
          v), "assigning variable z");
      current_statement__ = 166;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, rd,
          vd), "assigning variable z");
      current_statement__ = 167;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, rd,
          v), "assigning variable z");
      current_statement__ = 168;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 169;
      stan::model::assign(z,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, r,
          v), "assigning variable z");
      current_statement__ = 170;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable z");
      current_statement__ = 171;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 172;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 173;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 174;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 175;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 176;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 177;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 178;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 179;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 180;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 181;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 182;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 183;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 184;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 185;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 186;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 187;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 188;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 189;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 190;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 191;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 192;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 193;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 194;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 195;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 196;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 197;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          r, vd), "assigning variable z");
      current_statement__ = 198;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          r, v), "assigning variable z");
      current_statement__ = 199;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, vd), "assigning variable z");
      current_statement__ = 200;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, v), "assigning variable z");
      current_statement__ = 201;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__, r,
          vd), "assigning variable z");
      current_statement__ = 202;
      stan::model::assign(z,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__, r,
          v), "assigning variable z");
      if (emit_transformed_parameters__) {
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            out__.write(z[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      std::vector<Eigen::Matrix<double,-1,1>> zg =
        std::vector<Eigen::Matrix<double,-1,1>>(N,
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 5;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable zg");
      current_statement__ = 203;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 204;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 205;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 206;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 207;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 208;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 209;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 210;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 211;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 212;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 213;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 214;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 215;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 216;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 217;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 218;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 219;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 220;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 221;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 222;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 223;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 224;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 225;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 226;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 227;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 228;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 229;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 230;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 231;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 232;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 233;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 234;
      stan::model::assign(zg,
        stan::math::ode_bdf_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 235;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable zg");
      current_statement__ = 236;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 237;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 238;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 239;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 240;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 241;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 242;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 243;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 244;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 245;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 246;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 247;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 248;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 249;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 250;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 251;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 252;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 253;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 254;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 255;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 256;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 257;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 258;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 259;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 260;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 261;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 262;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 263;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 264;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 265;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 266;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 267;
      stan::model::assign(zg,
        stan::math::ode_adams_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 268;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, 1e-6, 1e-6, 100, pstream__, rd, vd),
        "assigning variable zg");
      current_statement__ = 269;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 270;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 271;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 272;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 273;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 274;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 275;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 276;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 277;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 278;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 279;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 280;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 281;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 282;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 283;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 284;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), vd, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 285;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 286;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 287;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 288;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 289;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 290;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 291;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 292;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, rd, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 293;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 294;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 295;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 296;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, rad, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 297;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 298;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, rd, v), "assigning variable zg");
      current_statement__ = 299;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, vd), "assigning variable zg");
      current_statement__ = 300;
      stan::model::assign(zg,
        stan::math::ode_rk45_tol(f_variadic2_functor__(), v, r, ra, 1e-6,
          1e-6, 100, pstream__, r, v), "assigning variable zg");
      current_statement__ = 301;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable zg");
      current_statement__ = 302;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 303;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 304;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 305;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 306;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 307;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 308;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 309;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 310;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 311;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 312;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 313;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 314;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 315;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 316;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 317;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 318;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 319;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 320;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 321;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 322;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 323;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 324;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 325;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 326;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 327;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 328;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 329;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, rad, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 330;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 331;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 332;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__, r,
          vd), "assigning variable zg");
      current_statement__ = 333;
      stan::model::assign(zg,
        stan::math::ode_rk45(f_variadic2_functor__(), v, r, ra, pstream__, r,
          v), "assigning variable zg");
      current_statement__ = 334;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable zg");
      current_statement__ = 335;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, rd, vd), "assigning variable zg");
      current_statement__ = 336;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, rd, v), "assigning variable zg");
      current_statement__ = 337;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, r, vd), "assigning variable zg");
      current_statement__ = 338;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, rad,
          pstream__, r, v), "assigning variable zg");
      current_statement__ = 339;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 340;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 341;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 342;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 343;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 344;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 345;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 346;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 347;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 348;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 349;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 350;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), vd, r, ra, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 351;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 352;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 353;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 354;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 355;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 356;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 357;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 358;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, rd, ra, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 359;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 360;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 361;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 362;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, rad, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 363;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 364;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 365;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 366;
      stan::model::assign(zg,
        stan::math::ode_adams(f_variadic2_functor__(), v, r, ra, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 367;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd,
          static_cast<double>(id), rad, pstream__, rd, vd),
        "assigning variable zg");
      current_statement__ = 368;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 369;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 370;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 371;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, rad, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 372;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 373;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 374;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 375;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, rd, ra, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 376;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 377;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 378;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 379;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, rad, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 380;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 381;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 382;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__, r,
          vd), "assigning variable zg");
      current_statement__ = 383;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), vd, r, ra, pstream__, r,
          v), "assigning variable zg");
      current_statement__ = 384;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 385;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 386;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, vd), "assigning variable zg");
      current_statement__ = 387;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, rad, pstream__,
          r, v), "assigning variable zg");
      current_statement__ = 388;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 389;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 390;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__, r,
          vd), "assigning variable zg");
      current_statement__ = 391;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, rd, ra, pstream__, r,
          v), "assigning variable zg");
      current_statement__ = 392;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, vd), "assigning variable zg");
      current_statement__ = 393;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__,
          rd, v), "assigning variable zg");
      current_statement__ = 394;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__, r,
          vd), "assigning variable zg");
      current_statement__ = 395;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, rad, pstream__, r,
          v), "assigning variable zg");
      current_statement__ = 396;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, rd,
          vd), "assigning variable zg");
      current_statement__ = 397;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, rd,
          v), "assigning variable zg");
      current_statement__ = 398;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, r,
          vd), "assigning variable zg");
      current_statement__ = 399;
      stan::model::assign(zg,
        stan::math::ode_bdf(f_variadic2_functor__(), v, r, ra, pstream__, r,
          v), "assigning variable zg");
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(zg[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ r = DUMMY_VAR__;
      current_statement__ = 1;
      r = in__.read<local_scalar_t__>();
      out__.write(r);
      std::vector<local_scalar_t__> ra =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(ra, in__.read<std::vector<local_scalar_t__>>(N),
        "assigning variable ra");
      out__.write(ra);
      Eigen::Matrix<local_scalar_t__,-1,1> v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(v,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable v");
      out__.write(v);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "r", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "ra", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "v", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ r = DUMMY_VAR__;
      current_statement__ = 1;
      r = context__.vals_r("r")[(1 - 1)];
      out__.write(r);
      std::vector<local_scalar_t__> ra =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 2;
      ra = context__.vals_r("ra");
      out__.write(ra);
      Eigen::Matrix<local_scalar_t__,-1,1> v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> v_flat__;
        current_statement__ = 3;
        v_flat__ = context__.vals_r("v");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(v, v_flat__[(pos__ - 1)],
            "assigning variable v", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(v);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"r", "ra", "v"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"z"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string> temp{"zg"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(N)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(N)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "r");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "ra" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "v" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "z" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "zg" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "r");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "ra" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "v" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "z" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "zg" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"r\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"ra\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"zg\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"r\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"ra\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"zg\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((1 + N) + N);
    const size_t num_transformed = emit_transformed_parameters * ((N * N));
    const size_t num_gen_quantities = emit_generated_quantities * ((N * N));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((1 + N) + N);
    const size_t num_transformed = emit_transformed_parameters * ((N * N));
    const size_t num_gen_quantities = emit_generated_quantities * ((N * N));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = new_integrate_interface_model_namespace::new_integrate_interface_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return new_integrate_interface_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp old_integrate_interface.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace old_integrate_interface_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 35> locations_array__ =
  {" (found before start of program)",
  " (in 'old_integrate_interface.stan', line 28, column 2 to column 22)",
  " (in 'old_integrate_interface.stan', line 29, column 2 to column 21)",
  " (in 'old_integrate_interface.stan', line 30, column 2 to column 22)",
  " (in 'old_integrate_interface.stan', line 31, column 2 to column 22)",
  " (in 'old_integrate_interface.stan', line 32, column 2 to column 32)",
  " (in 'old_integrate_interface.stan', line 33, column 2 to column 31)",
  " (in 'old_integrate_interface.stan', line 36, column 2 to line 39, column 65)",
  " (in 'old_integrate_interface.stan', line 42, column 2 to column 25)",
  " (in 'old_integrate_interface.stan', line 43, column 2 to column 25)",
  " (in 'old_integrate_interface.stan', line 44, column 2 to column 28)",
  " (in 'old_integrate_interface.stan', line 45, column 2 to column 29)",
  " (in 'old_integrate_interface.stan', line 46, column 2 to column 27)",
  " (in 'old_integrate_interface.stan', line 47, column 2 to column 33)",
  " (in 'old_integrate_interface.stan', line 49, column 4 to column 52)",
  " (in 'old_integrate_interface.stan', line 50, column 4 to column 52)",
  " (in 'old_integrate_interface.stan', line 48, column 19 to line 51, column 3)",
  " (in 'old_integrate_interface.stan', line 48, column 2 to line 51, column 3)",
  " (in 'old_integrate_interface.stan', line 22, column 2 to column 17)",
  " (in 'old_integrate_interface.stan', line 23, column 8 to column 9)",
  " (in 'old_integrate_interface.stan', line 23, column 2 to column 19)",
  " (in 'old_integrate_interface.stan', line 24, column 2 to column 23)",
  " (in 'old_integrate_interface.stan', line 25, column 8 to column 9)",
  " (in 'old_integrate_interface.stan', line 25, column 2 to column 30)",
  " (in 'old_integrate_interface.stan', line 36, column 8 to column 9)",
  " (in 'old_integrate_interface.stan', line 8, column 4 to column 18)",
  " (in 'old_integrate_interface.stan', line 9, column 4 to column 18)",
  " (in 'old_integrate_interface.stan', line 11, column 4 to column 26)",
  " (in 'old_integrate_interface.stan', line 12, column 4 to column 25)",
  " (in 'old_integrate_interface.stan', line 13, column 4 to column 26)",
  " (in 'old_integrate_interface.stan', line 14, column 4 to column 26)",
  " (in 'old_integrate_interface.stan', line 16, column 4 to column 40)",
  " (in 'old_integrate_interface.stan', line 17, column 4 to column 42)",
  " (in 'old_integrate_interface.stan', line 18, column 4 to column 26)",
  " (in 'old_integrate_interface.stan', line 7, column 38 to line 19, column 3)"};
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_std_vector<T1__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T1__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T1__>>>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>,
                              stan::is_std_vector<T4__>,
                              std::is_integral<stan::value_type_t<T4__>>>* = nullptr>
std::vector<
  stan::promote_args_t<T0__, stan::base_type_t<T1__>,
    stan::base_type_t<T2__>, stan::base_type_t<T3__>>>
dz_dt(const T0__& t, const T1__& z, const T2__& theta, const T3__& x_r,
      const T4__& x_i, std::ostream* pstream__);
struct dz_dt_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            typename T4__,
            stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                        std::is_floating_point<T0__>>,
                                stan::is_std_vector<T1__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T1__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T1__>>>,
                                stan::is_std_vector<T2__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T2__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T2__>>>,
                                stan::is_std_vector<T3__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T3__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T3__>>>,
                                stan::is_std_vector<T4__>,
                                std::is_integral<stan::value_type_t<T4__>>>* = nullptr>
  std::vector<
    stan::promote_args_t<T0__, stan::base_type_t<T1__>,
      stan::base_type_t<T2__>, stan::base_type_t<T3__>>>
  operator()(const T0__& t, const T1__& z, const T2__& theta, const T3__&
             x_r, const T4__& x_i, std::ostream* pstream__) const {
    return dz_dt(t, z, theta, x_r, x_i, pstream__);
  }
};
/* array[] real
   dz_dt(real, array[] real, array[] real, array[] real, array[] int)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_std_vector<T1__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T1__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T1__>>>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>,
                              stan::is_std_vector<T4__>,
                              std::is_integral<stan::value_type_t<T4__>>>*>
std::vector<
  stan::promote_args_t<T0__, stan::base_type_t<T1__>,
    stan::base_type_t<T2__>, stan::base_type_t<T3__>>>
dz_dt(const T0__& t, const T1__& z, const T2__& theta, const T3__& x_r,
      const T4__& x_i, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
                             stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ u = DUMMY_VAR__;
    current_statement__ = 25;
    u = stan::model::rvalue(z, "z", stan::model::index_uni(1));
    local_scalar_t__ v = DUMMY_VAR__;
    current_statement__ = 26;
    v = stan::model::rvalue(z, "z", stan::model::index_uni(2));
    local_scalar_t__ alpha = DUMMY_VAR__;
    current_statement__ = 27;
    alpha = stan::model::rvalue(theta, "theta", stan::model::index_uni(1));
    local_scalar_t__ beta = DUMMY_VAR__;
    current_statement__ = 28;
    beta = stan::model::rvalue(theta, "theta", stan::model::index_uni(2));
    local_scalar_t__ gamma = DUMMY_VAR__;
    current_statement__ = 29;
    gamma = stan::model::rvalue(theta, "theta", stan::model::index_uni(3));
    local_scalar_t__ delta = DUMMY_VAR__;
    current_statement__ = 30;
    delta = stan::model::rvalue(theta, "theta", stan::model::index_uni(4));
    local_scalar_t__ du_dt = DUMMY_VAR__;
    current_statement__ = 31;
    du_dt = ((alpha - (beta * v)) * u);
    local_scalar_t__ dv_dt = DUMMY_VAR__;
    current_statement__ = 32;
    dv_dt = ((-(gamma) + (delta * u)) * v);
    current_statement__ = 33;
    return std::vector<local_scalar_t__>{du_dt, dv_dt};
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class old_integrate_interface_model final : public model_base_crtp<old_integrate_interface_model> {
 private:
  int N;
  std::vector<double> ts;
  std::vector<double> y_init;
  std::vector<std::vector<double>> y;
 public:
  ~old_integrate_interface_model() {}
  old_integrate_interface_model(stan::io::var_context& context__,
                                unsigned int random_seed__ = 0, std::ostream*
                                pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "old_integrate_interface_model_namespace::old_integrate_interface_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 18;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 18;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 18;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 19;
      stan::math::validate_non_negative_index("ts", "N", N);
      current_statement__ = 20;
      context__.validate_dims("data initialization", "ts", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      ts = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 20;
      ts = context__.vals_r("ts");
      current_statement__ = 21;
      context__.validate_dims("data initialization", "y_init", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      y_init = std::vector<double>(2,
                 std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 21;
      y_init = context__.vals_r("y_init");
      current_statement__ = 22;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 23;
      context__.validate_dims("data initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(2)});
      y = std::vector<std::vector<double>>(N,
            std::vector<double>(2, std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> y_flat__;
        current_statement__ = 23;
        y_flat__ = context__.vals_r("y");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 24;
      stan::math::validate_non_negative_index("z", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + 2 + 2;
  }
  inline std::string model_name() const final {
    return "old_integrate_interface_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "old_integrate_interface_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      local_scalar_t__ beta = DUMMY_VAR__;
      current_statement__ = 2;
      beta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      local_scalar_t__ gamma = DUMMY_VAR__;
      current_statement__ = 3;
      gamma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      local_scalar_t__ delta = DUMMY_VAR__;
      current_statement__ = 4;
      delta = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      std::vector<local_scalar_t__> z_init =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 5;
      z_init = in__.template read_constrain_lb<std::vector<local_scalar_t__>,
                 jacobian__>(0, lp__, 2);
      std::vector<local_scalar_t__> sigma =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 6;
      sigma = in__.template read_constrain_lb<std::vector<local_scalar_t__>,
                jacobian__>(0, lp__, 2);
      std::vector<std::vector<local_scalar_t__>> z =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(2, DUMMY_VAR__));
      current_statement__ = 7;
      stan::model::assign(z,
        stan::math::integrate_ode_bdf(dz_dt_functor__(), z_init,
          static_cast<double>(0), ts,
          std::vector<local_scalar_t__>{alpha, beta, gamma, delta},
          stan::math::rep_array(0.0, 0), stan::math::rep_array(0, 0),
          pstream__, 1e-5, 1e-3, 5e2), "assigning variable z");
      {
        current_statement__ = 8;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha, 1, 0.5));
        current_statement__ = 9;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(gamma, 1, 0.5));
        current_statement__ = 10;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(beta, 0.05, 0.05));
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(delta, 0.05, 0.05));
        current_statement__ = 12;
        lp_accum__.add(stan::math::lognormal_lpdf<propto__>(sigma, -(1), 1));
        current_statement__ = 13;
        lp_accum__.add(stan::math::lognormal_lpdf<propto__>(z_init,
                         stan::math::log(10), 1));
        current_statement__ = 17;
        for (int k = 1; k <= 2; ++k) {
          current_statement__ = 14;
          lp_accum__.add(stan::math::lognormal_lpdf<propto__>(
                           stan::model::rvalue(y_init, "y_init",
                             stan::model::index_uni(k)),
                           stan::math::log(
                             stan::model::rvalue(z_init, "z_init",
                               stan::model::index_uni(k))),
                           stan::model::rvalue(sigma, "sigma",
                             stan::model::index_uni(k))));
          current_statement__ = 15;
          lp_accum__.add(stan::math::lognormal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_omni(),
                             stan::model::index_uni(k)),
                           stan::math::log(
                             stan::model::rvalue(z, "z",
                               stan::model::index_omni(),
                               stan::model::index_uni(k))),
                           stan::model::rvalue(sigma, "sigma",
                             stan::model::index_uni(k))));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "old_integrate_interface_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      local_scalar_t__ beta = DUMMY_VAR__;
      current_statement__ = 2;
      beta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      local_scalar_t__ gamma = DUMMY_VAR__;
      current_statement__ = 3;
      gamma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      local_scalar_t__ delta = DUMMY_VAR__;
      current_statement__ = 4;
      delta = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      std::vector<local_scalar_t__> z_init =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 5;
      z_init = in__.template read_constrain_lb<std::vector<local_scalar_t__>,
                 jacobian__>(0, lp__, 2);
      std::vector<local_scalar_t__> sigma =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 6;
      sigma = in__.template read_constrain_lb<std::vector<local_scalar_t__>,
                jacobian__>(0, lp__, 2);
      std::vector<std::vector<local_scalar_t__>> z =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(2, DUMMY_VAR__));
      current_statement__ = 7;
      stan::model::assign(z,
        stan::math::integrate_ode_bdf(dz_dt_functor__(), z_init,
          static_cast<double>(0), ts,
          std::vector<local_scalar_t__>{alpha, beta, gamma, delta},
          stan::math::rep_array(0.0, 0), stan::math::rep_array(0, 0),
          pstream__, 1e-5, 1e-3, 5e2), "assigning variable z");
      {
        current_statement__ = 8;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha, 1, 0.5));
        current_statement__ = 9;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(gamma, 1, 0.5));
        current_statement__ = 10;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(beta, 0.05, 0.05));
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(delta, 0.05, 0.05));
        current_statement__ = 12;
        lp_accum__.add(stan::math::lognormal_lpdf<propto__>(sigma, -(1), 1));
        current_statement__ = 13;
        lp_accum__.add(stan::math::lognormal_lpdf<propto__>(z_init,
                         stan::math::log(10), 1));
        current_statement__ = 17;
        for (int k = 1; k <= 2; ++k) {
          current_statement__ = 14;
          lp_accum__.add(stan::math::lognormal_lpdf<propto__>(
                           stan::model::rvalue(y_init, "y_init",
                             stan::model::index_uni(k)),
                           stan::math::log(
                             stan::model::rvalue(z_init, "z_init",
                               stan::model::index_uni(k))),
                           stan::model::rvalue(sigma, "sigma",
                             stan::model::index_uni(k))));
          current_statement__ = 15;
          lp_accum__.add(stan::math::lognormal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_omni(),
                             stan::model::index_uni(k)),
                           stan::math::log(
                             stan::model::rvalue(z, "z",
                               stan::model::index_omni(),
                               stan::model::index_uni(k))),
                           stan::model::rvalue(sigma, "sigma",
                             stan::model::index_uni(k))));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "old_integrate_interface_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double alpha = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      alpha = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      double beta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      beta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      double gamma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      gamma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      double delta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      delta = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      std::vector<double> z_init =
        std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      z_init = in__.template read_constrain_lb<std::vector<local_scalar_t__>,
                 jacobian__>(0, lp__, 2);
      std::vector<double> sigma =
        std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 6;
      sigma = in__.template read_constrain_lb<std::vector<local_scalar_t__>,
                jacobian__>(0, lp__, 2);
      std::vector<std::vector<double>> z =
        std::vector<std::vector<double>>(N,
          std::vector<double>(2, std::numeric_limits<double>::quiet_NaN()));
      out__.write(alpha);
      out__.write(beta);
      out__.write(gamma);
      out__.write(delta);
      out__.write(z_init);
      out__.write(sigma);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 7;
      stan::model::assign(z,
        stan::math::integrate_ode_bdf(dz_dt_functor__(), z_init,
          static_cast<double>(0), ts,
          std::vector<local_scalar_t__>{alpha, beta, gamma, delta},
          stan::math::rep_array(0.0, 0), stan::math::rep_array(0, 0),
          pstream__, 1e-5, 1e-3, 5e2), "assigning variable z");
      if (emit_transformed_parameters__) {
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            out__.write(z[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, alpha);
      local_scalar_t__ beta = DUMMY_VAR__;
      current_statement__ = 2;
      beta = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, beta);
      local_scalar_t__ gamma = DUMMY_VAR__;
      current_statement__ = 3;
      gamma = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, gamma);
      local_scalar_t__ delta = DUMMY_VAR__;
      current_statement__ = 4;
      delta = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, delta);
      std::vector<local_scalar_t__> z_init =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(z_init,
        in__.read<std::vector<local_scalar_t__>>(2),
        "assigning variable z_init");
      out__.write_free_lb(0, z_init);
      std::vector<local_scalar_t__> sigma =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(sigma, in__.read<std::vector<local_scalar_t__>>(2),
        "assigning variable sigma");
      out__.write_free_lb(0, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "alpha", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "beta", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "gamma", "double",
        std::vector<size_t>{});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "delta", "double",
        std::vector<size_t>{});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "z_init", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "sigma", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = context__.vals_r("alpha")[(1 - 1)];
      out__.write_free_lb(0, alpha);
      local_scalar_t__ beta = DUMMY_VAR__;
      current_statement__ = 2;
      beta = context__.vals_r("beta")[(1 - 1)];
      out__.write_free_lb(0, beta);
      local_scalar_t__ gamma = DUMMY_VAR__;
      current_statement__ = 3;
      gamma = context__.vals_r("gamma")[(1 - 1)];
      out__.write_free_lb(0, gamma);
      local_scalar_t__ delta = DUMMY_VAR__;
      current_statement__ = 4;
      delta = context__.vals_r("delta")[(1 - 1)];
      out__.write_free_lb(0, delta);
      std::vector<local_scalar_t__> z_init =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 5;
      z_init = context__.vals_r("z_init");
      out__.write_free_lb(0, z_init);
      std::vector<local_scalar_t__> sigma =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 6;
      sigma = context__.vals_r("sigma");
      out__.write_free_lb(0, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"alpha", "beta", "gamma", "delta",
                "z_init", "sigma"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"z"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(2)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(2)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha");
    param_names__.emplace_back(std::string() + "beta");
    param_names__.emplace_back(std::string() + "gamma");
    param_names__.emplace_back(std::string() + "delta");
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "z_init" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "sigma" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "z" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha");
    param_names__.emplace_back(std::string() + "beta");
    param_names__.emplace_back(std::string() + "gamma");
    param_names__.emplace_back(std::string() + "delta");
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "z_init" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "sigma" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "z" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"z_init\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"z_init\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((1 + 1) + 1) + 1) + 2) + 2);
    const size_t num_transformed = emit_transformed_parameters * ((N * 2));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((1 + 1) + 1) + 1) + 2) + 2);
    const size_t num_transformed = emit_transformed_parameters * ((N * 2));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = old_integrate_interface_model_namespace::old_integrate_interface_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return old_integrate_interface_model_namespace::profiles__;
}
#endif
Warning in 'old_integrate_interface.stan', line 36, column 23: integrate_ode_bdf
    is deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../../install/default/bin/stanc --print-cpp optimize_glm.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace optimize_glm_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 217> locations_array__ =
  {" (found before start of program)",
  " (in 'optimize_glm.stan', line 25, column 2 to column 20)",
  " (in 'optimize_glm.stan', line 26, column 2 to column 17)",
  " (in 'optimize_glm.stan', line 27, column 2 to column 17)",
  " (in 'optimize_glm.stan', line 28, column 2 to column 22)",
  " (in 'optimize_glm.stan', line 29, column 2 to column 13)",
  " (in 'optimize_glm.stan', line 30, column 2 to column 11)",
  " (in 'optimize_glm.stan', line 31, column 2 to column 19)",
  " (in 'optimize_glm.stan', line 32, column 2 to column 22)",
  " (in 'optimize_glm.stan', line 33, column 2 to column 23)",
  " (in 'optimize_glm.stan', line 36, column 2 to column 64)",
  " (in 'optimize_glm.stan', line 37, column 2 to column 49)",
  " (in 'optimize_glm.stan', line 39, column 2 to column 64)",
  " (in 'optimize_glm.stan', line 40, column 2 to column 49)",
  " (in 'optimize_glm.stan', line 42, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 43, column 2 to column 48)",
  " (in 'optimize_glm.stan', line 45, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 46, column 2 to column 48)",
  " (in 'optimize_glm.stan', line 48, column 2 to column 66)",
  " (in 'optimize_glm.stan', line 49, column 2 to column 51)",
  " (in 'optimize_glm.stan', line 51, column 2 to column 66)",
  " (in 'optimize_glm.stan', line 52, column 2 to column 51)",
  " (in 'optimize_glm.stan', line 54, column 2 to column 70)",
  " (in 'optimize_glm.stan', line 55, column 2 to column 55)",
  " (in 'optimize_glm.stan', line 57, column 2 to column 67)",
  " (in 'optimize_glm.stan', line 58, column 2 to column 52)",
  " (in 'optimize_glm.stan', line 60, column 2 to column 69)",
  " (in 'optimize_glm.stan', line 61, column 2 to column 54)",
  " (in 'optimize_glm.stan', line 63, column 2 to column 66)",
  " (in 'optimize_glm.stan', line 64, column 2 to column 51)",
  " (in 'optimize_glm.stan', line 66, column 2 to column 72)",
  " (in 'optimize_glm.stan', line 67, column 2 to column 57)",
  " (in 'optimize_glm.stan', line 69, column 2 to column 69)",
  " (in 'optimize_glm.stan', line 70, column 2 to column 54)",
  " (in 'optimize_glm.stan', line 72, column 2 to column 64)",
  " (in 'optimize_glm.stan', line 73, column 2 to column 49)",
  " (in 'optimize_glm.stan', line 75, column 2 to column 64)",
  " (in 'optimize_glm.stan', line 76, column 2 to column 49)",
  " (in 'optimize_glm.stan', line 78, column 2 to column 67)",
  " (in 'optimize_glm.stan', line 79, column 2 to column 52)",
  " (in 'optimize_glm.stan', line 81, column 2 to column 67)",
  " (in 'optimize_glm.stan', line 82, column 2 to column 52)",
  " (in 'optimize_glm.stan', line 84, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 85, column 2 to column 48)",
  " (in 'optimize_glm.stan', line 87, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 88, column 2 to column 48)",
  " (in 'optimize_glm.stan', line 90, column 2 to column 70)",
  " (in 'optimize_glm.stan', line 91, column 2 to column 55)",
  " (in 'optimize_glm.stan', line 93, column 2 to column 67)",
  " (in 'optimize_glm.stan', line 94, column 2 to column 52)",
  " (in 'optimize_glm.stan', line 96, column 2 to column 73)",
  " (in 'optimize_glm.stan', line 97, column 2 to column 58)",
  " (in 'optimize_glm.stan', line 99, column 2 to column 70)",
  " (in 'optimize_glm.stan', line 100, column 2 to column 55)",
  " (in 'optimize_glm.stan', line 102, column 2 to column 69)",
  " (in 'optimize_glm.stan', line 103, column 2 to column 54)",
  " (in 'optimize_glm.stan', line 105, column 2 to column 66)",
  " (in 'optimize_glm.stan', line 106, column 2 to column 51)",
  " (in 'optimize_glm.stan', line 108, column 2 to column 60)",
  " (in 'optimize_glm.stan', line 109, column 2 to column 45)",
  " (in 'optimize_glm.stan', line 111, column 2 to column 60)",
  " (in 'optimize_glm.stan', line 112, column 2 to column 45)",
  " (in 'optimize_glm.stan', line 114, column 2 to column 59)",
  " (in 'optimize_glm.stan', line 115, column 2 to column 44)",
  " (in 'optimize_glm.stan', line 117, column 2 to column 59)",
  " (in 'optimize_glm.stan', line 118, column 2 to column 44)",
  " (in 'optimize_glm.stan', line 120, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 121, column 2 to column 48)",
  " (in 'optimize_glm.stan', line 123, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 124, column 2 to column 48)",
  " (in 'optimize_glm.stan', line 126, column 2 to column 66)",
  " (in 'optimize_glm.stan', line 127, column 2 to column 51)",
  " (in 'optimize_glm.stan', line 129, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 130, column 2 to column 48)",
  " (in 'optimize_glm.stan', line 132, column 2 to column 65)",
  " (in 'optimize_glm.stan', line 133, column 2 to column 50)",
  " (in 'optimize_glm.stan', line 135, column 2 to column 62)",
  " (in 'optimize_glm.stan', line 136, column 2 to column 47)",
  " (in 'optimize_glm.stan', line 138, column 2 to column 69)",
  " (in 'optimize_glm.stan', line 139, column 2 to column 54)",
  " (in 'optimize_glm.stan', line 141, column 2 to column 66)",
  " (in 'optimize_glm.stan', line 142, column 2 to column 51)",
  " (in 'optimize_glm.stan', line 144, column 2 to column 72)",
  " (in 'optimize_glm.stan', line 145, column 2 to column 57)",
  " (in 'optimize_glm.stan', line 147, column 2 to column 72)",
  " (in 'optimize_glm.stan', line 148, column 2 to column 57)",
  " (in 'optimize_glm.stan', line 150, column 2 to column 71)",
  " (in 'optimize_glm.stan', line 151, column 2 to column 56)",
  " (in 'optimize_glm.stan', line 153, column 2 to column 71)",
  " (in 'optimize_glm.stan', line 154, column 2 to column 56)",
  " (in 'optimize_glm.stan', line 156, column 2 to column 75)",
  " (in 'optimize_glm.stan', line 157, column 2 to column 60)",
  " (in 'optimize_glm.stan', line 159, column 2 to column 75)",
  " (in 'optimize_glm.stan', line 160, column 2 to column 60)",
  " (in 'optimize_glm.stan', line 162, column 2 to column 78)",
  " (in 'optimize_glm.stan', line 163, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 165, column 2 to column 75)",
  " (in 'optimize_glm.stan', line 166, column 2 to column 60)",
  " (in 'optimize_glm.stan', line 168, column 2 to column 77)",
  " (in 'optimize_glm.stan', line 169, column 2 to column 62)",
  " (in 'optimize_glm.stan', line 171, column 2 to column 74)",
  " (in 'optimize_glm.stan', line 172, column 2 to column 59)",
  " (in 'optimize_glm.stan', line 174, column 2 to column 81)",
  " (in 'optimize_glm.stan', line 175, column 2 to column 66)",
  " (in 'optimize_glm.stan', line 177, column 2 to column 78)",
  " (in 'optimize_glm.stan', line 178, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 180, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 181, column 2 to column 48)",
  " (in 'optimize_glm.stan', line 183, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 184, column 2 to column 48)",
  " (in 'optimize_glm.stan', line 186, column 2 to column 69)",
  " (in 'optimize_glm.stan', line 187, column 2 to column 54)",
  " (in 'optimize_glm.stan', line 189, column 2 to column 66)",
  " (in 'optimize_glm.stan', line 190, column 2 to column 51)",
  " (in 'optimize_glm.stan', line 192, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 193, column 2 to column 48)",
  " (in 'optimize_glm.stan', line 195, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 196, column 2 to column 48)",
  " (in 'optimize_glm.stan', line 198, column 2 to column 69)",
  " (in 'optimize_glm.stan', line 199, column 2 to column 54)",
  " (in 'optimize_glm.stan', line 201, column 2 to column 66)",
  " (in 'optimize_glm.stan', line 202, column 2 to column 51)",
  " (in 'optimize_glm.stan', line 204, column 2 to column 66)",
  " (in 'optimize_glm.stan', line 205, column 2 to column 51)",
  " (in 'optimize_glm.stan', line 207, column 2 to column 66)",
  " (in 'optimize_glm.stan', line 208, column 2 to column 51)",
  " (in 'optimize_glm.stan', line 210, column 2 to column 64)",
  " (in 'optimize_glm.stan', line 211, column 2 to column 49)",
  " (in 'optimize_glm.stan', line 213, column 2 to column 64)",
  " (in 'optimize_glm.stan', line 214, column 2 to column 49)",
  " (in 'optimize_glm.stan', line 216, column 2 to column 70)",
  " (in 'optimize_glm.stan', line 217, column 2 to column 55)",
  " (in 'optimize_glm.stan', line 219, column 2 to column 67)",
  " (in 'optimize_glm.stan', line 220, column 2 to column 52)",
  " (in 'optimize_glm.stan', line 222, column 2 to column 67)",
  " (in 'optimize_glm.stan', line 223, column 2 to column 52)",
  " (in 'optimize_glm.stan', line 225, column 2 to column 67)",
  " (in 'optimize_glm.stan', line 226, column 2 to column 52)",
  " (in 'optimize_glm.stan', line 228, column 2 to column 69)",
  " (in 'optimize_glm.stan', line 229, column 2 to column 54)",
  " (in 'optimize_glm.stan', line 231, column 2 to column 69)",
  " (in 'optimize_glm.stan', line 232, column 2 to column 54)",
  " (in 'optimize_glm.stan', line 234, column 2 to column 75)",
  " (in 'optimize_glm.stan', line 235, column 2 to column 60)",
  " (in 'optimize_glm.stan', line 237, column 2 to column 72)",
  " (in 'optimize_glm.stan', line 238, column 2 to column 57)",
  " (in 'optimize_glm.stan', line 240, column 2 to column 72)",
  " (in 'optimize_glm.stan', line 241, column 2 to column 57)",
  " (in 'optimize_glm.stan', line 243, column 2 to column 72)",
  " (in 'optimize_glm.stan', line 244, column 2 to column 57)",
  " (in 'optimize_glm.stan', line 246, column 2 to column 78)",
  " (in 'optimize_glm.stan', line 247, column 2 to column 63)",
  " (in 'optimize_glm.stan', line 249, column 2 to column 75)",
  " (in 'optimize_glm.stan', line 250, column 2 to column 60)",
  " (in 'optimize_glm.stan', line 252, column 2 to column 70)",
  " (in 'optimize_glm.stan', line 253, column 2 to column 55)",
  " (in 'optimize_glm.stan', line 255, column 2 to column 70)",
  " (in 'optimize_glm.stan', line 256, column 2 to column 55)",
  " (in 'optimize_glm.stan', line 258, column 2 to column 76)",
  " (in 'optimize_glm.stan', line 259, column 2 to column 61)",
  " (in 'optimize_glm.stan', line 261, column 2 to column 73)",
  " (in 'optimize_glm.stan', line 262, column 2 to column 58)",
  " (in 'optimize_glm.stan', line 264, column 2 to column 73)",
  " (in 'optimize_glm.stan', line 265, column 2 to column 58)",
  " (in 'optimize_glm.stan', line 267, column 2 to column 73)",
  " (in 'optimize_glm.stan', line 268, column 2 to column 58)",
  " (in 'optimize_glm.stan', line 270, column 2 to column 79)",
  " (in 'optimize_glm.stan', line 271, column 2 to column 64)",
  " (in 'optimize_glm.stan', line 273, column 2 to column 76)",
  " (in 'optimize_glm.stan', line 274, column 2 to column 61)",
  " (in 'optimize_glm.stan', line 276, column 2 to column 74)",
  " (in 'optimize_glm.stan', line 277, column 2 to column 59)",
  " (in 'optimize_glm.stan', line 279, column 2 to column 77)",
  " (in 'optimize_glm.stan', line 280, column 2 to column 62)",
  " (in 'optimize_glm.stan', line 282, column 2 to column 69)",
  " (in 'optimize_glm.stan', line 283, column 2 to column 54)",
  " (in 'optimize_glm.stan', line 2, column 2 to column 17)",
  " (in 'optimize_glm.stan', line 3, column 2 to column 17)",
  " (in 'optimize_glm.stan', line 4, column 9 to column 10)",
  " (in 'optimize_glm.stan', line 4, column 12 to column 13)",
  " (in 'optimize_glm.stan', line 4, column 2 to column 19)",
  " (in 'optimize_glm.stan', line 5, column 18 to column 19)",
  " (in 'optimize_glm.stan', line 5, column 21 to column 22)",
  " (in 'optimize_glm.stan', line 5, column 2 to column 30)",
  " (in 'optimize_glm.stan', line 6, column 9 to column 10)",
  " (in 'optimize_glm.stan', line 6, column 2 to column 18)",
  " (in 'optimize_glm.stan', line 7, column 13 to column 14)",
  " (in 'optimize_glm.stan', line 7, column 2 to column 23)",
  " (in 'optimize_glm.stan', line 8, column 8 to column 9)",
  " (in 'optimize_glm.stan', line 8, column 2 to column 22)",
  " (in 'optimize_glm.stan', line 9, column 8 to column 9)",
  " (in 'optimize_glm.stan', line 9, column 2 to column 23)",
  " (in 'optimize_glm.stan', line 10, column 2 to column 12)",
  " (in 'optimize_glm.stan', line 11, column 2 to column 13)",
  " (in 'optimize_glm.stan', line 14, column 2 to column 20)",
  " (in 'optimize_glm.stan', line 15, column 2 to column 20)",
  " (in 'optimize_glm.stan', line 16, column 9 to column 10)",
  " (in 'optimize_glm.stan', line 16, column 12 to column 13)",
  " (in 'optimize_glm.stan', line 16, column 2 to column 22)",
  " (in 'optimize_glm.stan', line 17, column 9 to column 10)",
  " (in 'optimize_glm.stan', line 17, column 2 to column 21)",
  " (in 'optimize_glm.stan', line 18, column 13 to column 14)",
  " (in 'optimize_glm.stan', line 18, column 2 to column 26)",
  " (in 'optimize_glm.stan', line 19, column 8 to column 9)",
  " (in 'optimize_glm.stan', line 19, column 2 to column 25)",
  " (in 'optimize_glm.stan', line 20, column 8 to column 9)",
  " (in 'optimize_glm.stan', line 20, column 2 to column 26)",
  " (in 'optimize_glm.stan', line 21, column 2 to column 15)",
  " (in 'optimize_glm.stan', line 22, column 2 to column 16)",
  " (in 'optimize_glm.stan', line 25, column 9 to column 10)",
  " (in 'optimize_glm.stan', line 26, column 9 to column 10)",
  " (in 'optimize_glm.stan', line 27, column 9 to column 10)",
  " (in 'optimize_glm.stan', line 31, column 9 to column 10)",
  " (in 'optimize_glm.stan', line 31, column 12 to column 13)",
  " (in 'optimize_glm.stan', line 32, column 9 to column 10)",
  " (in 'optimize_glm.stan', line 32, column 12 to column 13)",
  " (in 'optimize_glm.stan', line 33, column 13 to column 14)"};
class optimize_glm_model final : public model_base_crtp<optimize_glm_model> {
 private:
  int k;
  int n;
  Eigen::Matrix<double,-1,-1> X_d_data__;
  std::vector<Eigen::Matrix<double,-1,-1>> X_d_a;
  Eigen::Matrix<double,-1,1> y_v_d_data__;
  Eigen::Matrix<double,1,-1> X_rv_d_data__;
  std::vector<int> y_vi_d;
  std::vector<int> y2_vi_d;
  int y_s_d;
  double y_r_d;
  int k_td;
  int n_td;
  Eigen::Matrix<double,-1,-1> X_d_td_data__;
  Eigen::Matrix<double,-1,1> y_v_d_td_data__;
  Eigen::Matrix<double,1,-1> X_rv_d_td_data__;
  std::vector<int> y_vi_d_td;
  std::vector<int> y2_vi_d_td;
  int y_s_d_td;
  double y_r_d_td;
  Eigen::Map<Eigen::Matrix<double,-1,-1>> X_d{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> y_v_d{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,1,-1>> X_rv_d{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> X_d_td{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> y_v_d_td{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,1,-1>> X_rv_d_td{nullptr, 0};
 public:
  ~optimize_glm_model() {}
  optimize_glm_model(stan::io::var_context& context__, unsigned int
                     random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "optimize_glm_model_namespace::optimize_glm_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 176;
      context__.validate_dims("data initialization", "k", "int",
        std::vector<size_t>{});
      k = std::numeric_limits<int>::min();
      current_statement__ = 176;
      k = context__.vals_i("k")[(1 - 1)];
      current_statement__ = 176;
      stan::math::check_greater_or_equal(function__, "k", k, 1);
      current_statement__ = 177;
      context__.validate_dims("data initialization", "n", "int",
        std::vector<size_t>{});
      n = std::numeric_limits<int>::min();
      current_statement__ = 177;
      n = context__.vals_i("n")[(1 - 1)];
      current_statement__ = 177;
      stan::math::check_greater_or_equal(function__, "n", n, 0);
      current_statement__ = 178;
      stan::math::validate_non_negative_index("X_d", "n", n);
      current_statement__ = 179;
      stan::math::validate_non_negative_index("X_d", "k", k);
      current_statement__ = 180;
      context__.validate_dims("data initialization", "X_d", "double",
        std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(k)});
      X_d_data__ = Eigen::Matrix<double,-1,-1>::Constant(n, k,
                     std::numeric_limits<double>::quiet_NaN());
      new (&X_d) Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_d_data__.data(),
        n, k);
      {
        std::vector<local_scalar_t__> X_d_flat__;
        current_statement__ = 180;
        X_d_flat__ = context__.vals_r("X_d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
              "assigning variable X_d", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 181;
      stan::math::validate_non_negative_index("X_d_a", "n", n);
      current_statement__ = 182;
      stan::math::validate_non_negative_index("X_d_a", "k", k);
      current_statement__ = 183;
      context__.validate_dims("data initialization", "X_d_a", "double",
        std::vector<size_t>{static_cast<size_t>(2), static_cast<size_t>(n),
          static_cast<size_t>(k)});
      X_d_a = std::vector<Eigen::Matrix<double,-1,-1>>(2,
                Eigen::Matrix<double,-1,-1>::Constant(n, k,
                  std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> X_d_a_flat__;
        current_statement__ = 183;
        X_d_a_flat__ = context__.vals_r("X_d_a");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
              stan::model::assign(X_d_a, X_d_a_flat__[(pos__ - 1)],
                "assigning variable X_d_a", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 184;
      stan::math::validate_non_negative_index("y_v_d", "n", n);
      current_statement__ = 185;
      context__.validate_dims("data initialization", "y_v_d", "double",
        std::vector<size_t>{static_cast<size_t>(n)});
      y_v_d_data__ = Eigen::Matrix<double,-1,1>::Constant(n,
                       std::numeric_limits<double>::quiet_NaN());
      new (&y_v_d)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(y_v_d_data__.data(), n);
      {
        std::vector<local_scalar_t__> y_v_d_flat__;
        current_statement__ = 185;
        y_v_d_flat__ = context__.vals_r("y_v_d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          stan::model::assign(y_v_d, y_v_d_flat__[(pos__ - 1)],
            "assigning variable y_v_d", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 186;
      stan::math::validate_non_negative_index("X_rv_d", "n", n);
      current_statement__ = 187;
      context__.validate_dims("data initialization", "X_rv_d", "double",
        std::vector<size_t>{static_cast<size_t>(n)});
      X_rv_d_data__ = Eigen::Matrix<double,1,-1>::Constant(n,
                        std::numeric_limits<double>::quiet_NaN());
      new (&X_rv_d)
        Eigen::Map<Eigen::Matrix<double,1,-1>>(X_rv_d_data__.data(), n);
      {
        std::vector<local_scalar_t__> X_rv_d_flat__;
        current_statement__ = 187;
        X_rv_d_flat__ = context__.vals_r("X_rv_d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          stan::model::assign(X_rv_d, X_rv_d_flat__[(pos__ - 1)],
            "assigning variable X_rv_d", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 188;
      stan::math::validate_non_negative_index("y_vi_d", "n", n);
      current_statement__ = 189;
      context__.validate_dims("data initialization", "y_vi_d", "int",
        std::vector<size_t>{static_cast<size_t>(n)});
      y_vi_d = std::vector<int>(n, std::numeric_limits<int>::min());
      current_statement__ = 189;
      y_vi_d = context__.vals_i("y_vi_d");
      current_statement__ = 190;
      stan::math::validate_non_negative_index("y2_vi_d", "n", n);
      current_statement__ = 191;
      context__.validate_dims("data initialization", "y2_vi_d", "int",
        std::vector<size_t>{static_cast<size_t>(n)});
      y2_vi_d = std::vector<int>(n, std::numeric_limits<int>::min());
      current_statement__ = 191;
      y2_vi_d = context__.vals_i("y2_vi_d");
      current_statement__ = 192;
      context__.validate_dims("data initialization", "y_s_d", "int",
        std::vector<size_t>{});
      y_s_d = std::numeric_limits<int>::min();
      current_statement__ = 192;
      y_s_d = context__.vals_i("y_s_d")[(1 - 1)];
      current_statement__ = 193;
      context__.validate_dims("data initialization", "y_r_d", "double",
        std::vector<size_t>{});
      y_r_d = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 193;
      y_r_d = context__.vals_r("y_r_d")[(1 - 1)];
      current_statement__ = 194;
      k_td = std::numeric_limits<int>::min();
      current_statement__ = 195;
      n_td = std::numeric_limits<int>::min();
      current_statement__ = 196;
      stan::math::validate_non_negative_index("X_d_td", "n", n);
      current_statement__ = 197;
      stan::math::validate_non_negative_index("X_d_td", "k", k);
      current_statement__ = 198;
      X_d_td_data__ = Eigen::Matrix<double,-1,-1>::Constant(n, k,
                        std::numeric_limits<double>::quiet_NaN());
      new (&X_d_td)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_d_td_data__.data(), n, k);
      current_statement__ = 199;
      stan::math::validate_non_negative_index("y_v_d_td", "n", n);
      current_statement__ = 200;
      y_v_d_td_data__ = Eigen::Matrix<double,-1,1>::Constant(n,
                          std::numeric_limits<double>::quiet_NaN());
      new (&y_v_d_td)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(y_v_d_td_data__.data(), n);
      current_statement__ = 201;
      stan::math::validate_non_negative_index("X_rv_d_td", "n", n);
      current_statement__ = 202;
      X_rv_d_td_data__ = Eigen::Matrix<double,1,-1>::Constant(n,
                           std::numeric_limits<double>::quiet_NaN());
      new (&X_rv_d_td)
        Eigen::Map<Eigen::Matrix<double,1,-1>>(X_rv_d_td_data__.data(), n);
      current_statement__ = 203;
      stan::math::validate_non_negative_index("y_vi_d_td", "n", n);
      current_statement__ = 204;
      y_vi_d_td = std::vector<int>(n, std::numeric_limits<int>::min());
      current_statement__ = 205;
      stan::math::validate_non_negative_index("y2_vi_d_td", "n", n);
      current_statement__ = 206;
      y2_vi_d_td = std::vector<int>(n, std::numeric_limits<int>::min());
      current_statement__ = 207;
      y_s_d_td = std::numeric_limits<int>::min();
      current_statement__ = 208;
      y_r_d_td = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 194;
      stan::math::check_greater_or_equal(function__, "k_td", k_td, 1);
      current_statement__ = 195;
      stan::math::check_greater_or_equal(function__, "n_td", n_td, 0);
      current_statement__ = 209;
      stan::math::validate_non_negative_index("alpha_v", "k", k);
      current_statement__ = 210;
      stan::math::validate_non_negative_index("beta", "k", k);
      current_statement__ = 211;
      stan::math::validate_non_negative_index("cuts", "k", k);
      current_statement__ = 212;
      stan::math::validate_non_negative_index("X_p", "n", n);
      current_statement__ = 213;
      stan::math::validate_non_negative_index("X_p", "k", k);
      current_statement__ = 214;
      stan::math::validate_non_negative_index("beta_m", "n", n);
      current_statement__ = 215;
      stan::math::validate_non_negative_index("beta_m", "k", k);
      current_statement__ = 216;
      stan::math::validate_non_negative_index("X_rv_p", "n", n);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = k + k + k + 1 + 1 + 1 + (n * k) + (n * k) + n;
  }
  inline std::string model_name() const final {
    return "optimize_glm_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "optimize_glm_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> alpha_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 1;
      alpha_v = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(k);
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 2;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(k);
      Eigen::Matrix<local_scalar_t__,-1,1> cuts =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 3;
      cuts = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(k);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 4;
      sigma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 5;
      alpha = in__.template read<local_scalar_t__>();
      local_scalar_t__ phi = DUMMY_VAR__;
      current_statement__ = 6;
      phi = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, k, DUMMY_VAR__);
      current_statement__ = 7;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(n, k);
      Eigen::Matrix<local_scalar_t__,-1,-1> beta_m =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, k, DUMMY_VAR__);
      current_statement__ = 8;
      beta_m = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(n,
                 k);
      Eigen::Matrix<local_scalar_t__,1,-1> X_rv_p =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(n, DUMMY_VAR__);
      current_statement__ = 9;
      X_rv_p = in__.template read<Eigen::Matrix<local_scalar_t__,1,-1>>(n);
      {
        current_statement__ = 10;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d, X_d,
                         alpha, beta, sigma));
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d, X_d,
                         alpha, beta, sigma));
        current_statement__ = 12;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d, X_p,
                         alpha, beta, sigma));
        current_statement__ = 13;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d, X_p,
                         alpha, beta, sigma));
        current_statement__ = 14;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_r_d, X_d,
                         alpha, beta, beta));
        current_statement__ = 15;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_r_d, X_d,
                         alpha, beta, beta));
        current_statement__ = 16;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_r_d, X_p,
                         alpha, beta, beta));
        current_statement__ = 17;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_r_d, X_p,
                         alpha, beta, beta));
        current_statement__ = 18;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d, X_rv_d,
                         alpha, beta, beta));
        current_statement__ = 19;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d,
                         X_rv_d, alpha, beta, beta));
        current_statement__ = 20;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d, X_rv_p,
                         alpha, beta, beta));
        current_statement__ = 21;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d,
                         X_rv_p, alpha, beta, beta));
        current_statement__ = 22;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d_td,
                         X_d_td, alpha, beta, sigma));
        current_statement__ = 23;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d_td,
                         X_d_td, alpha, beta, sigma));
        current_statement__ = 24;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d_td, X_p,
                         alpha, beta, sigma));
        current_statement__ = 25;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d_td,
                         X_p, alpha, beta, sigma));
        current_statement__ = 26;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_r_d_td,
                         X_d_td, alpha, beta, beta));
        current_statement__ = 27;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_r_d_td,
                         X_d_td, alpha, beta, beta));
        current_statement__ = 28;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_r_d_td, X_p,
                         alpha, beta, beta));
        current_statement__ = 29;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_r_d_td,
                         X_p, alpha, beta, beta));
        current_statement__ = 30;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d_td,
                         X_rv_d_td, alpha, beta, beta));
        current_statement__ = 31;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d_td,
                         X_rv_d_td, alpha, beta, beta));
        current_statement__ = 32;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d_td,
                         X_rv_p, alpha, beta, beta));
        current_statement__ = 33;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d_td,
                         X_rv_p, alpha, beta, beta));
        current_statement__ = 34;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d,
                         X_d, alpha, beta));
        current_statement__ = 35;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(y_vi_d,
                         X_d, alpha, beta));
        current_statement__ = 36;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d,
                         X_p, alpha, beta));
        current_statement__ = 37;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(y_vi_d,
                         X_p, alpha, beta));
        current_statement__ = 38;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d,
                         X_rv_d, alpha, beta));
        current_statement__ = 39;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(y_vi_d,
                         X_rv_d, alpha, beta));
        current_statement__ = 40;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d,
                         X_rv_p, alpha, beta));
        current_statement__ = 41;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(y_vi_d,
                         X_rv_p, alpha, beta));
        current_statement__ = 42;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_s_d,
                         X_d, alpha, beta));
        current_statement__ = 43;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(y_s_d,
                         X_d, alpha, beta));
        current_statement__ = 44;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_s_d,
                         X_p, alpha, beta));
        current_statement__ = 45;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(y_s_d,
                         X_p, alpha, beta));
        current_statement__ = 46;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d_td,
                         X_d_td, alpha, beta));
        current_statement__ = 47;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_d_td, alpha, beta));
        current_statement__ = 48;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d_td,
                         X_p, alpha, beta));
        current_statement__ = 49;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_p, alpha, beta));
        current_statement__ = 50;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d_td,
                         X_rv_d_td, alpha, beta));
        current_statement__ = 51;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_rv_d_td, alpha, beta));
        current_statement__ = 52;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d_td,
                         X_rv_p, alpha, beta));
        current_statement__ = 53;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_rv_p, alpha, beta));
        current_statement__ = 54;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_s_d_td,
                         X_d_td, alpha, beta));
        current_statement__ = 55;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(
                         y_s_d_td, X_d_td, alpha, beta));
        current_statement__ = 56;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_s_d_td,
                         X_p, alpha, beta));
        current_statement__ = 57;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(
                         y_s_d_td, X_p, alpha, beta));
        current_statement__ = 58;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d, X_d,
                         alpha, beta));
        current_statement__ = 59;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d,
                         X_d, alpha, beta));
        current_statement__ = 60;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d, X_p,
                         alpha, beta));
        current_statement__ = 61;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d,
                         X_p, alpha, beta));
        current_statement__ = 62;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_s_d, X_d,
                         alpha, beta));
        current_statement__ = 63;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_s_d, X_d,
                         alpha, beta));
        current_statement__ = 64;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_s_d, X_p,
                         alpha, beta));
        current_statement__ = 65;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_s_d, X_p,
                         alpha, beta));
        current_statement__ = 66;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d,
                         X_rv_d, alpha, beta));
        current_statement__ = 67;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d,
                         X_rv_d, alpha, beta));
        current_statement__ = 68;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d,
                         X_rv_p, alpha, beta));
        current_statement__ = 69;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d,
                         X_rv_p, alpha, beta));
        current_statement__ = 70;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d_td,
                         X_d_td, alpha, beta));
        current_statement__ = 71;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d_td,
                         X_d_td, alpha, beta));
        current_statement__ = 72;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d_td,
                         X_p, alpha, beta));
        current_statement__ = 73;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d_td,
                         X_p, alpha, beta));
        current_statement__ = 74;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_s_d_td,
                         X_d_td, alpha, beta));
        current_statement__ = 75;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_s_d_td,
                         X_d_td, alpha, beta));
        current_statement__ = 76;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_s_d_td, X_p,
                         alpha, beta));
        current_statement__ = 77;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_s_d_td,
                         X_p, alpha, beta));
        current_statement__ = 78;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d_td,
                         X_rv_d_td, alpha, beta));
        current_statement__ = 79;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d_td,
                         X_rv_d_td, alpha, beta));
        current_statement__ = 80;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d_td,
                         X_rv_p, alpha, beta));
        current_statement__ = 81;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d_td,
                         X_rv_p, alpha, beta));
        current_statement__ = 82;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(y_vi_d,
                         X_d, alpha, beta, phi));
        current_statement__ = 83;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d, X_d, alpha, beta, phi));
        current_statement__ = 84;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(y_vi_d,
                         X_p, alpha, beta, phi));
        current_statement__ = 85;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d, X_p, alpha, beta, phi));
        current_statement__ = 86;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(y_s_d,
                         X_d, alpha, beta, phi));
        current_statement__ = 87;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_s_d, X_d, alpha, beta, phi));
        current_statement__ = 88;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(y_s_d,
                         X_p, alpha, beta, phi));
        current_statement__ = 89;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_s_d, X_p, alpha, beta, phi));
        current_statement__ = 90;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(y_vi_d,
                         X_rv_d, alpha, beta, phi));
        current_statement__ = 91;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d, X_rv_d, alpha, beta, phi));
        current_statement__ = 92;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(y_vi_d,
                         X_rv_p, alpha, beta, phi));
        current_statement__ = 93;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d, X_rv_p, alpha, beta, phi));
        current_statement__ = 94;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(
                         y_vi_d_td, X_d_td, alpha, beta, phi));
        current_statement__ = 95;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d_td, X_d_td, alpha, beta, phi));
        current_statement__ = 96;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(
                         y_vi_d_td, X_p, alpha, beta, phi));
        current_statement__ = 97;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d_td, X_p, alpha, beta, phi));
        current_statement__ = 98;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(
                         y_s_d_td, X_d_td, alpha, beta, phi));
        current_statement__ = 99;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_s_d_td, X_d_td, alpha, beta, phi));
        current_statement__ = 100;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(
                         y_s_d_td, X_p, alpha, beta, phi));
        current_statement__ = 101;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_s_d_td, X_p, alpha, beta, phi));
        current_statement__ = 102;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(
                         y_vi_d_td, X_rv_d_td, alpha, beta, phi));
        current_statement__ = 103;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d_td, X_rv_d_td, alpha, beta, phi));
        current_statement__ = 104;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(
                         y_vi_d_td, X_rv_p, alpha, beta, phi));
        current_statement__ = 105;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d_td, X_rv_p, alpha, beta, phi));
        current_statement__ = 106;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d,
                         X_d, beta, cuts));
        current_statement__ = 107;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(y_s_d,
                         X_d, beta, cuts));
        current_statement__ = 108;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d,
                         X_p, beta, cuts));
        current_statement__ = 109;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(y_s_d,
                         X_p, beta, cuts));
        current_statement__ = 110;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d_td,
                         X_d_td, beta, cuts));
        current_statement__ = 111;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_s_d_td, X_d_td, beta, cuts));
        current_statement__ = 112;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d_td,
                         X_p, beta, cuts));
        current_statement__ = 113;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_s_d_td, X_p, beta, cuts));
        current_statement__ = 114;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d,
                         X_d, beta, cuts));
        current_statement__ = 115;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(y_s_d,
                         X_d, beta, cuts));
        current_statement__ = 116;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d,
                         X_p, beta, cuts));
        current_statement__ = 117;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(y_s_d,
                         X_p, beta, cuts));
        current_statement__ = 118;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d_td,
                         X_d_td, beta, cuts));
        current_statement__ = 119;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_s_d_td, X_d_td, beta, cuts));
        current_statement__ = 120;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d_td,
                         X_p, beta, cuts));
        current_statement__ = 121;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_s_d_td, X_p, beta, cuts));
        current_statement__ = 122;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d,
                         X_rv_d, beta, cuts));
        current_statement__ = 123;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(y_s_d,
                         X_rv_d, beta, cuts));
        current_statement__ = 124;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d,
                         X_rv_p, beta, cuts));
        current_statement__ = 125;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(y_s_d,
                         X_rv_p, beta, cuts));
        current_statement__ = 126;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_vi_d,
                         X_d, beta, cuts));
        current_statement__ = 127;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_vi_d, X_d, beta, cuts));
        current_statement__ = 128;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_vi_d,
                         X_p, beta, cuts));
        current_statement__ = 129;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_vi_d, X_p, beta, cuts));
        current_statement__ = 130;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(
                         y_vi_d_td, X_d_td, beta, cuts));
        current_statement__ = 131;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_vi_d_td, X_d_td, beta, cuts));
        current_statement__ = 132;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(
                         y_vi_d_td, X_p, beta, cuts));
        current_statement__ = 133;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_vi_d_td, X_p, beta, cuts));
        current_statement__ = 134;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_vi_d,
                         X_rv_d, beta, cuts));
        current_statement__ = 135;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_vi_d, X_rv_d, beta, cuts));
        current_statement__ = 136;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_vi_d,
                         X_rv_p, beta, cuts));
        current_statement__ = 137;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_vi_d, X_rv_p, beta, cuts));
        current_statement__ = 138;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_s_d,
                         X_d, alpha_v, beta_m));
        current_statement__ = 139;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d, X_d, alpha_v, beta_m));
        current_statement__ = 140;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_s_d,
                         X_p, alpha_v, beta_m));
        current_statement__ = 141;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d, X_p, alpha_v, beta_m));
        current_statement__ = 142;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_s_d_td, X_d_td, alpha_v, beta_m));
        current_statement__ = 143;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d_td, X_d_td, alpha_v, beta_m));
        current_statement__ = 144;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_s_d_td, X_p, alpha_v, beta_m));
        current_statement__ = 145;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d_td, X_p, alpha_v, beta_m));
        current_statement__ = 146;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_s_d,
                         X_rv_d, alpha_v, beta_m));
        current_statement__ = 147;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d, X_rv_d, alpha_v, beta_m));
        current_statement__ = 148;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_s_d,
                         X_rv_p, alpha_v, beta_m));
        current_statement__ = 149;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d, X_rv_p, alpha_v, beta_m));
        current_statement__ = 150;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_s_d_td, X_rv_d_td, alpha_v, beta_m));
        current_statement__ = 151;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d_td, X_rv_d_td, alpha_v, beta_m));
        current_statement__ = 152;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_s_d_td, X_rv_p, alpha_v, beta_m));
        current_statement__ = 153;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d_td, X_rv_p, alpha_v, beta_m));
        current_statement__ = 154;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_vi_d,
                         X_d, alpha_v, beta_m));
        current_statement__ = 155;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d, X_d, alpha_v, beta_m));
        current_statement__ = 156;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_vi_d,
                         X_p, alpha_v, beta_m));
        current_statement__ = 157;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d, X_p, alpha_v, beta_m));
        current_statement__ = 158;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_vi_d_td, X_d_td, alpha_v, beta_m));
        current_statement__ = 159;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_d_td, alpha_v, beta_m));
        current_statement__ = 160;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_vi_d_td, X_p, alpha_v, beta_m));
        current_statement__ = 161;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_p, alpha_v, beta_m));
        current_statement__ = 162;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_vi_d,
                         X_rv_d, alpha_v, beta_m));
        current_statement__ = 163;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d, X_rv_d, alpha_v, beta_m));
        current_statement__ = 164;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_vi_d,
                         X_rv_p, alpha_v, beta_m));
        current_statement__ = 165;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d, X_rv_p, alpha_v, beta_m));
        current_statement__ = 166;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_vi_d_td, X_rv_d_td, alpha_v, beta_m));
        current_statement__ = 167;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_rv_d_td, alpha_v, beta_m));
        current_statement__ = 168;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_vi_d_td, X_rv_p, alpha_v, beta_m));
        current_statement__ = 169;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_rv_p, alpha_v, beta_m));
        current_statement__ = 170;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y2_vi_d,
                         X_rv_p, alpha_v, beta_m));
        current_statement__ = 171;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y2_vi_d, X_rv_p, alpha_v, beta_m));
        current_statement__ = 172;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y2_vi_d_td, X_rv_p, alpha_v, beta_m));
        current_statement__ = 173;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y2_vi_d_td, X_rv_p, alpha_v, beta_m));
        current_statement__ = 174;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d,
                         stan::model::rvalue(X_d_a, "X_d_a",
                           stan::model::index_uni(1)), alpha, beta, sigma));
        current_statement__ = 175;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d,
                         stan::model::rvalue(X_d_a, "X_d_a",
                           stan::model::index_uni(1)), alpha, beta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "optimize_glm_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> alpha_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 1;
      alpha_v = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(k);
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 2;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(k);
      Eigen::Matrix<local_scalar_t__,-1,1> cuts =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 3;
      cuts = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(k);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 4;
      sigma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 5;
      alpha = in__.template read<local_scalar_t__>();
      local_scalar_t__ phi = DUMMY_VAR__;
      current_statement__ = 6;
      phi = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, k, DUMMY_VAR__);
      current_statement__ = 7;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(n, k);
      Eigen::Matrix<local_scalar_t__,-1,-1> beta_m =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, k, DUMMY_VAR__);
      current_statement__ = 8;
      beta_m = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(n,
                 k);
      Eigen::Matrix<local_scalar_t__,1,-1> X_rv_p =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(n, DUMMY_VAR__);
      current_statement__ = 9;
      X_rv_p = in__.template read<Eigen::Matrix<local_scalar_t__,1,-1>>(n);
      {
        current_statement__ = 10;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d, X_d,
                         alpha, beta, sigma));
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d, X_d,
                         alpha, beta, sigma));
        current_statement__ = 12;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d, X_p,
                         alpha, beta, sigma));
        current_statement__ = 13;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d, X_p,
                         alpha, beta, sigma));
        current_statement__ = 14;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_r_d, X_d,
                         alpha, beta, beta));
        current_statement__ = 15;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_r_d, X_d,
                         alpha, beta, beta));
        current_statement__ = 16;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_r_d, X_p,
                         alpha, beta, beta));
        current_statement__ = 17;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_r_d, X_p,
                         alpha, beta, beta));
        current_statement__ = 18;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d, X_rv_d,
                         alpha, beta, beta));
        current_statement__ = 19;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d,
                         X_rv_d, alpha, beta, beta));
        current_statement__ = 20;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d, X_rv_p,
                         alpha, beta, beta));
        current_statement__ = 21;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d,
                         X_rv_p, alpha, beta, beta));
        current_statement__ = 22;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d_td,
                         X_d_td, alpha, beta, sigma));
        current_statement__ = 23;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d_td,
                         X_d_td, alpha, beta, sigma));
        current_statement__ = 24;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d_td, X_p,
                         alpha, beta, sigma));
        current_statement__ = 25;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d_td,
                         X_p, alpha, beta, sigma));
        current_statement__ = 26;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_r_d_td,
                         X_d_td, alpha, beta, beta));
        current_statement__ = 27;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_r_d_td,
                         X_d_td, alpha, beta, beta));
        current_statement__ = 28;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_r_d_td, X_p,
                         alpha, beta, beta));
        current_statement__ = 29;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_r_d_td,
                         X_p, alpha, beta, beta));
        current_statement__ = 30;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d_td,
                         X_rv_d_td, alpha, beta, beta));
        current_statement__ = 31;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d_td,
                         X_rv_d_td, alpha, beta, beta));
        current_statement__ = 32;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d_td,
                         X_rv_p, alpha, beta, beta));
        current_statement__ = 33;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d_td,
                         X_rv_p, alpha, beta, beta));
        current_statement__ = 34;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d,
                         X_d, alpha, beta));
        current_statement__ = 35;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(y_vi_d,
                         X_d, alpha, beta));
        current_statement__ = 36;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d,
                         X_p, alpha, beta));
        current_statement__ = 37;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(y_vi_d,
                         X_p, alpha, beta));
        current_statement__ = 38;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d,
                         X_rv_d, alpha, beta));
        current_statement__ = 39;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(y_vi_d,
                         X_rv_d, alpha, beta));
        current_statement__ = 40;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d,
                         X_rv_p, alpha, beta));
        current_statement__ = 41;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(y_vi_d,
                         X_rv_p, alpha, beta));
        current_statement__ = 42;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_s_d,
                         X_d, alpha, beta));
        current_statement__ = 43;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(y_s_d,
                         X_d, alpha, beta));
        current_statement__ = 44;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_s_d,
                         X_p, alpha, beta));
        current_statement__ = 45;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(y_s_d,
                         X_p, alpha, beta));
        current_statement__ = 46;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d_td,
                         X_d_td, alpha, beta));
        current_statement__ = 47;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_d_td, alpha, beta));
        current_statement__ = 48;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d_td,
                         X_p, alpha, beta));
        current_statement__ = 49;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_p, alpha, beta));
        current_statement__ = 50;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d_td,
                         X_rv_d_td, alpha, beta));
        current_statement__ = 51;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_rv_d_td, alpha, beta));
        current_statement__ = 52;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_vi_d_td,
                         X_rv_p, alpha, beta));
        current_statement__ = 53;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_rv_p, alpha, beta));
        current_statement__ = 54;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_s_d_td,
                         X_d_td, alpha, beta));
        current_statement__ = 55;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(
                         y_s_d_td, X_d_td, alpha, beta));
        current_statement__ = 56;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<false>(y_s_d_td,
                         X_p, alpha, beta));
        current_statement__ = 57;
        lp_accum__.add(stan::math::bernoulli_logit_glm_lpmf<propto__>(
                         y_s_d_td, X_p, alpha, beta));
        current_statement__ = 58;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d, X_d,
                         alpha, beta));
        current_statement__ = 59;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d,
                         X_d, alpha, beta));
        current_statement__ = 60;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d, X_p,
                         alpha, beta));
        current_statement__ = 61;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d,
                         X_p, alpha, beta));
        current_statement__ = 62;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_s_d, X_d,
                         alpha, beta));
        current_statement__ = 63;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_s_d, X_d,
                         alpha, beta));
        current_statement__ = 64;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_s_d, X_p,
                         alpha, beta));
        current_statement__ = 65;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_s_d, X_p,
                         alpha, beta));
        current_statement__ = 66;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d,
                         X_rv_d, alpha, beta));
        current_statement__ = 67;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d,
                         X_rv_d, alpha, beta));
        current_statement__ = 68;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d,
                         X_rv_p, alpha, beta));
        current_statement__ = 69;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d,
                         X_rv_p, alpha, beta));
        current_statement__ = 70;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d_td,
                         X_d_td, alpha, beta));
        current_statement__ = 71;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d_td,
                         X_d_td, alpha, beta));
        current_statement__ = 72;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d_td,
                         X_p, alpha, beta));
        current_statement__ = 73;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d_td,
                         X_p, alpha, beta));
        current_statement__ = 74;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_s_d_td,
                         X_d_td, alpha, beta));
        current_statement__ = 75;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_s_d_td,
                         X_d_td, alpha, beta));
        current_statement__ = 76;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_s_d_td, X_p,
                         alpha, beta));
        current_statement__ = 77;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_s_d_td,
                         X_p, alpha, beta));
        current_statement__ = 78;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d_td,
                         X_rv_d_td, alpha, beta));
        current_statement__ = 79;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d_td,
                         X_rv_d_td, alpha, beta));
        current_statement__ = 80;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<false>(y_vi_d_td,
                         X_rv_p, alpha, beta));
        current_statement__ = 81;
        lp_accum__.add(stan::math::poisson_log_glm_lpmf<propto__>(y_vi_d_td,
                         X_rv_p, alpha, beta));
        current_statement__ = 82;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(y_vi_d,
                         X_d, alpha, beta, phi));
        current_statement__ = 83;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d, X_d, alpha, beta, phi));
        current_statement__ = 84;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(y_vi_d,
                         X_p, alpha, beta, phi));
        current_statement__ = 85;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d, X_p, alpha, beta, phi));
        current_statement__ = 86;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(y_s_d,
                         X_d, alpha, beta, phi));
        current_statement__ = 87;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_s_d, X_d, alpha, beta, phi));
        current_statement__ = 88;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(y_s_d,
                         X_p, alpha, beta, phi));
        current_statement__ = 89;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_s_d, X_p, alpha, beta, phi));
        current_statement__ = 90;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(y_vi_d,
                         X_rv_d, alpha, beta, phi));
        current_statement__ = 91;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d, X_rv_d, alpha, beta, phi));
        current_statement__ = 92;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(y_vi_d,
                         X_rv_p, alpha, beta, phi));
        current_statement__ = 93;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d, X_rv_p, alpha, beta, phi));
        current_statement__ = 94;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(
                         y_vi_d_td, X_d_td, alpha, beta, phi));
        current_statement__ = 95;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d_td, X_d_td, alpha, beta, phi));
        current_statement__ = 96;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(
                         y_vi_d_td, X_p, alpha, beta, phi));
        current_statement__ = 97;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d_td, X_p, alpha, beta, phi));
        current_statement__ = 98;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(
                         y_s_d_td, X_d_td, alpha, beta, phi));
        current_statement__ = 99;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_s_d_td, X_d_td, alpha, beta, phi));
        current_statement__ = 100;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(
                         y_s_d_td, X_p, alpha, beta, phi));
        current_statement__ = 101;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_s_d_td, X_p, alpha, beta, phi));
        current_statement__ = 102;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(
                         y_vi_d_td, X_rv_d_td, alpha, beta, phi));
        current_statement__ = 103;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d_td, X_rv_d_td, alpha, beta, phi));
        current_statement__ = 104;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<false>(
                         y_vi_d_td, X_rv_p, alpha, beta, phi));
        current_statement__ = 105;
        lp_accum__.add(stan::math::neg_binomial_2_log_glm_lpmf<propto__>(
                         y_vi_d_td, X_rv_p, alpha, beta, phi));
        current_statement__ = 106;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d,
                         X_d, beta, cuts));
        current_statement__ = 107;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(y_s_d,
                         X_d, beta, cuts));
        current_statement__ = 108;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d,
                         X_p, beta, cuts));
        current_statement__ = 109;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(y_s_d,
                         X_p, beta, cuts));
        current_statement__ = 110;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d_td,
                         X_d_td, beta, cuts));
        current_statement__ = 111;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_s_d_td, X_d_td, beta, cuts));
        current_statement__ = 112;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d_td,
                         X_p, beta, cuts));
        current_statement__ = 113;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_s_d_td, X_p, beta, cuts));
        current_statement__ = 114;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d,
                         X_d, beta, cuts));
        current_statement__ = 115;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(y_s_d,
                         X_d, beta, cuts));
        current_statement__ = 116;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d,
                         X_p, beta, cuts));
        current_statement__ = 117;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(y_s_d,
                         X_p, beta, cuts));
        current_statement__ = 118;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d_td,
                         X_d_td, beta, cuts));
        current_statement__ = 119;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_s_d_td, X_d_td, beta, cuts));
        current_statement__ = 120;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d_td,
                         X_p, beta, cuts));
        current_statement__ = 121;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_s_d_td, X_p, beta, cuts));
        current_statement__ = 122;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d,
                         X_rv_d, beta, cuts));
        current_statement__ = 123;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(y_s_d,
                         X_rv_d, beta, cuts));
        current_statement__ = 124;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_s_d,
                         X_rv_p, beta, cuts));
        current_statement__ = 125;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(y_s_d,
                         X_rv_p, beta, cuts));
        current_statement__ = 126;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_vi_d,
                         X_d, beta, cuts));
        current_statement__ = 127;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_vi_d, X_d, beta, cuts));
        current_statement__ = 128;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_vi_d,
                         X_p, beta, cuts));
        current_statement__ = 129;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_vi_d, X_p, beta, cuts));
        current_statement__ = 130;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(
                         y_vi_d_td, X_d_td, beta, cuts));
        current_statement__ = 131;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_vi_d_td, X_d_td, beta, cuts));
        current_statement__ = 132;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(
                         y_vi_d_td, X_p, beta, cuts));
        current_statement__ = 133;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_vi_d_td, X_p, beta, cuts));
        current_statement__ = 134;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_vi_d,
                         X_rv_d, beta, cuts));
        current_statement__ = 135;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_vi_d, X_rv_d, beta, cuts));
        current_statement__ = 136;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<false>(y_vi_d,
                         X_rv_p, beta, cuts));
        current_statement__ = 137;
        lp_accum__.add(stan::math::ordered_logistic_glm_lpmf<propto__>(
                         y_vi_d, X_rv_p, beta, cuts));
        current_statement__ = 138;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_s_d,
                         X_d, alpha_v, beta_m));
        current_statement__ = 139;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d, X_d, alpha_v, beta_m));
        current_statement__ = 140;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_s_d,
                         X_p, alpha_v, beta_m));
        current_statement__ = 141;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d, X_p, alpha_v, beta_m));
        current_statement__ = 142;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_s_d_td, X_d_td, alpha_v, beta_m));
        current_statement__ = 143;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d_td, X_d_td, alpha_v, beta_m));
        current_statement__ = 144;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_s_d_td, X_p, alpha_v, beta_m));
        current_statement__ = 145;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d_td, X_p, alpha_v, beta_m));
        current_statement__ = 146;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_s_d,
                         X_rv_d, alpha_v, beta_m));
        current_statement__ = 147;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d, X_rv_d, alpha_v, beta_m));
        current_statement__ = 148;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_s_d,
                         X_rv_p, alpha_v, beta_m));
        current_statement__ = 149;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d, X_rv_p, alpha_v, beta_m));
        current_statement__ = 150;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_s_d_td, X_rv_d_td, alpha_v, beta_m));
        current_statement__ = 151;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d_td, X_rv_d_td, alpha_v, beta_m));
        current_statement__ = 152;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_s_d_td, X_rv_p, alpha_v, beta_m));
        current_statement__ = 153;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_s_d_td, X_rv_p, alpha_v, beta_m));
        current_statement__ = 154;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_vi_d,
                         X_d, alpha_v, beta_m));
        current_statement__ = 155;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d, X_d, alpha_v, beta_m));
        current_statement__ = 156;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_vi_d,
                         X_p, alpha_v, beta_m));
        current_statement__ = 157;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d, X_p, alpha_v, beta_m));
        current_statement__ = 158;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_vi_d_td, X_d_td, alpha_v, beta_m));
        current_statement__ = 159;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_d_td, alpha_v, beta_m));
        current_statement__ = 160;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_vi_d_td, X_p, alpha_v, beta_m));
        current_statement__ = 161;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_p, alpha_v, beta_m));
        current_statement__ = 162;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_vi_d,
                         X_rv_d, alpha_v, beta_m));
        current_statement__ = 163;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d, X_rv_d, alpha_v, beta_m));
        current_statement__ = 164;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y_vi_d,
                         X_rv_p, alpha_v, beta_m));
        current_statement__ = 165;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d, X_rv_p, alpha_v, beta_m));
        current_statement__ = 166;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_vi_d_td, X_rv_d_td, alpha_v, beta_m));
        current_statement__ = 167;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_rv_d_td, alpha_v, beta_m));
        current_statement__ = 168;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y_vi_d_td, X_rv_p, alpha_v, beta_m));
        current_statement__ = 169;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y_vi_d_td, X_rv_p, alpha_v, beta_m));
        current_statement__ = 170;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(y2_vi_d,
                         X_rv_p, alpha_v, beta_m));
        current_statement__ = 171;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y2_vi_d, X_rv_p, alpha_v, beta_m));
        current_statement__ = 172;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<false>(
                         y2_vi_d_td, X_rv_p, alpha_v, beta_m));
        current_statement__ = 173;
        lp_accum__.add(stan::math::categorical_logit_glm_lpmf<propto__>(
                         y2_vi_d_td, X_rv_p, alpha_v, beta_m));
        current_statement__ = 174;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<false>(y_v_d,
                         stan::model::rvalue(X_d_a, "X_d_a",
                           stan::model::index_uni(1)), alpha, beta, sigma));
        current_statement__ = 175;
        lp_accum__.add(stan::math::normal_id_glm_lpdf<propto__>(y_v_d,
                         stan::model::rvalue(X_d_a, "X_d_a",
                           stan::model::index_uni(1)), alpha, beta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "optimize_glm_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,1> alpha_v =
        Eigen::Matrix<double,-1,1>::Constant(k,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      alpha_v = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(k);
      Eigen::Matrix<double,-1,1> beta =
        Eigen::Matrix<double,-1,1>::Constant(k,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(k);
      Eigen::Matrix<double,-1,1> cuts =
        Eigen::Matrix<double,-1,1>::Constant(k,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      cuts = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(k);
      double sigma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      sigma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      double alpha = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      alpha = in__.template read<local_scalar_t__>();
      double phi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 6;
      phi = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,-1> X_p =
        Eigen::Matrix<double,-1,-1>::Constant(n, k,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 7;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(n, k);
      Eigen::Matrix<double,-1,-1> beta_m =
        Eigen::Matrix<double,-1,-1>::Constant(n, k,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 8;
      beta_m = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(n,
                 k);
      Eigen::Matrix<double,1,-1> X_rv_p =
        Eigen::Matrix<double,1,-1>::Constant(n,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 9;
      X_rv_p = in__.template read<Eigen::Matrix<local_scalar_t__,1,-1>>(n);
      out__.write(alpha_v);
      out__.write(beta);
      out__.write(cuts);
      out__.write(sigma);
      out__.write(alpha);
      out__.write(phi);
      out__.write(X_p);
      out__.write(beta_m);
      out__.write(X_rv_p);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> alpha_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(alpha_v,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(k),
        "assigning variable alpha_v");
      out__.write(alpha_v);
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(beta,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(k),
        "assigning variable beta");
      out__.write(beta);
      Eigen::Matrix<local_scalar_t__,-1,1> cuts =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(cuts,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(k),
        "assigning variable cuts");
      out__.write(cuts);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 4;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma);
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 5;
      alpha = in__.read<local_scalar_t__>();
      out__.write(alpha);
      local_scalar_t__ phi = DUMMY_VAR__;
      current_statement__ = 6;
      phi = in__.read<local_scalar_t__>();
      out__.write(phi);
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, k, DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(X_p,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(n, k),
        "assigning variable X_p");
      out__.write(X_p);
      Eigen::Matrix<local_scalar_t__,-1,-1> beta_m =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, k, DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(beta_m,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(n, k),
        "assigning variable beta_m");
      out__.write(beta_m);
      Eigen::Matrix<local_scalar_t__,1,-1> X_rv_p =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(n, DUMMY_VAR__);
      current_statement__ = 9;
      stan::model::assign(X_rv_p,
        in__.read<Eigen::Matrix<local_scalar_t__,1,-1>>(n),
        "assigning variable X_rv_p");
      out__.write(X_rv_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "alpha_v",
        "double", std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "beta", "double",
        std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "cuts", "double",
        std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "sigma", "double",
        std::vector<size_t>{});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "alpha", "double",
        std::vector<size_t>{});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "phi", "double",
        std::vector<size_t>{});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "X_p", "double",
        std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(k)});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization", "beta_m", "double",
        std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(k)});
      current_statement__ = 9;
      context__.validate_dims("parameter initialization", "X_rv_p", "double",
        std::vector<size_t>{static_cast<size_t>(n)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> alpha_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> alpha_v_flat__;
        current_statement__ = 1;
        alpha_v_flat__ = context__.vals_r("alpha_v");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          stan::model::assign(alpha_v, alpha_v_flat__[(pos__ - 1)],
            "assigning variable alpha_v", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(alpha_v);
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> beta_flat__;
        current_statement__ = 2;
        beta_flat__ = context__.vals_r("beta");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          stan::model::assign(beta, beta_flat__[(pos__ - 1)],
            "assigning variable beta", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(beta);
      Eigen::Matrix<local_scalar_t__,-1,1> cuts =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> cuts_flat__;
        current_statement__ = 3;
        cuts_flat__ = context__.vals_r("cuts");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          stan::model::assign(cuts, cuts_flat__[(pos__ - 1)],
            "assigning variable cuts", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(cuts);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 4;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      out__.write_free_lb(0, sigma);
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 5;
      alpha = context__.vals_r("alpha")[(1 - 1)];
      out__.write(alpha);
      local_scalar_t__ phi = DUMMY_VAR__;
      current_statement__ = 6;
      phi = context__.vals_r("phi")[(1 - 1)];
      out__.write(phi);
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, k, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> X_p_flat__;
        current_statement__ = 7;
        X_p_flat__ = context__.vals_r("X_p");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(X_p);
      Eigen::Matrix<local_scalar_t__,-1,-1> beta_m =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, k, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> beta_m_flat__;
        current_statement__ = 8;
        beta_m_flat__ = context__.vals_r("beta_m");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            stan::model::assign(beta_m, beta_m_flat__[(pos__ - 1)],
              "assigning variable beta_m", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(beta_m);
      Eigen::Matrix<local_scalar_t__,1,-1> X_rv_p =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(n, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> X_rv_p_flat__;
        current_statement__ = 9;
        X_rv_p_flat__ = context__.vals_r("X_rv_p");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          stan::model::assign(X_rv_p, X_rv_p_flat__[(pos__ - 1)],
            "assigning variable X_rv_p", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(X_rv_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"alpha_v", "beta", "cuts", "sigma",
                "alpha", "phi", "X_p", "beta_m", "X_rv_p"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(k)},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(n),
                  static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(n),
                  static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(n)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "alpha_v" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "cuts" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "sigma");
    param_names__.emplace_back(std::string() + "alpha");
    param_names__.emplace_back(std::string() + "phi");
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
        param_names__.emplace_back(std::string() + "X_p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
        param_names__.emplace_back(std::string() + "beta_m" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
      param_names__.emplace_back(std::string() + "X_rv_p" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "alpha_v" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "cuts" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "sigma");
    param_names__.emplace_back(std::string() + "alpha");
    param_names__.emplace_back(std::string() + "phi");
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
        param_names__.emplace_back(std::string() + "X_p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
        param_names__.emplace_back(std::string() + "beta_m" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
      param_names__.emplace_back(std::string() + "X_rv_p" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"cuts\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n) + ",\"cols\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"beta_m\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n) + ",\"cols\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"X_rv_p\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n) + "},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"cuts\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n) + ",\"cols\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"beta_m\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n) + ",\"cols\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"X_rv_p\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n) + "},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((k + k) + k) + 1) + 1) + 1) + (n * k))
      + (n * k)) + n);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((k + k) + k) + 1) + 1) + 1) + (n * k))
      + (n * k)) + n);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = optimize_glm_model_namespace::optimize_glm_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return optimize_glm_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp overloading_templating.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace overloading_templating_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 39> locations_array__ =
  {" (found before start of program)",
  " (in 'overloading_templating.stan', line 48, column 4 to column 11)",
  " (in 'overloading_templating.stan', line 49, column 4 to column 11)",
  " (in 'overloading_templating.stan', line 52, column 4 to column 26)",
  " (in 'overloading_templating.stan', line 53, column 4 to column 28)",
  " (in 'overloading_templating.stan', line 54, column 4 to column 26)",
  " (in 'overloading_templating.stan', line 55, column 4 to column 26)",
  " (in 'overloading_templating.stan', line 56, column 4 to column 27)",
  " (in 'overloading_templating.stan', line 57, column 4 to column 26)",
  " (in 'overloading_templating.stan', line 58, column 4 to column 30)",
  " (in 'overloading_templating.stan', line 59, column 4 to column 30)",
  " (in 'overloading_templating.stan', line 60, column 4 to column 28)",
  " (in 'overloading_templating.stan', line 61, column 4 to column 30)",
  " (in 'overloading_templating.stan', line 62, column 4 to column 32)",
  " (in 'overloading_templating.stan', line 63, column 4 to column 40)",
  " (in 'overloading_templating.stan', line 44, column 3 to column 44)",
  " (in 'overloading_templating.stan', line 45, column 3 to column 36)",
  " (in 'overloading_templating.stan', line 8, column 4 to column 19)",
  " (in 'overloading_templating.stan', line 7, column 17 to line 9, column 3)",
  " (in 'overloading_templating.stan', line 12, column 4 to column 17)",
  " (in 'overloading_templating.stan', line 11, column 20 to line 13, column 4)",
  " (in 'overloading_templating.stan', line 15, column 4 to column 22)",
  " (in 'overloading_templating.stan', line 14, column 26 to line 16, column 4)",
  " (in 'overloading_templating.stan', line 18, column 4 to column 22)",
  " (in 'overloading_templating.stan', line 17, column 22 to line 19, column 4)",
  " (in 'overloading_templating.stan', line 21, column 4 to column 22)",
  " (in 'overloading_templating.stan', line 20, column 22 to line 22, column 4)",
  " (in 'overloading_templating.stan', line 24, column 4 to column 22)",
  " (in 'overloading_templating.stan', line 23, column 28 to line 25, column 4)",
  " (in 'overloading_templating.stan', line 28, column 4 to column 25)",
  " (in 'overloading_templating.stan', line 27, column 33 to line 29, column 4)",
  " (in 'overloading_templating.stan', line 31, column 4 to column 25)",
  " (in 'overloading_templating.stan', line 30, column 30 to line 32, column 4)",
  " (in 'overloading_templating.stan', line 34, column 4 to column 25)",
  " (in 'overloading_templating.stan', line 33, column 30 to line 35, column 4)",
  " (in 'overloading_templating.stan', line 37, column 4 to column 26)",
  " (in 'overloading_templating.stan', line 36, column 29 to line 38, column 4)",
  " (in 'overloading_templating.stan', line 40, column 4 to column 23)",
  " (in 'overloading_templating.stan', line 39, column 25 to line 41, column 3)"};
template <typename T0__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
double foo(const T0__& p, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__> foo(const T0__& p, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_row_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_row_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_col_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T0__>>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              std::is_integral<stan::value_type_t<T0__>>>* = nullptr>
double foo(const T0__& p, std::ostream* pstream__);
// real foo(int)
template <typename T0__, stan::require_all_t<std::is_integral<T0__>>*> double
foo(const T0__& p, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 17;
    return (p + 1.0);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__> foo(const T0__& p, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 19;
    return (p + 2);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(row_vector)
template <typename T0__,
          stan::require_all_t<stan::is_row_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& p = stan::math::to_ref(p_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 21;
    return (stan::math::sum(p) + 3);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(vector)
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& p = stan::math::to_ref(p_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 23;
    return (stan::math::sum(p) + 4);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(matrix)
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& p = stan::math::to_ref(p_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 25;
    return (stan::math::sum(p) + 5);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(array[] real)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 27;
    return (stan::math::sum(p) + 6);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(array[] row_vector)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_row_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 29;
    return (stan::math::sum(
              stan::model::rvalue(p, "p", stan::model::index_uni(1)))
           + 7);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(array[] vector)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_col_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 31;
    return (stan::math::sum(
              stan::model::rvalue(p, "p", stan::model::index_uni(1)))
           + 8);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(array[] matrix)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 33;
    return (stan::math::sum(
              stan::model::rvalue(p, "p", stan::model::index_uni(1)))
           + 9);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(array[,] real)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T0__>>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& p, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 35;
    return (stan::math::sum(
              stan::model::rvalue(p, "p", stan::model::index_uni(1)))
           + 10);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(array[] int)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              std::is_integral<stan::value_type_t<T0__>>>*>
double foo(const T0__& p, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 37;
    return (stan::math::sum(p) + 12);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class overloading_templating_model final : public model_base_crtp<overloading_templating_model> {
 private:
  Eigen::Matrix<double,-1,1> a_data__;
  Eigen::Matrix<double,-1,-1> M_data__;
  Eigen::Map<Eigen::Matrix<double,-1,1>> a{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> M{nullptr, 0, 0};
 public:
  ~overloading_templating_model() {}
  overloading_templating_model(stan::io::var_context& context__, unsigned int
                               random_seed__ = 0, std::ostream*
                               pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "overloading_templating_model_namespace::overloading_templating_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 15;
      a_data__ = Eigen::Matrix<double,-1,1>::Constant(5,
                   std::numeric_limits<double>::quiet_NaN());
      new (&a) Eigen::Map<Eigen::Matrix<double,-1,1>>(a_data__.data(), 5);
      current_statement__ = 15;
      stan::model::assign(a,
        (Eigen::Matrix<double,-1,1>(5) << 0.1, 0.1, 0.1, 0.1, 0.1).finished(),
        "assigning variable a");
      current_statement__ = 16;
      M_data__ = Eigen::Matrix<double,-1,-1>::Constant(5, 5,
                   std::numeric_limits<double>::quiet_NaN());
      new (&M) Eigen::Map<Eigen::Matrix<double,-1,-1>>(M_data__.data(), 5, 5);
      current_statement__ = 16;
      stan::model::assign(M,
        stan::math::to_matrix(
          std::vector<Eigen::Matrix<double,1,-1>>{stan::math::transpose(a),
            stan::math::transpose(a), stan::math::transpose(a),
            stan::math::transpose(a), stan::math::transpose(a)}),
        "assigning variable M");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1;
  }
  inline std::string model_name() const final {
    return "overloading_templating_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "overloading_templating_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 1;
      y = in__.template read<local_scalar_t__>();
      local_scalar_t__ z = DUMMY_VAR__;
      current_statement__ = 2;
      z = in__.template read<local_scalar_t__>();
      {
        current_statement__ = 3;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(1, pstream__), 1));
        current_statement__ = 4;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(1.5, pstream__), 1));
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(a,
                         foo(z, pstream__), 1));
        current_statement__ = 6;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(a, pstream__), 1));
        current_statement__ = 7;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(stan::math::transpose(a), pstream__), 1));
        current_statement__ = 8;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(M, pstream__), 1));
        current_statement__ = 9;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(
                           stan::model::rvalue(M, "M",
                             stan::model::index_omni(),
                             stan::model::index_uni(1)), pstream__), 1));
        current_statement__ = 10;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(
                           stan::model::rvalue(M, "M",
                             stan::model::index_uni(1),
                             stan::model::index_omni()), pstream__), 1));
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(std::vector<Eigen::Matrix<double,-1,1>>{a},
                           pstream__), 1));
        current_statement__ = 12;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(std::vector<int>{1, 2}, pstream__), 1));
        current_statement__ = 13;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(std::vector<double>{1, 2.3}, pstream__), 1));
        current_statement__ = 14;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         std::vector<double>{5.5, 6.5},
                         foo(std::vector<local_scalar_t__>{z, 2.3}, pstream__),
                         1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "overloading_templating_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 1;
      y = in__.template read<local_scalar_t__>();
      local_scalar_t__ z = DUMMY_VAR__;
      current_statement__ = 2;
      z = in__.template read<local_scalar_t__>();
      {
        current_statement__ = 3;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(1, pstream__), 1));
        current_statement__ = 4;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(1.5, pstream__), 1));
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(a,
                         foo(z, pstream__), 1));
        current_statement__ = 6;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(a, pstream__), 1));
        current_statement__ = 7;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(stan::math::transpose(a), pstream__), 1));
        current_statement__ = 8;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(M, pstream__), 1));
        current_statement__ = 9;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(
                           stan::model::rvalue(M, "M",
                             stan::model::index_omni(),
                             stan::model::index_uni(1)), pstream__), 1));
        current_statement__ = 10;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(
                           stan::model::rvalue(M, "M",
                             stan::model::index_uni(1),
                             stan::model::index_omni()), pstream__), 1));
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(std::vector<Eigen::Matrix<double,-1,1>>{a},
                           pstream__), 1));
        current_statement__ = 12;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(std::vector<int>{1, 2}, pstream__), 1));
        current_statement__ = 13;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         foo(std::vector<double>{1, 2.3}, pstream__), 1));
        current_statement__ = 14;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         std::vector<double>{5.5, 6.5},
                         foo(std::vector<local_scalar_t__>{z, 2.3}, pstream__),
                         1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "overloading_templating_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double y = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      y = in__.template read<local_scalar_t__>();
      double z = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      z = in__.template read<local_scalar_t__>();
      out__.write(y);
      out__.write(z);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 1;
      y = in__.read<local_scalar_t__>();
      out__.write(y);
      local_scalar_t__ z = DUMMY_VAR__;
      current_statement__ = 2;
      z = in__.read<local_scalar_t__>();
      out__.write(z);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "y", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "z", "double",
        std::vector<size_t>{});
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 1;
      y = context__.vals_r("y")[(1 - 1)];
      out__.write(y);
      local_scalar_t__ z = DUMMY_VAR__;
      current_statement__ = 2;
      z = context__.vals_r("z")[(1 - 1)];
      out__.write(z);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"y", "z"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "y");
    param_names__.emplace_back(std::string() + "z");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "y");
    param_names__.emplace_back(std::string() + "z");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"z\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"z\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + 1);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + 1);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = overloading_templating_model_namespace::overloading_templating_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return overloading_templating_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp param-constraint.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace param_constraint_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 7> locations_array__ =
  {" (found before start of program)",
  " (in 'param-constraint.stan', line 6, column 2 to column 44)",
  " (in 'param-constraint.stan', line 7, column 2 to column 40)",
  " (in 'param-constraint.stan', line 2, column 2 to column 9)",
  " (in 'param-constraint.stan', line 3, column 2 to column 9)",
  " (in 'param-constraint.stan', line 6, column 8 to column 10)",
  " (in 'param-constraint.stan', line 7, column 33 to column 35)"};
class param_constraint_model final : public model_base_crtp<param_constraint_model> {
 private:
  int nt;
  int NS;
 public:
  ~param_constraint_model() {}
  param_constraint_model(stan::io::var_context& context__, unsigned int
                         random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "param_constraint_model_namespace::param_constraint_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 3;
      context__.validate_dims("data initialization", "nt", "int",
        std::vector<size_t>{});
      nt = std::numeric_limits<int>::min();
      current_statement__ = 3;
      nt = context__.vals_i("nt")[(1 - 1)];
      current_statement__ = 4;
      context__.validate_dims("data initialization", "NS", "int",
        std::vector<size_t>{});
      NS = std::numeric_limits<int>::min();
      current_statement__ = 4;
      NS = context__.vals_i("NS")[(1 - 1)];
      current_statement__ = 5;
      stan::math::validate_non_negative_index("L_Omega", "nt", nt);
      current_statement__ = 6;
      stan::math::validate_non_negative_index("z1", "NS", NS);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (nt * ((2 * (2 - 1)) / 2)) + NS;
  }
  inline std::string model_name() const final {
    return "param_constraint_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "param_constraint_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> L_Omega =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(nt,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__));
      current_statement__ = 1;
      L_Omega = in__.template read_constrain_cholesky_factor_corr<
                  std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
                  jacobian__>(lp__, nt, 2);
      Eigen::Matrix<local_scalar_t__,-1,1> z1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(NS, DUMMY_VAR__);
      current_statement__ = 2;
      z1 = in__.template read_constrain_lb<
             Eigen::Matrix<local_scalar_t__,-1,1>,
             jacobian__>(stan::model::rvalue(L_Omega, "L_Omega",
                           stan::model::index_uni(1),
                           stan::model::index_uni(1),
                           stan::model::index_uni(2)), lp__, NS);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "param_constraint_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> L_Omega =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(nt,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__));
      current_statement__ = 1;
      L_Omega = in__.template read_constrain_cholesky_factor_corr<
                  std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
                  jacobian__>(lp__, nt, 2);
      Eigen::Matrix<local_scalar_t__,-1,1> z1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(NS, DUMMY_VAR__);
      current_statement__ = 2;
      z1 = in__.template read_constrain_lb<
             Eigen::Matrix<local_scalar_t__,-1,1>,
             jacobian__>(stan::model::rvalue(L_Omega, "L_Omega",
                           stan::model::index_uni(1),
                           stan::model::index_uni(1),
                           stan::model::index_uni(2)), lp__, NS);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "param_constraint_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<Eigen::Matrix<double,-1,-1>> L_Omega =
        std::vector<Eigen::Matrix<double,-1,-1>>(nt,
          Eigen::Matrix<double,-1,-1>::Constant(2, 2,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 1;
      L_Omega = in__.template read_constrain_cholesky_factor_corr<
                  std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
                  jacobian__>(lp__, nt, 2);
      Eigen::Matrix<double,-1,1> z1 =
        Eigen::Matrix<double,-1,1>::Constant(NS,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      z1 = in__.template read_constrain_lb<
             Eigen::Matrix<local_scalar_t__,-1,1>,
             jacobian__>(stan::model::rvalue(L_Omega, "L_Omega",
                           stan::model::index_uni(1),
                           stan::model::index_uni(1),
                           stan::model::index_uni(2)), lp__, NS);
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= nt; ++sym3__) {
            out__.write(stan::model::rvalue(L_Omega, "L_Omega",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      out__.write(z1);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> L_Omega =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(nt,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__));
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= nt; ++sym3__) {
            current_statement__ = 1;
            stan::model::assign(L_Omega, in__.read<local_scalar_t__>(),
              "assigning variable L_Omega", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write_free_cholesky_factor_corr(L_Omega);
      Eigen::Matrix<local_scalar_t__,-1,1> z1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(NS, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(z1,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(NS),
        "assigning variable z1");
      out__.write_free_lb(stan::model::rvalue(L_Omega, "L_Omega",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1),
                            stan::model::index_uni(2)), z1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "L_Omega",
        "double",
        std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(2),
          static_cast<size_t>(2)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "z1", "double",
        std::vector<size_t>{static_cast<size_t>(NS)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> L_Omega =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(nt,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> L_Omega_flat__;
        current_statement__ = 1;
        L_Omega_flat__ = context__.vals_r("L_Omega");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= nt; ++sym3__) {
              stan::model::assign(L_Omega, L_Omega_flat__[(pos__ - 1)],
                "assigning variable L_Omega", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write_free_cholesky_factor_corr(L_Omega);
      Eigen::Matrix<local_scalar_t__,-1,1> z1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(NS, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> z1_flat__;
        current_statement__ = 2;
        z1_flat__ = context__.vals_r("z1");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= NS; ++sym1__) {
          stan::model::assign(z1, z1_flat__[(pos__ - 1)],
            "assigning variable z1", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lb(stan::model::rvalue(L_Omega, "L_Omega",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1),
                            stan::model::index_uni(2)), z1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"L_Omega", "z1"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    nt),
                                                 static_cast<size_t>(2),
                                                 static_cast<size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(NS)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= nt; ++sym3__) {
          param_names__.emplace_back(std::string() + "L_Omega" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= NS; ++sym1__) {
      param_names__.emplace_back(std::string() + "z1" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= ((2 * (2 - 1)) / 2); ++sym1__) {
      for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
        param_names__.emplace_back(std::string() + "L_Omega" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= NS; ++sym1__) {
      param_names__.emplace_back(std::string() + "z1" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"L_Omega\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(nt) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(2) + "}},\"block\":\"parameters\"},{\"name\":\"z1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NS) + "},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"L_Omega\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(nt) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(((2 * (2 - 1)) /2)) + "}},\"block\":\"parameters\"},{\"name\":\"z1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NS) + "},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((nt * (2 * 2)) + NS);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((nt * (2 * 2)) + NS);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = param_constraint_model_namespace::param_constraint_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return param_constraint_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp print_unicode.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace print_unicode_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 3> locations_array__ =
  {" (found before start of program)",
  " (in 'print_unicode.stan', line 2, column 2 to column 24)",
  " (in 'print_unicode.stan', line 3, column 2 to column 23)"};
class print_unicode_model final : public model_base_crtp<print_unicode_model> {
 private:
  
 public:
  ~print_unicode_model() {}
  print_unicode_model(stan::io::var_context& context__, unsigned int
                      random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "print_unicode_model_namespace::print_unicode_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      if (pstream__) {
        stan::math::stan_print(pstream__, "test: \320\211\360\237\230\203");
        *(pstream__) << std::endl;
      }
      current_statement__ = 2;
      if (pstream__) {
        stan::math::stan_print(pstream__,
          "\316\273 \316\262 \316\266 \317\200");
        *(pstream__) << std::endl;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "print_unicode_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "print_unicode_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "print_unicode_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "print_unicode_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = print_unicode_model_namespace::print_unicode_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return print_unicode_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp promotion.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace promotion_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 9> locations_array__ =
  {" (found before start of program)",
  " (in 'promotion.stan', line 12, column 3 to column 14)",
  " (in 'promotion.stan', line 13, column 3 to column 25)",
  " (in 'promotion.stan', line 14, column 3 to column 31)",
  " (in 'promotion.stan', line 15, column 3 to column 20)",
  " (in 'promotion.stan', line 3, column 5 to column 14)",
  " (in 'promotion.stan', line 2, column 28 to line 4, column 4)",
  " (in 'promotion.stan', line 7, column 5 to column 18)",
  " (in 'promotion.stan', line 6, column 28 to line 8, column 4)"};
template <typename T0__,
          stan::require_all_t<stan::is_complex<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::base_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::base_type_t<T0__>>>>* = nullptr>
std::complex<stan::promote_args_t<stan::base_type_t<T0__>>>
ident(const T0__& x, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& zs, std::ostream* pstream__);
// complex ident(complex)
template <typename T0__,
          stan::require_all_t<stan::is_complex<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::base_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::base_type_t<T0__>>>>*>
std::complex<stan::promote_args_t<stan::base_type_t<T0__>>>
ident(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 5;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(array[] real)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& zs, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 7;
    return stan::model::rvalue(zs, "zs", stan::model::index_uni(0));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class promotion_model final : public model_base_crtp<promotion_model> {
 private:
  
 public:
  ~promotion_model() {}
  promotion_model(stan::io::var_context& context__, unsigned int
                  random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "promotion_model_namespace::promotion_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "promotion_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "promotion_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "promotion_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "promotion_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      double z = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      z = 1;
      std::complex<double> zi =
        std::complex<double>(std::numeric_limits<double>::quiet_NaN(),
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      zi = ident(stan::math::to_complex(z, 0), pstream__);
      std::vector<int> zs =
        std::vector<int>(4, std::numeric_limits<int>::min());
      current_statement__ = 3;
      stan::model::assign(zs, std::vector<int>{1, 2, 3, 4},
        "assigning variable zs");
      double x = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      x = foo(stan::math::promote_scalar<double>(zs), pstream__);
      out__.write(z);
      out__.write(zi);
      out__.write(zs);
      out__.write(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      std::vector<std::string> temp{"z", "zi", "zs", "x"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(2)},
             std::vector<size_t>{static_cast<size_t>(4)},
             std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "z");
      param_names__.emplace_back(std::string() + "zi" + '.' + "real");
      param_names__.emplace_back(std::string() + "zi" + '.' + "imag");
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        param_names__.emplace_back(std::string() + "zs" + '.' +
          std::to_string(sym1__));
      }
      param_names__.emplace_back(std::string() + "x");
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "z");
      param_names__.emplace_back(std::string() + "zi" + '.' + "real");
      param_names__.emplace_back(std::string() + "zi" + '.' + "imag");
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        param_names__.emplace_back(std::string() + "zs" + '.' +
          std::to_string(sym1__));
      }
      param_names__.emplace_back(std::string() + "x");
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"z\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"zi\",\"type\":{\"name\":\"complex\"},\"block\":\"generated_quantities\"},{\"name\":\"zs\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"z\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"zi\",\"type\":{\"name\":\"complex\"},\"block\":\"generated_quantities\"},{\"name\":\"zs\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * ((((1 + 2)
      + 4) + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * ((((1 + 2)
      + 4) + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = promotion_model_namespace::promotion_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return promotion_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp recursive-slicing.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace recursive_slicing_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 43> locations_array__ =
  {" (found before start of program)",
  " (in 'recursive-slicing.stan', line 73, column 2 to column 22)",
  " (in 'recursive-slicing.stan', line 76, column 2 to column 33)",
  " (in 'recursive-slicing.stan', line 77, column 2 to column 52)",
  " (in 'recursive-slicing.stan', line 69, column 2 to column 8)",
  " (in 'recursive-slicing.stan', line 70, column 2 to column 12)",
  " (in 'recursive-slicing.stan', line 73, column 9 to column 14)",
  " (in 'recursive-slicing.stan', line 76, column 9 to column 10)",
  " (in 'recursive-slicing.stan', line 4, column 3 to column 31)",
  " (in 'recursive-slicing.stan', line 9, column 6 to column 35)",
  " (in 'recursive-slicing.stan', line 7, column 6 to column 30)",
  " (in 'recursive-slicing.stan', line 6, column 3 to line 9, column 35)",
  " (in 'recursive-slicing.stan', line 3, column 28 to line 10, column 2)",
  " (in 'recursive-slicing.stan', line 16, column 4 to column 59)",
  " (in 'recursive-slicing.stan', line 15, column 9 to line 17, column 3)",
  " (in 'recursive-slicing.stan', line 14, column 4 to column 47)",
  " (in 'recursive-slicing.stan', line 13, column 14 to line 15, column 3)",
  " (in 'recursive-slicing.stan', line 13, column 2 to line 17, column 3)",
  " (in 'recursive-slicing.stan', line 12, column 35 to line 18, column 1)",
  " (in 'recursive-slicing.stan', line 22, column 2 to column 11)",
  " (in 'recursive-slicing.stan', line 21, column 18 to line 23, column 1)",
  " (in 'recursive-slicing.stan', line 26, column 2 to column 40)",
  " (in 'recursive-slicing.stan', line 27, column 2 to column 23)",
  " (in 'recursive-slicing.stan', line 25, column 16 to line 28, column 1)",
  " (in 'recursive-slicing.stan', line 32, column 3 to column 31)",
  " (in 'recursive-slicing.stan', line 37, column 6 to column 35)",
  " (in 'recursive-slicing.stan', line 35, column 6 to column 30)",
  " (in 'recursive-slicing.stan', line 34, column 3 to line 37, column 35)",
  " (in 'recursive-slicing.stan', line 31, column 27 to line 38, column 3)",
  " (in 'recursive-slicing.stan', line 40, column 2 to column 22)",
  " (in 'recursive-slicing.stan', line 39, column 27 to line 41, column 1)",
  " (in 'recursive-slicing.stan', line 45, column 3 to column 31)",
  " (in 'recursive-slicing.stan', line 50, column 6 to column 28)",
  " (in 'recursive-slicing.stan', line 48, column 6 to column 22)",
  " (in 'recursive-slicing.stan', line 47, column 3 to line 50, column 28)",
  " (in 'recursive-slicing.stan', line 44, column 24 to line 51, column 1)",
  " (in 'recursive-slicing.stan', line 54, column 3 to column 31)",
  " (in 'recursive-slicing.stan', line 59, column 6 to column 38)",
  " (in 'recursive-slicing.stan', line 57, column 6 to column 30)",
  " (in 'recursive-slicing.stan', line 56, column 3 to line 59, column 38)",
  " (in 'recursive-slicing.stan', line 53, column 28 to line 60, column 3)",
  " (in 'recursive-slicing.stan', line 64, column 4 to column 53)",
  " (in 'recursive-slicing.stan', line 63, column 41 to line 65, column 3)"};
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
test2(const T0__& gamma_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              std::is_integral<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
matrix_pow(const T0__& a_arg__, const T1__& n, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& a_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__> foo(const T0__& b, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
test4(const T0__& gamma_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
test3(const T0__& gamma_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
void test6(const T0__& alpha_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
test7(const T0__& gamma_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_eigen_matrix_dynamic<T2__>,
                              stan::is_vt_not_complex<T2__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>,
                stan::base_type_t<T2__>>,-1,1>
foo(const T0__& x, const T1__& s_arg__, const T2__& y_arg__, std::ostream*
    pstream__);
struct foo_variadic2_functor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                        std::is_floating_point<T0__>>,
                                stan::is_col_vector<T1__>,
                                stan::is_vt_not_complex<T1__>,
                                stan::is_eigen_matrix_dynamic<T2__>,
                                stan::is_vt_not_complex<T2__>>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>,
                  stan::base_type_t<T2__>>,-1,1>
  operator()(const T0__& x, const T1__& s, std::ostream* pstream__,
             const T2__& y) const {
    return foo(x, s, y, pstream__);
  }
};
// vector test2(vector)
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
test2(const T0__& gamma_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& gamma = stan::math::to_ref(gamma_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int D = std::numeric_limits<int>::min();
    current_statement__ = 8;
    D = stan::math::num_elements(gamma);
    current_statement__ = 11;
    if (stan::math::logical_eq(D, 1)) {
      current_statement__ = 10;
      return stan::math::promote_scalar<local_scalar_t__>(
               stan::math::rep_vector(D, 0));
    } else {
      current_statement__ = 9;
      return test2(
               stan::math::eval(
                 stan::model::rvalue(gamma, "gamma",
                   stan::model::index_min_max(1, (D - 1)))), pstream__);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// matrix matrix_pow(matrix, int)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              std::is_integral<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
matrix_pow(const T0__& a_arg__, const T1__& n, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a = stan::math::to_ref(a_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 17;
    if (stan::math::logical_eq(n, 0)) {
      current_statement__ = 15;
      return stan::math::promote_scalar<local_scalar_t__>(
               stan::math::diag_matrix(
                 stan::math::rep_vector(1, stan::math::rows(a))));
    } else {
      current_statement__ = 13;
      return stan::math::multiply(a,
               matrix_pow(
                 stan::math::eval(
                   stan::model::rvalue(a, "a",
                     stan::model::index_min_max(1, stan::math::rows(a)),
                     stan::model::index_min_max(1, stan::math::cols(a)))), (n
                 - 1), pstream__));
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(matrix)
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& a_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a = stan::math::to_ref(a_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 19;
    return 1;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__> foo(const T0__& b, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    Eigen::Matrix<local_scalar_t__,-1,-1> B =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
    current_statement__ = 21;
    stan::model::assign(B, stan::math::rep_matrix(b, 10, 10),
      "assigning variable B");
    current_statement__ = 22;
    return foo(
             stan::model::rvalue(B, "B", stan::model::index_omni(),
               stan::model::index_min_max(2, 4)), pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector test4(vector)
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
test4(const T0__& gamma_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& gamma = stan::math::to_ref(gamma_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int D = std::numeric_limits<int>::min();
    current_statement__ = 24;
    D = stan::math::num_elements(gamma);
    current_statement__ = 27;
    if (stan::math::logical_eq(D, 1)) {
      current_statement__ = 26;
      return stan::math::promote_scalar<local_scalar_t__>(
               stan::math::rep_vector(D, 0));
    } else {
      current_statement__ = 25;
      return test3(
               stan::model::rvalue(gamma, "gamma",
                 stan::model::index_min_max(1, (D - 1))), pstream__);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector test3(vector)
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
test3(const T0__& gamma_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& gamma = stan::math::to_ref(gamma_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 29;
    return test4(stan::math::eval(gamma), pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// void test6(vector)
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
void test6(const T0__& alpha_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& alpha = stan::math::to_ref(alpha_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int D = std::numeric_limits<int>::min();
    current_statement__ = 31;
    D = stan::math::num_elements(alpha);
    current_statement__ = 34;
    if (stan::math::logical_eq(D, 1)) {
      current_statement__ = 33;
      if (pstream__) {
        stan::math::stan_print(pstream__,
          stan::model::rvalue(alpha, "alpha", stan::model::index_uni(1)));
        *(pstream__) << std::endl;
      }
    } else {
      current_statement__ = 32;
      test6(
        stan::math::eval(
          stan::model::rvalue(alpha, "alpha",
            stan::model::index_min_max(1, (D - 1)))), pstream__);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector test7(vector)
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
test7(const T0__& gamma_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& gamma = stan::math::to_ref(gamma_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int D = std::numeric_limits<int>::min();
    current_statement__ = 36;
    D = stan::math::num_elements(gamma);
    current_statement__ = 39;
    if (stan::math::logical_eq(D, 1)) {
      current_statement__ = 38;
      return stan::math::promote_scalar<local_scalar_t__>(
               stan::math::rep_vector(D, 0));
    } else {
      current_statement__ = 37;
      return test7(stan::math::eval(stan::math::head(gamma, (D - 1))),
               pstream__);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector foo(real, vector, matrix)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_eigen_matrix_dynamic<T2__>,
                              stan::is_vt_not_complex<T2__>>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>,
                stan::base_type_t<T2__>>,-1,1>
foo(const T0__& x, const T1__& s_arg__, const T2__& y_arg__, std::ostream*
    pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
                             stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& s = stan::math::to_ref(s_arg__);
  const auto& y = stan::math::to_ref(y_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 41;
    return stan::model::rvalue(
             stan::math::ode_rk45(foo_variadic2_functor__(),
               (Eigen::Matrix<double,-1,1>(1) << 1).finished(), 0.0,
               std::vector<double>{1.0}, pstream__,
               stan::math::eval(
                 stan::model::rvalue(y, "y", stan::model::index_min(2)))),
             "ode_rk45(foo, Transpose__(FnMakeRowVec__(promote(1, real, data))), 0.0,\n         FnMakeArray__(1.0), eval(y[2:]))",
             stan::model::index_uni(1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class recursive_slicing_model final : public model_base_crtp<recursive_slicing_model> {
 private:
  int N;
  int times;
 public:
  ~recursive_slicing_model() {}
  recursive_slicing_model(stan::io::var_context& context__, unsigned int
                          random_seed__ = 0, std::ostream*
                          pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "recursive_slicing_model_namespace::recursive_slicing_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 4;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 4;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 5;
      context__.validate_dims("data initialization", "times", "int",
        std::vector<size_t>{});
      times = std::numeric_limits<int>::min();
      current_statement__ = 5;
      times = context__.vals_i("times")[(1 - 1)];
      current_statement__ = 6;
      stan::math::validate_non_negative_index("gamma", "times", times);
      current_statement__ = 7;
      stan::math::validate_non_negative_index("z_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = times;
  }
  inline std::string model_name() const final {
    return "recursive_slicing_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "recursive_slicing_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> gamma =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(times, DUMMY_VAR__);
      current_statement__ = 1;
      gamma = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(times);
      Eigen::Matrix<local_scalar_t__,-1,1> z_hat =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(z_hat, test2(gamma, pstream__),
        "assigning variable z_hat");
      Eigen::Matrix<local_scalar_t__,-1,1> z =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(z,
        foo(1.0, gamma, stan::math::diag_matrix(gamma), pstream__),
        "assigning variable z");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "recursive_slicing_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> gamma =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(times, DUMMY_VAR__);
      current_statement__ = 1;
      gamma = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(times);
      Eigen::Matrix<local_scalar_t__,-1,1> z_hat =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(z_hat, test2(gamma, pstream__),
        "assigning variable z_hat");
      Eigen::Matrix<local_scalar_t__,-1,1> z =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(z,
        foo(1.0, gamma, stan::math::diag_matrix(gamma), pstream__),
        "assigning variable z");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "recursive_slicing_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,1> gamma =
        Eigen::Matrix<double,-1,1>::Constant(times,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      gamma = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(times);
      Eigen::Matrix<double,-1,1> z_hat =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> z =
        Eigen::Matrix<double,-1,1>::Constant(3,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(gamma);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 2;
      stan::model::assign(z_hat, test2(gamma, pstream__),
        "assigning variable z_hat");
      current_statement__ = 3;
      stan::model::assign(z,
        foo(1.0, gamma, stan::math::diag_matrix(gamma), pstream__),
        "assigning variable z");
      if (emit_transformed_parameters__) {
        out__.write(z_hat);
        out__.write(z);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> gamma =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(times, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(gamma,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(times),
        "assigning variable gamma");
      out__.write(gamma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "gamma", "double",
        std::vector<size_t>{static_cast<size_t>(times)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> gamma =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(times, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> gamma_flat__;
        current_statement__ = 1;
        gamma_flat__ = context__.vals_r("gamma");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= times; ++sym1__) {
          stan::model::assign(gamma, gamma_flat__[(pos__ - 1)],
            "assigning variable gamma", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(gamma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"gamma"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"z_hat", "z"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    times)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(3)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= times; ++sym1__) {
      param_names__.emplace_back(std::string() + "gamma" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "z_hat" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "z" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= times; ++sym1__) {
      param_names__.emplace_back(std::string() + "gamma" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "z_hat" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        param_names__.emplace_back(std::string() + "z" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(times) + "},\"block\":\"parameters\"},{\"name\":\"z_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"z\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(times) + "},\"block\":\"parameters\"},{\"name\":\"z_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"z\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = times;
    const size_t num_transformed = emit_transformed_parameters * ((N + 3));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = times;
    const size_t num_transformed = emit_transformed_parameters * ((N + 3));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = recursive_slicing_model_namespace::recursive_slicing_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return recursive_slicing_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp reduce_sum_m1.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace reduce_sum_m1_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 26> locations_array__ =
  {" (found before start of program)",
  " (in 'reduce_sum_m1.stan', line 24, column 2 to column 19)",
  " (in 'reduce_sum_m1.stan', line 25, column 2 to column 19)",
  " (in 'reduce_sum_m1.stan', line 26, column 2 to column 19)",
  " (in 'reduce_sum_m1.stan', line 29, column 2 to column 33)",
  " (in 'reduce_sum_m1.stan', line 30, column 2 to column 37)",
  " (in 'reduce_sum_m1.stan', line 31, column 2 to column 40)",
  " (in 'reduce_sum_m1.stan', line 32, column 2 to column 41)",
  " (in 'reduce_sum_m1.stan', line 21, column 2 to column 14)",
  " (in 'reduce_sum_m1.stan', line 24, column 8 to column 9)",
  " (in 'reduce_sum_m1.stan', line 25, column 8 to column 9)",
  " (in 'reduce_sum_m1.stan', line 26, column 8 to column 9)",
  " (in 'reduce_sum_m1.stan', line 6, column 6 to column 41)",
  " (in 'reduce_sum_m1.stan', line 5, column 11 to line 7, column 5)",
  " (in 'reduce_sum_m1.stan', line 4, column 6 to column 39)",
  " (in 'reduce_sum_m1.stan', line 3, column 27 to line 5, column 5)",
  " (in 'reduce_sum_m1.stan', line 3, column 4 to line 7, column 5)",
  " (in 'reduce_sum_m1.stan', line 2, column 51 to line 8, column 3)",
  " (in 'reduce_sum_m1.stan', line 13, column 6 to column 35)",
  " (in 'reduce_sum_m1.stan', line 12, column 11 to line 14, column 5)",
  " (in 'reduce_sum_m1.stan', line 11, column 6 to column 55)",
  " (in 'reduce_sum_m1.stan', line 10, column 21 to line 12, column 5)",
  " (in 'reduce_sum_m1.stan', line 10, column 4 to line 14, column 5)",
  " (in 'reduce_sum_m1.stan', line 9, column 67 to line 15, column 3)",
  " (in 'reduce_sum_m1.stan', line 17, column 4 to column 39)",
  " (in 'reduce_sum_m1.stan', line 16, column 58 to line 18, column 3)"};
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
g(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
  pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
  std::ostream* pstream__);
template <bool propto__, typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo_lpdf(const T0__& y_slice, const T1__& start, const T2__& end,
         std::ostream* pstream__);
struct h_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T3__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T3__>>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return h(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct g_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return g(y_slice, (start + 1), (end + 1), pstream__);
  }
};
template <bool propto__>
struct foo_lpdf_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return foo_lpdf<propto__>(y_slice, (start + 1), (end + 1), pstream__);
  }
};
// real g(array[] real, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
g(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
  pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 16;
    if (stan::math::logical_gt(stan::math::size(y_slice), 1)) {
      current_statement__ = 14;
      return stan::math::reduce_sum<g_rsfunctor__>(y_slice, 1, pstream__);
    } else {
      current_statement__ = 12;
      return stan::math::normal_lpdf<false>(y_slice, 0, 1);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real h(array[] real, int, int, array[] real)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
  std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 22;
    if (stan::math::logical_gt(stan::math::size(a), 1)) {
      current_statement__ = 20;
      return stan::math::reduce_sum<h_rsfunctor__>(y_slice, 1, pstream__,
               stan::model::rvalue(a, "a",
                 stan::model::index_min_max(start, end)));
    } else {
      current_statement__ = 18;
      return stan::math::normal_lpdf<false>(a, 0, 1);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo_lpdf(array[] real, int, int)
template <bool propto__, typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo_lpdf(const T0__& y_slice, const T1__& start, const T2__& end,
         std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 24;
    return stan::math::normal_lpdf<false>(y_slice, 0, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class reduce_sum_m1_model final : public model_base_crtp<reduce_sum_m1_model> {
 private:
  int N;
 public:
  ~reduce_sum_m1_model() {}
  reduce_sum_m1_model(stan::io::var_context& context__, unsigned int
                      random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "reduce_sum_m1_model_namespace::reduce_sum_m1_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 8;
      N = std::numeric_limits<int>::min();
      current_statement__ = 8;
      N = 100;
      current_statement__ = 9;
      stan::math::validate_non_negative_index("y1", "N", N);
      current_statement__ = 10;
      stan::math::validate_non_negative_index("y2", "N", N);
      current_statement__ = 11;
      stan::math::validate_non_negative_index("y3", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = N + N + N;
  }
  inline std::string model_name() const final {
    return "reduce_sum_m1_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "reduce_sum_m1_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<local_scalar_t__> y1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 1;
      y1 = in__.template read<std::vector<local_scalar_t__>>(N);
      std::vector<local_scalar_t__> y2 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 2;
      y2 = in__.template read<std::vector<local_scalar_t__>>(N);
      std::vector<local_scalar_t__> y3 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 3;
      y3 = in__.template read<std::vector<local_scalar_t__>>(N);
      {
        current_statement__ = 4;
        lp_accum__.add(stan::math::reduce_sum<g_rsfunctor__>(y1, 1, pstream__));
        current_statement__ = 5;
        lp_accum__.add(stan::math::reduce_sum<h_rsfunctor__>(y2, 1,
                         pstream__, y2));
        current_statement__ = 6;
        lp_accum__.add(stan::math::reduce_sum<foo_lpdf_rsfunctor__<false>>(
                         y3, 1, pstream__));
        current_statement__ = 7;
        lp_accum__.add(stan::math::reduce_sum<foo_lpdf_rsfunctor__<propto__>>(
                         y3, 1, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "reduce_sum_m1_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<local_scalar_t__> y1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 1;
      y1 = in__.template read<std::vector<local_scalar_t__>>(N);
      std::vector<local_scalar_t__> y2 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 2;
      y2 = in__.template read<std::vector<local_scalar_t__>>(N);
      std::vector<local_scalar_t__> y3 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 3;
      y3 = in__.template read<std::vector<local_scalar_t__>>(N);
      {
        current_statement__ = 4;
        lp_accum__.add(stan::math::reduce_sum<g_rsfunctor__>(y1, 1, pstream__));
        current_statement__ = 5;
        lp_accum__.add(stan::math::reduce_sum<h_rsfunctor__>(y2, 1,
                         pstream__, y2));
        current_statement__ = 6;
        lp_accum__.add(stan::math::reduce_sum<foo_lpdf_rsfunctor__<false>>(
                         y3, 1, pstream__));
        current_statement__ = 7;
        lp_accum__.add(stan::math::reduce_sum<foo_lpdf_rsfunctor__<propto__>>(
                         y3, 1, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "reduce_sum_m1_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<double> y1 =
        std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      y1 = in__.template read<std::vector<local_scalar_t__>>(N);
      std::vector<double> y2 =
        std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      y2 = in__.template read<std::vector<local_scalar_t__>>(N);
      std::vector<double> y3 =
        std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      y3 = in__.template read<std::vector<local_scalar_t__>>(N);
      out__.write(y1);
      out__.write(y2);
      out__.write(y3);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      std::vector<local_scalar_t__> y1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(y1, in__.read<std::vector<local_scalar_t__>>(N),
        "assigning variable y1");
      out__.write(y1);
      std::vector<local_scalar_t__> y2 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(y2, in__.read<std::vector<local_scalar_t__>>(N),
        "assigning variable y2");
      out__.write(y2);
      std::vector<local_scalar_t__> y3 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(y3, in__.read<std::vector<local_scalar_t__>>(N),
        "assigning variable y3");
      out__.write(y3);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "y1", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "y2", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "y3", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      std::vector<local_scalar_t__> y1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 1;
      y1 = context__.vals_r("y1");
      out__.write(y1);
      std::vector<local_scalar_t__> y2 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 2;
      y2 = context__.vals_r("y2");
      out__.write(y2);
      std::vector<local_scalar_t__> y3 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 3;
      y3 = context__.vals_r("y3");
      out__.write(y3);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"y1", "y2", "y3"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y1" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y2" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y3" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y1" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y2" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y3" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"y1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"y1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((N + N) + N);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((N + N) + N);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = reduce_sum_m1_model_namespace::reduce_sum_m1_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return reduce_sum_m1_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp reduce_sum_m2.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace reduce_sum_m2_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 180> locations_array__ =
  {" (found before start of program)",
  " (in 'reduce_sum_m2.stan', line 128, column 2 to column 30)",
  " (in 'reduce_sum_m2.stan', line 129, column 2 to column 31)",
  " (in 'reduce_sum_m2.stan', line 130, column 2 to column 27)",
  " (in 'reduce_sum_m2.stan', line 131, column 2 to column 22)",
  " (in 'reduce_sum_m2.stan', line 132, column 2 to column 27)",
  " (in 'reduce_sum_m2.stan', line 133, column 2 to column 28)",
  " (in 'reduce_sum_m2.stan', line 134, column 2 to column 24)",
  " (in 'reduce_sum_m2.stan', line 135, column 2 to column 19)",
  " (in 'reduce_sum_m2.stan', line 137, column 2 to column 30)",
  " (in 'reduce_sum_m2.stan', line 138, column 2 to column 31)",
  " (in 'reduce_sum_m2.stan', line 139, column 2 to column 27)",
  " (in 'reduce_sum_m2.stan', line 140, column 2 to column 22)",
  " (in 'reduce_sum_m2.stan', line 141, column 2 to column 27)",
  " (in 'reduce_sum_m2.stan', line 142, column 2 to column 28)",
  " (in 'reduce_sum_m2.stan', line 143, column 2 to column 24)",
  " (in 'reduce_sum_m2.stan', line 144, column 2 to column 19)",
  " (in 'reduce_sum_m2.stan', line 147, column 2 to column 37)",
  " (in 'reduce_sum_m2.stan', line 148, column 2 to column 37)",
  " (in 'reduce_sum_m2.stan', line 149, column 2 to column 37)",
  " (in 'reduce_sum_m2.stan', line 150, column 2 to column 37)",
  " (in 'reduce_sum_m2.stan', line 151, column 2 to column 37)",
  " (in 'reduce_sum_m2.stan', line 152, column 2 to column 37)",
  " (in 'reduce_sum_m2.stan', line 153, column 2 to column 37)",
  " (in 'reduce_sum_m2.stan', line 154, column 2 to column 37)",
  " (in 'reduce_sum_m2.stan', line 156, column 2 to column 34)",
  " (in 'reduce_sum_m2.stan', line 157, column 2 to column 34)",
  " (in 'reduce_sum_m2.stan', line 158, column 2 to column 34)",
  " (in 'reduce_sum_m2.stan', line 159, column 2 to column 34)",
  " (in 'reduce_sum_m2.stan', line 160, column 2 to column 34)",
  " (in 'reduce_sum_m2.stan', line 161, column 2 to column 34)",
  " (in 'reduce_sum_m2.stan', line 162, column 2 to column 34)",
  " (in 'reduce_sum_m2.stan', line 163, column 2 to column 34)",
  " (in 'reduce_sum_m2.stan', line 124, column 2 to column 12)",
  " (in 'reduce_sum_m2.stan', line 125, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 125, column 2 to column 18)",
  " (in 'reduce_sum_m2.stan', line 128, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 128, column 11 to column 12)",
  " (in 'reduce_sum_m2.stan', line 128, column 21 to column 22)",
  " (in 'reduce_sum_m2.stan', line 128, column 24 to column 25)",
  " (in 'reduce_sum_m2.stan', line 129, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 129, column 11 to column 12)",
  " (in 'reduce_sum_m2.stan', line 129, column 25 to column 26)",
  " (in 'reduce_sum_m2.stan', line 130, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 130, column 11 to column 12)",
  " (in 'reduce_sum_m2.stan', line 130, column 21 to column 22)",
  " (in 'reduce_sum_m2.stan', line 131, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 131, column 11 to column 12)",
  " (in 'reduce_sum_m2.stan', line 132, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 132, column 18 to column 19)",
  " (in 'reduce_sum_m2.stan', line 132, column 21 to column 22)",
  " (in 'reduce_sum_m2.stan', line 133, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 133, column 22 to column 23)",
  " (in 'reduce_sum_m2.stan', line 134, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 134, column 18 to column 19)",
  " (in 'reduce_sum_m2.stan', line 135, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 137, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 137, column 11 to column 12)",
  " (in 'reduce_sum_m2.stan', line 137, column 21 to column 22)",
  " (in 'reduce_sum_m2.stan', line 137, column 24 to column 25)",
  " (in 'reduce_sum_m2.stan', line 138, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 138, column 11 to column 12)",
  " (in 'reduce_sum_m2.stan', line 138, column 25 to column 26)",
  " (in 'reduce_sum_m2.stan', line 139, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 139, column 11 to column 12)",
  " (in 'reduce_sum_m2.stan', line 139, column 21 to column 22)",
  " (in 'reduce_sum_m2.stan', line 140, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 140, column 11 to column 12)",
  " (in 'reduce_sum_m2.stan', line 141, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 141, column 18 to column 19)",
  " (in 'reduce_sum_m2.stan', line 141, column 21 to column 22)",
  " (in 'reduce_sum_m2.stan', line 142, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 142, column 22 to column 23)",
  " (in 'reduce_sum_m2.stan', line 143, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 143, column 18 to column 19)",
  " (in 'reduce_sum_m2.stan', line 144, column 8 to column 9)",
  " (in 'reduce_sum_m2.stan', line 3, column 4 to column 39)",
  " (in 'reduce_sum_m2.stan', line 2, column 52 to line 4, column 3)",
  " (in 'reduce_sum_m2.stan', line 6, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 8, column 6 to column 49)",
  " (in 'reduce_sum_m2.stan', line 7, column 33 to line 9, column 5)",
  " (in 'reduce_sum_m2.stan', line 7, column 4 to line 9, column 5)",
  " (in 'reduce_sum_m2.stan', line 10, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 5, column 54 to line 11, column 3)",
  " (in 'reduce_sum_m2.stan', line 13, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 15, column 6 to column 49)",
  " (in 'reduce_sum_m2.stan', line 14, column 33 to line 16, column 5)",
  " (in 'reduce_sum_m2.stan', line 14, column 4 to line 16, column 5)",
  " (in 'reduce_sum_m2.stan', line 17, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 12, column 58 to line 18, column 3)",
  " (in 'reduce_sum_m2.stan', line 20, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 22, column 6 to column 60)",
  " (in 'reduce_sum_m2.stan', line 21, column 33 to line 23, column 5)",
  " (in 'reduce_sum_m2.stan', line 21, column 4 to line 23, column 5)",
  " (in 'reduce_sum_m2.stan', line 24, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 19, column 54 to line 25, column 3)",
  " (in 'reduce_sum_m2.stan', line 27, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 30, column 8 to column 54)",
  " (in 'reduce_sum_m2.stan', line 29, column 38 to line 31, column 7)",
  " (in 'reduce_sum_m2.stan', line 29, column 6 to line 31, column 7)",
  " (in 'reduce_sum_m2.stan', line 28, column 33 to line 32, column 5)",
  " (in 'reduce_sum_m2.stan', line 28, column 4 to line 32, column 5)",
  " (in 'reduce_sum_m2.stan', line 33, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 26, column 53 to line 34, column 3)",
  " (in 'reduce_sum_m2.stan', line 36, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 39, column 8 to column 65)",
  " (in 'reduce_sum_m2.stan', line 38, column 38 to line 40, column 7)",
  " (in 'reduce_sum_m2.stan', line 38, column 6 to line 40, column 7)",
  " (in 'reduce_sum_m2.stan', line 37, column 33 to line 41, column 5)",
  " (in 'reduce_sum_m2.stan', line 37, column 4 to line 41, column 5)",
  " (in 'reduce_sum_m2.stan', line 42, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 35, column 55 to line 43, column 3)",
  " (in 'reduce_sum_m2.stan', line 45, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 48, column 8 to column 65)",
  " (in 'reduce_sum_m2.stan', line 47, column 38 to line 49, column 7)",
  " (in 'reduce_sum_m2.stan', line 47, column 6 to line 49, column 7)",
  " (in 'reduce_sum_m2.stan', line 46, column 33 to line 50, column 5)",
  " (in 'reduce_sum_m2.stan', line 46, column 4 to line 50, column 5)",
  " (in 'reduce_sum_m2.stan', line 51, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 44, column 59 to line 52, column 3)",
  " (in 'reduce_sum_m2.stan', line 54, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 57, column 8 to column 65)",
  " (in 'reduce_sum_m2.stan', line 56, column 38 to line 58, column 7)",
  " (in 'reduce_sum_m2.stan', line 56, column 6 to line 58, column 7)",
  " (in 'reduce_sum_m2.stan', line 55, column 33 to line 59, column 5)",
  " (in 'reduce_sum_m2.stan', line 55, column 4 to line 59, column 5)",
  " (in 'reduce_sum_m2.stan', line 60, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 53, column 55 to line 61, column 3)",
  " (in 'reduce_sum_m2.stan', line 63, column 4 to column 46)",
  " (in 'reduce_sum_m2.stan', line 62, column 62 to line 64, column 3)",
  " (in 'reduce_sum_m2.stan', line 66, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 68, column 6 to column 43)",
  " (in 'reduce_sum_m2.stan', line 67, column 27 to line 69, column 5)",
  " (in 'reduce_sum_m2.stan', line 67, column 4 to line 69, column 5)",
  " (in 'reduce_sum_m2.stan', line 70, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 65, column 64 to line 71, column 3)",
  " (in 'reduce_sum_m2.stan', line 73, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 75, column 6 to column 43)",
  " (in 'reduce_sum_m2.stan', line 74, column 27 to line 76, column 5)",
  " (in 'reduce_sum_m2.stan', line 74, column 4 to line 76, column 5)",
  " (in 'reduce_sum_m2.stan', line 77, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 72, column 68 to line 78, column 3)",
  " (in 'reduce_sum_m2.stan', line 80, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 82, column 6 to column 54)",
  " (in 'reduce_sum_m2.stan', line 81, column 27 to line 83, column 5)",
  " (in 'reduce_sum_m2.stan', line 81, column 4 to line 83, column 5)",
  " (in 'reduce_sum_m2.stan', line 84, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 79, column 64 to line 85, column 3)",
  " (in 'reduce_sum_m2.stan', line 87, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 90, column 8 to column 48)",
  " (in 'reduce_sum_m2.stan', line 89, column 32 to line 91, column 7)",
  " (in 'reduce_sum_m2.stan', line 89, column 6 to line 91, column 7)",
  " (in 'reduce_sum_m2.stan', line 88, column 27 to line 92, column 5)",
  " (in 'reduce_sum_m2.stan', line 88, column 4 to line 92, column 5)",
  " (in 'reduce_sum_m2.stan', line 93, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 86, column 63 to line 94, column 3)",
  " (in 'reduce_sum_m2.stan', line 96, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 99, column 8 to column 59)",
  " (in 'reduce_sum_m2.stan', line 98, column 32 to line 100, column 7)",
  " (in 'reduce_sum_m2.stan', line 98, column 6 to line 100, column 7)",
  " (in 'reduce_sum_m2.stan', line 97, column 27 to line 101, column 5)",
  " (in 'reduce_sum_m2.stan', line 97, column 4 to line 101, column 5)",
  " (in 'reduce_sum_m2.stan', line 102, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 95, column 65 to line 103, column 3)",
  " (in 'reduce_sum_m2.stan', line 105, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 108, column 8 to column 59)",
  " (in 'reduce_sum_m2.stan', line 107, column 32 to line 109, column 7)",
  " (in 'reduce_sum_m2.stan', line 107, column 6 to line 109, column 7)",
  " (in 'reduce_sum_m2.stan', line 106, column 27 to line 110, column 5)",
  " (in 'reduce_sum_m2.stan', line 106, column 4 to line 110, column 5)",
  " (in 'reduce_sum_m2.stan', line 111, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 104, column 69 to line 112, column 3)",
  " (in 'reduce_sum_m2.stan', line 114, column 4 to column 24)",
  " (in 'reduce_sum_m2.stan', line 117, column 8 to column 59)",
  " (in 'reduce_sum_m2.stan', line 116, column 32 to line 118, column 7)",
  " (in 'reduce_sum_m2.stan', line 116, column 6 to line 118, column 7)",
  " (in 'reduce_sum_m2.stan', line 115, column 27 to line 119, column 5)",
  " (in 'reduce_sum_m2.stan', line 115, column 4 to line 119, column 5)",
  " (in 'reduce_sum_m2.stan', line 120, column 4 to column 20)",
  " (in 'reduce_sum_m2.stan', line 113, column 65 to line 121, column 3)"};
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
g1(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_col_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
g2(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_row_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
g3(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
g4(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T0__>>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
g5(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
g6(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_row_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
g7(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T0__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
g8(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h1(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_col_vector<stan::value_type_t<T3__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T3__>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h2(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_row_vector<stan::value_type_t<T3__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T3__>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h3(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T3__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T3__>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h4(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T3__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h5(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T3__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h6(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::is_row_vector<stan::value_type_t<
                                                    stan::value_type_t<T3__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h7(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T3__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h8(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
struct h5_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_std_vector<stan::value_type_t<T3__>>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T3__>>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T3__>>>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y, const T1__& start, const T2__& end, std::ostream*
             pstream__, const T3__& a) const {
    return h5(y, (start + 1), (end + 1), a, pstream__);
  }
};
struct h1_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T3__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T3__>>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y, const T1__& start, const T2__& end, std::ostream*
             pstream__, const T3__& a) const {
    return h1(y, (start + 1), (end + 1), a, pstream__);
  }
};
struct g3_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_row_vector<stan::value_type_t<T0__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return g3(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct h7_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_std_vector<stan::value_type_t<T3__>>,
                                stan::is_row_vector<stan::value_type_t<
                                                      stan::value_type_t<T3__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T3__>>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y, const T1__& start, const T2__& end, std::ostream*
             pstream__, const T3__& a) const {
    return h7(y, (start + 1), (end + 1), a, pstream__);
  }
};
struct h3_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_row_vector<stan::value_type_t<T3__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T3__>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y, const T1__& start, const T2__& end, std::ostream*
             pstream__, const T3__& a) const {
    return h3(y, (start + 1), (end + 1), a, pstream__);
  }
};
struct g2_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_col_vector<stan::value_type_t<T0__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return g2(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct g8_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_std_vector<stan::value_type_t<T0__>>,
                                stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                                stan::value_type_t<T0__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return g8(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct h2_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_col_vector<stan::value_type_t<T3__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T3__>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y, const T1__& start, const T2__& end, std::ostream*
             pstream__, const T3__& a) const {
    return h2(y, (start + 1), (end + 1), a, pstream__);
  }
};
struct h8_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_std_vector<stan::value_type_t<T3__>>,
                                stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                                stan::value_type_t<T3__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T3__>>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y, const T1__& start, const T2__& end, std::ostream*
             pstream__, const T3__& a) const {
    return h8(y, (start + 1), (end + 1), a, pstream__);
  }
};
struct g7_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_std_vector<stan::value_type_t<T0__>>,
                                stan::is_row_vector<stan::value_type_t<
                                                      stan::value_type_t<T0__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return g7(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct g4_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_eigen_matrix_dynamic<stan::value_type_t<T0__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return g4(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct h4_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_eigen_matrix_dynamic<stan::value_type_t<T3__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T3__>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y, const T1__& start, const T2__& end, std::ostream*
             pstream__, const T3__& a) const {
    return h4(y, (start + 1), (end + 1), a, pstream__);
  }
};
struct g6_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_std_vector<stan::value_type_t<T0__>>,
                                stan::is_col_vector<stan::value_type_t<
                                                      stan::value_type_t<T0__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return g6(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct g5_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_std_vector<stan::value_type_t<T0__>>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T0__>>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T0__>>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return g5(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct h6_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_std_vector<stan::value_type_t<T3__>>,
                                stan::is_col_vector<stan::value_type_t<
                                                      stan::value_type_t<T3__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T3__>>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y, const T1__& start, const T2__& end, std::ostream*
             pstream__, const T3__& a) const {
    return h6(y, (start + 1), (end + 1), a, pstream__);
  }
};
struct g1_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return g1(y_slice, (start + 1), (end + 1), pstream__);
  }
};
// real g1(array[] real, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
g1(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 76;
    return stan::math::normal_lpdf<false>(y_slice, 0, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g2(array[] vector, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_col_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
g2(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 78;
    sum_lpdf = 0.0;
    current_statement__ = 81;
    for (int n = 1; n <= stan::math::size(y_slice); ++n) {
      current_statement__ = 79;
      sum_lpdf = (sum_lpdf +
        stan::math::normal_lpdf<false>(
          stan::model::rvalue(y_slice, "y_slice", stan::model::index_uni(n)),
          0, 1));
    }
    current_statement__ = 82;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g3(array[] row_vector, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_row_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
g3(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 84;
    sum_lpdf = 0.0;
    current_statement__ = 87;
    for (int n = 1; n <= stan::math::size(y_slice); ++n) {
      current_statement__ = 85;
      sum_lpdf = (sum_lpdf +
        stan::math::normal_lpdf<false>(
          stan::model::rvalue(y_slice, "y_slice", stan::model::index_uni(n)),
          0, 1));
    }
    current_statement__ = 88;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g4(array[] matrix, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
g4(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 90;
    sum_lpdf = 0.0;
    current_statement__ = 93;
    for (int n = 1; n <= stan::math::size(y_slice); ++n) {
      current_statement__ = 91;
      sum_lpdf = (sum_lpdf +
        stan::math::normal_lpdf<false>(
          stan::math::to_vector(
            stan::model::rvalue(y_slice, "y_slice", stan::model::index_uni(n))),
          0, 1));
    }
    current_statement__ = 94;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g5(array[,] real, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T0__>>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
g5(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 96;
    sum_lpdf = 0.0;
    current_statement__ = 101;
    for (int n = 1; n <= stan::math::size(y_slice); ++n) {
      current_statement__ = 99;
      for (int m = 1; m <=
           stan::math::size(
             stan::model::rvalue(y_slice, "y_slice",
               stan::model::index_uni(n))); ++m) {
        current_statement__ = 97;
        sum_lpdf = (sum_lpdf +
          stan::math::normal_lpdf<false>(
            stan::model::rvalue(y_slice, "y_slice",
              stan::model::index_uni(n), stan::model::index_uni(m)), 0, 1));
      }
    }
    current_statement__ = 102;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g6(array[,] vector, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
g6(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 104;
    sum_lpdf = 0.0;
    current_statement__ = 109;
    for (int n = 1; n <= stan::math::size(y_slice); ++n) {
      current_statement__ = 107;
      for (int m = 1; m <=
           stan::math::size(
             stan::model::rvalue(y_slice, "y_slice",
               stan::model::index_uni(n))); ++m) {
        current_statement__ = 105;
        sum_lpdf = (sum_lpdf +
          stan::math::normal_lpdf<false>(
            stan::math::to_vector(
              stan::model::rvalue(y_slice, "y_slice",
                stan::model::index_uni(n), stan::model::index_uni(m))), 0, 1));
      }
    }
    current_statement__ = 110;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g7(array[,] row_vector, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_row_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
g7(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 112;
    sum_lpdf = 0.0;
    current_statement__ = 117;
    for (int n = 1; n <= stan::math::size(y_slice); ++n) {
      current_statement__ = 115;
      for (int m = 1; m <=
           stan::math::size(
             stan::model::rvalue(y_slice, "y_slice",
               stan::model::index_uni(n))); ++m) {
        current_statement__ = 113;
        sum_lpdf = (sum_lpdf +
          stan::math::normal_lpdf<false>(
            stan::math::to_vector(
              stan::model::rvalue(y_slice, "y_slice",
                stan::model::index_uni(n), stan::model::index_uni(m))), 0, 1));
      }
    }
    current_statement__ = 118;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g8(array[,] matrix, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T0__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
g8(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 120;
    sum_lpdf = 0.0;
    current_statement__ = 125;
    for (int n = 1; n <= stan::math::size(y_slice); ++n) {
      current_statement__ = 123;
      for (int m = 1; m <=
           stan::math::size(
             stan::model::rvalue(y_slice, "y_slice",
               stan::model::index_uni(n))); ++m) {
        current_statement__ = 121;
        sum_lpdf = (sum_lpdf +
          stan::math::normal_lpdf<false>(
            stan::math::to_vector(
              stan::model::rvalue(y_slice, "y_slice",
                stan::model::index_uni(n), stan::model::index_uni(m))), 0, 1));
      }
    }
    current_statement__ = 126;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real h1(array[] real, int, int, array[] real)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h1(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 128;
    return stan::math::normal_lpdf<false>(
             stan::model::rvalue(a, "a",
               stan::model::index_min_max(start, end)), 0, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real h2(array[] real, int, int, array[] vector)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_col_vector<stan::value_type_t<T3__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T3__>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h2(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 130;
    sum_lpdf = 0.0;
    current_statement__ = 133;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 131;
      sum_lpdf = (sum_lpdf +
        stan::math::normal_lpdf<false>(
          stan::model::rvalue(a, "a", stan::model::index_uni(n)), 0, 1));
    }
    current_statement__ = 134;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real h3(array[] real, int, int, array[] row_vector)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_row_vector<stan::value_type_t<T3__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T3__>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h3(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 136;
    sum_lpdf = 0.0;
    current_statement__ = 139;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 137;
      sum_lpdf = (sum_lpdf +
        stan::math::normal_lpdf<false>(
          stan::model::rvalue(a, "a", stan::model::index_uni(n)), 0, 1));
    }
    current_statement__ = 140;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real h4(array[] real, int, int, array[] matrix)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T3__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T3__>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h4(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 142;
    sum_lpdf = 0.0;
    current_statement__ = 145;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 143;
      sum_lpdf = (sum_lpdf +
        stan::math::normal_lpdf<false>(
          stan::math::to_vector(
            stan::model::rvalue(a, "a", stan::model::index_uni(n))), 0, 1));
    }
    current_statement__ = 146;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real h5(array[] real, int, int, array[,] real)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T3__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h5(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 148;
    sum_lpdf = 0.0;
    current_statement__ = 153;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 151;
      for (int m = 1; m <=
           stan::math::size(
             stan::model::rvalue(a, "a", stan::model::index_uni(n))); ++m) {
        current_statement__ = 149;
        sum_lpdf = (sum_lpdf +
          stan::math::normal_lpdf<false>(
            stan::model::rvalue(a, "a", stan::model::index_uni(n),
              stan::model::index_uni(m)), 0, 1));
      }
    }
    current_statement__ = 154;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real h6(array[] real, int, int, array[,] vector)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T3__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h6(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 156;
    sum_lpdf = 0.0;
    current_statement__ = 161;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 159;
      for (int m = 1; m <=
           stan::math::size(
             stan::model::rvalue(a, "a", stan::model::index_uni(n))); ++m) {
        current_statement__ = 157;
        sum_lpdf = (sum_lpdf +
          stan::math::normal_lpdf<false>(
            stan::math::to_vector(
              stan::model::rvalue(a, "a", stan::model::index_uni(n),
                stan::model::index_uni(m))), 0, 1));
      }
    }
    current_statement__ = 162;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real h7(array[] real, int, int, array[,] row_vector)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::is_row_vector<stan::value_type_t<
                                                    stan::value_type_t<T3__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h7(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 164;
    sum_lpdf = 0.0;
    current_statement__ = 169;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 167;
      for (int m = 1; m <=
           stan::math::size(
             stan::model::rvalue(a, "a", stan::model::index_uni(n))); ++m) {
        current_statement__ = 165;
        sum_lpdf = (sum_lpdf +
          stan::math::normal_lpdf<false>(
            stan::math::to_vector(
              stan::model::rvalue(a, "a", stan::model::index_uni(n),
                stan::model::index_uni(m))), 0, 1));
      }
    }
    current_statement__ = 170;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real h8(array[] real, int, int, array[,] matrix)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T3__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
h8(const T0__& y, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ sum_lpdf = DUMMY_VAR__;
    current_statement__ = 172;
    sum_lpdf = 0.0;
    current_statement__ = 177;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 175;
      for (int m = 1; m <=
           stan::math::size(
             stan::model::rvalue(a, "a", stan::model::index_uni(n))); ++m) {
        current_statement__ = 173;
        sum_lpdf = (sum_lpdf +
          stan::math::normal_lpdf<false>(
            stan::math::to_vector(
              stan::model::rvalue(a, "a", stan::model::index_uni(n),
                stan::model::index_uni(m))), 0, 1));
      }
    }
    current_statement__ = 178;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class reduce_sum_m2_model final : public model_base_crtp<reduce_sum_m2_model> {
 private:
  int N;
  std::vector<double> x;
 public:
  ~reduce_sum_m2_model() {}
  reduce_sum_m2_model(stan::io::var_context& context__, unsigned int
                      random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "reduce_sum_m2_model_namespace::reduce_sum_m2_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 33;
      N = std::numeric_limits<int>::min();
      current_statement__ = 33;
      N = 2;
      current_statement__ = 34;
      stan::math::validate_non_negative_index("x", "N", N);
      current_statement__ = 35;
      x = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 36;
      stan::math::validate_non_negative_index("a8", "N", N);
      current_statement__ = 37;
      stan::math::validate_non_negative_index("a8", "N", N);
      current_statement__ = 38;
      stan::math::validate_non_negative_index("a8", "N", N);
      current_statement__ = 39;
      stan::math::validate_non_negative_index("a8", "N", N);
      current_statement__ = 40;
      stan::math::validate_non_negative_index("a7", "N", N);
      current_statement__ = 41;
      stan::math::validate_non_negative_index("a7", "N", N);
      current_statement__ = 42;
      stan::math::validate_non_negative_index("a7", "N", N);
      current_statement__ = 43;
      stan::math::validate_non_negative_index("a6", "N", N);
      current_statement__ = 44;
      stan::math::validate_non_negative_index("a6", "N", N);
      current_statement__ = 45;
      stan::math::validate_non_negative_index("a6", "N", N);
      current_statement__ = 46;
      stan::math::validate_non_negative_index("a5", "N", N);
      current_statement__ = 47;
      stan::math::validate_non_negative_index("a5", "N", N);
      current_statement__ = 48;
      stan::math::validate_non_negative_index("a4", "N", N);
      current_statement__ = 49;
      stan::math::validate_non_negative_index("a4", "N", N);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("a4", "N", N);
      current_statement__ = 51;
      stan::math::validate_non_negative_index("a3", "N", N);
      current_statement__ = 52;
      stan::math::validate_non_negative_index("a3", "N", N);
      current_statement__ = 53;
      stan::math::validate_non_negative_index("a2", "N", N);
      current_statement__ = 54;
      stan::math::validate_non_negative_index("a2", "N", N);
      current_statement__ = 55;
      stan::math::validate_non_negative_index("a1", "N", N);
      current_statement__ = 56;
      stan::math::validate_non_negative_index("y8", "N", N);
      current_statement__ = 57;
      stan::math::validate_non_negative_index("y8", "N", N);
      current_statement__ = 58;
      stan::math::validate_non_negative_index("y8", "N", N);
      current_statement__ = 59;
      stan::math::validate_non_negative_index("y8", "N", N);
      current_statement__ = 60;
      stan::math::validate_non_negative_index("y7", "N", N);
      current_statement__ = 61;
      stan::math::validate_non_negative_index("y7", "N", N);
      current_statement__ = 62;
      stan::math::validate_non_negative_index("y7", "N", N);
      current_statement__ = 63;
      stan::math::validate_non_negative_index("y6", "N", N);
      current_statement__ = 64;
      stan::math::validate_non_negative_index("y6", "N", N);
      current_statement__ = 65;
      stan::math::validate_non_negative_index("y6", "N", N);
      current_statement__ = 66;
      stan::math::validate_non_negative_index("y5", "N", N);
      current_statement__ = 67;
      stan::math::validate_non_negative_index("y5", "N", N);
      current_statement__ = 68;
      stan::math::validate_non_negative_index("y4", "N", N);
      current_statement__ = 69;
      stan::math::validate_non_negative_index("y4", "N", N);
      current_statement__ = 70;
      stan::math::validate_non_negative_index("y4", "N", N);
      current_statement__ = 71;
      stan::math::validate_non_negative_index("y3", "N", N);
      current_statement__ = 72;
      stan::math::validate_non_negative_index("y3", "N", N);
      current_statement__ = 73;
      stan::math::validate_non_negative_index("y2", "N", N);
      current_statement__ = 74;
      stan::math::validate_non_negative_index("y2", "N", N);
      current_statement__ = 75;
      stan::math::validate_non_negative_index("y1", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (N * (N * (N * N))) + (N * (N * N)) + (N * (N * N)) + (N
      * N) + (N * (N * N)) + (N * N) + (N * N) + N + (N * (N * (N * N))) + (N
      * (N * N)) + (N * (N * N)) + (N * N) + (N * (N * N)) + (N * N) + (N *
      N) + N;
  }
  inline std::string model_name() const final {
    return "reduce_sum_m2_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "reduce_sum_m2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> a8 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N,
              DUMMY_VAR__)));
      current_statement__ = 1;
      a8 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>>(N,
             N, N, N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> a7 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 2;
      a7 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
             N, N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> a6 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 3;
      a6 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
             N, N);
      std::vector<std::vector<local_scalar_t__>> a5 =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      current_statement__ = 4;
      a5 = in__.template read<std::vector<std::vector<local_scalar_t__>>>(N,
             N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> a4 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
      current_statement__ = 5;
      a4 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N, N, N);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> a3 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 6;
      a3 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N, N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> a2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 7;
      a2 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N, N);
      std::vector<local_scalar_t__> a1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 8;
      a1 = in__.template read<std::vector<local_scalar_t__>>(N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> y8 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N,
              DUMMY_VAR__)));
      current_statement__ = 9;
      y8 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>>(N,
             N, N, N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> y7 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 10;
      y7 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
             N, N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> y6 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 11;
      y6 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
             N, N);
      std::vector<std::vector<local_scalar_t__>> y5 =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      current_statement__ = 12;
      y5 = in__.template read<std::vector<std::vector<local_scalar_t__>>>(N,
             N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> y4 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
      current_statement__ = 13;
      y4 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N, N, N);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> y3 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 14;
      y3 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N, N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> y2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 15;
      y2 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N, N);
      std::vector<local_scalar_t__> y1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 16;
      y1 = in__.template read<std::vector<local_scalar_t__>>(N);
      {
        current_statement__ = 17;
        lp_accum__.add(stan::math::reduce_sum<h8_rsfunctor__>(x, 1,
                         pstream__, a8));
        current_statement__ = 18;
        lp_accum__.add(stan::math::reduce_sum<h7_rsfunctor__>(x, 1,
                         pstream__, a7));
        current_statement__ = 19;
        lp_accum__.add(stan::math::reduce_sum<h6_rsfunctor__>(x, 1,
                         pstream__, a6));
        current_statement__ = 20;
        lp_accum__.add(stan::math::reduce_sum<h5_rsfunctor__>(x, 1,
                         pstream__, a5));
        current_statement__ = 21;
        lp_accum__.add(stan::math::reduce_sum<h4_rsfunctor__>(x, 1,
                         pstream__, a4));
        current_statement__ = 22;
        lp_accum__.add(stan::math::reduce_sum<h3_rsfunctor__>(x, 1,
                         pstream__, a3));
        current_statement__ = 23;
        lp_accum__.add(stan::math::reduce_sum<h2_rsfunctor__>(x, 1,
                         pstream__, a2));
        current_statement__ = 24;
        lp_accum__.add(stan::math::reduce_sum<h1_rsfunctor__>(x, 1,
                         pstream__, a1));
        current_statement__ = 25;
        lp_accum__.add(stan::math::reduce_sum<g8_rsfunctor__>(y8, 1,
                         pstream__));
        current_statement__ = 26;
        lp_accum__.add(stan::math::reduce_sum<g7_rsfunctor__>(y7, 1,
                         pstream__));
        current_statement__ = 27;
        lp_accum__.add(stan::math::reduce_sum<g6_rsfunctor__>(y6, 1,
                         pstream__));
        current_statement__ = 28;
        lp_accum__.add(stan::math::reduce_sum<g5_rsfunctor__>(y5, 1,
                         pstream__));
        current_statement__ = 29;
        lp_accum__.add(stan::math::reduce_sum<g4_rsfunctor__>(y4, 1,
                         pstream__));
        current_statement__ = 30;
        lp_accum__.add(stan::math::reduce_sum<g3_rsfunctor__>(y3, 1,
                         pstream__));
        current_statement__ = 31;
        lp_accum__.add(stan::math::reduce_sum<g2_rsfunctor__>(y2, 1,
                         pstream__));
        current_statement__ = 32;
        lp_accum__.add(stan::math::reduce_sum<g1_rsfunctor__>(y1, 1,
                         pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "reduce_sum_m2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> a8 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N,
              DUMMY_VAR__)));
      current_statement__ = 1;
      a8 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>>(N,
             N, N, N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> a7 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 2;
      a7 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
             N, N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> a6 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 3;
      a6 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
             N, N);
      std::vector<std::vector<local_scalar_t__>> a5 =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      current_statement__ = 4;
      a5 = in__.template read<std::vector<std::vector<local_scalar_t__>>>(N,
             N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> a4 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
      current_statement__ = 5;
      a4 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N, N, N);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> a3 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 6;
      a3 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N, N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> a2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 7;
      a2 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N, N);
      std::vector<local_scalar_t__> a1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 8;
      a1 = in__.template read<std::vector<local_scalar_t__>>(N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> y8 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N,
              DUMMY_VAR__)));
      current_statement__ = 9;
      y8 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>>(N,
             N, N, N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> y7 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 10;
      y7 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
             N, N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> y6 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 11;
      y6 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
             N, N);
      std::vector<std::vector<local_scalar_t__>> y5 =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      current_statement__ = 12;
      y5 = in__.template read<std::vector<std::vector<local_scalar_t__>>>(N,
             N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> y4 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
      current_statement__ = 13;
      y4 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N, N, N);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> y3 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 14;
      y3 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N, N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> y2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 15;
      y2 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N, N);
      std::vector<local_scalar_t__> y1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 16;
      y1 = in__.template read<std::vector<local_scalar_t__>>(N);
      {
        current_statement__ = 17;
        lp_accum__.add(stan::math::reduce_sum<h8_rsfunctor__>(x, 1,
                         pstream__, a8));
        current_statement__ = 18;
        lp_accum__.add(stan::math::reduce_sum<h7_rsfunctor__>(x, 1,
                         pstream__, a7));
        current_statement__ = 19;
        lp_accum__.add(stan::math::reduce_sum<h6_rsfunctor__>(x, 1,
                         pstream__, a6));
        current_statement__ = 20;
        lp_accum__.add(stan::math::reduce_sum<h5_rsfunctor__>(x, 1,
                         pstream__, a5));
        current_statement__ = 21;
        lp_accum__.add(stan::math::reduce_sum<h4_rsfunctor__>(x, 1,
                         pstream__, a4));
        current_statement__ = 22;
        lp_accum__.add(stan::math::reduce_sum<h3_rsfunctor__>(x, 1,
                         pstream__, a3));
        current_statement__ = 23;
        lp_accum__.add(stan::math::reduce_sum<h2_rsfunctor__>(x, 1,
                         pstream__, a2));
        current_statement__ = 24;
        lp_accum__.add(stan::math::reduce_sum<h1_rsfunctor__>(x, 1,
                         pstream__, a1));
        current_statement__ = 25;
        lp_accum__.add(stan::math::reduce_sum<g8_rsfunctor__>(y8, 1,
                         pstream__));
        current_statement__ = 26;
        lp_accum__.add(stan::math::reduce_sum<g7_rsfunctor__>(y7, 1,
                         pstream__));
        current_statement__ = 27;
        lp_accum__.add(stan::math::reduce_sum<g6_rsfunctor__>(y6, 1,
                         pstream__));
        current_statement__ = 28;
        lp_accum__.add(stan::math::reduce_sum<g5_rsfunctor__>(y5, 1,
                         pstream__));
        current_statement__ = 29;
        lp_accum__.add(stan::math::reduce_sum<g4_rsfunctor__>(y4, 1,
                         pstream__));
        current_statement__ = 30;
        lp_accum__.add(stan::math::reduce_sum<g3_rsfunctor__>(y3, 1,
                         pstream__));
        current_statement__ = 31;
        lp_accum__.add(stan::math::reduce_sum<g2_rsfunctor__>(y2, 1,
                         pstream__));
        current_statement__ = 32;
        lp_accum__.add(stan::math::reduce_sum<g1_rsfunctor__>(y1, 1,
                         pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "reduce_sum_m2_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<std::vector<Eigen::Matrix<double,-1,-1>>> a8 =
        std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>(N,
          std::vector<Eigen::Matrix<double,-1,-1>>(N,
            Eigen::Matrix<double,-1,-1>::Constant(N, N,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 1;
      a8 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>>(N,
             N, N, N);
      std::vector<std::vector<Eigen::Matrix<double,1,-1>>> a7 =
        std::vector<std::vector<Eigen::Matrix<double,1,-1>>>(N,
          std::vector<Eigen::Matrix<double,1,-1>>(N,
            Eigen::Matrix<double,1,-1>::Constant(N,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 2;
      a7 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
             N, N);
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> a6 =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(N,
          std::vector<Eigen::Matrix<double,-1,1>>(N,
            Eigen::Matrix<double,-1,1>::Constant(N,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 3;
      a6 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
             N, N);
      std::vector<std::vector<double>> a5 =
        std::vector<std::vector<double>>(N,
          std::vector<double>(N, std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 4;
      a5 = in__.template read<std::vector<std::vector<local_scalar_t__>>>(N,
             N);
      std::vector<Eigen::Matrix<double,-1,-1>> a4 =
        std::vector<Eigen::Matrix<double,-1,-1>>(N,
          Eigen::Matrix<double,-1,-1>::Constant(N, N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 5;
      a4 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N, N, N);
      std::vector<Eigen::Matrix<double,1,-1>> a3 =
        std::vector<Eigen::Matrix<double,1,-1>>(N,
          Eigen::Matrix<double,1,-1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 6;
      a3 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N, N);
      std::vector<Eigen::Matrix<double,-1,1>> a2 =
        std::vector<Eigen::Matrix<double,-1,1>>(N,
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 7;
      a2 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N, N);
      std::vector<double> a1 =
        std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 8;
      a1 = in__.template read<std::vector<local_scalar_t__>>(N);
      std::vector<std::vector<Eigen::Matrix<double,-1,-1>>> y8 =
        std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>(N,
          std::vector<Eigen::Matrix<double,-1,-1>>(N,
            Eigen::Matrix<double,-1,-1>::Constant(N, N,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 9;
      y8 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>>(N,
             N, N, N);
      std::vector<std::vector<Eigen::Matrix<double,1,-1>>> y7 =
        std::vector<std::vector<Eigen::Matrix<double,1,-1>>>(N,
          std::vector<Eigen::Matrix<double,1,-1>>(N,
            Eigen::Matrix<double,1,-1>::Constant(N,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 10;
      y7 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
             N, N);
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> y6 =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(N,
          std::vector<Eigen::Matrix<double,-1,1>>(N,
            Eigen::Matrix<double,-1,1>::Constant(N,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 11;
      y6 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
             N, N);
      std::vector<std::vector<double>> y5 =
        std::vector<std::vector<double>>(N,
          std::vector<double>(N, std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 12;
      y5 = in__.template read<std::vector<std::vector<local_scalar_t__>>>(N,
             N);
      std::vector<Eigen::Matrix<double,-1,-1>> y4 =
        std::vector<Eigen::Matrix<double,-1,-1>>(N,
          Eigen::Matrix<double,-1,-1>::Constant(N, N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 13;
      y4 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N, N, N);
      std::vector<Eigen::Matrix<double,1,-1>> y3 =
        std::vector<Eigen::Matrix<double,1,-1>>(N,
          Eigen::Matrix<double,1,-1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 14;
      y3 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N, N);
      std::vector<Eigen::Matrix<double,-1,1>> y2 =
        std::vector<Eigen::Matrix<double,-1,1>>(N,
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 15;
      y2 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N, N);
      std::vector<double> y1 =
        std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 16;
      y1 = in__.template read<std::vector<local_scalar_t__>>(N);
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              out__.write(stan::model::rvalue(a8, "a8",
                            stan::model::index_uni(sym4__),
                            stan::model::index_uni(sym3__),
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(sym1__)));
            }
          }
        }
      }
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            out__.write(a7[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            out__.write(a6[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(a5[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            out__.write(stan::model::rvalue(a4, "a4",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(a3[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(a2[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      out__.write(a1);
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              out__.write(stan::model::rvalue(y8, "y8",
                            stan::model::index_uni(sym4__),
                            stan::model::index_uni(sym3__),
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(sym1__)));
            }
          }
        }
      }
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            out__.write(y7[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            out__.write(y6[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(y5[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            out__.write(stan::model::rvalue(y4, "y4",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(y3[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(y2[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      out__.write(y1);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> a8 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N,
              DUMMY_VAR__)));
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              current_statement__ = 1;
              stan::model::assign(a8, in__.read<local_scalar_t__>(),
                "assigning variable a8", stan::model::index_uni(sym4__),
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
            }
          }
        }
      }
      out__.write(a8);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> a7 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 2;
            stan::model::assign(a7, in__.read<local_scalar_t__>(),
              "assigning variable a7", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write(a7);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> a6 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 3;
            stan::model::assign(a6, in__.read<local_scalar_t__>(),
              "assigning variable a6", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write(a6);
      std::vector<std::vector<local_scalar_t__>> a5 =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 4;
          a5[(sym2__ - 1)][(sym1__ - 1)] = in__.read<local_scalar_t__>();
        }
      }
      out__.write(a5);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> a4 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 5;
            stan::model::assign(a4, in__.read<local_scalar_t__>(),
              "assigning variable a4", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write(a4);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> a3 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 6;
          stan::model::assign(a3, in__.read<local_scalar_t__>(),
            "assigning variable a3", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write(a3);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> a2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 7;
          stan::model::assign(a2, in__.read<local_scalar_t__>(),
            "assigning variable a2", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write(a2);
      std::vector<local_scalar_t__> a1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(a1, in__.read<std::vector<local_scalar_t__>>(N),
        "assigning variable a1");
      out__.write(a1);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> y8 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N,
              DUMMY_VAR__)));
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              current_statement__ = 9;
              stan::model::assign(y8, in__.read<local_scalar_t__>(),
                "assigning variable y8", stan::model::index_uni(sym4__),
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
            }
          }
        }
      }
      out__.write(y8);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> y7 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 10;
            stan::model::assign(y7, in__.read<local_scalar_t__>(),
              "assigning variable y7", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write(y7);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> y6 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 11;
            stan::model::assign(y6, in__.read<local_scalar_t__>(),
              "assigning variable y6", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write(y6);
      std::vector<std::vector<local_scalar_t__>> y5 =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 12;
          y5[(sym2__ - 1)][(sym1__ - 1)] = in__.read<local_scalar_t__>();
        }
      }
      out__.write(y5);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> y4 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 13;
            stan::model::assign(y4, in__.read<local_scalar_t__>(),
              "assigning variable y4", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write(y4);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> y3 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 14;
          stan::model::assign(y3, in__.read<local_scalar_t__>(),
            "assigning variable y3", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write(y3);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> y2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 15;
          stan::model::assign(y2, in__.read<local_scalar_t__>(),
            "assigning variable y2", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write(y2);
      std::vector<local_scalar_t__> y1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 16;
      stan::model::assign(y1, in__.read<std::vector<local_scalar_t__>>(N),
        "assigning variable y1");
      out__.write(y1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "a8", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "a7", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "a6", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "a5", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "a4", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "a3", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "a2", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization", "a1", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 9;
      context__.validate_dims("parameter initialization", "y8", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 10;
      context__.validate_dims("parameter initialization", "y7", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      current_statement__ = 11;
      context__.validate_dims("parameter initialization", "y6", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      current_statement__ = 12;
      context__.validate_dims("parameter initialization", "y5", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 13;
      context__.validate_dims("parameter initialization", "y4", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      current_statement__ = 14;
      context__.validate_dims("parameter initialization", "y3", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 15;
      context__.validate_dims("parameter initialization", "y2", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 16;
      context__.validate_dims("parameter initialization", "y1", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> a8 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N,
              DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> a8_flat__;
        current_statement__ = 1;
        a8_flat__ = context__.vals_r("a8");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                stan::model::assign(a8, a8_flat__[(pos__ - 1)],
                  "assigning variable a8", stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      out__.write(a8);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> a7 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> a7_flat__;
        current_statement__ = 2;
        a7_flat__ = context__.vals_r("a7");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(a7, a7_flat__[(pos__ - 1)],
                "assigning variable a7", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(a7);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> a6 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> a6_flat__;
        current_statement__ = 3;
        a6_flat__ = context__.vals_r("a6");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(a6, a6_flat__[(pos__ - 1)],
                "assigning variable a6", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(a6);
      std::vector<std::vector<local_scalar_t__>> a5 =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> a5_flat__;
        current_statement__ = 4;
        a5_flat__ = context__.vals_r("a5");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(a5, a5_flat__[(pos__ - 1)],
              "assigning variable a5", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(a5);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> a4 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> a4_flat__;
        current_statement__ = 5;
        a4_flat__ = context__.vals_r("a4");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(a4, a4_flat__[(pos__ - 1)],
                "assigning variable a4", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(a4);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> a3 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> a3_flat__;
        current_statement__ = 6;
        a3_flat__ = context__.vals_r("a3");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(a3, a3_flat__[(pos__ - 1)],
              "assigning variable a3", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(a3);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> a2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> a2_flat__;
        current_statement__ = 7;
        a2_flat__ = context__.vals_r("a2");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(a2, a2_flat__[(pos__ - 1)],
              "assigning variable a2", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(a2);
      std::vector<local_scalar_t__> a1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 8;
      a1 = context__.vals_r("a1");
      out__.write(a1);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> y8 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N,
              DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> y8_flat__;
        current_statement__ = 9;
        y8_flat__ = context__.vals_r("y8");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                stan::model::assign(y8, y8_flat__[(pos__ - 1)],
                  "assigning variable y8", stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      out__.write(y8);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> y7 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> y7_flat__;
        current_statement__ = 10;
        y7_flat__ = context__.vals_r("y7");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(y7, y7_flat__[(pos__ - 1)],
                "assigning variable y7", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(y7);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> y6 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> y6_flat__;
        current_statement__ = 11;
        y6_flat__ = context__.vals_r("y6");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(y6, y6_flat__[(pos__ - 1)],
                "assigning variable y6", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(y6);
      std::vector<std::vector<local_scalar_t__>> y5 =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> y5_flat__;
        current_statement__ = 12;
        y5_flat__ = context__.vals_r("y5");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y5, y5_flat__[(pos__ - 1)],
              "assigning variable y5", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(y5);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> y4 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> y4_flat__;
        current_statement__ = 13;
        y4_flat__ = context__.vals_r("y4");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(y4, y4_flat__[(pos__ - 1)],
                "assigning variable y4", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(y4);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> y3 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> y3_flat__;
        current_statement__ = 14;
        y3_flat__ = context__.vals_r("y3");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y3, y3_flat__[(pos__ - 1)],
              "assigning variable y3", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(y3);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> y2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> y2_flat__;
        current_statement__ = 15;
        y2_flat__ = context__.vals_r("y2");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y2, y2_flat__[(pos__ - 1)],
              "assigning variable y2", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(y2);
      std::vector<local_scalar_t__> y1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 16;
      y1 = context__.vals_r("y1");
      out__.write(y1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"a8", "a7", "a6", "a5", "a4", "a3",
                "a2", "a1", "y8", "y7", "y6", "y5", "y4", "y3", "y2", "y1"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(N),
                                                 static_cast<size_t>(N),
                                                 static_cast<size_t>(N),
                                                 static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N), static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N), static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N), static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N), static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N), static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N), static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N), static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
            param_names__.emplace_back(std::string() + "a8" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "a7" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "a6" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "a5" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "a4" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "a3" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "a2" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "a1" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
            param_names__.emplace_back(std::string() + "y8" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y7" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y6" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y5" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y4" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y3" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y2" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y1" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
            param_names__.emplace_back(std::string() + "a8" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "a7" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "a6" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "a5" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "a4" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "a3" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "a2" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "a1" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
            param_names__.emplace_back(std::string() + "y8" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y7" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y6" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y5" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y4" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y3" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y2" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y1" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"a8\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"a7\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"a6\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"a5\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"a4\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"a3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y8\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"y7\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"y6\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"y5\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"y4\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"y3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"y2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"y1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"a8\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"a7\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"a6\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"a5\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"a4\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"a3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y8\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"y7\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"y6\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"y5\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"y4\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"y3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"y2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"y1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((((((((((N * (N * (N * N))) + (N * (N
      * N))) + (N * (N * N))) + (N * N)) + (N * (N * N))) + (N * N)) + (N *
      N)) + N) + (N * (N * (N * N)))) + (N * (N * N))) + (N * (N * N))) + (N
      * N)) + (N * (N * N))) + (N * N)) + (N * N)) + N);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((((((((((N * (N * (N * N))) + (N * (N
      * N))) + (N * (N * N))) + (N * N)) + (N * (N * N))) + (N * N)) + (N *
      N)) + N) + (N * (N * (N * N)))) + (N * (N * N))) + (N * (N * N))) + (N
      * N)) + (N * (N * N))) + (N * N)) + (N * N)) + N);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = reduce_sum_m2_model_namespace::reduce_sum_m2_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return reduce_sum_m2_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp reduce_sum_m3.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace reduce_sum_m3_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 342> locations_array__ =
  {" (found before start of program)",
  " (in 'reduce_sum_m3.stan', line 201, column 2 to column 19)",
  " (in 'reduce_sum_m3.stan', line 202, column 2 to column 24)",
  " (in 'reduce_sum_m3.stan', line 203, column 2 to column 28)",
  " (in 'reduce_sum_m3.stan', line 204, column 2 to column 27)",
  " (in 'reduce_sum_m3.stan', line 205, column 2 to column 22)",
  " (in 'reduce_sum_m3.stan', line 206, column 2 to column 27)",
  " (in 'reduce_sum_m3.stan', line 207, column 2 to column 31)",
  " (in 'reduce_sum_m3.stan', line 208, column 2 to column 30)",
  " (in 'reduce_sum_m3.stan', line 209, column 2 to column 10)",
  " (in 'reduce_sum_m3.stan', line 210, column 2 to column 16)",
  " (in 'reduce_sum_m3.stan', line 211, column 2 to column 20)",
  " (in 'reduce_sum_m3.stan', line 212, column 2 to column 19)",
  " (in 'reduce_sum_m3.stan', line 213, column 2 to column 26)",
  " (in 'reduce_sum_m3.stan', line 247, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 248, column 2 to column 60)",
  " (in 'reduce_sum_m3.stan', line 249, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 250, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 251, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 252, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 253, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 254, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 255, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 256, column 2 to column 36)",
  " (in 'reduce_sum_m3.stan', line 257, column 2 to column 38)",
  " (in 'reduce_sum_m3.stan', line 258, column 2 to column 38)",
  " (in 'reduce_sum_m3.stan', line 259, column 2 to column 37)",
  " (in 'reduce_sum_m3.stan', line 260, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 261, column 2 to column 40)",
  " (in 'reduce_sum_m3.stan', line 262, column 2 to column 40)",
  " (in 'reduce_sum_m3.stan', line 263, column 2 to column 40)",
  " (in 'reduce_sum_m3.stan', line 264, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 265, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 266, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 267, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 268, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 269, column 2 to column 41)",
  " (in 'reduce_sum_m3.stan', line 270, column 2 to column 41)",
  " (in 'reduce_sum_m3.stan', line 271, column 2 to column 41)",
  " (in 'reduce_sum_m3.stan', line 272, column 2 to line 273, column 76)",
  " (in 'reduce_sum_m3.stan', line 216, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 217, column 2 to column 60)",
  " (in 'reduce_sum_m3.stan', line 218, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 219, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 220, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 221, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 222, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 223, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 224, column 2 to column 34)",
  " (in 'reduce_sum_m3.stan', line 225, column 2 to column 36)",
  " (in 'reduce_sum_m3.stan', line 226, column 2 to column 38)",
  " (in 'reduce_sum_m3.stan', line 227, column 2 to column 38)",
  " (in 'reduce_sum_m3.stan', line 228, column 2 to column 37)",
  " (in 'reduce_sum_m3.stan', line 229, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 230, column 2 to column 40)",
  " (in 'reduce_sum_m3.stan', line 231, column 2 to column 40)",
  " (in 'reduce_sum_m3.stan', line 232, column 2 to column 40)",
  " (in 'reduce_sum_m3.stan', line 233, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 234, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 235, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 236, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 237, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 238, column 2 to column 41)",
  " (in 'reduce_sum_m3.stan', line 239, column 2 to column 41)",
  " (in 'reduce_sum_m3.stan', line 240, column 2 to column 41)",
  " (in 'reduce_sum_m3.stan', line 241, column 2 to line 242, column 60)",
  " (in 'reduce_sum_m3.stan', line 244, column 2 to column 16)",
  " (in 'reduce_sum_m3.stan', line 152, column 2 to column 8)",
  " (in 'reduce_sum_m3.stan', line 153, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 153, column 2 to column 20)",
  " (in 'reduce_sum_m3.stan', line 154, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 154, column 18 to column 19)",
  " (in 'reduce_sum_m3.stan', line 154, column 2 to column 25)",
  " (in 'reduce_sum_m3.stan', line 155, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 155, column 22 to column 23)",
  " (in 'reduce_sum_m3.stan', line 155, column 2 to column 29)",
  " (in 'reduce_sum_m3.stan', line 156, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 156, column 18 to column 19)",
  " (in 'reduce_sum_m3.stan', line 156, column 21 to column 22)",
  " (in 'reduce_sum_m3.stan', line 156, column 2 to column 28)",
  " (in 'reduce_sum_m3.stan', line 157, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 157, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 157, column 2 to column 23)",
  " (in 'reduce_sum_m3.stan', line 158, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 158, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 158, column 21 to column 22)",
  " (in 'reduce_sum_m3.stan', line 158, column 2 to column 28)",
  " (in 'reduce_sum_m3.stan', line 159, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 159, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 159, column 25 to column 26)",
  " (in 'reduce_sum_m3.stan', line 159, column 2 to column 32)",
  " (in 'reduce_sum_m3.stan', line 160, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 160, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 160, column 21 to column 22)",
  " (in 'reduce_sum_m3.stan', line 160, column 24 to column 25)",
  " (in 'reduce_sum_m3.stan', line 160, column 2 to column 31)",
  " (in 'reduce_sum_m3.stan', line 161, column 2 to column 11)",
  " (in 'reduce_sum_m3.stan', line 162, column 9 to column 10)",
  " (in 'reduce_sum_m3.stan', line 162, column 2 to column 17)",
  " (in 'reduce_sum_m3.stan', line 163, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 163, column 2 to column 21)",
  " (in 'reduce_sum_m3.stan', line 164, column 9 to column 10)",
  " (in 'reduce_sum_m3.stan', line 164, column 12 to column 13)",
  " (in 'reduce_sum_m3.stan', line 164, column 2 to column 20)",
  " (in 'reduce_sum_m3.stan', line 165, column 2 to column 11)",
  " (in 'reduce_sum_m3.stan', line 166, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 166, column 2 to column 20)",
  " (in 'reduce_sum_m3.stan', line 167, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 167, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 167, column 2 to column 23)",
  " (in 'reduce_sum_m3.stan', line 168, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 168, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 168, column 14 to column 15)",
  " (in 'reduce_sum_m3.stan', line 168, column 2 to column 26)",
  " (in 'reduce_sum_m3.stan', line 169, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 169, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 169, column 14 to column 15)",
  " (in 'reduce_sum_m3.stan', line 169, column 2 to column 27)",
  " (in 'reduce_sum_m3.stan', line 172, column 2 to column 36)",
  " (in 'reduce_sum_m3.stan', line 173, column 2 to column 63)",
  " (in 'reduce_sum_m3.stan', line 174, column 2 to column 36)",
  " (in 'reduce_sum_m3.stan', line 175, column 2 to column 36)",
  " (in 'reduce_sum_m3.stan', line 176, column 2 to column 36)",
  " (in 'reduce_sum_m3.stan', line 177, column 2 to column 36)",
  " (in 'reduce_sum_m3.stan', line 178, column 2 to column 36)",
  " (in 'reduce_sum_m3.stan', line 179, column 2 to column 36)",
  " (in 'reduce_sum_m3.stan', line 180, column 2 to column 36)",
  " (in 'reduce_sum_m3.stan', line 181, column 2 to column 37)",
  " (in 'reduce_sum_m3.stan', line 182, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 183, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 184, column 2 to column 39)",
  " (in 'reduce_sum_m3.stan', line 185, column 2 to column 42)",
  " (in 'reduce_sum_m3.stan', line 186, column 2 to column 43)",
  " (in 'reduce_sum_m3.stan', line 187, column 2 to column 43)",
  " (in 'reduce_sum_m3.stan', line 188, column 2 to column 43)",
  " (in 'reduce_sum_m3.stan', line 189, column 2 to column 42)",
  " (in 'reduce_sum_m3.stan', line 190, column 2 to column 42)",
  " (in 'reduce_sum_m3.stan', line 191, column 2 to column 42)",
  " (in 'reduce_sum_m3.stan', line 192, column 2 to column 42)",
  " (in 'reduce_sum_m3.stan', line 193, column 2 to column 42)",
  " (in 'reduce_sum_m3.stan', line 194, column 2 to column 44)",
  " (in 'reduce_sum_m3.stan', line 195, column 2 to column 44)",
  " (in 'reduce_sum_m3.stan', line 196, column 2 to column 44)",
  " (in 'reduce_sum_m3.stan', line 197, column 2 to line 198, column 77)",
  " (in 'reduce_sum_m3.stan', line 201, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 202, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 202, column 18 to column 19)",
  " (in 'reduce_sum_m3.stan', line 203, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 203, column 22 to column 23)",
  " (in 'reduce_sum_m3.stan', line 204, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 204, column 18 to column 19)",
  " (in 'reduce_sum_m3.stan', line 204, column 21 to column 22)",
  " (in 'reduce_sum_m3.stan', line 205, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 205, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 206, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 206, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 206, column 21 to column 22)",
  " (in 'reduce_sum_m3.stan', line 207, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 207, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 207, column 25 to column 26)",
  " (in 'reduce_sum_m3.stan', line 208, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 208, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 208, column 21 to column 22)",
  " (in 'reduce_sum_m3.stan', line 208, column 24 to column 25)",
  " (in 'reduce_sum_m3.stan', line 210, column 9 to column 10)",
  " (in 'reduce_sum_m3.stan', line 211, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 212, column 9 to column 10)",
  " (in 'reduce_sum_m3.stan', line 212, column 12 to column 13)",
  " (in 'reduce_sum_m3.stan', line 213, column 8 to column 9)",
  " (in 'reduce_sum_m3.stan', line 213, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 213, column 14 to column 15)",
  " (in 'reduce_sum_m3.stan', line 3, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 2, column 52 to line 4, column 3)",
  " (in 'reduce_sum_m3.stan', line 6, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 5, column 53 to line 7, column 3)",
  " (in 'reduce_sum_m3.stan', line 9, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 8, column 54 to line 10, column 3)",
  " (in 'reduce_sum_m3.stan', line 12, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 11, column 58 to line 13, column 3)",
  " (in 'reduce_sum_m3.stan', line 15, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 14, column 54 to line 16, column 3)",
  " (in 'reduce_sum_m3.stan', line 18, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 17, column 53 to line 19, column 3)",
  " (in 'reduce_sum_m3.stan', line 21, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 20, column 55 to line 22, column 3)",
  " (in 'reduce_sum_m3.stan', line 24, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 23, column 59 to line 25, column 3)",
  " (in 'reduce_sum_m3.stan', line 27, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 26, column 55 to line 28, column 3)",
  " (in 'reduce_sum_m3.stan', line 30, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 29, column 51 to line 31, column 3)",
  " (in 'reduce_sum_m3.stan', line 33, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 32, column 53 to line 34, column 3)",
  " (in 'reduce_sum_m3.stan', line 36, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 35, column 54 to line 37, column 3)",
  " (in 'reduce_sum_m3.stan', line 39, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 38, column 55 to line 40, column 3)",
  " (in 'reduce_sum_m3.stan', line 42, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 41, column 60 to line 43, column 3)",
  " (in 'reduce_sum_m3.stan', line 45, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 44, column 62 to line 46, column 3)",
  " (in 'reduce_sum_m3.stan', line 48, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 47, column 66 to line 49, column 3)",
  " (in 'reduce_sum_m3.stan', line 51, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 50, column 62 to line 52, column 3)",
  " (in 'reduce_sum_m3.stan', line 54, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 53, column 68 to line 55, column 3)",
  " (in 'reduce_sum_m3.stan', line 57, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 56, column 70 to line 58, column 3)",
  " (in 'reduce_sum_m3.stan', line 60, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 59, column 74 to line 61, column 3)",
  " (in 'reduce_sum_m3.stan', line 63, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 62, column 70 to line 64, column 3)",
  " (in 'reduce_sum_m3.stan', line 66, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 65, column 69 to line 67, column 3)",
  " (in 'reduce_sum_m3.stan', line 69, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 68, column 72 to line 70, column 3)",
  " (in 'reduce_sum_m3.stan', line 72, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 71, column 76 to line 73, column 3)",
  " (in 'reduce_sum_m3.stan', line 75, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 74, column 72 to line 76, column 3)",
  " (in 'reduce_sum_m3.stan', line 83, column 4 to line 84, column 34)",
  " (in 'reduce_sum_m3.stan', line 82, column 27 to line 85, column 3)",
  " (in 'reduce_sum_m3.stan', line 87, column 4 to column 10)",
  " (in 'reduce_sum_m3.stan', line 88, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 88, column 4 to column 22)",
  " (in 'reduce_sum_m3.stan', line 89, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 89, column 20 to column 21)",
  " (in 'reduce_sum_m3.stan', line 89, column 4 to column 27)",
  " (in 'reduce_sum_m3.stan', line 90, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 90, column 24 to column 25)",
  " (in 'reduce_sum_m3.stan', line 90, column 4 to column 31)",
  " (in 'reduce_sum_m3.stan', line 91, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 91, column 20 to column 21)",
  " (in 'reduce_sum_m3.stan', line 91, column 23 to column 24)",
  " (in 'reduce_sum_m3.stan', line 91, column 4 to column 30)",
  " (in 'reduce_sum_m3.stan', line 92, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 92, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 92, column 4 to column 25)",
  " (in 'reduce_sum_m3.stan', line 93, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 93, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 93, column 23 to column 24)",
  " (in 'reduce_sum_m3.stan', line 93, column 4 to column 30)",
  " (in 'reduce_sum_m3.stan', line 94, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 94, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 94, column 27 to column 28)",
  " (in 'reduce_sum_m3.stan', line 94, column 4 to column 34)",
  " (in 'reduce_sum_m3.stan', line 95, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 95, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 95, column 23 to column 24)",
  " (in 'reduce_sum_m3.stan', line 95, column 26 to column 27)",
  " (in 'reduce_sum_m3.stan', line 95, column 4 to column 33)",
  " (in 'reduce_sum_m3.stan', line 96, column 4 to column 13)",
  " (in 'reduce_sum_m3.stan', line 97, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 97, column 4 to column 19)",
  " (in 'reduce_sum_m3.stan', line 98, column 15 to column 16)",
  " (in 'reduce_sum_m3.stan', line 98, column 4 to column 23)",
  " (in 'reduce_sum_m3.stan', line 99, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 99, column 14 to column 15)",
  " (in 'reduce_sum_m3.stan', line 99, column 4 to column 22)",
  " (in 'reduce_sum_m3.stan', line 100, column 4 to column 13)",
  " (in 'reduce_sum_m3.stan', line 101, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 101, column 4 to column 22)",
  " (in 'reduce_sum_m3.stan', line 102, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 102, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 102, column 4 to column 25)",
  " (in 'reduce_sum_m3.stan', line 103, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 103, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 103, column 16 to column 17)",
  " (in 'reduce_sum_m3.stan', line 103, column 4 to column 28)",
  " (in 'reduce_sum_m3.stan', line 104, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 104, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 104, column 16 to column 17)",
  " (in 'reduce_sum_m3.stan', line 104, column 4 to column 29)",
  " (in 'reduce_sum_m3.stan', line 106, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 106, column 4 to column 21)",
  " (in 'reduce_sum_m3.stan', line 107, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 107, column 20 to column 21)",
  " (in 'reduce_sum_m3.stan', line 107, column 4 to column 26)",
  " (in 'reduce_sum_m3.stan', line 108, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 108, column 24 to column 25)",
  " (in 'reduce_sum_m3.stan', line 108, column 4 to column 30)",
  " (in 'reduce_sum_m3.stan', line 109, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 109, column 20 to column 21)",
  " (in 'reduce_sum_m3.stan', line 109, column 23 to column 24)",
  " (in 'reduce_sum_m3.stan', line 109, column 4 to column 29)",
  " (in 'reduce_sum_m3.stan', line 110, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 110, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 110, column 4 to column 24)",
  " (in 'reduce_sum_m3.stan', line 111, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 111, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 111, column 23 to column 24)",
  " (in 'reduce_sum_m3.stan', line 111, column 4 to column 29)",
  " (in 'reduce_sum_m3.stan', line 112, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 112, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 112, column 27 to column 28)",
  " (in 'reduce_sum_m3.stan', line 112, column 4 to column 33)",
  " (in 'reduce_sum_m3.stan', line 113, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 113, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 113, column 23 to column 24)",
  " (in 'reduce_sum_m3.stan', line 113, column 26 to column 27)",
  " (in 'reduce_sum_m3.stan', line 113, column 4 to column 32)",
  " (in 'reduce_sum_m3.stan', line 114, column 4 to column 12)",
  " (in 'reduce_sum_m3.stan', line 115, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 115, column 4 to column 18)",
  " (in 'reduce_sum_m3.stan', line 116, column 15 to column 16)",
  " (in 'reduce_sum_m3.stan', line 116, column 4 to column 22)",
  " (in 'reduce_sum_m3.stan', line 117, column 11 to column 12)",
  " (in 'reduce_sum_m3.stan', line 117, column 14 to column 15)",
  " (in 'reduce_sum_m3.stan', line 117, column 4 to column 21)",
  " (in 'reduce_sum_m3.stan', line 118, column 10 to column 11)",
  " (in 'reduce_sum_m3.stan', line 118, column 13 to column 14)",
  " (in 'reduce_sum_m3.stan', line 118, column 16 to column 17)",
  " (in 'reduce_sum_m3.stan', line 118, column 4 to column 28)",
  " (in 'reduce_sum_m3.stan', line 120, column 4 to column 36)",
  " (in 'reduce_sum_m3.stan', line 121, column 4 to column 62)",
  " (in 'reduce_sum_m3.stan', line 122, column 4 to column 36)",
  " (in 'reduce_sum_m3.stan', line 123, column 4 to column 36)",
  " (in 'reduce_sum_m3.stan', line 124, column 4 to column 36)",
  " (in 'reduce_sum_m3.stan', line 125, column 4 to column 36)",
  " (in 'reduce_sum_m3.stan', line 126, column 4 to column 36)",
  " (in 'reduce_sum_m3.stan', line 127, column 4 to column 36)",
  " (in 'reduce_sum_m3.stan', line 128, column 4 to column 36)",
  " (in 'reduce_sum_m3.stan', line 129, column 4 to column 38)",
  " (in 'reduce_sum_m3.stan', line 130, column 4 to column 40)",
  " (in 'reduce_sum_m3.stan', line 131, column 4 to column 40)",
  " (in 'reduce_sum_m3.stan', line 132, column 4 to column 39)",
  " (in 'reduce_sum_m3.stan', line 133, column 4 to column 41)",
  " (in 'reduce_sum_m3.stan', line 134, column 4 to column 42)",
  " (in 'reduce_sum_m3.stan', line 135, column 4 to column 42)",
  " (in 'reduce_sum_m3.stan', line 136, column 4 to column 42)",
  " (in 'reduce_sum_m3.stan', line 137, column 4 to column 41)",
  " (in 'reduce_sum_m3.stan', line 138, column 4 to column 41)",
  " (in 'reduce_sum_m3.stan', line 139, column 4 to column 41)",
  " (in 'reduce_sum_m3.stan', line 140, column 4 to column 41)",
  " (in 'reduce_sum_m3.stan', line 141, column 4 to column 41)",
  " (in 'reduce_sum_m3.stan', line 142, column 4 to column 43)",
  " (in 'reduce_sum_m3.stan', line 143, column 4 to column 43)",
  " (in 'reduce_sum_m3.stan', line 144, column 4 to column 43)",
  " (in 'reduce_sum_m3.stan', line 145, column 4 to line 146, column 66)",
  " (in 'reduce_sum_m3.stan', line 148, column 4 to column 15)",
  " (in 'reduce_sum_m3.stan', line 86, column 11 to line 149, column 3)"};
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
f1(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
f1a(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
    pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_col_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
f2(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_row_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
f3(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
f4(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T0__>>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
f5(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
f6(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_row_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
f7(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T0__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
f8(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              std::is_integral<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
double
f9(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
double
f10(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
    pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<
                                                                    stan::value_type_t<T0__>>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
double
f11(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
    pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T0__>>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T0__>>>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
f12(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
    pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, T3__>
g1(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_col_vector<T3__>,
                              stan::is_vt_not_complex<T3__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g2(const T0__& y_slice, const T1__& start, const T2__& end, const T3__&
   a_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_row_vector<T3__>,
                              stan::is_vt_not_complex<T3__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g3(const T0__& y_slice, const T1__& start, const T2__& end, const T3__&
   a_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g4(const T0__& y_slice, const T1__& start, const T2__& end, const T3__&
   a_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g5(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_col_vector<stan::value_type_t<T3__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T3__>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g6(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_row_vector<stan::value_type_t<T3__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T3__>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g7(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T3__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T3__>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g8(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T3__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g9(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T3__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g10(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
    std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::is_row_vector<stan::value_type_t<
                                                    stan::value_type_t<T3__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g11(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
    std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T3__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g12(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
    std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          typename T12__, typename T13__, typename T14__, typename T15__,
          typename T16__, typename T17__, typename T18__, typename T19__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              std::is_integral<T3__>,
                              stan::math::disjunction<stan::is_autodiff<T4__>,
                                                      std::is_floating_point<T4__>>,
                              stan::is_col_vector<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_row_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_eigen_matrix_dynamic<T7__>,
                              stan::is_vt_not_complex<T7__>,
                              stan::is_std_vector<T8__>,
                              std::is_integral<stan::value_type_t<T8__>>,
                              stan::is_std_vector<T9__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T9__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T9__>>>,
                              stan::is_std_vector<T10__>,
                              stan::is_col_vector<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_row_vector<stan::value_type_t<T11__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T11__>>,
                              stan::is_std_vector<T12__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T12__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T12__>>,
                              stan::is_std_vector<T13__>,
                              stan::is_std_vector<stan::value_type_t<T13__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T13__>>>,
                              stan::is_std_vector<T14__>,
                              stan::is_std_vector<stan::value_type_t<T14__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T14__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T14__>>>>,
                              stan::is_std_vector<T15__>,
                              stan::is_std_vector<stan::value_type_t<T15__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T15__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T15__>>>,
                              stan::is_std_vector<T16__>,
                              stan::is_std_vector<stan::value_type_t<T16__>>,
                              stan::is_row_vector<stan::value_type_t<
                                                    stan::value_type_t<T16__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T16__>>>,
                              stan::is_std_vector<T17__>,
                              stan::is_std_vector<stan::value_type_t<T17__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T17__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T17__>>>,
                              stan::is_std_vector<T18__>,
                              stan::is_std_vector<stan::value_type_t<T18__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T18__>>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<
                                                                    stan::value_type_t<T18__>>>>,
                              stan::is_std_vector<T19__>,
                              stan::is_std_vector<stan::value_type_t<T19__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T19__>>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T19__>>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T19__>>>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, T4__, stan::base_type_t<T5__>,
  stan::base_type_t<T6__>, stan::base_type_t<T7__>,
  stan::promote_args_t<stan::base_type_t<T9__>, stan::base_type_t<T10__>,
    stan::base_type_t<T11__>, stan::base_type_t<T12__>,
    stan::base_type_t<T14__>,
    stan::promote_args_t<stan::base_type_t<T15__>, stan::base_type_t<T16__>,
      stan::base_type_t<T17__>, stan::base_type_t<T19__>>>>
s(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
  const T4__& b, const T5__& c_arg__, const T6__& d_arg__, const T7__&
  e_arg__, const T8__& f, const T9__& g, const T10__& h, const T11__& i,
  const T12__& j, const T13__& k, const T14__& l, const T15__& m,
  const T16__& n, const T17__& o, const T18__& p, const T19__& q,
  std::ostream* pstream__);
double r(std::ostream* pstream__);
struct f11_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_std_vector<stan::value_type_t<T0__>>,
                                stan::is_std_vector<stan::value_type_t<
                                                      stan::value_type_t<T0__>>>,
                                std::is_integral<stan::value_type_t<stan::value_type_t<
                                                                    stan::value_type_t<T0__>>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  double
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f11(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct f10_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_std_vector<stan::value_type_t<T0__>>,
                                std::is_integral<stan::value_type_t<stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  double
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f10(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct g8_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_eigen_matrix_dynamic<stan::value_type_t<T3__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T3__>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return g8(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct g7_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_row_vector<stan::value_type_t<T3__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T3__>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return g7(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct g4_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_eigen_matrix_dynamic<T3__>,
                                stan::is_vt_not_complex<T3__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return g4(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct g6_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_col_vector<stan::value_type_t<T3__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T3__>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return g6(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct g11_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_std_vector<stan::value_type_t<T3__>>,
                                stan::is_row_vector<stan::value_type_t<
                                                      stan::value_type_t<T3__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T3__>>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return g11(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct f5_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_std_vector<stan::value_type_t<T0__>>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T0__>>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T0__>>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f5(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct f1_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f1(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct g5_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T3__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T3__>>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return g5(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct g9_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_std_vector<stan::value_type_t<T3__>>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T3__>>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T3__>>>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return g9(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct g1_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::math::disjunction<stan::is_autodiff<T3__>,
                                                        std::is_floating_point<T3__>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, T3__>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return g1(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct f12_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_std_vector<stan::value_type_t<T0__>>,
                                stan::is_std_vector<stan::value_type_t<
                                                      stan::value_type_t<T0__>>>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<
                                                          stan::value_type_t<
                                                            stan::value_type_t<T0__>>>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<
                                                          stan::value_type_t<
                                                            stan::value_type_t<T0__>>>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f12(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct g3_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_row_vector<T3__>,
                                stan::is_vt_not_complex<T3__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return g3(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct f3_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_row_vector<stan::value_type_t<T0__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f3(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct f2_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_col_vector<stan::value_type_t<T0__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f2(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct f6_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_std_vector<stan::value_type_t<T0__>>,
                                stan::is_col_vector<stan::value_type_t<
                                                      stan::value_type_t<T0__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f6(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct g2_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_col_vector<T3__>,
                                stan::is_vt_not_complex<T3__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return g2(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct g10_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_std_vector<stan::value_type_t<T3__>>,
                                stan::is_col_vector<stan::value_type_t<
                                                      stan::value_type_t<T3__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T3__>>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return g10(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct f8_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_std_vector<stan::value_type_t<T0__>>,
                                stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                                stan::value_type_t<T0__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f8(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct g12_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                stan::is_std_vector<T3__>,
                                stan::is_std_vector<stan::value_type_t<T3__>>,
                                stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                                stan::value_type_t<T3__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T3__>>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a) const {
    return g12(y_slice, (start + 1), (end + 1), a, pstream__);
  }
};
struct f9_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                std::is_integral<stan::value_type_t<T0__>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  double
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f9(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct f4_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_eigen_matrix_dynamic<stan::value_type_t<T0__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f4(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct s_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            typename T4__, typename T5__, typename T6__, typename T7__,
            typename T8__, typename T9__, typename T10__, typename T11__,
            typename T12__, typename T13__, typename T14__, typename T15__,
            typename T16__, typename T17__, typename T18__, typename T19__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>,
                                std::is_integral<T3__>,
                                stan::math::disjunction<stan::is_autodiff<T4__>,
                                                        std::is_floating_point<T4__>>,
                                stan::is_col_vector<T5__>,
                                stan::is_vt_not_complex<T5__>,
                                stan::is_row_vector<T6__>,
                                stan::is_vt_not_complex<T6__>,
                                stan::is_eigen_matrix_dynamic<T7__>,
                                stan::is_vt_not_complex<T7__>,
                                stan::is_std_vector<T8__>,
                                std::is_integral<stan::value_type_t<T8__>>,
                                stan::is_std_vector<T9__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T9__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T9__>>>,
                                stan::is_std_vector<T10__>,
                                stan::is_col_vector<stan::value_type_t<T10__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                                stan::is_std_vector<T11__>,
                                stan::is_row_vector<stan::value_type_t<T11__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T11__>>,
                                stan::is_std_vector<T12__>,
                                stan::is_eigen_matrix_dynamic<stan::value_type_t<T12__>>,
                                stan::is_vt_not_complex<stan::value_type_t<T12__>>,
                                stan::is_std_vector<T13__>,
                                stan::is_std_vector<stan::value_type_t<T13__>>,
                                std::is_integral<stan::value_type_t<stan::value_type_t<T13__>>>,
                                stan::is_std_vector<T14__>,
                                stan::is_std_vector<stan::value_type_t<T14__>>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T14__>>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T14__>>>>,
                                stan::is_std_vector<T15__>,
                                stan::is_std_vector<stan::value_type_t<T15__>>,
                                stan::is_col_vector<stan::value_type_t<
                                                      stan::value_type_t<T15__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T15__>>>,
                                stan::is_std_vector<T16__>,
                                stan::is_std_vector<stan::value_type_t<T16__>>,
                                stan::is_row_vector<stan::value_type_t<
                                                      stan::value_type_t<T16__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T16__>>>,
                                stan::is_std_vector<T17__>,
                                stan::is_std_vector<stan::value_type_t<T17__>>,
                                stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                                stan::value_type_t<T17__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T17__>>>,
                                stan::is_std_vector<T18__>,
                                stan::is_std_vector<stan::value_type_t<T18__>>,
                                stan::is_std_vector<stan::value_type_t<
                                                      stan::value_type_t<T18__>>>,
                                std::is_integral<stan::value_type_t<stan::value_type_t<
                                                                    stan::value_type_t<T18__>>>>,
                                stan::is_std_vector<T19__>,
                                stan::is_std_vector<stan::value_type_t<T19__>>,
                                stan::is_std_vector<stan::value_type_t<
                                                      stan::value_type_t<T19__>>>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<
                                                          stan::value_type_t<
                                                            stan::value_type_t<T19__>>>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<
                                                          stan::value_type_t<
                                                            stan::value_type_t<T19__>>>>>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, T4__,
    stan::base_type_t<T5__>, stan::base_type_t<T6__>,
    stan::base_type_t<T7__>,
    stan::promote_args_t<stan::base_type_t<T9__>, stan::base_type_t<T10__>,
      stan::base_type_t<T11__>, stan::base_type_t<T12__>,
      stan::base_type_t<T14__>,
      stan::promote_args_t<stan::base_type_t<T15__>,
        stan::base_type_t<T16__>, stan::base_type_t<T17__>,
        stan::base_type_t<T19__>>>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__, const T3__& a, const T4__& b,
             const T5__& c, const T6__& d, const T7__& e, const T8__& f,
             const T9__& g, const T10__& h, const T11__& i, const T12__& j,
             const T13__& k, const T14__& l, const T15__& m, const T16__& n,
             const T17__& o, const T18__& p, const T19__& q) const {
    return s(y_slice, (start + 1), (end + 1), a, b, c, d, e, f, g, h, i, j,
             k, l, m, n, o, p, q, pstream__);
  }
};
struct f7_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::is_std_vector<stan::value_type_t<T0__>>,
                                stan::is_row_vector<stan::value_type_t<
                                                      stan::value_type_t<T0__>>>,
                                stan::is_vt_not_complex<stan::value_type_t<
                                                          stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f7(y_slice, (start + 1), (end + 1), pstream__);
  }
};
struct f1a_rsfunctor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_std_vector<T0__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T0__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T0__>>>,
                                std::is_integral<T1__>,
                                std::is_integral<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>>
  operator()(const T0__& y_slice, const T1__& start, const T2__& end,
             std::ostream* pstream__) const {
    return f1a(y_slice, (start + 1), (end + 1), pstream__);
  }
};
// real f1(array[] real, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
f1(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 171;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real f1a(array[] real, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
f1a(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
    pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 173;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real f2(array[] vector, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_col_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
f2(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 175;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real f3(array[] row_vector, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_row_vector<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
f3(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 177;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real f4(array[] matrix, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T0__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
f4(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 179;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real f5(array[,] real, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T0__>>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
f5(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 181;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real f6(array[,] vector, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
f6(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 183;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real f7(array[,] row_vector, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_row_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
f7(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 185;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real f8(array[,] matrix, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T0__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
f8(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 187;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real f9(array[] int, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              std::is_integral<stan::value_type_t<T0__>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
double
f9(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
   pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 189;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real f10(array[,] int, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
double
f10(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
    pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 191;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real f11(array[,,] int, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<
                                                                    stan::value_type_t<T0__>>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
double
f11(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
    pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 193;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real f12(array[,,] real, int, int)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T0__>>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T0__>>>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
f12(const T0__& y_slice, const T1__& start, const T2__& end, std::ostream*
    pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 195;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g1(array[] real, int, int, real)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::math::disjunction<stan::is_autodiff<T3__>,
                                                      std::is_floating_point<T3__>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, T3__>
g1(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             T3__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 197;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g2(array[] real, int, int, vector)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_col_vector<T3__>,
                              stan::is_vt_not_complex<T3__>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g2(const T0__& y_slice, const T1__& start, const T2__& end, const T3__&
   a_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a = stan::math::to_ref(a_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 199;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g3(array[] real, int, int, row_vector)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_row_vector<T3__>,
                              stan::is_vt_not_complex<T3__>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g3(const T0__& y_slice, const T1__& start, const T2__& end, const T3__&
   a_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a = stan::math::to_ref(a_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 201;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g4(array[] real, int, int, matrix)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g4(const T0__& y_slice, const T1__& start, const T2__& end, const T3__&
   a_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a = stan::math::to_ref(a_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 203;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g5(array[] real, int, int, array[] real)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g5(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 205;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g6(array[] real, int, int, array[] vector)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_col_vector<stan::value_type_t<T3__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T3__>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g6(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 207;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g7(array[] real, int, int, array[] row_vector)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_row_vector<stan::value_type_t<T3__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T3__>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g7(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 209;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g8(array[] real, int, int, array[] matrix)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T3__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T3__>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g8(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 211;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g9(array[] real, int, int, array[,] real)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T3__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g9(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 213;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g10(array[] real, int, int, array[,] vector)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T3__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g10(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 215;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g11(array[] real, int, int, array[,] row_vector)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::is_row_vector<stan::value_type_t<
                                                    stan::value_type_t<T3__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g11(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 217;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real g12(array[] real, int, int, array[,] matrix)
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              stan::is_std_vector<T3__>,
                              stan::is_std_vector<stan::value_type_t<T3__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T3__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T3__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>>
g12(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 219;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* real
   s(array[] real, int, int, int, real, vector, row_vector, matrix,
     array[] int, array[] real, array[] vector, array[] row_vector,
     array[] matrix, array[,] int, array[,] real, array[,] vector,
     array[,] row_vector, array[,] matrix, array[,,] int, array[,,] real)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          typename T12__, typename T13__, typename T14__, typename T15__,
          typename T16__, typename T17__, typename T18__, typename T19__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>,
                              std::is_integral<T1__>, std::is_integral<T2__>,
                              std::is_integral<T3__>,
                              stan::math::disjunction<stan::is_autodiff<T4__>,
                                                      std::is_floating_point<T4__>>,
                              stan::is_col_vector<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_row_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_eigen_matrix_dynamic<T7__>,
                              stan::is_vt_not_complex<T7__>,
                              stan::is_std_vector<T8__>,
                              std::is_integral<stan::value_type_t<T8__>>,
                              stan::is_std_vector<T9__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T9__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T9__>>>,
                              stan::is_std_vector<T10__>,
                              stan::is_col_vector<stan::value_type_t<T10__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T10__>>,
                              stan::is_std_vector<T11__>,
                              stan::is_row_vector<stan::value_type_t<T11__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T11__>>,
                              stan::is_std_vector<T12__>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<T12__>>,
                              stan::is_vt_not_complex<stan::value_type_t<T12__>>,
                              stan::is_std_vector<T13__>,
                              stan::is_std_vector<stan::value_type_t<T13__>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<T13__>>>,
                              stan::is_std_vector<T14__>,
                              stan::is_std_vector<stan::value_type_t<T14__>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T14__>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<T14__>>>>,
                              stan::is_std_vector<T15__>,
                              stan::is_std_vector<stan::value_type_t<T15__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T15__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T15__>>>,
                              stan::is_std_vector<T16__>,
                              stan::is_std_vector<stan::value_type_t<T16__>>,
                              stan::is_row_vector<stan::value_type_t<
                                                    stan::value_type_t<T16__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T16__>>>,
                              stan::is_std_vector<T17__>,
                              stan::is_std_vector<stan::value_type_t<T17__>>,
                              stan::is_eigen_matrix_dynamic<stan::value_type_t<
                                                              stan::value_type_t<T17__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T17__>>>,
                              stan::is_std_vector<T18__>,
                              stan::is_std_vector<stan::value_type_t<T18__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T18__>>>,
                              std::is_integral<stan::value_type_t<stan::value_type_t<
                                                                    stan::value_type_t<T18__>>>>,
                              stan::is_std_vector<T19__>,
                              stan::is_std_vector<stan::value_type_t<T19__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T19__>>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T19__>>>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T19__>>>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>, T4__, stan::base_type_t<T5__>,
  stan::base_type_t<T6__>, stan::base_type_t<T7__>,
  stan::promote_args_t<stan::base_type_t<T9__>, stan::base_type_t<T10__>,
    stan::base_type_t<T11__>, stan::base_type_t<T12__>,
    stan::base_type_t<T14__>,
    stan::promote_args_t<stan::base_type_t<T15__>, stan::base_type_t<T16__>,
      stan::base_type_t<T17__>, stan::base_type_t<T19__>>>>
s(const T0__& y_slice, const T1__& start, const T2__& end, const T3__& a,
  const T4__& b, const T5__& c_arg__, const T6__& d_arg__, const T7__&
  e_arg__, const T8__& f, const T9__& g, const T10__& h, const T11__& i,
  const T12__& j, const T13__& k, const T14__& l, const T15__& m,
  const T16__& n, const T17__& o, const T18__& p, const T19__& q,
  std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             T4__, stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>,
                               stan::base_type_t<T12__>,
                               stan::base_type_t<T14__>,
                               stan::promote_args_t<stan::base_type_t<T15__>,
                                 stan::base_type_t<T16__>,
                                 stan::base_type_t<T17__>,
                                 stan::base_type_t<T19__>>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& c = stan::math::to_ref(c_arg__);
  const auto& d = stan::math::to_ref(d_arg__);
  const auto& e = stan::math::to_ref(e_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 221;
    return stan::math::reduce_sum<s_rsfunctor__>(y_slice, 1, pstream__, a, b,
             stan::math::eval(c), stan::math::eval(d), stan::math::eval(e),
             f, g, h, i, j, k, l, m, n, o, p, q);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real r()
double r(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int N = std::numeric_limits<int>::min();
    current_statement__ = 224;
    stan::math::validate_non_negative_index("y1d", "N", N);
    std::vector<local_scalar_t__> y1d =
      std::vector<local_scalar_t__>(N, DUMMY_VAR__);
    current_statement__ = 226;
    stan::math::validate_non_negative_index("y2d", "N", N);
    current_statement__ = 227;
    stan::math::validate_non_negative_index("y2d", "N", N);
    std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> y2d =
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
    current_statement__ = 229;
    stan::math::validate_non_negative_index("y3d", "N", N);
    current_statement__ = 230;
    stan::math::validate_non_negative_index("y3d", "N", N);
    std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> y3d =
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
    current_statement__ = 232;
    stan::math::validate_non_negative_index("y4d", "N", N);
    current_statement__ = 233;
    stan::math::validate_non_negative_index("y4d", "N", N);
    current_statement__ = 234;
    stan::math::validate_non_negative_index("y4d", "N", N);
    std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> y4d =
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
    current_statement__ = 236;
    stan::math::validate_non_negative_index("y5d", "N", N);
    current_statement__ = 237;
    stan::math::validate_non_negative_index("y5d", "N", N);
    std::vector<std::vector<local_scalar_t__>> y5d =
      std::vector<std::vector<local_scalar_t__>>(N,
        std::vector<local_scalar_t__>(N, DUMMY_VAR__));
    current_statement__ = 239;
    stan::math::validate_non_negative_index("y6d", "N", N);
    current_statement__ = 240;
    stan::math::validate_non_negative_index("y6d", "N", N);
    current_statement__ = 241;
    stan::math::validate_non_negative_index("y6d", "N", N);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> y6d =
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
    current_statement__ = 243;
    stan::math::validate_non_negative_index("y7d", "N", N);
    current_statement__ = 244;
    stan::math::validate_non_negative_index("y7d", "N", N);
    current_statement__ = 245;
    stan::math::validate_non_negative_index("y7d", "N", N);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> y7d =
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
    current_statement__ = 247;
    stan::math::validate_non_negative_index("y8d", "N", N);
    current_statement__ = 248;
    stan::math::validate_non_negative_index("y8d", "N", N);
    current_statement__ = 249;
    stan::math::validate_non_negative_index("y8d", "N", N);
    current_statement__ = 250;
    stan::math::validate_non_negative_index("y8d", "N", N);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> y8d =
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__)));
    local_scalar_t__ y9d = DUMMY_VAR__;
    current_statement__ = 253;
    stan::math::validate_non_negative_index("y10d", "N", N);
    Eigen::Matrix<local_scalar_t__,-1,1> y10d =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
    current_statement__ = 255;
    stan::math::validate_non_negative_index("y11d", "N", N);
    Eigen::Matrix<local_scalar_t__,1,-1> y11d =
      Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
    current_statement__ = 257;
    stan::math::validate_non_negative_index("y12d", "N", N);
    current_statement__ = 258;
    stan::math::validate_non_negative_index("y12d", "N", N);
    Eigen::Matrix<local_scalar_t__,-1,-1> y12d =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
    int y13d = std::numeric_limits<int>::min();
    current_statement__ = 261;
    stan::math::validate_non_negative_index("y14d", "N", N);
    std::vector<int> y14d =
      std::vector<int>(N, std::numeric_limits<int>::min());
    current_statement__ = 263;
    stan::math::validate_non_negative_index("y15d", "N", N);
    current_statement__ = 264;
    stan::math::validate_non_negative_index("y15d", "N", N);
    std::vector<std::vector<int>> y15d =
      std::vector<std::vector<int>>(N,
        std::vector<int>(N, std::numeric_limits<int>::min()));
    current_statement__ = 266;
    stan::math::validate_non_negative_index("y16d", "N", N);
    current_statement__ = 267;
    stan::math::validate_non_negative_index("y16d", "N", N);
    current_statement__ = 268;
    stan::math::validate_non_negative_index("y16d", "N", N);
    std::vector<std::vector<std::vector<int>>> y16d =
      std::vector<std::vector<std::vector<int>>>(N,
        std::vector<std::vector<int>>(N,
          std::vector<int>(N, std::numeric_limits<int>::min())));
    current_statement__ = 270;
    stan::math::validate_non_negative_index("y17d", "N", N);
    current_statement__ = 271;
    stan::math::validate_non_negative_index("y17d", "N", N);
    current_statement__ = 272;
    stan::math::validate_non_negative_index("y17d", "N", N);
    std::vector<std::vector<std::vector<local_scalar_t__>>> y17d =
      std::vector<std::vector<std::vector<local_scalar_t__>>>(N,
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__)));
    current_statement__ = 274;
    stan::math::validate_non_negative_index("y1", "N", N);
    std::vector<local_scalar_t__> y1 =
      std::vector<local_scalar_t__>(N, DUMMY_VAR__);
    current_statement__ = 276;
    stan::math::validate_non_negative_index("y2", "N", N);
    current_statement__ = 277;
    stan::math::validate_non_negative_index("y2", "N", N);
    std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> y2 =
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
    current_statement__ = 279;
    stan::math::validate_non_negative_index("y3", "N", N);
    current_statement__ = 280;
    stan::math::validate_non_negative_index("y3", "N", N);
    std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> y3 =
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
    current_statement__ = 282;
    stan::math::validate_non_negative_index("y4", "N", N);
    current_statement__ = 283;
    stan::math::validate_non_negative_index("y4", "N", N);
    current_statement__ = 284;
    stan::math::validate_non_negative_index("y4", "N", N);
    std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> y4 =
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
    current_statement__ = 286;
    stan::math::validate_non_negative_index("y5", "N", N);
    current_statement__ = 287;
    stan::math::validate_non_negative_index("y5", "N", N);
    std::vector<std::vector<local_scalar_t__>> y5 =
      std::vector<std::vector<local_scalar_t__>>(N,
        std::vector<local_scalar_t__>(N, DUMMY_VAR__));
    current_statement__ = 289;
    stan::math::validate_non_negative_index("y6", "N", N);
    current_statement__ = 290;
    stan::math::validate_non_negative_index("y6", "N", N);
    current_statement__ = 291;
    stan::math::validate_non_negative_index("y6", "N", N);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> y6 =
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
    current_statement__ = 293;
    stan::math::validate_non_negative_index("y7", "N", N);
    current_statement__ = 294;
    stan::math::validate_non_negative_index("y7", "N", N);
    current_statement__ = 295;
    stan::math::validate_non_negative_index("y7", "N", N);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> y7 =
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
    current_statement__ = 297;
    stan::math::validate_non_negative_index("y8", "N", N);
    current_statement__ = 298;
    stan::math::validate_non_negative_index("y8", "N", N);
    current_statement__ = 299;
    stan::math::validate_non_negative_index("y8", "N", N);
    current_statement__ = 300;
    stan::math::validate_non_negative_index("y8", "N", N);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> y8 =
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__)));
    local_scalar_t__ y9 = DUMMY_VAR__;
    current_statement__ = 303;
    stan::math::validate_non_negative_index("y10", "N", N);
    Eigen::Matrix<local_scalar_t__,-1,1> y10 =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
    current_statement__ = 305;
    stan::math::validate_non_negative_index("y11", "N", N);
    Eigen::Matrix<local_scalar_t__,1,-1> y11 =
      Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
    current_statement__ = 307;
    stan::math::validate_non_negative_index("y12", "N", N);
    current_statement__ = 308;
    stan::math::validate_non_negative_index("y12", "N", N);
    Eigen::Matrix<local_scalar_t__,-1,-1> y12 =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
    current_statement__ = 310;
    stan::math::validate_non_negative_index("y17", "N", N);
    current_statement__ = 311;
    stan::math::validate_non_negative_index("y17", "N", N);
    current_statement__ = 312;
    stan::math::validate_non_negative_index("y17", "N", N);
    std::vector<std::vector<std::vector<local_scalar_t__>>> y17 =
      std::vector<std::vector<std::vector<local_scalar_t__>>>(N,
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__)));
    local_scalar_t__ t1 = DUMMY_VAR__;
    current_statement__ = 314;
    t1 = stan::math::reduce_sum<f1_rsfunctor__>(y1, 1, pstream__);
    local_scalar_t__ t1a = DUMMY_VAR__;
    current_statement__ = 315;
    t1a = (stan::math::reduce_sum<f1_rsfunctor__>(y1, 1, pstream__) +
      stan::math::reduce_sum<f1a_rsfunctor__>(y1, 1, pstream__));
    local_scalar_t__ t2 = DUMMY_VAR__;
    current_statement__ = 316;
    t2 = stan::math::reduce_sum<f2_rsfunctor__>(y2, 1, pstream__);
    local_scalar_t__ t3 = DUMMY_VAR__;
    current_statement__ = 317;
    t3 = stan::math::reduce_sum<f3_rsfunctor__>(y3, 1, pstream__);
    local_scalar_t__ t4 = DUMMY_VAR__;
    current_statement__ = 318;
    t4 = stan::math::reduce_sum<f4_rsfunctor__>(y4, 1, pstream__);
    local_scalar_t__ t5 = DUMMY_VAR__;
    current_statement__ = 319;
    t5 = stan::math::reduce_sum<f5_rsfunctor__>(y5, 1, pstream__);
    local_scalar_t__ t6 = DUMMY_VAR__;
    current_statement__ = 320;
    t6 = stan::math::reduce_sum<f6_rsfunctor__>(y6, 1, pstream__);
    local_scalar_t__ t7 = DUMMY_VAR__;
    current_statement__ = 321;
    t7 = stan::math::reduce_sum<f7_rsfunctor__>(y7, 1, pstream__);
    local_scalar_t__ t8 = DUMMY_VAR__;
    current_statement__ = 322;
    t8 = stan::math::reduce_sum<f8_rsfunctor__>(y8, 1, pstream__);
    local_scalar_t__ t9 = DUMMY_VAR__;
    current_statement__ = 323;
    t9 = stan::math::reduce_sum<f9_rsfunctor__>(y14d, 1, pstream__);
    local_scalar_t__ t10 = DUMMY_VAR__;
    current_statement__ = 324;
    t10 = stan::math::reduce_sum<f10_rsfunctor__>(y15d, 1, pstream__);
    local_scalar_t__ t11 = DUMMY_VAR__;
    current_statement__ = 325;
    t11 = stan::math::reduce_sum<f11_rsfunctor__>(y16d, 1, pstream__);
    local_scalar_t__ t12 = DUMMY_VAR__;
    current_statement__ = 326;
    t12 = stan::math::reduce_sum<f12_rsfunctor__>(y17, 1, pstream__);
    local_scalar_t__ tg1 = DUMMY_VAR__;
    current_statement__ = 327;
    tg1 = stan::math::reduce_sum<g1_rsfunctor__>(y1, 1, pstream__, y9);
    local_scalar_t__ tg2 = DUMMY_VAR__;
    current_statement__ = 328;
    tg2 = stan::math::reduce_sum<g2_rsfunctor__>(y1, 1, pstream__, y10);
    local_scalar_t__ tg3 = DUMMY_VAR__;
    current_statement__ = 329;
    tg3 = stan::math::reduce_sum<g3_rsfunctor__>(y1, 1, pstream__, y11);
    local_scalar_t__ tg4 = DUMMY_VAR__;
    current_statement__ = 330;
    tg4 = stan::math::reduce_sum<g4_rsfunctor__>(y1, 1, pstream__, y12);
    local_scalar_t__ tg5 = DUMMY_VAR__;
    current_statement__ = 331;
    tg5 = stan::math::reduce_sum<g5_rsfunctor__>(y1, 1, pstream__, y1);
    local_scalar_t__ tg6 = DUMMY_VAR__;
    current_statement__ = 332;
    tg6 = stan::math::reduce_sum<g6_rsfunctor__>(y1, 1, pstream__, y2);
    local_scalar_t__ tg7 = DUMMY_VAR__;
    current_statement__ = 333;
    tg7 = stan::math::reduce_sum<g7_rsfunctor__>(y1, 1, pstream__, y3);
    local_scalar_t__ tg8 = DUMMY_VAR__;
    current_statement__ = 334;
    tg8 = stan::math::reduce_sum<g8_rsfunctor__>(y1, 1, pstream__, y4);
    local_scalar_t__ tg9 = DUMMY_VAR__;
    current_statement__ = 335;
    tg9 = stan::math::reduce_sum<g9_rsfunctor__>(y1, 1, pstream__, y5);
    local_scalar_t__ tg10 = DUMMY_VAR__;
    current_statement__ = 336;
    tg10 = stan::math::reduce_sum<g10_rsfunctor__>(y1, 1, pstream__, y6);
    local_scalar_t__ tg11 = DUMMY_VAR__;
    current_statement__ = 337;
    tg11 = stan::math::reduce_sum<g11_rsfunctor__>(y1, 1, pstream__, y7);
    local_scalar_t__ tg12 = DUMMY_VAR__;
    current_statement__ = 338;
    tg12 = stan::math::reduce_sum<g12_rsfunctor__>(y1, 1, pstream__, y8);
    local_scalar_t__ ts = DUMMY_VAR__;
    current_statement__ = 339;
    ts = stan::math::reduce_sum<s_rsfunctor__>(y1d, 1, pstream__, y13d, y9,
           y10, y11, y12, y14d, y1, y2, y3, y4, y15d, y5, y6, y7, y8, y16d,
           y17);
    current_statement__ = 340;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class reduce_sum_m3_model final : public model_base_crtp<reduce_sum_m3_model> {
 private:
  int N;
  std::vector<double> y1d;
  std::vector<Eigen::Matrix<double,-1,1>> y2d;
  std::vector<Eigen::Matrix<double,1,-1>> y3d;
  std::vector<Eigen::Matrix<double,-1,-1>> y4d;
  std::vector<std::vector<double>> y5d;
  std::vector<std::vector<Eigen::Matrix<double,-1,1>>> y6d;
  std::vector<std::vector<Eigen::Matrix<double,1,-1>>> y7d;
  std::vector<std::vector<Eigen::Matrix<double,-1,-1>>> y8d;
  double y9d;
  Eigen::Matrix<double,-1,1> y10d_data__;
  Eigen::Matrix<double,1,-1> y11d_data__;
  Eigen::Matrix<double,-1,-1> y12d_data__;
  int y13d;
  std::vector<int> y14d;
  std::vector<std::vector<int>> y15d;
  std::vector<std::vector<std::vector<int>>> y16d;
  std::vector<std::vector<std::vector<double>>> y17d;
  double td1;
  double td1a;
  double td2;
  double td3;
  double td4;
  double td5;
  double td6;
  double td7;
  double td8;
  double td9;
  double td10;
  double td11;
  double td12;
  double tgd1;
  double tgd2;
  double tgd3;
  double tgd4;
  double tgd5;
  double tgd6;
  double tgd7;
  double tgd8;
  double tgd9;
  double tgd10;
  double tgd11;
  double tgd12;
  double tsd;
  Eigen::Map<Eigen::Matrix<double,-1,1>> y10d{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,1,-1>> y11d{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> y12d{nullptr, 0, 0};
 public:
  ~reduce_sum_m3_model() {}
  reduce_sum_m3_model(stan::io::var_context& context__, unsigned int
                      random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "reduce_sum_m3_model_namespace::reduce_sum_m3_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 67;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 67;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 68;
      stan::math::validate_non_negative_index("y1d", "N", N);
      current_statement__ = 69;
      context__.validate_dims("data initialization", "y1d", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      y1d = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 69;
      y1d = context__.vals_r("y1d");
      current_statement__ = 70;
      stan::math::validate_non_negative_index("y2d", "N", N);
      current_statement__ = 71;
      stan::math::validate_non_negative_index("y2d", "N", N);
      current_statement__ = 72;
      context__.validate_dims("data initialization", "y2d", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      y2d = std::vector<Eigen::Matrix<double,-1,1>>(N,
              Eigen::Matrix<double,-1,1>::Constant(N,
                std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> y2d_flat__;
        current_statement__ = 72;
        y2d_flat__ = context__.vals_r("y2d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y2d, y2d_flat__[(pos__ - 1)],
              "assigning variable y2d", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 73;
      stan::math::validate_non_negative_index("y3d", "N", N);
      current_statement__ = 74;
      stan::math::validate_non_negative_index("y3d", "N", N);
      current_statement__ = 75;
      context__.validate_dims("data initialization", "y3d", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      y3d = std::vector<Eigen::Matrix<double,1,-1>>(N,
              Eigen::Matrix<double,1,-1>::Constant(N,
                std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> y3d_flat__;
        current_statement__ = 75;
        y3d_flat__ = context__.vals_r("y3d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y3d, y3d_flat__[(pos__ - 1)],
              "assigning variable y3d", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 76;
      stan::math::validate_non_negative_index("y4d", "N", N);
      current_statement__ = 77;
      stan::math::validate_non_negative_index("y4d", "N", N);
      current_statement__ = 78;
      stan::math::validate_non_negative_index("y4d", "N", N);
      current_statement__ = 79;
      context__.validate_dims("data initialization", "y4d", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      y4d = std::vector<Eigen::Matrix<double,-1,-1>>(N,
              Eigen::Matrix<double,-1,-1>::Constant(N, N,
                std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> y4d_flat__;
        current_statement__ = 79;
        y4d_flat__ = context__.vals_r("y4d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(y4d, y4d_flat__[(pos__ - 1)],
                "assigning variable y4d", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 80;
      stan::math::validate_non_negative_index("y5d", "N", N);
      current_statement__ = 81;
      stan::math::validate_non_negative_index("y5d", "N", N);
      current_statement__ = 82;
      context__.validate_dims("data initialization", "y5d", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      y5d = std::vector<std::vector<double>>(N,
              std::vector<double>(N,
                std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> y5d_flat__;
        current_statement__ = 82;
        y5d_flat__ = context__.vals_r("y5d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y5d, y5d_flat__[(pos__ - 1)],
              "assigning variable y5d", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 83;
      stan::math::validate_non_negative_index("y6d", "N", N);
      current_statement__ = 84;
      stan::math::validate_non_negative_index("y6d", "N", N);
      current_statement__ = 85;
      stan::math::validate_non_negative_index("y6d", "N", N);
      current_statement__ = 86;
      context__.validate_dims("data initialization", "y6d", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      y6d = std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(N,
              std::vector<Eigen::Matrix<double,-1,1>>(N,
                Eigen::Matrix<double,-1,1>::Constant(N,
                  std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> y6d_flat__;
        current_statement__ = 86;
        y6d_flat__ = context__.vals_r("y6d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(y6d, y6d_flat__[(pos__ - 1)],
                "assigning variable y6d", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 87;
      stan::math::validate_non_negative_index("y7d", "N", N);
      current_statement__ = 88;
      stan::math::validate_non_negative_index("y7d", "N", N);
      current_statement__ = 89;
      stan::math::validate_non_negative_index("y7d", "N", N);
      current_statement__ = 90;
      context__.validate_dims("data initialization", "y7d", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      y7d = std::vector<std::vector<Eigen::Matrix<double,1,-1>>>(N,
              std::vector<Eigen::Matrix<double,1,-1>>(N,
                Eigen::Matrix<double,1,-1>::Constant(N,
                  std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> y7d_flat__;
        current_statement__ = 90;
        y7d_flat__ = context__.vals_r("y7d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(y7d, y7d_flat__[(pos__ - 1)],
                "assigning variable y7d", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 91;
      stan::math::validate_non_negative_index("y8d", "N", N);
      current_statement__ = 92;
      stan::math::validate_non_negative_index("y8d", "N", N);
      current_statement__ = 93;
      stan::math::validate_non_negative_index("y8d", "N", N);
      current_statement__ = 94;
      stan::math::validate_non_negative_index("y8d", "N", N);
      current_statement__ = 95;
      context__.validate_dims("data initialization", "y8d", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N), static_cast<size_t>(N)});
      y8d = std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>(N,
              std::vector<Eigen::Matrix<double,-1,-1>>(N,
                Eigen::Matrix<double,-1,-1>::Constant(N, N,
                  std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> y8d_flat__;
        current_statement__ = 95;
        y8d_flat__ = context__.vals_r("y8d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                stan::model::assign(y8d, y8d_flat__[(pos__ - 1)],
                  "assigning variable y8d", stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 96;
      context__.validate_dims("data initialization", "y9d", "double",
        std::vector<size_t>{});
      y9d = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 96;
      y9d = context__.vals_r("y9d")[(1 - 1)];
      current_statement__ = 97;
      stan::math::validate_non_negative_index("y10d", "N", N);
      current_statement__ = 98;
      context__.validate_dims("data initialization", "y10d", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      y10d_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                      std::numeric_limits<double>::quiet_NaN());
      new (&y10d) Eigen::Map<Eigen::Matrix<double,-1,1>>(y10d_data__.data(),
        N);
      {
        std::vector<local_scalar_t__> y10d_flat__;
        current_statement__ = 98;
        y10d_flat__ = context__.vals_r("y10d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(y10d, y10d_flat__[(pos__ - 1)],
            "assigning variable y10d", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 99;
      stan::math::validate_non_negative_index("y11d", "N", N);
      current_statement__ = 100;
      context__.validate_dims("data initialization", "y11d", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      y11d_data__ = Eigen::Matrix<double,1,-1>::Constant(N,
                      std::numeric_limits<double>::quiet_NaN());
      new (&y11d) Eigen::Map<Eigen::Matrix<double,1,-1>>(y11d_data__.data(),
        N);
      {
        std::vector<local_scalar_t__> y11d_flat__;
        current_statement__ = 100;
        y11d_flat__ = context__.vals_r("y11d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(y11d, y11d_flat__[(pos__ - 1)],
            "assigning variable y11d", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 101;
      stan::math::validate_non_negative_index("y12d", "N", N);
      current_statement__ = 102;
      stan::math::validate_non_negative_index("y12d", "N", N);
      current_statement__ = 103;
      context__.validate_dims("data initialization", "y12d", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      y12d_data__ = Eigen::Matrix<double,-1,-1>::Constant(N, N,
                      std::numeric_limits<double>::quiet_NaN());
      new (&y12d) Eigen::Map<Eigen::Matrix<double,-1,-1>>(y12d_data__.data(),
        N, N);
      {
        std::vector<local_scalar_t__> y12d_flat__;
        current_statement__ = 103;
        y12d_flat__ = context__.vals_r("y12d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y12d, y12d_flat__[(pos__ - 1)],
              "assigning variable y12d", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 104;
      context__.validate_dims("data initialization", "y13d", "int",
        std::vector<size_t>{});
      y13d = std::numeric_limits<int>::min();
      current_statement__ = 104;
      y13d = context__.vals_i("y13d")[(1 - 1)];
      current_statement__ = 105;
      stan::math::validate_non_negative_index("y14d", "N", N);
      current_statement__ = 106;
      context__.validate_dims("data initialization", "y14d", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      y14d = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 106;
      y14d = context__.vals_i("y14d");
      current_statement__ = 107;
      stan::math::validate_non_negative_index("y15d", "N", N);
      current_statement__ = 108;
      stan::math::validate_non_negative_index("y15d", "N", N);
      current_statement__ = 109;
      context__.validate_dims("data initialization", "y15d", "int",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      y15d = std::vector<std::vector<int>>(N,
               std::vector<int>(N, std::numeric_limits<int>::min()));
      {
        std::vector<int> y15d_flat__;
        current_statement__ = 109;
        y15d_flat__ = context__.vals_i("y15d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y15d, y15d_flat__[(pos__ - 1)],
              "assigning variable y15d", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 110;
      stan::math::validate_non_negative_index("y16d", "N", N);
      current_statement__ = 111;
      stan::math::validate_non_negative_index("y16d", "N", N);
      current_statement__ = 112;
      stan::math::validate_non_negative_index("y16d", "N", N);
      current_statement__ = 113;
      context__.validate_dims("data initialization", "y16d", "int",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      y16d = std::vector<std::vector<std::vector<int>>>(N,
               std::vector<std::vector<int>>(N,
                 std::vector<int>(N, std::numeric_limits<int>::min())));
      {
        std::vector<int> y16d_flat__;
        current_statement__ = 113;
        y16d_flat__ = context__.vals_i("y16d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(y16d, y16d_flat__[(pos__ - 1)],
                "assigning variable y16d", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 114;
      stan::math::validate_non_negative_index("y17d", "N", N);
      current_statement__ = 115;
      stan::math::validate_non_negative_index("y17d", "N", N);
      current_statement__ = 116;
      stan::math::validate_non_negative_index("y17d", "N", N);
      current_statement__ = 117;
      context__.validate_dims("data initialization", "y17d", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      y17d = std::vector<std::vector<std::vector<double>>>(N,
               std::vector<std::vector<double>>(N,
                 std::vector<double>(N,
                   std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> y17d_flat__;
        current_statement__ = 117;
        y17d_flat__ = context__.vals_r("y17d");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(y17d, y17d_flat__[(pos__ - 1)],
                "assigning variable y17d", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 118;
      td1 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 118;
      td1 = stan::math::reduce_sum<f1_rsfunctor__>(y1d, 1, pstream__);
      current_statement__ = 119;
      td1a = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 119;
      td1a = (stan::math::reduce_sum<f1_rsfunctor__>(y1d, 1, pstream__) +
        stan::math::reduce_sum<f1a_rsfunctor__>(y1d, 1, pstream__));
      current_statement__ = 120;
      td2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 120;
      td2 = stan::math::reduce_sum<f2_rsfunctor__>(y2d, 1, pstream__);
      current_statement__ = 121;
      td3 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 121;
      td3 = stan::math::reduce_sum<f3_rsfunctor__>(y3d, 1, pstream__);
      current_statement__ = 122;
      td4 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 122;
      td4 = stan::math::reduce_sum<f4_rsfunctor__>(y4d, 1, pstream__);
      current_statement__ = 123;
      td5 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 123;
      td5 = stan::math::reduce_sum<f5_rsfunctor__>(y5d, 1, pstream__);
      current_statement__ = 124;
      td6 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 124;
      td6 = stan::math::reduce_sum<f6_rsfunctor__>(y6d, 1, pstream__);
      current_statement__ = 125;
      td7 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 125;
      td7 = stan::math::reduce_sum<f7_rsfunctor__>(y7d, 1, pstream__);
      current_statement__ = 126;
      td8 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 126;
      td8 = stan::math::reduce_sum<f8_rsfunctor__>(y8d, 1, pstream__);
      current_statement__ = 127;
      td9 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 127;
      td9 = stan::math::reduce_sum<f9_rsfunctor__>(y14d, 1, pstream__);
      current_statement__ = 128;
      td10 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 128;
      td10 = stan::math::reduce_sum<f10_rsfunctor__>(y15d, 1, pstream__);
      current_statement__ = 129;
      td11 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 129;
      td11 = stan::math::reduce_sum<f11_rsfunctor__>(y16d, 1, pstream__);
      current_statement__ = 130;
      td12 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 130;
      td12 = stan::math::reduce_sum<f12_rsfunctor__>(y17d, 1, pstream__);
      current_statement__ = 131;
      tgd1 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 131;
      tgd1 = stan::math::reduce_sum<g1_rsfunctor__>(y1d, 1, pstream__, y9d);
      current_statement__ = 132;
      tgd2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 132;
      tgd2 = stan::math::reduce_sum<g2_rsfunctor__>(y1d, 1, pstream__, y10d);
      current_statement__ = 133;
      tgd3 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 133;
      tgd3 = stan::math::reduce_sum<g3_rsfunctor__>(y1d, 1, pstream__, y11d);
      current_statement__ = 134;
      tgd4 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 134;
      tgd4 = stan::math::reduce_sum<g4_rsfunctor__>(y1d, 1, pstream__, y12d);
      current_statement__ = 135;
      tgd5 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 135;
      tgd5 = stan::math::reduce_sum<g5_rsfunctor__>(y1d, 1, pstream__, y1d);
      current_statement__ = 136;
      tgd6 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 136;
      tgd6 = stan::math::reduce_sum<g6_rsfunctor__>(y1d, 1, pstream__, y2d);
      current_statement__ = 137;
      tgd7 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 137;
      tgd7 = stan::math::reduce_sum<g7_rsfunctor__>(y1d, 1, pstream__, y3d);
      current_statement__ = 138;
      tgd8 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 138;
      tgd8 = stan::math::reduce_sum<g8_rsfunctor__>(y1d, 1, pstream__, y4d);
      current_statement__ = 139;
      tgd9 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 139;
      tgd9 = stan::math::reduce_sum<g9_rsfunctor__>(y1d, 1, pstream__, y5d);
      current_statement__ = 140;
      tgd10 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 140;
      tgd10 = stan::math::reduce_sum<g10_rsfunctor__>(y1d, 1, pstream__, y6d);
      current_statement__ = 141;
      tgd11 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 141;
      tgd11 = stan::math::reduce_sum<g11_rsfunctor__>(y1d, 1, pstream__, y7d);
      current_statement__ = 142;
      tgd12 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 142;
      tgd12 = stan::math::reduce_sum<g12_rsfunctor__>(y1d, 1, pstream__, y8d);
      current_statement__ = 143;
      tsd = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 143;
      tsd = stan::math::reduce_sum<s_rsfunctor__>(y1d, 1, pstream__, y13d,
              y9d, y10d, y11d, y12d, y14d, y1d, y2d, y3d, y4d, y15d, y5d,
              y6d, y7d, y8d, y16d, y17d);
      current_statement__ = 144;
      stan::math::validate_non_negative_index("y1", "N", N);
      current_statement__ = 145;
      stan::math::validate_non_negative_index("y2", "N", N);
      current_statement__ = 146;
      stan::math::validate_non_negative_index("y2", "N", N);
      current_statement__ = 147;
      stan::math::validate_non_negative_index("y3", "N", N);
      current_statement__ = 148;
      stan::math::validate_non_negative_index("y3", "N", N);
      current_statement__ = 149;
      stan::math::validate_non_negative_index("y4", "N", N);
      current_statement__ = 150;
      stan::math::validate_non_negative_index("y4", "N", N);
      current_statement__ = 151;
      stan::math::validate_non_negative_index("y4", "N", N);
      current_statement__ = 152;
      stan::math::validate_non_negative_index("y5", "N", N);
      current_statement__ = 153;
      stan::math::validate_non_negative_index("y5", "N", N);
      current_statement__ = 154;
      stan::math::validate_non_negative_index("y6", "N", N);
      current_statement__ = 155;
      stan::math::validate_non_negative_index("y6", "N", N);
      current_statement__ = 156;
      stan::math::validate_non_negative_index("y6", "N", N);
      current_statement__ = 157;
      stan::math::validate_non_negative_index("y7", "N", N);
      current_statement__ = 158;
      stan::math::validate_non_negative_index("y7", "N", N);
      current_statement__ = 159;
      stan::math::validate_non_negative_index("y7", "N", N);
      current_statement__ = 160;
      stan::math::validate_non_negative_index("y8", "N", N);
      current_statement__ = 161;
      stan::math::validate_non_negative_index("y8", "N", N);
      current_statement__ = 162;
      stan::math::validate_non_negative_index("y8", "N", N);
      current_statement__ = 163;
      stan::math::validate_non_negative_index("y8", "N", N);
      current_statement__ = 164;
      stan::math::validate_non_negative_index("y10", "N", N);
      current_statement__ = 165;
      stan::math::validate_non_negative_index("y11", "N", N);
      current_statement__ = 166;
      stan::math::validate_non_negative_index("y12", "N", N);
      current_statement__ = 167;
      stan::math::validate_non_negative_index("y12", "N", N);
      current_statement__ = 168;
      stan::math::validate_non_negative_index("y17", "N", N);
      current_statement__ = 169;
      stan::math::validate_non_negative_index("y17", "N", N);
      current_statement__ = 170;
      stan::math::validate_non_negative_index("y17", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = N + (N * N) + (N * N) + (N * (N * N)) + (N * N) + (N *
      (N * N)) + (N * (N * N)) + (N * (N * (N * N))) + 1 + N + N + (N * N) +
      (N * (N * N));
  }
  inline std::string model_name() const final {
    return "reduce_sum_m3_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "reduce_sum_m3_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<local_scalar_t__> y1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 1;
      y1 = in__.template read<std::vector<local_scalar_t__>>(N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> y2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 2;
      y2 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N, N);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> y3 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 3;
      y3 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N, N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> y4 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
      current_statement__ = 4;
      y4 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N, N, N);
      std::vector<std::vector<local_scalar_t__>> y5 =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      current_statement__ = 5;
      y5 = in__.template read<std::vector<std::vector<local_scalar_t__>>>(N,
             N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> y6 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 6;
      y6 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
             N, N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> y7 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 7;
      y7 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
             N, N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> y8 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N,
              DUMMY_VAR__)));
      current_statement__ = 8;
      y8 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>>(N,
             N, N, N);
      local_scalar_t__ y9 = DUMMY_VAR__;
      current_statement__ = 9;
      y9 = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> y10 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 10;
      y10 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<local_scalar_t__,1,-1> y11 =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 11;
      y11 = in__.template read<Eigen::Matrix<local_scalar_t__,1,-1>>(N);
      Eigen::Matrix<local_scalar_t__,-1,-1> y12 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      current_statement__ = 12;
      y12 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N);
      std::vector<std::vector<std::vector<local_scalar_t__>>> y17 =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(N,
          std::vector<std::vector<local_scalar_t__>>(N,
            std::vector<local_scalar_t__>(N, DUMMY_VAR__)));
      current_statement__ = 13;
      y17 = in__.template read<
              std::vector<std::vector<std::vector<local_scalar_t__>>>>(N, N,
              N);
      {
        local_scalar_t__ t1 = DUMMY_VAR__;
        current_statement__ = 40;
        t1 = stan::math::reduce_sum<f1_rsfunctor__>(y1, 1, pstream__);
        local_scalar_t__ t1a = DUMMY_VAR__;
        current_statement__ = 41;
        t1a = (stan::math::reduce_sum<f1_rsfunctor__>(y1, 1, pstream__) +
          stan::math::reduce_sum<f1a_rsfunctor__>(y1, 1, pstream__));
        local_scalar_t__ t2 = DUMMY_VAR__;
        current_statement__ = 42;
        t2 = stan::math::reduce_sum<f2_rsfunctor__>(y2, 1, pstream__);
        local_scalar_t__ t3 = DUMMY_VAR__;
        current_statement__ = 43;
        t3 = stan::math::reduce_sum<f3_rsfunctor__>(y3, 1, pstream__);
        local_scalar_t__ t4 = DUMMY_VAR__;
        current_statement__ = 44;
        t4 = stan::math::reduce_sum<f4_rsfunctor__>(y4, 1, pstream__);
        local_scalar_t__ t5 = DUMMY_VAR__;
        current_statement__ = 45;
        t5 = stan::math::reduce_sum<f5_rsfunctor__>(y5, 1, pstream__);
        local_scalar_t__ t6 = DUMMY_VAR__;
        current_statement__ = 46;
        t6 = stan::math::reduce_sum<f6_rsfunctor__>(y6, 1, pstream__);
        local_scalar_t__ t7 = DUMMY_VAR__;
        current_statement__ = 47;
        t7 = stan::math::reduce_sum<f7_rsfunctor__>(y7, 1, pstream__);
        local_scalar_t__ t8 = DUMMY_VAR__;
        current_statement__ = 48;
        t8 = stan::math::reduce_sum<f8_rsfunctor__>(y8, 1, pstream__);
        local_scalar_t__ t9 = DUMMY_VAR__;
        current_statement__ = 49;
        t9 = stan::math::reduce_sum<f9_rsfunctor__>(y14d, 1, pstream__);
        local_scalar_t__ t10 = DUMMY_VAR__;
        current_statement__ = 50;
        t10 = stan::math::reduce_sum<f10_rsfunctor__>(y15d, 1, pstream__);
        local_scalar_t__ t11 = DUMMY_VAR__;
        current_statement__ = 51;
        t11 = stan::math::reduce_sum<f11_rsfunctor__>(y16d, 1, pstream__);
        local_scalar_t__ t12 = DUMMY_VAR__;
        current_statement__ = 52;
        t12 = stan::math::reduce_sum<f12_rsfunctor__>(y17, 1, pstream__);
        local_scalar_t__ tg1 = DUMMY_VAR__;
        current_statement__ = 53;
        tg1 = stan::math::reduce_sum<g1_rsfunctor__>(y1, 1, pstream__, y9);
        local_scalar_t__ tg2 = DUMMY_VAR__;
        current_statement__ = 54;
        tg2 = stan::math::reduce_sum<g2_rsfunctor__>(y1, 1, pstream__, y10);
        local_scalar_t__ tg3 = DUMMY_VAR__;
        current_statement__ = 55;
        tg3 = stan::math::reduce_sum<g3_rsfunctor__>(y1, 1, pstream__, y11);
        local_scalar_t__ tg4 = DUMMY_VAR__;
        current_statement__ = 56;
        tg4 = stan::math::reduce_sum<g4_rsfunctor__>(y1, 1, pstream__, y12);
        local_scalar_t__ tg5 = DUMMY_VAR__;
        current_statement__ = 57;
        tg5 = stan::math::reduce_sum<g5_rsfunctor__>(y1, 1, pstream__, y1);
        local_scalar_t__ tg6 = DUMMY_VAR__;
        current_statement__ = 58;
        tg6 = stan::math::reduce_sum<g6_rsfunctor__>(y1, 1, pstream__, y2);
        local_scalar_t__ tg7 = DUMMY_VAR__;
        current_statement__ = 59;
        tg7 = stan::math::reduce_sum<g7_rsfunctor__>(y1, 1, pstream__, y3);
        local_scalar_t__ tg8 = DUMMY_VAR__;
        current_statement__ = 60;
        tg8 = stan::math::reduce_sum<g8_rsfunctor__>(y1, 1, pstream__, y4);
        local_scalar_t__ tg9 = DUMMY_VAR__;
        current_statement__ = 61;
        tg9 = stan::math::reduce_sum<g9_rsfunctor__>(y1, 1, pstream__, y5);
        local_scalar_t__ tg10 = DUMMY_VAR__;
        current_statement__ = 62;
        tg10 = stan::math::reduce_sum<g10_rsfunctor__>(y1, 1, pstream__, y6);
        local_scalar_t__ tg11 = DUMMY_VAR__;
        current_statement__ = 63;
        tg11 = stan::math::reduce_sum<g11_rsfunctor__>(y1, 1, pstream__, y7);
        local_scalar_t__ tg12 = DUMMY_VAR__;
        current_statement__ = 64;
        tg12 = stan::math::reduce_sum<g12_rsfunctor__>(y1, 1, pstream__, y8);
        local_scalar_t__ ts = DUMMY_VAR__;
        current_statement__ = 65;
        ts = stan::math::reduce_sum<s_rsfunctor__>(y1d, 1, pstream__, y13d,
               y9, y10, y11, y12, y14d, y1, y2, y3, y4, y15d, y5, y6, y7, y8,
               y16d, y17);
        local_scalar_t__ tt = DUMMY_VAR__;
        current_statement__ = 66;
        tt = r(pstream__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "reduce_sum_m3_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<local_scalar_t__> y1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 1;
      y1 = in__.template read<std::vector<local_scalar_t__>>(N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> y2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 2;
      y2 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N, N);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> y3 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 3;
      y3 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N, N);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> y4 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
      current_statement__ = 4;
      y4 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N, N, N);
      std::vector<std::vector<local_scalar_t__>> y5 =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      current_statement__ = 5;
      y5 = in__.template read<std::vector<std::vector<local_scalar_t__>>>(N,
             N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> y6 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 6;
      y6 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
             N, N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> y7 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 7;
      y7 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
             N, N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> y8 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N,
              DUMMY_VAR__)));
      current_statement__ = 8;
      y8 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>>(N,
             N, N, N);
      local_scalar_t__ y9 = DUMMY_VAR__;
      current_statement__ = 9;
      y9 = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> y10 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 10;
      y10 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<local_scalar_t__,1,-1> y11 =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 11;
      y11 = in__.template read<Eigen::Matrix<local_scalar_t__,1,-1>>(N);
      Eigen::Matrix<local_scalar_t__,-1,-1> y12 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      current_statement__ = 12;
      y12 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N);
      std::vector<std::vector<std::vector<local_scalar_t__>>> y17 =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(N,
          std::vector<std::vector<local_scalar_t__>>(N,
            std::vector<local_scalar_t__>(N, DUMMY_VAR__)));
      current_statement__ = 13;
      y17 = in__.template read<
              std::vector<std::vector<std::vector<local_scalar_t__>>>>(N, N,
              N);
      {
        local_scalar_t__ t1 = DUMMY_VAR__;
        current_statement__ = 40;
        t1 = stan::math::reduce_sum<f1_rsfunctor__>(y1, 1, pstream__);
        local_scalar_t__ t1a = DUMMY_VAR__;
        current_statement__ = 41;
        t1a = (stan::math::reduce_sum<f1_rsfunctor__>(y1, 1, pstream__) +
          stan::math::reduce_sum<f1a_rsfunctor__>(y1, 1, pstream__));
        local_scalar_t__ t2 = DUMMY_VAR__;
        current_statement__ = 42;
        t2 = stan::math::reduce_sum<f2_rsfunctor__>(y2, 1, pstream__);
        local_scalar_t__ t3 = DUMMY_VAR__;
        current_statement__ = 43;
        t3 = stan::math::reduce_sum<f3_rsfunctor__>(y3, 1, pstream__);
        local_scalar_t__ t4 = DUMMY_VAR__;
        current_statement__ = 44;
        t4 = stan::math::reduce_sum<f4_rsfunctor__>(y4, 1, pstream__);
        local_scalar_t__ t5 = DUMMY_VAR__;
        current_statement__ = 45;
        t5 = stan::math::reduce_sum<f5_rsfunctor__>(y5, 1, pstream__);
        local_scalar_t__ t6 = DUMMY_VAR__;
        current_statement__ = 46;
        t6 = stan::math::reduce_sum<f6_rsfunctor__>(y6, 1, pstream__);
        local_scalar_t__ t7 = DUMMY_VAR__;
        current_statement__ = 47;
        t7 = stan::math::reduce_sum<f7_rsfunctor__>(y7, 1, pstream__);
        local_scalar_t__ t8 = DUMMY_VAR__;
        current_statement__ = 48;
        t8 = stan::math::reduce_sum<f8_rsfunctor__>(y8, 1, pstream__);
        local_scalar_t__ t9 = DUMMY_VAR__;
        current_statement__ = 49;
        t9 = stan::math::reduce_sum<f9_rsfunctor__>(y14d, 1, pstream__);
        local_scalar_t__ t10 = DUMMY_VAR__;
        current_statement__ = 50;
        t10 = stan::math::reduce_sum<f10_rsfunctor__>(y15d, 1, pstream__);
        local_scalar_t__ t11 = DUMMY_VAR__;
        current_statement__ = 51;
        t11 = stan::math::reduce_sum<f11_rsfunctor__>(y16d, 1, pstream__);
        local_scalar_t__ t12 = DUMMY_VAR__;
        current_statement__ = 52;
        t12 = stan::math::reduce_sum<f12_rsfunctor__>(y17, 1, pstream__);
        local_scalar_t__ tg1 = DUMMY_VAR__;
        current_statement__ = 53;
        tg1 = stan::math::reduce_sum<g1_rsfunctor__>(y1, 1, pstream__, y9);
        local_scalar_t__ tg2 = DUMMY_VAR__;
        current_statement__ = 54;
        tg2 = stan::math::reduce_sum<g2_rsfunctor__>(y1, 1, pstream__, y10);
        local_scalar_t__ tg3 = DUMMY_VAR__;
        current_statement__ = 55;
        tg3 = stan::math::reduce_sum<g3_rsfunctor__>(y1, 1, pstream__, y11);
        local_scalar_t__ tg4 = DUMMY_VAR__;
        current_statement__ = 56;
        tg4 = stan::math::reduce_sum<g4_rsfunctor__>(y1, 1, pstream__, y12);
        local_scalar_t__ tg5 = DUMMY_VAR__;
        current_statement__ = 57;
        tg5 = stan::math::reduce_sum<g5_rsfunctor__>(y1, 1, pstream__, y1);
        local_scalar_t__ tg6 = DUMMY_VAR__;
        current_statement__ = 58;
        tg6 = stan::math::reduce_sum<g6_rsfunctor__>(y1, 1, pstream__, y2);
        local_scalar_t__ tg7 = DUMMY_VAR__;
        current_statement__ = 59;
        tg7 = stan::math::reduce_sum<g7_rsfunctor__>(y1, 1, pstream__, y3);
        local_scalar_t__ tg8 = DUMMY_VAR__;
        current_statement__ = 60;
        tg8 = stan::math::reduce_sum<g8_rsfunctor__>(y1, 1, pstream__, y4);
        local_scalar_t__ tg9 = DUMMY_VAR__;
        current_statement__ = 61;
        tg9 = stan::math::reduce_sum<g9_rsfunctor__>(y1, 1, pstream__, y5);
        local_scalar_t__ tg10 = DUMMY_VAR__;
        current_statement__ = 62;
        tg10 = stan::math::reduce_sum<g10_rsfunctor__>(y1, 1, pstream__, y6);
        local_scalar_t__ tg11 = DUMMY_VAR__;
        current_statement__ = 63;
        tg11 = stan::math::reduce_sum<g11_rsfunctor__>(y1, 1, pstream__, y7);
        local_scalar_t__ tg12 = DUMMY_VAR__;
        current_statement__ = 64;
        tg12 = stan::math::reduce_sum<g12_rsfunctor__>(y1, 1, pstream__, y8);
        local_scalar_t__ ts = DUMMY_VAR__;
        current_statement__ = 65;
        ts = stan::math::reduce_sum<s_rsfunctor__>(y1d, 1, pstream__, y13d,
               y9, y10, y11, y12, y14d, y1, y2, y3, y4, y15d, y5, y6, y7, y8,
               y16d, y17);
        local_scalar_t__ tt = DUMMY_VAR__;
        current_statement__ = 66;
        tt = r(pstream__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "reduce_sum_m3_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<double> y1 =
        std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      y1 = in__.template read<std::vector<local_scalar_t__>>(N);
      std::vector<Eigen::Matrix<double,-1,1>> y2 =
        std::vector<Eigen::Matrix<double,-1,1>>(N,
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 2;
      y2 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N, N);
      std::vector<Eigen::Matrix<double,1,-1>> y3 =
        std::vector<Eigen::Matrix<double,1,-1>>(N,
          Eigen::Matrix<double,1,-1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 3;
      y3 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N, N);
      std::vector<Eigen::Matrix<double,-1,-1>> y4 =
        std::vector<Eigen::Matrix<double,-1,-1>>(N,
          Eigen::Matrix<double,-1,-1>::Constant(N, N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 4;
      y4 = in__.template read<
             std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N, N, N);
      std::vector<std::vector<double>> y5 =
        std::vector<std::vector<double>>(N,
          std::vector<double>(N, std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 5;
      y5 = in__.template read<std::vector<std::vector<local_scalar_t__>>>(N,
             N);
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> y6 =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(N,
          std::vector<Eigen::Matrix<double,-1,1>>(N,
            Eigen::Matrix<double,-1,1>::Constant(N,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 6;
      y6 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(N,
             N, N);
      std::vector<std::vector<Eigen::Matrix<double,1,-1>>> y7 =
        std::vector<std::vector<Eigen::Matrix<double,1,-1>>>(N,
          std::vector<Eigen::Matrix<double,1,-1>>(N,
            Eigen::Matrix<double,1,-1>::Constant(N,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 7;
      y7 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>>(N,
             N, N);
      std::vector<std::vector<Eigen::Matrix<double,-1,-1>>> y8 =
        std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>(N,
          std::vector<Eigen::Matrix<double,-1,-1>>(N,
            Eigen::Matrix<double,-1,-1>::Constant(N, N,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 8;
      y8 = in__.template read<
             std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>>(N,
             N, N, N);
      double y9 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 9;
      y9 = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,1> y10 =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 10;
      y10 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<double,1,-1> y11 =
        Eigen::Matrix<double,1,-1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 11;
      y11 = in__.template read<Eigen::Matrix<local_scalar_t__,1,-1>>(N);
      Eigen::Matrix<double,-1,-1> y12 =
        Eigen::Matrix<double,-1,-1>::Constant(N, N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 12;
      y12 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N);
      std::vector<std::vector<std::vector<double>>> y17 =
        std::vector<std::vector<std::vector<double>>>(N,
          std::vector<std::vector<double>>(N,
            std::vector<double>(N, std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 13;
      y17 = in__.template read<
              std::vector<std::vector<std::vector<local_scalar_t__>>>>(N, N,
              N);
      out__.write(y1);
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(y2[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(y3[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            out__.write(stan::model::rvalue(y4, "y4",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          out__.write(y5[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            out__.write(y6[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            out__.write(y7[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              out__.write(stan::model::rvalue(y8, "y8",
                            stan::model::index_uni(sym4__),
                            stan::model::index_uni(sym3__),
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(sym1__)));
            }
          }
        }
      }
      out__.write(y9);
      out__.write(y10);
      out__.write(y11);
      out__.write(y12);
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            out__.write(y17[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      double t1 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 14;
      t1 = stan::math::reduce_sum<f1_rsfunctor__>(y1, 1, pstream__);
      double t1a = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 15;
      t1a = (stan::math::reduce_sum<f1_rsfunctor__>(y1, 1, pstream__) +
        stan::math::reduce_sum<f1a_rsfunctor__>(y1, 1, pstream__));
      double t2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 16;
      t2 = stan::math::reduce_sum<f2_rsfunctor__>(y2, 1, pstream__);
      double t3 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 17;
      t3 = stan::math::reduce_sum<f3_rsfunctor__>(y3, 1, pstream__);
      double t4 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 18;
      t4 = stan::math::reduce_sum<f4_rsfunctor__>(y4, 1, pstream__);
      double t5 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 19;
      t5 = stan::math::reduce_sum<f5_rsfunctor__>(y5, 1, pstream__);
      double t6 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 20;
      t6 = stan::math::reduce_sum<f6_rsfunctor__>(y6, 1, pstream__);
      double t7 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 21;
      t7 = stan::math::reduce_sum<f7_rsfunctor__>(y7, 1, pstream__);
      double t8 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 22;
      t8 = stan::math::reduce_sum<f8_rsfunctor__>(y8, 1, pstream__);
      double t9 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 23;
      t9 = stan::math::reduce_sum<f9_rsfunctor__>(y14d, 1, pstream__);
      double t10 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 24;
      t10 = stan::math::reduce_sum<f10_rsfunctor__>(y15d, 1, pstream__);
      double t11 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 25;
      t11 = stan::math::reduce_sum<f11_rsfunctor__>(y16d, 1, pstream__);
      double t12 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 26;
      t12 = stan::math::reduce_sum<f12_rsfunctor__>(y17, 1, pstream__);
      double tg1 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 27;
      tg1 = stan::math::reduce_sum<g1_rsfunctor__>(y1, 1, pstream__, y9);
      double tg2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 28;
      tg2 = stan::math::reduce_sum<g2_rsfunctor__>(y1, 1, pstream__, y10);
      double tg3 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 29;
      tg3 = stan::math::reduce_sum<g3_rsfunctor__>(y1, 1, pstream__, y11);
      double tg4 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 30;
      tg4 = stan::math::reduce_sum<g4_rsfunctor__>(y1, 1, pstream__, y12);
      double tg5 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 31;
      tg5 = stan::math::reduce_sum<g5_rsfunctor__>(y1, 1, pstream__, y1);
      double tg6 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 32;
      tg6 = stan::math::reduce_sum<g6_rsfunctor__>(y1, 1, pstream__, y2);
      double tg7 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 33;
      tg7 = stan::math::reduce_sum<g7_rsfunctor__>(y1, 1, pstream__, y3);
      double tg8 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 34;
      tg8 = stan::math::reduce_sum<g8_rsfunctor__>(y1, 1, pstream__, y4);
      double tg9 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 35;
      tg9 = stan::math::reduce_sum<g9_rsfunctor__>(y1, 1, pstream__, y5);
      double tg10 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 36;
      tg10 = stan::math::reduce_sum<g10_rsfunctor__>(y1, 1, pstream__, y6);
      double tg11 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 37;
      tg11 = stan::math::reduce_sum<g11_rsfunctor__>(y1, 1, pstream__, y7);
      double tg12 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 38;
      tg12 = stan::math::reduce_sum<g12_rsfunctor__>(y1, 1, pstream__, y8);
      double tgs = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 39;
      tgs = stan::math::reduce_sum<s_rsfunctor__>(y1d, 1, pstream__, y13d,
              y9d, y10d, y11d, y12d, y14d, y1d, y2d, y3d, y4d, y15d, y5d,
              y6d, y7d, y8d, y16d, y17);
      out__.write(t1);
      out__.write(t1a);
      out__.write(t2);
      out__.write(t3);
      out__.write(t4);
      out__.write(t5);
      out__.write(t6);
      out__.write(t7);
      out__.write(t8);
      out__.write(t9);
      out__.write(t10);
      out__.write(t11);
      out__.write(t12);
      out__.write(tg1);
      out__.write(tg2);
      out__.write(tg3);
      out__.write(tg4);
      out__.write(tg5);
      out__.write(tg6);
      out__.write(tg7);
      out__.write(tg8);
      out__.write(tg9);
      out__.write(tg10);
      out__.write(tg11);
      out__.write(tg12);
      out__.write(tgs);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      std::vector<local_scalar_t__> y1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(y1, in__.read<std::vector<local_scalar_t__>>(N),
        "assigning variable y1");
      out__.write(y1);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> y2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 2;
          stan::model::assign(y2, in__.read<local_scalar_t__>(),
            "assigning variable y2", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write(y2);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> y3 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 3;
          stan::model::assign(y3, in__.read<local_scalar_t__>(),
            "assigning variable y3", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write(y3);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> y4 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 4;
            stan::model::assign(y4, in__.read<local_scalar_t__>(),
              "assigning variable y4", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write(y4);
      std::vector<std::vector<local_scalar_t__>> y5 =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 5;
          y5[(sym2__ - 1)][(sym1__ - 1)] = in__.read<local_scalar_t__>();
        }
      }
      out__.write(y5);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> y6 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 6;
            stan::model::assign(y6, in__.read<local_scalar_t__>(),
              "assigning variable y6", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write(y6);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> y7 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 7;
            stan::model::assign(y7, in__.read<local_scalar_t__>(),
              "assigning variable y7", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write(y7);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> y8 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N,
              DUMMY_VAR__)));
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              current_statement__ = 8;
              stan::model::assign(y8, in__.read<local_scalar_t__>(),
                "assigning variable y8", stan::model::index_uni(sym4__),
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
            }
          }
        }
      }
      out__.write(y8);
      local_scalar_t__ y9 = DUMMY_VAR__;
      current_statement__ = 9;
      y9 = in__.read<local_scalar_t__>();
      out__.write(y9);
      Eigen::Matrix<local_scalar_t__,-1,1> y10 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 10;
      stan::model::assign(y10,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable y10");
      out__.write(y10);
      Eigen::Matrix<local_scalar_t__,1,-1> y11 =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 11;
      stan::model::assign(y11,
        in__.read<Eigen::Matrix<local_scalar_t__,1,-1>>(N),
        "assigning variable y11");
      out__.write(y11);
      Eigen::Matrix<local_scalar_t__,-1,-1> y12 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      current_statement__ = 12;
      stan::model::assign(y12,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N),
        "assigning variable y12");
      out__.write(y12);
      std::vector<std::vector<std::vector<local_scalar_t__>>> y17 =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(N,
          std::vector<std::vector<local_scalar_t__>>(N,
            std::vector<local_scalar_t__>(N, DUMMY_VAR__)));
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 13;
            y17[(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
              1)] = in__.read<local_scalar_t__>();
          }
        }
      }
      out__.write(y17);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "y1", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "y2", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "y3", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "y4", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "y5", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "y6", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "y7", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization", "y8", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 9;
      context__.validate_dims("parameter initialization", "y9", "double",
        std::vector<size_t>{});
      current_statement__ = 10;
      context__.validate_dims("parameter initialization", "y10", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 11;
      context__.validate_dims("parameter initialization", "y11", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 12;
      context__.validate_dims("parameter initialization", "y12", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 13;
      context__.validate_dims("parameter initialization", "y17", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N),
          static_cast<size_t>(N)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      std::vector<local_scalar_t__> y1 =
        std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      current_statement__ = 1;
      y1 = context__.vals_r("y1");
      out__.write(y1);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> y2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> y2_flat__;
        current_statement__ = 2;
        y2_flat__ = context__.vals_r("y2");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y2, y2_flat__[(pos__ - 1)],
              "assigning variable y2", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(y2);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> y3 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> y3_flat__;
        current_statement__ = 3;
        y3_flat__ = context__.vals_r("y3");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y3, y3_flat__[(pos__ - 1)],
              "assigning variable y3", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(y3);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> y4 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> y4_flat__;
        current_statement__ = 4;
        y4_flat__ = context__.vals_r("y4");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(y4, y4_flat__[(pos__ - 1)],
                "assigning variable y4", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(y4);
      std::vector<std::vector<local_scalar_t__>> y5 =
        std::vector<std::vector<local_scalar_t__>>(N,
          std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> y5_flat__;
        current_statement__ = 5;
        y5_flat__ = context__.vals_r("y5");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y5, y5_flat__[(pos__ - 1)],
              "assigning variable y5", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(y5);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> y6 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> y6_flat__;
        current_statement__ = 6;
        y6_flat__ = context__.vals_r("y6");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(y6, y6_flat__[(pos__ - 1)],
                "assigning variable y6", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(y6);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> y7 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> y7_flat__;
        current_statement__ = 7;
        y7_flat__ = context__.vals_r("y7");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(y7, y7_flat__[(pos__ - 1)],
                "assigning variable y7", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(y7);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>> y8 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(N,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
            Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N,
              DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> y8_flat__;
        current_statement__ = 8;
        y8_flat__ = context__.vals_r("y8");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                stan::model::assign(y8, y8_flat__[(pos__ - 1)],
                  "assigning variable y8", stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      out__.write(y8);
      local_scalar_t__ y9 = DUMMY_VAR__;
      current_statement__ = 9;
      y9 = context__.vals_r("y9")[(1 - 1)];
      out__.write(y9);
      Eigen::Matrix<local_scalar_t__,-1,1> y10 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> y10_flat__;
        current_statement__ = 10;
        y10_flat__ = context__.vals_r("y10");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(y10, y10_flat__[(pos__ - 1)],
            "assigning variable y10", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(y10);
      Eigen::Matrix<local_scalar_t__,1,-1> y11 =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> y11_flat__;
        current_statement__ = 11;
        y11_flat__ = context__.vals_r("y11");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(y11, y11_flat__[(pos__ - 1)],
            "assigning variable y11", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(y11);
      Eigen::Matrix<local_scalar_t__,-1,-1> y12 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> y12_flat__;
        current_statement__ = 12;
        y12_flat__ = context__.vals_r("y12");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(y12, y12_flat__[(pos__ - 1)],
              "assigning variable y12", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(y12);
      std::vector<std::vector<std::vector<local_scalar_t__>>> y17 =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(N,
          std::vector<std::vector<local_scalar_t__>>(N,
            std::vector<local_scalar_t__>(N, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> y17_flat__;
        current_statement__ = 13;
        y17_flat__ = context__.vals_r("y17");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              stan::model::assign(y17, y17_flat__[(pos__ - 1)],
                "assigning variable y17", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(y17);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"y1", "y2", "y3", "y4", "y5", "y6",
                "y7", "y8", "y9", "y10", "y11", "y12", "y17"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      std::vector<std::string>
        temp{"t1", "t1a", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "t9",
             "t10", "t11", "t12", "tg1", "tg2", "tg3", "tg4", "tg5", "tg6",
             "tg7", "tg8", "tg9", "tg10", "tg11", "tg12", "tgs"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N), static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N), static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N), static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N), static_cast<size_t>(N),
                  static_cast<size_t>(N)}, std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N), static_cast<size_t>(N)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y1" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y2" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y3" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y4" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y5" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y6" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y7" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
            param_names__.emplace_back(std::string() + "y8" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    param_names__.emplace_back(std::string() + "y9");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y10" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y11" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y12" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y17" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "t1");
      param_names__.emplace_back(std::string() + "t1a");
      param_names__.emplace_back(std::string() + "t2");
      param_names__.emplace_back(std::string() + "t3");
      param_names__.emplace_back(std::string() + "t4");
      param_names__.emplace_back(std::string() + "t5");
      param_names__.emplace_back(std::string() + "t6");
      param_names__.emplace_back(std::string() + "t7");
      param_names__.emplace_back(std::string() + "t8");
      param_names__.emplace_back(std::string() + "t9");
      param_names__.emplace_back(std::string() + "t10");
      param_names__.emplace_back(std::string() + "t11");
      param_names__.emplace_back(std::string() + "t12");
      param_names__.emplace_back(std::string() + "tg1");
      param_names__.emplace_back(std::string() + "tg2");
      param_names__.emplace_back(std::string() + "tg3");
      param_names__.emplace_back(std::string() + "tg4");
      param_names__.emplace_back(std::string() + "tg5");
      param_names__.emplace_back(std::string() + "tg6");
      param_names__.emplace_back(std::string() + "tg7");
      param_names__.emplace_back(std::string() + "tg8");
      param_names__.emplace_back(std::string() + "tg9");
      param_names__.emplace_back(std::string() + "tg10");
      param_names__.emplace_back(std::string() + "tg11");
      param_names__.emplace_back(std::string() + "tg12");
      param_names__.emplace_back(std::string() + "tgs");
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y1" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y2" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y3" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y4" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y5" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y6" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y7" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
            param_names__.emplace_back(std::string() + "y8" + '.' +
              std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' +
              std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }
        }
      }
    }
    param_names__.emplace_back(std::string() + "y9");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y10" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "y11" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "y12" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
          param_names__.emplace_back(std::string() + "y17" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "t1");
      param_names__.emplace_back(std::string() + "t1a");
      param_names__.emplace_back(std::string() + "t2");
      param_names__.emplace_back(std::string() + "t3");
      param_names__.emplace_back(std::string() + "t4");
      param_names__.emplace_back(std::string() + "t5");
      param_names__.emplace_back(std::string() + "t6");
      param_names__.emplace_back(std::string() + "t7");
      param_names__.emplace_back(std::string() + "t8");
      param_names__.emplace_back(std::string() + "t9");
      param_names__.emplace_back(std::string() + "t10");
      param_names__.emplace_back(std::string() + "t11");
      param_names__.emplace_back(std::string() + "t12");
      param_names__.emplace_back(std::string() + "tg1");
      param_names__.emplace_back(std::string() + "tg2");
      param_names__.emplace_back(std::string() + "tg3");
      param_names__.emplace_back(std::string() + "tg4");
      param_names__.emplace_back(std::string() + "tg5");
      param_names__.emplace_back(std::string() + "tg6");
      param_names__.emplace_back(std::string() + "tg7");
      param_names__.emplace_back(std::string() + "tg8");
      param_names__.emplace_back(std::string() + "tg9");
      param_names__.emplace_back(std::string() + "tg10");
      param_names__.emplace_back(std::string() + "tg11");
      param_names__.emplace_back(std::string() + "tg12");
      param_names__.emplace_back(std::string() + "tgs");
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"y1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"y3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"y4\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"y5\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"y6\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"y7\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"y8\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"y9\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y10\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"y11\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"y12\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"y17\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"parameters\"},{\"name\":\"t1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t1a\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t3\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t4\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t5\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t6\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t7\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t8\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t9\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t10\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t11\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t12\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg3\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg4\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg5\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg6\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg7\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg8\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg9\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg10\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg11\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg12\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tgs\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"y1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"y3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"y4\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"y5\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"y6\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"y7\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"y8\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "}}},\"block\":\"parameters\"},{\"name\":\"y9\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y10\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"y11\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"y12\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"y17\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"parameters\"},{\"name\":\"t1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t1a\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t3\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t4\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t5\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t6\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t7\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t8\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t9\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t10\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t11\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t12\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg3\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg4\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg5\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg6\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg7\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg8\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg9\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg10\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg11\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg12\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tgs\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((((((N + (N * N)) + (N * N)) + (N * (N
      * N))) + (N * N)) + (N * (N * N))) + (N * (N * N))) + (N * (N * (N *
      N)))) + 1) + N) + N) + (N * N)) + (N * (N * N)));
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities *
      ((((((((((((((((((((((((((1 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
      1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
      1) + 1) + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((((((N + (N * N)) + (N * N)) + (N * (N
      * N))) + (N * N)) + (N * (N * N))) + (N * (N * N))) + (N * (N * (N *
      N)))) + 1) + N) + N) + (N * N)) + (N * (N * N)));
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities *
      ((((((((((((((((((((((((((1 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
      1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
      1) + 1) + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = reduce_sum_m3_model_namespace::reduce_sum_m3_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return reduce_sum_m3_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp return-position-types.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace return_position_types_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 11> locations_array__ =
  {" (found before start of program)",
  " (in 'return-position-types.stan', line 15, column 2 to column 9)",
  " (in 'return-position-types.stan', line 18, column 2 to column 27)",
  " (in 'return-position-types.stan', line 19, column 2 to column 31)",
  " (in 'return-position-types.stan', line 20, column 2 to column 30)",
  " (in 'return-position-types.stan', line 3, column 4 to column 17)",
  " (in 'return-position-types.stan', line 2, column 27 to line 4, column 3)",
  " (in 'return-position-types.stan', line 7, column 4 to column 23)",
  " (in 'return-position-types.stan', line 6, column 42 to line 8, column 3)",
  " (in 'return-position-types.stan', line 11, column 4 to column 24)",
  " (in 'return-position-types.stan', line 10, column 30 to line 12, column 3)"};
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
std::vector<stan::promote_args_t<T0__>>
foo(const T0__& a, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
std::tuple<std::vector<stan::promote_args_t<T0__>>,
  stan::promote_args_t<T0__>>
baz(const T0__& a, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
std::vector<std::complex<stan::promote_args_t<T0__>>>
bar(const T0__& a, std::ostream* pstream__);
// array[] real foo(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
std::vector<stan::promote_args_t<T0__>>
foo(const T0__& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 5;
    return std::vector<local_scalar_t__>{0.1};
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// tuple(array[] real, real) baz(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
std::tuple<std::vector<stan::promote_args_t<T0__>>,
  stan::promote_args_t<T0__>>
baz(const T0__& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 7;
    return std::tuple<std::vector<local_scalar_t__>, local_scalar_t__>(
             std::vector<local_scalar_t__>{0.1}, 0.2);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// array[] complex bar(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
std::vector<std::complex<stan::promote_args_t<T0__>>>
bar(const T0__& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 9;
    return std::vector<std::complex<local_scalar_t__>>{stan::math::promote_scalar<
                                                         std::complex<local_scalar_t__>>(
                                                         (0.1 +
                                                         stan::math::to_complex(
                                                           0, 0.3)))};
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class return_position_types_model final : public model_base_crtp<return_position_types_model> {
 private:
  
 public:
  ~return_position_types_model() {}
  return_position_types_model(stan::io::var_context& context__, unsigned int
                              random_seed__ = 0, std::ostream*
                              pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "return_position_types_model_namespace::return_position_types_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 1;
  }
  inline std::string model_name() const final {
    return "return_position_types_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "return_position_types_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ a = DUMMY_VAR__;
      current_statement__ = 1;
      a = in__.template read<local_scalar_t__>();
      {
        std::vector<local_scalar_t__> z =
          std::vector<local_scalar_t__>(1, DUMMY_VAR__);
        current_statement__ = 2;
        stan::model::assign(z, foo(a, pstream__), "assigning variable z");
        std::vector<std::complex<local_scalar_t__>> z2 =
          std::vector<std::complex<local_scalar_t__>>(1,
            std::complex<local_scalar_t__>(DUMMY_VAR__, DUMMY_VAR__));
        current_statement__ = 3;
        stan::model::assign(z2, bar(a, pstream__), "assigning variable z2");
        std::vector<local_scalar_t__> z3 =
          std::vector<local_scalar_t__>(1, DUMMY_VAR__);
        current_statement__ = 4;
        stan::model::assign(z3, std::get<0>(baz(a, pstream__)),
          "assigning variable z3");
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "return_position_types_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ a = DUMMY_VAR__;
      current_statement__ = 1;
      a = in__.template read<local_scalar_t__>();
      {
        std::vector<local_scalar_t__> z =
          std::vector<local_scalar_t__>(1, DUMMY_VAR__);
        current_statement__ = 2;
        stan::model::assign(z, foo(a, pstream__), "assigning variable z");
        std::vector<std::complex<local_scalar_t__>> z2 =
          std::vector<std::complex<local_scalar_t__>>(1,
            std::complex<local_scalar_t__>(DUMMY_VAR__, DUMMY_VAR__));
        current_statement__ = 3;
        stan::model::assign(z2, bar(a, pstream__), "assigning variable z2");
        std::vector<local_scalar_t__> z3 =
          std::vector<local_scalar_t__>(1, DUMMY_VAR__);
        current_statement__ = 4;
        stan::model::assign(z3, std::get<0>(baz(a, pstream__)),
          "assigning variable z3");
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "return_position_types_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double a = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      a = in__.template read<local_scalar_t__>();
      out__.write(a);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ a = DUMMY_VAR__;
      current_statement__ = 1;
      a = in__.read<local_scalar_t__>();
      out__.write(a);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "a", "double",
        std::vector<size_t>{});
      local_scalar_t__ a = DUMMY_VAR__;
      current_statement__ = 1;
      a = context__.vals_r("a")[(1 - 1)];
      out__.write(a);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"a"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "a");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "a");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = return_position_types_model_namespace::return_position_types_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return return_position_types_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp self-assign.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace self_assign_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 8> locations_array__ =
  {" (found before start of program)",
  " (in 'self-assign.stan', line 2, column 2 to column 12)",
  " (in 'self-assign.stan', line 6, column 2 to column 32)",
  " (in 'self-assign.stan', line 10, column 2 to column 19)",
  " (in 'self-assign.stan', line 4, column 2 to column 8)",
  " (in 'self-assign.stan', line 8, column 2 to column 12)",
  " (in 'self-assign.stan', line 12, column 4 to column 66)",
  " (in 'self-assign.stan', line 11, column 2 to line 12, column 66)"};
class self_assign_model final : public model_base_crtp<self_assign_model> {
 private:
  
 public:
  ~self_assign_model() {}
  self_assign_model(stan::io::var_context& context__, unsigned int
                    random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "self_assign_model_namespace::self_assign_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "self_assign_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "self_assign_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "self_assign_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "self_assign_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      int i = std::numeric_limits<int>::min();
      current_statement__ = 1;
      i = 3;
      current_statement__ = 4;
      // self-assignment omitted: i
      std::tuple<double, int> x =
        std::tuple<double, int>{std::numeric_limits<double>::quiet_NaN(),
          std::numeric_limits<int>::min()};
      current_statement__ = 2;
      stan::model::assign(x, std::tuple<double, int>(1.5, i),
        "assigning variable x");
      current_statement__ = 5;
      // self-assignment omitted: x.1
      std::vector<double> r =
        std::vector<double>(20, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 7;
      for (int j = 1; j <= 20; ++j) {
        current_statement__ = 6;
        stan::model::assign(r,
          stan::model::rvalue(r, "r",
            stan::model::index_uni(
              stan::math::to_int(stan::math::uniform_rng(1, 20, base_rng__)))),
          "assigning variable r",
          stan::model::index_uni(
            stan::math::to_int(stan::math::uniform_rng(1, 20, base_rng__))));
      }
      out__.write(i);
      out__.write(std::get<0>(x));
      out__.write(std::get<1>(x));
      out__.write(r);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      std::vector<std::string> temp{"i", "x.1", "x.2", "r"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(20)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "i");
      param_names__.emplace_back(std::string() + "x" + ':' +
        std::to_string(1));
      param_names__.emplace_back(std::string() + "x" + ':' +
        std::to_string(2));
      for (int sym1__ = 1; sym1__ <= 20; ++sym1__) {
        param_names__.emplace_back(std::string() + "r" + '.' +
          std::to_string(sym1__));
      }
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "i");
      param_names__.emplace_back(std::string() + "x" + ':' +
        std::to_string(1));
      param_names__.emplace_back(std::string() + "x" + ':' +
        std::to_string(2));
      for (int sym1__ = 1; sym1__ <= 20; ++sym1__) {
        param_names__.emplace_back(std::string() + "r" + '.' +
          std::to_string(sym1__));
      }
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"i\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"tuple\",\"num_elements\":\"2\",\"element_types\":[{\"name\":\"real\"},{\"name\":\"int\"}]},\"block\":\"generated_quantities\"},{\"name\":\"r\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(20) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"i\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"tuple\",\"num_elements\":\"2\",\"element_types\":[{\"name\":\"real\"},{\"name\":\"int\"}]},\"block\":\"generated_quantities\"},{\"name\":\"r\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(20) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (((1 + (1 +
      1)) + 20));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (((1 + (1 +
      1)) + 20));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = self_assign_model_namespace::self_assign_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return self_assign_model_namespace::profiles__;
}
#endif
Warning in 'self-assign.stan', line 4, column 2: Assignment of variable to
    itself.
Warning in 'self-assign.stan', line 8, column 2: Assignment of variable to
    itself.
Warning in 'self-assign.stan', line 12, column 4: Assignment of variable to
    itself.
  $ ../../../../../install/default/bin/stanc --print-cpp shadowing.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace shadowing_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 53> locations_array__ =
  {" (found before start of program)",
  " (in 'shadowing.stan', line 14, column 2 to column 9)",
  " (in 'shadowing.stan', line 15, column 2 to column 10)",
  " (in 'shadowing.stan', line 16, column 2 to column 12)",
  " (in 'shadowing.stan', line 17, column 2 to column 13)",
  " (in 'shadowing.stan', line 18, column 2 to column 13)",
  " (in 'shadowing.stan', line 19, column 2 to column 20)",
  " (in 'shadowing.stan', line 20, column 2 to column 25)",
  " (in 'shadowing.stan', line 21, column 2 to column 25)",
  " (in 'shadowing.stan', line 22, column 2 to column 25)",
  " (in 'shadowing.stan', line 24, column 2 to column 17)",
  " (in 'shadowing.stan', line 25, column 2 to column 13)",
  " (in 'shadowing.stan', line 26, column 2 to column 20)",
  " (in 'shadowing.stan', line 29, column 2 to column 11)",
  " (in 'shadowing.stan', line 30, column 2 to column 11)",
  " (in 'shadowing.stan', line 31, column 2 to column 11)",
  " (in 'shadowing.stan', line 32, column 2 to column 16)",
  " (in 'shadowing.stan', line 33, column 2 to column 15)",
  " (in 'shadowing.stan', line 34, column 2 to column 32)",
  " (in 'shadowing.stan', line 37, column 2 to column 34)",
  " (in 'shadowing.stan', line 38, column 2 to column 12)",
  " (in 'shadowing.stan', line 39, column 2 to column 35)",
  " (in 'shadowing.stan', line 40, column 2 to column 14)",
  " (in 'shadowing.stan', line 41, column 2 to column 37)",
  " (in 'shadowing.stan', line 42, column 2 to column 19)",
  " (in 'shadowing.stan', line 43, column 2 to column 14)",
  " (in 'shadowing.stan', line 44, column 2 to column 14)",
  " (in 'shadowing.stan', line 45, column 2 to column 18)",
  " (in 'shadowing.stan', line 46, column 2 to column 23)",
  " (in 'shadowing.stan', line 47, column 2 to column 17)",
  " (in 'shadowing.stan', line 50, column 2 to column 32)",
  " (in 'shadowing.stan', line 51, column 2 to column 18)",
  " (in 'shadowing.stan', line 52, column 2 to column 20)",
  " (in 'shadowing.stan', line 53, column 2 to column 15)",
  " (in 'shadowing.stan', line 54, column 2 to column 19)",
  " (in 'shadowing.stan', line 57, column 2 to column 10)",
  " (in 'shadowing.stan', line 70, column 2 to column 69)",
  " (in 'shadowing.stan', line 73, column 2 to column 43)",
  " (in 'shadowing.stan', line 58, column 2 to line 59, column 70)",
  " (in 'shadowing.stan', line 60, column 2 to column 54)",
  " (in 'shadowing.stan', line 62, column 2 to column 55)",
  " (in 'shadowing.stan', line 64, column 2 to column 23)",
  " (in 'shadowing.stan', line 66, column 2 to column 23)",
  " (in 'shadowing.stan', line 68, column 2 to column 58)",
  " (in 'shadowing.stan', line 76, column 4 to column 22)",
  " (in 'shadowing.stan', line 75, column 2 to line 77, column 3)",
  " (in 'shadowing.stan', line 80, column 2 to column 23)",
  " (in 'shadowing.stan', line 10, column 3 to column 15)",
  " (in 'shadowing.stan', line 70, column 8 to column 9)",
  " (in 'shadowing.stan', line 73, column 9 to column 24)",
  " (in 'shadowing.stan', line 3, column 4 to column 30)",
  " (in 'shadowing.stan', line 5, column 4 to column 14)",
  " (in 'shadowing.stan', line 2, column 43 to line 6, column 3)"};
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>, T2__>,-1,1>
rhs(const T0__& t, const T1__& y_arg__, const T2__& alpha, std::ostream*
    pstream__);
struct rhs_variadic2_functor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                        std::is_floating_point<T0__>>,
                                stan::is_col_vector<T1__>,
                                stan::is_vt_not_complex<T1__>,
                                stan::math::disjunction<stan::is_autodiff<T2__>,
                                                        std::is_floating_point<T2__>>>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>, T2__>,-1,1>
  operator()(const T0__& t, const T1__& y, std::ostream* pstream__,
             const T2__& alpha) const {
    return rhs(t, y, alpha, pstream__);
  }
};
// vector rhs(real, vector, real)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>, T2__>,-1,1>
rhs(const T0__& t, const T1__& y_arg__, const T2__& alpha, std::ostream*
    pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
                             stan::base_type_t<T1__>, T2__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& y = stan::math::to_ref(y_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    Eigen::Matrix<local_scalar_t__,-1,1> yp =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(1, DUMMY_VAR__);
    current_statement__ = 50;
    stan::model::assign(yp, stan::math::multiply(-(alpha), y),
      "assigning variable yp");
    current_statement__ = 51;
    return yp;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class shadowing_model final : public model_base_crtp<shadowing_model> {
 private:
  Eigen::Matrix<double,-1,1> x_data__;
  int result_1dim__;
  Eigen::Map<Eigen::Matrix<double,-1,1>> x{nullptr, 0};
 public:
  ~shadowing_model() {}
  shadowing_model(stan::io::var_context& context__, unsigned int
                  random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "shadowing_model_namespace::shadowing_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 47;
      context__.validate_dims("data initialization", "x", "double",
        std::vector<size_t>{static_cast<size_t>(4)});
      x_data__ = Eigen::Matrix<double,-1,1>::Constant(4,
                   std::numeric_limits<double>::quiet_NaN());
      new (&x) Eigen::Map<Eigen::Matrix<double,-1,1>>(x_data__.data(), 4);
      {
        std::vector<local_scalar_t__> x_flat__;
        current_statement__ = 47;
        x_flat__ = context__.vals_r("x");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
          stan::model::assign(x, x_flat__[(pos__ - 1)],
            "assigning variable x", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 48;
      stan::math::validate_non_negative_index("called", "1", 1);
      current_statement__ = 49;
      result_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 49;
      result_1dim__ = stan::math::num_elements(x);
      current_statement__ = 49;
      stan::math::validate_non_negative_index("result", "num_elements(x)",
        result_1dim__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +
      1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + (5 - 1) + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
      + 4 + 1 + 1;
  }
  inline std::string model_name() const final {
    return "shadowing_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "shadowing_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ e = DUMMY_VAR__;
      current_statement__ = 1;
      e = in__.template read<local_scalar_t__>();
      local_scalar_t__ pi = DUMMY_VAR__;
      current_statement__ = 2;
      pi = in__.template read<local_scalar_t__>();
      local_scalar_t__ log2 = DUMMY_VAR__;
      current_statement__ = 3;
      log2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ log10 = DUMMY_VAR__;
      current_statement__ = 4;
      log10 = in__.template read<local_scalar_t__>();
      local_scalar_t__ sqrt2 = DUMMY_VAR__;
      current_statement__ = 5;
      sqrt2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ not_a_number = DUMMY_VAR__;
      current_statement__ = 6;
      not_a_number = in__.template read<local_scalar_t__>();
      local_scalar_t__ positive_infinity = DUMMY_VAR__;
      current_statement__ = 7;
      positive_infinity = in__.template read<local_scalar_t__>();
      local_scalar_t__ negative_infinity = DUMMY_VAR__;
      current_statement__ = 8;
      negative_infinity = in__.template read<local_scalar_t__>();
      local_scalar_t__ machine_precision = DUMMY_VAR__;
      current_statement__ = 9;
      machine_precision = in__.template read<local_scalar_t__>();
      local_scalar_t__ inv_logit = DUMMY_VAR__;
      current_statement__ = 10;
      inv_logit = in__.template read<local_scalar_t__>();
      local_scalar_t__ logit = DUMMY_VAR__;
      current_statement__ = 11;
      logit = in__.template read<local_scalar_t__>();
      local_scalar_t__ num_elements = DUMMY_VAR__;
      current_statement__ = 12;
      num_elements = in__.template read<local_scalar_t__>();
      local_scalar_t__ pow = DUMMY_VAR__;
      current_statement__ = 13;
      pow = in__.template read<local_scalar_t__>();
      local_scalar_t__ add = DUMMY_VAR__;
      current_statement__ = 14;
      add = in__.template read<local_scalar_t__>();
      local_scalar_t__ sub = DUMMY_VAR__;
      current_statement__ = 15;
      sub = in__.template read<local_scalar_t__>();
      local_scalar_t__ multiply = DUMMY_VAR__;
      current_statement__ = 16;
      multiply = in__.template read<local_scalar_t__>();
      local_scalar_t__ lchoose = DUMMY_VAR__;
      current_statement__ = 17;
      lchoose = in__.template read<local_scalar_t__>();
      local_scalar_t__ binomial_coefficient_log = DUMMY_VAR__;
      current_statement__ = 18;
      binomial_coefficient_log = in__.template read<local_scalar_t__>();
      local_scalar_t__ read_constrain_lb = DUMMY_VAR__;
      current_statement__ = 19;
      read_constrain_lb = in__.template read_constrain_lb<local_scalar_t__,
                            jacobian__>(0, lp__);
      local_scalar_t__ read = DUMMY_VAR__;
      current_statement__ = 20;
      read = in__.template read<local_scalar_t__>();
      local_scalar_t__ validate_non_negative_index = DUMMY_VAR__;
      current_statement__ = 21;
      validate_non_negative_index = in__.template read<local_scalar_t__>();
      local_scalar_t__ length = DUMMY_VAR__;
      current_statement__ = 22;
      length = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> validate_positive_index =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(5, DUMMY_VAR__);
      current_statement__ = 23;
      validate_positive_index = in__.template read_constrain_simplex<
                                  Eigen::Matrix<local_scalar_t__,-1,1>,
                                  jacobian__>(lp__, 5);
      local_scalar_t__ profile_map = DUMMY_VAR__;
      current_statement__ = 24;
      profile_map = in__.template read<local_scalar_t__>();
      local_scalar_t__ assign = DUMMY_VAR__;
      current_statement__ = 25;
      assign = in__.template read<local_scalar_t__>();
      local_scalar_t__ rvalue = DUMMY_VAR__;
      current_statement__ = 26;
      rvalue = in__.template read<local_scalar_t__>();
      local_scalar_t__ stan_print = DUMMY_VAR__;
      current_statement__ = 27;
      stan_print = in__.template read<local_scalar_t__>();
      local_scalar_t__ model_base_crtp = DUMMY_VAR__;
      current_statement__ = 28;
      model_base_crtp = in__.template read<local_scalar_t__>();
      local_scalar_t__ index_uni = DUMMY_VAR__;
      current_statement__ = 29;
      index_uni = in__.template read<local_scalar_t__>();
      local_scalar_t__ bernoulli_logit_glm_lpmf = DUMMY_VAR__;
      current_statement__ = 30;
      bernoulli_logit_glm_lpmf = in__.template read<local_scalar_t__>();
      local_scalar_t__ reduce_sum = DUMMY_VAR__;
      current_statement__ = 31;
      reduce_sum = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> segment =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(4, DUMMY_VAR__);
      current_statement__ = 32;
      segment = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(4);
      local_scalar_t__ ode_bdf = DUMMY_VAR__;
      current_statement__ = 33;
      ode_bdf = in__.template read<local_scalar_t__>();
      local_scalar_t__ ode_bdf_tol = DUMMY_VAR__;
      current_statement__ = 34;
      ode_bdf_tol = in__.template read<local_scalar_t__>();
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 38;
      mu = ((((((((stan::math::e() + stan::math::pi()) + stan::math::log2())
        + stan::math::log10()) + stan::math::sqrt2()) +
        stan::math::not_a_number()) + stan::math::positive_infinity()) +
        stan::math::negative_infinity()) + stan::math::machine_precision());
      current_statement__ = 39;
      mu = (mu + ((logit + bernoulli_logit_glm_lpmf) + reduce_sum));
      current_statement__ = 40;
      mu = (mu + ((inv_logit * stan::math::inv_logit(0.5)) + (logit *
        stan::math::logit(10))));
      current_statement__ = 41;
      mu = (mu + (pow * stan::math::pow(3, 2)));
      current_statement__ = 42;
      mu = ((add + add) - sub);
      current_statement__ = 43;
      mu = (mu + ((lchoose * stan::math::binomial_coefficient_log(3, 4)) *
        binomial_coefficient_log));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> called =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(1,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(4, DUMMY_VAR__));
      current_statement__ = 36;
      stan::model::assign(called,
        stan::math::ode_bdf(rhs_variadic2_functor__(), segment, 1.0,
          std::vector<double>{3.0}, pstream__, 3.5),
        "assigning variable called");
      Eigen::Matrix<local_scalar_t__,-1,1> result =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(result_1dim__,
          DUMMY_VAR__);
      current_statement__ = 37;
      stan::model::assign(result, stan::math::multiply(x, 5.0),
        "assigning variable result");
      current_statement__ = 45;
      {
        stan::math::profile<local_scalar_t__> profile__("shadow-1",
          const_cast<stan::math::profile_map&>(profiles__));
        current_statement__ = 44;
        mu = (mu + profile_map);
      }
      {
        current_statement__ = 46;
        if (pstream__) {
          stan::math::stan_print(pstream__, "hello world");
          *(pstream__) << std::endl;
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "shadowing_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ e = DUMMY_VAR__;
      current_statement__ = 1;
      e = in__.template read<local_scalar_t__>();
      local_scalar_t__ pi = DUMMY_VAR__;
      current_statement__ = 2;
      pi = in__.template read<local_scalar_t__>();
      local_scalar_t__ log2 = DUMMY_VAR__;
      current_statement__ = 3;
      log2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ log10 = DUMMY_VAR__;
      current_statement__ = 4;
      log10 = in__.template read<local_scalar_t__>();
      local_scalar_t__ sqrt2 = DUMMY_VAR__;
      current_statement__ = 5;
      sqrt2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ not_a_number = DUMMY_VAR__;
      current_statement__ = 6;
      not_a_number = in__.template read<local_scalar_t__>();
      local_scalar_t__ positive_infinity = DUMMY_VAR__;
      current_statement__ = 7;
      positive_infinity = in__.template read<local_scalar_t__>();
      local_scalar_t__ negative_infinity = DUMMY_VAR__;
      current_statement__ = 8;
      negative_infinity = in__.template read<local_scalar_t__>();
      local_scalar_t__ machine_precision = DUMMY_VAR__;
      current_statement__ = 9;
      machine_precision = in__.template read<local_scalar_t__>();
      local_scalar_t__ inv_logit = DUMMY_VAR__;
      current_statement__ = 10;
      inv_logit = in__.template read<local_scalar_t__>();
      local_scalar_t__ logit = DUMMY_VAR__;
      current_statement__ = 11;
      logit = in__.template read<local_scalar_t__>();
      local_scalar_t__ num_elements = DUMMY_VAR__;
      current_statement__ = 12;
      num_elements = in__.template read<local_scalar_t__>();
      local_scalar_t__ pow = DUMMY_VAR__;
      current_statement__ = 13;
      pow = in__.template read<local_scalar_t__>();
      local_scalar_t__ add = DUMMY_VAR__;
      current_statement__ = 14;
      add = in__.template read<local_scalar_t__>();
      local_scalar_t__ sub = DUMMY_VAR__;
      current_statement__ = 15;
      sub = in__.template read<local_scalar_t__>();
      local_scalar_t__ multiply = DUMMY_VAR__;
      current_statement__ = 16;
      multiply = in__.template read<local_scalar_t__>();
      local_scalar_t__ lchoose = DUMMY_VAR__;
      current_statement__ = 17;
      lchoose = in__.template read<local_scalar_t__>();
      local_scalar_t__ binomial_coefficient_log = DUMMY_VAR__;
      current_statement__ = 18;
      binomial_coefficient_log = in__.template read<local_scalar_t__>();
      local_scalar_t__ read_constrain_lb = DUMMY_VAR__;
      current_statement__ = 19;
      read_constrain_lb = in__.template read_constrain_lb<local_scalar_t__,
                            jacobian__>(0, lp__);
      local_scalar_t__ read = DUMMY_VAR__;
      current_statement__ = 20;
      read = in__.template read<local_scalar_t__>();
      local_scalar_t__ validate_non_negative_index = DUMMY_VAR__;
      current_statement__ = 21;
      validate_non_negative_index = in__.template read<local_scalar_t__>();
      local_scalar_t__ length = DUMMY_VAR__;
      current_statement__ = 22;
      length = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> validate_positive_index =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(5, DUMMY_VAR__);
      current_statement__ = 23;
      validate_positive_index = in__.template read_constrain_simplex<
                                  Eigen::Matrix<local_scalar_t__,-1,1>,
                                  jacobian__>(lp__, 5);
      local_scalar_t__ profile_map = DUMMY_VAR__;
      current_statement__ = 24;
      profile_map = in__.template read<local_scalar_t__>();
      local_scalar_t__ assign = DUMMY_VAR__;
      current_statement__ = 25;
      assign = in__.template read<local_scalar_t__>();
      local_scalar_t__ rvalue = DUMMY_VAR__;
      current_statement__ = 26;
      rvalue = in__.template read<local_scalar_t__>();
      local_scalar_t__ stan_print = DUMMY_VAR__;
      current_statement__ = 27;
      stan_print = in__.template read<local_scalar_t__>();
      local_scalar_t__ model_base_crtp = DUMMY_VAR__;
      current_statement__ = 28;
      model_base_crtp = in__.template read<local_scalar_t__>();
      local_scalar_t__ index_uni = DUMMY_VAR__;
      current_statement__ = 29;
      index_uni = in__.template read<local_scalar_t__>();
      local_scalar_t__ bernoulli_logit_glm_lpmf = DUMMY_VAR__;
      current_statement__ = 30;
      bernoulli_logit_glm_lpmf = in__.template read<local_scalar_t__>();
      local_scalar_t__ reduce_sum = DUMMY_VAR__;
      current_statement__ = 31;
      reduce_sum = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> segment =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(4, DUMMY_VAR__);
      current_statement__ = 32;
      segment = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(4);
      local_scalar_t__ ode_bdf = DUMMY_VAR__;
      current_statement__ = 33;
      ode_bdf = in__.template read<local_scalar_t__>();
      local_scalar_t__ ode_bdf_tol = DUMMY_VAR__;
      current_statement__ = 34;
      ode_bdf_tol = in__.template read<local_scalar_t__>();
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 38;
      mu = ((((((((stan::math::e() + stan::math::pi()) + stan::math::log2())
        + stan::math::log10()) + stan::math::sqrt2()) +
        stan::math::not_a_number()) + stan::math::positive_infinity()) +
        stan::math::negative_infinity()) + stan::math::machine_precision());
      current_statement__ = 39;
      mu = (mu + ((logit + bernoulli_logit_glm_lpmf) + reduce_sum));
      current_statement__ = 40;
      mu = (mu + ((inv_logit * stan::math::inv_logit(0.5)) + (logit *
        stan::math::logit(10))));
      current_statement__ = 41;
      mu = (mu + (pow * stan::math::pow(3, 2)));
      current_statement__ = 42;
      mu = ((add + add) - sub);
      current_statement__ = 43;
      mu = (mu + ((lchoose * stan::math::binomial_coefficient_log(3, 4)) *
        binomial_coefficient_log));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> called =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(1,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(4, DUMMY_VAR__));
      current_statement__ = 36;
      stan::model::assign(called,
        stan::math::ode_bdf(rhs_variadic2_functor__(), segment, 1.0,
          std::vector<double>{3.0}, pstream__, 3.5),
        "assigning variable called");
      Eigen::Matrix<local_scalar_t__,-1,1> result =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(result_1dim__,
          DUMMY_VAR__);
      current_statement__ = 37;
      stan::model::assign(result, stan::math::multiply(x, 5.0),
        "assigning variable result");
      current_statement__ = 45;
      {
        stan::math::profile<local_scalar_t__> profile__("shadow-1",
          const_cast<stan::math::profile_map&>(profiles__));
        current_statement__ = 44;
        mu = (mu + profile_map);
      }
      {
        current_statement__ = 46;
        if (pstream__) {
          stan::math::stan_print(pstream__, "hello world");
          *(pstream__) << std::endl;
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "shadowing_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double e = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      e = in__.template read<local_scalar_t__>();
      double pi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      pi = in__.template read<local_scalar_t__>();
      double log2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      log2 = in__.template read<local_scalar_t__>();
      double log10 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      log10 = in__.template read<local_scalar_t__>();
      double sqrt2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      sqrt2 = in__.template read<local_scalar_t__>();
      double not_a_number = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 6;
      not_a_number = in__.template read<local_scalar_t__>();
      double positive_infinity = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 7;
      positive_infinity = in__.template read<local_scalar_t__>();
      double negative_infinity = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 8;
      negative_infinity = in__.template read<local_scalar_t__>();
      double machine_precision = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 9;
      machine_precision = in__.template read<local_scalar_t__>();
      double inv_logit = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 10;
      inv_logit = in__.template read<local_scalar_t__>();
      double logit = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 11;
      logit = in__.template read<local_scalar_t__>();
      double num_elements = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 12;
      num_elements = in__.template read<local_scalar_t__>();
      double pow = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 13;
      pow = in__.template read<local_scalar_t__>();
      double add = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 14;
      add = in__.template read<local_scalar_t__>();
      double sub = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 15;
      sub = in__.template read<local_scalar_t__>();
      double multiply = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 16;
      multiply = in__.template read<local_scalar_t__>();
      double lchoose = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 17;
      lchoose = in__.template read<local_scalar_t__>();
      double binomial_coefficient_log =
        std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 18;
      binomial_coefficient_log = in__.template read<local_scalar_t__>();
      double read_constrain_lb = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 19;
      read_constrain_lb = in__.template read_constrain_lb<local_scalar_t__,
                            jacobian__>(0, lp__);
      double read = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 20;
      read = in__.template read<local_scalar_t__>();
      double validate_non_negative_index =
        std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 21;
      validate_non_negative_index = in__.template read<local_scalar_t__>();
      double length = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 22;
      length = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,1> validate_positive_index =
        Eigen::Matrix<double,-1,1>::Constant(5,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 23;
      validate_positive_index = in__.template read_constrain_simplex<
                                  Eigen::Matrix<local_scalar_t__,-1,1>,
                                  jacobian__>(lp__, 5);
      double profile_map = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 24;
      profile_map = in__.template read<local_scalar_t__>();
      double assign = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 25;
      assign = in__.template read<local_scalar_t__>();
      double rvalue = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 26;
      rvalue = in__.template read<local_scalar_t__>();
      double stan_print = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 27;
      stan_print = in__.template read<local_scalar_t__>();
      double model_base_crtp = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 28;
      model_base_crtp = in__.template read<local_scalar_t__>();
      double index_uni = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 29;
      index_uni = in__.template read<local_scalar_t__>();
      double bernoulli_logit_glm_lpmf =
        std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 30;
      bernoulli_logit_glm_lpmf = in__.template read<local_scalar_t__>();
      double reduce_sum = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 31;
      reduce_sum = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,1> segment =
        Eigen::Matrix<double,-1,1>::Constant(4,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 32;
      segment = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(4);
      double ode_bdf = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 33;
      ode_bdf = in__.template read<local_scalar_t__>();
      double ode_bdf_tol = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 34;
      ode_bdf_tol = in__.template read<local_scalar_t__>();
      double mu = std::numeric_limits<double>::quiet_NaN();
      std::vector<Eigen::Matrix<double,-1,1>> called =
        std::vector<Eigen::Matrix<double,-1,1>>(1,
          Eigen::Matrix<double,-1,1>::Constant(4,
            std::numeric_limits<double>::quiet_NaN()));
      Eigen::Matrix<double,-1,1> result =
        Eigen::Matrix<double,-1,1>::Constant(result_1dim__,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(e);
      out__.write(pi);
      out__.write(log2);
      out__.write(log10);
      out__.write(sqrt2);
      out__.write(not_a_number);
      out__.write(positive_infinity);
      out__.write(negative_infinity);
      out__.write(machine_precision);
      out__.write(inv_logit);
      out__.write(logit);
      out__.write(num_elements);
      out__.write(pow);
      out__.write(add);
      out__.write(sub);
      out__.write(multiply);
      out__.write(lchoose);
      out__.write(binomial_coefficient_log);
      out__.write(read_constrain_lb);
      out__.write(read);
      out__.write(validate_non_negative_index);
      out__.write(length);
      out__.write(validate_positive_index);
      out__.write(profile_map);
      out__.write(assign);
      out__.write(rvalue);
      out__.write(stan_print);
      out__.write(model_base_crtp);
      out__.write(index_uni);
      out__.write(bernoulli_logit_glm_lpmf);
      out__.write(reduce_sum);
      out__.write(segment);
      out__.write(ode_bdf);
      out__.write(ode_bdf_tol);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 38;
      mu = ((((((((stan::math::e() + stan::math::pi()) + stan::math::log2())
        + stan::math::log10()) + stan::math::sqrt2()) +
        stan::math::not_a_number()) + stan::math::positive_infinity()) +
        stan::math::negative_infinity()) + stan::math::machine_precision());
      current_statement__ = 39;
      mu = (mu + ((logit + bernoulli_logit_glm_lpmf) + reduce_sum));
      current_statement__ = 40;
      mu = (mu + ((inv_logit * stan::math::inv_logit(0.5)) + (logit *
        stan::math::logit(10))));
      current_statement__ = 41;
      mu = (mu + (pow * stan::math::pow(3, 2)));
      current_statement__ = 42;
      mu = ((add + add) - sub);
      current_statement__ = 43;
      mu = (mu + ((lchoose * stan::math::binomial_coefficient_log(3, 4)) *
        binomial_coefficient_log));
      current_statement__ = 36;
      stan::model::assign(called,
        stan::math::ode_bdf(rhs_variadic2_functor__(), segment, 1.0,
          std::vector<double>{3.0}, pstream__, 3.5),
        "assigning variable called");
      current_statement__ = 37;
      stan::model::assign(result, stan::math::multiply(x, 5.0),
        "assigning variable result");
      current_statement__ = 45;
      {
        stan::math::profile<local_scalar_t__> profile__("shadow-1",
          const_cast<stan::math::profile_map&>(profiles__));
        current_statement__ = 44;
        mu = (mu + profile_map);
      }
      if (emit_transformed_parameters__) {
        out__.write(mu);
        current_statement__ = 36;
        for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
            out__.write(called[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        out__.write(result);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ e = DUMMY_VAR__;
      current_statement__ = 1;
      e = in__.read<local_scalar_t__>();
      out__.write(e);
      local_scalar_t__ pi = DUMMY_VAR__;
      current_statement__ = 2;
      pi = in__.read<local_scalar_t__>();
      out__.write(pi);
      local_scalar_t__ log2 = DUMMY_VAR__;
      current_statement__ = 3;
      log2 = in__.read<local_scalar_t__>();
      out__.write(log2);
      local_scalar_t__ log10 = DUMMY_VAR__;
      current_statement__ = 4;
      log10 = in__.read<local_scalar_t__>();
      out__.write(log10);
      local_scalar_t__ sqrt2 = DUMMY_VAR__;
      current_statement__ = 5;
      sqrt2 = in__.read<local_scalar_t__>();
      out__.write(sqrt2);
      local_scalar_t__ not_a_number = DUMMY_VAR__;
      current_statement__ = 6;
      not_a_number = in__.read<local_scalar_t__>();
      out__.write(not_a_number);
      local_scalar_t__ positive_infinity = DUMMY_VAR__;
      current_statement__ = 7;
      positive_infinity = in__.read<local_scalar_t__>();
      out__.write(positive_infinity);
      local_scalar_t__ negative_infinity = DUMMY_VAR__;
      current_statement__ = 8;
      negative_infinity = in__.read<local_scalar_t__>();
      out__.write(negative_infinity);
      local_scalar_t__ machine_precision = DUMMY_VAR__;
      current_statement__ = 9;
      machine_precision = in__.read<local_scalar_t__>();
      out__.write(machine_precision);
      local_scalar_t__ inv_logit = DUMMY_VAR__;
      current_statement__ = 10;
      inv_logit = in__.read<local_scalar_t__>();
      out__.write(inv_logit);
      local_scalar_t__ logit = DUMMY_VAR__;
      current_statement__ = 11;
      logit = in__.read<local_scalar_t__>();
      out__.write(logit);
      local_scalar_t__ num_elements = DUMMY_VAR__;
      current_statement__ = 12;
      num_elements = in__.read<local_scalar_t__>();
      out__.write(num_elements);
      local_scalar_t__ pow = DUMMY_VAR__;
      current_statement__ = 13;
      pow = in__.read<local_scalar_t__>();
      out__.write(pow);
      local_scalar_t__ add = DUMMY_VAR__;
      current_statement__ = 14;
      add = in__.read<local_scalar_t__>();
      out__.write(add);
      local_scalar_t__ sub = DUMMY_VAR__;
      current_statement__ = 15;
      sub = in__.read<local_scalar_t__>();
      out__.write(sub);
      local_scalar_t__ multiply = DUMMY_VAR__;
      current_statement__ = 16;
      multiply = in__.read<local_scalar_t__>();
      out__.write(multiply);
      local_scalar_t__ lchoose = DUMMY_VAR__;
      current_statement__ = 17;
      lchoose = in__.read<local_scalar_t__>();
      out__.write(lchoose);
      local_scalar_t__ binomial_coefficient_log = DUMMY_VAR__;
      current_statement__ = 18;
      binomial_coefficient_log = in__.read<local_scalar_t__>();
      out__.write(binomial_coefficient_log);
      local_scalar_t__ read_constrain_lb = DUMMY_VAR__;
      current_statement__ = 19;
      read_constrain_lb = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, read_constrain_lb);
      local_scalar_t__ read = DUMMY_VAR__;
      current_statement__ = 20;
      read = in__.read<local_scalar_t__>();
      out__.write(read);
      local_scalar_t__ validate_non_negative_index = DUMMY_VAR__;
      current_statement__ = 21;
      validate_non_negative_index = in__.read<local_scalar_t__>();
      out__.write(validate_non_negative_index);
      local_scalar_t__ length = DUMMY_VAR__;
      current_statement__ = 22;
      length = in__.read<local_scalar_t__>();
      out__.write(length);
      Eigen::Matrix<local_scalar_t__,-1,1> validate_positive_index =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(5, DUMMY_VAR__);
      current_statement__ = 23;
      stan::model::assign(validate_positive_index,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(5),
        "assigning variable validate_positive_index");
      out__.write_free_simplex(validate_positive_index);
      local_scalar_t__ profile_map = DUMMY_VAR__;
      current_statement__ = 24;
      profile_map = in__.read<local_scalar_t__>();
      out__.write(profile_map);
      local_scalar_t__ assign = DUMMY_VAR__;
      current_statement__ = 25;
      assign = in__.read<local_scalar_t__>();
      out__.write(assign);
      local_scalar_t__ rvalue = DUMMY_VAR__;
      current_statement__ = 26;
      rvalue = in__.read<local_scalar_t__>();
      out__.write(rvalue);
      local_scalar_t__ stan_print = DUMMY_VAR__;
      current_statement__ = 27;
      stan_print = in__.read<local_scalar_t__>();
      out__.write(stan_print);
      local_scalar_t__ model_base_crtp = DUMMY_VAR__;
      current_statement__ = 28;
      model_base_crtp = in__.read<local_scalar_t__>();
      out__.write(model_base_crtp);
      local_scalar_t__ index_uni = DUMMY_VAR__;
      current_statement__ = 29;
      index_uni = in__.read<local_scalar_t__>();
      out__.write(index_uni);
      local_scalar_t__ bernoulli_logit_glm_lpmf = DUMMY_VAR__;
      current_statement__ = 30;
      bernoulli_logit_glm_lpmf = in__.read<local_scalar_t__>();
      out__.write(bernoulli_logit_glm_lpmf);
      local_scalar_t__ reduce_sum = DUMMY_VAR__;
      current_statement__ = 31;
      reduce_sum = in__.read<local_scalar_t__>();
      out__.write(reduce_sum);
      Eigen::Matrix<local_scalar_t__,-1,1> segment =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(4, DUMMY_VAR__);
      current_statement__ = 32;
      stan::model::assign(segment,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(4),
        "assigning variable segment");
      out__.write(segment);
      local_scalar_t__ ode_bdf = DUMMY_VAR__;
      current_statement__ = 33;
      ode_bdf = in__.read<local_scalar_t__>();
      out__.write(ode_bdf);
      local_scalar_t__ ode_bdf_tol = DUMMY_VAR__;
      current_statement__ = 34;
      ode_bdf_tol = in__.read<local_scalar_t__>();
      out__.write(ode_bdf_tol);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "e", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "pi", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "log2", "double",
        std::vector<size_t>{});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "log10", "double",
        std::vector<size_t>{});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "sqrt2", "double",
        std::vector<size_t>{});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "not_a_number",
        "double", std::vector<size_t>{});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization",
        "positive_infinity", "double", std::vector<size_t>{});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization",
        "negative_infinity", "double", std::vector<size_t>{});
      current_statement__ = 9;
      context__.validate_dims("parameter initialization",
        "machine_precision", "double", std::vector<size_t>{});
      current_statement__ = 10;
      context__.validate_dims("parameter initialization", "inv_logit",
        "double", std::vector<size_t>{});
      current_statement__ = 11;
      context__.validate_dims("parameter initialization", "logit", "double",
        std::vector<size_t>{});
      current_statement__ = 12;
      context__.validate_dims("parameter initialization", "num_elements",
        "double", std::vector<size_t>{});
      current_statement__ = 13;
      context__.validate_dims("parameter initialization", "pow", "double",
        std::vector<size_t>{});
      current_statement__ = 14;
      context__.validate_dims("parameter initialization", "add", "double",
        std::vector<size_t>{});
      current_statement__ = 15;
      context__.validate_dims("parameter initialization", "sub", "double",
        std::vector<size_t>{});
      current_statement__ = 16;
      context__.validate_dims("parameter initialization", "multiply",
        "double", std::vector<size_t>{});
      current_statement__ = 17;
      context__.validate_dims("parameter initialization", "lchoose",
        "double", std::vector<size_t>{});
      current_statement__ = 18;
      context__.validate_dims("parameter initialization",
        "binomial_coefficient_log", "double", std::vector<size_t>{});
      current_statement__ = 19;
      context__.validate_dims("parameter initialization",
        "read_constrain_lb", "double", std::vector<size_t>{});
      current_statement__ = 20;
      context__.validate_dims("parameter initialization", "read", "double",
        std::vector<size_t>{});
      current_statement__ = 21;
      context__.validate_dims("parameter initialization",
        "validate_non_negative_index", "double", std::vector<size_t>{});
      current_statement__ = 22;
      context__.validate_dims("parameter initialization", "length", "double",
        std::vector<size_t>{});
      current_statement__ = 23;
      context__.validate_dims("parameter initialization",
        "validate_positive_index", "double",
        std::vector<size_t>{static_cast<size_t>(5)});
      current_statement__ = 24;
      context__.validate_dims("parameter initialization", "profile_map",
        "double", std::vector<size_t>{});
      current_statement__ = 25;
      context__.validate_dims("parameter initialization", "assign", "double",
        std::vector<size_t>{});
      current_statement__ = 26;
      context__.validate_dims("parameter initialization", "rvalue", "double",
        std::vector<size_t>{});
      current_statement__ = 27;
      context__.validate_dims("parameter initialization", "stan_print",
        "double", std::vector<size_t>{});
      current_statement__ = 28;
      context__.validate_dims("parameter initialization", "model_base_crtp",
        "double", std::vector<size_t>{});
      current_statement__ = 29;
      context__.validate_dims("parameter initialization", "index_uni",
        "double", std::vector<size_t>{});
      current_statement__ = 30;
      context__.validate_dims("parameter initialization",
        "bernoulli_logit_glm_lpmf", "double", std::vector<size_t>{});
      current_statement__ = 31;
      context__.validate_dims("parameter initialization", "reduce_sum",
        "double", std::vector<size_t>{});
      current_statement__ = 32;
      context__.validate_dims("parameter initialization", "segment",
        "double", std::vector<size_t>{static_cast<size_t>(4)});
      current_statement__ = 33;
      context__.validate_dims("parameter initialization", "ode_bdf",
        "double", std::vector<size_t>{});
      current_statement__ = 34;
      context__.validate_dims("parameter initialization", "ode_bdf_tol",
        "double", std::vector<size_t>{});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ e = DUMMY_VAR__;
      current_statement__ = 1;
      e = context__.vals_r("e")[(1 - 1)];
      out__.write(e);
      local_scalar_t__ pi = DUMMY_VAR__;
      current_statement__ = 2;
      pi = context__.vals_r("pi")[(1 - 1)];
      out__.write(pi);
      local_scalar_t__ log2 = DUMMY_VAR__;
      current_statement__ = 3;
      log2 = context__.vals_r("log2")[(1 - 1)];
      out__.write(log2);
      local_scalar_t__ log10 = DUMMY_VAR__;
      current_statement__ = 4;
      log10 = context__.vals_r("log10")[(1 - 1)];
      out__.write(log10);
      local_scalar_t__ sqrt2 = DUMMY_VAR__;
      current_statement__ = 5;
      sqrt2 = context__.vals_r("sqrt2")[(1 - 1)];
      out__.write(sqrt2);
      local_scalar_t__ not_a_number = DUMMY_VAR__;
      current_statement__ = 6;
      not_a_number = context__.vals_r("not_a_number")[(1 - 1)];
      out__.write(not_a_number);
      local_scalar_t__ positive_infinity = DUMMY_VAR__;
      current_statement__ = 7;
      positive_infinity = context__.vals_r("positive_infinity")[(1 - 1)];
      out__.write(positive_infinity);
      local_scalar_t__ negative_infinity = DUMMY_VAR__;
      current_statement__ = 8;
      negative_infinity = context__.vals_r("negative_infinity")[(1 - 1)];
      out__.write(negative_infinity);
      local_scalar_t__ machine_precision = DUMMY_VAR__;
      current_statement__ = 9;
      machine_precision = context__.vals_r("machine_precision")[(1 - 1)];
      out__.write(machine_precision);
      local_scalar_t__ inv_logit = DUMMY_VAR__;
      current_statement__ = 10;
      inv_logit = context__.vals_r("inv_logit")[(1 - 1)];
      out__.write(inv_logit);
      local_scalar_t__ logit = DUMMY_VAR__;
      current_statement__ = 11;
      logit = context__.vals_r("logit")[(1 - 1)];
      out__.write(logit);
      local_scalar_t__ num_elements = DUMMY_VAR__;
      current_statement__ = 12;
      num_elements = context__.vals_r("num_elements")[(1 - 1)];
      out__.write(num_elements);
      local_scalar_t__ pow = DUMMY_VAR__;
      current_statement__ = 13;
      pow = context__.vals_r("pow")[(1 - 1)];
      out__.write(pow);
      local_scalar_t__ add = DUMMY_VAR__;
      current_statement__ = 14;
      add = context__.vals_r("add")[(1 - 1)];
      out__.write(add);
      local_scalar_t__ sub = DUMMY_VAR__;
      current_statement__ = 15;
      sub = context__.vals_r("sub")[(1 - 1)];
      out__.write(sub);
      local_scalar_t__ multiply = DUMMY_VAR__;
      current_statement__ = 16;
      multiply = context__.vals_r("multiply")[(1 - 1)];
      out__.write(multiply);
      local_scalar_t__ lchoose = DUMMY_VAR__;
      current_statement__ = 17;
      lchoose = context__.vals_r("lchoose")[(1 - 1)];
      out__.write(lchoose);
      local_scalar_t__ binomial_coefficient_log = DUMMY_VAR__;
      current_statement__ = 18;
      binomial_coefficient_log = context__.vals_r("binomial_coefficient_log")[(1
        - 1)];
      out__.write(binomial_coefficient_log);
      local_scalar_t__ read_constrain_lb = DUMMY_VAR__;
      current_statement__ = 19;
      read_constrain_lb = context__.vals_r("read_constrain_lb")[(1 - 1)];
      out__.write_free_lb(0, read_constrain_lb);
      local_scalar_t__ read = DUMMY_VAR__;
      current_statement__ = 20;
      read = context__.vals_r("read")[(1 - 1)];
      out__.write(read);
      local_scalar_t__ validate_non_negative_index = DUMMY_VAR__;
      current_statement__ = 21;
      validate_non_negative_index = context__.vals_r("validate_non_negative_index")[(1
        - 1)];
      out__.write(validate_non_negative_index);
      local_scalar_t__ length = DUMMY_VAR__;
      current_statement__ = 22;
      length = context__.vals_r("length")[(1 - 1)];
      out__.write(length);
      Eigen::Matrix<local_scalar_t__,-1,1> validate_positive_index =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(5, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> validate_positive_index_flat__;
        current_statement__ = 23;
        validate_positive_index_flat__ = context__.vals_r("validate_positive_index");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
          stan::model::assign(validate_positive_index,
            validate_positive_index_flat__[(pos__ - 1)],
            "assigning variable validate_positive_index",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_simplex(validate_positive_index);
      local_scalar_t__ profile_map = DUMMY_VAR__;
      current_statement__ = 24;
      profile_map = context__.vals_r("profile_map")[(1 - 1)];
      out__.write(profile_map);
      local_scalar_t__ assign = DUMMY_VAR__;
      current_statement__ = 25;
      assign = context__.vals_r("assign")[(1 - 1)];
      out__.write(assign);
      local_scalar_t__ rvalue = DUMMY_VAR__;
      current_statement__ = 26;
      rvalue = context__.vals_r("rvalue")[(1 - 1)];
      out__.write(rvalue);
      local_scalar_t__ stan_print = DUMMY_VAR__;
      current_statement__ = 27;
      stan_print = context__.vals_r("stan_print")[(1 - 1)];
      out__.write(stan_print);
      local_scalar_t__ model_base_crtp = DUMMY_VAR__;
      current_statement__ = 28;
      model_base_crtp = context__.vals_r("model_base_crtp")[(1 - 1)];
      out__.write(model_base_crtp);
      local_scalar_t__ index_uni = DUMMY_VAR__;
      current_statement__ = 29;
      index_uni = context__.vals_r("index_uni")[(1 - 1)];
      out__.write(index_uni);
      local_scalar_t__ bernoulli_logit_glm_lpmf = DUMMY_VAR__;
      current_statement__ = 30;
      bernoulli_logit_glm_lpmf = context__.vals_r("bernoulli_logit_glm_lpmf")[(1
        - 1)];
      out__.write(bernoulli_logit_glm_lpmf);
      local_scalar_t__ reduce_sum = DUMMY_VAR__;
      current_statement__ = 31;
      reduce_sum = context__.vals_r("reduce_sum")[(1 - 1)];
      out__.write(reduce_sum);
      Eigen::Matrix<local_scalar_t__,-1,1> segment =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(4, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> segment_flat__;
        current_statement__ = 32;
        segment_flat__ = context__.vals_r("segment");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
          stan::model::assign(segment, segment_flat__[(pos__ - 1)],
            "assigning variable segment", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(segment);
      local_scalar_t__ ode_bdf = DUMMY_VAR__;
      current_statement__ = 33;
      ode_bdf = context__.vals_r("ode_bdf")[(1 - 1)];
      out__.write(ode_bdf);
      local_scalar_t__ ode_bdf_tol = DUMMY_VAR__;
      current_statement__ = 34;
      ode_bdf_tol = context__.vals_r("ode_bdf_tol")[(1 - 1)];
      out__.write(ode_bdf_tol);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"e", "pi", "log2", "log10", "sqrt2",
                "not_a_number", "positive_infinity", "negative_infinity",
                "machine_precision", "inv_logit", "logit", "num_elements",
                "pow", "add", "sub", "multiply", "lchoose",
                "binomial_coefficient_log", "read_constrain_lb", "read",
                "validate_non_negative_index", "length",
                "validate_positive_index", "profile_map", "assign", "rvalue",
                "stan_print", "model_base_crtp", "index_uni",
                "bernoulli_logit_glm_lpmf", "reduce_sum", "segment",
                "ode_bdf", "ode_bdf_tol"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"mu", "called", "result"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(5)},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(4)},
                std::vector<size_t>{}, std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(1),
               static_cast<size_t>(4)},
             std::vector<size_t>{static_cast<size_t>(result_1dim__)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "e");
    param_names__.emplace_back(std::string() + "pi");
    param_names__.emplace_back(std::string() + "log2");
    param_names__.emplace_back(std::string() + "log10");
    param_names__.emplace_back(std::string() + "sqrt2");
    param_names__.emplace_back(std::string() + "not_a_number");
    param_names__.emplace_back(std::string() + "positive_infinity");
    param_names__.emplace_back(std::string() + "negative_infinity");
    param_names__.emplace_back(std::string() + "machine_precision");
    param_names__.emplace_back(std::string() + "inv_logit");
    param_names__.emplace_back(std::string() + "logit");
    param_names__.emplace_back(std::string() + "num_elements");
    param_names__.emplace_back(std::string() + "pow");
    param_names__.emplace_back(std::string() + "add");
    param_names__.emplace_back(std::string() + "sub");
    param_names__.emplace_back(std::string() + "multiply");
    param_names__.emplace_back(std::string() + "lchoose");
    param_names__.emplace_back(std::string() + "binomial_coefficient_log");
    param_names__.emplace_back(std::string() + "read_constrain_lb");
    param_names__.emplace_back(std::string() + "read");
    param_names__.emplace_back(std::string() + "validate_non_negative_index");
    param_names__.emplace_back(std::string() + "length");
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      param_names__.emplace_back(std::string() + "validate_positive_index" +
        '.' + std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "profile_map");
    param_names__.emplace_back(std::string() + "assign");
    param_names__.emplace_back(std::string() + "rvalue");
    param_names__.emplace_back(std::string() + "stan_print");
    param_names__.emplace_back(std::string() + "model_base_crtp");
    param_names__.emplace_back(std::string() + "index_uni");
    param_names__.emplace_back(std::string() + "bernoulli_logit_glm_lpmf");
    param_names__.emplace_back(std::string() + "reduce_sum");
    for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
      param_names__.emplace_back(std::string() + "segment" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "ode_bdf");
    param_names__.emplace_back(std::string() + "ode_bdf_tol");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "mu");
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
          param_names__.emplace_back(std::string() + "called" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= result_1dim__; ++sym1__) {
        param_names__.emplace_back(std::string() + "result" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "e");
    param_names__.emplace_back(std::string() + "pi");
    param_names__.emplace_back(std::string() + "log2");
    param_names__.emplace_back(std::string() + "log10");
    param_names__.emplace_back(std::string() + "sqrt2");
    param_names__.emplace_back(std::string() + "not_a_number");
    param_names__.emplace_back(std::string() + "positive_infinity");
    param_names__.emplace_back(std::string() + "negative_infinity");
    param_names__.emplace_back(std::string() + "machine_precision");
    param_names__.emplace_back(std::string() + "inv_logit");
    param_names__.emplace_back(std::string() + "logit");
    param_names__.emplace_back(std::string() + "num_elements");
    param_names__.emplace_back(std::string() + "pow");
    param_names__.emplace_back(std::string() + "add");
    param_names__.emplace_back(std::string() + "sub");
    param_names__.emplace_back(std::string() + "multiply");
    param_names__.emplace_back(std::string() + "lchoose");
    param_names__.emplace_back(std::string() + "binomial_coefficient_log");
    param_names__.emplace_back(std::string() + "read_constrain_lb");
    param_names__.emplace_back(std::string() + "read");
    param_names__.emplace_back(std::string() + "validate_non_negative_index");
    param_names__.emplace_back(std::string() + "length");
    for (int sym1__ = 1; sym1__ <= (5 - 1); ++sym1__) {
      param_names__.emplace_back(std::string() + "validate_positive_index" +
        '.' + std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "profile_map");
    param_names__.emplace_back(std::string() + "assign");
    param_names__.emplace_back(std::string() + "rvalue");
    param_names__.emplace_back(std::string() + "stan_print");
    param_names__.emplace_back(std::string() + "model_base_crtp");
    param_names__.emplace_back(std::string() + "index_uni");
    param_names__.emplace_back(std::string() + "bernoulli_logit_glm_lpmf");
    param_names__.emplace_back(std::string() + "reduce_sum");
    for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
      param_names__.emplace_back(std::string() + "segment" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "ode_bdf");
    param_names__.emplace_back(std::string() + "ode_bdf_tol");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "mu");
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
          param_names__.emplace_back(std::string() + "called" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= result_1dim__; ++sym1__) {
        param_names__.emplace_back(std::string() + "result" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"e\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"pi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"log2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"log10\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sqrt2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"not_a_number\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"positive_infinity\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"negative_infinity\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"machine_precision\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"inv_logit\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"logit\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"num_elements\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"pow\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"add\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sub\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"multiply\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"lchoose\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"binomial_coefficient_log\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"read_constrain_lb\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"read\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"validate_non_negative_index\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"length\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"validate_positive_index\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"parameters\"},{\"name\":\"profile_map\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"assign\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"rvalue\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"stan_print\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"model_base_crtp\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"index_uni\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"bernoulli_logit_glm_lpmf\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"reduce_sum\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"segment\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(4) + "},\"block\":\"parameters\"},{\"name\":\"ode_bdf\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"ode_bdf_tol\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"called\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(1) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(4) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"result\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(result_1dim__) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"e\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"pi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"log2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"log10\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sqrt2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"not_a_number\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"positive_infinity\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"negative_infinity\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"machine_precision\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"inv_logit\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"logit\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"num_elements\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"pow\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"add\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sub\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"multiply\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"lchoose\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"binomial_coefficient_log\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"read_constrain_lb\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"read\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"validate_non_negative_index\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"length\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"validate_positive_index\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((5 -1)) + "},\"block\":\"parameters\"},{\"name\":\"profile_map\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"assign\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"rvalue\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"stan_print\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"model_base_crtp\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"index_uni\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"bernoulli_logit_glm_lpmf\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"reduce_sum\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"segment\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(4) + "},\"block\":\"parameters\"},{\"name\":\"ode_bdf\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"ode_bdf_tol\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"called\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(1) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(4) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"result\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(result_1dim__) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((((((((((((((((((((((((((((1 + 1) + 1)
      + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
      1) + 1) + 1) + 1) + 1) + 5) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
      4) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * (((1 + (1 *
      4)) + result_1dim__));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((((((((((((((((((((((((((((1 + 1) + 1)
      + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
      1) + 1) + 1) + 1) + 1) + 5) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
      4) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * (((1 + (1 *
      4)) + result_1dim__));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = shadowing_model_namespace::shadowing_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return shadowing_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp single-argument-lpmf.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace single_argument_lpmf_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 13> locations_array__ =
  {" (found before start of program)",
  " (in 'single-argument-lpmf.stan', line 3, column 4 to column 14)",
  " (in 'single-argument-lpmf.stan', line 2, column 24 to line 4, column 3)",
  " (in 'single-argument-lpmf.stan', line 6, column 4 to column 14)",
  " (in 'single-argument-lpmf.stan', line 5, column 24 to line 7, column 3)",
  " (in 'single-argument-lpmf.stan', line 9, column 4 to column 14)",
  " (in 'single-argument-lpmf.stan', line 8, column 22 to line 10, column 3)",
  " (in 'single-argument-lpmf.stan', line 12, column 4 to column 14)",
  " (in 'single-argument-lpmf.stan', line 11, column 25 to line 13, column 3)",
  " (in 'single-argument-lpmf.stan', line 15, column 4 to column 14)",
  " (in 'single-argument-lpmf.stan', line 14, column 25 to line 16, column 3)",
  " (in 'single-argument-lpmf.stan', line 18, column 4 to column 14)",
  " (in 'single-argument-lpmf.stan', line 17, column 23 to line 19, column 3)"};
template <bool propto__, typename T0__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
double foo0_lpmf(const T0__& y, std::ostream* pstream__);
template <bool propto__, typename T0__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
double foo1_lpmf(const T0__& y, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
double
foo4_lp(const T0__& y, T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream*
        pstream__);
template <bool propto__, typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__> foo2_lpdf(const T0__& y, std::ostream* pstream__);
template <bool propto__, typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__> foo3_lpdf(const T0__& y, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__>
foo5_lp(const T0__& y, T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream*
        pstream__);
// real foo0_lpmf(int)
template <bool propto__, typename T0__,
          stan::require_all_t<std::is_integral<T0__>>*>
double foo0_lpmf(const T0__& y, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 1;
    return -(5);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo1_lpmf(int)
template <bool propto__, typename T0__,
          stan::require_all_t<std::is_integral<T0__>>*>
double foo1_lpmf(const T0__& y, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 3;
    return -(5);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo4_lp(int)
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__, stan::require_all_t<std::is_integral<T0__>>*>
double
foo4_lp(const T0__& y, T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream*
        pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 5;
    return -(5);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo2_lpdf(real)
template <bool propto__, typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__> foo2_lpdf(const T0__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 7;
    return -(5);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo3_lpdf(real)
template <bool propto__, typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__> foo3_lpdf(const T0__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 9;
    return -(5);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real foo5_lp(real)
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__>
foo5_lp(const T0__& y, T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream*
        pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 11;
    return -(5);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class single_argument_lpmf_model final : public model_base_crtp<single_argument_lpmf_model> {
 private:
  
 public:
  ~single_argument_lpmf_model() {}
  single_argument_lpmf_model(stan::io::var_context& context__, unsigned int
                             random_seed__ = 0, std::ostream*
                             pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "single_argument_lpmf_model_namespace::single_argument_lpmf_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "single_argument_lpmf_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "single_argument_lpmf_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "single_argument_lpmf_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "single_argument_lpmf_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = single_argument_lpmf_model_namespace::single_argument_lpmf_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return single_argument_lpmf_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp tilde-block.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace tilde_block_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 8> locations_array__ =
  {" (found before start of program)",
  " (in 'tilde-block.stan', line 5, column 4 to column 20)",
  " (in 'tilde-block.stan', line 11, column 8 to column 31)",
  " (in 'tilde-block.stan', line 11, column 27 to column 28)",
  " (in 'tilde-block.stan', line 8, column 4 to line 11, column 31)",
  " (in 'tilde-block.stan', line 9, column 8 to column 38)",
  " (in 'tilde-block.stan', line 9, column 34 to column 35)",
  " (in 'tilde-block.stan', line 2, column 4 to column 10)"};
class tilde_block_model final : public model_base_crtp<tilde_block_model> {
 private:
  int t;
 public:
  ~tilde_block_model() {}
  tilde_block_model(stan::io::var_context& context__, unsigned int
                    random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "tilde_block_model_namespace::tilde_block_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 7;
      context__.validate_dims("data initialization", "t", "int",
        std::vector<size_t>{});
      t = std::numeric_limits<int>::min();
      current_statement__ = 7;
      t = context__.vals_i("t")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1;
  }
  inline std::string model_name() const final {
    return "tilde_block_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "tilde_block_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      {
        current_statement__ = 4;
        if (t) {
          current_statement__ = 5;
          lp_accum__.add(stan::math::student_t_lpdf<propto__>(x, 10, 0, 1));
          current_statement__ = 6;
          if (stan::math::logical_lt(x, 0)) {
            current_statement__ = 6;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 6;
            lp_accum__.add(-(stan::math::student_t_lccdf(0, 10, 0, 1)));
          }
        } else {
          current_statement__ = 2;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(x, 0, 1));
          current_statement__ = 3;
          if (stan::math::logical_lt(x, 0)) {
            current_statement__ = 3;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 3;
            lp_accum__.add(-(stan::math::normal_lccdf(0, 0, 1)));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "tilde_block_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      {
        current_statement__ = 4;
        if (t) {
          current_statement__ = 5;
          lp_accum__.add(stan::math::student_t_lpdf<propto__>(x, 10, 0, 1));
          current_statement__ = 6;
          if (stan::math::logical_lt(x, 0)) {
            current_statement__ = 6;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 6;
            lp_accum__.add(-(stan::math::student_t_lccdf(0, 10, 0, 1)));
          }
        } else {
          current_statement__ = 2;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(x, 0, 1));
          current_statement__ = 3;
          if (stan::math::logical_lt(x, 0)) {
            current_statement__ = 3;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 3;
            lp_accum__.add(-(stan::math::normal_lccdf(0, 0, 1)));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "tilde_block_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double x = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      x = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      out__.write(x);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "x", "double",
        std::vector<size_t>{});
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = context__.vals_r("x")[(1 - 1)];
      out__.write_free_lb(0, x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"x"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = tilde_block_model_namespace::tilde_block_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return tilde_block_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp transform.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace transform_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 116> locations_array__ =
  {" (found before start of program)",
  " (in 'transform.stan', line 11, column 2 to column 36)",
  " (in 'transform.stan', line 12, column 2 to column 36)",
  " (in 'transform.stan', line 13, column 2 to column 52)",
  " (in 'transform.stan', line 14, column 2 to column 45)",
  " (in 'transform.stan', line 15, column 2 to column 45)",
  " (in 'transform.stan', line 16, column 2 to column 37)",
  " (in 'transform.stan', line 17, column 2 to column 41)",
  " (in 'transform.stan', line 18, column 2 to column 58)",
  " (in 'transform.stan', line 19, column 2 to column 45)",
  " (in 'transform.stan', line 20, column 2 to column 46)",
  " (in 'transform.stan', line 21, column 2 to column 49)",
  " (in 'transform.stan', line 22, column 2 to column 39)",
  " (in 'transform.stan', line 23, column 2 to column 39)",
  " (in 'transform.stan', line 24, column 2 to column 53)",
  " (in 'transform.stan', line 25, column 2 to column 43)",
  " (in 'transform.stan', line 26, column 2 to column 43)",
  " (in 'transform.stan', line 27, column 2 to column 33)",
  " (in 'transform.stan', line 28, column 2 to column 39)",
  " (in 'transform.stan', line 31, column 2 to column 43)",
  " (in 'transform.stan', line 32, column 2 to column 43)",
  " (in 'transform.stan', line 33, column 2 to column 59)",
  " (in 'transform.stan', line 34, column 2 to column 52)",
  " (in 'transform.stan', line 35, column 2 to column 52)",
  " (in 'transform.stan', line 36, column 2 to column 44)",
  " (in 'transform.stan', line 37, column 2 to column 48)",
  " (in 'transform.stan', line 38, column 2 to column 65)",
  " (in 'transform.stan', line 39, column 2 to column 52)",
  " (in 'transform.stan', line 40, column 2 to column 54)",
  " (in 'transform.stan', line 41, column 2 to column 57)",
  " (in 'transform.stan', line 42, column 2 to column 47)",
  " (in 'transform.stan', line 43, column 2 to column 47)",
  " (in 'transform.stan', line 44, column 2 to column 61)",
  " (in 'transform.stan', line 45, column 2 to column 51)",
  " (in 'transform.stan', line 46, column 2 to column 51)",
  " (in 'transform.stan', line 47, column 2 to column 41)",
  " (in 'transform.stan', line 48, column 2 to column 47)",
  " (in 'transform.stan', line 2, column 2 to column 17)",
  " (in 'transform.stan', line 3, column 2 to column 17)",
  " (in 'transform.stan', line 4, column 2 to column 17)",
  " (in 'transform.stan', line 5, column 8 to column 9)",
  " (in 'transform.stan', line 5, column 11 to column 12)",
  " (in 'transform.stan', line 5, column 14 to column 15)",
  " (in 'transform.stan', line 5, column 2 to column 25)",
  " (in 'transform.stan', line 6, column 8 to column 9)",
  " (in 'transform.stan', line 6, column 11 to column 12)",
  " (in 'transform.stan', line 6, column 21 to column 22)",
  " (in 'transform.stan', line 6, column 2 to column 27)",
  " (in 'transform.stan', line 7, column 8 to column 9)",
  " (in 'transform.stan', line 7, column 11 to column 12)",
  " (in 'transform.stan', line 7, column 25 to column 26)",
  " (in 'transform.stan', line 7, column 2 to column 31)",
  " (in 'transform.stan', line 8, column 8 to column 9)",
  " (in 'transform.stan', line 8, column 18 to column 19)",
  " (in 'transform.stan', line 8, column 21 to column 22)",
  " (in 'transform.stan', line 8, column 2 to column 27)",
  " (in 'transform.stan', line 11, column 8 to column 9)",
  " (in 'transform.stan', line 12, column 8 to column 9)",
  " (in 'transform.stan', line 13, column 8 to column 9)",
  " (in 'transform.stan', line 14, column 8 to column 9)",
  " (in 'transform.stan', line 15, column 8 to column 9)",
  " (in 'transform.stan', line 16, column 8 to column 9)",
  " (in 'transform.stan', line 17, column 8 to column 9)",
  " (in 'transform.stan', line 18, column 8 to column 9)",
  " (in 'transform.stan', line 19, column 8 to column 9)",
  " (in 'transform.stan', line 19, column 11 to column 12)",
  " (in 'transform.stan', line 20, column 8 to column 9)",
  " (in 'transform.stan', line 20, column 11 to column 12)",
  " (in 'transform.stan', line 20, column 14 to column 15)",
  " (in 'transform.stan', line 21, column 41 to column 42)",
  " (in 'transform.stan', line 22, column 8 to column 9)",
  " (in 'transform.stan', line 22, column 31 to column 32)",
  " (in 'transform.stan', line 23, column 8 to column 9)",
  " (in 'transform.stan', line 23, column 11 to column 12)",
  " (in 'transform.stan', line 23, column 31 to column 32)",
  " (in 'transform.stan', line 24, column 45 to column 46)",
  " (in 'transform.stan', line 25, column 8 to column 9)",
  " (in 'transform.stan', line 25, column 35 to column 36)",
  " (in 'transform.stan', line 26, column 8 to column 9)",
  " (in 'transform.stan', line 26, column 11 to column 12)",
  " (in 'transform.stan', line 26, column 35 to column 36)",
  " (in 'transform.stan', line 27, column 22 to column 23)",
  " (in 'transform.stan', line 27, column 25 to column 26)",
  " (in 'transform.stan', line 28, column 8 to column 9)",
  " (in 'transform.stan', line 28, column 28 to column 29)",
  " (in 'transform.stan', line 28, column 31 to column 32)",
  " (in 'transform.stan', line 31, column 8 to column 9)",
  " (in 'transform.stan', line 32, column 8 to column 9)",
  " (in 'transform.stan', line 33, column 8 to column 9)",
  " (in 'transform.stan', line 34, column 8 to column 9)",
  " (in 'transform.stan', line 35, column 8 to column 9)",
  " (in 'transform.stan', line 36, column 8 to column 9)",
  " (in 'transform.stan', line 37, column 8 to column 9)",
  " (in 'transform.stan', line 38, column 8 to column 9)",
  " (in 'transform.stan', line 39, column 8 to column 9)",
  " (in 'transform.stan', line 39, column 11 to column 12)",
  " (in 'transform.stan', line 40, column 8 to column 9)",
  " (in 'transform.stan', line 40, column 11 to column 12)",
  " (in 'transform.stan', line 40, column 14 to column 15)",
  " (in 'transform.stan', line 41, column 41 to column 42)",
  " (in 'transform.stan', line 42, column 8 to column 9)",
  " (in 'transform.stan', line 42, column 31 to column 32)",
  " (in 'transform.stan', line 43, column 8 to column 9)",
  " (in 'transform.stan', line 43, column 11 to column 12)",
  " (in 'transform.stan', line 43, column 31 to column 32)",
  " (in 'transform.stan', line 44, column 45 to column 46)",
  " (in 'transform.stan', line 45, column 8 to column 9)",
  " (in 'transform.stan', line 45, column 35 to column 36)",
  " (in 'transform.stan', line 46, column 8 to column 9)",
  " (in 'transform.stan', line 46, column 11 to column 12)",
  " (in 'transform.stan', line 46, column 35 to column 36)",
  " (in 'transform.stan', line 47, column 22 to column 23)",
  " (in 'transform.stan', line 47, column 25 to column 26)",
  " (in 'transform.stan', line 48, column 8 to column 9)",
  " (in 'transform.stan', line 48, column 28 to column 29)",
  " (in 'transform.stan', line 48, column 31 to column 32)"};
class transform_model final : public model_base_crtp<transform_model> {
 private:
  int n;
  int m;
  int k;
  std::vector<std::vector<std::vector<double>>> ds;
  std::vector<std::vector<Eigen::Matrix<double,-1,1>>> dv;
  std::vector<std::vector<Eigen::Matrix<double,1,-1>>> dr;
  std::vector<Eigen::Matrix<double,-1,-1>> dm;
 public:
  ~transform_model() {}
  transform_model(stan::io::var_context& context__, unsigned int
                  random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "transform_model_namespace::transform_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 37;
      context__.validate_dims("data initialization", "n", "int",
        std::vector<size_t>{});
      n = std::numeric_limits<int>::min();
      current_statement__ = 37;
      n = context__.vals_i("n")[(1 - 1)];
      current_statement__ = 37;
      stan::math::check_greater_or_equal(function__, "n", n, 1);
      current_statement__ = 38;
      context__.validate_dims("data initialization", "m", "int",
        std::vector<size_t>{});
      m = std::numeric_limits<int>::min();
      current_statement__ = 38;
      m = context__.vals_i("m")[(1 - 1)];
      current_statement__ = 38;
      stan::math::check_greater_or_equal(function__, "m", m, 1);
      current_statement__ = 39;
      context__.validate_dims("data initialization", "k", "int",
        std::vector<size_t>{});
      k = std::numeric_limits<int>::min();
      current_statement__ = 39;
      k = context__.vals_i("k")[(1 - 1)];
      current_statement__ = 39;
      stan::math::check_greater_or_equal(function__, "k", k, 1);
      current_statement__ = 40;
      stan::math::validate_non_negative_index("ds", "n", n);
      current_statement__ = 41;
      stan::math::validate_non_negative_index("ds", "m", m);
      current_statement__ = 42;
      stan::math::validate_non_negative_index("ds", "k", k);
      current_statement__ = 43;
      context__.validate_dims("data initialization", "ds", "double",
        std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m),
          static_cast<size_t>(k)});
      ds = std::vector<std::vector<std::vector<double>>>(n,
             std::vector<std::vector<double>>(m,
               std::vector<double>(k,
                 std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> ds_flat__;
        current_statement__ = 43;
        ds_flat__ = context__.vals_r("ds");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
              stan::model::assign(ds, ds_flat__[(pos__ - 1)],
                "assigning variable ds", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 44;
      stan::math::validate_non_negative_index("dv", "n", n);
      current_statement__ = 45;
      stan::math::validate_non_negative_index("dv", "m", m);
      current_statement__ = 46;
      stan::math::validate_non_negative_index("dv", "k", k);
      current_statement__ = 47;
      context__.validate_dims("data initialization", "dv", "double",
        std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m),
          static_cast<size_t>(k)});
      dv = std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(n,
             std::vector<Eigen::Matrix<double,-1,1>>(m,
               Eigen::Matrix<double,-1,1>::Constant(k,
                 std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> dv_flat__;
        current_statement__ = 47;
        dv_flat__ = context__.vals_r("dv");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
              stan::model::assign(dv, dv_flat__[(pos__ - 1)],
                "assigning variable dv", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 48;
      stan::math::validate_non_negative_index("dr", "n", n);
      current_statement__ = 49;
      stan::math::validate_non_negative_index("dr", "m", m);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("dr", "k", k);
      current_statement__ = 51;
      context__.validate_dims("data initialization", "dr", "double",
        std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m),
          static_cast<size_t>(k)});
      dr = std::vector<std::vector<Eigen::Matrix<double,1,-1>>>(n,
             std::vector<Eigen::Matrix<double,1,-1>>(m,
               Eigen::Matrix<double,1,-1>::Constant(k,
                 std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> dr_flat__;
        current_statement__ = 51;
        dr_flat__ = context__.vals_r("dr");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
              stan::model::assign(dr, dr_flat__[(pos__ - 1)],
                "assigning variable dr", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 52;
      stan::math::validate_non_negative_index("dm", "n", n);
      current_statement__ = 53;
      stan::math::validate_non_negative_index("dm", "m", m);
      current_statement__ = 54;
      stan::math::validate_non_negative_index("dm", "k", k);
      current_statement__ = 55;
      context__.validate_dims("data initialization", "dm", "double",
        std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m),
          static_cast<size_t>(k)});
      dm = std::vector<Eigen::Matrix<double,-1,-1>>(n,
             Eigen::Matrix<double,-1,-1>::Constant(m, k,
               std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> dm_flat__;
        current_statement__ = 55;
        dm_flat__ = context__.vals_r("dm");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
              stan::model::assign(dm, dm_flat__[(pos__ - 1)],
                "assigning variable dm", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 56;
      stan::math::validate_non_negative_index("p_1", "k", k);
      current_statement__ = 57;
      stan::math::validate_non_negative_index("p_2", "k", k);
      current_statement__ = 58;
      stan::math::validate_non_negative_index("p_3", "k", k);
      current_statement__ = 59;
      stan::math::validate_non_negative_index("p_4", "k", k);
      current_statement__ = 60;
      stan::math::validate_non_negative_index("p_5", "k", k);
      current_statement__ = 61;
      stan::math::validate_non_negative_index("p_6", "k", k);
      current_statement__ = 62;
      stan::math::validate_non_negative_index("p_7", "k", k);
      current_statement__ = 63;
      stan::math::validate_non_negative_index("p_8", "k", k);
      current_statement__ = 64;
      stan::math::validate_non_negative_index("p_9", "m", m);
      current_statement__ = 65;
      stan::math::validate_non_negative_index("p_9", "k", k);
      current_statement__ = 66;
      stan::math::validate_non_negative_index("p_10", "n", n);
      current_statement__ = 67;
      stan::math::validate_non_negative_index("p_10", "m", m);
      current_statement__ = 68;
      stan::math::validate_non_negative_index("p_10", "k", k);
      current_statement__ = 69;
      stan::math::validate_non_negative_index("pv_1", "k", k);
      current_statement__ = 70;
      stan::math::validate_non_negative_index("pv_2", "m", m);
      current_statement__ = 71;
      stan::math::validate_non_negative_index("pv_2", "k", k);
      current_statement__ = 72;
      stan::math::validate_non_negative_index("pv_3", "n", n);
      current_statement__ = 73;
      stan::math::validate_non_negative_index("pv_3", "m", m);
      current_statement__ = 74;
      stan::math::validate_non_negative_index("pv_3", "k", k);
      current_statement__ = 75;
      stan::math::validate_non_negative_index("pr_1", "k", k);
      current_statement__ = 76;
      stan::math::validate_non_negative_index("pr_2", "m", m);
      current_statement__ = 77;
      stan::math::validate_non_negative_index("pr_2", "k", k);
      current_statement__ = 78;
      stan::math::validate_non_negative_index("pr_3", "n", n);
      current_statement__ = 79;
      stan::math::validate_non_negative_index("pr_3", "m", m);
      current_statement__ = 80;
      stan::math::validate_non_negative_index("pr_3", "k", k);
      current_statement__ = 81;
      stan::math::validate_non_negative_index("pm_1", "m", m);
      current_statement__ = 82;
      stan::math::validate_non_negative_index("pm_1", "k", k);
      current_statement__ = 83;
      stan::math::validate_non_negative_index("pm_2", "n", n);
      current_statement__ = 84;
      stan::math::validate_non_negative_index("pm_2", "m", m);
      current_statement__ = 85;
      stan::math::validate_non_negative_index("pm_2", "k", k);
      current_statement__ = 86;
      stan::math::validate_non_negative_index("tp_1", "k", k);
      current_statement__ = 87;
      stan::math::validate_non_negative_index("tp_2", "k", k);
      current_statement__ = 88;
      stan::math::validate_non_negative_index("tp_3", "k", k);
      current_statement__ = 89;
      stan::math::validate_non_negative_index("tp_4", "k", k);
      current_statement__ = 90;
      stan::math::validate_non_negative_index("tp_5", "k", k);
      current_statement__ = 91;
      stan::math::validate_non_negative_index("tp_6", "k", k);
      current_statement__ = 92;
      stan::math::validate_non_negative_index("tp_7", "k", k);
      current_statement__ = 93;
      stan::math::validate_non_negative_index("tp_8", "k", k);
      current_statement__ = 94;
      stan::math::validate_non_negative_index("tp_9", "m", m);
      current_statement__ = 95;
      stan::math::validate_non_negative_index("tp_9", "k", k);
      current_statement__ = 96;
      stan::math::validate_non_negative_index("tp_10", "n", n);
      current_statement__ = 97;
      stan::math::validate_non_negative_index("tp_10", "m", m);
      current_statement__ = 98;
      stan::math::validate_non_negative_index("tp_10", "k", k);
      current_statement__ = 99;
      stan::math::validate_non_negative_index("tpv_1", "k", k);
      current_statement__ = 100;
      stan::math::validate_non_negative_index("tpv_2", "m", m);
      current_statement__ = 101;
      stan::math::validate_non_negative_index("tpv_2", "k", k);
      current_statement__ = 102;
      stan::math::validate_non_negative_index("tpv_3", "n", n);
      current_statement__ = 103;
      stan::math::validate_non_negative_index("tpv_3", "m", m);
      current_statement__ = 104;
      stan::math::validate_non_negative_index("tpv_3", "k", k);
      current_statement__ = 105;
      stan::math::validate_non_negative_index("tpr_1", "k", k);
      current_statement__ = 106;
      stan::math::validate_non_negative_index("tpr_2", "m", m);
      current_statement__ = 107;
      stan::math::validate_non_negative_index("tpr_2", "k", k);
      current_statement__ = 108;
      stan::math::validate_non_negative_index("tpr_3", "n", n);
      current_statement__ = 109;
      stan::math::validate_non_negative_index("tpr_3", "m", m);
      current_statement__ = 110;
      stan::math::validate_non_negative_index("tpr_3", "k", k);
      current_statement__ = 111;
      stan::math::validate_non_negative_index("tpm_1", "m", m);
      current_statement__ = 112;
      stan::math::validate_non_negative_index("tpm_1", "k", k);
      current_statement__ = 113;
      stan::math::validate_non_negative_index("tpm_2", "n", n);
      current_statement__ = 114;
      stan::math::validate_non_negative_index("tpm_2", "m", m);
      current_statement__ = 115;
      stan::math::validate_non_negative_index("tpm_2", "k", k);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = k + k + k + k + k + k + k + k + (m * k) + (n * (m * k))
      + k + (m * k) + (n * (m * k)) + k + (m * k) + (n * (m * k)) + (m * k) +
      (n * (m * k));
  }
  inline std::string model_name() const final {
    return "transform_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "transform_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<local_scalar_t__> p_1 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 1;
      p_1 = in__.template read_constrain_lb<std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), lp__, k);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "p_1", p_1, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> p_2 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 2;
      p_2 = in__.template read_constrain_ub<std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), lp__, k);
      current_statement__ = 2;
      stan::math::check_matching_dims("constraint", "p_2", p_2, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> p_3 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 3;
      p_3 = in__.template read_constrain_lub<std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)),
              stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
                stan::model::index_uni(2)), lp__, k);
      current_statement__ = 3;
      stan::math::check_matching_dims("constraint", "p_3", p_3, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 3;
      stan::math::check_matching_dims("constraint", "p_3", p_3, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<local_scalar_t__> p_4 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 4;
      p_4 = in__.template read_constrain_lub<std::vector<local_scalar_t__>,
              jacobian__>(0,
              stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
                stan::model::index_uni(2)), lp__, k);
      current_statement__ = 4;
      stan::math::check_matching_dims("constraint", "p_4", p_4, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<local_scalar_t__> p_5 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 5;
      p_5 = in__.template read_constrain_lub<std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), 1, lp__, k);
      current_statement__ = 5;
      stan::math::check_matching_dims("constraint", "p_5", p_5, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> p_6 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 6;
      p_6 = in__.template read_constrain_offset_multiplier<
              std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), 1, lp__, k);
      current_statement__ = 6;
      stan::math::check_matching_dims("constraint", "p_6", p_6, "offset",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> p_7 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 7;
      p_7 = in__.template read_constrain_offset_multiplier<
              std::vector<local_scalar_t__>, jacobian__>(0,
              stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
                stan::model::index_uni(1)), lp__, k);
      current_statement__ = 7;
      stan::math::check_matching_dims("constraint", "p_7", p_7, "multiplier",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> p_8 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 8;
      p_8 = in__.template read_constrain_offset_multiplier<
              std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)),
              stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
                stan::model::index_uni(2)), lp__, k);
      current_statement__ = 8;
      stan::math::check_matching_dims("constraint", "p_8", p_8, "offset",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 8;
      stan::math::check_matching_dims("constraint", "p_8", p_8, "multiplier",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<std::vector<local_scalar_t__>> p_9 =
        std::vector<std::vector<local_scalar_t__>>(m,
          std::vector<local_scalar_t__>(k, DUMMY_VAR__));
      current_statement__ = 9;
      p_9 = in__.template read_constrain_lub<
              std::vector<std::vector<local_scalar_t__>>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1)), 1, lp__, m, k);
      current_statement__ = 9;
      stan::math::check_matching_dims("constraint", "p_9", p_9, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1)));
      std::vector<std::vector<std::vector<local_scalar_t__>>> p_10 =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(n,
          std::vector<std::vector<local_scalar_t__>>(m,
            std::vector<local_scalar_t__>(k, DUMMY_VAR__)));
      current_statement__ = 10;
      p_10 = in__.template read_constrain_lub<
               std::vector<std::vector<std::vector<local_scalar_t__>>>,
               jacobian__>(0, ds, lp__, n, m, k);
      current_statement__ = 10;
      stan::math::check_matching_dims("constraint", "p_10", p_10, "upper", ds);
      Eigen::Matrix<local_scalar_t__,-1,1> pv_1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 11;
      pv_1 = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__,-1,1>,
               jacobian__>(stan::model::rvalue(dv, "dv",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)),
               stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
                 stan::model::index_uni(2)), lp__, k);
      current_statement__ = 11;
      stan::math::check_matching_dims("constraint", "pv_1", pv_1, "lower",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 11;
      stan::math::check_matching_dims("constraint", "pv_1", pv_1, "upper",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> pv_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(m,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__));
      current_statement__ = 12;
      pv_2 = in__.template read_constrain_lb<
               std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>,
               jacobian__>(stan::model::rvalue(dv, "dv",
                             stan::model::index_uni(1)), lp__, m, k);
      current_statement__ = 12;
      stan::math::check_matching_dims("constraint", "pv_2", pv_2, "lower",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1)));
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> pv_3 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(n,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(m,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__)));
      current_statement__ = 13;
      pv_3 = in__.template read_constrain_ub<
               std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>,
               jacobian__>(dv, lp__, n, m, k);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "pv_3", pv_3, "upper", dv);
      Eigen::Matrix<local_scalar_t__,1,-1> pr_1 =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 14;
      pr_1 = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__,1,-1>,
               jacobian__>(stan::model::rvalue(dr, "dr",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)),
               stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
                 stan::model::index_uni(2)), lp__, k);
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint", "pr_1", pr_1, "lower",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint", "pr_1", pr_1, "upper",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> pr_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(m,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__));
      current_statement__ = 15;
      pr_2 = in__.template read_constrain_lb<
               std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>,
               jacobian__>(stan::model::rvalue(dr, "dr",
                             stan::model::index_uni(1)), lp__, m, k);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "pr_2", pr_2, "lower",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1)));
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> pr_3 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(n,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(m,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__)));
      current_statement__ = 16;
      pr_3 = in__.template read_constrain_ub<
               std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>,
               jacobian__>(dr, lp__, n, m, k);
      current_statement__ = 16;
      stan::math::check_matching_dims("constraint", "pr_3", pr_3, "upper", dr);
      Eigen::Matrix<local_scalar_t__,-1,-1> pm_1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, k, DUMMY_VAR__);
      current_statement__ = 17;
      pm_1 = in__.template read_constrain_lb<
               Eigen::Matrix<local_scalar_t__,-1,-1>,
               jacobian__>(stan::model::rvalue(dm, "dm",
                             stan::model::index_uni(1)), lp__, m, k);
      current_statement__ = 17;
      stan::math::check_matching_dims("constraint", "pm_1", pm_1, "lower",
        stan::model::rvalue(dm, "dm", stan::model::index_uni(1)));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> pm_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(n,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, k, DUMMY_VAR__));
      current_statement__ = 18;
      pm_2 = in__.template read_constrain_ub<
               std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
               jacobian__>(dm, lp__, n, m, k);
      current_statement__ = 18;
      stan::math::check_matching_dims("constraint", "pm_2", pm_2, "upper", dm);
      std::vector<local_scalar_t__> tp_1 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 19;
      stan::model::assign(tp_1, p_1, "assigning variable tp_1");
      current_statement__ = 19;
      stan::math::check_matching_dims("constraint", "tp_1", tp_1, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> tp_2 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 20;
      stan::model::assign(tp_2, p_2, "assigning variable tp_2");
      current_statement__ = 20;
      stan::math::check_matching_dims("constraint", "tp_2", tp_2, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> tp_3 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 21;
      stan::model::assign(tp_3, p_3, "assigning variable tp_3");
      current_statement__ = 21;
      stan::math::check_matching_dims("constraint", "tp_3", tp_3, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 21;
      stan::math::check_matching_dims("constraint", "tp_3", tp_3, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<local_scalar_t__> tp_4 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 22;
      stan::model::assign(tp_4, p_4, "assigning variable tp_4");
      current_statement__ = 22;
      stan::math::check_matching_dims("constraint", "tp_4", tp_4, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<local_scalar_t__> tp_5 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 23;
      stan::model::assign(tp_5, p_5, "assigning variable tp_5");
      current_statement__ = 23;
      stan::math::check_matching_dims("constraint", "tp_5", tp_5, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> tp_6 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 24;
      stan::model::assign(tp_6, p_6, "assigning variable tp_6");
      current_statement__ = 24;
      stan::math::check_matching_dims("constraint", "tp_6", tp_6, "offset",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> tp_7 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 25;
      stan::model::assign(tp_7, p_7, "assigning variable tp_7");
      current_statement__ = 25;
      stan::math::check_matching_dims("constraint", "tp_7", tp_7,
        "multiplier",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> tp_8 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 26;
      stan::model::assign(tp_8, p_8, "assigning variable tp_8");
      current_statement__ = 26;
      stan::math::check_matching_dims("constraint", "tp_8", tp_8, "offset",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 26;
      stan::math::check_matching_dims("constraint", "tp_8", tp_8,
        "multiplier",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<std::vector<local_scalar_t__>> tp_9 =
        std::vector<std::vector<local_scalar_t__>>(m,
          std::vector<local_scalar_t__>(k, DUMMY_VAR__));
      current_statement__ = 27;
      stan::model::assign(tp_9, p_9, "assigning variable tp_9");
      current_statement__ = 27;
      stan::math::check_matching_dims("constraint", "tp_9", tp_9, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1)));
      std::vector<std::vector<std::vector<local_scalar_t__>>> tp_10 =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(n,
          std::vector<std::vector<local_scalar_t__>>(m,
            std::vector<local_scalar_t__>(k, DUMMY_VAR__)));
      current_statement__ = 28;
      stan::model::assign(tp_10, p_10, "assigning variable tp_10");
      current_statement__ = 28;
      stan::math::check_matching_dims("constraint", "tp_10", tp_10, "upper",
        ds);
      Eigen::Matrix<local_scalar_t__,-1,1> tpv_1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 29;
      stan::model::assign(tpv_1, pv_1, "assigning variable tpv_1");
      current_statement__ = 29;
      stan::math::check_matching_dims("constraint", "tpv_1", tpv_1, "lower",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 29;
      stan::math::check_matching_dims("constraint", "tpv_1", tpv_1, "upper",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> tpv_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(m,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__));
      current_statement__ = 30;
      stan::model::assign(tpv_2, pv_2, "assigning variable tpv_2");
      current_statement__ = 30;
      stan::math::check_matching_dims("constraint", "tpv_2", tpv_2, "lower",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1)));
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> tpv_3 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(n,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(m,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__)));
      current_statement__ = 31;
      stan::model::assign(tpv_3, pv_3, "assigning variable tpv_3");
      current_statement__ = 31;
      stan::math::check_matching_dims("constraint", "tpv_3", tpv_3, "upper",
        dv);
      Eigen::Matrix<local_scalar_t__,1,-1> tpr_1 =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 32;
      stan::model::assign(tpr_1, pr_1, "assigning variable tpr_1");
      current_statement__ = 32;
      stan::math::check_matching_dims("constraint", "tpr_1", tpr_1, "lower",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 32;
      stan::math::check_matching_dims("constraint", "tpr_1", tpr_1, "upper",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> tpr_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(m,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__));
      current_statement__ = 33;
      stan::model::assign(tpr_2, pr_2, "assigning variable tpr_2");
      current_statement__ = 33;
      stan::math::check_matching_dims("constraint", "tpr_2", tpr_2, "lower",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1)));
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> tpr_3 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(n,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(m,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__)));
      current_statement__ = 34;
      stan::model::assign(tpr_3, pr_3, "assigning variable tpr_3");
      current_statement__ = 34;
      stan::math::check_matching_dims("constraint", "tpr_3", tpr_3, "upper",
        dr);
      Eigen::Matrix<local_scalar_t__,-1,-1> tpm_1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, k, DUMMY_VAR__);
      current_statement__ = 35;
      stan::model::assign(tpm_1, pm_1, "assigning variable tpm_1");
      current_statement__ = 35;
      stan::math::check_matching_dims("constraint", "tpm_1", tpm_1, "lower",
        stan::model::rvalue(dm, "dm", stan::model::index_uni(1)));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> tpm_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(n,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, k, DUMMY_VAR__));
      current_statement__ = 36;
      stan::model::assign(tpm_2, pm_2, "assigning variable tpm_2");
      current_statement__ = 36;
      stan::math::check_matching_dims("constraint", "tpm_2", tpm_2, "upper",
        dm);
      current_statement__ = 19;
      stan::math::check_greater_or_equal(function__, "tp_1", tp_1,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 20;
      stan::math::check_less_or_equal(function__, "tp_2", tp_2,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 21;
      stan::math::check_greater_or_equal(function__, "tp_3", tp_3,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 21;
      stan::math::check_less_or_equal(function__, "tp_3", tp_3,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 22;
      stan::math::check_greater_or_equal(function__, "tp_4", tp_4, 0);
      current_statement__ = 22;
      stan::math::check_less_or_equal(function__, "tp_4", tp_4,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "tp_5", tp_5,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 23;
      stan::math::check_less_or_equal(function__, "tp_5", tp_5, 1);
      current_statement__ = 27;
      stan::math::check_greater_or_equal(function__, "tp_9", tp_9,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1)));
      current_statement__ = 27;
      stan::math::check_less_or_equal(function__, "tp_9", tp_9, 1);
      current_statement__ = 28;
      stan::math::check_greater_or_equal(function__, "tp_10", tp_10, 0);
      current_statement__ = 28;
      stan::math::check_less_or_equal(function__, "tp_10", tp_10, ds);
      current_statement__ = 29;
      stan::math::check_greater_or_equal(function__, "tpv_1", tpv_1,
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 29;
      stan::math::check_less_or_equal(function__, "tpv_1", tpv_1,
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "tpv_2", tpv_2,
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1)));
      current_statement__ = 31;
      stan::math::check_less_or_equal(function__, "tpv_3", tpv_3, dv);
      current_statement__ = 32;
      stan::math::check_greater_or_equal(function__, "tpr_1", tpr_1,
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 32;
      stan::math::check_less_or_equal(function__, "tpr_1", tpr_1,
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 33;
      stan::math::check_greater_or_equal(function__, "tpr_2", tpr_2,
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1)));
      current_statement__ = 34;
      stan::math::check_less_or_equal(function__, "tpr_3", tpr_3, dr);
      current_statement__ = 35;
      stan::math::check_greater_or_equal(function__, "tpm_1", tpm_1,
        stan::model::rvalue(dm, "dm", stan::model::index_uni(1)));
      current_statement__ = 36;
      stan::math::check_less_or_equal(function__, "tpm_2", tpm_2, dm);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "transform_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<local_scalar_t__> p_1 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 1;
      p_1 = in__.template read_constrain_lb<std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), lp__, k);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "p_1", p_1, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> p_2 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 2;
      p_2 = in__.template read_constrain_ub<std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), lp__, k);
      current_statement__ = 2;
      stan::math::check_matching_dims("constraint", "p_2", p_2, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> p_3 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 3;
      p_3 = in__.template read_constrain_lub<std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)),
              stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
                stan::model::index_uni(2)), lp__, k);
      current_statement__ = 3;
      stan::math::check_matching_dims("constraint", "p_3", p_3, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 3;
      stan::math::check_matching_dims("constraint", "p_3", p_3, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<local_scalar_t__> p_4 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 4;
      p_4 = in__.template read_constrain_lub<std::vector<local_scalar_t__>,
              jacobian__>(0,
              stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
                stan::model::index_uni(2)), lp__, k);
      current_statement__ = 4;
      stan::math::check_matching_dims("constraint", "p_4", p_4, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<local_scalar_t__> p_5 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 5;
      p_5 = in__.template read_constrain_lub<std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), 1, lp__, k);
      current_statement__ = 5;
      stan::math::check_matching_dims("constraint", "p_5", p_5, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> p_6 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 6;
      p_6 = in__.template read_constrain_offset_multiplier<
              std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), 1, lp__, k);
      current_statement__ = 6;
      stan::math::check_matching_dims("constraint", "p_6", p_6, "offset",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> p_7 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 7;
      p_7 = in__.template read_constrain_offset_multiplier<
              std::vector<local_scalar_t__>, jacobian__>(0,
              stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
                stan::model::index_uni(1)), lp__, k);
      current_statement__ = 7;
      stan::math::check_matching_dims("constraint", "p_7", p_7, "multiplier",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> p_8 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 8;
      p_8 = in__.template read_constrain_offset_multiplier<
              std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)),
              stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
                stan::model::index_uni(2)), lp__, k);
      current_statement__ = 8;
      stan::math::check_matching_dims("constraint", "p_8", p_8, "offset",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 8;
      stan::math::check_matching_dims("constraint", "p_8", p_8, "multiplier",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<std::vector<local_scalar_t__>> p_9 =
        std::vector<std::vector<local_scalar_t__>>(m,
          std::vector<local_scalar_t__>(k, DUMMY_VAR__));
      current_statement__ = 9;
      p_9 = in__.template read_constrain_lub<
              std::vector<std::vector<local_scalar_t__>>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1)), 1, lp__, m, k);
      current_statement__ = 9;
      stan::math::check_matching_dims("constraint", "p_9", p_9, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1)));
      std::vector<std::vector<std::vector<local_scalar_t__>>> p_10 =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(n,
          std::vector<std::vector<local_scalar_t__>>(m,
            std::vector<local_scalar_t__>(k, DUMMY_VAR__)));
      current_statement__ = 10;
      p_10 = in__.template read_constrain_lub<
               std::vector<std::vector<std::vector<local_scalar_t__>>>,
               jacobian__>(0, ds, lp__, n, m, k);
      current_statement__ = 10;
      stan::math::check_matching_dims("constraint", "p_10", p_10, "upper", ds);
      Eigen::Matrix<local_scalar_t__,-1,1> pv_1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 11;
      pv_1 = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__,-1,1>,
               jacobian__>(stan::model::rvalue(dv, "dv",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)),
               stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
                 stan::model::index_uni(2)), lp__, k);
      current_statement__ = 11;
      stan::math::check_matching_dims("constraint", "pv_1", pv_1, "lower",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 11;
      stan::math::check_matching_dims("constraint", "pv_1", pv_1, "upper",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> pv_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(m,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__));
      current_statement__ = 12;
      pv_2 = in__.template read_constrain_lb<
               std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>,
               jacobian__>(stan::model::rvalue(dv, "dv",
                             stan::model::index_uni(1)), lp__, m, k);
      current_statement__ = 12;
      stan::math::check_matching_dims("constraint", "pv_2", pv_2, "lower",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1)));
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> pv_3 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(n,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(m,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__)));
      current_statement__ = 13;
      pv_3 = in__.template read_constrain_ub<
               std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>,
               jacobian__>(dv, lp__, n, m, k);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "pv_3", pv_3, "upper", dv);
      Eigen::Matrix<local_scalar_t__,1,-1> pr_1 =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 14;
      pr_1 = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__,1,-1>,
               jacobian__>(stan::model::rvalue(dr, "dr",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)),
               stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
                 stan::model::index_uni(2)), lp__, k);
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint", "pr_1", pr_1, "lower",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint", "pr_1", pr_1, "upper",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> pr_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(m,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__));
      current_statement__ = 15;
      pr_2 = in__.template read_constrain_lb<
               std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>,
               jacobian__>(stan::model::rvalue(dr, "dr",
                             stan::model::index_uni(1)), lp__, m, k);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "pr_2", pr_2, "lower",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1)));
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> pr_3 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(n,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(m,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__)));
      current_statement__ = 16;
      pr_3 = in__.template read_constrain_ub<
               std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>,
               jacobian__>(dr, lp__, n, m, k);
      current_statement__ = 16;
      stan::math::check_matching_dims("constraint", "pr_3", pr_3, "upper", dr);
      Eigen::Matrix<local_scalar_t__,-1,-1> pm_1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, k, DUMMY_VAR__);
      current_statement__ = 17;
      pm_1 = in__.template read_constrain_lb<
               Eigen::Matrix<local_scalar_t__,-1,-1>,
               jacobian__>(stan::model::rvalue(dm, "dm",
                             stan::model::index_uni(1)), lp__, m, k);
      current_statement__ = 17;
      stan::math::check_matching_dims("constraint", "pm_1", pm_1, "lower",
        stan::model::rvalue(dm, "dm", stan::model::index_uni(1)));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> pm_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(n,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, k, DUMMY_VAR__));
      current_statement__ = 18;
      pm_2 = in__.template read_constrain_ub<
               std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
               jacobian__>(dm, lp__, n, m, k);
      current_statement__ = 18;
      stan::math::check_matching_dims("constraint", "pm_2", pm_2, "upper", dm);
      std::vector<local_scalar_t__> tp_1 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 19;
      stan::model::assign(tp_1, p_1, "assigning variable tp_1");
      current_statement__ = 19;
      stan::math::check_matching_dims("constraint", "tp_1", tp_1, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> tp_2 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 20;
      stan::model::assign(tp_2, p_2, "assigning variable tp_2");
      current_statement__ = 20;
      stan::math::check_matching_dims("constraint", "tp_2", tp_2, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> tp_3 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 21;
      stan::model::assign(tp_3, p_3, "assigning variable tp_3");
      current_statement__ = 21;
      stan::math::check_matching_dims("constraint", "tp_3", tp_3, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 21;
      stan::math::check_matching_dims("constraint", "tp_3", tp_3, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<local_scalar_t__> tp_4 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 22;
      stan::model::assign(tp_4, p_4, "assigning variable tp_4");
      current_statement__ = 22;
      stan::math::check_matching_dims("constraint", "tp_4", tp_4, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<local_scalar_t__> tp_5 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 23;
      stan::model::assign(tp_5, p_5, "assigning variable tp_5");
      current_statement__ = 23;
      stan::math::check_matching_dims("constraint", "tp_5", tp_5, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> tp_6 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 24;
      stan::model::assign(tp_6, p_6, "assigning variable tp_6");
      current_statement__ = 24;
      stan::math::check_matching_dims("constraint", "tp_6", tp_6, "offset",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> tp_7 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 25;
      stan::model::assign(tp_7, p_7, "assigning variable tp_7");
      current_statement__ = 25;
      stan::math::check_matching_dims("constraint", "tp_7", tp_7,
        "multiplier",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<local_scalar_t__> tp_8 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 26;
      stan::model::assign(tp_8, p_8, "assigning variable tp_8");
      current_statement__ = 26;
      stan::math::check_matching_dims("constraint", "tp_8", tp_8, "offset",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 26;
      stan::math::check_matching_dims("constraint", "tp_8", tp_8,
        "multiplier",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<std::vector<local_scalar_t__>> tp_9 =
        std::vector<std::vector<local_scalar_t__>>(m,
          std::vector<local_scalar_t__>(k, DUMMY_VAR__));
      current_statement__ = 27;
      stan::model::assign(tp_9, p_9, "assigning variable tp_9");
      current_statement__ = 27;
      stan::math::check_matching_dims("constraint", "tp_9", tp_9, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1)));
      std::vector<std::vector<std::vector<local_scalar_t__>>> tp_10 =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(n,
          std::vector<std::vector<local_scalar_t__>>(m,
            std::vector<local_scalar_t__>(k, DUMMY_VAR__)));
      current_statement__ = 28;
      stan::model::assign(tp_10, p_10, "assigning variable tp_10");
      current_statement__ = 28;
      stan::math::check_matching_dims("constraint", "tp_10", tp_10, "upper",
        ds);
      Eigen::Matrix<local_scalar_t__,-1,1> tpv_1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 29;
      stan::model::assign(tpv_1, pv_1, "assigning variable tpv_1");
      current_statement__ = 29;
      stan::math::check_matching_dims("constraint", "tpv_1", tpv_1, "lower",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 29;
      stan::math::check_matching_dims("constraint", "tpv_1", tpv_1, "upper",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> tpv_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(m,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__));
      current_statement__ = 30;
      stan::model::assign(tpv_2, pv_2, "assigning variable tpv_2");
      current_statement__ = 30;
      stan::math::check_matching_dims("constraint", "tpv_2", tpv_2, "lower",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1)));
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> tpv_3 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(n,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(m,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__)));
      current_statement__ = 31;
      stan::model::assign(tpv_3, pv_3, "assigning variable tpv_3");
      current_statement__ = 31;
      stan::math::check_matching_dims("constraint", "tpv_3", tpv_3, "upper",
        dv);
      Eigen::Matrix<local_scalar_t__,1,-1> tpr_1 =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 32;
      stan::model::assign(tpr_1, pr_1, "assigning variable tpr_1");
      current_statement__ = 32;
      stan::math::check_matching_dims("constraint", "tpr_1", tpr_1, "lower",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 32;
      stan::math::check_matching_dims("constraint", "tpr_1", tpr_1, "upper",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> tpr_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(m,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__));
      current_statement__ = 33;
      stan::model::assign(tpr_2, pr_2, "assigning variable tpr_2");
      current_statement__ = 33;
      stan::math::check_matching_dims("constraint", "tpr_2", tpr_2, "lower",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1)));
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> tpr_3 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(n,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(m,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__)));
      current_statement__ = 34;
      stan::model::assign(tpr_3, pr_3, "assigning variable tpr_3");
      current_statement__ = 34;
      stan::math::check_matching_dims("constraint", "tpr_3", tpr_3, "upper",
        dr);
      Eigen::Matrix<local_scalar_t__,-1,-1> tpm_1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, k, DUMMY_VAR__);
      current_statement__ = 35;
      stan::model::assign(tpm_1, pm_1, "assigning variable tpm_1");
      current_statement__ = 35;
      stan::math::check_matching_dims("constraint", "tpm_1", tpm_1, "lower",
        stan::model::rvalue(dm, "dm", stan::model::index_uni(1)));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> tpm_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(n,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, k, DUMMY_VAR__));
      current_statement__ = 36;
      stan::model::assign(tpm_2, pm_2, "assigning variable tpm_2");
      current_statement__ = 36;
      stan::math::check_matching_dims("constraint", "tpm_2", tpm_2, "upper",
        dm);
      current_statement__ = 19;
      stan::math::check_greater_or_equal(function__, "tp_1", tp_1,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 20;
      stan::math::check_less_or_equal(function__, "tp_2", tp_2,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 21;
      stan::math::check_greater_or_equal(function__, "tp_3", tp_3,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 21;
      stan::math::check_less_or_equal(function__, "tp_3", tp_3,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 22;
      stan::math::check_greater_or_equal(function__, "tp_4", tp_4, 0);
      current_statement__ = 22;
      stan::math::check_less_or_equal(function__, "tp_4", tp_4,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "tp_5", tp_5,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 23;
      stan::math::check_less_or_equal(function__, "tp_5", tp_5, 1);
      current_statement__ = 27;
      stan::math::check_greater_or_equal(function__, "tp_9", tp_9,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1)));
      current_statement__ = 27;
      stan::math::check_less_or_equal(function__, "tp_9", tp_9, 1);
      current_statement__ = 28;
      stan::math::check_greater_or_equal(function__, "tp_10", tp_10, 0);
      current_statement__ = 28;
      stan::math::check_less_or_equal(function__, "tp_10", tp_10, ds);
      current_statement__ = 29;
      stan::math::check_greater_or_equal(function__, "tpv_1", tpv_1,
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 29;
      stan::math::check_less_or_equal(function__, "tpv_1", tpv_1,
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "tpv_2", tpv_2,
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1)));
      current_statement__ = 31;
      stan::math::check_less_or_equal(function__, "tpv_3", tpv_3, dv);
      current_statement__ = 32;
      stan::math::check_greater_or_equal(function__, "tpr_1", tpr_1,
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 32;
      stan::math::check_less_or_equal(function__, "tpr_1", tpr_1,
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 33;
      stan::math::check_greater_or_equal(function__, "tpr_2", tpr_2,
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1)));
      current_statement__ = 34;
      stan::math::check_less_or_equal(function__, "tpr_3", tpr_3, dr);
      current_statement__ = 35;
      stan::math::check_greater_or_equal(function__, "tpm_1", tpm_1,
        stan::model::rvalue(dm, "dm", stan::model::index_uni(1)));
      current_statement__ = 36;
      stan::math::check_less_or_equal(function__, "tpm_2", tpm_2, dm);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "transform_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<double> p_1 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      p_1 = in__.template read_constrain_lb<std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), lp__, k);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "p_1", p_1, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<double> p_2 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      p_2 = in__.template read_constrain_ub<std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), lp__, k);
      current_statement__ = 2;
      stan::math::check_matching_dims("constraint", "p_2", p_2, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<double> p_3 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      p_3 = in__.template read_constrain_lub<std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)),
              stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
                stan::model::index_uni(2)), lp__, k);
      current_statement__ = 3;
      stan::math::check_matching_dims("constraint", "p_3", p_3, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 3;
      stan::math::check_matching_dims("constraint", "p_3", p_3, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<double> p_4 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 4;
      p_4 = in__.template read_constrain_lub<std::vector<local_scalar_t__>,
              jacobian__>(0,
              stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
                stan::model::index_uni(2)), lp__, k);
      current_statement__ = 4;
      stan::math::check_matching_dims("constraint", "p_4", p_4, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<double> p_5 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      p_5 = in__.template read_constrain_lub<std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), 1, lp__, k);
      current_statement__ = 5;
      stan::math::check_matching_dims("constraint", "p_5", p_5, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<double> p_6 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 6;
      p_6 = in__.template read_constrain_offset_multiplier<
              std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), 1, lp__, k);
      current_statement__ = 6;
      stan::math::check_matching_dims("constraint", "p_6", p_6, "offset",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<double> p_7 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 7;
      p_7 = in__.template read_constrain_offset_multiplier<
              std::vector<local_scalar_t__>, jacobian__>(0,
              stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
                stan::model::index_uni(1)), lp__, k);
      current_statement__ = 7;
      stan::math::check_matching_dims("constraint", "p_7", p_7, "multiplier",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      std::vector<double> p_8 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 8;
      p_8 = in__.template read_constrain_offset_multiplier<
              std::vector<local_scalar_t__>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)),
              stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
                stan::model::index_uni(2)), lp__, k);
      current_statement__ = 8;
      stan::math::check_matching_dims("constraint", "p_8", p_8, "offset",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 8;
      stan::math::check_matching_dims("constraint", "p_8", p_8, "multiplier",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<std::vector<double>> p_9 =
        std::vector<std::vector<double>>(m,
          std::vector<double>(k, std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 9;
      p_9 = in__.template read_constrain_lub<
              std::vector<std::vector<local_scalar_t__>>,
              jacobian__>(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1)), 1, lp__, m, k);
      current_statement__ = 9;
      stan::math::check_matching_dims("constraint", "p_9", p_9, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1)));
      std::vector<std::vector<std::vector<double>>> p_10 =
        std::vector<std::vector<std::vector<double>>>(n,
          std::vector<std::vector<double>>(m,
            std::vector<double>(k, std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 10;
      p_10 = in__.template read_constrain_lub<
               std::vector<std::vector<std::vector<local_scalar_t__>>>,
               jacobian__>(0, ds, lp__, n, m, k);
      current_statement__ = 10;
      stan::math::check_matching_dims("constraint", "p_10", p_10, "upper", ds);
      Eigen::Matrix<double,-1,1> pv_1 =
        Eigen::Matrix<double,-1,1>::Constant(k,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 11;
      pv_1 = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__,-1,1>,
               jacobian__>(stan::model::rvalue(dv, "dv",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)),
               stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
                 stan::model::index_uni(2)), lp__, k);
      current_statement__ = 11;
      stan::math::check_matching_dims("constraint", "pv_1", pv_1, "lower",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 11;
      stan::math::check_matching_dims("constraint", "pv_1", pv_1, "upper",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<Eigen::Matrix<double,-1,1>> pv_2 =
        std::vector<Eigen::Matrix<double,-1,1>>(m,
          Eigen::Matrix<double,-1,1>::Constant(k,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 12;
      pv_2 = in__.template read_constrain_lb<
               std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>,
               jacobian__>(stan::model::rvalue(dv, "dv",
                             stan::model::index_uni(1)), lp__, m, k);
      current_statement__ = 12;
      stan::math::check_matching_dims("constraint", "pv_2", pv_2, "lower",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1)));
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> pv_3 =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(n,
          std::vector<Eigen::Matrix<double,-1,1>>(m,
            Eigen::Matrix<double,-1,1>::Constant(k,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 13;
      pv_3 = in__.template read_constrain_ub<
               std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>,
               jacobian__>(dv, lp__, n, m, k);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "pv_3", pv_3, "upper", dv);
      Eigen::Matrix<double,1,-1> pr_1 =
        Eigen::Matrix<double,1,-1>::Constant(k,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 14;
      pr_1 = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__,1,-1>,
               jacobian__>(stan::model::rvalue(dr, "dr",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)),
               stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
                 stan::model::index_uni(2)), lp__, k);
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint", "pr_1", pr_1, "lower",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint", "pr_1", pr_1, "upper",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      std::vector<Eigen::Matrix<double,1,-1>> pr_2 =
        std::vector<Eigen::Matrix<double,1,-1>>(m,
          Eigen::Matrix<double,1,-1>::Constant(k,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 15;
      pr_2 = in__.template read_constrain_lb<
               std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>,
               jacobian__>(stan::model::rvalue(dr, "dr",
                             stan::model::index_uni(1)), lp__, m, k);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "pr_2", pr_2, "lower",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1)));
      std::vector<std::vector<Eigen::Matrix<double,1,-1>>> pr_3 =
        std::vector<std::vector<Eigen::Matrix<double,1,-1>>>(n,
          std::vector<Eigen::Matrix<double,1,-1>>(m,
            Eigen::Matrix<double,1,-1>::Constant(k,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 16;
      pr_3 = in__.template read_constrain_ub<
               std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>,
               jacobian__>(dr, lp__, n, m, k);
      current_statement__ = 16;
      stan::math::check_matching_dims("constraint", "pr_3", pr_3, "upper", dr);
      Eigen::Matrix<double,-1,-1> pm_1 =
        Eigen::Matrix<double,-1,-1>::Constant(m, k,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 17;
      pm_1 = in__.template read_constrain_lb<
               Eigen::Matrix<local_scalar_t__,-1,-1>,
               jacobian__>(stan::model::rvalue(dm, "dm",
                             stan::model::index_uni(1)), lp__, m, k);
      current_statement__ = 17;
      stan::math::check_matching_dims("constraint", "pm_1", pm_1, "lower",
        stan::model::rvalue(dm, "dm", stan::model::index_uni(1)));
      std::vector<Eigen::Matrix<double,-1,-1>> pm_2 =
        std::vector<Eigen::Matrix<double,-1,-1>>(n,
          Eigen::Matrix<double,-1,-1>::Constant(m, k,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 18;
      pm_2 = in__.template read_constrain_ub<
               std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
               jacobian__>(dm, lp__, n, m, k);
      current_statement__ = 18;
      stan::math::check_matching_dims("constraint", "pm_2", pm_2, "upper", dm);
      std::vector<double> tp_1 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      std::vector<double> tp_2 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      std::vector<double> tp_3 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      std::vector<double> tp_4 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      std::vector<double> tp_5 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      std::vector<double> tp_6 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      std::vector<double> tp_7 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      std::vector<double> tp_8 =
        std::vector<double>(k, std::numeric_limits<double>::quiet_NaN());
      std::vector<std::vector<double>> tp_9 =
        std::vector<std::vector<double>>(m,
          std::vector<double>(k, std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<std::vector<double>>> tp_10 =
        std::vector<std::vector<std::vector<double>>>(n,
          std::vector<std::vector<double>>(m,
            std::vector<double>(k, std::numeric_limits<double>::quiet_NaN())));
      Eigen::Matrix<double,-1,1> tpv_1 =
        Eigen::Matrix<double,-1,1>::Constant(k,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,-1,1>> tpv_2 =
        std::vector<Eigen::Matrix<double,-1,1>>(m,
          Eigen::Matrix<double,-1,1>::Constant(k,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> tpv_3 =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(n,
          std::vector<Eigen::Matrix<double,-1,1>>(m,
            Eigen::Matrix<double,-1,1>::Constant(k,
              std::numeric_limits<double>::quiet_NaN())));
      Eigen::Matrix<double,1,-1> tpr_1 =
        Eigen::Matrix<double,1,-1>::Constant(k,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,1,-1>> tpr_2 =
        std::vector<Eigen::Matrix<double,1,-1>>(m,
          Eigen::Matrix<double,1,-1>::Constant(k,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<Eigen::Matrix<double,1,-1>>> tpr_3 =
        std::vector<std::vector<Eigen::Matrix<double,1,-1>>>(n,
          std::vector<Eigen::Matrix<double,1,-1>>(m,
            Eigen::Matrix<double,1,-1>::Constant(k,
              std::numeric_limits<double>::quiet_NaN())));
      Eigen::Matrix<double,-1,-1> tpm_1 =
        Eigen::Matrix<double,-1,-1>::Constant(m, k,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,-1,-1>> tpm_2 =
        std::vector<Eigen::Matrix<double,-1,-1>>(n,
          Eigen::Matrix<double,-1,-1>::Constant(m, k,
            std::numeric_limits<double>::quiet_NaN()));
      out__.write(p_1);
      out__.write(p_2);
      out__.write(p_3);
      out__.write(p_4);
      out__.write(p_5);
      out__.write(p_6);
      out__.write(p_7);
      out__.write(p_8);
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          out__.write(p_9[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            out__.write(p_10[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      out__.write(pv_1);
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          out__.write(pv_2[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            out__.write(pv_3[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      out__.write(pr_1);
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          out__.write(pr_2[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            out__.write(pr_3[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      out__.write(pm_1);
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            out__.write(stan::model::rvalue(pm_2, "pm_2",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 19;
      stan::model::assign(tp_1, p_1, "assigning variable tp_1");
      current_statement__ = 19;
      stan::math::check_matching_dims("constraint", "tp_1", tp_1, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 20;
      stan::model::assign(tp_2, p_2, "assigning variable tp_2");
      current_statement__ = 20;
      stan::math::check_matching_dims("constraint", "tp_2", tp_2, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 21;
      stan::model::assign(tp_3, p_3, "assigning variable tp_3");
      current_statement__ = 21;
      stan::math::check_matching_dims("constraint", "tp_3", tp_3, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 21;
      stan::math::check_matching_dims("constraint", "tp_3", tp_3, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 22;
      stan::model::assign(tp_4, p_4, "assigning variable tp_4");
      current_statement__ = 22;
      stan::math::check_matching_dims("constraint", "tp_4", tp_4, "upper",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 23;
      stan::model::assign(tp_5, p_5, "assigning variable tp_5");
      current_statement__ = 23;
      stan::math::check_matching_dims("constraint", "tp_5", tp_5, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 24;
      stan::model::assign(tp_6, p_6, "assigning variable tp_6");
      current_statement__ = 24;
      stan::math::check_matching_dims("constraint", "tp_6", tp_6, "offset",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 25;
      stan::model::assign(tp_7, p_7, "assigning variable tp_7");
      current_statement__ = 25;
      stan::math::check_matching_dims("constraint", "tp_7", tp_7,
        "multiplier",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 26;
      stan::model::assign(tp_8, p_8, "assigning variable tp_8");
      current_statement__ = 26;
      stan::math::check_matching_dims("constraint", "tp_8", tp_8, "offset",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 26;
      stan::math::check_matching_dims("constraint", "tp_8", tp_8,
        "multiplier",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 27;
      stan::model::assign(tp_9, p_9, "assigning variable tp_9");
      current_statement__ = 27;
      stan::math::check_matching_dims("constraint", "tp_9", tp_9, "lower",
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1)));
      current_statement__ = 28;
      stan::model::assign(tp_10, p_10, "assigning variable tp_10");
      current_statement__ = 28;
      stan::math::check_matching_dims("constraint", "tp_10", tp_10, "upper",
        ds);
      current_statement__ = 29;
      stan::model::assign(tpv_1, pv_1, "assigning variable tpv_1");
      current_statement__ = 29;
      stan::math::check_matching_dims("constraint", "tpv_1", tpv_1, "lower",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 29;
      stan::math::check_matching_dims("constraint", "tpv_1", tpv_1, "upper",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 30;
      stan::model::assign(tpv_2, pv_2, "assigning variable tpv_2");
      current_statement__ = 30;
      stan::math::check_matching_dims("constraint", "tpv_2", tpv_2, "lower",
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1)));
      current_statement__ = 31;
      stan::model::assign(tpv_3, pv_3, "assigning variable tpv_3");
      current_statement__ = 31;
      stan::math::check_matching_dims("constraint", "tpv_3", tpv_3, "upper",
        dv);
      current_statement__ = 32;
      stan::model::assign(tpr_1, pr_1, "assigning variable tpr_1");
      current_statement__ = 32;
      stan::math::check_matching_dims("constraint", "tpr_1", tpr_1, "lower",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 32;
      stan::math::check_matching_dims("constraint", "tpr_1", tpr_1, "upper",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 33;
      stan::model::assign(tpr_2, pr_2, "assigning variable tpr_2");
      current_statement__ = 33;
      stan::math::check_matching_dims("constraint", "tpr_2", tpr_2, "lower",
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1)));
      current_statement__ = 34;
      stan::model::assign(tpr_3, pr_3, "assigning variable tpr_3");
      current_statement__ = 34;
      stan::math::check_matching_dims("constraint", "tpr_3", tpr_3, "upper",
        dr);
      current_statement__ = 35;
      stan::model::assign(tpm_1, pm_1, "assigning variable tpm_1");
      current_statement__ = 35;
      stan::math::check_matching_dims("constraint", "tpm_1", tpm_1, "lower",
        stan::model::rvalue(dm, "dm", stan::model::index_uni(1)));
      current_statement__ = 36;
      stan::model::assign(tpm_2, pm_2, "assigning variable tpm_2");
      current_statement__ = 36;
      stan::math::check_matching_dims("constraint", "tpm_2", tpm_2, "upper",
        dm);
      current_statement__ = 19;
      stan::math::check_greater_or_equal(function__, "tp_1", tp_1,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 20;
      stan::math::check_less_or_equal(function__, "tp_2", tp_2,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 21;
      stan::math::check_greater_or_equal(function__, "tp_3", tp_3,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 21;
      stan::math::check_less_or_equal(function__, "tp_3", tp_3,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 22;
      stan::math::check_greater_or_equal(function__, "tp_4", tp_4, 0);
      current_statement__ = 22;
      stan::math::check_less_or_equal(function__, "tp_4", tp_4,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "tp_5", tp_5,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 23;
      stan::math::check_less_or_equal(function__, "tp_5", tp_5, 1);
      current_statement__ = 27;
      stan::math::check_greater_or_equal(function__, "tp_9", tp_9,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1)));
      current_statement__ = 27;
      stan::math::check_less_or_equal(function__, "tp_9", tp_9, 1);
      current_statement__ = 28;
      stan::math::check_greater_or_equal(function__, "tp_10", tp_10, 0);
      current_statement__ = 28;
      stan::math::check_less_or_equal(function__, "tp_10", tp_10, ds);
      current_statement__ = 29;
      stan::math::check_greater_or_equal(function__, "tpv_1", tpv_1,
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 29;
      stan::math::check_less_or_equal(function__, "tpv_1", tpv_1,
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "tpv_2", tpv_2,
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1)));
      current_statement__ = 31;
      stan::math::check_less_or_equal(function__, "tpv_3", tpv_3, dv);
      current_statement__ = 32;
      stan::math::check_greater_or_equal(function__, "tpr_1", tpr_1,
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(1)));
      current_statement__ = 32;
      stan::math::check_less_or_equal(function__, "tpr_1", tpr_1,
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(2)));
      current_statement__ = 33;
      stan::math::check_greater_or_equal(function__, "tpr_2", tpr_2,
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1)));
      current_statement__ = 34;
      stan::math::check_less_or_equal(function__, "tpr_3", tpr_3, dr);
      current_statement__ = 35;
      stan::math::check_greater_or_equal(function__, "tpm_1", tpm_1,
        stan::model::rvalue(dm, "dm", stan::model::index_uni(1)));
      current_statement__ = 36;
      stan::math::check_less_or_equal(function__, "tpm_2", tpm_2, dm);
      if (emit_transformed_parameters__) {
        out__.write(tp_1);
        out__.write(tp_2);
        out__.write(tp_3);
        out__.write(tp_4);
        out__.write(tp_5);
        out__.write(tp_6);
        out__.write(tp_7);
        out__.write(tp_8);
        current_statement__ = 27;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            out__.write(tp_9[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        current_statement__ = 28;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
              out__.write(tp_10[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
            }
          }
        }
        out__.write(tpv_1);
        current_statement__ = 30;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            out__.write(tpv_2[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        current_statement__ = 31;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
              out__.write(tpv_3[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
            }
          }
        }
        out__.write(tpr_1);
        current_statement__ = 33;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            out__.write(tpr_2[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        current_statement__ = 34;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
              out__.write(tpr_3[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
            }
          }
        }
        out__.write(tpm_1);
        current_statement__ = 36;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
              out__.write(stan::model::rvalue(tpm_2, "tpm_2",
                            stan::model::index_uni(sym3__),
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(sym1__)));
            }
          }
        }
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      std::vector<local_scalar_t__> p_1 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(p_1, in__.read<std::vector<local_scalar_t__>>(k),
        "assigning variable p_1");
      out__.write_free_lb(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), p_1);
      std::vector<local_scalar_t__> p_2 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(p_2, in__.read<std::vector<local_scalar_t__>>(k),
        "assigning variable p_2");
      out__.write_free_ub(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), p_2);
      std::vector<local_scalar_t__> p_3 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(p_3, in__.read<std::vector<local_scalar_t__>>(k),
        "assigning variable p_3");
      out__.write_free_lub(stan::model::rvalue(ds, "ds",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)),
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)), p_3);
      std::vector<local_scalar_t__> p_4 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(p_4, in__.read<std::vector<local_scalar_t__>>(k),
        "assigning variable p_4");
      out__.write_free_lub(0,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)), p_4);
      std::vector<local_scalar_t__> p_5 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(p_5, in__.read<std::vector<local_scalar_t__>>(k),
        "assigning variable p_5");
      out__.write_free_lub(stan::model::rvalue(ds, "ds",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)), 1, p_5);
      std::vector<local_scalar_t__> p_6 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(p_6, in__.read<std::vector<local_scalar_t__>>(k),
        "assigning variable p_6");
      out__.write_free_offset_multiplier(stan::model::rvalue(ds, "ds",
                                           stan::model::index_uni(1),
                                           stan::model::index_uni(1)), 1,
        p_6);
      std::vector<local_scalar_t__> p_7 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(p_7, in__.read<std::vector<local_scalar_t__>>(k),
        "assigning variable p_7");
      out__.write_free_offset_multiplier(0,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)), p_7);
      std::vector<local_scalar_t__> p_8 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(p_8, in__.read<std::vector<local_scalar_t__>>(k),
        "assigning variable p_8");
      out__.write_free_offset_multiplier(stan::model::rvalue(ds, "ds",
                                           stan::model::index_uni(1),
                                           stan::model::index_uni(1)),
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)), p_8);
      std::vector<std::vector<local_scalar_t__>> p_9 =
        std::vector<std::vector<local_scalar_t__>>(m,
          std::vector<local_scalar_t__>(k, DUMMY_VAR__));
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          current_statement__ = 9;
          p_9[(sym2__ - 1)][(sym1__ - 1)] = in__.read<local_scalar_t__>();
        }
      }
      out__.write_free_lub(stan::model::rvalue(ds, "ds",
                             stan::model::index_uni(1)), 1, p_9);
      std::vector<std::vector<std::vector<local_scalar_t__>>> p_10 =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(n,
          std::vector<std::vector<local_scalar_t__>>(m,
            std::vector<local_scalar_t__>(k, DUMMY_VAR__)));
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            current_statement__ = 10;
            p_10[(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
              1)] = in__.read<local_scalar_t__>();
          }
        }
      }
      out__.write_free_lub(0, ds, p_10);
      Eigen::Matrix<local_scalar_t__,-1,1> pv_1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 11;
      stan::model::assign(pv_1,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(k),
        "assigning variable pv_1");
      out__.write_free_lub(stan::model::rvalue(dv, "dv",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)),
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(2)), pv_1);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> pv_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(m,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__));
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          current_statement__ = 12;
          stan::model::assign(pv_2, in__.read<local_scalar_t__>(),
            "assigning variable pv_2", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write_free_lb(stan::model::rvalue(dv, "dv",
                            stan::model::index_uni(1)), pv_2);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> pv_3 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(n,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(m,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__)));
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            current_statement__ = 13;
            stan::model::assign(pv_3, in__.read<local_scalar_t__>(),
              "assigning variable pv_3", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write_free_ub(dv, pv_3);
      Eigen::Matrix<local_scalar_t__,1,-1> pr_1 =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__);
      current_statement__ = 14;
      stan::model::assign(pr_1,
        in__.read<Eigen::Matrix<local_scalar_t__,1,-1>>(k),
        "assigning variable pr_1");
      out__.write_free_lub(stan::model::rvalue(dr, "dr",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)),
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(2)), pr_1);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> pr_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(m,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__));
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          current_statement__ = 15;
          stan::model::assign(pr_2, in__.read<local_scalar_t__>(),
            "assigning variable pr_2", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write_free_lb(stan::model::rvalue(dr, "dr",
                            stan::model::index_uni(1)), pr_2);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> pr_3 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(n,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(m,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__)));
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            current_statement__ = 16;
            stan::model::assign(pr_3, in__.read<local_scalar_t__>(),
              "assigning variable pr_3", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write_free_ub(dr, pr_3);
      Eigen::Matrix<local_scalar_t__,-1,-1> pm_1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, k, DUMMY_VAR__);
      current_statement__ = 17;
      stan::model::assign(pm_1,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, k),
        "assigning variable pm_1");
      out__.write_free_lb(stan::model::rvalue(dm, "dm",
                            stan::model::index_uni(1)), pm_1);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> pm_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(n,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, k, DUMMY_VAR__));
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            current_statement__ = 18;
            stan::model::assign(pm_2, in__.read<local_scalar_t__>(),
              "assigning variable pm_2", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write_free_ub(dm, pm_2);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "p_1", "double",
        std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "p_2", "double",
        std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "p_3", "double",
        std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "p_4", "double",
        std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "p_5", "double",
        std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "p_6", "double",
        std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "p_7", "double",
        std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization", "p_8", "double",
        std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 9;
      context__.validate_dims("parameter initialization", "p_9", "double",
        std::vector<size_t>{static_cast<size_t>(m), static_cast<size_t>(k)});
      current_statement__ = 10;
      context__.validate_dims("parameter initialization", "p_10", "double",
        std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m),
          static_cast<size_t>(k)});
      current_statement__ = 11;
      context__.validate_dims("parameter initialization", "pv_1", "double",
        std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 12;
      context__.validate_dims("parameter initialization", "pv_2", "double",
        std::vector<size_t>{static_cast<size_t>(m), static_cast<size_t>(k)});
      current_statement__ = 13;
      context__.validate_dims("parameter initialization", "pv_3", "double",
        std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m),
          static_cast<size_t>(k)});
      current_statement__ = 14;
      context__.validate_dims("parameter initialization", "pr_1", "double",
        std::vector<size_t>{static_cast<size_t>(k)});
      current_statement__ = 15;
      context__.validate_dims("parameter initialization", "pr_2", "double",
        std::vector<size_t>{static_cast<size_t>(m), static_cast<size_t>(k)});
      current_statement__ = 16;
      context__.validate_dims("parameter initialization", "pr_3", "double",
        std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m),
          static_cast<size_t>(k)});
      current_statement__ = 17;
      context__.validate_dims("parameter initialization", "pm_1", "double",
        std::vector<size_t>{static_cast<size_t>(m), static_cast<size_t>(k)});
      current_statement__ = 18;
      context__.validate_dims("parameter initialization", "pm_2", "double",
        std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m),
          static_cast<size_t>(k)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      std::vector<local_scalar_t__> p_1 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 1;
      p_1 = context__.vals_r("p_1");
      out__.write_free_lb(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), p_1);
      std::vector<local_scalar_t__> p_2 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 2;
      p_2 = context__.vals_r("p_2");
      out__.write_free_ub(stan::model::rvalue(ds, "ds",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)), p_2);
      std::vector<local_scalar_t__> p_3 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 3;
      p_3 = context__.vals_r("p_3");
      out__.write_free_lub(stan::model::rvalue(ds, "ds",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)),
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)), p_3);
      std::vector<local_scalar_t__> p_4 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 4;
      p_4 = context__.vals_r("p_4");
      out__.write_free_lub(0,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)), p_4);
      std::vector<local_scalar_t__> p_5 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 5;
      p_5 = context__.vals_r("p_5");
      out__.write_free_lub(stan::model::rvalue(ds, "ds",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)), 1, p_5);
      std::vector<local_scalar_t__> p_6 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 6;
      p_6 = context__.vals_r("p_6");
      out__.write_free_offset_multiplier(stan::model::rvalue(ds, "ds",
                                           stan::model::index_uni(1),
                                           stan::model::index_uni(1)), 1,
        p_6);
      std::vector<local_scalar_t__> p_7 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 7;
      p_7 = context__.vals_r("p_7");
      out__.write_free_offset_multiplier(0,
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(1)), p_7);
      std::vector<local_scalar_t__> p_8 =
        std::vector<local_scalar_t__>(k, DUMMY_VAR__);
      current_statement__ = 8;
      p_8 = context__.vals_r("p_8");
      out__.write_free_offset_multiplier(stan::model::rvalue(ds, "ds",
                                           stan::model::index_uni(1),
                                           stan::model::index_uni(1)),
        stan::model::rvalue(ds, "ds", stan::model::index_uni(1),
          stan::model::index_uni(2)), p_8);
      std::vector<std::vector<local_scalar_t__>> p_9 =
        std::vector<std::vector<local_scalar_t__>>(m,
          std::vector<local_scalar_t__>(k, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> p_9_flat__;
        current_statement__ = 9;
        p_9_flat__ = context__.vals_r("p_9");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            stan::model::assign(p_9, p_9_flat__[(pos__ - 1)],
              "assigning variable p_9", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_lub(stan::model::rvalue(ds, "ds",
                             stan::model::index_uni(1)), 1, p_9);
      std::vector<std::vector<std::vector<local_scalar_t__>>> p_10 =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(n,
          std::vector<std::vector<local_scalar_t__>>(m,
            std::vector<local_scalar_t__>(k, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> p_10_flat__;
        current_statement__ = 10;
        p_10_flat__ = context__.vals_r("p_10");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
              stan::model::assign(p_10, p_10_flat__[(pos__ - 1)],
                "assigning variable p_10", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write_free_lub(0, ds, p_10);
      Eigen::Matrix<local_scalar_t__,-1,1> pv_1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> pv_1_flat__;
        current_statement__ = 11;
        pv_1_flat__ = context__.vals_r("pv_1");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          stan::model::assign(pv_1, pv_1_flat__[(pos__ - 1)],
            "assigning variable pv_1", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lub(stan::model::rvalue(dv, "dv",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)),
        stan::model::rvalue(dv, "dv", stan::model::index_uni(1),
          stan::model::index_uni(2)), pv_1);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> pv_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(m,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> pv_2_flat__;
        current_statement__ = 12;
        pv_2_flat__ = context__.vals_r("pv_2");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            stan::model::assign(pv_2, pv_2_flat__[(pos__ - 1)],
              "assigning variable pv_2", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_lb(stan::model::rvalue(dv, "dv",
                            stan::model::index_uni(1)), pv_2);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> pv_3 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(n,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(m,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> pv_3_flat__;
        current_statement__ = 13;
        pv_3_flat__ = context__.vals_r("pv_3");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
              stan::model::assign(pv_3, pv_3_flat__[(pos__ - 1)],
                "assigning variable pv_3", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write_free_ub(dv, pv_3);
      Eigen::Matrix<local_scalar_t__,1,-1> pr_1 =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> pr_1_flat__;
        current_statement__ = 14;
        pr_1_flat__ = context__.vals_r("pr_1");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          stan::model::assign(pr_1, pr_1_flat__[(pos__ - 1)],
            "assigning variable pr_1", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lub(stan::model::rvalue(dr, "dr",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)),
        stan::model::rvalue(dr, "dr", stan::model::index_uni(1),
          stan::model::index_uni(2)), pr_1);
      std::vector<Eigen::Matrix<local_scalar_t__,1,-1>> pr_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(m,
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> pr_2_flat__;
        current_statement__ = 15;
        pr_2_flat__ = context__.vals_r("pr_2");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            stan::model::assign(pr_2, pr_2_flat__[(pos__ - 1)],
              "assigning variable pr_2", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_lb(stan::model::rvalue(dr, "dr",
                            stan::model::index_uni(1)), pr_2);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>> pr_3 =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>>(n,
          std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>(m,
            Eigen::Matrix<local_scalar_t__,1,-1>::Constant(k, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> pr_3_flat__;
        current_statement__ = 16;
        pr_3_flat__ = context__.vals_r("pr_3");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
              stan::model::assign(pr_3, pr_3_flat__[(pos__ - 1)],
                "assigning variable pr_3", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write_free_ub(dr, pr_3);
      Eigen::Matrix<local_scalar_t__,-1,-1> pm_1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, k, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> pm_1_flat__;
        current_statement__ = 17;
        pm_1_flat__ = context__.vals_r("pm_1");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            stan::model::assign(pm_1, pm_1_flat__[(pos__ - 1)],
              "assigning variable pm_1", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_lb(stan::model::rvalue(dm, "dm",
                            stan::model::index_uni(1)), pm_1);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> pm_2 =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(n,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, k, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> pm_2_flat__;
        current_statement__ = 18;
        pm_2_flat__ = context__.vals_r("pm_2");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
              stan::model::assign(pm_2, pm_2_flat__[(pos__ - 1)],
                "assigning variable pm_2", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write_free_ub(dm, pm_2);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"p_1", "p_2", "p_3", "p_4", "p_5",
                "p_6", "p_7", "p_8", "p_9", "p_10", "pv_1", "pv_2", "pv_3",
                "pr_1", "pr_2", "pr_3", "pm_1", "pm_2"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"tp_1", "tp_2", "tp_3", "tp_4", "tp_5", "tp_6", "tp_7", "tp_8",
             "tp_9", "tp_10", "tpv_1", "tpv_2", "tpv_3", "tpr_1", "tpr_2",
             "tpr_3", "tpm_1", "tpm_2"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(m),
                  static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(n),
                  static_cast<size_t>(m), static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(m),
                  static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(n),
                  static_cast<size_t>(m), static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(m),
                  static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(n),
                  static_cast<size_t>(m), static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(m),
                  static_cast<size_t>(k)},
                std::vector<size_t>{static_cast<size_t>(n),
                  static_cast<size_t>(m), static_cast<size_t>(k)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(m),
               static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(n),
               static_cast<size_t>(m), static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(m),
               static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(n),
               static_cast<size_t>(m), static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(m),
               static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(n),
               static_cast<size_t>(m), static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(m),
               static_cast<size_t>(k)},
             std::vector<size_t>{static_cast<size_t>(n),
               static_cast<size_t>(m), static_cast<size_t>(k)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_1" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_2" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_3" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_4" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_5" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_6" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_7" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_8" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_9" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
          param_names__.emplace_back(std::string() + "p_10" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "pv_1" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        param_names__.emplace_back(std::string() + "pv_2" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
          param_names__.emplace_back(std::string() + "pv_3" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "pr_1" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        param_names__.emplace_back(std::string() + "pr_2" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
          param_names__.emplace_back(std::string() + "pr_3" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        param_names__.emplace_back(std::string() + "pm_1" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
          param_names__.emplace_back(std::string() + "pm_2" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_1" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_2" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_3" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_4" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_5" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_6" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_7" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_8" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_9" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            param_names__.emplace_back(std::string() + "tp_10" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tpv_1" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          param_names__.emplace_back(std::string() + "tpv_2" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            param_names__.emplace_back(std::string() + "tpv_3" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tpr_1" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          param_names__.emplace_back(std::string() + "tpr_2" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            param_names__.emplace_back(std::string() + "tpr_3" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          param_names__.emplace_back(std::string() + "tpm_1" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            param_names__.emplace_back(std::string() + "tpm_2" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_1" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_2" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_3" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_4" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_5" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_6" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_7" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_8" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_9" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
          param_names__.emplace_back(std::string() + "p_10" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "pv_1" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        param_names__.emplace_back(std::string() + "pv_2" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
          param_names__.emplace_back(std::string() + "pv_3" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      param_names__.emplace_back(std::string() + "pr_1" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        param_names__.emplace_back(std::string() + "pr_2" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
          param_names__.emplace_back(std::string() + "pr_3" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        param_names__.emplace_back(std::string() + "pm_1" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
          param_names__.emplace_back(std::string() + "pm_2" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_1" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_2" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_3" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_4" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_5" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_6" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_7" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_8" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_9" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            param_names__.emplace_back(std::string() + "tp_10" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tpv_1" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          param_names__.emplace_back(std::string() + "tpv_2" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            param_names__.emplace_back(std::string() + "tpv_3" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        param_names__.emplace_back(std::string() + "tpr_1" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          param_names__.emplace_back(std::string() + "tpr_2" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            param_names__.emplace_back(std::string() + "tpr_3" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          param_names__.emplace_back(std::string() + "tpm_1" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= n; ++sym3__) {
            param_names__.emplace_back(std::string() + "tpm_2" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"p_1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_4\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_5\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_6\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_7\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_8\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_9\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"p_10\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"parameters\"},{\"name\":\"pv_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"pv_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}},\"block\":\"parameters\"},{\"name\":\"pv_3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}}},\"block\":\"parameters\"},{\"name\":\"pr_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"pr_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}},\"block\":\"parameters\"},{\"name\":\"pr_3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}}},\"block\":\"parameters\"},{\"name\":\"pm_1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(m) + ",\"cols\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"pm_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(m) + ",\"cols\":" + std::to_string(k) + "}},\"block\":\"parameters\"},{\"name\":\"tp_1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_4\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_5\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_6\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_7\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_8\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_9\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_10\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tpv_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tpv_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"tpv_3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tpr_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tpr_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"tpr_3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tpm_1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(m) + ",\"cols\":" + std::to_string(k) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tpm_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(m) + ",\"cols\":" + std::to_string(k) + "}},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"p_1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_4\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_5\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_6\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_7\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_8\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_9\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"p_10\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"parameters\"},{\"name\":\"pv_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"pv_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}},\"block\":\"parameters\"},{\"name\":\"pv_3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}}},\"block\":\"parameters\"},{\"name\":\"pr_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"pr_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}},\"block\":\"parameters\"},{\"name\":\"pr_3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}}},\"block\":\"parameters\"},{\"name\":\"pm_1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(m) + ",\"cols\":" + std::to_string(k) + "},\"block\":\"parameters\"},{\"name\":\"pm_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(m) + ",\"cols\":" + std::to_string(k) + "}},\"block\":\"parameters\"},{\"name\":\"tp_1\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_4\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_5\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_6\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_7\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_8\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_9\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_10\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(k) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tpv_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tpv_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"tpv_3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tpr_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tpr_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"tpr_3\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(m) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(k) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tpm_1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(m) + ",\"cols\":" + std::to_string(k) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tpm_2\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(m) + ",\"cols\":" + std::to_string(k) + "}},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((((((((((((k + k) + k) + k) + k) + k) +
      k) + k) + (m * k)) + (n * (m * k))) + k) + (m * k)) + (n * (m * k))) +
      k) + (m * k)) + (n * (m * k))) + (m * k)) + (n * (m * k)));
    const size_t num_transformed = emit_transformed_parameters *
      ((((((((((((((((((k + k) + k) + k) + k) + k) + k) + k) + (m * k)) + (n
      * (m * k))) + k) + (m * k)) + (n * (m * k))) + k) + (m * k)) + (n * (m
      * k))) + (m * k)) + (n * (m * k))));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((((((((((((k + k) + k) + k) + k) + k) +
      k) + k) + (m * k)) + (n * (m * k))) + k) + (m * k)) + (n * (m * k))) +
      k) + (m * k)) + (n * (m * k))) + (m * k)) + (n * (m * k)));
    const size_t num_transformed = emit_transformed_parameters *
      ((((((((((((((((((k + k) + k) + k) + k) + k) + k) + k) + (m * k)) + (n
      * (m * k))) + k) + (m * k)) + (n * (m * k))) + k) + (m * k)) + (n * (m
      * k))) + (m * k)) + (n * (m * k))));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = transform_model_namespace::transform_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return transform_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp truncate.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace truncate_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 21> locations_array__ =
  {" (found before start of program)",
  " (in 'truncate.stan', line 6, column 4 to column 11)",
  " (in 'truncate.stan', line 7, column 4 to column 20)",
  " (in 'truncate.stan', line 10, column 4 to column 25)",
  " (in 'truncate.stan', line 11, column 4 to column 28)",
  " (in 'truncate.stan', line 11, column 22 to column 25)",
  " (in 'truncate.stan', line 12, column 4 to column 29)",
  " (in 'truncate.stan', line 12, column 23 to column 27)",
  " (in 'truncate.stan', line 13, column 4 to column 32)",
  " (in 'truncate.stan', line 13, column 26 to column 30)",
  " (in 'truncate.stan', line 13, column 22 to column 25)",
  " (in 'truncate.stan', line 14, column 4 to column 24)",
  " (in 'truncate.stan', line 15, column 4 to column 26)",
  " (in 'truncate.stan', line 15, column 21 to column 23)",
  " (in 'truncate.stan', line 16, column 4 to column 26)",
  " (in 'truncate.stan', line 16, column 22 to column 24)",
  " (in 'truncate.stan', line 17, column 4 to column 28)",
  " (in 'truncate.stan', line 17, column 24 to column 26)",
  " (in 'truncate.stan', line 17, column 21 to column 23)",
  " (in 'truncate.stan', line 2, column 4 to column 10)",
  " (in 'truncate.stan', line 3, column 4 to column 11)"};
class truncate_model final : public model_base_crtp<truncate_model> {
 private:
  int n;
  double x;
 public:
  ~truncate_model() {}
  truncate_model(stan::io::var_context& context__, unsigned int
                 random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "truncate_model_namespace::truncate_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 19;
      context__.validate_dims("data initialization", "n", "int",
        std::vector<size_t>{});
      n = std::numeric_limits<int>::min();
      current_statement__ = 19;
      n = context__.vals_i("n")[(1 - 1)];
      current_statement__ = 20;
      context__.validate_dims("data initialization", "x", "double",
        std::vector<size_t>{});
      x = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 20;
      x = context__.vals_r("x")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1;
  }
  inline std::string model_name() const final {
    return "truncate_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "truncate_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ m = DUMMY_VAR__;
      current_statement__ = 1;
      m = in__.template read<local_scalar_t__>();
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 2;
      y = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      {
        current_statement__ = 3;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x, m, 1));
        current_statement__ = 4;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x, m, 1));
        current_statement__ = 5;
        if (stan::math::logical_lt(x, 0.0)) {
          current_statement__ = 5;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 5;
          lp_accum__.add(-(stan::math::normal_lccdf(0.0, m, 1)));
        }
        current_statement__ = 6;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x, m, 1));
        current_statement__ = 7;
        if (stan::math::logical_gt(x, 10.0)) {
          current_statement__ = 7;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 7;
          lp_accum__.add(-(stan::math::normal_lcdf(10.0, m, 1)));
        }
        current_statement__ = 8;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x, m, 1));
        current_statement__ = 10;
        if (stan::math::logical_lt(x, 0.0)) {
          current_statement__ = 10;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 9;
          if (stan::math::logical_gt(x, 10.0)) {
            current_statement__ = 9;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 9;
            lp_accum__.add(-(stan::math::log_diff_exp(
                               stan::math::normal_lcdf(10.0, m, 1),
                               stan::math::normal_lcdf(0.0, m, 1))));
          }
        }
        current_statement__ = 11;
        lp_accum__.add(stan::math::poisson_lpmf<propto__>(n, y));
        current_statement__ = 12;
        lp_accum__.add(stan::math::poisson_lpmf<propto__>(n, y));
        current_statement__ = 13;
        if (stan::math::logical_lt(n, 10)) {
          current_statement__ = 13;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 13;
          lp_accum__.add(-(stan::math::poisson_lccdf((10 - 1), y)));
        }
        current_statement__ = 14;
        lp_accum__.add(stan::math::poisson_lpmf<propto__>(n, y));
        current_statement__ = 15;
        if (stan::math::logical_gt(n, 20)) {
          current_statement__ = 15;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 15;
          lp_accum__.add(-(stan::math::poisson_lcdf(20, y)));
        }
        current_statement__ = 16;
        lp_accum__.add(stan::math::poisson_lpmf<propto__>(n, y));
        current_statement__ = 18;
        if (stan::math::logical_lt(n, 10)) {
          current_statement__ = 18;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 17;
          if (stan::math::logical_gt(n, 20)) {
            current_statement__ = 17;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 17;
            lp_accum__.add(-(stan::math::log_diff_exp(
                               stan::math::poisson_lcdf(20, y),
                               stan::math::poisson_lcdf((10 - 1), y))));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "truncate_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ m = DUMMY_VAR__;
      current_statement__ = 1;
      m = in__.template read<local_scalar_t__>();
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 2;
      y = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      {
        current_statement__ = 3;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x, m, 1));
        current_statement__ = 4;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x, m, 1));
        current_statement__ = 5;
        if (stan::math::logical_lt(x, 0.0)) {
          current_statement__ = 5;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 5;
          lp_accum__.add(-(stan::math::normal_lccdf(0.0, m, 1)));
        }
        current_statement__ = 6;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x, m, 1));
        current_statement__ = 7;
        if (stan::math::logical_gt(x, 10.0)) {
          current_statement__ = 7;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 7;
          lp_accum__.add(-(stan::math::normal_lcdf(10.0, m, 1)));
        }
        current_statement__ = 8;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x, m, 1));
        current_statement__ = 10;
        if (stan::math::logical_lt(x, 0.0)) {
          current_statement__ = 10;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 9;
          if (stan::math::logical_gt(x, 10.0)) {
            current_statement__ = 9;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 9;
            lp_accum__.add(-(stan::math::log_diff_exp(
                               stan::math::normal_lcdf(10.0, m, 1),
                               stan::math::normal_lcdf(0.0, m, 1))));
          }
        }
        current_statement__ = 11;
        lp_accum__.add(stan::math::poisson_lpmf<propto__>(n, y));
        current_statement__ = 12;
        lp_accum__.add(stan::math::poisson_lpmf<propto__>(n, y));
        current_statement__ = 13;
        if (stan::math::logical_lt(n, 10)) {
          current_statement__ = 13;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 13;
          lp_accum__.add(-(stan::math::poisson_lccdf((10 - 1), y)));
        }
        current_statement__ = 14;
        lp_accum__.add(stan::math::poisson_lpmf<propto__>(n, y));
        current_statement__ = 15;
        if (stan::math::logical_gt(n, 20)) {
          current_statement__ = 15;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 15;
          lp_accum__.add(-(stan::math::poisson_lcdf(20, y)));
        }
        current_statement__ = 16;
        lp_accum__.add(stan::math::poisson_lpmf<propto__>(n, y));
        current_statement__ = 18;
        if (stan::math::logical_lt(n, 10)) {
          current_statement__ = 18;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 17;
          if (stan::math::logical_gt(n, 20)) {
            current_statement__ = 17;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 17;
            lp_accum__.add(-(stan::math::log_diff_exp(
                               stan::math::poisson_lcdf(20, y),
                               stan::math::poisson_lcdf((10 - 1), y))));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "truncate_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double m = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      m = in__.template read<local_scalar_t__>();
      double y = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      y = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      out__.write(m);
      out__.write(y);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ m = DUMMY_VAR__;
      current_statement__ = 1;
      m = in__.read<local_scalar_t__>();
      out__.write(m);
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 2;
      y = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "m", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "y", "double",
        std::vector<size_t>{});
      local_scalar_t__ m = DUMMY_VAR__;
      current_statement__ = 1;
      m = context__.vals_r("m")[(1 - 1)];
      out__.write(m);
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 2;
      y = context__.vals_r("y")[(1 - 1)];
      out__.write_free_lb(0, y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"m", "y"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "m");
    param_names__.emplace_back(std::string() + "y");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "m");
    param_names__.emplace_back(std::string() + "y");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"m\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"m\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + 1);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + 1);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = truncate_model_namespace::truncate_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return truncate_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp udf_tilde_stmt_conflict.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace udf_tilde_stmt_conflict_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 5> locations_array__ =
  {" (found before start of program)",
  " (in 'udf_tilde_stmt_conflict.stan', line 7, column 4 to column 11)",
  " (in 'udf_tilde_stmt_conflict.stan', line 10, column 4 to column 20)",
  " (in 'udf_tilde_stmt_conflict.stan', line 3, column 4 to column 21)",
  " (in 'udf_tilde_stmt_conflict.stan', line 2, column 22 to line 4, column 3)"};
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__> normal(const T0__& a, std::ostream* pstream__);
// real normal(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__> normal(const T0__& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 3;
    return stan::math::square(a);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class udf_tilde_stmt_conflict_model final : public model_base_crtp<udf_tilde_stmt_conflict_model> {
 private:
  
 public:
  ~udf_tilde_stmt_conflict_model() {}
  udf_tilde_stmt_conflict_model(stan::io::var_context& context__,
                                unsigned int random_seed__ = 0, std::ostream*
                                pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "udf_tilde_stmt_conflict_model_namespace::udf_tilde_stmt_conflict_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 1;
  }
  inline std::string model_name() const final {
    return "udf_tilde_stmt_conflict_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "udf_tilde_stmt_conflict_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = in__.template read<local_scalar_t__>();
      {
        current_statement__ = 2;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x, 0, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "udf_tilde_stmt_conflict_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = in__.template read<local_scalar_t__>();
      {
        current_statement__ = 2;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x, 0, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "udf_tilde_stmt_conflict_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double x = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      x = in__.template read<local_scalar_t__>();
      out__.write(x);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = in__.read<local_scalar_t__>();
      out__.write(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "x", "double",
        std::vector<size_t>{});
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = context__.vals_r("x")[(1 - 1)];
      out__.write(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"x"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = udf_tilde_stmt_conflict_model_namespace::udf_tilde_stmt_conflict_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return udf_tilde_stmt_conflict_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp user_constrain.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace user_constrain_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 5> locations_array__ =
  {" (found before start of program)",
  " (in 'user_constrain.stan', line 7, column 2 to column 18)",
  " (in 'user_constrain.stan', line 10, column 2 to column 19)",
  " (in 'user_constrain.stan', line 3, column 4 to column 13)",
  " (in 'user_constrain.stan', line 2, column 36 to line 4, column 3)"};
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>* = nullptr>
stan::promote_args_t<T0__, T1__>
lb_constrain(const T0__& x, const T1__& y, std::ostream* pstream__);
// real lb_constrain(real, real)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>*>
stan::promote_args_t<T0__, T1__>
lb_constrain(const T0__& x, const T1__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 3;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class user_constrain_model final : public model_base_crtp<user_constrain_model> {
 private:
  
 public:
  ~user_constrain_model() {}
  user_constrain_model(stan::io::var_context& context__, unsigned int
                       random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "user_constrain_model_namespace::user_constrain_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 1;
  }
  inline std::string model_name() const final {
    return "user_constrain_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "user_constrain_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      {
        current_statement__ = 2;
        lp_accum__.add(stan::math::std_normal_lpdf<propto__>(x));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "user_constrain_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      {
        current_statement__ = 2;
        lp_accum__.add(stan::math::std_normal_lpdf<propto__>(x));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "user_constrain_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double x = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      x = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      out__.write(x);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "x", "double",
        std::vector<size_t>{});
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = context__.vals_r("x")[(1 - 1)];
      out__.write_free_lb(0, x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"x"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = user_constrain_model_namespace::user_constrain_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return user_constrain_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp variable_named_context.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace variable_named_context_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 7> locations_array__ =
  {" (found before start of program)",
  " (in 'variable_named_context.stan', line 7, column 2 to column 10)",
  " (in 'variable_named_context.stan', line 8, column 2 to column 22)",
  " (in 'variable_named_context.stan', line 12, column 2 to column 29)",
  " (in 'variable_named_context.stan', line 2, column 2 to column 17)",
  " (in 'variable_named_context.stan', line 3, column 9 to column 10)",
  " (in 'variable_named_context.stan', line 3, column 2 to column 20)"};
class variable_named_context_model final : public model_base_crtp<variable_named_context_model> {
 private:
  int N;
  Eigen::Matrix<double,-1,1> context_data__;
  Eigen::Map<Eigen::Matrix<double,-1,1>> context{nullptr, 0};
 public:
  ~variable_named_context_model() {}
  variable_named_context_model(stan::io::var_context& context__, unsigned int
                               random_seed__ = 0, std::ostream*
                               pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "variable_named_context_model_namespace::variable_named_context_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 4;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 4;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 5;
      stan::math::validate_non_negative_index("context", "N", N);
      current_statement__ = 6;
      context__.validate_dims("data initialization", "context", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      context_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                         std::numeric_limits<double>::quiet_NaN());
      new (&context)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(context_data__.data(), N);
      {
        std::vector<local_scalar_t__> context_flat__;
        current_statement__ = 6;
        context_flat__ = context__.vals_r("context");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(context, context_flat__[(pos__ - 1)],
            "assigning variable context", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1;
  }
  inline std::string model_name() const final {
    return "variable_named_context_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "variable_named_context_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      {
        current_statement__ = 3;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(context, mu, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "variable_named_context_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      {
        current_statement__ = 3;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(context, mu, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "variable_named_context_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double mu = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      double sigma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      out__.write(mu);
      out__.write(sigma);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.read<local_scalar_t__>();
      out__.write(mu);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 2;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mu", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "sigma", "double",
        std::vector<size_t>{});
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = context__.vals_r("mu")[(1 - 1)];
      out__.write(mu);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 2;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      out__.write_free_lb(0, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mu", "sigma"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mu");
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mu");
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + 1);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + 1);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = variable_named_context_model_namespace::variable_named_context_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return variable_named_context_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --print-cpp vector_truncate.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace vector_truncate_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 94> locations_array__ =
  {" (found before start of program)",
  " (in 'vector_truncate.stan', line 8, column 2 to column 10)",
  " (in 'vector_truncate.stan', line 9, column 2 to column 22)",
  " (in 'vector_truncate.stan', line 11, column 2 to column 22)",
  " (in 'vector_truncate.stan', line 12, column 2 to column 29)",
  " (in 'vector_truncate.stan', line 15, column 2 to column 31)",
  " (in 'vector_truncate.stan', line 15, column 26 to column 27)",
  " (in 'vector_truncate.stan', line 18, column 4 to column 36)",
  " (in 'vector_truncate.stan', line 18, column 31 to column 32)",
  " (in 'vector_truncate.stan', line 17, column 19 to line 19, column 3)",
  " (in 'vector_truncate.stan', line 17, column 2 to line 19, column 3)",
  " (in 'vector_truncate.stan', line 21, column 2 to column 32)",
  " (in 'vector_truncate.stan', line 21, column 29 to column 30)",
  " (in 'vector_truncate.stan', line 24, column 4 to column 37)",
  " (in 'vector_truncate.stan', line 24, column 34 to column 35)",
  " (in 'vector_truncate.stan', line 23, column 19 to line 25, column 3)",
  " (in 'vector_truncate.stan', line 23, column 2 to line 25, column 3)",
  " (in 'vector_truncate.stan', line 27, column 2 to column 32)",
  " (in 'vector_truncate.stan', line 27, column 29 to column 30)",
  " (in 'vector_truncate.stan', line 27, column 26 to column 27)",
  " (in 'vector_truncate.stan', line 30, column 4 to column 37)",
  " (in 'vector_truncate.stan', line 30, column 34 to column 35)",
  " (in 'vector_truncate.stan', line 30, column 31 to column 32)",
  " (in 'vector_truncate.stan', line 29, column 19 to line 31, column 3)",
  " (in 'vector_truncate.stan', line 29, column 2 to line 31, column 3)",
  " (in 'vector_truncate.stan', line 35, column 2 to column 38)",
  " (in 'vector_truncate.stan', line 35, column 33 to column 34)",
  " (in 'vector_truncate.stan', line 38, column 4 to column 46)",
  " (in 'vector_truncate.stan', line 38, column 41 to column 42)",
  " (in 'vector_truncate.stan', line 37, column 19 to line 39, column 3)",
  " (in 'vector_truncate.stan', line 37, column 2 to line 39, column 3)",
  " (in 'vector_truncate.stan', line 41, column 2 to column 39)",
  " (in 'vector_truncate.stan', line 41, column 36 to column 37)",
  " (in 'vector_truncate.stan', line 44, column 4 to column 47)",
  " (in 'vector_truncate.stan', line 44, column 44 to column 45)",
  " (in 'vector_truncate.stan', line 43, column 19 to line 45, column 3)",
  " (in 'vector_truncate.stan', line 43, column 2 to line 45, column 3)",
  " (in 'vector_truncate.stan', line 47, column 2 to column 39)",
  " (in 'vector_truncate.stan', line 47, column 36 to column 37)",
  " (in 'vector_truncate.stan', line 47, column 33 to column 34)",
  " (in 'vector_truncate.stan', line 50, column 4 to column 47)",
  " (in 'vector_truncate.stan', line 50, column 44 to column 45)",
  " (in 'vector_truncate.stan', line 50, column 41 to column 42)",
  " (in 'vector_truncate.stan', line 49, column 19 to line 51, column 3)",
  " (in 'vector_truncate.stan', line 49, column 2 to line 51, column 3)",
  " (in 'vector_truncate.stan', line 55, column 2 to column 38)",
  " (in 'vector_truncate.stan', line 55, column 33 to column 34)",
  " (in 'vector_truncate.stan', line 58, column 4 to column 46)",
  " (in 'vector_truncate.stan', line 58, column 41 to column 42)",
  " (in 'vector_truncate.stan', line 57, column 19 to line 59, column 3)",
  " (in 'vector_truncate.stan', line 57, column 2 to line 59, column 3)",
  " (in 'vector_truncate.stan', line 61, column 2 to column 39)",
  " (in 'vector_truncate.stan', line 61, column 36 to column 37)",
  " (in 'vector_truncate.stan', line 64, column 4 to column 47)",
  " (in 'vector_truncate.stan', line 64, column 44 to column 45)",
  " (in 'vector_truncate.stan', line 63, column 19 to line 65, column 3)",
  " (in 'vector_truncate.stan', line 63, column 2 to line 65, column 3)",
  " (in 'vector_truncate.stan', line 67, column 2 to column 39)",
  " (in 'vector_truncate.stan', line 67, column 36 to column 37)",
  " (in 'vector_truncate.stan', line 67, column 33 to column 34)",
  " (in 'vector_truncate.stan', line 70, column 4 to column 47)",
  " (in 'vector_truncate.stan', line 70, column 44 to column 45)",
  " (in 'vector_truncate.stan', line 70, column 41 to column 42)",
  " (in 'vector_truncate.stan', line 69, column 19 to line 71, column 3)",
  " (in 'vector_truncate.stan', line 69, column 2 to line 71, column 3)",
  " (in 'vector_truncate.stan', line 75, column 2 to column 45)",
  " (in 'vector_truncate.stan', line 75, column 40 to column 41)",
  " (in 'vector_truncate.stan', line 78, column 4 to column 56)",
  " (in 'vector_truncate.stan', line 78, column 51 to column 52)",
  " (in 'vector_truncate.stan', line 77, column 19 to line 79, column 3)",
  " (in 'vector_truncate.stan', line 77, column 2 to line 79, column 3)",
  " (in 'vector_truncate.stan', line 81, column 2 to column 46)",
  " (in 'vector_truncate.stan', line 81, column 43 to column 44)",
  " (in 'vector_truncate.stan', line 84, column 4 to column 57)",
  " (in 'vector_truncate.stan', line 84, column 54 to column 55)",
  " (in 'vector_truncate.stan', line 83, column 19 to line 85, column 3)",
  " (in 'vector_truncate.stan', line 83, column 2 to line 85, column 3)",
  " (in 'vector_truncate.stan', line 88, column 2 to column 54)",
  " (in 'vector_truncate.stan', line 88, column 13 to column 26)",
  " (in 'vector_truncate.stan', line 88, column 28 to column 44)",
  " (in 'vector_truncate.stan', line 88, column 51 to column 52)",
  " (in 'vector_truncate.stan', line 88, column 48 to column 49)",
  " (in 'vector_truncate.stan', line 91, column 4 to column 57)",
  " (in 'vector_truncate.stan', line 91, column 54 to column 55)",
  " (in 'vector_truncate.stan', line 91, column 51 to column 52)",
  " (in 'vector_truncate.stan', line 90, column 19 to line 92, column 3)",
  " (in 'vector_truncate.stan', line 90, column 2 to line 92, column 3)",
  " (in 'vector_truncate.stan', line 2, column 2 to column 17)",
  " (in 'vector_truncate.stan', line 3, column 2 to column 9)",
  " (in 'vector_truncate.stan', line 4, column 2 to column 18)",
  " (in 'vector_truncate.stan', line 5, column 8 to column 9)",
  " (in 'vector_truncate.stan', line 5, column 2 to column 36)",
  " (in 'vector_truncate.stan', line 11, column 9 to column 10)",
  " (in 'vector_truncate.stan', line 12, column 13 to column 14)"};
class vector_truncate_model final : public model_base_crtp<vector_truncate_model> {
 private:
  int N;
  double L;
  double U;
  std::vector<double> y;
 public:
  ~vector_truncate_model() {}
  vector_truncate_model(stan::io::var_context& context__, unsigned int
                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "vector_truncate_model_namespace::vector_truncate_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 87;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 87;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 87;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 88;
      context__.validate_dims("data initialization", "L", "double",
        std::vector<size_t>{});
      L = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 88;
      L = context__.vals_r("L")[(1 - 1)];
      current_statement__ = 89;
      context__.validate_dims("data initialization", "U", "double",
        std::vector<size_t>{});
      U = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 89;
      U = context__.vals_r("U")[(1 - 1)];
      current_statement__ = 89;
      stan::math::check_greater_or_equal(function__, "U", U, L);
      current_statement__ = 90;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 91;
      context__.validate_dims("data initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      y = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 91;
      y = context__.vals_r("y");
      current_statement__ = 91;
      stan::math::check_greater_or_equal(function__, "y", y, L);
      current_statement__ = 91;
      stan::math::check_less_or_equal(function__, "y", y, U);
      current_statement__ = 92;
      stan::math::validate_non_negative_index("vector_mu", "N", N);
      current_statement__ = 93;
      stan::math::validate_non_negative_index("vector_sigma", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + N + N;
  }
  inline std::string model_name() const final {
    return "vector_truncate_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "vector_truncate_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> vector_mu =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 3;
      vector_mu = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<local_scalar_t__,1,-1> vector_sigma =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 4;
      vector_sigma = in__.template read<
                       Eigen::Matrix<local_scalar_t__,1,-1>>(N);
      {
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, mu, sigma));
        current_statement__ = 6;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 6;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 6;
          lp_accum__.add(-((stan::math::normal_lccdf(L, mu, sigma) *
            stan::math::size(y))));
        }
        current_statement__ = 10;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 7;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)), mu, sigma));
          current_statement__ = 8;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 8;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 8;
            lp_accum__.add(-(stan::math::normal_lccdf(L, mu, sigma)));
          }
        }
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, mu, sigma));
        current_statement__ = 12;
        if (stan::math::logical_gt(stan::math::max(y), U)) {
          current_statement__ = 12;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 12;
          lp_accum__.add(-((stan::math::normal_lcdf(U, mu, sigma) *
            stan::math::size(y))));
        }
        current_statement__ = 16;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 13;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)), mu, sigma));
          current_statement__ = 14;
          if (stan::math::logical_gt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
            current_statement__ = 14;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 14;
            lp_accum__.add(-(stan::math::normal_lcdf(U, mu, sigma)));
          }
        }
        current_statement__ = 17;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, mu, sigma));
        current_statement__ = 19;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 19;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 18;
          if (stan::math::logical_gt(stan::math::max(y), U)) {
            current_statement__ = 18;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 18;
            lp_accum__.add(-((stan::math::log_diff_exp(
                                stan::math::normal_lcdf(U, mu, sigma),
                                stan::math::normal_lcdf(L, mu, sigma)) *
              stan::math::size(y))));
          }
        }
        current_statement__ = 24;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 20;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)), mu, sigma));
          current_statement__ = 22;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 22;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 21;
            if (stan::math::logical_gt(
                  stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
              current_statement__ = 21;
              lp_accum__.add(stan::math::negative_infinity());
            } else {
              current_statement__ = 21;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U, mu, sigma),
                                 stan::math::normal_lcdf(L, mu, sigma))));
            }
          }
        }
        current_statement__ = 25;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, vector_mu, sigma));
        current_statement__ = 26;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 26;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 26;
          lp_accum__.add(-(stan::math::normal_lccdf(L, vector_mu, sigma)));
        }
        current_statement__ = 30;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 27;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_mu, "vector_mu",
                             stan::model::index_uni(n)), sigma));
          current_statement__ = 28;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 28;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 28;
            lp_accum__.add(-(stan::math::normal_lccdf(L,
                               stan::model::rvalue(vector_mu, "vector_mu",
                                 stan::model::index_uni(n)), sigma)));
          }
        }
        current_statement__ = 31;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, vector_mu, sigma));
        current_statement__ = 32;
        if (stan::math::logical_gt(stan::math::max(y), U)) {
          current_statement__ = 32;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 32;
          lp_accum__.add(-(stan::math::normal_lcdf(U, vector_mu, sigma)));
        }
        current_statement__ = 36;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 33;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_mu, "vector_mu",
                             stan::model::index_uni(n)), sigma));
          current_statement__ = 34;
          if (stan::math::logical_gt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
            current_statement__ = 34;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 34;
            lp_accum__.add(-(stan::math::normal_lcdf(U,
                               stan::model::rvalue(vector_mu, "vector_mu",
                                 stan::model::index_uni(n)), sigma)));
          }
        }
        current_statement__ = 37;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, vector_mu, sigma));
        current_statement__ = 39;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 39;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 38;
          if (stan::math::logical_gt(stan::math::max(y), U)) {
            current_statement__ = 38;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 38;
            for (int sym2__ = 1; sym2__ <=
                 stan::math::size(vector_mu); ++sym2__) {
              current_statement__ = 38;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U, vector_mu[(sym2__
                                   - 1)], sigma),
                                 stan::math::normal_lcdf(L, vector_mu[(sym2__
                                   - 1)], sigma))));
            }
          }
        }
        current_statement__ = 44;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 40;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_mu, "vector_mu",
                             stan::model::index_uni(n)), sigma));
          current_statement__ = 42;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 42;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 41;
            if (stan::math::logical_gt(
                  stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
              current_statement__ = 41;
              lp_accum__.add(stan::math::negative_infinity());
            } else {
              current_statement__ = 41;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U,
                                   stan::model::rvalue(vector_mu,
                                     "vector_mu", stan::model::index_uni(n)),
                                   sigma),
                                 stan::math::normal_lcdf(L,
                                   stan::model::rvalue(vector_mu,
                                     "vector_mu", stan::model::index_uni(n)),
                                   sigma))));
            }
          }
        }
        current_statement__ = 45;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, mu, vector_sigma));
        current_statement__ = 46;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 46;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 46;
          lp_accum__.add(-(stan::math::normal_lccdf(L, mu, vector_sigma)));
        }
        current_statement__ = 50;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 47;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)), mu,
                           stan::model::rvalue(vector_sigma, "vector_sigma",
                             stan::model::index_uni(n))));
          current_statement__ = 48;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 48;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 48;
            lp_accum__.add(-(stan::math::normal_lccdf(L, mu,
                               stan::model::rvalue(vector_sigma,
                                 "vector_sigma", stan::model::index_uni(n)))));
          }
        }
        current_statement__ = 51;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, mu, vector_sigma));
        current_statement__ = 52;
        if (stan::math::logical_gt(stan::math::max(y), U)) {
          current_statement__ = 52;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 52;
          lp_accum__.add(-(stan::math::normal_lcdf(U, mu, vector_sigma)));
        }
        current_statement__ = 56;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 53;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)), mu,
                           stan::model::rvalue(vector_sigma, "vector_sigma",
                             stan::model::index_uni(n))));
          current_statement__ = 54;
          if (stan::math::logical_gt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
            current_statement__ = 54;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 54;
            lp_accum__.add(-(stan::math::normal_lcdf(U, mu,
                               stan::model::rvalue(vector_sigma,
                                 "vector_sigma", stan::model::index_uni(n)))));
          }
        }
        current_statement__ = 57;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, mu, vector_sigma));
        current_statement__ = 59;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 59;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 58;
          if (stan::math::logical_gt(stan::math::max(y), U)) {
            current_statement__ = 58;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 58;
            for (int sym2__ = 1; sym2__ <=
                 stan::math::size(vector_sigma); ++sym2__) {
              current_statement__ = 58;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U, mu,
                                   vector_sigma[(sym2__ - 1)]),
                                 stan::math::normal_lcdf(L, mu,
                                   vector_sigma[(sym2__ - 1)]))));
            }
          }
        }
        current_statement__ = 64;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 60;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)), mu,
                           stan::model::rvalue(vector_sigma, "vector_sigma",
                             stan::model::index_uni(n))));
          current_statement__ = 62;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 62;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 61;
            if (stan::math::logical_gt(
                  stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
              current_statement__ = 61;
              lp_accum__.add(stan::math::negative_infinity());
            } else {
              current_statement__ = 61;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U, mu,
                                   stan::model::rvalue(vector_sigma,
                                     "vector_sigma",
                                     stan::model::index_uni(n))),
                                 stan::math::normal_lcdf(L, mu,
                                   stan::model::rvalue(vector_sigma,
                                     "vector_sigma",
                                     stan::model::index_uni(n))))));
            }
          }
        }
        current_statement__ = 65;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, vector_mu,
                         vector_sigma));
        current_statement__ = 66;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 66;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 66;
          lp_accum__.add(-(stan::math::normal_lccdf(L, vector_mu,
                             vector_sigma)));
        }
        current_statement__ = 70;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 67;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_mu, "vector_mu",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_sigma, "vector_sigma",
                             stan::model::index_uni(n))));
          current_statement__ = 68;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 68;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 68;
            lp_accum__.add(-(stan::math::normal_lccdf(L,
                               stan::model::rvalue(vector_mu, "vector_mu",
                                 stan::model::index_uni(n)),
                               stan::model::rvalue(vector_sigma,
                                 "vector_sigma", stan::model::index_uni(n)))));
          }
        }
        current_statement__ = 71;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, vector_mu,
                         vector_sigma));
        current_statement__ = 72;
        if (stan::math::logical_gt(stan::math::max(y), U)) {
          current_statement__ = 72;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 72;
          lp_accum__.add(-(stan::math::normal_lcdf(U, vector_mu, vector_sigma)));
        }
        current_statement__ = 76;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 73;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_mu, "vector_mu",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_sigma, "vector_sigma",
                             stan::model::index_uni(n))));
          current_statement__ = 74;
          if (stan::math::logical_gt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
            current_statement__ = 74;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 74;
            lp_accum__.add(-(stan::math::normal_lcdf(U,
                               stan::model::rvalue(vector_mu, "vector_mu",
                                 stan::model::index_uni(n)),
                               stan::model::rvalue(vector_sigma,
                                 "vector_sigma", stan::model::index_uni(n)))));
          }
        }
        current_statement__ = 77;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(vector_mu, 4),
                         stan::math::add(vector_sigma, 1)));
        current_statement__ = 81;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 81;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 80;
          if (stan::math::logical_gt(stan::math::max(y), U)) {
            current_statement__ = 80;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            Eigen::Matrix<local_scalar_t__,-1,1> sym2__;
            current_statement__ = 78;
            stan::model::assign(sym2__, stan::math::multiply(vector_mu, 4),
              "assigning variable sym2__");
            Eigen::Matrix<local_scalar_t__,1,-1> sym1__;
            current_statement__ = 79;
            stan::model::assign(sym1__, stan::math::add(vector_sigma, 1),
              "assigning variable sym1__");
            current_statement__ = 80;
            for (int sym4__ = 1; sym4__ <= stan::math::size(sym2__); ++sym4__) {
              current_statement__ = 80;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U, sym2__[(sym4__ -
                                   1)], sym1__[(sym4__ - 1)]),
                                 stan::math::normal_lcdf(L, sym2__[(sym4__ -
                                   1)], sym1__[(sym4__ - 1)]))));
            }
          }
        }
        current_statement__ = 86;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 82;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_mu, "vector_mu",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_sigma, "vector_sigma",
                             stan::model::index_uni(n))));
          current_statement__ = 84;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 84;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 83;
            if (stan::math::logical_gt(
                  stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
              current_statement__ = 83;
              lp_accum__.add(stan::math::negative_infinity());
            } else {
              current_statement__ = 83;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U,
                                   stan::model::rvalue(vector_mu,
                                     "vector_mu", stan::model::index_uni(n)),
                                   stan::model::rvalue(vector_sigma,
                                     "vector_sigma",
                                     stan::model::index_uni(n))),
                                 stan::math::normal_lcdf(L,
                                   stan::model::rvalue(vector_mu,
                                     "vector_mu", stan::model::index_uni(n)),
                                   stan::model::rvalue(vector_sigma,
                                     "vector_sigma",
                                     stan::model::index_uni(n))))));
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "vector_truncate_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> vector_mu =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 3;
      vector_mu = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<local_scalar_t__,1,-1> vector_sigma =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 4;
      vector_sigma = in__.template read<
                       Eigen::Matrix<local_scalar_t__,1,-1>>(N);
      {
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, mu, sigma));
        current_statement__ = 6;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 6;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 6;
          lp_accum__.add(-((stan::math::normal_lccdf(L, mu, sigma) *
            stan::math::size(y))));
        }
        current_statement__ = 10;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 7;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)), mu, sigma));
          current_statement__ = 8;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 8;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 8;
            lp_accum__.add(-(stan::math::normal_lccdf(L, mu, sigma)));
          }
        }
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, mu, sigma));
        current_statement__ = 12;
        if (stan::math::logical_gt(stan::math::max(y), U)) {
          current_statement__ = 12;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 12;
          lp_accum__.add(-((stan::math::normal_lcdf(U, mu, sigma) *
            stan::math::size(y))));
        }
        current_statement__ = 16;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 13;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)), mu, sigma));
          current_statement__ = 14;
          if (stan::math::logical_gt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
            current_statement__ = 14;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 14;
            lp_accum__.add(-(stan::math::normal_lcdf(U, mu, sigma)));
          }
        }
        current_statement__ = 17;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, mu, sigma));
        current_statement__ = 19;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 19;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 18;
          if (stan::math::logical_gt(stan::math::max(y), U)) {
            current_statement__ = 18;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 18;
            lp_accum__.add(-((stan::math::log_diff_exp(
                                stan::math::normal_lcdf(U, mu, sigma),
                                stan::math::normal_lcdf(L, mu, sigma)) *
              stan::math::size(y))));
          }
        }
        current_statement__ = 24;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 20;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)), mu, sigma));
          current_statement__ = 22;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 22;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 21;
            if (stan::math::logical_gt(
                  stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
              current_statement__ = 21;
              lp_accum__.add(stan::math::negative_infinity());
            } else {
              current_statement__ = 21;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U, mu, sigma),
                                 stan::math::normal_lcdf(L, mu, sigma))));
            }
          }
        }
        current_statement__ = 25;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, vector_mu, sigma));
        current_statement__ = 26;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 26;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 26;
          lp_accum__.add(-(stan::math::normal_lccdf(L, vector_mu, sigma)));
        }
        current_statement__ = 30;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 27;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_mu, "vector_mu",
                             stan::model::index_uni(n)), sigma));
          current_statement__ = 28;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 28;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 28;
            lp_accum__.add(-(stan::math::normal_lccdf(L,
                               stan::model::rvalue(vector_mu, "vector_mu",
                                 stan::model::index_uni(n)), sigma)));
          }
        }
        current_statement__ = 31;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, vector_mu, sigma));
        current_statement__ = 32;
        if (stan::math::logical_gt(stan::math::max(y), U)) {
          current_statement__ = 32;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 32;
          lp_accum__.add(-(stan::math::normal_lcdf(U, vector_mu, sigma)));
        }
        current_statement__ = 36;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 33;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_mu, "vector_mu",
                             stan::model::index_uni(n)), sigma));
          current_statement__ = 34;
          if (stan::math::logical_gt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
            current_statement__ = 34;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 34;
            lp_accum__.add(-(stan::math::normal_lcdf(U,
                               stan::model::rvalue(vector_mu, "vector_mu",
                                 stan::model::index_uni(n)), sigma)));
          }
        }
        current_statement__ = 37;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, vector_mu, sigma));
        current_statement__ = 39;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 39;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 38;
          if (stan::math::logical_gt(stan::math::max(y), U)) {
            current_statement__ = 38;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 38;
            for (int sym2__ = 1; sym2__ <=
                 stan::math::size(vector_mu); ++sym2__) {
              current_statement__ = 38;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U, vector_mu[(sym2__
                                   - 1)], sigma),
                                 stan::math::normal_lcdf(L, vector_mu[(sym2__
                                   - 1)], sigma))));
            }
          }
        }
        current_statement__ = 44;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 40;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_mu, "vector_mu",
                             stan::model::index_uni(n)), sigma));
          current_statement__ = 42;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 42;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 41;
            if (stan::math::logical_gt(
                  stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
              current_statement__ = 41;
              lp_accum__.add(stan::math::negative_infinity());
            } else {
              current_statement__ = 41;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U,
                                   stan::model::rvalue(vector_mu,
                                     "vector_mu", stan::model::index_uni(n)),
                                   sigma),
                                 stan::math::normal_lcdf(L,
                                   stan::model::rvalue(vector_mu,
                                     "vector_mu", stan::model::index_uni(n)),
                                   sigma))));
            }
          }
        }
        current_statement__ = 45;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, mu, vector_sigma));
        current_statement__ = 46;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 46;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 46;
          lp_accum__.add(-(stan::math::normal_lccdf(L, mu, vector_sigma)));
        }
        current_statement__ = 50;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 47;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)), mu,
                           stan::model::rvalue(vector_sigma, "vector_sigma",
                             stan::model::index_uni(n))));
          current_statement__ = 48;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 48;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 48;
            lp_accum__.add(-(stan::math::normal_lccdf(L, mu,
                               stan::model::rvalue(vector_sigma,
                                 "vector_sigma", stan::model::index_uni(n)))));
          }
        }
        current_statement__ = 51;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, mu, vector_sigma));
        current_statement__ = 52;
        if (stan::math::logical_gt(stan::math::max(y), U)) {
          current_statement__ = 52;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 52;
          lp_accum__.add(-(stan::math::normal_lcdf(U, mu, vector_sigma)));
        }
        current_statement__ = 56;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 53;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)), mu,
                           stan::model::rvalue(vector_sigma, "vector_sigma",
                             stan::model::index_uni(n))));
          current_statement__ = 54;
          if (stan::math::logical_gt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
            current_statement__ = 54;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 54;
            lp_accum__.add(-(stan::math::normal_lcdf(U, mu,
                               stan::model::rvalue(vector_sigma,
                                 "vector_sigma", stan::model::index_uni(n)))));
          }
        }
        current_statement__ = 57;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, mu, vector_sigma));
        current_statement__ = 59;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 59;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 58;
          if (stan::math::logical_gt(stan::math::max(y), U)) {
            current_statement__ = 58;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 58;
            for (int sym2__ = 1; sym2__ <=
                 stan::math::size(vector_sigma); ++sym2__) {
              current_statement__ = 58;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U, mu,
                                   vector_sigma[(sym2__ - 1)]),
                                 stan::math::normal_lcdf(L, mu,
                                   vector_sigma[(sym2__ - 1)]))));
            }
          }
        }
        current_statement__ = 64;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 60;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)), mu,
                           stan::model::rvalue(vector_sigma, "vector_sigma",
                             stan::model::index_uni(n))));
          current_statement__ = 62;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 62;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 61;
            if (stan::math::logical_gt(
                  stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
              current_statement__ = 61;
              lp_accum__.add(stan::math::negative_infinity());
            } else {
              current_statement__ = 61;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U, mu,
                                   stan::model::rvalue(vector_sigma,
                                     "vector_sigma",
                                     stan::model::index_uni(n))),
                                 stan::math::normal_lcdf(L, mu,
                                   stan::model::rvalue(vector_sigma,
                                     "vector_sigma",
                                     stan::model::index_uni(n))))));
            }
          }
        }
        current_statement__ = 65;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, vector_mu,
                         vector_sigma));
        current_statement__ = 66;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 66;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 66;
          lp_accum__.add(-(stan::math::normal_lccdf(L, vector_mu,
                             vector_sigma)));
        }
        current_statement__ = 70;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 67;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_mu, "vector_mu",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_sigma, "vector_sigma",
                             stan::model::index_uni(n))));
          current_statement__ = 68;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 68;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 68;
            lp_accum__.add(-(stan::math::normal_lccdf(L,
                               stan::model::rvalue(vector_mu, "vector_mu",
                                 stan::model::index_uni(n)),
                               stan::model::rvalue(vector_sigma,
                                 "vector_sigma", stan::model::index_uni(n)))));
          }
        }
        current_statement__ = 71;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, vector_mu,
                         vector_sigma));
        current_statement__ = 72;
        if (stan::math::logical_gt(stan::math::max(y), U)) {
          current_statement__ = 72;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 72;
          lp_accum__.add(-(stan::math::normal_lcdf(U, vector_mu, vector_sigma)));
        }
        current_statement__ = 76;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 73;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_mu, "vector_mu",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_sigma, "vector_sigma",
                             stan::model::index_uni(n))));
          current_statement__ = 74;
          if (stan::math::logical_gt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
            current_statement__ = 74;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 74;
            lp_accum__.add(-(stan::math::normal_lcdf(U,
                               stan::model::rvalue(vector_mu, "vector_mu",
                                 stan::model::index_uni(n)),
                               stan::model::rvalue(vector_sigma,
                                 "vector_sigma", stan::model::index_uni(n)))));
          }
        }
        current_statement__ = 77;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(vector_mu, 4),
                         stan::math::add(vector_sigma, 1)));
        current_statement__ = 81;
        if (stan::math::logical_lt(stan::math::min(y), L)) {
          current_statement__ = 81;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 80;
          if (stan::math::logical_gt(stan::math::max(y), U)) {
            current_statement__ = 80;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            Eigen::Matrix<local_scalar_t__,-1,1> sym2__;
            current_statement__ = 78;
            stan::model::assign(sym2__, stan::math::multiply(vector_mu, 4),
              "assigning variable sym2__");
            Eigen::Matrix<local_scalar_t__,1,-1> sym1__;
            current_statement__ = 79;
            stan::model::assign(sym1__, stan::math::add(vector_sigma, 1),
              "assigning variable sym1__");
            current_statement__ = 80;
            for (int sym4__ = 1; sym4__ <= stan::math::size(sym2__); ++sym4__) {
              current_statement__ = 80;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U, sym2__[(sym4__ -
                                   1)], sym1__[(sym4__ - 1)]),
                                 stan::math::normal_lcdf(L, sym2__[(sym4__ -
                                   1)], sym1__[(sym4__ - 1)]))));
            }
          }
        }
        current_statement__ = 86;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 82;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(y, "y",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_mu, "vector_mu",
                             stan::model::index_uni(n)),
                           stan::model::rvalue(vector_sigma, "vector_sigma",
                             stan::model::index_uni(n))));
          current_statement__ = 84;
          if (stan::math::logical_lt(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)), L)) {
            current_statement__ = 84;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 83;
            if (stan::math::logical_gt(
                  stan::model::rvalue(y, "y", stan::model::index_uni(n)), U)) {
              current_statement__ = 83;
              lp_accum__.add(stan::math::negative_infinity());
            } else {
              current_statement__ = 83;
              lp_accum__.add(-(stan::math::log_diff_exp(
                                 stan::math::normal_lcdf(U,
                                   stan::model::rvalue(vector_mu,
                                     "vector_mu", stan::model::index_uni(n)),
                                   stan::model::rvalue(vector_sigma,
                                     "vector_sigma",
                                     stan::model::index_uni(n))),
                                 stan::math::normal_lcdf(L,
                                   stan::model::rvalue(vector_mu,
                                     "vector_mu", stan::model::index_uni(n)),
                                   stan::model::rvalue(vector_sigma,
                                     "vector_sigma",
                                     stan::model::index_uni(n))))));
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "vector_truncate_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double mu = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      double sigma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      Eigen::Matrix<double,-1,1> vector_mu =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      vector_mu = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<double,1,-1> vector_sigma =
        Eigen::Matrix<double,1,-1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 4;
      vector_sigma = in__.template read<
                       Eigen::Matrix<local_scalar_t__,1,-1>>(N);
      out__.write(mu);
      out__.write(sigma);
      out__.write(vector_mu);
      out__.write(vector_sigma);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.read<local_scalar_t__>();
      out__.write(mu);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 2;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma);
      Eigen::Matrix<local_scalar_t__,-1,1> vector_mu =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(vector_mu,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable vector_mu");
      out__.write(vector_mu);
      Eigen::Matrix<local_scalar_t__,1,-1> vector_sigma =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(vector_sigma,
        in__.read<Eigen::Matrix<local_scalar_t__,1,-1>>(N),
        "assigning variable vector_sigma");
      out__.write(vector_sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    // suppress unused var warning
    (void) current_statement__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mu", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "sigma", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "vector_mu",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "vector_sigma",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = context__.vals_r("mu")[(1 - 1)];
      out__.write(mu);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 2;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      out__.write_free_lb(0, sigma);
      Eigen::Matrix<local_scalar_t__,-1,1> vector_mu =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> vector_mu_flat__;
        current_statement__ = 3;
        vector_mu_flat__ = context__.vals_r("vector_mu");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(vector_mu, vector_mu_flat__[(pos__ - 1)],
            "assigning variable vector_mu", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(vector_mu);
      Eigen::Matrix<local_scalar_t__,1,-1> vector_sigma =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> vector_sigma_flat__;
        current_statement__ = 4;
        vector_sigma_flat__ = context__.vals_r("vector_sigma");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(vector_sigma, vector_sigma_flat__[(pos__ - 1)],
            "assigning variable vector_sigma", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(vector_sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mu", "sigma", "vector_mu",
                "vector_sigma"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mu");
    param_names__.emplace_back(std::string() + "sigma");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "vector_mu" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "vector_sigma" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mu");
    param_names__.emplace_back(std::string() + "sigma");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "vector_mu" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "vector_sigma" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"vector_mu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"vector_sigma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"vector_mu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"vector_sigma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((1 + 1) + N) + N);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((1 + 1) + N) + N);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = vector_truncate_model_namespace::vector_truncate_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return vector_truncate_model_namespace::profiles__;
}
#endif
