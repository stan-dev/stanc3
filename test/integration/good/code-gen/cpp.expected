  $ ../../../../../install/default/bin/stanc --print-cpp eight_schools_ncp.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace eight_schools_ncp_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'eight_schools_ncp.stan', line 8, column 2 to column 10)",
                                                      " (in 'eight_schools_ncp.stan', line 9, column 2 to column 20)",
                                                      " (in 'eight_schools_ncp.stan', line 10, column 2 to column 24)",
                                                      " (in 'eight_schools_ncp.stan', line 14, column 2 to column 43)",
                                                      " (in 'eight_schools_ncp.stan', line 18, column 2 to column 20)",
                                                      " (in 'eight_schools_ncp.stan', line 19, column 2 to column 21)",
                                                      " (in 'eight_schools_ncp.stan', line 20, column 2 to column 29)",
                                                      " (in 'eight_schools_ncp.stan', line 21, column 2 to column 27)",
                                                      " (in 'eight_schools_ncp.stan', line 2, column 2 to column 17)",
                                                      " (in 'eight_schools_ncp.stan', line 3, column 2 to column 12)",
                                                      " (in 'eight_schools_ncp.stan', line 4, column 2 to column 25)"};



class eight_schools_ncp_model : public model_base_crtp<eight_schools_ncp_model> {

 private:
  int pos__;
  int J;
  std::vector<double> y;
  std::vector<double> sigma;
 
 public:
  ~eight_schools_ncp_model() { }
  
  std::string model_name() const { return "eight_schools_ncp_model"; }
  
  eight_schools_ncp_model(stan::io::var_context& context__,
                          unsigned int random_seed__ = 0,
                          std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "eight_schools_ncp_model_namespace::eight_schools_ncp_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      context__.validate_dims("data initialization","J","int",
          context__.to_vec());
      J = std::numeric_limits<int>::min();
      
      current_statement__ = 9;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 10;
      validate_non_negative_index("y", "J", J);
      context__.validate_dims("data initialization","y","double",
          context__.to_vec(J));
      y = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 10;
      assign(y, nil_index_list(), context__.vals_r("y"),
        "assigning variable y");
      current_statement__ = 11;
      validate_non_negative_index("sigma", "J", J);
      context__.validate_dims("data initialization","sigma","double",
          context__.to_vec(J));
      sigma = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 11;
      assign(sigma, nil_index_list(), context__.vals_r("sigma"),
        "assigning variable sigma");
      current_statement__ = 9;
      current_statement__ = 9;
      check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        current_statement__ = 11;
        current_statement__ = 11;
        check_greater_or_equal(function__, "sigma[sym1__]",
                               sigma[(sym1__ - 1)], 0);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      current_statement__ = 3;
      validate_non_negative_index("theta_tilde", "J", J);
      num_params_r__ += J;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  inline T__ log_prob(std::vector<T__>& params_r__,
                      std::vector<int>& params_i__,
                      std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "eight_schools_ncp_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ mu;
      mu = DUMMY_VAR__;
      
      current_statement__ = 1;
      mu = in__.scalar();
      local_scalar_t__ tau;
      tau = DUMMY_VAR__;
      
      current_statement__ = 2;
      tau = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        tau = stan::math::lb_constrain(tau, 0, lp__);
      } else {
        current_statement__ = 2;
        tau = stan::math::lb_constrain(tau, 0);
      }
      current_statement__ = 3;
      validate_non_negative_index("theta_tilde", "J", J);
      Eigen::Matrix<local_scalar_t__, -1, 1> theta_tilde;
      theta_tilde = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      stan::math::fill(theta_tilde, DUMMY_VAR__);
      
      current_statement__ = 3;
      theta_tilde = in__.vector(J);
      current_statement__ = 4;
      validate_non_negative_index("theta", "J", J);
      Eigen::Matrix<local_scalar_t__, -1, 1> theta;
      theta = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      stan::math::fill(theta, DUMMY_VAR__);
      
      current_statement__ = 4;
      assign(theta, nil_index_list(), add(mu, multiply(tau, theta_tilde)),
        "assigning variable theta");
      {
        current_statement__ = 5;
        lp_accum__.add(normal_log<propto__>(mu, 0, 5));
        current_statement__ = 6;
        lp_accum__.add(normal_log<propto__>(tau, 0, 5));
        current_statement__ = 7;
        lp_accum__.add(normal_log<propto__>(theta_tilde, 0, 1));
        current_statement__ = 8;
        lp_accum__.add(normal_log<propto__>(y, theta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  inline void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                          std::vector<int>& params_i__,
                          std::vector<double>& vars__,
                          bool emit_transformed_parameters__ = true,
                          bool emit_generated_quantities__ = true,
                          std::ostream* pstream__ = 0) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "eight_schools_ncp_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double mu;
      mu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mu = in__.scalar();
      double tau;
      tau = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      tau = in__.scalar();
      current_statement__ = 2;
      tau = stan::math::lb_constrain(tau, 0);
      current_statement__ = 3;
      validate_non_negative_index("theta_tilde", "J", J);
      Eigen::Matrix<double, -1, 1> theta_tilde;
      theta_tilde = Eigen::Matrix<double, -1, 1>(J);
      stan::math::fill(theta_tilde, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      theta_tilde = in__.vector(J);
      current_statement__ = 4;
      validate_non_negative_index("theta", "J", J);
      Eigen::Matrix<double, -1, 1> theta;
      theta = Eigen::Matrix<double, -1, 1>(J);
      stan::math::fill(theta, std::numeric_limits<double>::quiet_NaN());
      
      vars__.push_back(mu);
      vars__.push_back(tau);
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        vars__.push_back(theta_tilde[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 4;
      assign(theta, nil_index_list(), add(mu, multiply(tau, theta_tilde)),
        "assigning variable theta");
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        vars__.push_back(theta[(sym1__ - 1)]);}
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  inline void transform_inits(const stan::io::var_context& context__,
                              std::vector<int>& params_i__,
                              std::vector<double>& vars__,
                              std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double mu;
      mu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mu = context__.vals_r("mu")[(1 - 1)];
      double tau;
      tau = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      tau = context__.vals_r("tau")[(1 - 1)];
      current_statement__ = 2;
      tau = stan::math::lb_free(tau, 0);
      current_statement__ = 3;
      validate_non_negative_index("theta_tilde", "J", J);
      Eigen::Matrix<double, -1, 1> theta_tilde;
      theta_tilde = Eigen::Matrix<double, -1, 1>(J);
      stan::math::fill(theta_tilde, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> theta_tilde_flat__;
        current_statement__ = 3;
        assign(theta_tilde_flat__, nil_index_list(),
          context__.vals_r("theta_tilde"),
          "assigning variable theta_tilde_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
          current_statement__ = 3;
          assign(theta_tilde, cons_list(index_uni(sym1__), nil_index_list()),
            theta_tilde_flat__[(pos__ - 1)], "assigning variable theta_tilde");
          current_statement__ = 3;
          pos__ = (pos__ + 1);}
      }
      vars__.push_back(mu);
      vars__.push_back(tau);
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        vars__.push_back(theta_tilde[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("mu");
    names__.push_back("tau");
    names__.push_back("theta_tilde");
    names__.push_back("theta");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(J);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(J);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mu");
    param_names__.push_back(std::string() + "tau");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.push_back(std::string() + "theta_tilde" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        {
          param_names__.push_back(std::string() + "theta" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mu");
    param_names__.push_back(std::string() + "tau");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.push_back(std::string() + "theta_tilde" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        {
          param_names__.push_back(std::string() + "theta" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_tilde\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_tilde\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}

typedef eight_schools_ncp_model_namespace::eight_schools_ncp_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp mother.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace mother_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'mother.stan', line 401, column 2 to column 14)",
                                                      " (in 'mother.stan', line 402, column 2 to column 52)",
                                                      " (in 'mother.stan', line 403, column 2 to column 45)",
                                                      " (in 'mother.stan', line 404, column 2 to column 41)",
                                                      " (in 'mother.stan', line 405, column 2 to column 32)",
                                                      " (in 'mother.stan', line 406, column 2 to column 36)",
                                                      " (in 'mother.stan', line 407, column 2 to column 27)",
                                                      " (in 'mother.stan', line 408, column 2 to column 24)",
                                                      " (in 'mother.stan', line 409, column 2 to column 28)",
                                                      " (in 'mother.stan', line 410, column 2 to column 26)",
                                                      " (in 'mother.stan', line 411, column 2 to column 32)",
                                                      " (in 'mother.stan', line 412, column 2 to column 36)",
                                                      " (in 'mother.stan', line 413, column 2 to column 45)",
                                                      " (in 'mother.stan', line 414, column 2 to column 23)",
                                                      " (in 'mother.stan', line 415, column 2 to column 29)",
                                                      " (in 'mother.stan', line 416, column 2 to column 33)",
                                                      " (in 'mother.stan', line 417, column 2 to column 38)",
                                                      " (in 'mother.stan', line 418, column 2 to column 36)",
                                                      " (in 'mother.stan', line 419, column 2 to column 42)",
                                                      " (in 'mother.stan', line 420, column 2 to column 16)",
                                                      " (in 'mother.stan', line 421, column 2 to column 16)",
                                                      " (in 'mother.stan', line 424, column 2 to column 33)",
                                                      " (in 'mother.stan', line 425, column 2 to column 37)",
                                                      " (in 'mother.stan', line 426, column 2 to column 28)",
                                                      " (in 'mother.stan', line 427, column 2 to column 25)",
                                                      " (in 'mother.stan', line 428, column 2 to column 29)",
                                                      " (in 'mother.stan', line 429, column 2 to column 27)",
                                                      " (in 'mother.stan', line 430, column 2 to column 33)",
                                                      " (in 'mother.stan', line 431, column 2 to column 37)",
                                                      " (in 'mother.stan', line 432, column 2 to column 46)",
                                                      " (in 'mother.stan', line 433, column 2 to column 24)",
                                                      " (in 'mother.stan', line 434, column 2 to column 30)",
                                                      " (in 'mother.stan', line 435, column 2 to column 34)",
                                                      " (in 'mother.stan', line 436, column 2 to column 39)",
                                                      " (in 'mother.stan', line 437, column 2 to column 37)",
                                                      " (in 'mother.stan', line 438, column 2 to column 43)",
                                                      " (in 'mother.stan', line 439, column 2 to column 20)",
                                                      " (in 'mother.stan', line 441, column 2 to column 31)",
                                                      " (in 'mother.stan', line 442, column 2 to column 31)",
                                                      " (in 'mother.stan', line 443, column 2 to column 23)",
                                                      " (in 'mother.stan', line 444, column 2 to column 23)",
                                                      " (in 'mother.stan', line 446, column 2 to column 25)",
                                                      " (in 'mother.stan', line 447, column 2 to column 31)",
                                                      " (in 'mother.stan', line 448, column 2 to column 31)",
                                                      " (in 'mother.stan', line 450, column 2 to column 27)",
                                                      " (in 'mother.stan', line 451, column 2 to column 27)",
                                                      " (in 'mother.stan', line 452, column 2 to column 33)",
                                                      " (in 'mother.stan', line 458, column 10 to column 38)",
                                                      " (in 'mother.stan', line 457, column 23 to line 458, column 39)",
                                                      " (in 'mother.stan', line 457, column 8 to line 458, column 39)",
                                                      " (in 'mother.stan', line 456, column 21 to line 458, column 40)",
                                                      " (in 'mother.stan', line 456, column 6 to line 458, column 40)",
                                                      " (in 'mother.stan', line 455, column 19 to line 458, column 41)",
                                                      " (in 'mother.stan', line 455, column 4 to line 458, column 41)",
                                                      " (in 'mother.stan', line 454, column 17 to line 458, column 42)",
                                                      " (in 'mother.stan', line 454, column 2 to line 458, column 42)",
                                                      " (in 'mother.stan', line 460, column 17 to column 45)",
                                                      " (in 'mother.stan', line 460, column 2 to column 45)",
                                                      " (in 'mother.stan', line 461, column 2 to column 29)",
                                                      " (in 'mother.stan', line 462, column 2 to column 31)",
                                                      " (in 'mother.stan', line 463, column 2 to column 31)",
                                                      " (in 'mother.stan', line 465, column 2 to column 63)",
                                                      " (in 'mother.stan', line 466, column 2 to column 79)",
                                                      " (in 'mother.stan', line 467, column 2 to column 81)",
                                                      " (in 'mother.stan', line 468, column 2 to column 65)",
                                                      " (in 'mother.stan', line 469, column 2 to column 81)",
                                                      " (in 'mother.stan', line 470, column 2 to column 67)",
                                                      " (in 'mother.stan', line 471, column 2 to column 83)",
                                                      " (in 'mother.stan', line 515, column 2 to column 32)",
                                                      " (in 'mother.stan', line 516, column 2 to column 27)",
                                                      " (in 'mother.stan', line 517, column 2 to column 35)",
                                                      " (in 'mother.stan', line 518, column 2 to column 39)",
                                                      " (in 'mother.stan', line 519, column 2 to column 28)",
                                                      " (in 'mother.stan', line 520, column 2 to column 25)",
                                                      " (in 'mother.stan', line 521, column 2 to column 29)",
                                                      " (in 'mother.stan', line 522, column 2 to column 27)",
                                                      " (in 'mother.stan', line 523, column 2 to column 33)",
                                                      " (in 'mother.stan', line 524, column 2 to column 37)",
                                                      " (in 'mother.stan', line 525, column 2 to column 46)",
                                                      " (in 'mother.stan', line 526, column 2 to column 24)",
                                                      " (in 'mother.stan', line 527, column 2 to column 30)",
                                                      " (in 'mother.stan', line 528, column 2 to column 34)",
                                                      " (in 'mother.stan', line 529, column 2 to column 39)",
                                                      " (in 'mother.stan', line 530, column 2 to column 37)",
                                                      " (in 'mother.stan', line 531, column 2 to column 43)",
                                                      " (in 'mother.stan', line 532, column 2 to column 29)",
                                                      " (in 'mother.stan', line 533, column 2 to column 31)",
                                                      " (in 'mother.stan', line 534, column 2 to column 27)",
                                                      " (in 'mother.stan', line 535, column 2 to column 27)",
                                                      " (in 'mother.stan', line 536, column 2 to column 27)",
                                                      " (in 'mother.stan', line 537, column 2 to column 28)",
                                                      " (in 'mother.stan', line 538, column 2 to column 28)",
                                                      " (in 'mother.stan', line 539, column 2 to column 28)",
                                                      " (in 'mother.stan', line 540, column 2 to column 28)",
                                                      " (in 'mother.stan', line 541, column 2 to column 24)",
                                                      " (in 'mother.stan', line 543, column 2 to column 35)",
                                                      " (in 'mother.stan', line 544, column 2 to column 31)",
                                                      " (in 'mother.stan', line 545, column 2 to column 23)",
                                                      " (in 'mother.stan', line 546, column 2 to column 23)",
                                                      " (in 'mother.stan', line 547, column 2 to column 25)",
                                                      " (in 'mother.stan', line 548, column 2 to column 31)",
                                                      " (in 'mother.stan', line 549, column 2 to column 31)",
                                                      " (in 'mother.stan', line 551, column 2 to column 35)",
                                                      " (in 'mother.stan', line 552, column 2 to column 31)",
                                                      " (in 'mother.stan', line 553, column 2 to column 31)",
                                                      " (in 'mother.stan', line 555, column 2 to column 27)",
                                                      " (in 'mother.stan', line 556, column 2 to column 27)",
                                                      " (in 'mother.stan', line 557, column 2 to column 33)",
                                                      " (in 'mother.stan', line 563, column 10 to column 38)",
                                                      " (in 'mother.stan', line 562, column 23 to line 563, column 39)",
                                                      " (in 'mother.stan', line 562, column 8 to line 563, column 39)",
                                                      " (in 'mother.stan', line 561, column 21 to line 563, column 40)",
                                                      " (in 'mother.stan', line 561, column 6 to line 563, column 40)",
                                                      " (in 'mother.stan', line 560, column 19 to line 563, column 41)",
                                                      " (in 'mother.stan', line 560, column 4 to line 563, column 41)",
                                                      " (in 'mother.stan', line 559, column 17 to line 563, column 42)",
                                                      " (in 'mother.stan', line 559, column 2 to line 563, column 42)",
                                                      " (in 'mother.stan', line 565, column 17 to column 45)",
                                                      " (in 'mother.stan', line 565, column 2 to column 45)",
                                                      " (in 'mother.stan', line 571, column 8 to column 49)",
                                                      " (in 'mother.stan', line 570, column 6 to line 571, column 49)",
                                                      " (in 'mother.stan', line 569, column 4 to line 571, column 49)",
                                                      " (in 'mother.stan', line 568, column 2 to line 571, column 49)",
                                                      " (in 'mother.stan', line 576, column 6 to column 60)",
                                                      " (in 'mother.stan', line 575, column 4 to line 576, column 60)",
                                                      " (in 'mother.stan', line 574, column 2 to line 576, column 60)",
                                                      " (in 'mother.stan', line 578, column 2 to column 45)",
                                                      " (in 'mother.stan', line 579, column 64 to column 97)",
                                                      " (in 'mother.stan', line 579, column 2 to column 97)",
                                                      " (in 'mother.stan', line 584, column 6 to column 51)",
                                                      " (in 'mother.stan', line 583, column 4 to line 584, column 51)",
                                                      " (in 'mother.stan', line 582, column 2 to line 584, column 51)",
                                                      " (in 'mother.stan', line 585, column 2 to column 39)",
                                                      " (in 'mother.stan', line 587, column 58 to column 91)",
                                                      " (in 'mother.stan', line 587, column 2 to column 91)",
                                                      " (in 'mother.stan', line 593, column 8 to column 68)",
                                                      " (in 'mother.stan', line 592, column 6 to line 593, column 68)",
                                                      " (in 'mother.stan', line 591, column 4 to line 593, column 68)",
                                                      " (in 'mother.stan', line 590, column 2 to line 593, column 68)",
                                                      " (in 'mother.stan', line 594, column 2 to column 48)",
                                                      " (in 'mother.stan', line 595, column 67 to column 100)",
                                                      " (in 'mother.stan', line 595, column 2 to column 100)",
                                                      " (in 'mother.stan', line 597, column 2 to column 36)",
                                                      " (in 'mother.stan', line 598, column 2 to column 38)",
                                                      " (in 'mother.stan', line 474, column 2 to column 16)",
                                                      " (in 'mother.stan', line 475, column 2 to column 20)",
                                                      " (in 'mother.stan', line 476, column 2 to column 29)",
                                                      " (in 'mother.stan', line 477, column 2 to column 24)",
                                                      " (in 'mother.stan', line 478, column 2 to column 23)",
                                                      " (in 'mother.stan', line 479, column 2 to column 35)",
                                                      " (in 'mother.stan', line 481, column 2 to column 38)",
                                                      " (in 'mother.stan', line 482, column 2 to column 38)",
                                                      " (in 'mother.stan', line 484, column 2 to column 41)",
                                                      " (in 'mother.stan', line 486, column 4 to column 42)",
                                                      " (in 'mother.stan', line 487, column 4 to column 46)",
                                                      " (in 'mother.stan', line 488, column 4 to column 46)",
                                                      " (in 'mother.stan', line 491, column 8 to column 68)",
                                                      " (in 'mother.stan', line 492, column 8 to column 76)",
                                                      " (in 'mother.stan', line 493, column 8 to column 76)",
                                                      " (in 'mother.stan', line 494, column 8 to column 65)",
                                                      " (in 'mother.stan', line 490, column 21 to line 495, column 7)",
                                                      " (in 'mother.stan', line 490, column 6 to line 495, column 7)",
                                                      " (in 'mother.stan', line 489, column 19 to line 496, column 5)",
                                                      " (in 'mother.stan', line 489, column 4 to line 496, column 5)",
                                                      " (in 'mother.stan', line 485, column 17 to line 497, column 3)",
                                                      " (in 'mother.stan', line 485, column 2 to line 497, column 3)",
                                                      " (in 'mother.stan', line 500, column 6 to column 47)",
                                                      " (in 'mother.stan', line 499, column 19 to line 501, column 5)",
                                                      " (in 'mother.stan', line 499, column 4 to line 501, column 5)",
                                                      " (in 'mother.stan', line 498, column 17 to line 502, column 3)",
                                                      " (in 'mother.stan', line 498, column 2 to line 502, column 3)",
                                                      " (in 'mother.stan', line 504, column 4 to column 47)",
                                                      " (in 'mother.stan', line 503, column 17 to line 505, column 3)",
                                                      " (in 'mother.stan', line 503, column 2 to line 505, column 3)",
                                                      " (in 'mother.stan', line 506, column 2 to column 38)",
                                                      " (in 'mother.stan', line 507, column 2 to column 38)",
                                                      " (in 'mother.stan', line 508, column 2 to column 38)",
                                                      " (in 'mother.stan', line 509, column 2 to column 39)",
                                                      " (in 'mother.stan', line 510, column 2 to column 39)",
                                                      " (in 'mother.stan', line 512, column 2 to column 53)",
                                                      " (in 'mother.stan', line 316, column 2 to column 17)",
                                                      " (in 'mother.stan', line 317, column 2 to column 17)",
                                                      " (in 'mother.stan', line 318, column 2 to column 28)",
                                                      " (in 'mother.stan', line 319, column 2 to column 30)",
                                                      " (in 'mother.stan', line 320, column 2 to column 34)",
                                                      " (in 'mother.stan', line 321, column 2 to column 32)",
                                                      " (in 'mother.stan', line 322, column 2 to column 23)",
                                                      " (in 'mother.stan', line 323, column 2 to column 27)",
                                                      " (in 'mother.stan', line 324, column 2 to column 18)",
                                                      " (in 'mother.stan', line 325, column 2 to column 24)",
                                                      " (in 'mother.stan', line 326, column 2 to column 28)",
                                                      " (in 'mother.stan', line 327, column 2 to column 26)",
                                                      " (in 'mother.stan', line 328, column 2 to column 32)",
                                                      " (in 'mother.stan', line 329, column 2 to column 36)",
                                                      " (in 'mother.stan', line 330, column 2 to column 45)",
                                                      " (in 'mother.stan', line 331, column 2 to column 23)",
                                                      " (in 'mother.stan', line 332, column 2 to column 29)",
                                                      " (in 'mother.stan', line 333, column 2 to column 33)",
                                                      " (in 'mother.stan', line 334, column 2 to column 38)",
                                                      " (in 'mother.stan', line 335, column 2 to column 36)",
                                                      " (in 'mother.stan', line 336, column 2 to column 42)",
                                                      " (in 'mother.stan', line 339, column 2 to column 13)",
                                                      " (in 'mother.stan', line 340, column 2 to column 15)",
                                                      " (in 'mother.stan', line 341, column 2 to column 34)",
                                                      " (in 'mother.stan', line 342, column 2 to column 15)",
                                                      " (in 'mother.stan', line 343, column 2 to column 20)",
                                                      " (in 'mother.stan', line 344, column 2 to column 29)",
                                                      " (in 'mother.stan', line 345, column 2 to column 46)",
                                                      " (in 'mother.stan', line 346, column 2 to column 24)",
                                                      " (in 'mother.stan', line 347, column 2 to column 30)",
                                                      " (in 'mother.stan', line 348, column 2 to column 34)",
                                                      " (in 'mother.stan', line 349, column 2 to column 39)",
                                                      " (in 'mother.stan', line 350, column 2 to column 37)",
                                                      " (in 'mother.stan', line 351, column 2 to column 14)",
                                                      " (in 'mother.stan', line 352, column 2 to column 14)",
                                                      " (in 'mother.stan', line 353, column 2 to column 14)",
                                                      " (in 'mother.stan', line 354, column 2 to column 17)",
                                                      " (in 'mother.stan', line 355, column 2 to column 17)",
                                                      " (in 'mother.stan', line 356, column 2 to column 16)",
                                                      " (in 'mother.stan', line 357, column 2 to column 18)",
                                                      " (in 'mother.stan', line 358, column 2 to column 18)",
                                                      " (in 'mother.stan', line 363, column 10 to column 38)",
                                                      " (in 'mother.stan', line 362, column 23 to line 363, column 39)",
                                                      " (in 'mother.stan', line 362, column 8 to line 363, column 39)",
                                                      " (in 'mother.stan', line 361, column 21 to line 363, column 40)",
                                                      " (in 'mother.stan', line 361, column 6 to line 363, column 40)",
                                                      " (in 'mother.stan', line 360, column 19 to line 363, column 41)",
                                                      " (in 'mother.stan', line 360, column 4 to line 363, column 41)",
                                                      " (in 'mother.stan', line 359, column 17 to line 363, column 42)",
                                                      " (in 'mother.stan', line 359, column 2 to line 363, column 42)",
                                                      " (in 'mother.stan', line 365, column 4 to column 28)",
                                                      " (in 'mother.stan', line 367, column 6 to column 36)",
                                                      " (in 'mother.stan', line 370, column 10 to column 46)",
                                                      " (in 'mother.stan', line 369, column 23 to line 370, column 47)",
                                                      " (in 'mother.stan', line 369, column 8 to line 370, column 47)",
                                                      " (in 'mother.stan', line 368, column 21 to line 370, column 48)",
                                                      " (in 'mother.stan', line 368, column 6 to line 370, column 48)",
                                                      " (in 'mother.stan', line 366, column 19 to line 370, column 49)",
                                                      " (in 'mother.stan', line 366, column 4 to line 370, column 49)",
                                                      " (in 'mother.stan', line 364, column 17 to line 370, column 50)",
                                                      " (in 'mother.stan', line 364, column 2 to line 370, column 50)",
                                                      " (in 'mother.stan', line 373, column 6 to column 40)",
                                                      " (in 'mother.stan', line 374, column 6 to column 63)",
                                                      " (in 'mother.stan', line 372, column 19 to line 375, column 5)",
                                                      " (in 'mother.stan', line 372, column 4 to line 375, column 5)",
                                                      " (in 'mother.stan', line 371, column 17 to line 375, column 6)",
                                                      " (in 'mother.stan', line 371, column 2 to line 375, column 6)",
                                                      " (in 'mother.stan', line 376, column 2 to column 62)",
                                                      " (in 'mother.stan', line 377, column 2 to column 62)",
                                                      " (in 'mother.stan', line 379, column 4 to column 11)",
                                                      " (in 'mother.stan', line 380, column 4 to column 35)",
                                                      " (in 'mother.stan', line 381, column 4 to line 383, column 5)",
                                                      " (in 'mother.stan', line 382, column 6 to column 12)",
                                                      " (in 'mother.stan', line 384, column 4 to column 31)",
                                                      " (in 'mother.stan', line 385, column 4 to line 387, column 5)",
                                                      " (in 'mother.stan', line 386, column 6 to column 12)",
                                                      " (in 'mother.stan', line 378, column 2 to line 388, column 3)",
                                                      " (in 'mother.stan', line 390, column 2 to column 25)",
                                                      " (in 'mother.stan', line 391, column 2 to column 34)",
                                                      " (in 'mother.stan', line 392, column 2 to column 33)",
                                                      " (in 'mother.stan', line 393, column 2 to column 36)",
                                                      " (in 'mother.stan', line 395, column 2 to column 23)",
                                                      " (in 'mother.stan', line 396, column 2 to column 30)",
                                                      " (in 'mother.stan', line 398, column 2 to column 28)",
                                                      " (in 'mother.stan', line 10, column 16 to column 17)",
                                                      " (in 'mother.stan', line 13, column 16 to column 25)",
                                                      " (in 'mother.stan', line 13, column 4 to column 25)",
                                                      " (in 'mother.stan', line 14, column 4 to column 26)",
                                                      " (in 'mother.stan', line 12, column 17 to line 15, column 3)",
                                                      " (in 'mother.stan', line 22, column 31 to column 32)",
                                                      " (in 'mother.stan', line 29, column 4 to column 17)",
                                                      " (in 'mother.stan', line 30, column 4 to column 19)",
                                                      " (in 'mother.stan', line 31, column 4 to column 38)",
                                                      " (in 'mother.stan', line 32, column 4 to column 16)",
                                                      " (in 'mother.stan', line 28, column 31 to line 33, column 3)",
                                                      " (in 'mother.stan', line 36, column 4 to column 15)",
                                                      " (in 'mother.stan', line 35, column 18 to line 37, column 3)",
                                                      " (in 'mother.stan', line 40, column 4 to column 15)",
                                                      " (in 'mother.stan', line 39, column 24 to line 41, column 3)",
                                                      " (in 'mother.stan', line 44, column 4 to column 15)",
                                                      " (in 'mother.stan', line 43, column 32 to line 45, column 3)",
                                                      " (in 'mother.stan', line 48, column 4 to column 15)",
                                                      " (in 'mother.stan', line 47, column 36 to line 49, column 3)",
                                                      " (in 'mother.stan', line 52, column 4 to column 15)",
                                                      " (in 'mother.stan', line 51, column 36 to line 53, column 3)",
                                                      " (in 'mother.stan', line 56, column 4 to column 15)",
                                                      " (in 'mother.stan', line 55, column 37 to line 57, column 3)",
                                                      " (in 'mother.stan', line 59, column 4 to column 33)",
                                                      " (in 'mother.stan', line 58, column 36 to line 60, column 3)",
                                                      " (in 'mother.stan', line 63, column 4 to column 42)",
                                                      " (in 'mother.stan', line 64, column 4 to column 26)",
                                                      " (in 'mother.stan', line 62, column 30 to line 65, column 3)",
                                                      " (in 'mother.stan', line 69, column 14 to column 20)",
                                                      " (in 'mother.stan', line 69, column 4 to column 20)",
                                                      " (in 'mother.stan', line 70, column 14 to column 23)",
                                                      " (in 'mother.stan', line 70, column 4 to column 23)",
                                                      " (in 'mother.stan', line 73, column 20 to column 26)",
                                                      " (in 'mother.stan', line 73, column 4 to column 26)",
                                                      " (in 'mother.stan', line 74, column 20 to column 29)",
                                                      " (in 'mother.stan', line 74, column 4 to column 29)",
                                                      " (in 'mother.stan', line 78, column 6 to column 12)",
                                                      " (in 'mother.stan', line 79, column 6 to column 12)",
                                                      " (in 'mother.stan', line 80, column 6 to column 12)",
                                                      " (in 'mother.stan', line 77, column 14 to line 81, column 5)",
                                                      " (in 'mother.stan', line 77, column 4 to line 81, column 5)",
                                                      " (in 'mother.stan', line 87, column 11 to column 17)",
                                                      " (in 'mother.stan', line 86, column 18 to column 24)",
                                                      " (in 'mother.stan', line 86, column 11 to line 87, column 17)",
                                                      " (in 'mother.stan', line 85, column 13 to column 19)",
                                                      " (in 'mother.stan', line 85, column 6 to line 87, column 17)",
                                                      " (in 'mother.stan', line 84, column 14 to line 88, column 5)",
                                                      " (in 'mother.stan', line 84, column 4 to line 88, column 5)",
                                                      " (in 'mother.stan', line 91, column 24 to column 30)",
                                                      " (in 'mother.stan', line 91, column 14 to column 30)",
                                                      " (in 'mother.stan', line 91, column 4 to column 30)",
                                                      " (in 'mother.stan', line 95, column 22 to column 28)",
                                                      " (in 'mother.stan', line 95, column 6 to column 28)",
                                                      " (in 'mother.stan', line 94, column 14 to line 96, column 5)",
                                                      " (in 'mother.stan', line 94, column 4 to line 96, column 5)",
                                                      " (in 'mother.stan', line 100, column 6 to column 19)",
                                                      " (in 'mother.stan', line 101, column 6 to column 12)",
                                                      " (in 'mother.stan', line 102, column 6 to line 105, column 7)",
                                                      " (in 'mother.stan', line 103, column 8 to column 14)",
                                                      " (in 'mother.stan', line 104, column 8 to column 14)",
                                                      " (in 'mother.stan', line 106, column 6 to line 109, column 7)",
                                                      " (in 'mother.stan', line 107, column 8 to column 14)",
                                                      " (in 'mother.stan', line 108, column 8 to column 17)",
                                                      " (in 'mother.stan', line 110, column 6 to line 116, column 7)",
                                                      " (in 'mother.stan', line 111, column 8 to line 114, column 9)",
                                                      " (in 'mother.stan', line 112, column 10 to column 16)",
                                                      " (in 'mother.stan', line 113, column 10 to column 16)",
                                                      " (in 'mother.stan', line 115, column 8 to column 14)",
                                                      " (in 'mother.stan', line 99, column 14 to line 117, column 5)",
                                                      " (in 'mother.stan', line 99, column 4 to line 117, column 5)",
                                                      " (in 'mother.stan', line 121, column 6 to column 13)",
                                                      " (in 'mother.stan', line 122, column 6 to column 21)",
                                                      " (in 'mother.stan', line 123, column 6 to line 126, column 7)",
                                                      " (in 'mother.stan', line 124, column 8 to column 14)",
                                                      " (in 'mother.stan', line 125, column 8 to column 14)",
                                                      " (in 'mother.stan', line 127, column 6 to line 130, column 7)",
                                                      " (in 'mother.stan', line 128, column 8 to column 16)",
                                                      " (in 'mother.stan', line 129, column 8 to column 17)",
                                                      " (in 'mother.stan', line 120, column 14 to line 131, column 5)",
                                                      " (in 'mother.stan', line 120, column 4 to line 131, column 5)",
                                                      " (in 'mother.stan', line 135, column 6 to column 13)",
                                                      " (in 'mother.stan', line 136, column 6 to column 19)",
                                                      " (in 'mother.stan', line 137, column 6 to line 140, column 7)",
                                                      " (in 'mother.stan', line 138, column 8 to column 14)",
                                                      " (in 'mother.stan', line 139, column 8 to column 14)",
                                                      " (in 'mother.stan', line 141, column 6 to line 144, column 7)",
                                                      " (in 'mother.stan', line 142, column 8 to column 16)",
                                                      " (in 'mother.stan', line 143, column 8 to column 17)",
                                                      " (in 'mother.stan', line 134, column 14 to line 145, column 5)",
                                                      " (in 'mother.stan', line 134, column 4 to line 145, column 5)",
                                                      " (in 'mother.stan', line 149, column 6 to column 13)",
                                                      " (in 'mother.stan', line 150, column 6 to column 23)",
                                                      " (in 'mother.stan', line 151, column 6 to line 154, column 7)",
                                                      " (in 'mother.stan', line 152, column 8 to column 14)",
                                                      " (in 'mother.stan', line 153, column 8 to column 14)",
                                                      " (in 'mother.stan', line 155, column 6 to line 158, column 7)",
                                                      " (in 'mother.stan', line 156, column 8 to column 16)",
                                                      " (in 'mother.stan', line 157, column 8 to column 17)",
                                                      " (in 'mother.stan', line 148, column 14 to line 159, column 5)",
                                                      " (in 'mother.stan', line 148, column 4 to line 159, column 5)",
                                                      " (in 'mother.stan', line 163, column 6 to column 12)",
                                                      " (in 'mother.stan', line 164, column 6 to column 12)",
                                                      " (in 'mother.stan', line 166, column 8 to column 14)",
                                                      " (in 'mother.stan', line 167, column 8 to column 14)",
                                                      " (in 'mother.stan', line 168, column 8 to column 14)",
                                                      " (in 'mother.stan', line 165, column 6 to line 169, column 7)",
                                                      " (in 'mother.stan', line 162, column 14 to line 170, column 5)",
                                                      " (in 'mother.stan', line 162, column 4 to line 170, column 5)",
                                                      " (in 'mother.stan', line 172, column 4 to column 13)",
                                                      " (in 'mother.stan', line 67, column 19 to line 173, column 3)",
                                                      " (in 'mother.stan', line 176, column 4 to column 14)",
                                                      " (in 'mother.stan', line 177, column 4 to column 10)",
                                                      " (in 'mother.stan', line 178, column 4 to column 24)",
                                                      " (in 'mother.stan', line 178, column 18 to column 24)",
                                                      " (in 'mother.stan', line 179, column 4 to column 13)",
                                                      " (in 'mother.stan', line 175, column 19 to line 180, column 3)",
                                                      " (in 'mother.stan', line 183, column 4 to column 26)",
                                                      " (in 'mother.stan', line 182, column 30 to line 184, column 3)",
                                                      " (in 'mother.stan', line 187, column 4 to column 24)",
                                                      " (in 'mother.stan', line 186, column 22 to line 188, column 3)",
                                                      " (in 'mother.stan', line 191, column 4 to column 42)",
                                                      " (in 'mother.stan', line 190, column 21 to line 192, column 3)",
                                                      " (in 'mother.stan', line 195, column 4 to column 18)",
                                                      " (in 'mother.stan', line 196, column 4 to column 19)",
                                                      " (in 'mother.stan', line 197, column 4 to column 27)",
                                                      " (in 'mother.stan', line 198, column 4 to column 40)",
                                                      " (in 'mother.stan', line 200, column 6 to column 81)",
                                                      " (in 'mother.stan', line 199, column 4 to line 200, column 81)",
                                                      " (in 'mother.stan', line 202, column 6 to column 81)",
                                                      " (in 'mother.stan', line 201, column 4 to line 202, column 81)",
                                                      " (in 'mother.stan', line 203, column 4 to column 32)",
                                                      " (in 'mother.stan', line 194, column 59 to line 204, column 3)",
                                                      " (in 'mother.stan', line 208, column 4 to column 22)",
                                                      " (in 'mother.stan', line 207, column 52 to line 209, column 3)",
                                                      " (in 'mother.stan', line 212, column 4 to column 14)",
                                                      " (in 'mother.stan', line 211, column 66 to line 213, column 3)",
                                                      " (in 'mother.stan', line 215, column 4 to column 14)",
                                                      " (in 'mother.stan', line 214, column 78 to line 216, column 3)",
                                                      " (in 'mother.stan', line 219, column 4 to column 35)",
                                                      " (in 'mother.stan', line 220, column 4 to column 12)",
                                                      " (in 'mother.stan', line 221, column 4 to column 16)",
                                                      " (in 'mother.stan', line 222, column 4 to column 20)",
                                                      " (in 'mother.stan', line 223, column 4 to column 13)",
                                                      " (in 'mother.stan', line 218, column 49 to line 224, column 3)",
                                                      " (in 'mother.stan', line 226, column 4 to column 16)",
                                                      " (in 'mother.stan', line 225, column 150 to line 227, column 3)",
                                                      " (in 'mother.stan', line 230, column 4 to column 14)",
                                                      " (in 'mother.stan', line 229, column 149 to line 231, column 3)",
                                                      " (in 'mother.stan', line 234, column 4 to column 14)",
                                                      " (in 'mother.stan', line 233, column 151 to line 235, column 3)",
                                                      " (in 'mother.stan', line 238, column 4 to column 14)",
                                                      " (in 'mother.stan', line 237, column 152 to line 239, column 3)",
                                                      " (in 'mother.stan', line 242, column 4 to column 14)",
                                                      " (in 'mother.stan', line 241, column 150 to line 243, column 3)",
                                                      " (in 'mother.stan', line 246, column 4 to column 14)",
                                                      " (in 'mother.stan', line 245, column 152 to line 247, column 3)",
                                                      " (in 'mother.stan', line 250, column 4 to column 14)",
                                                      " (in 'mother.stan', line 249, column 153 to line 251, column 3)",
                                                      " (in 'mother.stan', line 254, column 4 to column 14)",
                                                      " (in 'mother.stan', line 253, column 152 to line 255, column 3)",
                                                      " (in 'mother.stan', line 258, column 4 to column 14)",
                                                      " (in 'mother.stan', line 257, column 154 to line 259, column 3)",
                                                      " (in 'mother.stan', line 262, column 4 to column 14)",
                                                      " (in 'mother.stan', line 261, column 155 to line 263, column 3)",
                                                      " (in 'mother.stan', line 266, column 4 to column 15)",
                                                      " (in 'mother.stan', line 265, column 153 to line 267, column 3)",
                                                      " (in 'mother.stan', line 270, column 4 to column 15)",
                                                      " (in 'mother.stan', line 269, column 155 to line 271, column 3)",
                                                      " (in 'mother.stan', line 274, column 4 to column 15)",
                                                      " (in 'mother.stan', line 273, column 156 to line 275, column 3)",
                                                      " (in 'mother.stan', line 277, column 4 to column 10)",
                                                      " (in 'mother.stan', line 278, column 4 to column 11)",
                                                      " (in 'mother.stan', line 279, column 4 to column 18)",
                                                      " (in 'mother.stan', line 280, column 4 to column 32)",
                                                      " (in 'mother.stan', line 281, column 4 to column 24)",
                                                      " (in 'mother.stan', line 276, column 14 to line 282, column 3)",
                                                      " (in 'mother.stan', line 284, column 4 to line 286, column 40)",
                                                      " (in 'mother.stan', line 283, column 18 to line 287, column 3)",
                                                      " (in 'mother.stan', line 289, column 4 to column 35)",
                                                      " (in 'mother.stan', line 288, column 18 to line 290, column 3)",
                                                      " (in 'mother.stan', line 292, column 4 to column 33)",
                                                      " (in 'mother.stan', line 293, column 4 to column 13)",
                                                      " (in 'mother.stan', line 291, column 27 to line 294, column 3)",
                                                      " (in 'mother.stan', line 296, column 4 to column 48)",
                                                      " (in 'mother.stan', line 297, column 4 to column 26)",
                                                      " (in 'mother.stan', line 295, column 27 to line 298, column 3)",
                                                      " (in 'mother.stan', line 303, column 4 to column 18)",
                                                      " (in 'mother.stan', line 304, column 4 to column 25)",
                                                      " (in 'mother.stan', line 305, column 4 to column 25)",
                                                      " (in 'mother.stan', line 306, column 4 to column 15)",
                                                      " (in 'mother.stan', line 302, column 39 to line 307, column 3)",
                                                      " (in 'mother.stan', line 310, column 4 to column 19)",
                                                      " (in 'mother.stan', line 311, column 4 to column 18)",
                                                      " (in 'mother.stan', line 312, column 4 to column 16)",
                                                      " (in 'mother.stan', line 309, column 78 to line 313, column 3)"};


int
foo(const int& n, std::ostream* pstream__) ;

int
foo(const int& n, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 267;
    if (logical_eq(n, 0)) {
      current_statement__ = 266;
      return 1;
    } 
    current_statement__ = 268;
    return (n * foo((n - 1), pstream__));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_functor__ {
int
operator()(const int& n, std::ostream* pstream__)  const 
{
return foo(n, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__>
std::vector<stan::promote_args_t<T0__, T1__,
T2__>>
sho(const T0__& t, const std::vector<T1__>& y,
    const std::vector<T2__>& theta, const std::vector<double>& x,
    const std::vector<int>& x_int, std::ostream* pstream__) ;

template <typename T0__, typename T1__, typename T2__>
std::vector<stan::promote_args_t<T0__, T1__,
T2__>>
sho(const T0__& t, const std::vector<T1__>& y,
    const std::vector<T2__>& theta, const std::vector<double>& x,
    const std::vector<int>& x_int, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 271;
    validate_non_negative_index("dydt", "2", 2);
    std::vector<local_scalar_t__> dydt;
    dydt = std::vector<local_scalar_t__>(2, DUMMY_VAR__);
    
    current_statement__ = 272;
    assign(dydt, cons_list(index_uni(1), nil_index_list()),
      rvalue(y, cons_list(index_uni(2), nil_index_list()), "y"),
      "assigning variable dydt");
    current_statement__ = 273;
    assign(dydt, cons_list(index_uni(2), nil_index_list()),
      (-rvalue(y, cons_list(index_uni(1), nil_index_list()), "y") -
        (rvalue(theta, cons_list(index_uni(1), nil_index_list()), "theta") *
          rvalue(y, cons_list(index_uni(2), nil_index_list()), "y"))),
      "assigning variable dydt");
    current_statement__ = 274;
    return dydt;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct sho_functor__ {
template <typename T0__, typename T1__, typename T2__>
std::vector<stan::promote_args_t<T0__, T1__,
T2__>>
operator()(const T0__& t, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<double>& x,
           const std::vector<int>& x_int, std::ostream* pstream__)  const 
{
return sho(t, y, theta, x, x_int, pstream__);
}
};

double
foo_bar0(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 276;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_bar0_functor__ {
double
operator()(std::ostream* pstream__)  const 
{
return foo_bar0(pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
foo_bar1(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 278;
    return 1.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_bar1_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return foo_bar1(x, pstream__);
}
};

template <typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
foo_bar2(const T0__& x, const T1__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 280;
    return 2.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_bar2_functor__ {
template <typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
operator()(const T0__& x, const T1__& y, std::ostream* pstream__)  const 
{
return foo_bar2(x, y, pstream__);
}
};

template <bool propto__, typename T1__>
stan::promote_args_t<T1__>
foo_lpmf(const int& y, const T1__& lambda, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__>;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 282;
    return 1.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_lpmf_functor__ {
template <bool propto__, typename T1__>
stan::promote_args_t<T1__>
operator()(const int& y, const T1__& lambda, std::ostream* pstream__)  const 
{
return foo_lpmf(y, lambda, pstream__);
}
};

template <typename T1__>
stan::promote_args_t<T1__>
foo_lcdf(const int& y, const T1__& lambda, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 284;
    return 1.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_lcdf_functor__ {
template <typename T1__>
stan::promote_args_t<T1__>
operator()(const int& y, const T1__& lambda, std::ostream* pstream__)  const 
{
return foo_lcdf(y, lambda, pstream__);
}
};

template <typename T1__>
stan::promote_args_t<T1__>
foo_lccdf(const int& y, const T1__& lambda, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 286;
    return 1.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_lccdf_functor__ {
template <typename T1__>
stan::promote_args_t<T1__>
operator()(const int& y, const T1__& lambda, std::ostream* pstream__)  const 
{
return foo_lccdf(y, lambda, pstream__);
}
};

template <typename T0__, typename T1__, typename RNG>
stan::promote_args_t<T0__,
T1__>
foo_rng(const T0__& mu, const T1__& sigma, RNG& base_rng__,
        std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 288;
    return normal_rng(mu, sigma, base_rng__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_rng_functor__ {
template <typename T0__, typename T1__, typename RNG>
stan::promote_args_t<T0__,
T1__>
operator()(const T0__& mu, const T1__& sigma, RNG& base_rng__,
           std::ostream* pstream__)  const 
{
return foo_rng(mu, sigma, base_rng__, pstream__);
}
};

template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
unit_normal_lp(const T0__& u, T_lp__& lp__, T_lp_accum__& lp_accum__,
               std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 290;
    lp_accum__.add(normal_log<false>(u, 0, 1));
    current_statement__ = 291;
    lp_accum__.add(uniform_log<propto__>(u, -100, 100));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct unit_normal_lp_functor__ {
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
operator()(const T0__& u, T_lp__& lp__, T_lp_accum__& lp_accum__,
           std::ostream* pstream__)  const 
{
return unit_normal_lp(u, lp__, lp_accum__, pstream__);
}
};

int
foo_1(const int& a, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 294;
    while (1) {
      break;
    }
    current_statement__ = 296;
    while (0) {
      continue;
    }
    current_statement__ = 298;
    for (int i = 1; i <= 10; ++i) { break;}
    current_statement__ = 300;
    for (int i = 1; i <= 10; ++i) { continue;}
    current_statement__ = 305;
    while (1) {
      int b;
      b = std::numeric_limits<int>::min();
      
      current_statement__ = 302;
      b = 5;
      break;
    }
    current_statement__ = 312;
    while (1) {
      current_statement__ = 310;
      if (0) {
        break;
      } else {
        current_statement__ = 308;
        if (1) {
          break;
        } else {
          break;
        }
      }
    }
    current_statement__ = 315;
    while (1) {
      current_statement__ = 314;
      while (0) {
        break;
      }
    }
    current_statement__ = 319;
    while (1) {
      current_statement__ = 317;
      for (int i = 1; i <= 10; ++i) { break;}
    }
    current_statement__ = 334;
    while (1) {
      current_statement__ = 320;
      validate_non_negative_index("vs", "2", 2);
      current_statement__ = 320;
      validate_non_negative_index("vs", "3", 3);
      std::vector<std::vector<int>> vs;
      vs = std::vector<std::vector<int>>(2, std::vector<int>(3, std::numeric_limits<int>::min()));
      
      int z;
      z = std::numeric_limits<int>::min();
      
      current_statement__ = 322;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        {
          std::vector<int> v;
          current_statement__ = 322;
          assign(v, nil_index_list(), vs[(sym1__ - 1)],
            "assigning variable v");
          current_statement__ = 323;
          z = 0;
          break;
        }}
      current_statement__ = 325;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        {
          std::vector<int> v;
          current_statement__ = 325;
          assign(v, nil_index_list(), vs[(sym1__ - 1)],
            "assigning variable v");
          current_statement__ = 326;
          z = 0;
          continue;
        }}
      current_statement__ = 328;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        {
          std::vector<int> v;
          current_statement__ = 328;
          assign(v, nil_index_list(), vs[(sym1__ - 1)],
            "assigning variable v");
          current_statement__ = 329;
          for (int sym1__ = 1; sym1__ <= stan::math::size(v); ++sym1__) {
            {
              int vv;
              current_statement__ = 329;
              vv = v[(sym1__ - 1)];
              current_statement__ = 330;
              z = 0;
              break;
            }}
          current_statement__ = 332;
          z = 1;
        }}
    }
    current_statement__ = 344;
    while (1) {
      local_scalar_t__ z;
      z = DUMMY_VAR__;
      
      current_statement__ = 336;
      validate_non_negative_index("vs", "2", 2);
      current_statement__ = 336;
      validate_non_negative_index("vs", "3", 3);
      Eigen::Matrix<local_scalar_t__, -1, -1> vs;
      vs = Eigen::Matrix<local_scalar_t__, -1, -1>(2, 3);
      stan::math::fill(vs, DUMMY_VAR__);
      
      current_statement__ = 337;
      for (int sym1__ = 1; sym1__ <= rows(vs); ++sym1__) {
        current_statement__ = 337;
        for (int sym2__ = 1;
             sym2__ <= stan::math::size(
                         rvalue(vs,
                           cons_list(index_uni(sym1__), nil_index_list()),
                           "vs")); ++sym2__) {
          {
            local_scalar_t__ v;
            current_statement__ = 337;
            v = rvalue(vs,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())), "vs");
            current_statement__ = 338;
            z = 0;
            break;
          }}}
      current_statement__ = 340;
      for (int sym1__ = 1; sym1__ <= rows(vs); ++sym1__) {
        current_statement__ = 340;
        for (int sym2__ = 1;
             sym2__ <= stan::math::size(
                         rvalue(vs,
                           cons_list(index_uni(sym1__), nil_index_list()),
                           "vs")); ++sym2__) {
          {
            local_scalar_t__ v;
            current_statement__ = 340;
            v = rvalue(vs,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())), "vs");
            current_statement__ = 341;
            z = 3.1;
            continue;
          }}}
    }
    current_statement__ = 354;
    while (1) {
      local_scalar_t__ z;
      z = DUMMY_VAR__;
      
      current_statement__ = 346;
      validate_non_negative_index("vs", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> vs;
      vs = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(vs, DUMMY_VAR__);
      
      current_statement__ = 347;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        {
          local_scalar_t__ v;
          current_statement__ = 347;
          v = vs[(sym1__ - 1)];
          current_statement__ = 348;
          z = 0;
          break;
        }}
      current_statement__ = 350;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        {
          local_scalar_t__ v;
          current_statement__ = 350;
          v = vs[(sym1__ - 1)];
          current_statement__ = 351;
          z = 3.2;
          continue;
        }}
    }
    current_statement__ = 364;
    while (1) {
      local_scalar_t__ z;
      z = DUMMY_VAR__;
      
      current_statement__ = 356;
      validate_non_negative_index("vs", "2", 2);
      Eigen::Matrix<local_scalar_t__, 1, -1> vs;
      vs = Eigen::Matrix<local_scalar_t__, 1, -1>(2);
      stan::math::fill(vs, DUMMY_VAR__);
      
      current_statement__ = 357;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        {
          local_scalar_t__ v;
          current_statement__ = 357;
          v = vs[(sym1__ - 1)];
          current_statement__ = 358;
          z = 0;
          break;
        }}
      current_statement__ = 360;
      for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
        {
          local_scalar_t__ v;
          current_statement__ = 360;
          v = vs[(sym1__ - 1)];
          current_statement__ = 361;
          z = 3.3;
          continue;
        }}
    }
    current_statement__ = 372;
    while (1) {
      int b;
      b = std::numeric_limits<int>::min();
      
      current_statement__ = 366;
      b = 5;
      {
        int c;
        c = std::numeric_limits<int>::min();
        
        current_statement__ = 368;
        c = 6;
        break;
      }
    }
    current_statement__ = 373;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_1_functor__ {
int
operator()(const int& a, std::ostream* pstream__)  const 
{
return foo_1(a, pstream__);
}
};

int
foo_2(const int& a, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 375;
    validate_non_negative_index("vs", "2", 2);
    std::vector<int> vs;
    vs = std::vector<int>(2, std::numeric_limits<int>::min());
    
    int y;
    y = std::numeric_limits<int>::min();
    
    current_statement__ = 377;
    for (int sym1__ = 1; sym1__ <= stan::math::size(vs); ++sym1__) {
      {
        int v;
        current_statement__ = 377;
        v = vs[(sym1__ - 1)];
        current_statement__ = 378;
        y = v;
      }}
    current_statement__ = 379;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_2_functor__ {
int
operator()(const int& a, std::ostream* pstream__)  const 
{
return foo_2(a, pstream__);
}
};

template <typename T0__>
std::vector<stan::promote_args_t<T0__>>
foo_3(const T0__& t, const int& n, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 381;
    return rep_array(t, n);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_3_functor__ {
template <typename T0__>
std::vector<stan::promote_args_t<T0__>>
operator()(const T0__& t, const int& n, std::ostream* pstream__)  const 
{
return foo_3(t, n, pstream__);
}
};

template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
stan::promote_args_t<T0__>
foo_lp(const T0__& x, T_lp__& lp__, T_lp_accum__& lp_accum__,
       std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 383;
    return (x + get_lp(lp__, lp_accum__));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_lp_functor__ {
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
stan::promote_args_t<T0__>
operator()(const T0__& x, T_lp__& lp__, T_lp_accum__& lp_accum__,
           std::ostream* pstream__)  const 
{
return foo_lp(x, lp__, lp_accum__, pstream__);
}
};

template <typename T0__>
void
foo_4(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 385;
    std::stringstream errmsg_stream__;
    errmsg_stream__ << "user-specified rejection";
    errmsg_stream__ << x;
    throw std::domain_error(errmsg_stream__.str());
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_4_functor__ {
template <typename T0__>
void
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return foo_4(x, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
stan::promote_args_t<T0__, T1__, T2__,
T3__>
relative_diff(const T0__& x, const T1__& y, const T2__& max_,
              const T3__& min_, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ abs_diff;
    abs_diff = DUMMY_VAR__;
    
    local_scalar_t__ avg_scale;
    avg_scale = DUMMY_VAR__;
    
    current_statement__ = 389;
    abs_diff = stan::math::fabs((x - y));
    current_statement__ = 390;
    avg_scale = ((stan::math::fabs(x) + stan::math::fabs(y)) / 2);
    current_statement__ = 392;
    if (logical_gt((abs_diff / avg_scale), max_)) {
      current_statement__ = 391;
      std::stringstream errmsg_stream__;
      errmsg_stream__ << "user-specified rejection, difference above ";
      errmsg_stream__ << max_;
      errmsg_stream__ << " x:";
      errmsg_stream__ << x;
      errmsg_stream__ << " y:";
      errmsg_stream__ << y;
      throw std::domain_error(errmsg_stream__.str());
    } 
    current_statement__ = 394;
    if (logical_lt((abs_diff / avg_scale), min_)) {
      current_statement__ = 393;
      std::stringstream errmsg_stream__;
      errmsg_stream__ << "user-specified rejection, difference below ";
      errmsg_stream__ << min_;
      errmsg_stream__ << " x:";
      errmsg_stream__ << x;
      errmsg_stream__ << " y:";
      errmsg_stream__ << y;
      throw std::domain_error(errmsg_stream__.str());
    } 
    current_statement__ = 395;
    return (abs_diff / avg_scale);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct relative_diff_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__>
stan::promote_args_t<T0__, T1__, T2__,
T3__>
operator()(const T0__& x, const T1__& y, const T2__& max_, const T3__& min_,
           std::ostream* pstream__)  const 
{
return relative_diff(x, y, max_, min_, pstream__);
}
};

template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<T0__,
T1__>, -1, 1>
foo_5(const Eigen::Matrix<T0__, -1, 1>& shared_params,
      const Eigen::Matrix<T1__, -1, 1>& job_params,
      const std::vector<double>& data_r, const std::vector<int>& data_i,
      std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 397;
    return transpose(stan::math::to_row_vector(
             stan::math::array_builder<int>().add(1).add(2).add(3).array()));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_5_functor__ {
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<T0__,
T1__>, -1, 1>
operator()(const Eigen::Matrix<T0__, -1, 1>& shared_params,
           const Eigen::Matrix<T1__, -1, 1>& job_params,
           const std::vector<double>& data_r, const std::vector<int>& data_i,
           std::ostream* pstream__)  const 
{
return foo_5(shared_params, job_params, data_r, data_i, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__, typename T3__,
typename T4__>
stan::promote_args_t<T0__, T1__, T2__, T3__,
T4__>
foo_five_args(const T0__& x1, const T1__& x2, const T2__& x3, const T3__& x4,
              const T4__& x5, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
          T1__,
          T2__,
          T3__,
          T4__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 399;
    return x1;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_five_args_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__,
typename T4__>
stan::promote_args_t<T0__, T1__, T2__, T3__,
T4__>
operator()(const T0__& x1, const T1__& x2, const T2__& x3, const T3__& x4,
           const T4__& x5, std::ostream* pstream__)  const 
{
return foo_five_args(x1, x2, x3, x4, x5, pstream__);
}
};

template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__, typename T4__, typename T5__, typename T_lp__,
typename T_lp_accum__>
stan::promote_args_t<T0__, T1__, T2__, T3__,
T4__, stan::promote_args_t<T5__>>
foo_five_args_lp(const T0__& x1, const T1__& x2, const T2__& x3,
                 const T3__& x4, const T4__& x5, const T5__& x6,
                 T_lp__& lp__, T_lp_accum__& lp_accum__,
                 std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
          T1__,
          T2__,
          T3__,
          T4__, stan::promote_args_t<T5__>>;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 401;
    return x1;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_five_args_lp_functor__ {
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__, typename T4__, typename T5__, typename T_lp__,
typename T_lp_accum__>
stan::promote_args_t<T0__, T1__, T2__, T3__,
T4__, stan::promote_args_t<T5__>>
operator()(const T0__& x1, const T1__& x2, const T2__& x3, const T3__& x4,
           const T4__& x5, const T5__& x6, T_lp__& lp__,
           T_lp_accum__& lp_accum__, std::ostream* pstream__)  const 
{
return foo_five_args_lp(x1, x2, x3, x4, x5, x6, lp__, lp_accum__, pstream__);
}
};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<T0__>, -1, -1>
covsqrt2corsqrt(const Eigen::Matrix<T0__, -1, -1>& mat, const int& invert,
                std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 403;
    validate_non_negative_index("o", "rows(mat)", rows(mat));
    current_statement__ = 403;
    validate_non_negative_index("o", "cols(mat)", cols(mat));
    Eigen::Matrix<local_scalar_t__, -1, -1> o;
    o = Eigen::Matrix<local_scalar_t__, -1, -1>(rows(mat), cols(mat));
    stan::math::fill(o, DUMMY_VAR__);
    
    current_statement__ = 404;
    assign(o, nil_index_list(), mat, "assigning variable o");
    current_statement__ = 405;
    assign(o, cons_list(index_uni(1), nil_index_list()),
      stan::model::deep_copy(
        rvalue(o, cons_list(index_uni(2), nil_index_list()), "o")),
      "assigning variable o");
    current_statement__ = 406;
    assign(o, cons_list(index_min_max(3, 4), nil_index_list()),
      stan::model::deep_copy(
        rvalue(o, cons_list(index_min_max(1, 2), nil_index_list()), "o")),
      "assigning variable o");
    current_statement__ = 407;
    return o;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct covsqrt2corsqrt_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<T0__>, -1, -1>
operator()(const Eigen::Matrix<T0__, -1, -1>& mat, const int& invert,
           std::ostream* pstream__)  const 
{
return covsqrt2corsqrt(mat, invert, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
void
f0(const int& a1, const std::vector<int>& a2,
   const std::vector<std::vector<int>>& a3, const T3__& a4,
   const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
   const Eigen::Matrix<T6__, -1, 1>& a7,
   const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
   const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
   const Eigen::Matrix<T9__, -1, -1>& a10,
   const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
   const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 409;
    if (pstream__) {
      stan_print(pstream__, "hi");
      stan_print(pstream__, "\n");
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f0_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
void
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f0(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
int
f1(const int& a1, const std::vector<int>& a2,
   const std::vector<std::vector<int>>& a3, const T3__& a4,
   const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
   const Eigen::Matrix<T6__, -1, 1>& a7,
   const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
   const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
   const Eigen::Matrix<T9__, -1, -1>& a10,
   const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
   const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 411;
    return a1;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f1_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
int
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f1(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<int>
f2(const int& a1, const std::vector<int>& a2,
   const std::vector<std::vector<int>>& a3, const T3__& a4,
   const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
   const Eigen::Matrix<T6__, -1, 1>& a7,
   const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
   const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
   const Eigen::Matrix<T9__, -1, -1>& a10,
   const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
   const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 413;
    return a2;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f2_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<int>
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f2(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<std::vector<int>>
f3(const int& a1, const std::vector<int>& a2,
   const std::vector<std::vector<int>>& a3, const T3__& a4,
   const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
   const Eigen::Matrix<T6__, -1, 1>& a7,
   const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
   const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
   const Eigen::Matrix<T9__, -1, -1>& a10,
   const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
   const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 415;
    return a3;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f3_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<std::vector<int>>
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f3(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>
f4(const int& a1, const std::vector<int>& a2,
   const std::vector<std::vector<int>>& a3, const T3__& a4,
   const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
   const Eigen::Matrix<T6__, -1, 1>& a7,
   const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
   const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
   const Eigen::Matrix<T9__, -1, -1>& a10,
   const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
   const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 417;
    return a4;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f4_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f4(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>>
f5(const int& a1, const std::vector<int>& a2,
   const std::vector<std::vector<int>>& a3, const T3__& a4,
   const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
   const Eigen::Matrix<T6__, -1, 1>& a7,
   const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
   const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
   const Eigen::Matrix<T9__, -1, -1>& a10,
   const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
   const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 419;
    return a5;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f5_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>>
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f5(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<std::vector<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>>>
f6(const int& a1, const std::vector<int>& a2,
   const std::vector<std::vector<int>>& a3, const T3__& a4,
   const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
   const Eigen::Matrix<T6__, -1, 1>& a7,
   const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
   const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
   const Eigen::Matrix<T9__, -1, -1>& a10,
   const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
   const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 421;
    return a6;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f6_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<std::vector<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>>>
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f6(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
Eigen::Matrix<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>, -1, 1>
f7(const int& a1, const std::vector<int>& a2,
   const std::vector<std::vector<int>>& a3, const T3__& a4,
   const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
   const Eigen::Matrix<T6__, -1, 1>& a7,
   const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
   const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
   const Eigen::Matrix<T9__, -1, -1>& a10,
   const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
   const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 423;
    return a7;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f7_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
Eigen::Matrix<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>, -1, 1>
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f7(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<Eigen::Matrix<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>, -1, 1>>
f8(const int& a1, const std::vector<int>& a2,
   const std::vector<std::vector<int>>& a3, const T3__& a4,
   const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
   const Eigen::Matrix<T6__, -1, 1>& a7,
   const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
   const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
   const Eigen::Matrix<T9__, -1, -1>& a10,
   const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
   const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 425;
    return a8;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f8_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<Eigen::Matrix<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>, -1, 1>>
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f8(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<std::vector<Eigen::Matrix<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>, -1, 1>>>
f9(const int& a1, const std::vector<int>& a2,
   const std::vector<std::vector<int>>& a3, const T3__& a4,
   const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
   const Eigen::Matrix<T6__, -1, 1>& a7,
   const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
   const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
   const Eigen::Matrix<T9__, -1, -1>& a10,
   const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
   const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 427;
    return a9;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f9_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<std::vector<Eigen::Matrix<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>, -1, 1>>>
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f9(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
Eigen::Matrix<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>, -1, -1>
f10(const int& a1, const std::vector<int>& a2,
    const std::vector<std::vector<int>>& a3, const T3__& a4,
    const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
    const Eigen::Matrix<T6__, -1, 1>& a7,
    const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
    const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
    const Eigen::Matrix<T9__, -1, -1>& a10,
    const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
    const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 429;
    return a10;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f10_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
Eigen::Matrix<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>, -1, -1>
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f10(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<Eigen::Matrix<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>, -1, -1>>
f11(const int& a1, const std::vector<int>& a2,
    const std::vector<std::vector<int>>& a3, const T3__& a4,
    const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
    const Eigen::Matrix<T6__, -1, 1>& a7,
    const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
    const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
    const Eigen::Matrix<T9__, -1, -1>& a10,
    const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
    const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 431;
    return a11;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f11_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<Eigen::Matrix<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>, -1, -1>>
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<std::vector<Eigen::Matrix<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>, -1, -1>>>
f12(const int& a1, const std::vector<int>& a2,
    const std::vector<std::vector<int>>& a3, const T3__& a4,
    const std::vector<T4__>& a5, const std::vector<std::vector<T5__>>& a6,
    const Eigen::Matrix<T6__, -1, 1>& a7,
    const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
    const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
    const Eigen::Matrix<T9__, -1, -1>& a10,
    const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
    const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T8__,
          T9__,
          T10__,
          T11__>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 433;
    return a12;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f12_functor__ {
template <typename T3__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
std::vector<std::vector<Eigen::Matrix<stan::promote_args_t<T3__, T4__, T5__, T6__, T7__, stan::promote_args_t<T8__,
T9__, T10__,
T11__>>, -1, -1>>>
operator()(const int& a1, const std::vector<int>& a2,
           const std::vector<std::vector<int>>& a3, const T3__& a4,
           const std::vector<T4__>& a5,
           const std::vector<std::vector<T5__>>& a6,
           const Eigen::Matrix<T6__, -1, 1>& a7,
           const std::vector<Eigen::Matrix<T7__, -1, 1>>& a8,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& a9,
           const Eigen::Matrix<T9__, -1, -1>& a10,
           const std::vector<Eigen::Matrix<T10__, -1, -1>>& a11,
           const std::vector<std::vector<Eigen::Matrix<T11__, -1, -1>>>& a12,
           std::ostream* pstream__)  const 
{
return f12(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, pstream__);
}
};

void
foo_6(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int a;
    a = std::numeric_limits<int>::min();
    
    local_scalar_t__ b;
    b = DUMMY_VAR__;
    
    current_statement__ = 437;
    validate_non_negative_index("c", "20", 20);
    current_statement__ = 437;
    validate_non_negative_index("c", "30", 30);
    std::vector<std::vector<local_scalar_t__>> c;
    c = std::vector<std::vector<local_scalar_t__>>(20, std::vector<local_scalar_t__>(30, DUMMY_VAR__));
    
    current_statement__ = 438;
    validate_non_negative_index("ar_mat", "60", 60);
    current_statement__ = 438;
    validate_non_negative_index("ar_mat", "70", 70);
    current_statement__ = 438;
    validate_non_negative_index("ar_mat", "40", 40);
    current_statement__ = 438;
    validate_non_negative_index("ar_mat", "50", 50);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>> ar_mat;
    ar_mat = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>>(60, std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(70, Eigen::Matrix<local_scalar_t__, -1, -1>(40, 50)));
    stan::math::fill(ar_mat, DUMMY_VAR__);
    
    current_statement__ = 439;
    assign(ar_mat,
      cons_list(index_uni(1),
        cons_list(index_uni(1),
          cons_list(index_uni(1), cons_list(index_uni(1), nil_index_list())))),
      b, "assigning variable ar_mat");
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_6_functor__ {
void
operator()(std::ostream* pstream__)  const 
{
return foo_6(pstream__);
}
};

Eigen::Matrix<double, -1, -1>
matfoo(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 441;
    return stan::math::to_matrix(
        stan::math::array_builder<Eigen::Matrix<double, 1, -1>>()
        .add(stan::math::to_row_vector(stan::math::array_builder<int>()
        .add(1).add(2).add(3).add(4).add(5).add(6).add(7).add(8).add(9)
        .add(10).array())).add(stan::math::to_row_vector(
        stan::math::array_builder<int>().add(1).add(2).add(3).add(4).add(5)
        .add(6).add(7).add(8).add(9).add(10).array()))
        .add(stan::math::to_row_vector(stan::math::array_builder<int>()
        .add(1).add(2).add(3).add(4).add(5).add(6).add(7).add(8).add(9)
        .add(10).array())).array());
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct matfoo_functor__ {
Eigen::Matrix<double, -1, -1>
operator()(std::ostream* pstream__)  const 
{
return matfoo(pstream__);
}
};

Eigen::Matrix<double, -1, 1>
vecfoo(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 443;
    return transpose(stan::math::to_row_vector(
             stan::math::array_builder<int>().add(1).add(2).add(3).add(4)
             .add(5).add(6).add(7).add(8).add(9).add(10).array()));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct vecfoo_functor__ {
Eigen::Matrix<double, -1, 1>
operator()(std::ostream* pstream__)  const 
{
return vecfoo(pstream__);
}
};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<T0__>, -1, 1>
vecmufoo(const T0__& mu, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 445;
    validate_non_negative_index("l", "10", 10);
    Eigen::Matrix<local_scalar_t__, -1, 1> l;
    l = Eigen::Matrix<local_scalar_t__, -1, 1>(10);
    stan::math::fill(l, DUMMY_VAR__);
    
    current_statement__ = 445;
    assign(l, nil_index_list(), multiply(mu, vecfoo(pstream__)),
      "assigning variable l");
    current_statement__ = 446;
    return l;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct vecmufoo_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<T0__>, -1, 1>
operator()(const T0__& mu, std::ostream* pstream__)  const 
{
return vecmufoo(mu, pstream__);
}
};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<T0__>, -1, 1>
vecmubar(const T0__& mu, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 448;
    validate_non_negative_index("l", "10", 10);
    Eigen::Matrix<local_scalar_t__, -1, 1> l;
    l = Eigen::Matrix<local_scalar_t__, -1, 1>(10);
    stan::math::fill(l, DUMMY_VAR__);
    
    current_statement__ = 448;
    assign(l, nil_index_list(),
      multiply(mu,
        transpose(stan::math::to_row_vector(stan::math::array_builder<int>()
          .add(1).add(2).add(3).add(4).add(5).add(6).add(7).add(8).add(9)
          .add(10).array()))), "assigning variable l");
    current_statement__ = 449;
    return rvalue(l,
             cons_list(index_multi(stan::math::array_builder<int>().add(1)
               .add(2).add(3).add(4).add(5).array()), nil_index_list()), "l");
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct vecmubar_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<T0__>, -1, 1>
operator()(const T0__& mu, std::ostream* pstream__)  const 
{
return vecmubar(mu, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<T0__, T1__,
T2__>, -1, 1>
algebra_system(const Eigen::Matrix<T0__, -1, 1>& x,
               const Eigen::Matrix<T1__, -1, 1>& y,
               const std::vector<T2__>& dat, const std::vector<int>& dat_int,
               std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 451;
    validate_non_negative_index("f_x", "2", 2);
    Eigen::Matrix<local_scalar_t__, -1, 1> f_x;
    f_x = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
    stan::math::fill(f_x, DUMMY_VAR__);
    
    current_statement__ = 452;
    assign(f_x, cons_list(index_uni(1), nil_index_list()),
      (rvalue(x, cons_list(index_uni(1), nil_index_list()), "x") -
        rvalue(y, cons_list(index_uni(1), nil_index_list()), "y")),
      "assigning variable f_x");
    current_statement__ = 453;
    assign(f_x, cons_list(index_uni(2), nil_index_list()),
      (rvalue(x, cons_list(index_uni(2), nil_index_list()), "x") -
        rvalue(y, cons_list(index_uni(2), nil_index_list()), "y")),
      "assigning variable f_x");
    current_statement__ = 454;
    return f_x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct algebra_system_functor__ {
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<T0__, T1__,
T2__>, -1, 1>
operator()(const Eigen::Matrix<T0__, -1, 1>& x,
           const Eigen::Matrix<T1__, -1, 1>& y, const std::vector<T2__>& dat,
           const std::vector<int>& dat_int, std::ostream* pstream__)  const 
{
return algebra_system(x, y, dat, dat_int, pstream__);
}
};

template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<T0__,
T1__>, -1, 1>
binomialf(const Eigen::Matrix<T0__, -1, 1>& phi,
          const Eigen::Matrix<T1__, -1, 1>& theta,
          const std::vector<double>& x_r, const std::vector<int>& x_i,
          std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 456;
    validate_non_negative_index("lpmf", "1", 1);
    Eigen::Matrix<local_scalar_t__, -1, 1> lpmf;
    lpmf = Eigen::Matrix<local_scalar_t__, -1, 1>(1);
    stan::math::fill(lpmf, DUMMY_VAR__);
    
    current_statement__ = 457;
    assign(lpmf, cons_list(index_uni(1), nil_index_list()), 0.0,
      "assigning variable lpmf");
    current_statement__ = 458;
    return lpmf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct binomialf_functor__ {
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<T0__,
T1__>, -1, 1>
operator()(const Eigen::Matrix<T0__, -1, 1>& phi,
           const Eigen::Matrix<T1__, -1, 1>& theta,
           const std::vector<double>& x_r, const std::vector<int>& x_i,
           std::ostream* pstream__)  const 
{
return binomialf(phi, theta, x_r, x_i, pstream__);
}
};

class mother_model : public model_base_crtp<mother_model> {

 private:
  int pos__;
  int N;
  int M;
  int K;
  std::vector<int> d_int_1d_ar;
  std::vector<std::vector<std::vector<int>>> d_int_3d_ar;
  double J;
  std::vector<double> d_real_1d_ar;
  std::vector<std::vector<std::vector<double>>> d_real_3d_ar;
  Eigen::Matrix<double, -1, 1> d_vec;
  std::vector<Eigen::Matrix<double, -1, 1>> d_1d_vec;
  std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>> d_3d_vec;
  Eigen::Matrix<double, 1, -1> d_row_vec;
  std::vector<Eigen::Matrix<double, 1, -1>> d_1d_row_vec;
  std::vector<std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>> d_3d_row_vec;
  std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> d_ar_mat;
  Eigen::Matrix<double, -1, 1> d_simplex;
  std::vector<Eigen::Matrix<double, -1, 1>> d_1d_simplex;
  std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>> d_3d_simplex;
  Eigen::Matrix<double, -1, -1> d_cfcov_54;
  Eigen::Matrix<double, -1, -1> d_cfcov_33;
  std::vector<Eigen::Matrix<double, -1, -1>> d_cfcov_33_ar;
  int td_int;
  std::vector<int> td_1d;
  std::vector<int> td_1dk;
  int td_a;
  double td_b;
  double td_c;
  std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> td_ar_mat;
  Eigen::Matrix<double, -1, 1> td_simplex;
  std::vector<Eigen::Matrix<double, -1, 1>> td_1d_simplex;
  std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>> td_3d_simplex;
  Eigen::Matrix<double, -1, -1> td_cfcov_54;
  Eigen::Matrix<double, -1, -1> td_cfcov_33;
  Eigen::Matrix<double, -1, 1> x;
  Eigen::Matrix<double, -1, 1> y;
  std::vector<double> dat;
  std::vector<int> dat_int;
  std::vector<std::vector<double>> x_r;
  std::vector<std::vector<int>> x_i;
  std::vector<std::vector<int>> arr_mul_ind;
  std::vector<double> x_mul_ind;
 
 public:
  ~mother_model() { }
  
  std::string model_name() const { return "mother_model"; }
  
  mother_model(stan::io::var_context& context__,
               unsigned int random_seed__ = 0,
               std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "mother_model_namespace::mother_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 181;
      N = context__.vals_i("N")[(1 - 1)];
      context__.validate_dims("data initialization","M","int",
          context__.to_vec());
      M = std::numeric_limits<int>::min();
      
      current_statement__ = 182;
      M = context__.vals_i("M")[(1 - 1)];
      context__.validate_dims("data initialization","K","int",
          context__.to_vec());
      K = std::numeric_limits<int>::min();
      
      current_statement__ = 183;
      K = context__.vals_i("K")[(1 - 1)];
      current_statement__ = 184;
      validate_non_negative_index("d_int_1d_ar", "N", N);
      context__.validate_dims("data initialization","d_int_1d_ar","int",
          context__.to_vec(N));
      d_int_1d_ar = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 184;
      assign(d_int_1d_ar, nil_index_list(), context__.vals_i("d_int_1d_ar"),
        "assigning variable d_int_1d_ar");
      current_statement__ = 185;
      validate_non_negative_index("d_int_3d_ar", "N", N);
      current_statement__ = 185;
      validate_non_negative_index("d_int_3d_ar", "M", M);
      current_statement__ = 185;
      validate_non_negative_index("d_int_3d_ar", "K", K);
      context__.validate_dims("data initialization","d_int_3d_ar","int",
          context__.to_vec(N, M, K));
      d_int_3d_ar = std::vector<std::vector<std::vector<int>>>(N, std::vector<std::vector<int>>(M, std::vector<int>(K, std::numeric_limits<int>::min())));
      
      {
        std::vector<int> d_int_3d_ar_flat__;
        current_statement__ = 185;
        assign(d_int_3d_ar_flat__, nil_index_list(),
          context__.vals_i("d_int_3d_ar"),
          "assigning variable d_int_3d_ar_flat__");
        current_statement__ = 185;
        pos__ = 1;
        current_statement__ = 185;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 185;
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            current_statement__ = 185;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 185;
              assign(d_int_3d_ar,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                d_int_3d_ar_flat__[(pos__ - 1)],
                "assigning variable d_int_3d_ar");
              current_statement__ = 185;
              pos__ = (pos__ + 1);}}}
      }
      context__.validate_dims("data initialization","J","double",
          context__.to_vec());
      J = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 186;
      J = context__.vals_r("J")[(1 - 1)];
      current_statement__ = 187;
      validate_non_negative_index("d_real_1d_ar", "N", N);
      context__.validate_dims("data initialization","d_real_1d_ar","double",
          context__.to_vec(N));
      d_real_1d_ar = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 187;
      assign(d_real_1d_ar, nil_index_list(),
        context__.vals_r("d_real_1d_ar"), "assigning variable d_real_1d_ar");
      current_statement__ = 188;
      validate_non_negative_index("d_real_3d_ar", "N", N);
      current_statement__ = 188;
      validate_non_negative_index("d_real_3d_ar", "M", M);
      current_statement__ = 188;
      validate_non_negative_index("d_real_3d_ar", "K", K);
      context__.validate_dims("data initialization","d_real_3d_ar","double",
          context__.to_vec(N, M, K));
      d_real_3d_ar = std::vector<std::vector<std::vector<double>>>(N, std::vector<std::vector<double>>(M, std::vector<double>(K, std::numeric_limits<double>::quiet_NaN())));
      
      {
        std::vector<local_scalar_t__> d_real_3d_ar_flat__;
        current_statement__ = 188;
        assign(d_real_3d_ar_flat__, nil_index_list(),
          context__.vals_r("d_real_3d_ar"),
          "assigning variable d_real_3d_ar_flat__");
        current_statement__ = 188;
        pos__ = 1;
        current_statement__ = 188;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 188;
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            current_statement__ = 188;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 188;
              assign(d_real_3d_ar,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                d_real_3d_ar_flat__[(pos__ - 1)],
                "assigning variable d_real_3d_ar");
              current_statement__ = 188;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 189;
      validate_non_negative_index("d_vec", "N", N);
      context__.validate_dims("data initialization","d_vec","double",
          context__.to_vec(N));
      d_vec = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(d_vec, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_vec_flat__;
        current_statement__ = 189;
        assign(d_vec_flat__, nil_index_list(), context__.vals_r("d_vec"),
          "assigning variable d_vec_flat__");
        current_statement__ = 189;
        pos__ = 1;
        current_statement__ = 189;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 189;
          assign(d_vec, cons_list(index_uni(sym1__), nil_index_list()),
            d_vec_flat__[(pos__ - 1)], "assigning variable d_vec");
          current_statement__ = 189;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 190;
      validate_non_negative_index("d_1d_vec", "N", N);
      current_statement__ = 190;
      validate_non_negative_index("d_1d_vec", "N", N);
      context__.validate_dims("data initialization","d_1d_vec","double",
          context__.to_vec(N, N));
      d_1d_vec = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(d_1d_vec, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_1d_vec_flat__;
        current_statement__ = 190;
        assign(d_1d_vec_flat__, nil_index_list(),
          context__.vals_r("d_1d_vec"), "assigning variable d_1d_vec_flat__");
        current_statement__ = 190;
        pos__ = 1;
        current_statement__ = 190;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 190;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 190;
            assign(d_1d_vec,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              d_1d_vec_flat__[(pos__ - 1)], "assigning variable d_1d_vec");
            current_statement__ = 190;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 191;
      validate_non_negative_index("d_3d_vec", "N", N);
      current_statement__ = 191;
      validate_non_negative_index("d_3d_vec", "M", M);
      current_statement__ = 191;
      validate_non_negative_index("d_3d_vec", "K", K);
      current_statement__ = 191;
      validate_non_negative_index("d_3d_vec", "N", N);
      context__.validate_dims("data initialization","d_3d_vec","double",
          context__.to_vec(N, M, K, N));
      d_3d_vec = std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(N))));
      stan::math::fill(d_3d_vec, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_3d_vec_flat__;
        current_statement__ = 191;
        assign(d_3d_vec_flat__, nil_index_list(),
          context__.vals_r("d_3d_vec"), "assigning variable d_3d_vec_flat__");
        current_statement__ = 191;
        pos__ = 1;
        current_statement__ = 191;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 191;
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            current_statement__ = 191;
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              current_statement__ = 191;
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                current_statement__ = 191;
                assign(d_3d_vec,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  d_3d_vec_flat__[(pos__ - 1)], "assigning variable d_3d_vec");
                current_statement__ = 191;
                pos__ = (pos__ + 1);}}}}
      }
      current_statement__ = 192;
      validate_non_negative_index("d_row_vec", "N", N);
      context__.validate_dims("data initialization","d_row_vec","double",
          context__.to_vec(N));
      d_row_vec = Eigen::Matrix<double, 1, -1>(N);
      stan::math::fill(d_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_row_vec_flat__;
        current_statement__ = 192;
        assign(d_row_vec_flat__, nil_index_list(),
          context__.vals_r("d_row_vec"),
          "assigning variable d_row_vec_flat__");
        current_statement__ = 192;
        pos__ = 1;
        current_statement__ = 192;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 192;
          assign(d_row_vec, cons_list(index_uni(sym1__), nil_index_list()),
            d_row_vec_flat__[(pos__ - 1)], "assigning variable d_row_vec");
          current_statement__ = 192;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 193;
      validate_non_negative_index("d_1d_row_vec", "N", N);
      current_statement__ = 193;
      validate_non_negative_index("d_1d_row_vec", "N", N);
      context__.validate_dims("data initialization","d_1d_row_vec","double",
          context__.to_vec(N, N));
      d_1d_row_vec = std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N));
      stan::math::fill(d_1d_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_1d_row_vec_flat__;
        current_statement__ = 193;
        assign(d_1d_row_vec_flat__, nil_index_list(),
          context__.vals_r("d_1d_row_vec"),
          "assigning variable d_1d_row_vec_flat__");
        current_statement__ = 193;
        pos__ = 1;
        current_statement__ = 193;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 193;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 193;
            assign(d_1d_row_vec,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              d_1d_row_vec_flat__[(pos__ - 1)],
              "assigning variable d_1d_row_vec");
            current_statement__ = 193;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 194;
      validate_non_negative_index("d_3d_row_vec", "N", N);
      current_statement__ = 194;
      validate_non_negative_index("d_3d_row_vec", "M", M);
      current_statement__ = 194;
      validate_non_negative_index("d_3d_row_vec", "K", K);
      current_statement__ = 194;
      validate_non_negative_index("d_3d_row_vec", "N", N);
      context__.validate_dims("data initialization","d_3d_row_vec","double",
          context__.to_vec(N, M, K, N));
      d_3d_row_vec = std::vector<std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(M, std::vector<Eigen::Matrix<double, 1, -1>>(K, Eigen::Matrix<double, 1, -1>(N))));
      stan::math::fill(d_3d_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_3d_row_vec_flat__;
        current_statement__ = 194;
        assign(d_3d_row_vec_flat__, nil_index_list(),
          context__.vals_r("d_3d_row_vec"),
          "assigning variable d_3d_row_vec_flat__");
        current_statement__ = 194;
        pos__ = 1;
        current_statement__ = 194;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 194;
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            current_statement__ = 194;
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              current_statement__ = 194;
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                current_statement__ = 194;
                assign(d_3d_row_vec,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  d_3d_row_vec_flat__[(pos__ - 1)],
                  "assigning variable d_3d_row_vec");
                current_statement__ = 194;
                pos__ = (pos__ + 1);}}}}
      }
      current_statement__ = 195;
      validate_non_negative_index("d_ar_mat", "4", 4);
      current_statement__ = 195;
      validate_non_negative_index("d_ar_mat", "5", 5);
      current_statement__ = 195;
      validate_non_negative_index("d_ar_mat", "2", 2);
      current_statement__ = 195;
      validate_non_negative_index("d_ar_mat", "3", 3);
      context__.validate_dims("data initialization","d_ar_mat","double",
          context__.to_vec(4, 5, 2, 3));
      d_ar_mat = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(4, std::vector<Eigen::Matrix<double, -1, -1>>(5, Eigen::Matrix<double, -1, -1>(2, 3)));
      stan::math::fill(d_ar_mat, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_ar_mat_flat__;
        current_statement__ = 195;
        assign(d_ar_mat_flat__, nil_index_list(),
          context__.vals_r("d_ar_mat"), "assigning variable d_ar_mat_flat__");
        current_statement__ = 195;
        pos__ = 1;
        current_statement__ = 195;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 195;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 195;
            for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
              current_statement__ = 195;
              for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
                current_statement__ = 195;
                assign(d_ar_mat,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  d_ar_mat_flat__[(pos__ - 1)], "assigning variable d_ar_mat");
                current_statement__ = 195;
                pos__ = (pos__ + 1);}}}}
      }
      current_statement__ = 196;
      validate_non_negative_index("d_simplex", "N", N);
      context__.validate_dims("data initialization","d_simplex","double",
          context__.to_vec(N));
      d_simplex = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_simplex_flat__;
        current_statement__ = 196;
        assign(d_simplex_flat__, nil_index_list(),
          context__.vals_r("d_simplex"),
          "assigning variable d_simplex_flat__");
        current_statement__ = 196;
        pos__ = 1;
        current_statement__ = 196;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 196;
          assign(d_simplex, cons_list(index_uni(sym1__), nil_index_list()),
            d_simplex_flat__[(pos__ - 1)], "assigning variable d_simplex");
          current_statement__ = 196;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 197;
      validate_non_negative_index("d_1d_simplex", "N", N);
      current_statement__ = 197;
      validate_non_negative_index("d_1d_simplex", "N", N);
      context__.validate_dims("data initialization","d_1d_simplex","double",
          context__.to_vec(N, N));
      d_1d_simplex = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(d_1d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_1d_simplex_flat__;
        current_statement__ = 197;
        assign(d_1d_simplex_flat__, nil_index_list(),
          context__.vals_r("d_1d_simplex"),
          "assigning variable d_1d_simplex_flat__");
        current_statement__ = 197;
        pos__ = 1;
        current_statement__ = 197;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 197;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 197;
            assign(d_1d_simplex,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              d_1d_simplex_flat__[(pos__ - 1)],
              "assigning variable d_1d_simplex");
            current_statement__ = 197;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 198;
      validate_non_negative_index("d_3d_simplex", "N", N);
      current_statement__ = 198;
      validate_non_negative_index("d_3d_simplex", "M", M);
      current_statement__ = 198;
      validate_non_negative_index("d_3d_simplex", "K", K);
      current_statement__ = 198;
      validate_non_negative_index("d_3d_simplex", "N", N);
      context__.validate_dims("data initialization","d_3d_simplex","double",
          context__.to_vec(N, M, K, N));
      d_3d_simplex = std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(N))));
      stan::math::fill(d_3d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_3d_simplex_flat__;
        current_statement__ = 198;
        assign(d_3d_simplex_flat__, nil_index_list(),
          context__.vals_r("d_3d_simplex"),
          "assigning variable d_3d_simplex_flat__");
        current_statement__ = 198;
        pos__ = 1;
        current_statement__ = 198;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 198;
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            current_statement__ = 198;
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              current_statement__ = 198;
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                current_statement__ = 198;
                assign(d_3d_simplex,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  d_3d_simplex_flat__[(pos__ - 1)],
                  "assigning variable d_3d_simplex");
                current_statement__ = 198;
                pos__ = (pos__ + 1);}}}}
      }
      current_statement__ = 199;
      validate_non_negative_index("d_cfcov_54", "5", 5);
      current_statement__ = 199;
      validate_non_negative_index("d_cfcov_54", "4", 4);
      context__.validate_dims("data initialization","d_cfcov_54","double",
          context__.to_vec(5, 4));
      d_cfcov_54 = Eigen::Matrix<double, -1, -1>(5, 4);
      stan::math::fill(d_cfcov_54, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_cfcov_54_flat__;
        current_statement__ = 199;
        assign(d_cfcov_54_flat__, nil_index_list(),
          context__.vals_r("d_cfcov_54"),
          "assigning variable d_cfcov_54_flat__");
        current_statement__ = 199;
        pos__ = 1;
        current_statement__ = 199;
        for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
          current_statement__ = 199;
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            current_statement__ = 199;
            assign(d_cfcov_54,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              d_cfcov_54_flat__[(pos__ - 1)], "assigning variable d_cfcov_54");
            current_statement__ = 199;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 200;
      validate_non_negative_index("d_cfcov_33", "3", 3);
      current_statement__ = 200;
      validate_non_negative_index("d_cfcov_33", "3", 3);
      context__.validate_dims("data initialization","d_cfcov_33","double",
          context__.to_vec(3, 3));
      d_cfcov_33 = Eigen::Matrix<double, -1, -1>(3, 3);
      stan::math::fill(d_cfcov_33, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_cfcov_33_flat__;
        current_statement__ = 200;
        assign(d_cfcov_33_flat__, nil_index_list(),
          context__.vals_r("d_cfcov_33"),
          "assigning variable d_cfcov_33_flat__");
        current_statement__ = 200;
        pos__ = 1;
        current_statement__ = 200;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 200;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 200;
            assign(d_cfcov_33,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              d_cfcov_33_flat__[(pos__ - 1)], "assigning variable d_cfcov_33");
            current_statement__ = 200;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 201;
      validate_non_negative_index("d_cfcov_33_ar", "K", K);
      current_statement__ = 201;
      validate_non_negative_index("d_cfcov_33_ar", "3", 3);
      current_statement__ = 201;
      validate_non_negative_index("d_cfcov_33_ar", "3", 3);
      context__.validate_dims("data initialization","d_cfcov_33_ar","double",
          context__.to_vec(K, 3, 3));
      d_cfcov_33_ar = std::vector<Eigen::Matrix<double, -1, -1>>(K, Eigen::Matrix<double, -1, -1>(3, 3));
      stan::math::fill(d_cfcov_33_ar, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> d_cfcov_33_ar_flat__;
        current_statement__ = 201;
        assign(d_cfcov_33_ar_flat__, nil_index_list(),
          context__.vals_r("d_cfcov_33_ar"),
          "assigning variable d_cfcov_33_ar_flat__");
        current_statement__ = 201;
        pos__ = 1;
        current_statement__ = 201;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 201;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 201;
            for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
              current_statement__ = 201;
              assign(d_cfcov_33_ar,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                d_cfcov_33_ar_flat__[(pos__ - 1)],
                "assigning variable d_cfcov_33_ar");
              current_statement__ = 201;
              pos__ = (pos__ + 1);}}}
      }
      td_int = std::numeric_limits<int>::min();
      
      current_statement__ = 203;
      validate_non_negative_index("td_1d", "N", N);
      td_1d = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 204;
      validate_non_negative_index("td_1dk", "M", M);
      td_1dk = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 204;
      assign(td_1dk, nil_index_list(), rep_array(1, M),
        "assigning variable td_1dk");
      td_a = std::numeric_limits<int>::min();
      
      current_statement__ = 205;
      td_a = N;
      td_b = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 206;
      td_b = (N * J);
      td_c = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 207;
      td_c = foo_bar1(td_b, pstream__);
      current_statement__ = 208;
      validate_non_negative_index("td_ar_mat", "4", 4);
      current_statement__ = 208;
      validate_non_negative_index("td_ar_mat", "5", 5);
      current_statement__ = 208;
      validate_non_negative_index("td_ar_mat", "2", 2);
      current_statement__ = 208;
      validate_non_negative_index("td_ar_mat", "3", 3);
      td_ar_mat = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(4, std::vector<Eigen::Matrix<double, -1, -1>>(5, Eigen::Matrix<double, -1, -1>(2, 3)));
      stan::math::fill(td_ar_mat, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 209;
      validate_non_negative_index("td_simplex", "N", N);
      td_simplex = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(td_simplex, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 210;
      validate_non_negative_index("td_1d_simplex", "N", N);
      current_statement__ = 210;
      validate_non_negative_index("td_1d_simplex", "N", N);
      td_1d_simplex = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(td_1d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 211;
      validate_non_negative_index("td_3d_simplex", "N", N);
      current_statement__ = 211;
      validate_non_negative_index("td_3d_simplex", "M", M);
      current_statement__ = 211;
      validate_non_negative_index("td_3d_simplex", "K", K);
      current_statement__ = 211;
      validate_non_negative_index("td_3d_simplex", "N", N);
      td_3d_simplex = std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(N))));
      stan::math::fill(td_3d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 212;
      validate_non_negative_index("td_cfcov_54", "5", 5);
      current_statement__ = 212;
      validate_non_negative_index("td_cfcov_54", "5", 5);
      td_cfcov_54 = Eigen::Matrix<double, -1, -1>(5, 5);
      stan::math::fill(td_cfcov_54, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 213;
      validate_non_negative_index("td_cfcov_33", "3", 3);
      current_statement__ = 213;
      validate_non_negative_index("td_cfcov_33", "3", 3);
      td_cfcov_33 = Eigen::Matrix<double, -1, -1>(3, 3);
      stan::math::fill(td_cfcov_33, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 214;
      validate_non_negative_index("x", "2", 2);
      x = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(x, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 215;
      validate_non_negative_index("y", "2", 2);
      y = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(y, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 216;
      validate_non_negative_index("dat", "0", 0);
      dat = std::vector<double>(0, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 217;
      validate_non_negative_index("dat_int", "0", 0);
      dat_int = std::vector<int>(0, std::numeric_limits<int>::min());
      
      current_statement__ = 218;
      validate_non_negative_index("x_r", "0", 0);
      current_statement__ = 218;
      validate_non_negative_index("x_r", "0", 0);
      x_r = std::vector<std::vector<double>>(0, std::vector<double>(0, std::numeric_limits<double>::quiet_NaN()));
      
      current_statement__ = 219;
      validate_non_negative_index("x_i", "0", 0);
      current_statement__ = 219;
      validate_non_negative_index("x_i", "0", 0);
      x_i = std::vector<std::vector<int>>(0, std::vector<int>(0, std::numeric_limits<int>::min()));
      
      current_statement__ = 220;
      td_int = (primitive_value(1) || primitive_value(2));
      current_statement__ = 221;
      td_int = (primitive_value(1) && primitive_value(2));
      current_statement__ = 230;
      for (int i = 1; i <= 2; ++i) {
        current_statement__ = 228;
        for (int j = 1; j <= 3; ++j) {
          current_statement__ = 226;
          for (int m = 1; m <= 4; ++m) {
            current_statement__ = 224;
            for (int n = 1; n <= 5; ++n) {
              current_statement__ = 222;
              assign(td_ar_mat,
                cons_list(index_uni(m),
                  cons_list(index_uni(n),
                    cons_list(index_uni(i),
                      cons_list(index_uni(j), nil_index_list())))), 0.4,
                "assigning variable td_ar_mat");}}}}
      current_statement__ = 241;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 231;
        assign(td_simplex, cons_list(index_uni(i), nil_index_list()),
          (1.0 / N), "assigning variable td_simplex");
        current_statement__ = 239;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 232;
          assign(td_1d_simplex,
            cons_list(index_uni(n),
              cons_list(index_uni(i), nil_index_list())), (1.0 / N),
            "assigning variable td_1d_simplex");
          current_statement__ = 237;
          for (int m = 1; m <= M; ++m) {
            current_statement__ = 235;
            for (int k = 1; k <= K; ++k) {
              current_statement__ = 233;
              assign(td_3d_simplex,
                cons_list(index_uni(n),
                  cons_list(index_uni(m),
                    cons_list(index_uni(k),
                      cons_list(index_uni(i), nil_index_list())))),
                (1.0 / N), "assigning variable td_3d_simplex");}}}}
      current_statement__ = 247;
      for (int i = 1; i <= 4; ++i) {
        current_statement__ = 245;
        for (int j = 1; j <= 5; ++j) {
          current_statement__ = 242;
          validate_non_negative_index("l_mat", "2", 2);
          current_statement__ = 242;
          validate_non_negative_index("l_mat", "3", 3);
          Eigen::Matrix<double, -1, -1> l_mat;
          l_mat = Eigen::Matrix<double, -1, -1>(2, 3);
          stan::math::fill(l_mat, std::numeric_limits<double>::quiet_NaN());
          
          current_statement__ = 242;
          assign(l_mat, nil_index_list(),
            rvalue(d_ar_mat,
              cons_list(index_uni(i),
                cons_list(index_uni(j), nil_index_list())), "d_ar_mat"),
            "assigning variable l_mat");
          current_statement__ = 243;
          if (pstream__) {
            stan_print(pstream__, "ar dim1: ");
            stan_print(pstream__, i);
            stan_print(pstream__, " ar dim2: ");
            stan_print(pstream__, j);
            stan_print(pstream__, " matrix: ");
            stan_print(pstream__, l_mat);
            stan_print(pstream__, "\n");
          }}}
      current_statement__ = 248;
      assign(td_cfcov_54, nil_index_list(),
        diag_matrix(rep_vector(1, rows(td_cfcov_54))),
        "assigning variable td_cfcov_54");
      current_statement__ = 249;
      assign(td_cfcov_33, nil_index_list(),
        diag_matrix(rep_vector(1, rows(td_cfcov_33))),
        "assigning variable td_cfcov_33");
      {
        double z;
        z = std::numeric_limits<double>::quiet_NaN();
        
        current_statement__ = 251;
        validate_non_negative_index("blocked_tdata_vs", "2", 2);
        Eigen::Matrix<double, 1, -1> blocked_tdata_vs;
        blocked_tdata_vs = Eigen::Matrix<double, 1, -1>(2);
        stan::math::fill(blocked_tdata_vs, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 252;
        for (int sym1__ = 1; sym1__ <= stan::math::size(blocked_tdata_vs);
             ++sym1__) {
          {
            double v;
            current_statement__ = 252;
            v = blocked_tdata_vs[(sym1__ - 1)];
            current_statement__ = 253;
            z = 0;
          }}
        current_statement__ = 254;
        validate_non_negative_index("indices", "4", 4);
        std::vector<int> indices;
        indices = std::vector<int>(4, std::numeric_limits<int>::min());
        
        current_statement__ = 254;
        assign(indices, nil_index_list(), stan::math::array_builder<int>()
          .add(1).add(2).add(3).add(4).array(), "assigning variable indices");
        {
          std::vector<int> sym1__;
          current_statement__ = 255;
          assign(sym1__, nil_index_list(),
            rvalue(indices, cons_list(index_min_max(1, 3), nil_index_list()),
              "indices"), "assigning variable sym1__");
          current_statement__ = 255;
          for (int sym2__ = 1; sym2__ <= stan::math::size(sym1__); ++sym2__) {
            {
              int i;
              current_statement__ = 255;
              i = sym1__[(sym2__ - 1)];
              current_statement__ = 256;
              z = i;
            }}
        }
      }
      current_statement__ = 258;
      assign(td_1dk, nil_index_list(),
        rvalue(td_1d,
          cons_list(index_multi(stan::model::deep_copy(td_1dk)),
            nil_index_list()), "td_1d"), "assigning variable td_1dk");
      current_statement__ = 259;
      assign(td_simplex, nil_index_list(),
        rvalue(td_1d_simplex,
          cons_list(index_uni(1), cons_list(index_omni(), nil_index_list())),
          "td_1d_simplex"), "assigning variable td_simplex");
      current_statement__ = 260;
      assign(td_simplex, nil_index_list(),
        rvalue(td_1d_simplex,
          cons_list(index_uni(1), cons_list(index_omni(), nil_index_list())),
          "td_1d_simplex"), "assigning variable td_simplex");
      current_statement__ = 261;
      assign(td_simplex, nil_index_list(),
        rvalue(td_1d_simplex,
          cons_list(index_uni(1),
            cons_list(index_min_max(1, N), nil_index_list())),
          "td_1d_simplex"), "assigning variable td_simplex");
      current_statement__ = 262;
      validate_non_negative_index("arr_mul_ind", "2", 2);
      current_statement__ = 262;
      validate_non_negative_index("arr_mul_ind", "2", 2);
      arr_mul_ind = std::vector<std::vector<int>>(2, std::vector<int>(2, std::numeric_limits<int>::min()));
      
      current_statement__ = 263;
      assign(arr_mul_ind,
        cons_list(index_uni(1),
          cons_list(index_min_max(1, 2), nil_index_list())),
        stan::math::array_builder<int>().add(1).add(1).array(),
        "assigning variable arr_mul_ind");
      current_statement__ = 264;
      validate_non_negative_index("x_mul_ind", "2", 2);
      x_mul_ind = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 264;
      assign(x_mul_ind, nil_index_list(), stan::math::array_builder<int>()
        .add(1).add(2).array(), "assigning variable x_mul_ind");
      current_statement__ = 181;
      current_statement__ = 181;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 182;
      current_statement__ = 182;
      check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 183;
      current_statement__ = 183;
      check_greater_or_equal(function__, "K", K, 0);
      current_statement__ = 183;
      current_statement__ = 183;
      check_less_or_equal(function__, "K", K, (N * M));
      current_statement__ = 184;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 184;
        current_statement__ = 184;
        check_less_or_equal(function__, "d_int_1d_ar[sym1__]",
                            d_int_1d_ar[(sym1__ - 1)], N);}
      current_statement__ = 185;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 185;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 185;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 185;
            current_statement__ = 185;
            check_less_or_equal(function__,
                                "d_int_3d_ar[sym1__, sym2__, sym3__]",
                                d_int_3d_ar[(sym1__ - 1)][(sym2__ - 1)][
                                (sym3__ - 1)], N);}}}
      current_statement__ = 186;
      current_statement__ = 186;
      check_greater_or_equal(function__, "J", J, -2.0);
      current_statement__ = 186;
      current_statement__ = 186;
      check_less_or_equal(function__, "J", J, 2.0);
      current_statement__ = 195;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 195;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 195;
          current_statement__ = 195;
          check_greater_or_equal(function__, "d_ar_mat[sym1__, sym2__]",
                                 d_ar_mat[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 195;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 195;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 195;
          current_statement__ = 195;
          check_less_or_equal(function__, "d_ar_mat[sym1__, sym2__]",
                              d_ar_mat[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 196;
      current_statement__ = 196;
      check_simplex(function__, "d_simplex", d_simplex);
      current_statement__ = 197;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 197;
        current_statement__ = 197;
        check_simplex(function__, "d_1d_simplex[sym1__]",
                      d_1d_simplex[(sym1__ - 1)]);}
      current_statement__ = 198;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 198;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 198;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 198;
            current_statement__ = 198;
            check_simplex(function__, "d_3d_simplex[sym1__, sym2__, sym3__]",
                          d_3d_simplex[(sym1__ - 1)][(sym2__ - 1)][(sym3__ -
                                                                    1)]);}}}
      current_statement__ = 199;
      current_statement__ = 199;
      check_cholesky_factor(function__, "d_cfcov_54", d_cfcov_54);
      current_statement__ = 200;
      current_statement__ = 200;
      check_cholesky_factor(function__, "d_cfcov_33", d_cfcov_33);
      current_statement__ = 201;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        current_statement__ = 201;
        current_statement__ = 201;
        check_cholesky_factor(function__, "d_cfcov_33_ar[sym1__]",
                              d_cfcov_33_ar[(sym1__ - 1)]);}
      current_statement__ = 208;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 208;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 208;
          current_statement__ = 208;
          check_greater_or_equal(function__, "td_ar_mat[sym1__, sym2__]",
                                 td_ar_mat[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 208;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 208;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 208;
          current_statement__ = 208;
          check_less_or_equal(function__, "td_ar_mat[sym1__, sym2__]",
                              td_ar_mat[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 209;
      current_statement__ = 209;
      check_simplex(function__, "td_simplex", td_simplex);
      current_statement__ = 210;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 210;
        current_statement__ = 210;
        check_simplex(function__, "td_1d_simplex[sym1__]",
                      td_1d_simplex[(sym1__ - 1)]);}
      current_statement__ = 211;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 211;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 211;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 211;
            current_statement__ = 211;
            check_simplex(function__,
                          "td_3d_simplex[sym1__, sym2__, sym3__]",
                          td_3d_simplex[(sym1__ - 1)][(sym2__ - 1)][(sym3__ -
                                                                    1)]);}}}
      current_statement__ = 212;
      current_statement__ = 212;
      check_cholesky_factor(function__, "td_cfcov_54", td_cfcov_54);
      current_statement__ = 213;
      current_statement__ = 213;
      check_cholesky_factor(function__, "td_cfcov_33", td_cfcov_33);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      current_statement__ = 2;
      validate_non_negative_index("offset_multiplier", "5", 5);
      num_params_r__ += 5;
      current_statement__ = 3;
      validate_non_negative_index("no_offset_multiplier", "5", 5);
      num_params_r__ += 5;
      current_statement__ = 4;
      validate_non_negative_index("offset_no_multiplier", "5", 5);
      num_params_r__ += 5;
      current_statement__ = 5;
      validate_non_negative_index("p_real_1d_ar", "N", N);
      num_params_r__ += N;
      current_statement__ = 6;
      validate_non_negative_index("p_real_3d_ar", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("p_real_3d_ar", "M", M);
      current_statement__ = 6;
      validate_non_negative_index("p_real_3d_ar", "K", K);
      num_params_r__ += N * M * K;
      current_statement__ = 7;
      validate_non_negative_index("p_vec", "N", N);
      num_params_r__ += N;
      current_statement__ = 8;
      validate_non_negative_index("p_1d_vec", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("p_1d_vec", "N", N);
      num_params_r__ += N * N;
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "M", M);
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "K", K);
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "N", N);
      num_params_r__ += N * M * K * N;
      current_statement__ = 10;
      validate_non_negative_index("p_row_vec", "N", N);
      num_params_r__ += N;
      current_statement__ = 11;
      validate_non_negative_index("p_1d_row_vec", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("p_1d_row_vec", "N", N);
      num_params_r__ += N * N;
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "N", N);
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "M", M);
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "K", K);
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "N", N);
      num_params_r__ += N * M * K * N;
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "4", 4);
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "5", 5);
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "2", 2);
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "3", 3);
      num_params_r__ += 4 * 5 * 2 * 3;
      current_statement__ = 14;
      validate_positive_index("p_simplex", "N", N);
      num_params_r__ += (N - 1);
      current_statement__ = 15;
      validate_non_negative_index("p_1d_simplex", "N", N);
      current_statement__ = 15;
      validate_positive_index("p_1d_simplex", "N", N);
      num_params_r__ += N * (N - 1);
      current_statement__ = 16;
      validate_non_negative_index("p_3d_simplex", "N", N);
      current_statement__ = 16;
      validate_non_negative_index("p_3d_simplex", "M", M);
      current_statement__ = 16;
      validate_non_negative_index("p_3d_simplex", "K", K);
      current_statement__ = 16;
      validate_positive_index("p_3d_simplex", "N", N);
      num_params_r__ += N * M * K * (N - 1);
      current_statement__ = 17;
      check_greater_or_equal("cholesky_factor_cov p_cfcov_54",
                             "num rows (must be greater or equal to num cols)",
                             5, 4);
      current_statement__ = 17;
      validate_non_negative_index("p_cfcov_54", "4", 4);
      num_params_r__ += ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4));
      current_statement__ = 18;
      check_greater_or_equal("cholesky_factor_cov p_cfcov_33",
                             "num rows (must be greater or equal to num cols)",
                             3, 3);
      current_statement__ = 18;
      validate_non_negative_index("p_cfcov_33", "3", 3);
      num_params_r__ += ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3));
      current_statement__ = 19;
      validate_non_negative_index("p_cfcov_33_ar", "K", K);
      current_statement__ = 19;
      check_greater_or_equal("cholesky_factor_cov p_cfcov_33_ar",
                             "num rows (must be greater or equal to num cols)",
                             3, 3);
      current_statement__ = 19;
      validate_non_negative_index("p_cfcov_33_ar", "3", 3);
      num_params_r__ += K * ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3));
      current_statement__ = 20;
      validate_non_negative_index("x_p", "2", 2);
      num_params_r__ += 2;
      current_statement__ = 21;
      validate_non_negative_index("y_p", "2", 2);
      num_params_r__ += 2;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  inline T__ log_prob(std::vector<T__>& params_r__,
                      std::vector<int>& params_i__,
                      std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "mother_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ p_real;
      p_real = DUMMY_VAR__;
      
      current_statement__ = 1;
      p_real = in__.scalar();
      current_statement__ = 2;
      validate_non_negative_index("offset_multiplier", "5", 5);
      std::vector<local_scalar_t__> offset_multiplier;
      offset_multiplier = std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 2;
        assign(offset_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()), in__.scalar(),
          "assigning variable offset_multiplier");}
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 2;
        if (jacobian__) {
          current_statement__ = 2;
          assign(offset_multiplier,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::offset_multiplier_constrain(
              offset_multiplier[(sym1__ - 1)], 1, 2, lp__),
            "assigning variable offset_multiplier");
        } else {
          current_statement__ = 2;
          assign(offset_multiplier,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::offset_multiplier_constrain(
              offset_multiplier[(sym1__ - 1)], 1, 2),
            "assigning variable offset_multiplier");
        }}
      current_statement__ = 3;
      validate_non_negative_index("no_offset_multiplier", "5", 5);
      std::vector<local_scalar_t__> no_offset_multiplier;
      no_offset_multiplier = std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 3;
        assign(no_offset_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()), in__.scalar(),
          "assigning variable no_offset_multiplier");}
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 3;
        if (jacobian__) {
          current_statement__ = 3;
          assign(no_offset_multiplier,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::offset_multiplier_constrain(
              no_offset_multiplier[(sym1__ - 1)], 0, 2, lp__),
            "assigning variable no_offset_multiplier");
        } else {
          current_statement__ = 3;
          assign(no_offset_multiplier,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::offset_multiplier_constrain(
              no_offset_multiplier[(sym1__ - 1)], 0, 2),
            "assigning variable no_offset_multiplier");
        }}
      current_statement__ = 4;
      validate_non_negative_index("offset_no_multiplier", "5", 5);
      std::vector<local_scalar_t__> offset_no_multiplier;
      offset_no_multiplier = std::vector<local_scalar_t__>(5, DUMMY_VAR__);
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 4;
        assign(offset_no_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()), in__.scalar(),
          "assigning variable offset_no_multiplier");}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 4;
        if (jacobian__) {
          current_statement__ = 4;
          assign(offset_no_multiplier,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::offset_multiplier_constrain(
              offset_no_multiplier[(sym1__ - 1)], 3, 1, lp__),
            "assigning variable offset_no_multiplier");
        } else {
          current_statement__ = 4;
          assign(offset_no_multiplier,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::offset_multiplier_constrain(
              offset_no_multiplier[(sym1__ - 1)], 3, 1),
            "assigning variable offset_no_multiplier");
        }}
      current_statement__ = 5;
      validate_non_negative_index("p_real_1d_ar", "N", N);
      std::vector<local_scalar_t__> p_real_1d_ar;
      p_real_1d_ar = std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 5;
        assign(p_real_1d_ar, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable p_real_1d_ar");}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 5;
        if (jacobian__) {
          current_statement__ = 5;
          assign(p_real_1d_ar,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(p_real_1d_ar[(sym1__ - 1)], 0, lp__),
            "assigning variable p_real_1d_ar");
        } else {
          current_statement__ = 5;
          assign(p_real_1d_ar,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(p_real_1d_ar[(sym1__ - 1)], 0),
            "assigning variable p_real_1d_ar");
        }}
      current_statement__ = 6;
      validate_non_negative_index("p_real_3d_ar", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("p_real_3d_ar", "M", M);
      current_statement__ = 6;
      validate_non_negative_index("p_real_3d_ar", "K", K);
      std::vector<std::vector<std::vector<local_scalar_t__>>> p_real_3d_ar;
      p_real_3d_ar = std::vector<std::vector<std::vector<local_scalar_t__>>>(N, std::vector<std::vector<local_scalar_t__>>(M, std::vector<local_scalar_t__>(K, DUMMY_VAR__)));
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 6;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 6;
            assign(p_real_3d_ar,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              in__.scalar(), "assigning variable p_real_3d_ar");}}}
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 6;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 6;
            if (jacobian__) {
              current_statement__ = 6;
              assign(p_real_3d_ar,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym3__), nil_index_list()))),
                stan::math::lb_constrain(
                  p_real_3d_ar[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)], 0,
                  lp__), "assigning variable p_real_3d_ar");
            } else {
              current_statement__ = 6;
              assign(p_real_3d_ar,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym3__), nil_index_list()))),
                stan::math::lb_constrain(
                  p_real_3d_ar[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)], 0),
                "assigning variable p_real_3d_ar");
            }}}}
      current_statement__ = 7;
      validate_non_negative_index("p_vec", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_vec;
      p_vec = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(p_vec, DUMMY_VAR__);
      
      current_statement__ = 7;
      p_vec = in__.vector(N);
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 7;
        if (jacobian__) {
          current_statement__ = 7;
          assign(p_vec, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(p_vec[(sym1__ - 1)], 0, lp__),
            "assigning variable p_vec");
        } else {
          current_statement__ = 7;
          assign(p_vec, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(p_vec[(sym1__ - 1)], 0),
            "assigning variable p_vec");
        }}
      current_statement__ = 8;
      validate_non_negative_index("p_1d_vec", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("p_1d_vec", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> p_1d_vec;
      p_1d_vec = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N));
      stan::math::fill(p_1d_vec, DUMMY_VAR__);
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 8;
        assign(p_1d_vec, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(N), "assigning variable p_1d_vec");}
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "M", M);
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "K", K);
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>> p_3d_vec;
      p_3d_vec = std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(M, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(N))));
      stan::math::fill(p_3d_vec, DUMMY_VAR__);
      
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 9;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 9;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 9;
            assign(p_3d_vec,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              in__.vector(N), "assigning variable p_3d_vec");}}}
      current_statement__ = 10;
      validate_non_negative_index("p_row_vec", "N", N);
      Eigen::Matrix<local_scalar_t__, 1, -1> p_row_vec;
      p_row_vec = Eigen::Matrix<local_scalar_t__, 1, -1>(N);
      stan::math::fill(p_row_vec, DUMMY_VAR__);
      
      current_statement__ = 10;
      p_row_vec = in__.row_vector(N);
      current_statement__ = 11;
      validate_non_negative_index("p_1d_row_vec", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("p_1d_row_vec", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>> p_1d_row_vec;
      p_1d_row_vec = std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(N, Eigen::Matrix<local_scalar_t__, 1, -1>(N));
      stan::math::fill(p_1d_row_vec, DUMMY_VAR__);
      
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 11;
        assign(p_1d_row_vec, cons_list(index_uni(sym1__), nil_index_list()),
          in__.row_vector(N), "assigning variable p_1d_row_vec");}
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "N", N);
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "M", M);
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "K", K);
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>> p_3d_row_vec;
      p_3d_row_vec = std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>>(N, std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>(M, std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(K, Eigen::Matrix<local_scalar_t__, 1, -1>(N))));
      stan::math::fill(p_3d_row_vec, DUMMY_VAR__);
      
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 12;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 12;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 12;
            assign(p_3d_row_vec,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              in__.row_vector(N), "assigning variable p_3d_row_vec");}}}
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "4", 4);
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "5", 5);
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "2", 2);
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "3", 3);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>> p_ar_mat;
      p_ar_mat = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>>(4, std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(5, Eigen::Matrix<local_scalar_t__, -1, -1>(2, 3)));
      stan::math::fill(p_ar_mat, DUMMY_VAR__);
      
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 13;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 13;
          assign(p_ar_mat,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.matrix(2, 3), "assigning variable p_ar_mat");}}
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 13;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 13;
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            current_statement__ = 13;
            for (int sym4__ = 1; sym4__ <= 3; ++sym4__) {
              current_statement__ = 13;
              if (jacobian__) {
                current_statement__ = 13;
                assign(p_ar_mat,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym3__),
                        cons_list(index_uni(sym4__), nil_index_list())))),
                  stan::math::lub_constrain(
                    rvalue(p_ar_mat,
                      cons_list(index_uni(sym1__),
                        cons_list(index_uni(sym2__),
                          cons_list(index_uni(sym3__),
                            cons_list(index_uni(sym4__), nil_index_list())))),
                      "p_ar_mat"), 0, 1, lp__), "assigning variable p_ar_mat");
              } else {
                current_statement__ = 13;
                assign(p_ar_mat,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym3__),
                        cons_list(index_uni(sym4__), nil_index_list())))),
                  stan::math::lub_constrain(
                    rvalue(p_ar_mat,
                      cons_list(index_uni(sym1__),
                        cons_list(index_uni(sym2__),
                          cons_list(index_uni(sym3__),
                            cons_list(index_uni(sym4__), nil_index_list())))),
                      "p_ar_mat"), 0, 1), "assigning variable p_ar_mat");
              }}}}}
      current_statement__ = 14;
      validate_positive_index("p_simplex", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_simplex;
      p_simplex = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(p_simplex, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> p_simplex_in__;
      p_simplex_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>((N - 1));
      stan::math::fill(p_simplex_in__, DUMMY_VAR__);
      
      current_statement__ = 14;
      p_simplex_in__ = in__.vector((N - 1));
      current_statement__ = 14;
      if (jacobian__) {
        current_statement__ = 14;
        assign(p_simplex, nil_index_list(),
          stan::math::simplex_constrain(p_simplex_in__, lp__),
          "assigning variable p_simplex");
      } else {
        current_statement__ = 14;
        assign(p_simplex, nil_index_list(),
          stan::math::simplex_constrain(p_simplex_in__),
          "assigning variable p_simplex");
      }
      current_statement__ = 15;
      validate_non_negative_index("p_1d_simplex", "N", N);
      current_statement__ = 15;
      validate_positive_index("p_1d_simplex", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> p_1d_simplex;
      p_1d_simplex = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N));
      stan::math::fill(p_1d_simplex, DUMMY_VAR__);
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> p_1d_simplex_in__;
      p_1d_simplex_in__ = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(
        (N - 1)));
      stan::math::fill(p_1d_simplex_in__, DUMMY_VAR__);
      
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 15;
        assign(p_1d_simplex_in__,
          cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector((N - 1)), "assigning variable p_1d_simplex_in__");}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 15;
        if (jacobian__) {
          current_statement__ = 15;
          assign(p_1d_simplex,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::simplex_constrain(p_1d_simplex_in__[(sym1__ - 1)],
              lp__), "assigning variable p_1d_simplex");
        } else {
          current_statement__ = 15;
          assign(p_1d_simplex,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::simplex_constrain(p_1d_simplex_in__[(sym1__ - 1)]),
            "assigning variable p_1d_simplex");
        }}
      current_statement__ = 16;
      validate_non_negative_index("p_3d_simplex", "N", N);
      current_statement__ = 16;
      validate_non_negative_index("p_3d_simplex", "M", M);
      current_statement__ = 16;
      validate_non_negative_index("p_3d_simplex", "K", K);
      current_statement__ = 16;
      validate_positive_index("p_3d_simplex", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>> p_3d_simplex;
      p_3d_simplex = std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(M, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(N))));
      stan::math::fill(p_3d_simplex, DUMMY_VAR__);
      
      std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>> p_3d_simplex_in__;
      p_3d_simplex_in__ = std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(M, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(
        (N - 1)))));
      stan::math::fill(p_3d_simplex_in__, DUMMY_VAR__);
      
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 16;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 16;
            assign(p_3d_simplex_in__,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              in__.vector((N - 1)), "assigning variable p_3d_simplex_in__");}
        }}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 16;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 16;
            if (jacobian__) {
              current_statement__ = 16;
              assign(p_3d_simplex,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym3__), nil_index_list()))),
                stan::math::simplex_constrain(
                  p_3d_simplex_in__[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)],
                  lp__), "assigning variable p_3d_simplex");
            } else {
              current_statement__ = 16;
              assign(p_3d_simplex,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym3__), nil_index_list()))),
                stan::math::simplex_constrain(
                  p_3d_simplex_in__[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)]),
                "assigning variable p_3d_simplex");
            }}}}
      current_statement__ = 17;
      check_greater_or_equal("cholesky_factor_cov p_cfcov_54",
                             "num rows (must be greater or equal to num cols)",
                             5, 4);
      current_statement__ = 17;
      validate_non_negative_index("p_cfcov_54", "4", 4);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_cfcov_54;
      p_cfcov_54 = Eigen::Matrix<local_scalar_t__, -1, -1>(5, 4);
      stan::math::fill(p_cfcov_54, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> p_cfcov_54_in__;
      p_cfcov_54_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(((((4 *
                                                                    (4 - 1))
                                                                   / 2) + 4)
                                                                 +
                                                                 ((5 - 4) *
                                                                   4)));
      stan::math::fill(p_cfcov_54_in__, DUMMY_VAR__);
      
      current_statement__ = 17;
      p_cfcov_54_in__ = in__.vector(
                          ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4)));
      current_statement__ = 17;
      if (jacobian__) {
        current_statement__ = 17;
        assign(p_cfcov_54, nil_index_list(),
          stan::math::cholesky_factor_constrain(p_cfcov_54_in__, 5, 4, lp__),
          "assigning variable p_cfcov_54");
      } else {
        current_statement__ = 17;
        assign(p_cfcov_54, nil_index_list(),
          stan::math::cholesky_factor_constrain(p_cfcov_54_in__, 5, 4),
          "assigning variable p_cfcov_54");
      }
      current_statement__ = 18;
      check_greater_or_equal("cholesky_factor_cov p_cfcov_33",
                             "num rows (must be greater or equal to num cols)",
                             3, 3);
      current_statement__ = 18;
      validate_non_negative_index("p_cfcov_33", "3", 3);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_cfcov_33;
      p_cfcov_33 = Eigen::Matrix<local_scalar_t__, -1, -1>(3, 3);
      stan::math::fill(p_cfcov_33, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> p_cfcov_33_in__;
      p_cfcov_33_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(((((3 *
                                                                    (3 - 1))
                                                                   / 2) + 3)
                                                                 +
                                                                 ((3 - 3) *
                                                                   3)));
      stan::math::fill(p_cfcov_33_in__, DUMMY_VAR__);
      
      current_statement__ = 18;
      p_cfcov_33_in__ = in__.vector(
                          ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)));
      current_statement__ = 18;
      if (jacobian__) {
        current_statement__ = 18;
        assign(p_cfcov_33, nil_index_list(),
          stan::math::cholesky_factor_constrain(p_cfcov_33_in__, 3, 3, lp__),
          "assigning variable p_cfcov_33");
      } else {
        current_statement__ = 18;
        assign(p_cfcov_33, nil_index_list(),
          stan::math::cholesky_factor_constrain(p_cfcov_33_in__, 3, 3),
          "assigning variable p_cfcov_33");
      }
      current_statement__ = 19;
      validate_non_negative_index("p_cfcov_33_ar", "K", K);
      current_statement__ = 19;
      check_greater_or_equal("cholesky_factor_cov p_cfcov_33_ar",
                             "num rows (must be greater or equal to num cols)",
                             3, 3);
      current_statement__ = 19;
      validate_non_negative_index("p_cfcov_33_ar", "3", 3);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> p_cfcov_33_ar;
      p_cfcov_33_ar = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(K, Eigen::Matrix<local_scalar_t__, -1, -1>(3, 3));
      stan::math::fill(p_cfcov_33_ar, DUMMY_VAR__);
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> p_cfcov_33_ar_in__;
      p_cfcov_33_ar_in__ = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(
        ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3))));
      stan::math::fill(p_cfcov_33_ar_in__, DUMMY_VAR__);
      
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        current_statement__ = 19;
        assign(p_cfcov_33_ar_in__,
          cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3))),
          "assigning variable p_cfcov_33_ar_in__");}
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        current_statement__ = 19;
        if (jacobian__) {
          current_statement__ = 19;
          assign(p_cfcov_33_ar,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::cholesky_factor_constrain(
              p_cfcov_33_ar_in__[(sym1__ - 1)], 3, 3, lp__),
            "assigning variable p_cfcov_33_ar");
        } else {
          current_statement__ = 19;
          assign(p_cfcov_33_ar,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::cholesky_factor_constrain(
              p_cfcov_33_ar_in__[(sym1__ - 1)], 3, 3),
            "assigning variable p_cfcov_33_ar");
        }}
      current_statement__ = 20;
      validate_non_negative_index("x_p", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> x_p;
      x_p = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(x_p, DUMMY_VAR__);
      
      current_statement__ = 20;
      x_p = in__.vector(2);
      current_statement__ = 21;
      validate_non_negative_index("y_p", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_p;
      y_p = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(y_p, DUMMY_VAR__);
      
      current_statement__ = 21;
      y_p = in__.vector(2);
      current_statement__ = 22;
      validate_non_negative_index("tp_real_1d_ar", "N", N);
      std::vector<local_scalar_t__> tp_real_1d_ar;
      tp_real_1d_ar = std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      
      current_statement__ = 23;
      validate_non_negative_index("tp_real_3d_ar", "N", N);
      current_statement__ = 23;
      validate_non_negative_index("tp_real_3d_ar", "M", M);
      current_statement__ = 23;
      validate_non_negative_index("tp_real_3d_ar", "K", K);
      std::vector<std::vector<std::vector<local_scalar_t__>>> tp_real_3d_ar;
      tp_real_3d_ar = std::vector<std::vector<std::vector<local_scalar_t__>>>(N, std::vector<std::vector<local_scalar_t__>>(M, std::vector<local_scalar_t__>(K, DUMMY_VAR__)));
      
      current_statement__ = 24;
      validate_non_negative_index("tp_vec", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> tp_vec;
      tp_vec = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(tp_vec, DUMMY_VAR__);
      
      current_statement__ = 25;
      validate_non_negative_index("tp_1d_vec", "N", N);
      current_statement__ = 25;
      validate_non_negative_index("tp_1d_vec", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> tp_1d_vec;
      tp_1d_vec = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N));
      stan::math::fill(tp_1d_vec, DUMMY_VAR__);
      
      current_statement__ = 26;
      validate_non_negative_index("tp_3d_vec", "N", N);
      current_statement__ = 26;
      validate_non_negative_index("tp_3d_vec", "M", M);
      current_statement__ = 26;
      validate_non_negative_index("tp_3d_vec", "K", K);
      current_statement__ = 26;
      validate_non_negative_index("tp_3d_vec", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>> tp_3d_vec;
      tp_3d_vec = std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(M, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(N))));
      stan::math::fill(tp_3d_vec, DUMMY_VAR__);
      
      current_statement__ = 27;
      validate_non_negative_index("tp_row_vec", "N", N);
      Eigen::Matrix<local_scalar_t__, 1, -1> tp_row_vec;
      tp_row_vec = Eigen::Matrix<local_scalar_t__, 1, -1>(N);
      stan::math::fill(tp_row_vec, DUMMY_VAR__);
      
      current_statement__ = 28;
      validate_non_negative_index("tp_1d_row_vec", "N", N);
      current_statement__ = 28;
      validate_non_negative_index("tp_1d_row_vec", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>> tp_1d_row_vec;
      tp_1d_row_vec = std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(N, Eigen::Matrix<local_scalar_t__, 1, -1>(N));
      stan::math::fill(tp_1d_row_vec, DUMMY_VAR__);
      
      current_statement__ = 29;
      validate_non_negative_index("tp_3d_row_vec", "N", N);
      current_statement__ = 29;
      validate_non_negative_index("tp_3d_row_vec", "M", M);
      current_statement__ = 29;
      validate_non_negative_index("tp_3d_row_vec", "K", K);
      current_statement__ = 29;
      validate_non_negative_index("tp_3d_row_vec", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>> tp_3d_row_vec;
      tp_3d_row_vec = std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>>(N, std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>(M, std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(K, Eigen::Matrix<local_scalar_t__, 1, -1>(N))));
      stan::math::fill(tp_3d_row_vec, DUMMY_VAR__);
      
      current_statement__ = 30;
      validate_non_negative_index("tp_ar_mat", "4", 4);
      current_statement__ = 30;
      validate_non_negative_index("tp_ar_mat", "5", 5);
      current_statement__ = 30;
      validate_non_negative_index("tp_ar_mat", "2", 2);
      current_statement__ = 30;
      validate_non_negative_index("tp_ar_mat", "3", 3);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>> tp_ar_mat;
      tp_ar_mat = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>>(4, std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(5, Eigen::Matrix<local_scalar_t__, -1, -1>(2, 3)));
      stan::math::fill(tp_ar_mat, DUMMY_VAR__);
      
      current_statement__ = 31;
      validate_non_negative_index("tp_simplex", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> tp_simplex;
      tp_simplex = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(tp_simplex, DUMMY_VAR__);
      
      current_statement__ = 32;
      validate_non_negative_index("tp_1d_simplex", "N", N);
      current_statement__ = 32;
      validate_non_negative_index("tp_1d_simplex", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> tp_1d_simplex;
      tp_1d_simplex = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N));
      stan::math::fill(tp_1d_simplex, DUMMY_VAR__);
      
      current_statement__ = 33;
      validate_non_negative_index("tp_3d_simplex", "N", N);
      current_statement__ = 33;
      validate_non_negative_index("tp_3d_simplex", "M", M);
      current_statement__ = 33;
      validate_non_negative_index("tp_3d_simplex", "K", K);
      current_statement__ = 33;
      validate_non_negative_index("tp_3d_simplex", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>> tp_3d_simplex;
      tp_3d_simplex = std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(M, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(N))));
      stan::math::fill(tp_3d_simplex, DUMMY_VAR__);
      
      current_statement__ = 34;
      validate_non_negative_index("tp_cfcov_54", "5", 5);
      current_statement__ = 34;
      validate_non_negative_index("tp_cfcov_54", "4", 4);
      Eigen::Matrix<local_scalar_t__, -1, -1> tp_cfcov_54;
      tp_cfcov_54 = Eigen::Matrix<local_scalar_t__, -1, -1>(5, 4);
      stan::math::fill(tp_cfcov_54, DUMMY_VAR__);
      
      current_statement__ = 35;
      validate_non_negative_index("tp_cfcov_33", "3", 3);
      current_statement__ = 35;
      validate_non_negative_index("tp_cfcov_33", "3", 3);
      Eigen::Matrix<local_scalar_t__, -1, -1> tp_cfcov_33;
      tp_cfcov_33 = Eigen::Matrix<local_scalar_t__, -1, -1>(3, 3);
      stan::math::fill(tp_cfcov_33, DUMMY_VAR__);
      
      current_statement__ = 36;
      validate_non_negative_index("tp_cfcov_33_ar", "K", K);
      current_statement__ = 36;
      validate_non_negative_index("tp_cfcov_33_ar", "3", 3);
      current_statement__ = 36;
      validate_non_negative_index("tp_cfcov_33_ar", "3", 3);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> tp_cfcov_33_ar;
      tp_cfcov_33_ar = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(K, Eigen::Matrix<local_scalar_t__, -1, -1>(3, 3));
      stan::math::fill(tp_cfcov_33_ar, DUMMY_VAR__);
      
      current_statement__ = 37;
      validate_non_negative_index("theta_p", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> theta_p;
      theta_p = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(theta_p, DUMMY_VAR__);
      
      current_statement__ = 38;
      assign(tp_real_1d_ar, nil_index_list(), p_real_1d_ar,
        "assigning variable tp_real_1d_ar");
      current_statement__ = 39;
      assign(tp_real_3d_ar, nil_index_list(), p_real_3d_ar,
        "assigning variable tp_real_3d_ar");
      current_statement__ = 40;
      assign(tp_1d_vec, nil_index_list(), p_1d_vec,
        "assigning variable tp_1d_vec");
      current_statement__ = 41;
      assign(tp_3d_vec, nil_index_list(), p_3d_vec,
        "assigning variable tp_3d_vec");
      current_statement__ = 42;
      assign(tp_simplex, nil_index_list(), p_simplex,
        "assigning variable tp_simplex");
      current_statement__ = 43;
      assign(tp_1d_simplex, nil_index_list(), p_1d_simplex,
        "assigning variable tp_1d_simplex");
      current_statement__ = 44;
      assign(tp_3d_simplex, nil_index_list(), p_3d_simplex,
        "assigning variable tp_3d_simplex");
      current_statement__ = 45;
      assign(tp_cfcov_54, nil_index_list(), p_cfcov_54,
        "assigning variable tp_cfcov_54");
      current_statement__ = 46;
      assign(tp_cfcov_33, nil_index_list(), p_cfcov_33,
        "assigning variable tp_cfcov_33");
      current_statement__ = 47;
      assign(tp_cfcov_33_ar, nil_index_list(), p_cfcov_33_ar,
        "assigning variable tp_cfcov_33_ar");
      current_statement__ = 56;
      for (int i = 1; i <= 2; ++i) {
        current_statement__ = 54;
        for (int j = 1; j <= 3; ++j) {
          current_statement__ = 52;
          for (int m = 1; m <= 4; ++m) {
            current_statement__ = 50;
            for (int n = 1; n <= 5; ++n) {
              current_statement__ = 48;
              assign(tp_ar_mat,
                cons_list(index_uni(m),
                  cons_list(index_uni(n),
                    cons_list(index_uni(i),
                      cons_list(index_uni(j), nil_index_list())))), 0.4,
                "assigning variable tp_ar_mat");}}}}
      current_statement__ = 58;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 57;
        assign(tp_vec, cons_list(index_uni(i), nil_index_list()),
          (-1.0 *
            rvalue(p_vec, cons_list(index_uni(i), nil_index_list()), "p_vec")),
          "assigning variable tp_vec");}
      current_statement__ = 59;
      assign(tp_row_vec, nil_index_list(),
        transpose(
          rvalue(tp_1d_vec, cons_list(index_uni(1), nil_index_list()),
            "tp_1d_vec")), "assigning variable tp_row_vec");
      current_statement__ = 60;
      assign(tp_1d_row_vec, nil_index_list(), p_1d_row_vec,
        "assigning variable tp_1d_row_vec");
      current_statement__ = 61;
      assign(tp_3d_row_vec, nil_index_list(), p_3d_row_vec,
        "assigning variable tp_3d_row_vec");
      current_statement__ = 62;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x, y, dat, dat_int,
          pstream__), "assigning variable theta_p");
      current_statement__ = 63;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x, y, dat, dat_int,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p");
      current_statement__ = 64;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x, y_p, dat, dat_int,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p");
      current_statement__ = 65;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p, y, dat, dat_int,
          pstream__), "assigning variable theta_p");
      current_statement__ = 66;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p, y, dat, dat_int,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p");
      current_statement__ = 67;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p, y_p, dat, dat_int,
          pstream__), "assigning variable theta_p");
      current_statement__ = 68;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p, y_p, dat, dat_int,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p");
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 22;
        current_statement__ = 22;
        check_greater_or_equal(function__, "tp_real_1d_ar[sym1__]",
                               tp_real_1d_ar[(sym1__ - 1)], 0);}
      current_statement__ = 23;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 23;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 23;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 23;
            current_statement__ = 23;
            check_greater_or_equal(function__,
                                   "tp_real_3d_ar[sym1__, sym2__, sym3__]",
                                   tp_real_3d_ar[(sym1__ - 1)][(sym2__ - 1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 24;
      current_statement__ = 24;
      check_less_or_equal(function__, "tp_vec", tp_vec, 0);
      current_statement__ = 30;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 30;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 30;
          current_statement__ = 30;
          check_greater_or_equal(function__, "tp_ar_mat[sym1__, sym2__]",
                                 tp_ar_mat[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 30;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 30;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 30;
          current_statement__ = 30;
          check_less_or_equal(function__, "tp_ar_mat[sym1__, sym2__]",
                              tp_ar_mat[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 31;
      current_statement__ = 31;
      check_simplex(function__, "tp_simplex", tp_simplex);
      current_statement__ = 32;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 32;
        current_statement__ = 32;
        check_simplex(function__, "tp_1d_simplex[sym1__]",
                      tp_1d_simplex[(sym1__ - 1)]);}
      current_statement__ = 33;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 33;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 33;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 33;
            current_statement__ = 33;
            check_simplex(function__,
                          "tp_3d_simplex[sym1__, sym2__, sym3__]",
                          tp_3d_simplex[(sym1__ - 1)][(sym2__ - 1)][(sym3__ -
                                                                    1)]);}}}
      current_statement__ = 34;
      current_statement__ = 34;
      check_cholesky_factor(function__, "tp_cfcov_54", tp_cfcov_54);
      current_statement__ = 35;
      current_statement__ = 35;
      check_cholesky_factor(function__, "tp_cfcov_33", tp_cfcov_33);
      current_statement__ = 36;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        current_statement__ = 36;
        current_statement__ = 36;
        check_cholesky_factor(function__, "tp_cfcov_33_ar[sym1__]",
                              tp_cfcov_33_ar[(sym1__ - 1)]);}
      {
        current_statement__ = 145;
        validate_non_negative_index("tmp", "0", 0);
        Eigen::Matrix<local_scalar_t__, -1, 1> tmp;
        tmp = Eigen::Matrix<local_scalar_t__, -1, 1>(0);
        stan::math::fill(tmp, DUMMY_VAR__);
        
        current_statement__ = 146;
        validate_non_negative_index("tmp2", "0", 0);
        current_statement__ = 146;
        validate_non_negative_index("tmp2", "0", 0);
        std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> tmp2;
        tmp2 = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(0, Eigen::Matrix<local_scalar_t__, -1, 1>(0));
        stan::math::fill(tmp2, DUMMY_VAR__);
        
        local_scalar_t__ r1;
        r1 = DUMMY_VAR__;
        
        current_statement__ = 147;
        r1 = foo_bar1(p_real, pstream__);
        local_scalar_t__ r2;
        r2 = DUMMY_VAR__;
        
        current_statement__ = 148;
        r2 = foo_bar1(J, pstream__);
        current_statement__ = 149;
        lp_accum__.add(normal_log<propto__>(p_real, 0, 1));
        current_statement__ = 150;
        lp_accum__.add(normal_log<propto__>(offset_multiplier, 0, 1));
        current_statement__ = 151;
        lp_accum__.add(normal_log<propto__>(no_offset_multiplier, 0, 1));
        current_statement__ = 152;
        lp_accum__.add(normal_log<propto__>(offset_no_multiplier, 0, 1));
        current_statement__ = 153;
        lp_accum__.add(normal_log<propto__>(to_vector(p_real_1d_ar), 0, 1));
        current_statement__ = 166;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 154;
          lp_accum__.add(
            normal_log<propto__>(
              to_vector(
                rvalue(p_1d_vec, cons_list(index_uni(n), nil_index_list()),
                  "p_1d_vec")), 0, 1));
          current_statement__ = 155;
          lp_accum__.add(
            normal_log<propto__>(
              to_vector(
                rvalue(p_1d_row_vec,
                  cons_list(index_uni(n), nil_index_list()), "p_1d_row_vec")),
              0, 1));
          current_statement__ = 156;
          lp_accum__.add(
            normal_log<propto__>(
              to_vector(
                rvalue(p_1d_simplex,
                  cons_list(index_uni(n), nil_index_list()), "p_1d_simplex")),
              0, 1));
          current_statement__ = 164;
          for (int m = 1; m <= M; ++m) {
            current_statement__ = 162;
            for (int k = 1; k <= K; ++k) {
              current_statement__ = 157;
              lp_accum__.add(
                normal_log<propto__>(
                  to_vector(
                    rvalue(p_3d_vec,
                      cons_list(index_uni(n),
                        cons_list(index_uni(m),
                          cons_list(index_uni(k), nil_index_list()))),
                      "p_3d_vec")),
                  rvalue(d_3d_vec,
                    cons_list(index_uni(n),
                      cons_list(index_uni(m),
                        cons_list(index_uni(k), nil_index_list()))),
                    "d_3d_vec"), 1));
              current_statement__ = 158;
              lp_accum__.add(
                normal_log<propto__>(
                  to_vector(
                    rvalue(p_3d_row_vec,
                      cons_list(index_uni(n),
                        cons_list(index_uni(m),
                          cons_list(index_uni(k), nil_index_list()))),
                      "p_3d_row_vec")),
                  rvalue(d_3d_row_vec,
                    cons_list(index_uni(n),
                      cons_list(index_uni(m),
                        cons_list(index_uni(k), nil_index_list()))),
                    "d_3d_row_vec"), 1));
              current_statement__ = 159;
              lp_accum__.add(
                normal_log<propto__>(
                  to_vector(
                    rvalue(p_3d_simplex,
                      cons_list(index_uni(n),
                        cons_list(index_uni(m),
                          cons_list(index_uni(k), nil_index_list()))),
                      "p_3d_simplex")),
                  rvalue(d_3d_simplex,
                    cons_list(index_uni(n),
                      cons_list(index_uni(m),
                        cons_list(index_uni(k), nil_index_list()))),
                    "d_3d_simplex"), 1));
              current_statement__ = 160;
              lp_accum__.add(
                normal_log<propto__>(
                  rvalue(p_real_3d_ar,
                    cons_list(index_uni(n),
                      cons_list(index_uni(m),
                        cons_list(index_uni(k), nil_index_list()))),
                    "p_real_3d_ar"),
                  rvalue(p_real_3d_ar,
                    cons_list(index_uni(n),
                      cons_list(index_uni(m),
                        cons_list(index_uni(k), nil_index_list()))),
                    "p_real_3d_ar"), 1));}}}
        current_statement__ = 171;
        for (int i = 1; i <= 4; ++i) {
          current_statement__ = 169;
          for (int j = 1; j <= 5; ++j) {
            current_statement__ = 167;
            lp_accum__.add(
              normal_log<propto__>(
                to_vector(
                  rvalue(p_ar_mat,
                    cons_list(index_uni(i),
                      cons_list(index_uni(j), nil_index_list())), "p_ar_mat")),
                0, 1));}}
        current_statement__ = 174;
        for (int k = 1; k <= K; ++k) {
          current_statement__ = 172;
          lp_accum__.add(
            normal_log<propto__>(
              to_vector(
                rvalue(p_cfcov_33_ar,
                  cons_list(index_uni(k), nil_index_list()), "p_cfcov_33_ar")),
              0, 1));}
        current_statement__ = 175;
        lp_accum__.add(normal_log<propto__>(to_vector(p_vec), d_vec, 1));
        current_statement__ = 176;
        lp_accum__.add(normal_log<propto__>(to_vector(p_row_vec), 0, 1));
        current_statement__ = 177;
        lp_accum__.add(normal_log<propto__>(to_vector(p_simplex), 0, 1));
        current_statement__ = 178;
        lp_accum__.add(normal_log<propto__>(to_vector(p_cfcov_54), 0, 1));
        current_statement__ = 179;
        lp_accum__.add(normal_log<propto__>(to_vector(p_cfcov_33), 0, 1));
        current_statement__ = 180;
        lp_accum__.add(
          map_rect<1, binomialf_functor__>(tmp, tmp2, x_r, x_i, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  inline void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                          std::vector<int>& params_i__,
                          std::vector<double>& vars__,
                          bool emit_transformed_parameters__ = true,
                          bool emit_generated_quantities__ = true,
                          std::ostream* pstream__ = 0) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "mother_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double p_real;
      p_real = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      p_real = in__.scalar();
      current_statement__ = 2;
      validate_non_negative_index("offset_multiplier", "5", 5);
      std::vector<double> offset_multiplier;
      offset_multiplier = std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 2;
        assign(offset_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()), in__.scalar(),
          "assigning variable offset_multiplier");}
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 2;
        assign(offset_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::offset_multiplier_constrain(
            offset_multiplier[(sym1__ - 1)], 1, 2),
          "assigning variable offset_multiplier");}
      current_statement__ = 3;
      validate_non_negative_index("no_offset_multiplier", "5", 5);
      std::vector<double> no_offset_multiplier;
      no_offset_multiplier = std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 3;
        assign(no_offset_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()), in__.scalar(),
          "assigning variable no_offset_multiplier");}
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 3;
        assign(no_offset_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::offset_multiplier_constrain(
            no_offset_multiplier[(sym1__ - 1)], 0, 2),
          "assigning variable no_offset_multiplier");}
      current_statement__ = 4;
      validate_non_negative_index("offset_no_multiplier", "5", 5);
      std::vector<double> offset_no_multiplier;
      offset_no_multiplier = std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 4;
        assign(offset_no_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()), in__.scalar(),
          "assigning variable offset_no_multiplier");}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 4;
        assign(offset_no_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::offset_multiplier_constrain(
            offset_no_multiplier[(sym1__ - 1)], 3, 1),
          "assigning variable offset_no_multiplier");}
      current_statement__ = 5;
      validate_non_negative_index("p_real_1d_ar", "N", N);
      std::vector<double> p_real_1d_ar;
      p_real_1d_ar = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 5;
        assign(p_real_1d_ar, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable p_real_1d_ar");}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 5;
        assign(p_real_1d_ar, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(p_real_1d_ar[(sym1__ - 1)], 0),
          "assigning variable p_real_1d_ar");}
      current_statement__ = 6;
      validate_non_negative_index("p_real_3d_ar", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("p_real_3d_ar", "M", M);
      current_statement__ = 6;
      validate_non_negative_index("p_real_3d_ar", "K", K);
      std::vector<std::vector<std::vector<double>>> p_real_3d_ar;
      p_real_3d_ar = std::vector<std::vector<std::vector<double>>>(N, std::vector<std::vector<double>>(M, std::vector<double>(K, std::numeric_limits<double>::quiet_NaN())));
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 6;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 6;
            assign(p_real_3d_ar,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              in__.scalar(), "assigning variable p_real_3d_ar");}}}
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 6;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 6;
            assign(p_real_3d_ar,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              stan::math::lb_constrain(
                p_real_3d_ar[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)], 0),
              "assigning variable p_real_3d_ar");}}}
      current_statement__ = 7;
      validate_non_negative_index("p_vec", "N", N);
      Eigen::Matrix<double, -1, 1> p_vec;
      p_vec = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(p_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      p_vec = in__.vector(N);
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 7;
        assign(p_vec, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(p_vec[(sym1__ - 1)], 0),
          "assigning variable p_vec");}
      current_statement__ = 8;
      validate_non_negative_index("p_1d_vec", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("p_1d_vec", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> p_1d_vec;
      p_1d_vec = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(p_1d_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 8;
        assign(p_1d_vec, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(N), "assigning variable p_1d_vec");}
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "M", M);
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "K", K);
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>> p_3d_vec;
      p_3d_vec = std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(N))));
      stan::math::fill(p_3d_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 9;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 9;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 9;
            assign(p_3d_vec,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              in__.vector(N), "assigning variable p_3d_vec");}}}
      current_statement__ = 10;
      validate_non_negative_index("p_row_vec", "N", N);
      Eigen::Matrix<double, 1, -1> p_row_vec;
      p_row_vec = Eigen::Matrix<double, 1, -1>(N);
      stan::math::fill(p_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 10;
      p_row_vec = in__.row_vector(N);
      current_statement__ = 11;
      validate_non_negative_index("p_1d_row_vec", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("p_1d_row_vec", "N", N);
      std::vector<Eigen::Matrix<double, 1, -1>> p_1d_row_vec;
      p_1d_row_vec = std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N));
      stan::math::fill(p_1d_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 11;
        assign(p_1d_row_vec, cons_list(index_uni(sym1__), nil_index_list()),
          in__.row_vector(N), "assigning variable p_1d_row_vec");}
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "N", N);
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "M", M);
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "K", K);
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>> p_3d_row_vec;
      p_3d_row_vec = std::vector<std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(M, std::vector<Eigen::Matrix<double, 1, -1>>(K, Eigen::Matrix<double, 1, -1>(N))));
      stan::math::fill(p_3d_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 12;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 12;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 12;
            assign(p_3d_row_vec,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              in__.row_vector(N), "assigning variable p_3d_row_vec");}}}
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "4", 4);
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "5", 5);
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "2", 2);
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "3", 3);
      std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> p_ar_mat;
      p_ar_mat = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(4, std::vector<Eigen::Matrix<double, -1, -1>>(5, Eigen::Matrix<double, -1, -1>(2, 3)));
      stan::math::fill(p_ar_mat, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 13;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 13;
          assign(p_ar_mat,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.matrix(2, 3), "assigning variable p_ar_mat");}}
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 13;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 13;
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            current_statement__ = 13;
            for (int sym4__ = 1; sym4__ <= 3; ++sym4__) {
              current_statement__ = 13;
              assign(p_ar_mat,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym4__), nil_index_list())))),
                stan::math::lub_constrain(
                  rvalue(p_ar_mat,
                    cons_list(index_uni(sym1__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym3__),
                          cons_list(index_uni(sym4__), nil_index_list())))),
                    "p_ar_mat"), 0, 1), "assigning variable p_ar_mat");}}}}
      current_statement__ = 14;
      validate_positive_index("p_simplex", "N", N);
      Eigen::Matrix<double, -1, 1> p_simplex;
      p_simplex = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(p_simplex, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, 1> p_simplex_in__;
      p_simplex_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>((N - 1));
      stan::math::fill(p_simplex_in__, DUMMY_VAR__);
      
      current_statement__ = 14;
      p_simplex_in__ = in__.vector((N - 1));
      current_statement__ = 14;
      assign(p_simplex, nil_index_list(),
        stan::math::simplex_constrain(p_simplex_in__),
        "assigning variable p_simplex");
      current_statement__ = 15;
      validate_non_negative_index("p_1d_simplex", "N", N);
      current_statement__ = 15;
      validate_positive_index("p_1d_simplex", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> p_1d_simplex;
      p_1d_simplex = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(p_1d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> p_1d_simplex_in__;
      p_1d_simplex_in__ = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(
        (N - 1)));
      stan::math::fill(p_1d_simplex_in__, DUMMY_VAR__);
      
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 15;
        assign(p_1d_simplex_in__,
          cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector((N - 1)), "assigning variable p_1d_simplex_in__");}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 15;
        assign(p_1d_simplex, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::simplex_constrain(p_1d_simplex_in__[(sym1__ - 1)]),
          "assigning variable p_1d_simplex");}
      current_statement__ = 16;
      validate_non_negative_index("p_3d_simplex", "N", N);
      current_statement__ = 16;
      validate_non_negative_index("p_3d_simplex", "M", M);
      current_statement__ = 16;
      validate_non_negative_index("p_3d_simplex", "K", K);
      current_statement__ = 16;
      validate_positive_index("p_3d_simplex", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>> p_3d_simplex;
      p_3d_simplex = std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(N))));
      stan::math::fill(p_3d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>> p_3d_simplex_in__;
      p_3d_simplex_in__ = std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(M, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(
        (N - 1)))));
      stan::math::fill(p_3d_simplex_in__, DUMMY_VAR__);
      
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 16;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 16;
            assign(p_3d_simplex_in__,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              in__.vector((N - 1)), "assigning variable p_3d_simplex_in__");}
        }}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 16;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 16;
            assign(p_3d_simplex,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              stan::math::simplex_constrain(
                p_3d_simplex_in__[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)]),
              "assigning variable p_3d_simplex");}}}
      current_statement__ = 17;
      check_greater_or_equal("cholesky_factor_cov p_cfcov_54",
                             "num rows (must be greater or equal to num cols)",
                             5, 4);
      current_statement__ = 17;
      validate_non_negative_index("p_cfcov_54", "4", 4);
      Eigen::Matrix<double, -1, -1> p_cfcov_54;
      p_cfcov_54 = Eigen::Matrix<double, -1, -1>(5, 4);
      stan::math::fill(p_cfcov_54, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, 1> p_cfcov_54_in__;
      p_cfcov_54_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(((((4 *
                                                                    (4 - 1))
                                                                   / 2) + 4)
                                                                 +
                                                                 ((5 - 4) *
                                                                   4)));
      stan::math::fill(p_cfcov_54_in__, DUMMY_VAR__);
      
      current_statement__ = 17;
      p_cfcov_54_in__ = in__.vector(
                          ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4)));
      current_statement__ = 17;
      assign(p_cfcov_54, nil_index_list(),
        stan::math::cholesky_factor_constrain(p_cfcov_54_in__, 5, 4),
        "assigning variable p_cfcov_54");
      current_statement__ = 18;
      check_greater_or_equal("cholesky_factor_cov p_cfcov_33",
                             "num rows (must be greater or equal to num cols)",
                             3, 3);
      current_statement__ = 18;
      validate_non_negative_index("p_cfcov_33", "3", 3);
      Eigen::Matrix<double, -1, -1> p_cfcov_33;
      p_cfcov_33 = Eigen::Matrix<double, -1, -1>(3, 3);
      stan::math::fill(p_cfcov_33, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, 1> p_cfcov_33_in__;
      p_cfcov_33_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(((((3 *
                                                                    (3 - 1))
                                                                   / 2) + 3)
                                                                 +
                                                                 ((3 - 3) *
                                                                   3)));
      stan::math::fill(p_cfcov_33_in__, DUMMY_VAR__);
      
      current_statement__ = 18;
      p_cfcov_33_in__ = in__.vector(
                          ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)));
      current_statement__ = 18;
      assign(p_cfcov_33, nil_index_list(),
        stan::math::cholesky_factor_constrain(p_cfcov_33_in__, 3, 3),
        "assigning variable p_cfcov_33");
      current_statement__ = 19;
      validate_non_negative_index("p_cfcov_33_ar", "K", K);
      current_statement__ = 19;
      check_greater_or_equal("cholesky_factor_cov p_cfcov_33_ar",
                             "num rows (must be greater or equal to num cols)",
                             3, 3);
      current_statement__ = 19;
      validate_non_negative_index("p_cfcov_33_ar", "3", 3);
      std::vector<Eigen::Matrix<double, -1, -1>> p_cfcov_33_ar;
      p_cfcov_33_ar = std::vector<Eigen::Matrix<double, -1, -1>>(K, Eigen::Matrix<double, -1, -1>(3, 3));
      stan::math::fill(p_cfcov_33_ar, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> p_cfcov_33_ar_in__;
      p_cfcov_33_ar_in__ = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(
        ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3))));
      stan::math::fill(p_cfcov_33_ar_in__, DUMMY_VAR__);
      
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        current_statement__ = 19;
        assign(p_cfcov_33_ar_in__,
          cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3))),
          "assigning variable p_cfcov_33_ar_in__");}
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        current_statement__ = 19;
        assign(p_cfcov_33_ar, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::cholesky_factor_constrain(
            p_cfcov_33_ar_in__[(sym1__ - 1)], 3, 3),
          "assigning variable p_cfcov_33_ar");}
      current_statement__ = 20;
      validate_non_negative_index("x_p", "2", 2);
      Eigen::Matrix<double, -1, 1> x_p;
      x_p = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(x_p, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 20;
      x_p = in__.vector(2);
      current_statement__ = 21;
      validate_non_negative_index("y_p", "2", 2);
      Eigen::Matrix<double, -1, 1> y_p;
      y_p = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(y_p, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 21;
      y_p = in__.vector(2);
      current_statement__ = 22;
      validate_non_negative_index("tp_real_1d_ar", "N", N);
      std::vector<double> tp_real_1d_ar;
      tp_real_1d_ar = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 23;
      validate_non_negative_index("tp_real_3d_ar", "N", N);
      current_statement__ = 23;
      validate_non_negative_index("tp_real_3d_ar", "M", M);
      current_statement__ = 23;
      validate_non_negative_index("tp_real_3d_ar", "K", K);
      std::vector<std::vector<std::vector<double>>> tp_real_3d_ar;
      tp_real_3d_ar = std::vector<std::vector<std::vector<double>>>(N, std::vector<std::vector<double>>(M, std::vector<double>(K, std::numeric_limits<double>::quiet_NaN())));
      
      current_statement__ = 24;
      validate_non_negative_index("tp_vec", "N", N);
      Eigen::Matrix<double, -1, 1> tp_vec;
      tp_vec = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(tp_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 25;
      validate_non_negative_index("tp_1d_vec", "N", N);
      current_statement__ = 25;
      validate_non_negative_index("tp_1d_vec", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> tp_1d_vec;
      tp_1d_vec = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(tp_1d_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 26;
      validate_non_negative_index("tp_3d_vec", "N", N);
      current_statement__ = 26;
      validate_non_negative_index("tp_3d_vec", "M", M);
      current_statement__ = 26;
      validate_non_negative_index("tp_3d_vec", "K", K);
      current_statement__ = 26;
      validate_non_negative_index("tp_3d_vec", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>> tp_3d_vec;
      tp_3d_vec = std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(N))));
      stan::math::fill(tp_3d_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 27;
      validate_non_negative_index("tp_row_vec", "N", N);
      Eigen::Matrix<double, 1, -1> tp_row_vec;
      tp_row_vec = Eigen::Matrix<double, 1, -1>(N);
      stan::math::fill(tp_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 28;
      validate_non_negative_index("tp_1d_row_vec", "N", N);
      current_statement__ = 28;
      validate_non_negative_index("tp_1d_row_vec", "N", N);
      std::vector<Eigen::Matrix<double, 1, -1>> tp_1d_row_vec;
      tp_1d_row_vec = std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N));
      stan::math::fill(tp_1d_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 29;
      validate_non_negative_index("tp_3d_row_vec", "N", N);
      current_statement__ = 29;
      validate_non_negative_index("tp_3d_row_vec", "M", M);
      current_statement__ = 29;
      validate_non_negative_index("tp_3d_row_vec", "K", K);
      current_statement__ = 29;
      validate_non_negative_index("tp_3d_row_vec", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>> tp_3d_row_vec;
      tp_3d_row_vec = std::vector<std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(M, std::vector<Eigen::Matrix<double, 1, -1>>(K, Eigen::Matrix<double, 1, -1>(N))));
      stan::math::fill(tp_3d_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 30;
      validate_non_negative_index("tp_ar_mat", "4", 4);
      current_statement__ = 30;
      validate_non_negative_index("tp_ar_mat", "5", 5);
      current_statement__ = 30;
      validate_non_negative_index("tp_ar_mat", "2", 2);
      current_statement__ = 30;
      validate_non_negative_index("tp_ar_mat", "3", 3);
      std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> tp_ar_mat;
      tp_ar_mat = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(4, std::vector<Eigen::Matrix<double, -1, -1>>(5, Eigen::Matrix<double, -1, -1>(2, 3)));
      stan::math::fill(tp_ar_mat, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 31;
      validate_non_negative_index("tp_simplex", "N", N);
      Eigen::Matrix<double, -1, 1> tp_simplex;
      tp_simplex = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(tp_simplex, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 32;
      validate_non_negative_index("tp_1d_simplex", "N", N);
      current_statement__ = 32;
      validate_non_negative_index("tp_1d_simplex", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> tp_1d_simplex;
      tp_1d_simplex = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(tp_1d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 33;
      validate_non_negative_index("tp_3d_simplex", "N", N);
      current_statement__ = 33;
      validate_non_negative_index("tp_3d_simplex", "M", M);
      current_statement__ = 33;
      validate_non_negative_index("tp_3d_simplex", "K", K);
      current_statement__ = 33;
      validate_non_negative_index("tp_3d_simplex", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>> tp_3d_simplex;
      tp_3d_simplex = std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(N))));
      stan::math::fill(tp_3d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 34;
      validate_non_negative_index("tp_cfcov_54", "5", 5);
      current_statement__ = 34;
      validate_non_negative_index("tp_cfcov_54", "4", 4);
      Eigen::Matrix<double, -1, -1> tp_cfcov_54;
      tp_cfcov_54 = Eigen::Matrix<double, -1, -1>(5, 4);
      stan::math::fill(tp_cfcov_54, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 35;
      validate_non_negative_index("tp_cfcov_33", "3", 3);
      current_statement__ = 35;
      validate_non_negative_index("tp_cfcov_33", "3", 3);
      Eigen::Matrix<double, -1, -1> tp_cfcov_33;
      tp_cfcov_33 = Eigen::Matrix<double, -1, -1>(3, 3);
      stan::math::fill(tp_cfcov_33, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 36;
      validate_non_negative_index("tp_cfcov_33_ar", "K", K);
      current_statement__ = 36;
      validate_non_negative_index("tp_cfcov_33_ar", "3", 3);
      current_statement__ = 36;
      validate_non_negative_index("tp_cfcov_33_ar", "3", 3);
      std::vector<Eigen::Matrix<double, -1, -1>> tp_cfcov_33_ar;
      tp_cfcov_33_ar = std::vector<Eigen::Matrix<double, -1, -1>>(K, Eigen::Matrix<double, -1, -1>(3, 3));
      stan::math::fill(tp_cfcov_33_ar, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 37;
      validate_non_negative_index("theta_p", "2", 2);
      Eigen::Matrix<double, -1, 1> theta_p;
      theta_p = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(theta_p, std::numeric_limits<double>::quiet_NaN());
      
      vars__.push_back(p_real);
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        vars__.push_back(offset_multiplier[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        vars__.push_back(no_offset_multiplier[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        vars__.push_back(offset_no_multiplier[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(p_real_1d_ar[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(
              p_real_3d_ar[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(p_vec[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(p_1d_vec[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                p_3d_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
                                                                    1)]);}}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(p_row_vec[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(p_1d_row_vec[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                p_3d_row_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][
                (sym1__ - 1)]);}}}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
              vars__.push_back(
                rvalue(p_ar_mat,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  "p_ar_mat"));}}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(p_simplex[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(p_1d_simplex[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                p_3d_simplex[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][
                (sym1__ - 1)]);}}}}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          vars__.push_back(
            rvalue(p_cfcov_54,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "p_cfcov_54"));}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          vars__.push_back(
            rvalue(p_cfcov_33,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "p_cfcov_33"));}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            vars__.push_back(
              rvalue(p_cfcov_33_ar,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                "p_cfcov_33_ar"));}}}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(x_p[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(y_p[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 38;
      assign(tp_real_1d_ar, nil_index_list(), p_real_1d_ar,
        "assigning variable tp_real_1d_ar");
      current_statement__ = 39;
      assign(tp_real_3d_ar, nil_index_list(), p_real_3d_ar,
        "assigning variable tp_real_3d_ar");
      current_statement__ = 40;
      assign(tp_1d_vec, nil_index_list(), p_1d_vec,
        "assigning variable tp_1d_vec");
      current_statement__ = 41;
      assign(tp_3d_vec, nil_index_list(), p_3d_vec,
        "assigning variable tp_3d_vec");
      current_statement__ = 42;
      assign(tp_simplex, nil_index_list(), p_simplex,
        "assigning variable tp_simplex");
      current_statement__ = 43;
      assign(tp_1d_simplex, nil_index_list(), p_1d_simplex,
        "assigning variable tp_1d_simplex");
      current_statement__ = 44;
      assign(tp_3d_simplex, nil_index_list(), p_3d_simplex,
        "assigning variable tp_3d_simplex");
      current_statement__ = 45;
      assign(tp_cfcov_54, nil_index_list(), p_cfcov_54,
        "assigning variable tp_cfcov_54");
      current_statement__ = 46;
      assign(tp_cfcov_33, nil_index_list(), p_cfcov_33,
        "assigning variable tp_cfcov_33");
      current_statement__ = 47;
      assign(tp_cfcov_33_ar, nil_index_list(), p_cfcov_33_ar,
        "assigning variable tp_cfcov_33_ar");
      current_statement__ = 56;
      for (int i = 1; i <= 2; ++i) {
        current_statement__ = 54;
        for (int j = 1; j <= 3; ++j) {
          current_statement__ = 52;
          for (int m = 1; m <= 4; ++m) {
            current_statement__ = 50;
            for (int n = 1; n <= 5; ++n) {
              current_statement__ = 48;
              assign(tp_ar_mat,
                cons_list(index_uni(m),
                  cons_list(index_uni(n),
                    cons_list(index_uni(i),
                      cons_list(index_uni(j), nil_index_list())))), 0.4,
                "assigning variable tp_ar_mat");}}}}
      current_statement__ = 58;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 57;
        assign(tp_vec, cons_list(index_uni(i), nil_index_list()),
          (-1.0 *
            rvalue(p_vec, cons_list(index_uni(i), nil_index_list()), "p_vec")),
          "assigning variable tp_vec");}
      current_statement__ = 59;
      assign(tp_row_vec, nil_index_list(),
        transpose(
          rvalue(tp_1d_vec, cons_list(index_uni(1), nil_index_list()),
            "tp_1d_vec")), "assigning variable tp_row_vec");
      current_statement__ = 60;
      assign(tp_1d_row_vec, nil_index_list(), p_1d_row_vec,
        "assigning variable tp_1d_row_vec");
      current_statement__ = 61;
      assign(tp_3d_row_vec, nil_index_list(), p_3d_row_vec,
        "assigning variable tp_3d_row_vec");
      current_statement__ = 62;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x, y, dat, dat_int,
          pstream__), "assigning variable theta_p");
      current_statement__ = 63;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x, y, dat, dat_int,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p");
      current_statement__ = 64;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x, y_p, dat, dat_int,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p");
      current_statement__ = 65;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p, y, dat, dat_int,
          pstream__), "assigning variable theta_p");
      current_statement__ = 66;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p, y, dat, dat_int,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p");
      current_statement__ = 67;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p, y_p, dat, dat_int,
          pstream__), "assigning variable theta_p");
      current_statement__ = 68;
      assign(theta_p, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p, y_p, dat, dat_int,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(tp_real_1d_ar[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(
              tp_real_3d_ar[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(tp_vec[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(tp_1d_vec[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                tp_3d_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
                                                                    1)]);}}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(tp_row_vec[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(tp_1d_row_vec[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                tp_3d_row_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][
                (sym1__ - 1)]);}}}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
              vars__.push_back(
                rvalue(tp_ar_mat,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  "tp_ar_mat"));}}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(tp_simplex[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(tp_1d_simplex[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                tp_3d_simplex[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][
                (sym1__ - 1)]);}}}}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          vars__.push_back(
            rvalue(tp_cfcov_54,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "tp_cfcov_54"));}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          vars__.push_back(
            rvalue(tp_cfcov_33,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "tp_cfcov_33"));}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            vars__.push_back(
              rvalue(tp_cfcov_33_ar,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                "tp_cfcov_33_ar"));}}}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(theta_p[(sym1__ - 1)]);}
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double gq_r1;
      gq_r1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 69;
      gq_r1 = foo_bar1(p_real, pstream__);
      double gq_r2;
      gq_r2 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 70;
      gq_r2 = foo_bar1(J, pstream__);
      current_statement__ = 71;
      validate_non_negative_index("gq_real_1d_ar", "N", N);
      std::vector<double> gq_real_1d_ar;
      gq_real_1d_ar = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 72;
      validate_non_negative_index("gq_real_3d_ar", "N", N);
      current_statement__ = 72;
      validate_non_negative_index("gq_real_3d_ar", "M", M);
      current_statement__ = 72;
      validate_non_negative_index("gq_real_3d_ar", "K", K);
      std::vector<std::vector<std::vector<double>>> gq_real_3d_ar;
      gq_real_3d_ar = std::vector<std::vector<std::vector<double>>>(N, std::vector<std::vector<double>>(M, std::vector<double>(K, std::numeric_limits<double>::quiet_NaN())));
      
      current_statement__ = 73;
      validate_non_negative_index("gq_vec", "N", N);
      Eigen::Matrix<double, -1, 1> gq_vec;
      gq_vec = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(gq_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 74;
      validate_non_negative_index("gq_1d_vec", "N", N);
      current_statement__ = 74;
      validate_non_negative_index("gq_1d_vec", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> gq_1d_vec;
      gq_1d_vec = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(gq_1d_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 75;
      validate_non_negative_index("gq_3d_vec", "N", N);
      current_statement__ = 75;
      validate_non_negative_index("gq_3d_vec", "M", M);
      current_statement__ = 75;
      validate_non_negative_index("gq_3d_vec", "K", K);
      current_statement__ = 75;
      validate_non_negative_index("gq_3d_vec", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>> gq_3d_vec;
      gq_3d_vec = std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(N))));
      stan::math::fill(gq_3d_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 76;
      validate_non_negative_index("gq_row_vec", "N", N);
      Eigen::Matrix<double, 1, -1> gq_row_vec;
      gq_row_vec = Eigen::Matrix<double, 1, -1>(N);
      stan::math::fill(gq_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 77;
      validate_non_negative_index("gq_1d_row_vec", "N", N);
      current_statement__ = 77;
      validate_non_negative_index("gq_1d_row_vec", "N", N);
      std::vector<Eigen::Matrix<double, 1, -1>> gq_1d_row_vec;
      gq_1d_row_vec = std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N));
      stan::math::fill(gq_1d_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 78;
      validate_non_negative_index("gq_3d_row_vec", "N", N);
      current_statement__ = 78;
      validate_non_negative_index("gq_3d_row_vec", "M", M);
      current_statement__ = 78;
      validate_non_negative_index("gq_3d_row_vec", "K", K);
      current_statement__ = 78;
      validate_non_negative_index("gq_3d_row_vec", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>> gq_3d_row_vec;
      gq_3d_row_vec = std::vector<std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(M, std::vector<Eigen::Matrix<double, 1, -1>>(K, Eigen::Matrix<double, 1, -1>(N))));
      stan::math::fill(gq_3d_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 79;
      validate_non_negative_index("gq_ar_mat", "4", 4);
      current_statement__ = 79;
      validate_non_negative_index("gq_ar_mat", "5", 5);
      current_statement__ = 79;
      validate_non_negative_index("gq_ar_mat", "2", 2);
      current_statement__ = 79;
      validate_non_negative_index("gq_ar_mat", "3", 3);
      std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> gq_ar_mat;
      gq_ar_mat = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(4, std::vector<Eigen::Matrix<double, -1, -1>>(5, Eigen::Matrix<double, -1, -1>(2, 3)));
      stan::math::fill(gq_ar_mat, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 80;
      validate_non_negative_index("gq_simplex", "N", N);
      Eigen::Matrix<double, -1, 1> gq_simplex;
      gq_simplex = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(gq_simplex, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 81;
      validate_non_negative_index("gq_1d_simplex", "N", N);
      current_statement__ = 81;
      validate_non_negative_index("gq_1d_simplex", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> gq_1d_simplex;
      gq_1d_simplex = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(gq_1d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 82;
      validate_non_negative_index("gq_3d_simplex", "N", N);
      current_statement__ = 82;
      validate_non_negative_index("gq_3d_simplex", "M", M);
      current_statement__ = 82;
      validate_non_negative_index("gq_3d_simplex", "K", K);
      current_statement__ = 82;
      validate_non_negative_index("gq_3d_simplex", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>> gq_3d_simplex;
      gq_3d_simplex = std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(N))));
      stan::math::fill(gq_3d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 83;
      validate_non_negative_index("gq_cfcov_54", "5", 5);
      current_statement__ = 83;
      validate_non_negative_index("gq_cfcov_54", "4", 4);
      Eigen::Matrix<double, -1, -1> gq_cfcov_54;
      gq_cfcov_54 = Eigen::Matrix<double, -1, -1>(5, 4);
      stan::math::fill(gq_cfcov_54, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 84;
      validate_non_negative_index("gq_cfcov_33", "3", 3);
      current_statement__ = 84;
      validate_non_negative_index("gq_cfcov_33", "3", 3);
      Eigen::Matrix<double, -1, -1> gq_cfcov_33;
      gq_cfcov_33 = Eigen::Matrix<double, -1, -1>(3, 3);
      stan::math::fill(gq_cfcov_33, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 85;
      validate_non_negative_index("gq_cfcov_33_ar", "K", K);
      current_statement__ = 85;
      validate_non_negative_index("gq_cfcov_33_ar", "3", 3);
      current_statement__ = 85;
      validate_non_negative_index("gq_cfcov_33_ar", "3", 3);
      std::vector<Eigen::Matrix<double, -1, -1>> gq_cfcov_33_ar;
      gq_cfcov_33_ar = std::vector<Eigen::Matrix<double, -1, -1>>(K, Eigen::Matrix<double, -1, -1>(3, 3));
      stan::math::fill(gq_cfcov_33_ar, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 86;
      validate_non_negative_index("indices", "3", 3);
      std::vector<int> indices;
      indices = std::vector<int>(3, std::numeric_limits<int>::min());
      
      current_statement__ = 86;
      assign(indices, nil_index_list(), stan::math::array_builder<int>()
        .add(2).add(3).add(1).array(), "assigning variable indices");
      current_statement__ = 87;
      validate_non_negative_index("indexing_mat", "5", 5);
      current_statement__ = 87;
      validate_non_negative_index("indexing_mat", "3", 3);
      current_statement__ = 87;
      validate_non_negative_index("indexing_mat", "4", 4);
      std::vector<Eigen::Matrix<double, -1, -1>> indexing_mat;
      indexing_mat = std::vector<Eigen::Matrix<double, -1, -1>>(5, Eigen::Matrix<double, -1, -1>(3, 4));
      stan::math::fill(indexing_mat, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 88;
      validate_non_negative_index("idx_res1", "3", 3);
      current_statement__ = 88;
      validate_non_negative_index("idx_res1", "3", 3);
      current_statement__ = 88;
      validate_non_negative_index("idx_res1", "4", 4);
      std::vector<Eigen::Matrix<double, -1, -1>> idx_res1;
      idx_res1 = std::vector<Eigen::Matrix<double, -1, -1>>(3, Eigen::Matrix<double, -1, -1>(3, 4));
      stan::math::fill(idx_res1, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 89;
      validate_non_negative_index("idx_res2", "5", 5);
      current_statement__ = 89;
      validate_non_negative_index("idx_res2", "3", 3);
      current_statement__ = 89;
      validate_non_negative_index("idx_res2", "4", 4);
      std::vector<Eigen::Matrix<double, -1, -1>> idx_res2;
      idx_res2 = std::vector<Eigen::Matrix<double, -1, -1>>(5, Eigen::Matrix<double, -1, -1>(3, 4));
      stan::math::fill(idx_res2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 90;
      validate_non_negative_index("idx_res3", "3", 3);
      current_statement__ = 90;
      validate_non_negative_index("idx_res3", "3", 3);
      current_statement__ = 90;
      validate_non_negative_index("idx_res3", "3", 3);
      std::vector<Eigen::Matrix<double, -1, -1>> idx_res3;
      idx_res3 = std::vector<Eigen::Matrix<double, -1, -1>>(3, Eigen::Matrix<double, -1, -1>(3, 3));
      stan::math::fill(idx_res3, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 91;
      validate_non_negative_index("idx_res11", "3", 3);
      current_statement__ = 91;
      validate_non_negative_index("idx_res11", "3", 3);
      current_statement__ = 91;
      validate_non_negative_index("idx_res11", "4", 4);
      std::vector<Eigen::Matrix<double, -1, -1>> idx_res11;
      idx_res11 = std::vector<Eigen::Matrix<double, -1, -1>>(3, Eigen::Matrix<double, -1, -1>(3, 4));
      stan::math::fill(idx_res11, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 92;
      validate_non_negative_index("idx_res21", "5", 5);
      current_statement__ = 92;
      validate_non_negative_index("idx_res21", "3", 3);
      current_statement__ = 92;
      validate_non_negative_index("idx_res21", "4", 4);
      std::vector<Eigen::Matrix<double, -1, -1>> idx_res21;
      idx_res21 = std::vector<Eigen::Matrix<double, -1, -1>>(5, Eigen::Matrix<double, -1, -1>(3, 4));
      stan::math::fill(idx_res21, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 93;
      validate_non_negative_index("idx_res31", "3", 3);
      current_statement__ = 93;
      validate_non_negative_index("idx_res31", "3", 3);
      current_statement__ = 93;
      validate_non_negative_index("idx_res31", "3", 3);
      std::vector<Eigen::Matrix<double, -1, -1>> idx_res31;
      idx_res31 = std::vector<Eigen::Matrix<double, -1, -1>>(3, Eigen::Matrix<double, -1, -1>(3, 3));
      stan::math::fill(idx_res31, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 94;
      validate_non_negative_index("idx_res4", "3", 3);
      current_statement__ = 94;
      validate_non_negative_index("idx_res4", "4", 4);
      std::vector<Eigen::Matrix<double, 1, -1>> idx_res4;
      idx_res4 = std::vector<Eigen::Matrix<double, 1, -1>>(3, Eigen::Matrix<double, 1, -1>(4));
      stan::math::fill(idx_res4, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 95;
      validate_non_negative_index("idx_res5", "2", 2);
      current_statement__ = 95;
      validate_non_negative_index("idx_res5", "2", 2);
      std::vector<Eigen::Matrix<double, -1, 1>> idx_res5;
      idx_res5 = std::vector<Eigen::Matrix<double, -1, 1>>(2, Eigen::Matrix<double, -1, 1>(2));
      stan::math::fill(idx_res5, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 96;
      assign(gq_real_1d_ar, nil_index_list(),
        rvalue(p_1d_simplex,
          cons_list(index_omni(), cons_list(index_uni(1), nil_index_list())),
          "p_1d_simplex"), "assigning variable gq_real_1d_ar");
      current_statement__ = 97;
      assign(gq_real_3d_ar, nil_index_list(), p_real_3d_ar,
        "assigning variable gq_real_3d_ar");
      current_statement__ = 98;
      assign(gq_1d_vec, nil_index_list(), p_1d_vec,
        "assigning variable gq_1d_vec");
      current_statement__ = 99;
      assign(gq_3d_vec, nil_index_list(), p_3d_vec,
        "assigning variable gq_3d_vec");
      current_statement__ = 100;
      assign(gq_row_vec, nil_index_list(), p_row_vec,
        "assigning variable gq_row_vec");
      current_statement__ = 101;
      assign(gq_1d_row_vec, nil_index_list(), p_1d_row_vec,
        "assigning variable gq_1d_row_vec");
      current_statement__ = 102;
      assign(gq_3d_row_vec, nil_index_list(), p_3d_row_vec,
        "assigning variable gq_3d_row_vec");
      current_statement__ = 103;
      assign(gq_simplex, nil_index_list(),
        rvalue(p_1d_simplex,
          cons_list(index_uni(1),
            cons_list(index_min_max(1, N), nil_index_list())),
          "p_1d_simplex"), "assigning variable gq_simplex");
      current_statement__ = 104;
      assign(gq_1d_simplex, nil_index_list(), p_1d_simplex,
        "assigning variable gq_1d_simplex");
      current_statement__ = 105;
      assign(gq_3d_simplex, nil_index_list(), p_3d_simplex,
        "assigning variable gq_3d_simplex");
      current_statement__ = 106;
      assign(gq_cfcov_54, nil_index_list(), p_cfcov_54,
        "assigning variable gq_cfcov_54");
      current_statement__ = 107;
      assign(gq_cfcov_33, nil_index_list(), p_cfcov_33,
        "assigning variable gq_cfcov_33");
      current_statement__ = 108;
      assign(gq_cfcov_33_ar, nil_index_list(), p_cfcov_33_ar,
        "assigning variable gq_cfcov_33_ar");
      current_statement__ = 117;
      for (int i = 1; i <= 2; ++i) {
        current_statement__ = 115;
        for (int j = 1; j <= 3; ++j) {
          current_statement__ = 113;
          for (int m = 1; m <= 4; ++m) {
            current_statement__ = 111;
            for (int n = 1; n <= 5; ++n) {
              current_statement__ = 109;
              assign(gq_ar_mat,
                cons_list(index_uni(m),
                  cons_list(index_uni(n),
                    cons_list(index_uni(i),
                      cons_list(index_uni(j), nil_index_list())))), 0.4,
                "assigning variable gq_ar_mat");}}}}
      current_statement__ = 119;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 118;
        assign(gq_vec, cons_list(index_uni(i), nil_index_list()),
          (-1.0 *
            rvalue(p_vec, cons_list(index_uni(i), nil_index_list()), "p_vec")),
          "assigning variable gq_vec");}
      current_statement__ = 123;
      for (int i = 1; i <= 3; ++i) {
        current_statement__ = 122;
        for (int j = 1; j <= 4; ++j) {
          current_statement__ = 121;
          for (int k = 1; k <= 5; ++k) {
            current_statement__ = 120;
            assign(indexing_mat,
              cons_list(index_uni(k),
                cons_list(index_uni(i),
                  cons_list(index_uni(j), nil_index_list()))),
              normal_rng(0, 1, base_rng__), "assigning variable indexing_mat");
          }}}
      current_statement__ = 126;
      for (int i = 1; i <= size(indices); ++i) {
        current_statement__ = 125;
        for (int j = 1; j <= size(indices); ++j) {
          current_statement__ = 124;
          assign(idx_res1,
            cons_list(index_uni(i),
              cons_list(index_uni(j), nil_index_list())),
            rvalue(indexing_mat,
              cons_list(
                index_uni(rvalue(indices,
                            cons_list(index_uni(i), nil_index_list()),
                            "indices")),
                cons_list(
                  index_uni(rvalue(indices,
                              cons_list(index_uni(j), nil_index_list()),
                              "indices")), nil_index_list())),
              "indexing_mat"), "assigning variable idx_res1");}}
      current_statement__ = 127;
      assign(idx_res11, nil_index_list(),
        rvalue(indexing_mat,
          cons_list(index_multi(indices),
            cons_list(index_multi(indices), nil_index_list())),
          "indexing_mat"), "assigning variable idx_res11");
      current_statement__ = 129;
      if (logical_neq(
            rvalue(
              rvalue(indexing_mat,
  cons_list(index_multi(indices),
    cons_list(index_multi(indices), nil_index_list())), "indexing_mat"),
              cons_list(index_uni(2),
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list()))),
              "indexing_mat[indices, indices]"),
            rvalue(idx_res1,
              cons_list(index_uni(2),
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list()))), "idx_res1"))) {
        current_statement__ = 128;
        std::stringstream errmsg_stream__;
        errmsg_stream__ << "indexing test 1 failed";
        throw std::domain_error(errmsg_stream__.str());
      } 
      current_statement__ = 132;
      for (int i = 1; i <= 5; ++i) {
        current_statement__ = 131;
        for (int j = 1; j <= size(indices); ++j) {
          current_statement__ = 130;
          assign(idx_res2,
            cons_list(index_uni(i),
              cons_list(index_uni(j), nil_index_list())),
            rvalue(indexing_mat,
              cons_list(index_uni(i),
                cons_list(
                  index_uni(rvalue(indices,
                              cons_list(index_uni(j), nil_index_list()),
                              "indices")), nil_index_list())),
              "indexing_mat"), "assigning variable idx_res2");}}
      current_statement__ = 133;
      assign(idx_res21, nil_index_list(),
        rvalue(indexing_mat,
          cons_list(index_omni(),
            cons_list(index_multi(indices), nil_index_list())),
          "indexing_mat"), "assigning variable idx_res21");
      current_statement__ = 135;
      if (logical_neq(
            rvalue(
              rvalue(indexing_mat,
  cons_list(index_omni(), cons_list(index_multi(indices), nil_index_list())),
  "indexing_mat"),
              cons_list(index_uni(2),
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list()))),
              "indexing_mat[:, indices]"),
            rvalue(idx_res2,
              cons_list(index_uni(2),
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list()))), "idx_res2"))) {
        current_statement__ = 134;
        std::stringstream errmsg_stream__;
        errmsg_stream__ << "indexing test 2 failed";
        throw std::domain_error(errmsg_stream__.str());
      } 
      current_statement__ = 139;
      for (int i = 1; i <= size(indices); ++i) {
        current_statement__ = 138;
        for (int j = 1; j <= 3; ++j) {
          current_statement__ = 137;
          for (int k = 1; k <= size(indices); ++k) {
            current_statement__ = 136;
            assign(idx_res3,
              cons_list(index_uni(i),
                cons_list(index_uni(j),
                  cons_list(index_uni(k), nil_index_list()))),
              rvalue(indexing_mat,
                cons_list(
                  index_uni(rvalue(indices,
                              cons_list(index_uni(i), nil_index_list()),
                              "indices")),
                  cons_list(index_uni(j),
                    cons_list(
                      index_uni(rvalue(indices,
                                  cons_list(index_uni(k), nil_index_list()),
                                  "indices")), nil_index_list()))),
                "indexing_mat"), "assigning variable idx_res3");}}}
      current_statement__ = 140;
      assign(idx_res31, nil_index_list(),
        rvalue(indexing_mat,
          cons_list(index_multi(indices),
            cons_list(index_omni(),
              cons_list(index_multi(indices), nil_index_list()))),
          "indexing_mat"), "assigning variable idx_res31");
      current_statement__ = 142;
      if (logical_neq(
            rvalue(
              rvalue(indexing_mat,
  cons_list(index_multi(indices),
    cons_list(index_omni(),
      cons_list(index_multi(indices), nil_index_list()))), "indexing_mat"),
              cons_list(index_uni(2),
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list()))),
              "indexing_mat[indices, :, indices]"),
            rvalue(idx_res3,
              cons_list(index_uni(2),
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list()))), "idx_res3"))) {
        current_statement__ = 141;
        std::stringstream errmsg_stream__;
        errmsg_stream__ << "indexing test 3 failed";
        throw std::domain_error(errmsg_stream__.str());
      } 
      current_statement__ = 143;
      assign(idx_res4, nil_index_list(),
        rvalue(indexing_mat,
          cons_list(index_min_max(1, 3),
            cons_list(index_uni(1),
              cons_list(index_omni(), nil_index_list()))), "indexing_mat"),
        "assigning variable idx_res4");
      current_statement__ = 144;
      assign(idx_res5, nil_index_list(),
        rvalue(indexing_mat,
          cons_list(index_min(4),
            cons_list(index_min_max(2, 3),
              cons_list(index_uni(1), nil_index_list()))), "indexing_mat"),
        "assigning variable idx_res5");
      current_statement__ = 71;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 71;
        current_statement__ = 71;
        check_greater_or_equal(function__, "gq_real_1d_ar[sym1__]",
                               gq_real_1d_ar[(sym1__ - 1)], 0);}
      current_statement__ = 72;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 72;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 72;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 72;
            current_statement__ = 72;
            check_greater_or_equal(function__,
                                   "gq_real_3d_ar[sym1__, sym2__, sym3__]",
                                   gq_real_3d_ar[(sym1__ - 1)][(sym2__ - 1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 73;
      current_statement__ = 73;
      check_less_or_equal(function__, "gq_vec", gq_vec, 1);
      current_statement__ = 79;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 79;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 79;
          current_statement__ = 79;
          check_greater_or_equal(function__, "gq_ar_mat[sym1__, sym2__]",
                                 gq_ar_mat[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 79;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 79;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 79;
          current_statement__ = 79;
          check_less_or_equal(function__, "gq_ar_mat[sym1__, sym2__]",
                              gq_ar_mat[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 80;
      current_statement__ = 80;
      check_simplex(function__, "gq_simplex", gq_simplex);
      current_statement__ = 81;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 81;
        current_statement__ = 81;
        check_simplex(function__, "gq_1d_simplex[sym1__]",
                      gq_1d_simplex[(sym1__ - 1)]);}
      current_statement__ = 82;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 82;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 82;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 82;
            current_statement__ = 82;
            check_simplex(function__,
                          "gq_3d_simplex[sym1__, sym2__, sym3__]",
                          gq_3d_simplex[(sym1__ - 1)][(sym2__ - 1)][(sym3__ -
                                                                    1)]);}}}
      current_statement__ = 83;
      current_statement__ = 83;
      check_cholesky_factor(function__, "gq_cfcov_54", gq_cfcov_54);
      current_statement__ = 84;
      current_statement__ = 84;
      check_cholesky_factor(function__, "gq_cfcov_33", gq_cfcov_33);
      current_statement__ = 85;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        current_statement__ = 85;
        current_statement__ = 85;
        check_cholesky_factor(function__, "gq_cfcov_33_ar[sym1__]",
                              gq_cfcov_33_ar[(sym1__ - 1)]);}
      vars__.push_back(gq_r1);
      vars__.push_back(gq_r2);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(gq_real_1d_ar[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(
              gq_real_3d_ar[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(gq_vec[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(gq_1d_vec[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                gq_3d_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
                                                                    1)]);}}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(gq_row_vec[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(gq_1d_row_vec[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                gq_3d_row_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][
                (sym1__ - 1)]);}}}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
              vars__.push_back(
                rvalue(gq_ar_mat,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  "gq_ar_mat"));}}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(gq_simplex[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(gq_1d_simplex[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                gq_3d_simplex[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][
                (sym1__ - 1)]);}}}}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          vars__.push_back(
            rvalue(gq_cfcov_54,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "gq_cfcov_54"));}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          vars__.push_back(
            rvalue(gq_cfcov_33,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "gq_cfcov_33"));}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            vars__.push_back(
              rvalue(gq_cfcov_33_ar,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                "gq_cfcov_33_ar"));}}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        vars__.push_back(indices[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            vars__.push_back(
              rvalue(indexing_mat,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                "indexing_mat"));}}}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            vars__.push_back(
              rvalue(idx_res1,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                "idx_res1"));}}}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            vars__.push_back(
              rvalue(idx_res2,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                "idx_res2"));}}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            vars__.push_back(
              rvalue(idx_res3,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                "idx_res3"));}}}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            vars__.push_back(
              rvalue(idx_res11,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                "idx_res11"));}}}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            vars__.push_back(
              rvalue(idx_res21,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                "idx_res21"));}}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
            vars__.push_back(
              rvalue(idx_res31,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                "idx_res31"));}}}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          vars__.push_back(idx_res4[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          vars__.push_back(idx_res5[(sym2__ - 1)][(sym1__ - 1)]);}}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  inline void transform_inits(const stan::io::var_context& context__,
                              std::vector<int>& params_i__,
                              std::vector<double>& vars__,
                              std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double p_real;
      p_real = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      p_real = context__.vals_r("p_real")[(1 - 1)];
      current_statement__ = 2;
      validate_non_negative_index("offset_multiplier", "5", 5);
      std::vector<double> offset_multiplier;
      offset_multiplier = std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      assign(offset_multiplier, nil_index_list(),
        context__.vals_r("offset_multiplier"),
        "assigning variable offset_multiplier");
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 2;
        assign(offset_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::offset_multiplier_free(offset_multiplier[(sym1__ - 1)],
            1, 2), "assigning variable offset_multiplier");}
      current_statement__ = 3;
      validate_non_negative_index("no_offset_multiplier", "5", 5);
      std::vector<double> no_offset_multiplier;
      no_offset_multiplier = std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      assign(no_offset_multiplier, nil_index_list(),
        context__.vals_r("no_offset_multiplier"),
        "assigning variable no_offset_multiplier");
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 3;
        assign(no_offset_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::offset_multiplier_free(
            no_offset_multiplier[(sym1__ - 1)], 0, 2),
          "assigning variable no_offset_multiplier");}
      current_statement__ = 4;
      validate_non_negative_index("offset_no_multiplier", "5", 5);
      std::vector<double> offset_no_multiplier;
      offset_no_multiplier = std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      assign(offset_no_multiplier, nil_index_list(),
        context__.vals_r("offset_no_multiplier"),
        "assigning variable offset_no_multiplier");
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        current_statement__ = 4;
        assign(offset_no_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::offset_multiplier_free(
            offset_no_multiplier[(sym1__ - 1)], 3, 1),
          "assigning variable offset_no_multiplier");}
      current_statement__ = 5;
      validate_non_negative_index("p_real_1d_ar", "N", N);
      std::vector<double> p_real_1d_ar;
      p_real_1d_ar = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      assign(p_real_1d_ar, nil_index_list(),
        context__.vals_r("p_real_1d_ar"), "assigning variable p_real_1d_ar");
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 5;
        assign(p_real_1d_ar, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(p_real_1d_ar[(sym1__ - 1)], 0),
          "assigning variable p_real_1d_ar");}
      current_statement__ = 6;
      validate_non_negative_index("p_real_3d_ar", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("p_real_3d_ar", "M", M);
      current_statement__ = 6;
      validate_non_negative_index("p_real_3d_ar", "K", K);
      std::vector<std::vector<std::vector<double>>> p_real_3d_ar;
      p_real_3d_ar = std::vector<std::vector<std::vector<double>>>(N, std::vector<std::vector<double>>(M, std::vector<double>(K, std::numeric_limits<double>::quiet_NaN())));
      
      {
        std::vector<local_scalar_t__> p_real_3d_ar_flat__;
        current_statement__ = 6;
        assign(p_real_3d_ar_flat__, nil_index_list(),
          context__.vals_r("p_real_3d_ar"),
          "assigning variable p_real_3d_ar_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 6;
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            current_statement__ = 6;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 6;
              assign(p_real_3d_ar,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                p_real_3d_ar_flat__[(pos__ - 1)],
                "assigning variable p_real_3d_ar");
              current_statement__ = 6;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 6;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 6;
            assign(p_real_3d_ar,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              stan::math::lb_free(
                p_real_3d_ar[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)], 0),
              "assigning variable p_real_3d_ar");}}}
      current_statement__ = 7;
      validate_non_negative_index("p_vec", "N", N);
      Eigen::Matrix<double, -1, 1> p_vec;
      p_vec = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(p_vec, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_vec_flat__;
        current_statement__ = 7;
        assign(p_vec_flat__, nil_index_list(), context__.vals_r("p_vec"),
          "assigning variable p_vec_flat__");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 7;
          assign(p_vec, cons_list(index_uni(sym1__), nil_index_list()),
            p_vec_flat__[(pos__ - 1)], "assigning variable p_vec");
          current_statement__ = 7;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 7;
        assign(p_vec, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(p_vec[(sym1__ - 1)], 0),
          "assigning variable p_vec");}
      current_statement__ = 8;
      validate_non_negative_index("p_1d_vec", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("p_1d_vec", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> p_1d_vec;
      p_1d_vec = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(p_1d_vec, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_1d_vec_flat__;
        current_statement__ = 8;
        assign(p_1d_vec_flat__, nil_index_list(),
          context__.vals_r("p_1d_vec"), "assigning variable p_1d_vec_flat__");
        current_statement__ = 8;
        pos__ = 1;
        current_statement__ = 8;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 8;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 8;
            assign(p_1d_vec,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              p_1d_vec_flat__[(pos__ - 1)], "assigning variable p_1d_vec");
            current_statement__ = 8;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "M", M);
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "K", K);
      current_statement__ = 9;
      validate_non_negative_index("p_3d_vec", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>> p_3d_vec;
      p_3d_vec = std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(N))));
      stan::math::fill(p_3d_vec, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_3d_vec_flat__;
        current_statement__ = 9;
        assign(p_3d_vec_flat__, nil_index_list(),
          context__.vals_r("p_3d_vec"), "assigning variable p_3d_vec_flat__");
        current_statement__ = 9;
        pos__ = 1;
        current_statement__ = 9;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 9;
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            current_statement__ = 9;
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              current_statement__ = 9;
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                current_statement__ = 9;
                assign(p_3d_vec,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  p_3d_vec_flat__[(pos__ - 1)], "assigning variable p_3d_vec");
                current_statement__ = 9;
                pos__ = (pos__ + 1);}}}}
      }
      current_statement__ = 10;
      validate_non_negative_index("p_row_vec", "N", N);
      Eigen::Matrix<double, 1, -1> p_row_vec;
      p_row_vec = Eigen::Matrix<double, 1, -1>(N);
      stan::math::fill(p_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_row_vec_flat__;
        current_statement__ = 10;
        assign(p_row_vec_flat__, nil_index_list(),
          context__.vals_r("p_row_vec"),
          "assigning variable p_row_vec_flat__");
        current_statement__ = 10;
        pos__ = 1;
        current_statement__ = 10;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 10;
          assign(p_row_vec, cons_list(index_uni(sym1__), nil_index_list()),
            p_row_vec_flat__[(pos__ - 1)], "assigning variable p_row_vec");
          current_statement__ = 10;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 11;
      validate_non_negative_index("p_1d_row_vec", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("p_1d_row_vec", "N", N);
      std::vector<Eigen::Matrix<double, 1, -1>> p_1d_row_vec;
      p_1d_row_vec = std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N));
      stan::math::fill(p_1d_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_1d_row_vec_flat__;
        current_statement__ = 11;
        assign(p_1d_row_vec_flat__, nil_index_list(),
          context__.vals_r("p_1d_row_vec"),
          "assigning variable p_1d_row_vec_flat__");
        current_statement__ = 11;
        pos__ = 1;
        current_statement__ = 11;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 11;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 11;
            assign(p_1d_row_vec,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              p_1d_row_vec_flat__[(pos__ - 1)],
              "assigning variable p_1d_row_vec");
            current_statement__ = 11;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "N", N);
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "M", M);
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "K", K);
      current_statement__ = 12;
      validate_non_negative_index("p_3d_row_vec", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>> p_3d_row_vec;
      p_3d_row_vec = std::vector<std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(M, std::vector<Eigen::Matrix<double, 1, -1>>(K, Eigen::Matrix<double, 1, -1>(N))));
      stan::math::fill(p_3d_row_vec, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_3d_row_vec_flat__;
        current_statement__ = 12;
        assign(p_3d_row_vec_flat__, nil_index_list(),
          context__.vals_r("p_3d_row_vec"),
          "assigning variable p_3d_row_vec_flat__");
        current_statement__ = 12;
        pos__ = 1;
        current_statement__ = 12;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 12;
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            current_statement__ = 12;
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              current_statement__ = 12;
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                current_statement__ = 12;
                assign(p_3d_row_vec,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  p_3d_row_vec_flat__[(pos__ - 1)],
                  "assigning variable p_3d_row_vec");
                current_statement__ = 12;
                pos__ = (pos__ + 1);}}}}
      }
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "4", 4);
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "5", 5);
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "2", 2);
      current_statement__ = 13;
      validate_non_negative_index("p_ar_mat", "3", 3);
      std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> p_ar_mat;
      p_ar_mat = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(4, std::vector<Eigen::Matrix<double, -1, -1>>(5, Eigen::Matrix<double, -1, -1>(2, 3)));
      stan::math::fill(p_ar_mat, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_ar_mat_flat__;
        current_statement__ = 13;
        assign(p_ar_mat_flat__, nil_index_list(),
          context__.vals_r("p_ar_mat"), "assigning variable p_ar_mat_flat__");
        current_statement__ = 13;
        pos__ = 1;
        current_statement__ = 13;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 13;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 13;
            for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
              current_statement__ = 13;
              for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
                current_statement__ = 13;
                assign(p_ar_mat,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  p_ar_mat_flat__[(pos__ - 1)], "assigning variable p_ar_mat");
                current_statement__ = 13;
                pos__ = (pos__ + 1);}}}}
      }
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        current_statement__ = 13;
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          current_statement__ = 13;
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            current_statement__ = 13;
            for (int sym4__ = 1; sym4__ <= 3; ++sym4__) {
              current_statement__ = 13;
              assign(p_ar_mat,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym4__), nil_index_list())))),
                stan::math::lub_free(
                  rvalue(p_ar_mat,
                    cons_list(index_uni(sym1__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym3__),
                          cons_list(index_uni(sym4__), nil_index_list())))),
                    "p_ar_mat"), 0, 1), "assigning variable p_ar_mat");}}}}
      current_statement__ = 14;
      validate_positive_index("p_simplex", "N", N);
      Eigen::Matrix<double, -1, 1> p_simplex;
      p_simplex = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(p_simplex, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_simplex_flat__;
        current_statement__ = 14;
        assign(p_simplex_flat__, nil_index_list(),
          context__.vals_r("p_simplex"),
          "assigning variable p_simplex_flat__");
        current_statement__ = 14;
        pos__ = 1;
        current_statement__ = 14;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 14;
          assign(p_simplex, cons_list(index_uni(sym1__), nil_index_list()),
            p_simplex_flat__[(pos__ - 1)], "assigning variable p_simplex");
          current_statement__ = 14;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 14;
      assign(p_simplex, nil_index_list(),
        stan::math::simplex_free(p_simplex), "assigning variable p_simplex");
      current_statement__ = 15;
      validate_non_negative_index("p_1d_simplex", "N", N);
      current_statement__ = 15;
      validate_positive_index("p_1d_simplex", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> p_1d_simplex;
      p_1d_simplex = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(p_1d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_1d_simplex_flat__;
        current_statement__ = 15;
        assign(p_1d_simplex_flat__, nil_index_list(),
          context__.vals_r("p_1d_simplex"),
          "assigning variable p_1d_simplex_flat__");
        current_statement__ = 15;
        pos__ = 1;
        current_statement__ = 15;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 15;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 15;
            assign(p_1d_simplex,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              p_1d_simplex_flat__[(pos__ - 1)],
              "assigning variable p_1d_simplex");
            current_statement__ = 15;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 15;
        assign(p_1d_simplex, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::simplex_free(p_1d_simplex[(sym1__ - 1)]),
          "assigning variable p_1d_simplex");}
      current_statement__ = 16;
      validate_non_negative_index("p_3d_simplex", "N", N);
      current_statement__ = 16;
      validate_non_negative_index("p_3d_simplex", "M", M);
      current_statement__ = 16;
      validate_non_negative_index("p_3d_simplex", "K", K);
      current_statement__ = 16;
      validate_positive_index("p_3d_simplex", "N", N);
      std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>> p_3d_simplex;
      p_3d_simplex = std::vector<std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>>(N, std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(N))));
      stan::math::fill(p_3d_simplex, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_3d_simplex_flat__;
        current_statement__ = 16;
        assign(p_3d_simplex_flat__, nil_index_list(),
          context__.vals_r("p_3d_simplex"),
          "assigning variable p_3d_simplex_flat__");
        current_statement__ = 16;
        pos__ = 1;
        current_statement__ = 16;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 16;
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            current_statement__ = 16;
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              current_statement__ = 16;
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                current_statement__ = 16;
                assign(p_3d_simplex,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  p_3d_simplex_flat__[(pos__ - 1)],
                  "assigning variable p_3d_simplex");
                current_statement__ = 16;
                pos__ = (pos__ + 1);}}}}
      }
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 16;
          for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
            current_statement__ = 16;
            assign(p_3d_simplex,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              stan::math::simplex_free(
                p_3d_simplex[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)]),
              "assigning variable p_3d_simplex");}}}
      current_statement__ = 17;
      check_greater_or_equal("cholesky_factor_cov p_cfcov_54",
                             "num rows (must be greater or equal to num cols)",
                             5, 4);
      current_statement__ = 17;
      validate_non_negative_index("p_cfcov_54", "4", 4);
      Eigen::Matrix<double, -1, -1> p_cfcov_54;
      p_cfcov_54 = Eigen::Matrix<double, -1, -1>(5, 4);
      stan::math::fill(p_cfcov_54, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_cfcov_54_flat__;
        current_statement__ = 17;
        assign(p_cfcov_54_flat__, nil_index_list(),
          context__.vals_r("p_cfcov_54"),
          "assigning variable p_cfcov_54_flat__");
        current_statement__ = 17;
        pos__ = 1;
        current_statement__ = 17;
        for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
          current_statement__ = 17;
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            current_statement__ = 17;
            assign(p_cfcov_54,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              p_cfcov_54_flat__[(pos__ - 1)], "assigning variable p_cfcov_54");
            current_statement__ = 17;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 17;
      validate_non_negative_index("p_cfcov_54_free__",
                                  "((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4))",
                                  ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4)));
      Eigen::Matrix<double, -1, 1> p_cfcov_54_free__;
      p_cfcov_54_free__ = Eigen::Matrix<double, -1, 1>(((((4 * (4 - 1)) / 2)
                                                          + 4) +
                                                         ((5 - 4) * 4)));
      stan::math::fill(p_cfcov_54_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 17;
      assign(p_cfcov_54_free__, nil_index_list(),
        stan::math::cholesky_factor_free(p_cfcov_54),
        "assigning variable p_cfcov_54_free__");
      current_statement__ = 18;
      check_greater_or_equal("cholesky_factor_cov p_cfcov_33",
                             "num rows (must be greater or equal to num cols)",
                             3, 3);
      current_statement__ = 18;
      validate_non_negative_index("p_cfcov_33", "3", 3);
      Eigen::Matrix<double, -1, -1> p_cfcov_33;
      p_cfcov_33 = Eigen::Matrix<double, -1, -1>(3, 3);
      stan::math::fill(p_cfcov_33, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_cfcov_33_flat__;
        current_statement__ = 18;
        assign(p_cfcov_33_flat__, nil_index_list(),
          context__.vals_r("p_cfcov_33"),
          "assigning variable p_cfcov_33_flat__");
        current_statement__ = 18;
        pos__ = 1;
        current_statement__ = 18;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 18;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 18;
            assign(p_cfcov_33,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              p_cfcov_33_flat__[(pos__ - 1)], "assigning variable p_cfcov_33");
            current_statement__ = 18;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 18;
      validate_non_negative_index("p_cfcov_33_free__",
                                  "((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3))",
                                  ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)));
      Eigen::Matrix<double, -1, 1> p_cfcov_33_free__;
      p_cfcov_33_free__ = Eigen::Matrix<double, -1, 1>(((((3 * (3 - 1)) / 2)
                                                          + 3) +
                                                         ((3 - 3) * 3)));
      stan::math::fill(p_cfcov_33_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 18;
      assign(p_cfcov_33_free__, nil_index_list(),
        stan::math::cholesky_factor_free(p_cfcov_33),
        "assigning variable p_cfcov_33_free__");
      current_statement__ = 19;
      validate_non_negative_index("p_cfcov_33_ar", "K", K);
      current_statement__ = 19;
      check_greater_or_equal("cholesky_factor_cov p_cfcov_33_ar",
                             "num rows (must be greater or equal to num cols)",
                             3, 3);
      current_statement__ = 19;
      validate_non_negative_index("p_cfcov_33_ar", "3", 3);
      std::vector<Eigen::Matrix<double, -1, -1>> p_cfcov_33_ar;
      p_cfcov_33_ar = std::vector<Eigen::Matrix<double, -1, -1>>(K, Eigen::Matrix<double, -1, -1>(3, 3));
      stan::math::fill(p_cfcov_33_ar, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> p_cfcov_33_ar_flat__;
        current_statement__ = 19;
        assign(p_cfcov_33_ar_flat__, nil_index_list(),
          context__.vals_r("p_cfcov_33_ar"),
          "assigning variable p_cfcov_33_ar_flat__");
        current_statement__ = 19;
        pos__ = 1;
        current_statement__ = 19;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 19;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 19;
            for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
              current_statement__ = 19;
              assign(p_cfcov_33_ar,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                p_cfcov_33_ar_flat__[(pos__ - 1)],
                "assigning variable p_cfcov_33_ar");
              current_statement__ = 19;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 19;
      validate_non_negative_index("p_cfcov_33_ar_free__", "K", K);
      current_statement__ = 19;
      validate_non_negative_index("p_cfcov_33_ar_free__",
                                  "((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3))",
                                  ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)));
      std::vector<Eigen::Matrix<double, -1, 1>> p_cfcov_33_ar_free__;
      p_cfcov_33_ar_free__ = std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(
        ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3))));
      stan::math::fill(p_cfcov_33_ar_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        current_statement__ = 19;
        assign(p_cfcov_33_ar_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::cholesky_factor_free(p_cfcov_33_ar[(sym1__ - 1)]),
          "assigning variable p_cfcov_33_ar_free__");}
      current_statement__ = 20;
      validate_non_negative_index("x_p", "2", 2);
      Eigen::Matrix<double, -1, 1> x_p;
      x_p = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(x_p, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_p_flat__;
        current_statement__ = 20;
        assign(x_p_flat__, nil_index_list(), context__.vals_r("x_p"),
          "assigning variable x_p_flat__");
        current_statement__ = 20;
        pos__ = 1;
        current_statement__ = 20;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 20;
          assign(x_p, cons_list(index_uni(sym1__), nil_index_list()),
            x_p_flat__[(pos__ - 1)], "assigning variable x_p");
          current_statement__ = 20;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 21;
      validate_non_negative_index("y_p", "2", 2);
      Eigen::Matrix<double, -1, 1> y_p;
      y_p = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(y_p, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y_p_flat__;
        current_statement__ = 21;
        assign(y_p_flat__, nil_index_list(), context__.vals_r("y_p"),
          "assigning variable y_p_flat__");
        current_statement__ = 21;
        pos__ = 1;
        current_statement__ = 21;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 21;
          assign(y_p, cons_list(index_uni(sym1__), nil_index_list()),
            y_p_flat__[(pos__ - 1)], "assigning variable y_p");
          current_statement__ = 21;
          pos__ = (pos__ + 1);}
      }
      vars__.push_back(p_real);
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        vars__.push_back(offset_multiplier[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        vars__.push_back(no_offset_multiplier[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        vars__.push_back(offset_no_multiplier[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(p_real_1d_ar[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(
              p_real_3d_ar[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(p_vec[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(p_1d_vec[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                p_3d_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
                                                                    1)]);}}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(p_row_vec[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(p_1d_row_vec[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                p_3d_row_vec[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][
                (sym1__ - 1)]);}}}}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
              vars__.push_back(
                rvalue(p_ar_mat,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  "p_ar_mat"));}}}}
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        vars__.push_back(p_simplex[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(p_1d_simplex[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                p_3d_simplex[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][
                (sym1__ - 1)]);}}}}
      for (int sym1__ = 1;
           sym1__ <= ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4)); ++sym1__) {
        vars__.push_back(p_cfcov_54_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1;
           sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)); ++sym1__) {
        vars__.push_back(p_cfcov_33_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1;
           sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)); ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          vars__.push_back(p_cfcov_33_ar_free__[(sym2__ - 1)][(sym1__ - 1)]);
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(x_p[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(y_p[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("p_real");
    names__.push_back("offset_multiplier");
    names__.push_back("no_offset_multiplier");
    names__.push_back("offset_no_multiplier");
    names__.push_back("p_real_1d_ar");
    names__.push_back("p_real_3d_ar");
    names__.push_back("p_vec");
    names__.push_back("p_1d_vec");
    names__.push_back("p_3d_vec");
    names__.push_back("p_row_vec");
    names__.push_back("p_1d_row_vec");
    names__.push_back("p_3d_row_vec");
    names__.push_back("p_ar_mat");
    names__.push_back("p_simplex");
    names__.push_back("p_1d_simplex");
    names__.push_back("p_3d_simplex");
    names__.push_back("p_cfcov_54");
    names__.push_back("p_cfcov_33");
    names__.push_back("p_cfcov_33_ar");
    names__.push_back("x_p");
    names__.push_back("y_p");
    names__.push_back("tp_real_1d_ar");
    names__.push_back("tp_real_3d_ar");
    names__.push_back("tp_vec");
    names__.push_back("tp_1d_vec");
    names__.push_back("tp_3d_vec");
    names__.push_back("tp_row_vec");
    names__.push_back("tp_1d_row_vec");
    names__.push_back("tp_3d_row_vec");
    names__.push_back("tp_ar_mat");
    names__.push_back("tp_simplex");
    names__.push_back("tp_1d_simplex");
    names__.push_back("tp_3d_simplex");
    names__.push_back("tp_cfcov_54");
    names__.push_back("tp_cfcov_33");
    names__.push_back("tp_cfcov_33_ar");
    names__.push_back("theta_p");
    names__.push_back("gq_r1");
    names__.push_back("gq_r2");
    names__.push_back("gq_real_1d_ar");
    names__.push_back("gq_real_3d_ar");
    names__.push_back("gq_vec");
    names__.push_back("gq_1d_vec");
    names__.push_back("gq_3d_vec");
    names__.push_back("gq_row_vec");
    names__.push_back("gq_1d_row_vec");
    names__.push_back("gq_3d_row_vec");
    names__.push_back("gq_ar_mat");
    names__.push_back("gq_simplex");
    names__.push_back("gq_1d_simplex");
    names__.push_back("gq_3d_simplex");
    names__.push_back("gq_cfcov_54");
    names__.push_back("gq_cfcov_33");
    names__.push_back("gq_cfcov_33_ar");
    names__.push_back("indices");
    names__.push_back("indexing_mat");
    names__.push_back("idx_res1");
    names__.push_back("idx_res2");
    names__.push_back("idx_res3");
    names__.push_back("idx_res11");
    names__.push_back("idx_res21");
    names__.push_back("idx_res31");
    names__.push_back("idx_res4");
    names__.push_back("idx_res5");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(5);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(5);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(5);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(M);
    
    dims__.push_back(K);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(M);
    
    dims__.push_back(K);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(M);
    
    dims__.push_back(K);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(4);
    
    dims__.push_back(5);
    
    dims__.push_back(2);
    
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(M);
    
    dims__.push_back(K);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(5);
    
    dims__.push_back(4);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(K);
    
    dims__.push_back(3);
    
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(M);
    
    dims__.push_back(K);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(M);
    
    dims__.push_back(K);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(M);
    
    dims__.push_back(K);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(4);
    
    dims__.push_back(5);
    
    dims__.push_back(2);
    
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(M);
    
    dims__.push_back(K);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(5);
    
    dims__.push_back(4);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(K);
    
    dims__.push_back(3);
    
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(M);
    
    dims__.push_back(K);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(M);
    
    dims__.push_back(K);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(M);
    
    dims__.push_back(K);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(4);
    
    dims__.push_back(5);
    
    dims__.push_back(2);
    
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(M);
    
    dims__.push_back(K);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(5);
    
    dims__.push_back(4);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(K);
    
    dims__.push_back(3);
    
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(5);
    
    dims__.push_back(3);
    
    dims__.push_back(4);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    
    dims__.push_back(3);
    
    dims__.push_back(4);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(5);
    
    dims__.push_back(3);
    
    dims__.push_back(4);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    
    dims__.push_back(3);
    
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    
    dims__.push_back(3);
    
    dims__.push_back(4);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(5);
    
    dims__.push_back(3);
    
    dims__.push_back(4);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    
    dims__.push_back(3);
    
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    
    dims__.push_back(4);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "p_real");
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      {
        param_names__.push_back(std::string() + "offset_multiplier" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      {
        param_names__.push_back(std::string() + "no_offset_multiplier" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      {
        param_names__.push_back(std::string() + "offset_no_multiplier" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "p_real_1d_ar" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "p_real_3d_ar" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "p_vec" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "p_1d_vec" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "p_3d_vec" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "p_row_vec" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "p_1d_row_vec" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "p_3d_row_vec" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "p_ar_mat" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "p_simplex" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "p_1d_simplex" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "p_3d_simplex" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          {
            param_names__.push_back(std::string() + "p_cfcov_54" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          {
            param_names__.push_back(std::string() + "p_cfcov_33" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
              {
                param_names__.push_back(std::string() + "p_cfcov_33_ar" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.push_back(std::string() + "x_p" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y_p" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "tp_real_1d_ar" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "tp_real_3d_ar" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "tp_vec" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "tp_1d_vec" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "tp_3d_vec" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "tp_row_vec" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "tp_1d_row_vec" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "tp_3d_row_vec" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "tp_ar_mat" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "tp_simplex" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "tp_1d_simplex" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "tp_3d_simplex" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            {
              param_names__.push_back(std::string() + "tp_cfcov_54" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              param_names__.push_back(std::string() + "tp_cfcov_33" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "tp_cfcov_33_ar" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          param_names__.push_back(std::string() + "theta_p" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "gq_r1");
      param_names__.push_back(std::string() + "gq_r2");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "gq_real_1d_ar" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "gq_real_3d_ar" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "gq_vec" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "gq_1d_vec" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "gq_3d_vec" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "gq_row_vec" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "gq_1d_row_vec" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "gq_3d_row_vec" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "gq_ar_mat" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "gq_simplex" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "gq_1d_simplex" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "gq_3d_simplex" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            {
              param_names__.push_back(std::string() + "gq_cfcov_54" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              param_names__.push_back(std::string() + "gq_cfcov_33" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= K; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "gq_cfcov_33_ar" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          param_names__.push_back(std::string() + "indices" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "indexing_mat" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "idx_res1" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "idx_res2" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "idx_res3" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "idx_res11" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "idx_res21" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "idx_res31" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              param_names__.push_back(std::string() + "idx_res4" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            {
              param_names__.push_back(std::string() + "idx_res5" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "p_real");
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      {
        param_names__.push_back(std::string() + "offset_multiplier" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      {
        param_names__.push_back(std::string() + "no_offset_multiplier" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      {
        param_names__.push_back(std::string() + "offset_no_multiplier" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "p_real_1d_ar" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "p_real_3d_ar" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "p_vec" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "p_1d_vec" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "p_3d_vec" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "p_row_vec" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "p_1d_row_vec" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "p_3d_row_vec" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "p_ar_mat" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
      {
        param_names__.push_back(std::string() + "p_simplex" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "p_1d_simplex" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "p_3d_simplex" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    for (int sym1__ = 1;
         sym1__ <= ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4)); ++sym1__) {
      {
        param_names__.push_back(std::string() + "p_cfcov_54" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1;
         sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)); ++sym1__) {
      {
        param_names__.push_back(std::string() + "p_cfcov_33" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1;
         sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)); ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            param_names__.push_back(std::string() + "p_cfcov_33_ar" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.push_back(std::string() + "x_p" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y_p" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "tp_real_1d_ar" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "tp_real_3d_ar" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "tp_vec" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "tp_1d_vec" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "tp_3d_vec" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "tp_row_vec" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "tp_1d_row_vec" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "tp_3d_row_vec" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "tp_ar_mat" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        {
          param_names__.push_back(std::string() + "tp_simplex" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "tp_1d_simplex" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "tp_3d_simplex" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1;
           sym1__ <= ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4)); ++sym1__) {
        {
          param_names__.push_back(std::string() + "tp_cfcov_54" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1;
           sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)); ++sym1__) {
        {
          param_names__.push_back(std::string() + "tp_cfcov_33" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1;
           sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)); ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              param_names__.push_back(std::string() + "tp_cfcov_33_ar" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          param_names__.push_back(std::string() + "theta_p" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "gq_r1");
      param_names__.push_back(std::string() + "gq_r2");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "gq_real_1d_ar" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "gq_real_3d_ar" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "gq_vec" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "gq_1d_vec" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "gq_3d_vec" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.push_back(std::string() + "gq_row_vec" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "gq_1d_row_vec" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "gq_3d_row_vec" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= 4; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "gq_ar_mat" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        {
          param_names__.push_back(std::string() + "gq_simplex" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "gq_1d_simplex" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= (N - 1); ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                    {
                      param_names__.push_back(std::string() + "gq_3d_simplex" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1;
           sym1__ <= ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4)); ++sym1__) {
        {
          param_names__.push_back(std::string() + "gq_cfcov_54" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1;
           sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)); ++sym1__) {
        {
          param_names__.push_back(std::string() + "gq_cfcov_33" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1;
           sym1__ <= ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)); ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              param_names__.push_back(std::string() + "gq_cfcov_33_ar" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          param_names__.push_back(std::string() + "indices" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "indexing_mat" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "idx_res1" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "idx_res2" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "idx_res3" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "idx_res11" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 5; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "idx_res21" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= 3; ++sym3__) {
                {
                  param_names__.push_back(std::string() + "idx_res31" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              param_names__.push_back(std::string() + "idx_res4" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            {
              param_names__.push_back(std::string() + "idx_res5" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"p_real\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"offset_multiplier\",\"type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"no_offset_multiplier\",\"type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"offset_no_multiplier\",\"type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_real_1d_ar\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_real_3d_ar\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"parameters\"},{\"name\":\"p_vec\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"p_1d_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"p_3d_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"parameters\"},{\"name\":\"p_row_vec\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"p_1d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"p_3d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"parameters\"},{\"name\":\"p_ar_mat\",\"type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 2 << ",\"cols\":" << 3 << "}}},\"block\":\"parameters\"},{\"name\":\"p_simplex\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"p_1d_simplex\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"p_3d_simplex\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"parameters\"},{\"name\":\"p_cfcov_54\",\"type\":{\"name\":\"matrix\",\"rows\":" << 5 << ",\"cols\":" << 4 << "},\"block\":\"parameters\"},{\"name\":\"p_cfcov_33\",\"type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 3 << "},\"block\":\"parameters\"},{\"name\":\"p_cfcov_33_ar\",\"type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 3 << "}},\"block\":\"parameters\"},{\"name\":\"x_p\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"y_p\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"tp_real_1d_ar\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_real_3d_ar\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_vec\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_1d_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3d_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_row_vec\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_1d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_ar_mat\",\"type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 2 << ",\"cols\":" << 3 << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_simplex\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_1d_simplex\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3d_simplex\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_cfcov_54\",\"type\":{\"name\":\"matrix\",\"rows\":" << 5 << ",\"cols\":" << 4 << "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_cfcov_33\",\"type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 3 << "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_cfcov_33_ar\",\"type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 3 << "}},\"block\":\"transformed_parameters\"},{\"name\":\"theta_p\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"transformed_parameters\"},{\"name\":\"gq_r1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"gq_r2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"gq_real_1d_ar\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"gq_real_3d_ar\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_vec\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"gq_1d_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"generated_quantities\"},{\"name\":\"gq_3d_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_row_vec\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"gq_1d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"generated_quantities\"},{\"name\":\"gq_3d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_ar_mat\",\"type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 2 << ",\"cols\":" << 3 << "}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_simplex\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"gq_1d_simplex\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"generated_quantities\"},{\"name\":\"gq_3d_simplex\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_cfcov_54\",\"type\":{\"name\":\"matrix\",\"rows\":" << 5 << ",\"cols\":" << 4 << "},\"block\":\"generated_quantities\"},{\"name\":\"gq_cfcov_33\",\"type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 3 << "},\"block\":\"generated_quantities\"},{\"name\":\"gq_cfcov_33_ar\",\"type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 3 << "}},\"block\":\"generated_quantities\"},{\"name\":\"indices\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"indexing_mat\",\"type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 4 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res1\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 4 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res2\",\"type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 4 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res3\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 3 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res11\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 4 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res21\",\"type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 4 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res31\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 3 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res4\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 4 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res5\",\"type\":{\"name\":\"array\",\"length\":" << 2 << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"p_real\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"offset_multiplier\",\"type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"no_offset_multiplier\",\"type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"offset_no_multiplier\",\"type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_real_1d_ar\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"p_real_3d_ar\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"parameters\"},{\"name\":\"p_vec\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"p_1d_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"p_3d_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"parameters\"},{\"name\":\"p_row_vec\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"p_1d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"p_3d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"parameters\"},{\"name\":\"p_ar_mat\",\"type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 2 << ",\"cols\":" << 3 << "}}},\"block\":\"parameters\"},{\"name\":\"p_simplex\",\"type\":{\"name\":\"vector\",\"length\":" << (N - 1) << "},\"block\":\"parameters\"},{\"name\":\"p_1d_simplex\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << (N - 1) << "}},\"block\":\"parameters\"},{\"name\":\"p_3d_simplex\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << (N - 1) << "}}}},\"block\":\"parameters\"},{\"name\":\"p_cfcov_54\",\"type\":{\"name\":\"vector\",\"length\":" << ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4)) << "},\"block\":\"parameters\"},{\"name\":\"p_cfcov_33\",\"type\":{\"name\":\"vector\",\"length\":" << ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)) << "},\"block\":\"parameters\"},{\"name\":\"p_cfcov_33_ar\",\"type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)) << "}},\"block\":\"parameters\"},{\"name\":\"x_p\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"y_p\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"tp_real_1d_ar\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_real_3d_ar\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_vec\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_1d_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3d_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_row_vec\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_1d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_ar_mat\",\"type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 2 << ",\"cols\":" << 3 << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_simplex\",\"type\":{\"name\":\"vector\",\"length\":" << (N - 1) << "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_1d_simplex\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << (N - 1) << "}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_3d_simplex\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << (N - 1) << "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"tp_cfcov_54\",\"type\":{\"name\":\"vector\",\"length\":" << ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4)) << "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_cfcov_33\",\"type\":{\"name\":\"vector\",\"length\":" << ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)) << "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_cfcov_33_ar\",\"type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)) << "}},\"block\":\"transformed_parameters\"},{\"name\":\"theta_p\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"transformed_parameters\"},{\"name\":\"gq_r1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"gq_r2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"gq_real_1d_ar\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"gq_real_3d_ar\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_vec\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"gq_1d_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"generated_quantities\"},{\"name\":\"gq_3d_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_row_vec\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"gq_1d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"generated_quantities\"},{\"name\":\"gq_3d_row_vec\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_ar_mat\",\"type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 2 << ",\"cols\":" << 3 << "}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_simplex\",\"type\":{\"name\":\"vector\",\"length\":" << (N - 1) << "},\"block\":\"generated_quantities\"},{\"name\":\"gq_1d_simplex\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << (N - 1) << "}},\"block\":\"generated_quantities\"},{\"name\":\"gq_3d_simplex\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << (N - 1) << "}}}},\"block\":\"generated_quantities\"},{\"name\":\"gq_cfcov_54\",\"type\":{\"name\":\"vector\",\"length\":" << ((((4 * (4 - 1)) / 2) + 4) + ((5 - 4) * 4)) << "},\"block\":\"generated_quantities\"},{\"name\":\"gq_cfcov_33\",\"type\":{\"name\":\"vector\",\"length\":" << ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)) << "},\"block\":\"generated_quantities\"},{\"name\":\"gq_cfcov_33_ar\",\"type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << ((((3 * (3 - 1)) / 2) + 3) + ((3 - 3) * 3)) << "}},\"block\":\"generated_quantities\"},{\"name\":\"indices\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"indexing_mat\",\"type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 4 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res1\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 4 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res2\",\"type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 4 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res3\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 3 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res11\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 4 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res21\",\"type\":{\"name\":\"array\",\"length\":" << 5 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 4 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res31\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 3 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res4\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 4 << "}},\"block\":\"generated_quantities\"},{\"name\":\"idx_res5\",\"type\":{\"name\":\"array\",\"length\":" << 2 << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef mother_model_namespace::mother_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif


STAN_REGISTER_MAP_RECT(1, mother_model_namespace::binomialf_functor__)

Warning: deprecated language construct used in 'mother.stan', line 63, column 21:
   -------------------------------------------------
    61:  
    62:    void unit_normal_lp(real u) {
    63:      increment_log_prob(normal_log(u,0,1));
                              ^
    64:      u ~ uniform(-100,100);
    65:    }
   -------------------------------------------------

increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.


Warning: deprecated language construct used in 'mother.stan', line 187, column 20:
   -------------------------------------------------
   185:  
   186:    real foo_lp(real x) {
   187:      return x + get_lp();
                             ^
   188:    }
   189:  
   -------------------------------------------------

get_lp() function is deprecated. It will be removed in a future release. Use target() instead.

  $ ../../../../../install/default/bin/stanc --print-cpp motherHOF.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace motherHOF_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'motherHOF.stan', line 48, column 2 to column 15)",
                                                      " (in 'motherHOF.stan', line 49, column 2 to column 18)",
                                                      " (in 'motherHOF.stan', line 50, column 2 to column 14)",
                                                      " (in 'motherHOF.stan', line 51, column 2 to column 18)",
                                                      " (in 'motherHOF.stan', line 52, column 2 to column 28)",
                                                      " (in 'motherHOF.stan', line 53, column 2 to column 28)",
                                                      " (in 'motherHOF.stan', line 54, column 2 to column 11)",
                                                      " (in 'motherHOF.stan', line 57, column 2 to column 18)",
                                                      " (in 'motherHOF.stan', line 58, column 2 to column 37)",
                                                      " (in 'motherHOF.stan', line 59, column 2 to column 33)",
                                                      " (in 'motherHOF.stan', line 60, column 2 to line 61, column 69)",
                                                      " (in 'motherHOF.stan', line 62, column 2 to line 63, column 69)",
                                                      " (in 'motherHOF.stan', line 64, column 2 to line 65, column 69)",
                                                      " (in 'motherHOF.stan', line 66, column 2 to column 23)",
                                                      " (in 'motherHOF.stan', line 67, column 2 to column 16)",
                                                      " (in 'motherHOF.stan', line 68, column 2 to column 16)",
                                                      " (in 'motherHOF.stan', line 69, column 2 to column 16)",
                                                      " (in 'motherHOF.stan', line 70, column 2 to column 70)",
                                                      " (in 'motherHOF.stan', line 71, column 2 to column 86)",
                                                      " (in 'motherHOF.stan', line 72, column 2 to column 86)",
                                                      " (in 'motherHOF.stan', line 73, column 2 to column 72)",
                                                      " (in 'motherHOF.stan', line 75, column 2 to column 88)",
                                                      " (in 'motherHOF.stan', line 76, column 2 to column 72)",
                                                      " (in 'motherHOF.stan', line 77, column 2 to column 88)",
                                                      " (in 'motherHOF.stan', line 132, column 2 to column 18)",
                                                      " (in 'motherHOF.stan', line 133, column 2 to column 68)",
                                                      " (in 'motherHOF.stan', line 134, column 2 to column 68)",
                                                      " (in 'motherHOF.stan', line 135, column 2 to column 68)",
                                                      " (in 'motherHOF.stan', line 136, column 2 to column 68)",
                                                      " (in 'motherHOF.stan', line 138, column 2 to column 87)",
                                                      " (in 'motherHOF.stan', line 139, column 2 to column 87)",
                                                      " (in 'motherHOF.stan', line 140, column 2 to column 87)",
                                                      " (in 'motherHOF.stan', line 141, column 2 to column 87)",
                                                      " (in 'motherHOF.stan', line 143, column 2 to column 66)",
                                                      " (in 'motherHOF.stan', line 144, column 2 to column 66)",
                                                      " (in 'motherHOF.stan', line 145, column 2 to column 66)",
                                                      " (in 'motherHOF.stan', line 146, column 2 to column 66)",
                                                      " (in 'motherHOF.stan', line 148, column 2 to column 85)",
                                                      " (in 'motherHOF.stan', line 149, column 2 to column 85)",
                                                      " (in 'motherHOF.stan', line 150, column 2 to column 85)",
                                                      " (in 'motherHOF.stan', line 151, column 2 to column 85)",
                                                      " (in 'motherHOF.stan', line 153, column 2 to column 67)",
                                                      " (in 'motherHOF.stan', line 154, column 2 to column 67)",
                                                      " (in 'motherHOF.stan', line 155, column 2 to column 67)",
                                                      " (in 'motherHOF.stan', line 156, column 2 to column 67)",
                                                      " (in 'motherHOF.stan', line 158, column 2 to column 61)",
                                                      " (in 'motherHOF.stan', line 159, column 2 to column 58)",
                                                      " (in 'motherHOF.stan', line 160, column 2 to column 58)",
                                                      " (in 'motherHOF.stan', line 161, column 2 to column 60)",
                                                      " (in 'motherHOF.stan', line 163, column 2 to column 67)",
                                                      " (in 'motherHOF.stan', line 164, column 2 to column 64)",
                                                      " (in 'motherHOF.stan', line 165, column 2 to column 64)",
                                                      " (in 'motherHOF.stan', line 166, column 2 to column 66)",
                                                      " (in 'motherHOF.stan', line 168, column 2 to column 34)",
                                                      " (in 'motherHOF.stan', line 169, column 2 to column 38)",
                                                      " (in 'motherHOF.stan', line 170, column 2 to line 171, column 69)",
                                                      " (in 'motherHOF.stan', line 81, column 2 to column 18)",
                                                      " (in 'motherHOF.stan', line 82, column 2 to column 68)",
                                                      " (in 'motherHOF.stan', line 83, column 2 to column 68)",
                                                      " (in 'motherHOF.stan', line 84, column 2 to column 68)",
                                                      " (in 'motherHOF.stan', line 86, column 2 to column 87)",
                                                      " (in 'motherHOF.stan', line 87, column 2 to column 87)",
                                                      " (in 'motherHOF.stan', line 88, column 2 to column 87)",
                                                      " (in 'motherHOF.stan', line 90, column 2 to column 66)",
                                                      " (in 'motherHOF.stan', line 91, column 2 to column 66)",
                                                      " (in 'motherHOF.stan', line 92, column 2 to column 66)",
                                                      " (in 'motherHOF.stan', line 93, column 2 to column 66)",
                                                      " (in 'motherHOF.stan', line 95, column 2 to column 85)",
                                                      " (in 'motherHOF.stan', line 96, column 2 to column 85)",
                                                      " (in 'motherHOF.stan', line 97, column 2 to column 85)",
                                                      " (in 'motherHOF.stan', line 98, column 2 to column 85)",
                                                      " (in 'motherHOF.stan', line 100, column 2 to column 67)",
                                                      " (in 'motherHOF.stan', line 101, column 2 to column 67)",
                                                      " (in 'motherHOF.stan', line 102, column 2 to column 67)",
                                                      " (in 'motherHOF.stan', line 103, column 2 to column 67)",
                                                      " (in 'motherHOF.stan', line 105, column 2 to column 61)",
                                                      " (in 'motherHOF.stan', line 106, column 2 to column 58)",
                                                      " (in 'motherHOF.stan', line 107, column 2 to column 58)",
                                                      " (in 'motherHOF.stan', line 108, column 2 to column 60)",
                                                      " (in 'motherHOF.stan', line 109, column 2 to column 56)",
                                                      " (in 'motherHOF.stan', line 110, column 2 to column 58)",
                                                      " (in 'motherHOF.stan', line 111, column 2 to column 58)",
                                                      " (in 'motherHOF.stan', line 112, column 2 to column 60)",
                                                      " (in 'motherHOF.stan', line 113, column 2 to column 62)",
                                                      " (in 'motherHOF.stan', line 114, column 2 to column 62)",
                                                      " (in 'motherHOF.stan', line 115, column 2 to column 64)",
                                                      " (in 'motherHOF.stan', line 117, column 2 to column 67)",
                                                      " (in 'motherHOF.stan', line 118, column 2 to column 64)",
                                                      " (in 'motherHOF.stan', line 119, column 2 to column 64)",
                                                      " (in 'motherHOF.stan', line 120, column 2 to column 66)",
                                                      " (in 'motherHOF.stan', line 121, column 2 to column 62)",
                                                      " (in 'motherHOF.stan', line 122, column 2 to column 64)",
                                                      " (in 'motherHOF.stan', line 123, column 2 to column 64)",
                                                      " (in 'motherHOF.stan', line 124, column 2 to column 66)",
                                                      " (in 'motherHOF.stan', line 125, column 2 to column 68)",
                                                      " (in 'motherHOF.stan', line 126, column 2 to column 68)",
                                                      " (in 'motherHOF.stan', line 127, column 2 to column 70)",
                                                      " (in 'motherHOF.stan', line 129, column 2 to column 36)",
                                                      " (in 'motherHOF.stan', line 33, column 2 to column 17)",
                                                      " (in 'motherHOF.stan', line 34, column 2 to column 15)",
                                                      " (in 'motherHOF.stan', line 35, column 2 to column 10)",
                                                      " (in 'motherHOF.stan', line 36, column 2 to column 13)",
                                                      " (in 'motherHOF.stan', line 37, column 2 to column 18)",
                                                      " (in 'motherHOF.stan', line 38, column 2 to column 12)",
                                                      " (in 'motherHOF.stan', line 39, column 2 to column 15)",
                                                      " (in 'motherHOF.stan', line 40, column 2 to column 16)",
                                                      " (in 'motherHOF.stan', line 41, column 2 to column 15)",
                                                      " (in 'motherHOF.stan', line 42, column 2 to column 28)",
                                                      " (in 'motherHOF.stan', line 43, column 2 to column 28)",
                                                      " (in 'motherHOF.stan', line 44, column 2 to column 20)",
                                                      " (in 'motherHOF.stan', line 45, column 2 to column 19)",
                                                      " (in 'motherHOF.stan', line 7, column 4 to column 17)",
                                                      " (in 'motherHOF.stan', line 8, column 4 to column 19)",
                                                      " (in 'motherHOF.stan', line 9, column 4 to column 38)",
                                                      " (in 'motherHOF.stan', line 10, column 4 to column 16)",
                                                      " (in 'motherHOF.stan', line 6, column 26 to line 11, column 3)",
                                                      " (in 'motherHOF.stan', line 13, column 4 to column 15)",
                                                      " (in 'motherHOF.stan', line 12, column 71 to line 14, column 3)",
                                                      " (in 'motherHOF.stan', line 17, column 4 to column 22)",
                                                      " (in 'motherHOF.stan', line 16, column 42 to line 18, column 3)",
                                                      " (in 'motherHOF.stan', line 20, column 4 to column 17)",
                                                      " (in 'motherHOF.stan', line 19, column 28 to line 21, column 3)",
                                                      " (in 'motherHOF.stan', line 26, column 4 to column 18)",
                                                      " (in 'motherHOF.stan', line 27, column 4 to column 25)",
                                                      " (in 'motherHOF.stan', line 28, column 4 to column 25)",
                                                      " (in 'motherHOF.stan', line 29, column 4 to column 15)",
                                                      " (in 'motherHOF.stan', line 25, column 39 to line 30, column 3)"};


template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<stan::promote_args_t<T0__, T1__, T2__,
T3__>>
sho(const T0__& t, const std::vector<T1__>& y,
    const std::vector<T2__>& theta, const std::vector<T3__>& x,
    const std::vector<int>& x_int, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 112;
    validate_non_negative_index("dydt", "2", 2);
    std::vector<local_scalar_t__> dydt;
    dydt = std::vector<local_scalar_t__>(2, DUMMY_VAR__);
    
    current_statement__ = 113;
    assign(dydt, cons_list(index_uni(1), nil_index_list()),
      rvalue(y, cons_list(index_uni(2), nil_index_list()), "y"),
      "assigning variable dydt");
    current_statement__ = 114;
    assign(dydt, cons_list(index_uni(2), nil_index_list()),
      (-rvalue(y, cons_list(index_uni(1), nil_index_list()), "y") -
        (rvalue(theta, cons_list(index_uni(1), nil_index_list()), "theta") *
          rvalue(y, cons_list(index_uni(2), nil_index_list()), "y"))),
      "assigning variable dydt");
    current_statement__ = 115;
    return dydt;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct sho_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<stan::promote_args_t<T0__, T1__, T2__,
T3__>>
operator()(const T0__& t, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x,
           const std::vector<int>& x_int, std::ostream* pstream__)  const 
{
return sho(t, y, theta, x, x_int, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
stan::promote_args_t<T0__, T1__, T2__,
T3__>
integrand(const T0__& x, const T1__& xc, const std::vector<T2__>& theta,
          const std::vector<T3__>& x_r, const std::vector<int>& x_i,
          std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 117;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct integrand_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__>
stan::promote_args_t<T0__, T1__, T2__,
T3__>
operator()(const T0__& x, const T1__& xc, const std::vector<T2__>& theta,
           const std::vector<T3__>& x_r, const std::vector<int>& x_i,
           std::ostream* pstream__)  const 
{
return integrand(x, xc, theta, x_r, x_i, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<T0__, T1__,
T2__>, -1, 1>
foo(const Eigen::Matrix<T0__, -1, 1>& shared_params,
    const Eigen::Matrix<T1__, -1, 1>& job_params,
    const std::vector<T2__>& data_r, const std::vector<int>& data_i,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 119;
    return transpose(stan::math::to_row_vector(
             stan::math::array_builder<int>().add(1).add(2).add(3).array()));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_functor__ {
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<T0__, T1__,
T2__>, -1, 1>
operator()(const Eigen::Matrix<T0__, -1, 1>& shared_params,
           const Eigen::Matrix<T1__, -1, 1>& job_params,
           const std::vector<T2__>& data_r, const std::vector<int>& data_i,
           std::ostream* pstream__)  const 
{
return foo(shared_params, job_params, data_r, data_i, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
map_rectfake(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 121;
    return (2 * x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct map_rectfake_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return map_rectfake(x, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<T0__, T1__,
T2__>, -1, 1>
algebra_system(const Eigen::Matrix<T0__, -1, 1>& x,
               const Eigen::Matrix<T1__, -1, 1>& y,
               const std::vector<T2__>& dat, const std::vector<int>& dat_int,
               std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 123;
    validate_non_negative_index("f_x", "2", 2);
    Eigen::Matrix<local_scalar_t__, -1, 1> f_x;
    f_x = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
    stan::math::fill(f_x, DUMMY_VAR__);
    
    current_statement__ = 124;
    assign(f_x, cons_list(index_uni(1), nil_index_list()),
      (rvalue(x, cons_list(index_uni(1), nil_index_list()), "x") -
        rvalue(y, cons_list(index_uni(1), nil_index_list()), "y")),
      "assigning variable f_x");
    current_statement__ = 125;
    assign(f_x, cons_list(index_uni(2), nil_index_list()),
      (rvalue(x, cons_list(index_uni(2), nil_index_list()), "x") -
        rvalue(y, cons_list(index_uni(2), nil_index_list()), "y")),
      "assigning variable f_x");
    current_statement__ = 126;
    return f_x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct algebra_system_functor__ {
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<T0__, T1__,
T2__>, -1, 1>
operator()(const Eigen::Matrix<T0__, -1, 1>& x,
           const Eigen::Matrix<T1__, -1, 1>& y, const std::vector<T2__>& dat,
           const std::vector<int>& dat_int, std::ostream* pstream__)  const 
{
return algebra_system(x, y, dat, dat_int, pstream__);
}
};

class motherHOF_model : public model_base_crtp<motherHOF_model> {

 private:
  int pos__;
  int T;
  std::vector<double> y0_d;
  double t0;
  std::vector<double> ts;
  std::vector<double> theta_d;
  std::vector<double> x;
  std::vector<int> x_int;
  std::vector<double> x_d_r;
  std::vector<int> x_d_i;
  Eigen::Matrix<double, -1, 1> shared_params_d;
  std::vector<Eigen::Matrix<double, -1, 1>> job_params_d;
  std::vector<std::vector<double>> data_r;
  std::vector<std::vector<int>> data_i;
 
 public:
  ~motherHOF_model() { }
  
  std::string model_name() const { return "motherHOF_model"; }
  
  motherHOF_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "motherHOF_model_namespace::motherHOF_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      context__.validate_dims("data initialization","T","int",
          context__.to_vec());
      T = std::numeric_limits<int>::min();
      
      current_statement__ = 99;
      T = context__.vals_i("T")[(1 - 1)];
      current_statement__ = 100;
      validate_non_negative_index("y0_d", "2", 2);
      context__.validate_dims("data initialization","y0_d","double",
          context__.to_vec(2));
      y0_d = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 100;
      assign(y0_d, nil_index_list(), context__.vals_r("y0_d"),
        "assigning variable y0_d");
      context__.validate_dims("data initialization","t0","double",
          context__.to_vec());
      t0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 101;
      t0 = context__.vals_r("t0")[(1 - 1)];
      current_statement__ = 102;
      validate_non_negative_index("ts", "T", T);
      context__.validate_dims("data initialization","ts","double",
          context__.to_vec(T));
      ts = std::vector<double>(T, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 102;
      assign(ts, nil_index_list(), context__.vals_r("ts"),
        "assigning variable ts");
      current_statement__ = 103;
      validate_non_negative_index("theta_d", "1", 1);
      context__.validate_dims("data initialization","theta_d","double",
          context__.to_vec(1));
      theta_d = std::vector<double>(1, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 103;
      assign(theta_d, nil_index_list(), context__.vals_r("theta_d"),
        "assigning variable theta_d");
      current_statement__ = 104;
      validate_non_negative_index("x", "0", 0);
      context__.validate_dims("data initialization","x","double",
          context__.to_vec(0));
      x = std::vector<double>(0, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 104;
      assign(x, nil_index_list(), context__.vals_r("x"),
        "assigning variable x");
      current_statement__ = 105;
      validate_non_negative_index("x_int", "0", 0);
      context__.validate_dims("data initialization","x_int","int",
          context__.to_vec(0));
      x_int = std::vector<int>(0, std::numeric_limits<int>::min());
      
      current_statement__ = 105;
      assign(x_int, nil_index_list(), context__.vals_i("x_int"),
        "assigning variable x_int");
      current_statement__ = 106;
      validate_non_negative_index("x_d_r", "0", 0);
      context__.validate_dims("data initialization","x_d_r","double",
          context__.to_vec(0));
      x_d_r = std::vector<double>(0, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 106;
      assign(x_d_r, nil_index_list(), context__.vals_r("x_d_r"),
        "assigning variable x_d_r");
      current_statement__ = 107;
      validate_non_negative_index("x_d_i", "0", 0);
      context__.validate_dims("data initialization","x_d_i","int",
          context__.to_vec(0));
      x_d_i = std::vector<int>(0, std::numeric_limits<int>::min());
      
      current_statement__ = 107;
      assign(x_d_i, nil_index_list(), context__.vals_i("x_d_i"),
        "assigning variable x_d_i");
      current_statement__ = 108;
      validate_non_negative_index("shared_params_d", "3", 3);
      context__.validate_dims("data initialization","shared_params_d",
          "double",context__.to_vec(3));
      shared_params_d = Eigen::Matrix<double, -1, 1>(3);
      stan::math::fill(shared_params_d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> shared_params_d_flat__;
        current_statement__ = 108;
        assign(shared_params_d_flat__, nil_index_list(),
          context__.vals_r("shared_params_d"),
          "assigning variable shared_params_d_flat__");
        current_statement__ = 108;
        pos__ = 1;
        current_statement__ = 108;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 108;
          assign(shared_params_d,
            cons_list(index_uni(sym1__), nil_index_list()),
            shared_params_d_flat__[(pos__ - 1)],
            "assigning variable shared_params_d");
          current_statement__ = 108;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 109;
      validate_non_negative_index("job_params_d", "3", 3);
      current_statement__ = 109;
      validate_non_negative_index("job_params_d", "3", 3);
      context__.validate_dims("data initialization","job_params_d","double",
          context__.to_vec(3, 3));
      job_params_d = std::vector<Eigen::Matrix<double, -1, 1>>(3, Eigen::Matrix<double, -1, 1>(3));
      stan::math::fill(job_params_d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> job_params_d_flat__;
        current_statement__ = 109;
        assign(job_params_d_flat__, nil_index_list(),
          context__.vals_r("job_params_d"),
          "assigning variable job_params_d_flat__");
        current_statement__ = 109;
        pos__ = 1;
        current_statement__ = 109;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 109;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 109;
            assign(job_params_d,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              job_params_d_flat__[(pos__ - 1)],
              "assigning variable job_params_d");
            current_statement__ = 109;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 110;
      validate_non_negative_index("data_r", "3", 3);
      current_statement__ = 110;
      validate_non_negative_index("data_r", "3", 3);
      context__.validate_dims("data initialization","data_r","double",
          context__.to_vec(3, 3));
      data_r = std::vector<std::vector<double>>(3, std::vector<double>(3, std::numeric_limits<double>::quiet_NaN()));
      
      {
        std::vector<local_scalar_t__> data_r_flat__;
        current_statement__ = 110;
        assign(data_r_flat__, nil_index_list(), context__.vals_r("data_r"),
          "assigning variable data_r_flat__");
        current_statement__ = 110;
        pos__ = 1;
        current_statement__ = 110;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 110;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 110;
            assign(data_r,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              data_r_flat__[(pos__ - 1)], "assigning variable data_r");
            current_statement__ = 110;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 111;
      validate_non_negative_index("data_i", "3", 3);
      current_statement__ = 111;
      validate_non_negative_index("data_i", "3", 3);
      context__.validate_dims("data initialization","data_i","int",
          context__.to_vec(3, 3));
      data_i = std::vector<std::vector<int>>(3, std::vector<int>(3, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> data_i_flat__;
        current_statement__ = 111;
        assign(data_i_flat__, nil_index_list(), context__.vals_i("data_i"),
          "assigning variable data_i_flat__");
        current_statement__ = 111;
        pos__ = 1;
        current_statement__ = 111;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 111;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 111;
            assign(data_i,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              data_i_flat__[(pos__ - 1)], "assigning variable data_i");
            current_statement__ = 111;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 99;
      current_statement__ = 99;
      check_greater_or_equal(function__, "T", T, 1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      current_statement__ = 1;
      validate_non_negative_index("y0_p", "2", 2);
      num_params_r__ += 2;
      current_statement__ = 2;
      validate_non_negative_index("theta_p", "1", 1);
      num_params_r__ += 1;
      current_statement__ = 3;
      validate_non_negative_index("x_p", "1", 1);
      num_params_r__ += 1;
      current_statement__ = 4;
      validate_non_negative_index("x_p_v", "2", 2);
      num_params_r__ += 2;
      current_statement__ = 5;
      validate_non_negative_index("shared_params_p", "3", 3);
      num_params_r__ += 3;
      current_statement__ = 6;
      validate_non_negative_index("job_params_p", "3", 3);
      current_statement__ = 6;
      validate_non_negative_index("job_params_p", "3", 3);
      num_params_r__ += 3 * 3;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  inline T__ log_prob(std::vector<T__>& params_r__,
                      std::vector<int>& params_i__,
                      std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "motherHOF_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      current_statement__ = 1;
      validate_non_negative_index("y0_p", "2", 2);
      std::vector<local_scalar_t__> y0_p;
      y0_p = std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 1;
        assign(y0_p, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable y0_p");}
      current_statement__ = 2;
      validate_non_negative_index("theta_p", "1", 1);
      std::vector<local_scalar_t__> theta_p;
      theta_p = std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        current_statement__ = 2;
        assign(theta_p, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable theta_p");}
      current_statement__ = 3;
      validate_non_negative_index("x_p", "1", 1);
      std::vector<local_scalar_t__> x_p;
      x_p = std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        current_statement__ = 3;
        assign(x_p, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable x_p");}
      current_statement__ = 4;
      validate_non_negative_index("x_p_v", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> x_p_v;
      x_p_v = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(x_p_v, DUMMY_VAR__);
      
      current_statement__ = 4;
      x_p_v = in__.vector(2);
      current_statement__ = 5;
      validate_non_negative_index("shared_params_p", "3", 3);
      Eigen::Matrix<local_scalar_t__, -1, 1> shared_params_p;
      shared_params_p = Eigen::Matrix<local_scalar_t__, -1, 1>(3);
      stan::math::fill(shared_params_p, DUMMY_VAR__);
      
      current_statement__ = 5;
      shared_params_p = in__.vector(3);
      current_statement__ = 6;
      validate_non_negative_index("job_params_p", "3", 3);
      current_statement__ = 6;
      validate_non_negative_index("job_params_p", "3", 3);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> job_params_p;
      job_params_p = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(3, Eigen::Matrix<local_scalar_t__, -1, 1>(3));
      stan::math::fill(job_params_p, DUMMY_VAR__);
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        current_statement__ = 6;
        assign(job_params_p, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(3), "assigning variable job_params_p");}
      local_scalar_t__ x_r;
      x_r = DUMMY_VAR__;
      
      current_statement__ = 7;
      x_r = in__.scalar();
      local_scalar_t__ abc1_p;
      abc1_p = DUMMY_VAR__;
      
      current_statement__ = 8;
      abc1_p = 3;
      local_scalar_t__ abc2_p;
      abc2_p = DUMMY_VAR__;
      
      current_statement__ = 9;
      abc2_p = map_rectfake(abc1_p, pstream__);
      local_scalar_t__ abc3_p;
      abc3_p = DUMMY_VAR__;
      
      current_statement__ = 10;
      abc3_p = map_rectfake(12, pstream__);
      current_statement__ = 11;
      validate_non_negative_index("y_hat_tp1", "3", 3);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat_tp1;
      y_hat_tp1 = Eigen::Matrix<local_scalar_t__, -1, 1>(3);
      stan::math::fill(y_hat_tp1, DUMMY_VAR__);
      
      current_statement__ = 11;
      assign(y_hat_tp1, nil_index_list(),
        map_rect<1, foo_functor__>(shared_params_p, job_params_d, data_r,
          data_i, pstream__), "assigning variable y_hat_tp1");
      current_statement__ = 12;
      validate_non_negative_index("y_hat_tp2", "3", 3);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat_tp2;
      y_hat_tp2 = Eigen::Matrix<local_scalar_t__, -1, 1>(3);
      stan::math::fill(y_hat_tp2, DUMMY_VAR__);
      
      current_statement__ = 12;
      assign(y_hat_tp2, nil_index_list(),
        map_rect<2, foo_functor__>(shared_params_d, job_params_p, data_r,
          data_i, pstream__), "assigning variable y_hat_tp2");
      current_statement__ = 13;
      validate_non_negative_index("y_hat_tp3", "3", 3);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat_tp3;
      y_hat_tp3 = Eigen::Matrix<local_scalar_t__, -1, 1>(3);
      stan::math::fill(y_hat_tp3, DUMMY_VAR__);
      
      current_statement__ = 13;
      assign(y_hat_tp3, nil_index_list(),
        map_rect<3, foo_functor__>(shared_params_p, job_params_d, data_r,
          data_i, pstream__), "assigning variable y_hat_tp3");
      current_statement__ = 14;
      validate_non_negative_index("theta_p_as", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> theta_p_as;
      theta_p_as = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(theta_p_as, DUMMY_VAR__);
      
      current_statement__ = 15;
      validate_non_negative_index("x_v", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> x_v;
      x_v = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(x_v, DUMMY_VAR__);
      
      current_statement__ = 16;
      validate_non_negative_index("y_v", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_v;
      y_v = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(y_v, DUMMY_VAR__);
      
      current_statement__ = 17;
      validate_non_negative_index("y_p", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_p;
      y_p = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(y_p, DUMMY_VAR__);
      
      current_statement__ = 18;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_v, y_v, x_d_r, x_d_i,
          pstream__), "assigning variable theta_p_as");
      current_statement__ = 19;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_v, y_v, x_d_r, x_d_i,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p_as");
      current_statement__ = 20;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_v, y_p, x_d_r, x_d_i,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p_as");
      current_statement__ = 21;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p_v, y_v, x_d_r, x_d_i,
          pstream__), "assigning variable theta_p_as");
      current_statement__ = 22;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p_v, y_v, x_d_r, x_d_i,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p_as");
      current_statement__ = 23;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p_v, y_p, x_d_r, x_d_i,
          pstream__), "assigning variable theta_p_as");
      current_statement__ = 24;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p_v, y_p, x_d_r, x_d_i,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p_as");
      {
        current_statement__ = 57;
        validate_non_negative_index("y_hat", "T", T);
        current_statement__ = 57;
        validate_non_negative_index("y_hat", "2", 2);
        std::vector<std::vector<local_scalar_t__>> y_hat;
        y_hat = std::vector<std::vector<local_scalar_t__>>(T, std::vector<local_scalar_t__>(2, DUMMY_VAR__));
        
        current_statement__ = 58;
        assign(y_hat, nil_index_list(),
          integrate_ode_adams(sho_functor__(), y0_d, t0, ts, theta_p, x,
            x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 59;
        assign(y_hat, nil_index_list(),
          integrate_ode_adams(sho_functor__(), y0_p, t0, ts, theta_d, x,
            x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 60;
        assign(y_hat, nil_index_list(),
          integrate_ode_adams(sho_functor__(), y0_p, t0, ts, theta_p, x,
            x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 61;
        assign(y_hat, nil_index_list(),
          integrate_ode_adams(sho_functor__(), y0_d, t0, ts, theta_p, x,
            x_int, pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
        current_statement__ = 62;
        assign(y_hat, nil_index_list(),
          integrate_ode_adams(sho_functor__(), y0_p, t0, ts, theta_d, x,
            x_int, pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
        current_statement__ = 63;
        assign(y_hat, nil_index_list(),
          integrate_ode_adams(sho_functor__(), y0_p, t0, ts, theta_p, x,
            x_int, pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
        current_statement__ = 64;
        assign(y_hat, nil_index_list(),
          integrate_ode_bdf(sho_functor__(), y0_d, t0, ts, theta_d, x, x_int,
            pstream__), "assigning variable y_hat");
        current_statement__ = 65;
        assign(y_hat, nil_index_list(),
          integrate_ode_bdf(sho_functor__(), y0_d, t0, ts, theta_p, x, x_int,
            pstream__), "assigning variable y_hat");
        current_statement__ = 66;
        assign(y_hat, nil_index_list(),
          integrate_ode_bdf(sho_functor__(), y0_p, t0, ts, theta_d, x, x_int,
            pstream__), "assigning variable y_hat");
        current_statement__ = 67;
        assign(y_hat, nil_index_list(),
          integrate_ode_bdf(sho_functor__(), y0_p, t0, ts, theta_p, x, x_int,
            pstream__), "assigning variable y_hat");
        current_statement__ = 68;
        assign(y_hat, nil_index_list(),
          integrate_ode_bdf(sho_functor__(), y0_d, t0, ts, theta_d, x, x_int,
            pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
        current_statement__ = 69;
        assign(y_hat, nil_index_list(),
          integrate_ode_bdf(sho_functor__(), y0_d, t0, ts, theta_p, x, x_int,
            pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
        current_statement__ = 70;
        assign(y_hat, nil_index_list(),
          integrate_ode_bdf(sho_functor__(), y0_p, t0, ts, theta_d, x, x_int,
            pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
        current_statement__ = 71;
        assign(y_hat, nil_index_list(),
          integrate_ode_bdf(sho_functor__(), y0_p, t0, ts, theta_p, x, x_int,
            pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
        current_statement__ = 72;
        assign(y_hat, nil_index_list(),
          integrate_ode_rk45(sho_functor__(), y0_d, t0, ts, theta_d, x,
            x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 73;
        assign(y_hat, nil_index_list(),
          integrate_ode_rk45(sho_functor__(), y0_d, t0, ts, theta_p, x,
            x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 74;
        assign(y_hat, nil_index_list(),
          integrate_ode_rk45(sho_functor__(), y0_p, t0, ts, theta_d, x,
            x_int, pstream__), "assigning variable y_hat");
        current_statement__ = 75;
        assign(y_hat, nil_index_list(),
          integrate_ode_rk45(sho_functor__(), y0_p, t0, ts, theta_p, x,
            x_int, pstream__), "assigning variable y_hat");
        local_scalar_t__ y_1d;
        y_1d = DUMMY_VAR__;
        
        current_statement__ = 76;
        y_1d = integrate_1d(integrand_functor__(), 0, 1, x, x_d_r, x_d_i,
                 pstream__);
        current_statement__ = 77;
        y_1d = integrate_1d(integrand_functor__(), 0.0, 1, x, x_d_r, x_d_i,
                 pstream__);
        current_statement__ = 78;
        y_1d = integrate_1d(integrand_functor__(), 0, 1.0, x, x_d_r, x_d_i,
                 pstream__);
        current_statement__ = 79;
        y_1d = integrate_1d(integrand_functor__(), 0.0, 1.0, x, x_d_r, x_d_i,
                 pstream__);
        current_statement__ = 80;
        y_1d = integrate_1d(integrand_functor__(), 0, 1, x, x_d_r, x_d_i,
                 pstream__);
        current_statement__ = 81;
        y_1d = integrate_1d(integrand_functor__(), x_r, 1, x, x_d_r, x_d_i,
                 pstream__);
        current_statement__ = 82;
        y_1d = integrate_1d(integrand_functor__(), 0, x_r, x, x_d_r, x_d_i,
                 pstream__);
        current_statement__ = 83;
        y_1d = integrate_1d(integrand_functor__(), x_r, x_r, x, x_d_r, x_d_i,
                 pstream__);
        current_statement__ = 84;
        y_1d = integrate_1d(integrand_functor__(), x_r, 1, x_d_r, x_d_r,
                 x_d_i, pstream__);
        current_statement__ = 85;
        y_1d = integrate_1d(integrand_functor__(), 0, x_r, x_d_r, x_d_r,
                 x_d_i, pstream__);
        current_statement__ = 86;
        y_1d = integrate_1d(integrand_functor__(), x_r, x_r, x_d_r, x_d_r,
                 x_d_i, pstream__);
        local_scalar_t__ z_1d;
        z_1d = DUMMY_VAR__;
        
        current_statement__ = 87;
        z_1d = integrate_1d(integrand_functor__(), 0, 1, x, x_d_r, x_d_i,
                 pstream__, 1e-8);
        current_statement__ = 88;
        z_1d = integrate_1d(integrand_functor__(), 0.0, 1, x, x_d_r, x_d_i,
                 pstream__, 1e-8);
        current_statement__ = 89;
        z_1d = integrate_1d(integrand_functor__(), 0, 1.0, x, x_d_r, x_d_i,
                 pstream__, 1e-8);
        current_statement__ = 90;
        z_1d = integrate_1d(integrand_functor__(), 0.0, 1.0, x, x_d_r, x_d_i,
                 pstream__, 1e-8);
        current_statement__ = 91;
        z_1d = integrate_1d(integrand_functor__(), 0, 1, x, x_d_r, x_d_i,
                 pstream__, 1e-8);
        current_statement__ = 92;
        z_1d = integrate_1d(integrand_functor__(), x_r, 1, x, x_d_r, x_d_i,
                 pstream__, 1e-8);
        current_statement__ = 93;
        z_1d = integrate_1d(integrand_functor__(), 0, x_r, x, x_d_r, x_d_i,
                 pstream__, 1e-8);
        current_statement__ = 94;
        z_1d = integrate_1d(integrand_functor__(), x_r, x_r, x, x_d_r, x_d_i,
                 pstream__, 1e-8);
        current_statement__ = 95;
        z_1d = integrate_1d(integrand_functor__(), x_r, 1, x_d_r, x_d_r,
                 x_d_i, pstream__, 1e-8);
        current_statement__ = 96;
        z_1d = integrate_1d(integrand_functor__(), 0, x_r, x_d_r, x_d_r,
                 x_d_i, pstream__, 1e-8);
        current_statement__ = 97;
        z_1d = integrate_1d(integrand_functor__(), x_r, x_r, x_d_r, x_d_r,
                 x_d_i, pstream__, 1e-8);
        local_scalar_t__ abc_m;
        abc_m = DUMMY_VAR__;
        
        current_statement__ = 98;
        abc_m = map_rectfake(abc1_p, pstream__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  inline void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                          std::vector<int>& params_i__,
                          std::vector<double>& vars__,
                          bool emit_transformed_parameters__ = true,
                          bool emit_generated_quantities__ = true,
                          std::ostream* pstream__ = 0) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "motherHOF_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      current_statement__ = 1;
      validate_non_negative_index("y0_p", "2", 2);
      std::vector<double> y0_p;
      y0_p = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 1;
        assign(y0_p, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable y0_p");}
      current_statement__ = 2;
      validate_non_negative_index("theta_p", "1", 1);
      std::vector<double> theta_p;
      theta_p = std::vector<double>(1, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        current_statement__ = 2;
        assign(theta_p, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable theta_p");}
      current_statement__ = 3;
      validate_non_negative_index("x_p", "1", 1);
      std::vector<double> x_p;
      x_p = std::vector<double>(1, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        current_statement__ = 3;
        assign(x_p, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable x_p");}
      current_statement__ = 4;
      validate_non_negative_index("x_p_v", "2", 2);
      Eigen::Matrix<double, -1, 1> x_p_v;
      x_p_v = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(x_p_v, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      x_p_v = in__.vector(2);
      current_statement__ = 5;
      validate_non_negative_index("shared_params_p", "3", 3);
      Eigen::Matrix<double, -1, 1> shared_params_p;
      shared_params_p = Eigen::Matrix<double, -1, 1>(3);
      stan::math::fill(shared_params_p, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      shared_params_p = in__.vector(3);
      current_statement__ = 6;
      validate_non_negative_index("job_params_p", "3", 3);
      current_statement__ = 6;
      validate_non_negative_index("job_params_p", "3", 3);
      std::vector<Eigen::Matrix<double, -1, 1>> job_params_p;
      job_params_p = std::vector<Eigen::Matrix<double, -1, 1>>(3, Eigen::Matrix<double, -1, 1>(3));
      stan::math::fill(job_params_p, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        current_statement__ = 6;
        assign(job_params_p, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(3), "assigning variable job_params_p");}
      double x_r;
      x_r = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      x_r = in__.scalar();
      double abc1_p;
      abc1_p = std::numeric_limits<double>::quiet_NaN();
      
      double abc2_p;
      abc2_p = std::numeric_limits<double>::quiet_NaN();
      
      double abc3_p;
      abc3_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      validate_non_negative_index("y_hat_tp1", "3", 3);
      Eigen::Matrix<double, -1, 1> y_hat_tp1;
      y_hat_tp1 = Eigen::Matrix<double, -1, 1>(3);
      stan::math::fill(y_hat_tp1, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 12;
      validate_non_negative_index("y_hat_tp2", "3", 3);
      Eigen::Matrix<double, -1, 1> y_hat_tp2;
      y_hat_tp2 = Eigen::Matrix<double, -1, 1>(3);
      stan::math::fill(y_hat_tp2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 13;
      validate_non_negative_index("y_hat_tp3", "3", 3);
      Eigen::Matrix<double, -1, 1> y_hat_tp3;
      y_hat_tp3 = Eigen::Matrix<double, -1, 1>(3);
      stan::math::fill(y_hat_tp3, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 14;
      validate_non_negative_index("theta_p_as", "2", 2);
      Eigen::Matrix<double, -1, 1> theta_p_as;
      theta_p_as = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(theta_p_as, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 15;
      validate_non_negative_index("x_v", "2", 2);
      Eigen::Matrix<double, -1, 1> x_v;
      x_v = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(x_v, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 16;
      validate_non_negative_index("y_v", "2", 2);
      Eigen::Matrix<double, -1, 1> y_v;
      y_v = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(y_v, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 17;
      validate_non_negative_index("y_p", "2", 2);
      Eigen::Matrix<double, -1, 1> y_p;
      y_p = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(y_p, std::numeric_limits<double>::quiet_NaN());
      
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(y0_p[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        vars__.push_back(theta_p[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        vars__.push_back(x_p[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(x_p_v[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        vars__.push_back(shared_params_p[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          vars__.push_back(job_params_p[(sym2__ - 1)][(sym1__ - 1)]);}}
      vars__.push_back(x_r);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 8;
      abc1_p = 3;
      current_statement__ = 9;
      abc2_p = map_rectfake(abc1_p, pstream__);
      current_statement__ = 10;
      abc3_p = map_rectfake(12, pstream__);
      current_statement__ = 11;
      assign(y_hat_tp1, nil_index_list(),
        map_rect<4, foo_functor__>(shared_params_p, job_params_d, data_r,
          data_i, pstream__), "assigning variable y_hat_tp1");
      current_statement__ = 12;
      assign(y_hat_tp2, nil_index_list(),
        map_rect<5, foo_functor__>(shared_params_d, job_params_p, data_r,
          data_i, pstream__), "assigning variable y_hat_tp2");
      current_statement__ = 13;
      assign(y_hat_tp3, nil_index_list(),
        map_rect<6, foo_functor__>(shared_params_p, job_params_d, data_r,
          data_i, pstream__), "assigning variable y_hat_tp3");
      current_statement__ = 18;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_v, y_v, x_d_r, x_d_i,
          pstream__), "assigning variable theta_p_as");
      current_statement__ = 19;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_v, y_v, x_d_r, x_d_i,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p_as");
      current_statement__ = 20;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_v, y_p, x_d_r, x_d_i,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p_as");
      current_statement__ = 21;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p_v, y_v, x_d_r, x_d_i,
          pstream__), "assigning variable theta_p_as");
      current_statement__ = 22;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p_v, y_v, x_d_r, x_d_i,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p_as");
      current_statement__ = 23;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p_v, y_p, x_d_r, x_d_i,
          pstream__), "assigning variable theta_p_as");
      current_statement__ = 24;
      assign(theta_p_as, nil_index_list(),
        algebra_solver(algebra_system_functor__(), x_p_v, y_p, x_d_r, x_d_i,
          pstream__, 0.01, 0.01, 10), "assigning variable theta_p_as");
      vars__.push_back(abc1_p);
      vars__.push_back(abc2_p);
      vars__.push_back(abc3_p);
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        vars__.push_back(y_hat_tp1[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        vars__.push_back(y_hat_tp2[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        vars__.push_back(y_hat_tp3[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(theta_p_as[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(x_v[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(y_v[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(y_p[(sym1__ - 1)]);}
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      current_statement__ = 25;
      validate_non_negative_index("y_hat", "T", T);
      current_statement__ = 25;
      validate_non_negative_index("y_hat", "2", 2);
      std::vector<std::vector<double>> y_hat;
      y_hat = std::vector<std::vector<double>>(T, std::vector<double>(2, std::numeric_limits<double>::quiet_NaN()));
      
      current_statement__ = 26;
      assign(y_hat, nil_index_list(),
        integrate_ode_adams(sho_functor__(), y0_d, t0, ts, theta_d, x, x_int,
          pstream__), "assigning variable y_hat");
      current_statement__ = 27;
      assign(y_hat, nil_index_list(),
        integrate_ode_adams(sho_functor__(), y0_d, t0, ts, theta_p, x, x_int,
          pstream__), "assigning variable y_hat");
      current_statement__ = 28;
      assign(y_hat, nil_index_list(),
        integrate_ode_adams(sho_functor__(), y0_p, t0, ts, theta_d, x, x_int,
          pstream__), "assigning variable y_hat");
      current_statement__ = 29;
      assign(y_hat, nil_index_list(),
        integrate_ode_adams(sho_functor__(), y0_p, t0, ts, theta_p, x, x_int,
          pstream__), "assigning variable y_hat");
      current_statement__ = 30;
      assign(y_hat, nil_index_list(),
        integrate_ode_adams(sho_functor__(), y0_d, t0, ts, theta_d, x, x_int,
          pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
      current_statement__ = 31;
      assign(y_hat, nil_index_list(),
        integrate_ode_adams(sho_functor__(), y0_d, t0, ts, theta_p, x, x_int,
          pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
      current_statement__ = 32;
      assign(y_hat, nil_index_list(),
        integrate_ode_adams(sho_functor__(), y0_p, t0, ts, theta_d, x, x_int,
          pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
      current_statement__ = 33;
      assign(y_hat, nil_index_list(),
        integrate_ode_adams(sho_functor__(), y0_p, t0, ts, theta_p, x, x_int,
          pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
      current_statement__ = 34;
      assign(y_hat, nil_index_list(),
        integrate_ode_bdf(sho_functor__(), y0_d, t0, ts, theta_d, x, x_int,
          pstream__), "assigning variable y_hat");
      current_statement__ = 35;
      assign(y_hat, nil_index_list(),
        integrate_ode_bdf(sho_functor__(), y0_d, t0, ts, theta_p, x, x_int,
          pstream__), "assigning variable y_hat");
      current_statement__ = 36;
      assign(y_hat, nil_index_list(),
        integrate_ode_bdf(sho_functor__(), y0_p, t0, ts, theta_d, x, x_int,
          pstream__), "assigning variable y_hat");
      current_statement__ = 37;
      assign(y_hat, nil_index_list(),
        integrate_ode_bdf(sho_functor__(), y0_p, t0, ts, theta_p, x, x_int,
          pstream__), "assigning variable y_hat");
      current_statement__ = 38;
      assign(y_hat, nil_index_list(),
        integrate_ode_bdf(sho_functor__(), y0_d, t0, ts, theta_d, x, x_int,
          pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
      current_statement__ = 39;
      assign(y_hat, nil_index_list(),
        integrate_ode_bdf(sho_functor__(), y0_d, t0, ts, theta_p, x, x_int,
          pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
      current_statement__ = 40;
      assign(y_hat, nil_index_list(),
        integrate_ode_bdf(sho_functor__(), y0_p, t0, ts, theta_d, x, x_int,
          pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
      current_statement__ = 41;
      assign(y_hat, nil_index_list(),
        integrate_ode_bdf(sho_functor__(), y0_p, t0, ts, theta_p, x, x_int,
          pstream__, 1e-10, 1e-10, 1e8), "assigning variable y_hat");
      current_statement__ = 42;
      assign(y_hat, nil_index_list(),
        integrate_ode_rk45(sho_functor__(), y0_d, t0, ts, theta_d, x, x_int,
          pstream__), "assigning variable y_hat");
      current_statement__ = 43;
      assign(y_hat, nil_index_list(),
        integrate_ode_rk45(sho_functor__(), y0_d, t0, ts, theta_p, x, x_int,
          pstream__), "assigning variable y_hat");
      current_statement__ = 44;
      assign(y_hat, nil_index_list(),
        integrate_ode_rk45(sho_functor__(), y0_p, t0, ts, theta_d, x, x_int,
          pstream__), "assigning variable y_hat");
      current_statement__ = 45;
      assign(y_hat, nil_index_list(),
        integrate_ode_rk45(sho_functor__(), y0_p, t0, ts, theta_p, x, x_int,
          pstream__), "assigning variable y_hat");
      double y_1d;
      y_1d = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 46;
      y_1d = integrate_1d(integrand_functor__(), 0, 1, x, x_d_r, x_d_i,
               pstream__);
      current_statement__ = 47;
      y_1d = integrate_1d(integrand_functor__(), 0.0, 1, x, x_d_r, x_d_i,
               pstream__);
      current_statement__ = 48;
      y_1d = integrate_1d(integrand_functor__(), 0, 1.0, x, x_d_r, x_d_i,
               pstream__);
      current_statement__ = 49;
      y_1d = integrate_1d(integrand_functor__(), 0.0, 1.0, x, x_d_r, x_d_i,
               pstream__);
      double z_1d;
      z_1d = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 50;
      z_1d = integrate_1d(integrand_functor__(), 0, 1, x, x_d_r, x_d_i,
               pstream__, 1e-8);
      current_statement__ = 51;
      z_1d = integrate_1d(integrand_functor__(), 0.0, 1, x, x_d_r, x_d_i,
               pstream__, 1e-8);
      current_statement__ = 52;
      z_1d = integrate_1d(integrand_functor__(), 0, 1.0, x, x_d_r, x_d_i,
               pstream__, 1e-8);
      current_statement__ = 53;
      z_1d = integrate_1d(integrand_functor__(), 0.0, 1.0, x, x_d_r, x_d_i,
               pstream__, 1e-8);
      double abc1_gq;
      abc1_gq = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 54;
      abc1_gq = map_rectfake(12, pstream__);
      double abc2_gq;
      abc2_gq = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 55;
      abc2_gq = map_rectfake(abc1_p, pstream__);
      current_statement__ = 56;
      validate_non_negative_index("y_hat_gq", "3", 3);
      Eigen::Matrix<double, -1, 1> y_hat_gq;
      y_hat_gq = Eigen::Matrix<double, -1, 1>(3);
      stan::math::fill(y_hat_gq, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 56;
      assign(y_hat_gq, nil_index_list(),
        map_rect<7, foo_functor__>(shared_params_d, job_params_d, data_r,
          data_i, pstream__), "assigning variable y_hat_gq");
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= T; ++sym2__) {
          vars__.push_back(y_hat[(sym2__ - 1)][(sym1__ - 1)]);}}
      vars__.push_back(y_1d);
      vars__.push_back(z_1d);
      vars__.push_back(abc1_gq);
      vars__.push_back(abc2_gq);
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        vars__.push_back(y_hat_gq[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  inline void transform_inits(const stan::io::var_context& context__,
                              std::vector<int>& params_i__,
                              std::vector<double>& vars__,
                              std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 1;
      validate_non_negative_index("y0_p", "2", 2);
      std::vector<double> y0_p;
      y0_p = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      assign(y0_p, nil_index_list(), context__.vals_r("y0_p"),
        "assigning variable y0_p");
      current_statement__ = 2;
      validate_non_negative_index("theta_p", "1", 1);
      std::vector<double> theta_p;
      theta_p = std::vector<double>(1, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      assign(theta_p, nil_index_list(), context__.vals_r("theta_p"),
        "assigning variable theta_p");
      current_statement__ = 3;
      validate_non_negative_index("x_p", "1", 1);
      std::vector<double> x_p;
      x_p = std::vector<double>(1, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      assign(x_p, nil_index_list(), context__.vals_r("x_p"),
        "assigning variable x_p");
      current_statement__ = 4;
      validate_non_negative_index("x_p_v", "2", 2);
      Eigen::Matrix<double, -1, 1> x_p_v;
      x_p_v = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(x_p_v, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_p_v_flat__;
        current_statement__ = 4;
        assign(x_p_v_flat__, nil_index_list(), context__.vals_r("x_p_v"),
          "assigning variable x_p_v_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 4;
          assign(x_p_v, cons_list(index_uni(sym1__), nil_index_list()),
            x_p_v_flat__[(pos__ - 1)], "assigning variable x_p_v");
          current_statement__ = 4;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 5;
      validate_non_negative_index("shared_params_p", "3", 3);
      Eigen::Matrix<double, -1, 1> shared_params_p;
      shared_params_p = Eigen::Matrix<double, -1, 1>(3);
      stan::math::fill(shared_params_p, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> shared_params_p_flat__;
        current_statement__ = 5;
        assign(shared_params_p_flat__, nil_index_list(),
          context__.vals_r("shared_params_p"),
          "assigning variable shared_params_p_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 5;
          assign(shared_params_p,
            cons_list(index_uni(sym1__), nil_index_list()),
            shared_params_p_flat__[(pos__ - 1)],
            "assigning variable shared_params_p");
          current_statement__ = 5;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 6;
      validate_non_negative_index("job_params_p", "3", 3);
      current_statement__ = 6;
      validate_non_negative_index("job_params_p", "3", 3);
      std::vector<Eigen::Matrix<double, -1, 1>> job_params_p;
      job_params_p = std::vector<Eigen::Matrix<double, -1, 1>>(3, Eigen::Matrix<double, -1, 1>(3));
      stan::math::fill(job_params_p, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> job_params_p_flat__;
        current_statement__ = 6;
        assign(job_params_p_flat__, nil_index_list(),
          context__.vals_r("job_params_p"),
          "assigning variable job_params_p_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 6;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 6;
            assign(job_params_p,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              job_params_p_flat__[(pos__ - 1)],
              "assigning variable job_params_p");
            current_statement__ = 6;
            pos__ = (pos__ + 1);}}
      }
      double x_r;
      x_r = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      x_r = context__.vals_r("x_r")[(1 - 1)];
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(y0_p[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        vars__.push_back(theta_p[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        vars__.push_back(x_p[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.push_back(x_p_v[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        vars__.push_back(shared_params_p[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          vars__.push_back(job_params_p[(sym2__ - 1)][(sym1__ - 1)]);}}
      vars__.push_back(x_r);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("y0_p");
    names__.push_back("theta_p");
    names__.push_back("x_p");
    names__.push_back("x_p_v");
    names__.push_back("shared_params_p");
    names__.push_back("job_params_p");
    names__.push_back("x_r");
    names__.push_back("abc1_p");
    names__.push_back("abc2_p");
    names__.push_back("abc3_p");
    names__.push_back("y_hat_tp1");
    names__.push_back("y_hat_tp2");
    names__.push_back("y_hat_tp3");
    names__.push_back("theta_p_as");
    names__.push_back("x_v");
    names__.push_back("y_v");
    names__.push_back("y_p");
    names__.push_back("y_hat");
    names__.push_back("y_1d");
    names__.push_back("z_1d");
    names__.push_back("abc1_gq");
    names__.push_back("abc2_gq");
    names__.push_back("y_hat_gq");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(1);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(1);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(T);
    
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const {
    
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y0_p" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      {
        param_names__.push_back(std::string() + "theta_p" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      {
        param_names__.push_back(std::string() + "x_p" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.push_back(std::string() + "x_p_v" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      {
        param_names__.push_back(std::string() + "shared_params_p" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          {
            param_names__.push_back(std::string() + "job_params_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    param_names__.push_back(std::string() + "x_r");
    if (emit_transformed_parameters__) {
      param_names__.push_back(std::string() + "abc1_p");
      param_names__.push_back(std::string() + "abc2_p");
      param_names__.push_back(std::string() + "abc3_p");
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          param_names__.push_back(std::string() + "y_hat_tp1" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          param_names__.push_back(std::string() + "y_hat_tp2" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          param_names__.push_back(std::string() + "y_hat_tp3" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          param_names__.push_back(std::string() + "theta_p_as" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          param_names__.push_back(std::string() + "x_v" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          param_names__.push_back(std::string() + "y_v" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          param_names__.push_back(std::string() + "y_p" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= T; ++sym2__) {
            {
              param_names__.push_back(std::string() + "y_hat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      param_names__.push_back(std::string() + "y_1d");
      param_names__.push_back(std::string() + "z_1d");
      param_names__.push_back(std::string() + "abc1_gq");
      param_names__.push_back(std::string() + "abc2_gq");
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          param_names__.push_back(std::string() + "y_hat_gq" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const {
    
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y0_p" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      {
        param_names__.push_back(std::string() + "theta_p" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      {
        param_names__.push_back(std::string() + "x_p" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.push_back(std::string() + "x_p_v" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      {
        param_names__.push_back(std::string() + "shared_params_p" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          {
            param_names__.push_back(std::string() + "job_params_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    param_names__.push_back(std::string() + "x_r");
    if (emit_transformed_parameters__) {
      param_names__.push_back(std::string() + "abc1_p");
      param_names__.push_back(std::string() + "abc2_p");
      param_names__.push_back(std::string() + "abc3_p");
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          param_names__.push_back(std::string() + "y_hat_tp1" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          param_names__.push_back(std::string() + "y_hat_tp2" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          param_names__.push_back(std::string() + "y_hat_tp3" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          param_names__.push_back(std::string() + "theta_p_as" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          param_names__.push_back(std::string() + "x_v" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          param_names__.push_back(std::string() + "y_v" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          param_names__.push_back(std::string() + "y_p" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= T; ++sym2__) {
            {
              param_names__.push_back(std::string() + "y_hat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      param_names__.push_back(std::string() + "y_1d");
      param_names__.push_back(std::string() + "z_1d");
      param_names__.push_back(std::string() + "abc1_gq");
      param_names__.push_back(std::string() + "abc2_gq");
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          param_names__.push_back(std::string() + "y_hat_gq" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"y0_p\",\"type\":{\"name\":\"array\",\"length\":" << 2 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta_p\",\"type\":{\"name\":\"array\",\"length\":" << 1 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_p\",\"type\":{\"name\":\"array\",\"length\":" << 1 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_p_v\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"shared_params_p\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"parameters\"},{\"name\":\"job_params_p\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 3 << "}},\"block\":\"parameters\"},{\"name\":\"x_r\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"abc1_p\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"abc2_p\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"abc3_p\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat_tp1\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat_tp2\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat_tp3\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"transformed_parameters\"},{\"name\":\"theta_p_as\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"transformed_parameters\"},{\"name\":\"x_v\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_v\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_p\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"array\",\"length\":" << T << ",\"element_type\":{\"name\":\"array\",\"length\":" << 2 << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"generated_quantities\"},{\"name\":\"y_1d\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"z_1d\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"abc1_gq\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"abc2_gq\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"y_hat_gq\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"y0_p\",\"type\":{\"name\":\"array\",\"length\":" << 2 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta_p\",\"type\":{\"name\":\"array\",\"length\":" << 1 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_p\",\"type\":{\"name\":\"array\",\"length\":" << 1 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_p_v\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"shared_params_p\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"parameters\"},{\"name\":\"job_params_p\",\"type\":{\"name\":\"array\",\"length\":" << 3 << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 3 << "}},\"block\":\"parameters\"},{\"name\":\"x_r\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"abc1_p\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"abc2_p\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"abc3_p\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat_tp1\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat_tp2\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat_tp3\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"transformed_parameters\"},{\"name\":\"theta_p_as\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"transformed_parameters\"},{\"name\":\"x_v\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_v\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_p\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"array\",\"length\":" << T << ",\"element_type\":{\"name\":\"array\",\"length\":" << 2 << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"generated_quantities\"},{\"name\":\"y_1d\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"z_1d\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"abc1_gq\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"abc2_gq\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"y_hat_gq\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef motherHOF_model_namespace::motherHOF_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif


STAN_REGISTER_MAP_RECT(1, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(2, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(3, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(4, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(5, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(6, motherHOF_model_namespace::foo_functor__)
STAN_REGISTER_MAP_RECT(7, motherHOF_model_namespace::foo_functor__)
  $ ../../../../../install/default/bin/stanc --print-cpp optimize_glm.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace optimize_glm_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'optimize_glm.stan', line 26, column 2 to column 20)",
                                                      " (in 'optimize_glm.stan', line 27, column 2 to column 17)",
                                                      " (in 'optimize_glm.stan', line 28, column 2 to column 17)",
                                                      " (in 'optimize_glm.stan', line 29, column 2 to column 22)",
                                                      " (in 'optimize_glm.stan', line 30, column 2 to column 13)",
                                                      " (in 'optimize_glm.stan', line 31, column 2 to column 11)",
                                                      " (in 'optimize_glm.stan', line 32, column 2 to column 19)",
                                                      " (in 'optimize_glm.stan', line 33, column 2 to column 22)",
                                                      " (in 'optimize_glm.stan', line 34, column 2 to column 23)",
                                                      " (in 'optimize_glm.stan', line 38, column 2 to column 64)",
                                                      " (in 'optimize_glm.stan', line 39, column 2 to column 49)",
                                                      " (in 'optimize_glm.stan', line 41, column 2 to column 64)",
                                                      " (in 'optimize_glm.stan', line 42, column 2 to column 49)",
                                                      " (in 'optimize_glm.stan', line 44, column 2 to column 63)",
                                                      " (in 'optimize_glm.stan', line 45, column 2 to column 48)",
                                                      " (in 'optimize_glm.stan', line 47, column 2 to column 63)",
                                                      " (in 'optimize_glm.stan', line 48, column 2 to column 48)",
                                                      " (in 'optimize_glm.stan', line 50, column 2 to column 66)",
                                                      " (in 'optimize_glm.stan', line 51, column 2 to column 51)",
                                                      " (in 'optimize_glm.stan', line 53, column 2 to column 66)",
                                                      " (in 'optimize_glm.stan', line 54, column 2 to column 51)",
                                                      " (in 'optimize_glm.stan', line 56, column 2 to column 70)",
                                                      " (in 'optimize_glm.stan', line 57, column 2 to column 55)",
                                                      " (in 'optimize_glm.stan', line 59, column 2 to column 67)",
                                                      " (in 'optimize_glm.stan', line 60, column 2 to column 52)",
                                                      " (in 'optimize_glm.stan', line 62, column 2 to column 69)",
                                                      " (in 'optimize_glm.stan', line 63, column 2 to column 54)",
                                                      " (in 'optimize_glm.stan', line 65, column 2 to column 66)",
                                                      " (in 'optimize_glm.stan', line 66, column 2 to column 51)",
                                                      " (in 'optimize_glm.stan', line 68, column 2 to column 72)",
                                                      " (in 'optimize_glm.stan', line 69, column 2 to column 57)",
                                                      " (in 'optimize_glm.stan', line 71, column 2 to column 69)",
                                                      " (in 'optimize_glm.stan', line 72, column 2 to column 54)",
                                                      " (in 'optimize_glm.stan', line 74, column 2 to column 63)",
                                                      " (in 'optimize_glm.stan', line 75, column 2 to column 49)",
                                                      " (in 'optimize_glm.stan', line 77, column 2 to column 63)",
                                                      " (in 'optimize_glm.stan', line 78, column 2 to column 49)",
                                                      " (in 'optimize_glm.stan', line 80, column 2 to column 66)",
                                                      " (in 'optimize_glm.stan', line 81, column 2 to column 52)",
                                                      " (in 'optimize_glm.stan', line 83, column 2 to column 66)",
                                                      " (in 'optimize_glm.stan', line 84, column 2 to column 52)",
                                                      " (in 'optimize_glm.stan', line 86, column 2 to column 62)",
                                                      " (in 'optimize_glm.stan', line 87, column 2 to column 48)",
                                                      " (in 'optimize_glm.stan', line 89, column 2 to column 62)",
                                                      " (in 'optimize_glm.stan', line 90, column 2 to column 48)",
                                                      " (in 'optimize_glm.stan', line 92, column 2 to column 69)",
                                                      " (in 'optimize_glm.stan', line 93, column 2 to column 55)",
                                                      " (in 'optimize_glm.stan', line 95, column 2 to column 66)",
                                                      " (in 'optimize_glm.stan', line 96, column 2 to column 52)",
                                                      " (in 'optimize_glm.stan', line 98, column 2 to column 72)",
                                                      " (in 'optimize_glm.stan', line 99, column 2 to column 58)",
                                                      " (in 'optimize_glm.stan', line 101, column 2 to column 69)",
                                                      " (in 'optimize_glm.stan', line 102, column 2 to column 55)",
                                                      " (in 'optimize_glm.stan', line 104, column 2 to column 68)",
                                                      " (in 'optimize_glm.stan', line 105, column 2 to column 54)",
                                                      " (in 'optimize_glm.stan', line 107, column 2 to column 65)",
                                                      " (in 'optimize_glm.stan', line 108, column 2 to column 51)",
                                                      " (in 'optimize_glm.stan', line 110, column 2 to column 59)",
                                                      " (in 'optimize_glm.stan', line 111, column 2 to column 45)",
                                                      " (in 'optimize_glm.stan', line 113, column 2 to column 59)",
                                                      " (in 'optimize_glm.stan', line 114, column 2 to column 45)",
                                                      " (in 'optimize_glm.stan', line 116, column 2 to column 58)",
                                                      " (in 'optimize_glm.stan', line 117, column 2 to column 44)",
                                                      " (in 'optimize_glm.stan', line 119, column 2 to column 58)",
                                                      " (in 'optimize_glm.stan', line 120, column 2 to column 44)",
                                                      " (in 'optimize_glm.stan', line 122, column 2 to column 62)",
                                                      " (in 'optimize_glm.stan', line 123, column 2 to column 48)",
                                                      " (in 'optimize_glm.stan', line 125, column 2 to column 62)",
                                                      " (in 'optimize_glm.stan', line 126, column 2 to column 48)",
                                                      " (in 'optimize_glm.stan', line 128, column 2 to column 65)",
                                                      " (in 'optimize_glm.stan', line 129, column 2 to column 51)",
                                                      " (in 'optimize_glm.stan', line 131, column 2 to column 62)",
                                                      " (in 'optimize_glm.stan', line 132, column 2 to column 48)",
                                                      " (in 'optimize_glm.stan', line 134, column 2 to column 64)",
                                                      " (in 'optimize_glm.stan', line 135, column 2 to column 50)",
                                                      " (in 'optimize_glm.stan', line 137, column 2 to column 61)",
                                                      " (in 'optimize_glm.stan', line 138, column 2 to column 47)",
                                                      " (in 'optimize_glm.stan', line 140, column 2 to column 68)",
                                                      " (in 'optimize_glm.stan', line 141, column 2 to column 54)",
                                                      " (in 'optimize_glm.stan', line 143, column 2 to column 65)",
                                                      " (in 'optimize_glm.stan', line 144, column 2 to column 51)",
                                                      " (in 'optimize_glm.stan', line 146, column 2 to column 71)",
                                                      " (in 'optimize_glm.stan', line 147, column 2 to column 57)",
                                                      " (in 'optimize_glm.stan', line 149, column 2 to column 71)",
                                                      " (in 'optimize_glm.stan', line 150, column 2 to column 57)",
                                                      " (in 'optimize_glm.stan', line 152, column 2 to column 70)",
                                                      " (in 'optimize_glm.stan', line 153, column 2 to column 56)",
                                                      " (in 'optimize_glm.stan', line 155, column 2 to column 70)",
                                                      " (in 'optimize_glm.stan', line 156, column 2 to column 56)",
                                                      " (in 'optimize_glm.stan', line 158, column 2 to column 74)",
                                                      " (in 'optimize_glm.stan', line 159, column 2 to column 60)",
                                                      " (in 'optimize_glm.stan', line 161, column 2 to column 74)",
                                                      " (in 'optimize_glm.stan', line 162, column 2 to column 60)",
                                                      " (in 'optimize_glm.stan', line 164, column 2 to column 77)",
                                                      " (in 'optimize_glm.stan', line 165, column 2 to column 63)",
                                                      " (in 'optimize_glm.stan', line 167, column 2 to column 74)",
                                                      " (in 'optimize_glm.stan', line 168, column 2 to column 60)",
                                                      " (in 'optimize_glm.stan', line 170, column 2 to column 76)",
                                                      " (in 'optimize_glm.stan', line 171, column 2 to column 62)",
                                                      " (in 'optimize_glm.stan', line 173, column 2 to column 73)",
                                                      " (in 'optimize_glm.stan', line 174, column 2 to column 59)",
                                                      " (in 'optimize_glm.stan', line 176, column 2 to column 80)",
                                                      " (in 'optimize_glm.stan', line 177, column 2 to column 66)",
                                                      " (in 'optimize_glm.stan', line 179, column 2 to column 77)",
                                                      " (in 'optimize_glm.stan', line 180, column 2 to column 63)",
                                                      " (in 'optimize_glm.stan', line 182, column 2 to column 62)",
                                                      " (in 'optimize_glm.stan', line 183, column 2 to column 48)",
                                                      " (in 'optimize_glm.stan', line 185, column 2 to column 62)",
                                                      " (in 'optimize_glm.stan', line 186, column 2 to column 48)",
                                                      " (in 'optimize_glm.stan', line 188, column 2 to column 68)",
                                                      " (in 'optimize_glm.stan', line 189, column 2 to column 54)",
                                                      " (in 'optimize_glm.stan', line 191, column 2 to column 65)",
                                                      " (in 'optimize_glm.stan', line 192, column 2 to column 51)",
                                                      " (in 'optimize_glm.stan', line 194, column 2 to column 62)",
                                                      " (in 'optimize_glm.stan', line 195, column 2 to column 48)",
                                                      " (in 'optimize_glm.stan', line 197, column 2 to column 62)",
                                                      " (in 'optimize_glm.stan', line 198, column 2 to column 48)",
                                                      " (in 'optimize_glm.stan', line 200, column 2 to column 68)",
                                                      " (in 'optimize_glm.stan', line 201, column 2 to column 54)",
                                                      " (in 'optimize_glm.stan', line 203, column 2 to column 65)",
                                                      " (in 'optimize_glm.stan', line 204, column 2 to column 51)",
                                                      " (in 'optimize_glm.stan', line 206, column 2 to column 65)",
                                                      " (in 'optimize_glm.stan', line 207, column 2 to column 51)",
                                                      " (in 'optimize_glm.stan', line 209, column 2 to column 65)",
                                                      " (in 'optimize_glm.stan', line 210, column 2 to column 51)",
                                                      " (in 'optimize_glm.stan', line 212, column 2 to column 63)",
                                                      " (in 'optimize_glm.stan', line 213, column 2 to column 49)",
                                                      " (in 'optimize_glm.stan', line 215, column 2 to column 63)",
                                                      " (in 'optimize_glm.stan', line 216, column 2 to column 49)",
                                                      " (in 'optimize_glm.stan', line 218, column 2 to column 69)",
                                                      " (in 'optimize_glm.stan', line 219, column 2 to column 55)",
                                                      " (in 'optimize_glm.stan', line 221, column 2 to column 66)",
                                                      " (in 'optimize_glm.stan', line 222, column 2 to column 53)",
                                                      " (in 'optimize_glm.stan', line 224, column 2 to column 66)",
                                                      " (in 'optimize_glm.stan', line 225, column 2 to column 52)",
                                                      " (in 'optimize_glm.stan', line 227, column 2 to column 66)",
                                                      " (in 'optimize_glm.stan', line 228, column 2 to column 52)",
                                                      " (in 'optimize_glm.stan', line 230, column 2 to column 68)",
                                                      " (in 'optimize_glm.stan', line 231, column 2 to column 54)",
                                                      " (in 'optimize_glm.stan', line 233, column 2 to column 68)",
                                                      " (in 'optimize_glm.stan', line 234, column 2 to column 54)",
                                                      " (in 'optimize_glm.stan', line 236, column 2 to column 74)",
                                                      " (in 'optimize_glm.stan', line 237, column 2 to column 60)",
                                                      " (in 'optimize_glm.stan', line 239, column 2 to column 71)",
                                                      " (in 'optimize_glm.stan', line 240, column 2 to column 57)",
                                                      " (in 'optimize_glm.stan', line 242, column 2 to column 71)",
                                                      " (in 'optimize_glm.stan', line 243, column 2 to column 57)",
                                                      " (in 'optimize_glm.stan', line 245, column 2 to column 71)",
                                                      " (in 'optimize_glm.stan', line 246, column 2 to column 57)",
                                                      " (in 'optimize_glm.stan', line 248, column 2 to column 77)",
                                                      " (in 'optimize_glm.stan', line 249, column 2 to column 63)",
                                                      " (in 'optimize_glm.stan', line 251, column 2 to column 74)",
                                                      " (in 'optimize_glm.stan', line 252, column 2 to column 60)",
                                                      " (in 'optimize_glm.stan', line 254, column 2 to column 69)",
                                                      " (in 'optimize_glm.stan', line 255, column 2 to column 55)",
                                                      " (in 'optimize_glm.stan', line 257, column 2 to column 69)",
                                                      " (in 'optimize_glm.stan', line 258, column 2 to column 55)",
                                                      " (in 'optimize_glm.stan', line 260, column 2 to column 75)",
                                                      " (in 'optimize_glm.stan', line 261, column 2 to column 61)",
                                                      " (in 'optimize_glm.stan', line 263, column 2 to column 72)",
                                                      " (in 'optimize_glm.stan', line 264, column 2 to column 58)",
                                                      " (in 'optimize_glm.stan', line 266, column 2 to column 72)",
                                                      " (in 'optimize_glm.stan', line 267, column 2 to column 58)",
                                                      " (in 'optimize_glm.stan', line 269, column 2 to column 72)",
                                                      " (in 'optimize_glm.stan', line 270, column 2 to column 58)",
                                                      " (in 'optimize_glm.stan', line 272, column 2 to column 78)",
                                                      " (in 'optimize_glm.stan', line 273, column 2 to column 64)",
                                                      " (in 'optimize_glm.stan', line 275, column 2 to column 75)",
                                                      " (in 'optimize_glm.stan', line 276, column 2 to column 61)",
                                                      " (in 'optimize_glm.stan', line 278, column 2 to column 73)",
                                                      " (in 'optimize_glm.stan', line 279, column 2 to column 59)",
                                                      " (in 'optimize_glm.stan', line 281, column 2 to column 76)",
                                                      " (in 'optimize_glm.stan', line 282, column 2 to column 62)",
                                                      " (in 'optimize_glm.stan', line 2, column 2 to column 17)",
                                                      " (in 'optimize_glm.stan', line 3, column 2 to column 17)",
                                                      " (in 'optimize_glm.stan', line 4, column 2 to column 19)",
                                                      " (in 'optimize_glm.stan', line 5, column 2 to column 18)",
                                                      " (in 'optimize_glm.stan', line 6, column 2 to column 23)",
                                                      " (in 'optimize_glm.stan', line 7, column 2 to column 16)",
                                                      " (in 'optimize_glm.stan', line 8, column 2 to column 17)",
                                                      " (in 'optimize_glm.stan', line 9, column 2 to column 12)",
                                                      " (in 'optimize_glm.stan', line 10, column 2 to column 13)",
                                                      " (in 'optimize_glm.stan', line 14, column 2 to column 20)",
                                                      " (in 'optimize_glm.stan', line 15, column 2 to column 20)",
                                                      " (in 'optimize_glm.stan', line 16, column 2 to column 22)",
                                                      " (in 'optimize_glm.stan', line 17, column 2 to column 21)",
                                                      " (in 'optimize_glm.stan', line 18, column 2 to column 26)",
                                                      " (in 'optimize_glm.stan', line 19, column 2 to column 19)",
                                                      " (in 'optimize_glm.stan', line 20, column 2 to column 20)",
                                                      " (in 'optimize_glm.stan', line 21, column 2 to column 15)",
                                                      " (in 'optimize_glm.stan', line 22, column 2 to column 16)"};



class optimize_glm_model : public model_base_crtp<optimize_glm_model> {

 private:
  int pos__;
  int k;
  int n;
  Eigen::Matrix<double, -1, -1> X_d;
  Eigen::Matrix<double, -1, 1> y_v_d;
  Eigen::Matrix<double, 1, -1> X_rv_d;
  std::vector<int> y_vi_d;
  std::vector<int> y2_vi_d;
  int y_s_d;
  double y_r_d;
  int k_td;
  int n_td;
  Eigen::Matrix<double, -1, -1> X_d_td;
  Eigen::Matrix<double, -1, 1> y_v_d_td;
  Eigen::Matrix<double, 1, -1> X_rv_d_td;
  std::vector<int> y_vi_d_td;
  std::vector<int> y2_vi_d_td;
  int y_s_d_td;
  double y_r_d_td;
 
 public:
  ~optimize_glm_model() { }
  
  std::string model_name() const { return "optimize_glm_model"; }
  
  optimize_glm_model(stan::io::var_context& context__,
                     unsigned int random_seed__ = 0,
                     std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "optimize_glm_model_namespace::optimize_glm_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      context__.validate_dims("data initialization","k","int",
          context__.to_vec());
      k = std::numeric_limits<int>::min();
      
      current_statement__ = 174;
      k = context__.vals_i("k")[(1 - 1)];
      context__.validate_dims("data initialization","n","int",
          context__.to_vec());
      n = std::numeric_limits<int>::min();
      
      current_statement__ = 175;
      n = context__.vals_i("n")[(1 - 1)];
      current_statement__ = 176;
      validate_non_negative_index("X_d", "n", n);
      current_statement__ = 176;
      validate_non_negative_index("X_d", "k", k);
      context__.validate_dims("data initialization","X_d","double",
          context__.to_vec(n, k));
      X_d = Eigen::Matrix<double, -1, -1>(n, k);
      stan::math::fill(X_d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> X_d_flat__;
        current_statement__ = 176;
        assign(X_d_flat__, nil_index_list(), context__.vals_r("X_d"),
          "assigning variable X_d_flat__");
        current_statement__ = 176;
        pos__ = 1;
        current_statement__ = 176;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          current_statement__ = 176;
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            current_statement__ = 176;
            assign(X_d,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              X_d_flat__[(pos__ - 1)], "assigning variable X_d");
            current_statement__ = 176;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 177;
      validate_non_negative_index("y_v_d", "n", n);
      context__.validate_dims("data initialization","y_v_d","double",
          context__.to_vec(n));
      y_v_d = Eigen::Matrix<double, -1, 1>(n);
      stan::math::fill(y_v_d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y_v_d_flat__;
        current_statement__ = 177;
        assign(y_v_d_flat__, nil_index_list(), context__.vals_r("y_v_d"),
          "assigning variable y_v_d_flat__");
        current_statement__ = 177;
        pos__ = 1;
        current_statement__ = 177;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          current_statement__ = 177;
          assign(y_v_d, cons_list(index_uni(sym1__), nil_index_list()),
            y_v_d_flat__[(pos__ - 1)], "assigning variable y_v_d");
          current_statement__ = 177;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 178;
      validate_non_negative_index("X_rv_d", "n", n);
      context__.validate_dims("data initialization","X_rv_d","double",
          context__.to_vec(n));
      X_rv_d = Eigen::Matrix<double, 1, -1>(n);
      stan::math::fill(X_rv_d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> X_rv_d_flat__;
        current_statement__ = 178;
        assign(X_rv_d_flat__, nil_index_list(), context__.vals_r("X_rv_d"),
          "assigning variable X_rv_d_flat__");
        current_statement__ = 178;
        pos__ = 1;
        current_statement__ = 178;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          current_statement__ = 178;
          assign(X_rv_d, cons_list(index_uni(sym1__), nil_index_list()),
            X_rv_d_flat__[(pos__ - 1)], "assigning variable X_rv_d");
          current_statement__ = 178;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 179;
      validate_non_negative_index("y_vi_d", "n", n);
      context__.validate_dims("data initialization","y_vi_d","int",
          context__.to_vec(n));
      y_vi_d = std::vector<int>(n, std::numeric_limits<int>::min());
      
      current_statement__ = 179;
      assign(y_vi_d, nil_index_list(), context__.vals_i("y_vi_d"),
        "assigning variable y_vi_d");
      current_statement__ = 180;
      validate_non_negative_index("y2_vi_d", "n", n);
      context__.validate_dims("data initialization","y2_vi_d","int",
          context__.to_vec(n));
      y2_vi_d = std::vector<int>(n, std::numeric_limits<int>::min());
      
      current_statement__ = 180;
      assign(y2_vi_d, nil_index_list(), context__.vals_i("y2_vi_d"),
        "assigning variable y2_vi_d");
      context__.validate_dims("data initialization","y_s_d","int",
          context__.to_vec());
      y_s_d = std::numeric_limits<int>::min();
      
      current_statement__ = 181;
      y_s_d = context__.vals_i("y_s_d")[(1 - 1)];
      context__.validate_dims("data initialization","y_r_d","double",
          context__.to_vec());
      y_r_d = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 182;
      y_r_d = context__.vals_r("y_r_d")[(1 - 1)];
      k_td = std::numeric_limits<int>::min();
      
      n_td = std::numeric_limits<int>::min();
      
      current_statement__ = 185;
      validate_non_negative_index("X_d_td", "n", n);
      current_statement__ = 185;
      validate_non_negative_index("X_d_td", "k", k);
      X_d_td = Eigen::Matrix<double, -1, -1>(n, k);
      stan::math::fill(X_d_td, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 186;
      validate_non_negative_index("y_v_d_td", "n", n);
      y_v_d_td = Eigen::Matrix<double, -1, 1>(n);
      stan::math::fill(y_v_d_td, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 187;
      validate_non_negative_index("X_rv_d_td", "n", n);
      X_rv_d_td = Eigen::Matrix<double, 1, -1>(n);
      stan::math::fill(X_rv_d_td, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 188;
      validate_non_negative_index("y_vi_d_td", "n", n);
      y_vi_d_td = std::vector<int>(n, std::numeric_limits<int>::min());
      
      current_statement__ = 189;
      validate_non_negative_index("y2_vi_d_td", "n", n);
      y2_vi_d_td = std::vector<int>(n, std::numeric_limits<int>::min());
      
      y_s_d_td = std::numeric_limits<int>::min();
      
      y_r_d_td = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 174;
      current_statement__ = 174;
      check_greater_or_equal(function__, "k", k, 1);
      current_statement__ = 175;
      current_statement__ = 175;
      check_greater_or_equal(function__, "n", n, 0);
      current_statement__ = 183;
      current_statement__ = 183;
      check_greater_or_equal(function__, "k_td", k_td, 1);
      current_statement__ = 184;
      current_statement__ = 184;
      check_greater_or_equal(function__, "n_td", n_td, 0);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      current_statement__ = 1;
      validate_non_negative_index("alpha_v", "k", k);
      num_params_r__ += k;
      current_statement__ = 2;
      validate_non_negative_index("beta", "k", k);
      num_params_r__ += k;
      current_statement__ = 3;
      validate_non_negative_index("cuts", "k", k);
      num_params_r__ += k;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      current_statement__ = 7;
      validate_non_negative_index("X_p", "n", n);
      current_statement__ = 7;
      validate_non_negative_index("X_p", "k", k);
      num_params_r__ += n * k;
      current_statement__ = 8;
      validate_non_negative_index("beta_m", "n", n);
      current_statement__ = 8;
      validate_non_negative_index("beta_m", "k", k);
      num_params_r__ += n * k;
      current_statement__ = 9;
      validate_non_negative_index("X_rv_p", "n", n);
      num_params_r__ += n;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  inline T__ log_prob(std::vector<T__>& params_r__,
                      std::vector<int>& params_i__,
                      std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "optimize_glm_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      current_statement__ = 1;
      validate_non_negative_index("alpha_v", "k", k);
      Eigen::Matrix<local_scalar_t__, -1, 1> alpha_v;
      alpha_v = Eigen::Matrix<local_scalar_t__, -1, 1>(k);
      stan::math::fill(alpha_v, DUMMY_VAR__);
      
      current_statement__ = 1;
      alpha_v = in__.vector(k);
      current_statement__ = 2;
      validate_non_negative_index("beta", "k", k);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(k);
      stan::math::fill(beta, DUMMY_VAR__);
      
      current_statement__ = 2;
      beta = in__.vector(k);
      current_statement__ = 3;
      validate_non_negative_index("cuts", "k", k);
      Eigen::Matrix<local_scalar_t__, -1, 1> cuts;
      cuts = Eigen::Matrix<local_scalar_t__, -1, 1>(k);
      stan::math::fill(cuts, DUMMY_VAR__);
      
      current_statement__ = 3;
      cuts = in__.vector(k);
      local_scalar_t__ sigma;
      sigma = DUMMY_VAR__;
      
      current_statement__ = 4;
      sigma = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        sigma = stan::math::lb_constrain(sigma, 0, lp__);
      } else {
        current_statement__ = 4;
        sigma = stan::math::lb_constrain(sigma, 0);
      }
      local_scalar_t__ alpha;
      alpha = DUMMY_VAR__;
      
      current_statement__ = 5;
      alpha = in__.scalar();
      local_scalar_t__ phi;
      phi = DUMMY_VAR__;
      
      current_statement__ = 6;
      phi = in__.scalar();
      current_statement__ = 7;
      validate_non_negative_index("X_p", "n", n);
      current_statement__ = 7;
      validate_non_negative_index("X_p", "k", k);
      Eigen::Matrix<local_scalar_t__, -1, -1> X_p;
      X_p = Eigen::Matrix<local_scalar_t__, -1, -1>(n, k);
      stan::math::fill(X_p, DUMMY_VAR__);
      
      current_statement__ = 7;
      X_p = in__.matrix(n, k);
      current_statement__ = 8;
      validate_non_negative_index("beta_m", "n", n);
      current_statement__ = 8;
      validate_non_negative_index("beta_m", "k", k);
      Eigen::Matrix<local_scalar_t__, -1, -1> beta_m;
      beta_m = Eigen::Matrix<local_scalar_t__, -1, -1>(n, k);
      stan::math::fill(beta_m, DUMMY_VAR__);
      
      current_statement__ = 8;
      beta_m = in__.matrix(n, k);
      current_statement__ = 9;
      validate_non_negative_index("X_rv_p", "n", n);
      Eigen::Matrix<local_scalar_t__, 1, -1> X_rv_p;
      X_rv_p = Eigen::Matrix<local_scalar_t__, 1, -1>(n);
      stan::math::fill(X_rv_p, DUMMY_VAR__);
      
      current_statement__ = 9;
      X_rv_p = in__.row_vector(n);
      {
        current_statement__ = 10;
        lp_accum__.add(
          normal_id_glm_lpdf<false>(y_v_d, X_d, alpha, beta, sigma));
        current_statement__ = 11;
        lp_accum__.add(
          normal_id_glm_lpdf<propto__>(y_v_d, X_d, alpha, beta, sigma));
        current_statement__ = 12;
        lp_accum__.add(
          normal_id_glm_lpdf<false>(y_v_d, X_p, alpha, beta, sigma));
        current_statement__ = 13;
        lp_accum__.add(
          normal_id_glm_lpdf<propto__>(y_v_d, X_p, alpha, beta, sigma));
        current_statement__ = 14;
        lp_accum__.add(
          normal_id_glm_lpdf<false>(y_r_d, X_d, alpha, beta, beta));
        current_statement__ = 15;
        lp_accum__.add(
          normal_id_glm_lpdf<propto__>(y_r_d, X_d, alpha, beta, beta));
        current_statement__ = 16;
        lp_accum__.add(
          normal_id_glm_lpdf<false>(y_r_d, X_p, alpha, beta, beta));
        current_statement__ = 17;
        lp_accum__.add(
          normal_id_glm_lpdf<propto__>(y_r_d, X_p, alpha, beta, beta));
        current_statement__ = 18;
        lp_accum__.add(
          normal_id_glm_lpdf<false>(y_v_d, X_rv_d, alpha, beta, beta));
        current_statement__ = 19;
        lp_accum__.add(
          normal_id_glm_lpdf<propto__>(y_v_d, X_rv_d, alpha, beta, beta));
        current_statement__ = 20;
        lp_accum__.add(
          normal_id_glm_lpdf<false>(y_v_d, X_rv_p, alpha, beta, beta));
        current_statement__ = 21;
        lp_accum__.add(
          normal_id_glm_lpdf<propto__>(y_v_d, X_rv_p, alpha, beta, beta));
        current_statement__ = 22;
        lp_accum__.add(
          normal_id_glm_lpdf<false>(y_v_d_td, X_d_td, alpha, beta, sigma));
        current_statement__ = 23;
        lp_accum__.add(
          normal_id_glm_lpdf<propto__>(y_v_d_td, X_d_td, alpha, beta, sigma));
        current_statement__ = 24;
        lp_accum__.add(
          normal_id_glm_lpdf<false>(y_v_d_td, X_p, alpha, beta, sigma));
        current_statement__ = 25;
        lp_accum__.add(
          normal_id_glm_lpdf<propto__>(y_v_d_td, X_p, alpha, beta, sigma));
        current_statement__ = 26;
        lp_accum__.add(
          normal_id_glm_lpdf<false>(y_r_d_td, X_d_td, alpha, beta, beta));
        current_statement__ = 27;
        lp_accum__.add(
          normal_id_glm_lpdf<propto__>(y_r_d_td, X_d_td, alpha, beta, beta));
        current_statement__ = 28;
        lp_accum__.add(
          normal_id_glm_lpdf<false>(y_r_d_td, X_p, alpha, beta, beta));
        current_statement__ = 29;
        lp_accum__.add(
          normal_id_glm_lpdf<propto__>(y_r_d_td, X_p, alpha, beta, beta));
        current_statement__ = 30;
        lp_accum__.add(
          normal_id_glm_lpdf<false>(y_v_d_td, X_rv_d_td, alpha, beta, beta));
        current_statement__ = 31;
        lp_accum__.add(
          normal_id_glm_lpdf<propto__>(y_v_d_td, X_rv_d_td, alpha, beta,
            beta));
        current_statement__ = 32;
        lp_accum__.add(
          normal_id_glm_lpdf<false>(y_v_d_td, X_rv_p, alpha, beta, beta));
        current_statement__ = 33;
        lp_accum__.add(
          normal_id_glm_lpdf<propto__>(y_v_d_td, X_rv_p, alpha, beta, beta));
        current_statement__ = 34;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<false>(y_vi_d, X_d, alpha, beta));
        current_statement__ = 35;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<propto__>(y_vi_d, X_d, alpha, beta));
        current_statement__ = 36;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<false>(y_vi_d, X_p, alpha, beta));
        current_statement__ = 37;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<propto__>(y_vi_d, X_p, alpha, beta));
        current_statement__ = 38;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<false>(y_vi_d, X_rv_d, alpha, beta));
        current_statement__ = 39;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<propto__>(y_vi_d, X_rv_d, alpha, beta));
        current_statement__ = 40;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<false>(y_vi_d, X_rv_p, alpha, beta));
        current_statement__ = 41;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<propto__>(y_vi_d, X_rv_p, alpha, beta));
        current_statement__ = 42;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<false>(y_s_d, X_d, alpha, beta));
        current_statement__ = 43;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<propto__>(y_s_d, X_d, alpha, beta));
        current_statement__ = 44;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<false>(y_s_d, X_p, alpha, beta));
        current_statement__ = 45;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<propto__>(y_s_d, X_p, alpha, beta));
        current_statement__ = 46;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<false>(y_vi_d_td, X_d_td, alpha, beta));
        current_statement__ = 47;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<propto__>(y_vi_d_td, X_d_td, alpha, beta));
        current_statement__ = 48;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<false>(y_vi_d_td, X_p, alpha, beta));
        current_statement__ = 49;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<propto__>(y_vi_d_td, X_p, alpha, beta));
        current_statement__ = 50;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<false>(y_vi_d_td, X_rv_d_td, alpha, beta));
        current_statement__ = 51;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<propto__>(y_vi_d_td, X_rv_d_td, alpha,
            beta));
        current_statement__ = 52;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<false>(y_vi_d_td, X_rv_p, alpha, beta));
        current_statement__ = 53;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<propto__>(y_vi_d_td, X_rv_p, alpha, beta));
        current_statement__ = 54;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<false>(y_s_d_td, X_d_td, alpha, beta));
        current_statement__ = 55;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<propto__>(y_s_d_td, X_d_td, alpha, beta));
        current_statement__ = 56;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<false>(y_s_d_td, X_p, alpha, beta));
        current_statement__ = 57;
        lp_accum__.add(
          bernoulli_logit_glm_lpmf<propto__>(y_s_d_td, X_p, alpha, beta));
        current_statement__ = 58;
        lp_accum__.add(poisson_log_glm_lpmf<false>(y_vi_d, X_d, alpha, beta));
        current_statement__ = 59;
        lp_accum__.add(
          poisson_log_glm_lpmf<propto__>(y_vi_d, X_d, alpha, beta));
        current_statement__ = 60;
        lp_accum__.add(poisson_log_glm_lpmf<false>(y_vi_d, X_p, alpha, beta));
        current_statement__ = 61;
        lp_accum__.add(
          poisson_log_glm_lpmf<propto__>(y_vi_d, X_p, alpha, beta));
        current_statement__ = 62;
        lp_accum__.add(poisson_log_glm_lpmf<false>(y_s_d, X_d, alpha, beta));
        current_statement__ = 63;
        lp_accum__.add(
          poisson_log_glm_lpmf<propto__>(y_s_d, X_d, alpha, beta));
        current_statement__ = 64;
        lp_accum__.add(poisson_log_glm_lpmf<false>(y_s_d, X_p, alpha, beta));
        current_statement__ = 65;
        lp_accum__.add(
          poisson_log_glm_lpmf<propto__>(y_s_d, X_p, alpha, beta));
        current_statement__ = 66;
        lp_accum__.add(
          poisson_log_glm_lpmf<false>(y_vi_d, X_rv_d, alpha, beta));
        current_statement__ = 67;
        lp_accum__.add(
          poisson_log_glm_lpmf<propto__>(y_vi_d, X_rv_d, alpha, beta));
        current_statement__ = 68;
        lp_accum__.add(
          poisson_log_glm_lpmf<false>(y_vi_d, X_rv_p, alpha, beta));
        current_statement__ = 69;
        lp_accum__.add(
          poisson_log_glm_lpmf<propto__>(y_vi_d, X_rv_p, alpha, beta));
        current_statement__ = 70;
        lp_accum__.add(
          poisson_log_glm_lpmf<false>(y_vi_d_td, X_d_td, alpha, beta));
        current_statement__ = 71;
        lp_accum__.add(
          poisson_log_glm_lpmf<propto__>(y_vi_d_td, X_d_td, alpha, beta));
        current_statement__ = 72;
        lp_accum__.add(
          poisson_log_glm_lpmf<false>(y_vi_d_td, X_p, alpha, beta));
        current_statement__ = 73;
        lp_accum__.add(
          poisson_log_glm_lpmf<propto__>(y_vi_d_td, X_p, alpha, beta));
        current_statement__ = 74;
        lp_accum__.add(
          poisson_log_glm_lpmf<false>(y_s_d_td, X_d_td, alpha, beta));
        current_statement__ = 75;
        lp_accum__.add(
          poisson_log_glm_lpmf<propto__>(y_s_d_td, X_d_td, alpha, beta));
        current_statement__ = 76;
        lp_accum__.add(
          poisson_log_glm_lpmf<false>(y_s_d_td, X_p, alpha, beta));
        current_statement__ = 77;
        lp_accum__.add(
          poisson_log_glm_lpmf<propto__>(y_s_d_td, X_p, alpha, beta));
        current_statement__ = 78;
        lp_accum__.add(
          poisson_log_glm_lpmf<false>(y_vi_d_td, X_rv_d_td, alpha, beta));
        current_statement__ = 79;
        lp_accum__.add(
          poisson_log_glm_lpmf<propto__>(y_vi_d_td, X_rv_d_td, alpha, beta));
        current_statement__ = 80;
        lp_accum__.add(
          poisson_log_glm_lpmf<false>(y_vi_d_td, X_rv_p, alpha, beta));
        current_statement__ = 81;
        lp_accum__.add(
          poisson_log_glm_lpmf<propto__>(y_vi_d_td, X_rv_p, alpha, beta));
        current_statement__ = 82;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<false>(y_vi_d, X_d, alpha, beta, phi));
        current_statement__ = 83;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<propto__>(y_vi_d, X_d, alpha, beta,
            phi));
        current_statement__ = 84;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<false>(y_vi_d, X_p, alpha, beta, phi));
        current_statement__ = 85;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<propto__>(y_vi_d, X_p, alpha, beta,
            phi));
        current_statement__ = 86;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<false>(y_s_d, X_d, alpha, beta, phi));
        current_statement__ = 87;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<propto__>(y_s_d, X_d, alpha, beta, phi));
        current_statement__ = 88;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<false>(y_s_d, X_p, alpha, beta, phi));
        current_statement__ = 89;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<propto__>(y_s_d, X_p, alpha, beta, phi));
        current_statement__ = 90;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<false>(y_vi_d, X_rv_d, alpha, beta,
            phi));
        current_statement__ = 91;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<propto__>(y_vi_d, X_rv_d, alpha, beta,
            phi));
        current_statement__ = 92;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<false>(y_vi_d, X_rv_p, alpha, beta,
            phi));
        current_statement__ = 93;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<propto__>(y_vi_d, X_rv_p, alpha, beta,
            phi));
        current_statement__ = 94;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<false>(y_vi_d_td, X_d_td, alpha, beta,
            phi));
        current_statement__ = 95;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<propto__>(y_vi_d_td, X_d_td, alpha,
            beta, phi));
        current_statement__ = 96;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<false>(y_vi_d_td, X_p, alpha, beta,
            phi));
        current_statement__ = 97;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<propto__>(y_vi_d_td, X_p, alpha, beta,
            phi));
        current_statement__ = 98;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<false>(y_s_d_td, X_d_td, alpha, beta,
            phi));
        current_statement__ = 99;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<propto__>(y_s_d_td, X_d_td, alpha,
            beta, phi));
        current_statement__ = 100;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<false>(y_s_d_td, X_p, alpha, beta, phi));
        current_statement__ = 101;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<propto__>(y_s_d_td, X_p, alpha, beta,
            phi));
        current_statement__ = 102;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<false>(y_vi_d_td, X_rv_d_td, alpha,
            beta, phi));
        current_statement__ = 103;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<propto__>(y_vi_d_td, X_rv_d_td, alpha,
            beta, phi));
        current_statement__ = 104;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<false>(y_vi_d_td, X_rv_p, alpha, beta,
            phi));
        current_statement__ = 105;
        lp_accum__.add(
          neg_binomial_2_log_glm_lpmf<propto__>(y_vi_d_td, X_rv_p, alpha,
            beta, phi));
        current_statement__ = 106;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_s_d, X_d, beta, cuts));
        current_statement__ = 107;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_s_d, X_d, beta, cuts));
        current_statement__ = 108;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_s_d, X_p, beta, cuts));
        current_statement__ = 109;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_s_d, X_p, beta, cuts));
        current_statement__ = 110;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_s_d_td, X_d_td, beta, cuts));
        current_statement__ = 111;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_s_d_td, X_d_td, beta, cuts));
        current_statement__ = 112;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_s_d_td, X_p, beta, cuts));
        current_statement__ = 113;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_s_d_td, X_p, beta, cuts));
        current_statement__ = 114;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_s_d, X_d, beta, cuts));
        current_statement__ = 115;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_s_d, X_d, beta, cuts));
        current_statement__ = 116;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_s_d, X_p, beta, cuts));
        current_statement__ = 117;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_s_d, X_p, beta, cuts));
        current_statement__ = 118;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_s_d_td, X_d_td, beta, cuts));
        current_statement__ = 119;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_s_d_td, X_d_td, beta, cuts));
        current_statement__ = 120;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_s_d_td, X_p, beta, cuts));
        current_statement__ = 121;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_s_d_td, X_p, beta, cuts));
        current_statement__ = 122;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_s_d, X_rv_d, beta, cuts));
        current_statement__ = 123;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_s_d, X_rv_d, beta, cuts));
        current_statement__ = 124;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_s_d, X_rv_p, beta, cuts));
        current_statement__ = 125;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_s_d, X_rv_p, beta, cuts));
        current_statement__ = 126;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_vi_d, X_d, beta, cuts));
        current_statement__ = 127;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_vi_d, X_d, beta, cuts));
        current_statement__ = 128;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_vi_d, X_p, beta, cuts));
        current_statement__ = 129;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_vi_d, X_p, beta, cuts));
        current_statement__ = 130;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_vi_d_td, X_d_td, beta, cuts));
        current_statement__ = 131;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_vi_d_td, X_d_td, beta, cuts));
        current_statement__ = 132;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_vi_d_td, X_p, beta, cuts));
        current_statement__ = 133;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_vi_d_td, X_p, beta, cuts));
        current_statement__ = 134;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_vi_d, X_rv_d, beta, cuts));
        current_statement__ = 135;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_vi_d, X_rv_d, beta, cuts));
        current_statement__ = 136;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<false>(y_vi_d, X_rv_p, beta, cuts));
        current_statement__ = 137;
        lp_accum__.add(
          ordered_logistic_glm_lpmf<propto__>(y_vi_d, X_rv_p, beta, cuts));
        current_statement__ = 138;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_s_d, X_d, alpha_v, beta_m));
        current_statement__ = 139;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_s_d, X_d, alpha_v, beta_m));
        current_statement__ = 140;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_s_d, X_p, alpha_v, beta_m));
        current_statement__ = 141;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_s_d, X_p, alpha_v, beta_m));
        current_statement__ = 142;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_s_d_td, X_d_td, alpha_v,
            beta_m));
        current_statement__ = 143;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_s_d_td, X_d_td, alpha_v,
            beta_m));
        current_statement__ = 144;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_s_d_td, X_p, alpha_v, beta_m));
        current_statement__ = 145;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_s_d_td, X_p, alpha_v,
            beta_m));
        current_statement__ = 146;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_s_d, X_rv_d, alpha_v, beta_m));
        current_statement__ = 147;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_s_d, X_rv_d, alpha_v,
            beta_m));
        current_statement__ = 148;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_s_d, X_rv_p, alpha_v, beta_m));
        current_statement__ = 149;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_s_d, X_rv_p, alpha_v,
            beta_m));
        current_statement__ = 150;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_s_d_td, X_rv_d_td, alpha_v,
            beta_m));
        current_statement__ = 151;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_s_d_td, X_rv_d_td, alpha_v,
            beta_m));
        current_statement__ = 152;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_s_d_td, X_rv_p, alpha_v,
            beta_m));
        current_statement__ = 153;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_s_d_td, X_rv_p, alpha_v,
            beta_m));
        current_statement__ = 154;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_vi_d, X_d, alpha_v, beta_m));
        current_statement__ = 155;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_vi_d, X_d, alpha_v, beta_m));
        current_statement__ = 156;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_vi_d, X_p, alpha_v, beta_m));
        current_statement__ = 157;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_vi_d, X_p, alpha_v, beta_m));
        current_statement__ = 158;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_vi_d_td, X_d_td, alpha_v,
            beta_m));
        current_statement__ = 159;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_vi_d_td, X_d_td, alpha_v,
            beta_m));
        current_statement__ = 160;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_vi_d_td, X_p, alpha_v, beta_m));
        current_statement__ = 161;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_vi_d_td, X_p, alpha_v,
            beta_m));
        current_statement__ = 162;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_vi_d, X_rv_d, alpha_v, beta_m));
        current_statement__ = 163;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_vi_d, X_rv_d, alpha_v,
            beta_m));
        current_statement__ = 164;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_vi_d, X_rv_p, alpha_v, beta_m));
        current_statement__ = 165;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_vi_d, X_rv_p, alpha_v,
            beta_m));
        current_statement__ = 166;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_vi_d_td, X_rv_d_td, alpha_v,
            beta_m));
        current_statement__ = 167;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_vi_d_td, X_rv_d_td, alpha_v,
            beta_m));
        current_statement__ = 168;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y_vi_d_td, X_rv_p, alpha_v,
            beta_m));
        current_statement__ = 169;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y_vi_d_td, X_rv_p, alpha_v,
            beta_m));
        current_statement__ = 170;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y2_vi_d, X_rv_p, alpha_v, beta_m));
        current_statement__ = 171;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y2_vi_d, X_rv_p, alpha_v,
            beta_m));
        current_statement__ = 172;
        lp_accum__.add(
          categorical_logit_glm_lpmf<false>(y2_vi_d_td, X_rv_p, alpha_v,
            beta_m));
        current_statement__ = 173;
        lp_accum__.add(
          categorical_logit_glm_lpmf<propto__>(y2_vi_d_td, X_rv_p, alpha_v,
            beta_m));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  inline void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                          std::vector<int>& params_i__,
                          std::vector<double>& vars__,
                          bool emit_transformed_parameters__ = true,
                          bool emit_generated_quantities__ = true,
                          std::ostream* pstream__ = 0) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "optimize_glm_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      current_statement__ = 1;
      validate_non_negative_index("alpha_v", "k", k);
      Eigen::Matrix<double, -1, 1> alpha_v;
      alpha_v = Eigen::Matrix<double, -1, 1>(k);
      stan::math::fill(alpha_v, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      alpha_v = in__.vector(k);
      current_statement__ = 2;
      validate_non_negative_index("beta", "k", k);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(k);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      beta = in__.vector(k);
      current_statement__ = 3;
      validate_non_negative_index("cuts", "k", k);
      Eigen::Matrix<double, -1, 1> cuts;
      cuts = Eigen::Matrix<double, -1, 1>(k);
      stan::math::fill(cuts, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      cuts = in__.vector(k);
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      sigma = in__.scalar();
      current_statement__ = 4;
      sigma = stan::math::lb_constrain(sigma, 0);
      double alpha;
      alpha = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      alpha = in__.scalar();
      double phi;
      phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      phi = in__.scalar();
      current_statement__ = 7;
      validate_non_negative_index("X_p", "n", n);
      current_statement__ = 7;
      validate_non_negative_index("X_p", "k", k);
      Eigen::Matrix<double, -1, -1> X_p;
      X_p = Eigen::Matrix<double, -1, -1>(n, k);
      stan::math::fill(X_p, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      X_p = in__.matrix(n, k);
      current_statement__ = 8;
      validate_non_negative_index("beta_m", "n", n);
      current_statement__ = 8;
      validate_non_negative_index("beta_m", "k", k);
      Eigen::Matrix<double, -1, -1> beta_m;
      beta_m = Eigen::Matrix<double, -1, -1>(n, k);
      stan::math::fill(beta_m, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      beta_m = in__.matrix(n, k);
      current_statement__ = 9;
      validate_non_negative_index("X_rv_p", "n", n);
      Eigen::Matrix<double, 1, -1> X_rv_p;
      X_rv_p = Eigen::Matrix<double, 1, -1>(n);
      stan::math::fill(X_rv_p, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 9;
      X_rv_p = in__.row_vector(n);
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        vars__.push_back(alpha_v[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        vars__.push_back(beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        vars__.push_back(cuts[(sym1__ - 1)]);}
      vars__.push_back(sigma);
      vars__.push_back(alpha);
      vars__.push_back(phi);
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          vars__.push_back(
            rvalue(X_p,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "X_p"));}}
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          vars__.push_back(
            rvalue(beta_m,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "beta_m"));}
      }
      for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
        vars__.push_back(X_rv_p[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  inline void transform_inits(const stan::io::var_context& context__,
                              std::vector<int>& params_i__,
                              std::vector<double>& vars__,
                              std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 1;
      validate_non_negative_index("alpha_v", "k", k);
      Eigen::Matrix<double, -1, 1> alpha_v;
      alpha_v = Eigen::Matrix<double, -1, 1>(k);
      stan::math::fill(alpha_v, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> alpha_v_flat__;
        current_statement__ = 1;
        assign(alpha_v_flat__, nil_index_list(), context__.vals_r("alpha_v"),
          "assigning variable alpha_v_flat__");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          current_statement__ = 1;
          assign(alpha_v, cons_list(index_uni(sym1__), nil_index_list()),
            alpha_v_flat__[(pos__ - 1)], "assigning variable alpha_v");
          current_statement__ = 1;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 2;
      validate_non_negative_index("beta", "k", k);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(k);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> beta_flat__;
        current_statement__ = 2;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            beta_flat__[(pos__ - 1)], "assigning variable beta");
          current_statement__ = 2;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 3;
      validate_non_negative_index("cuts", "k", k);
      Eigen::Matrix<double, -1, 1> cuts;
      cuts = Eigen::Matrix<double, -1, 1>(k);
      stan::math::fill(cuts, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> cuts_flat__;
        current_statement__ = 3;
        assign(cuts_flat__, nil_index_list(), context__.vals_r("cuts"),
          "assigning variable cuts_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          current_statement__ = 3;
          assign(cuts, cons_list(index_uni(sym1__), nil_index_list()),
            cuts_flat__[(pos__ - 1)], "assigning variable cuts");
          current_statement__ = 3;
          pos__ = (pos__ + 1);}
      }
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      current_statement__ = 4;
      sigma = stan::math::lb_free(sigma, 0);
      double alpha;
      alpha = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      alpha = context__.vals_r("alpha")[(1 - 1)];
      double phi;
      phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      phi = context__.vals_r("phi")[(1 - 1)];
      current_statement__ = 7;
      validate_non_negative_index("X_p", "n", n);
      current_statement__ = 7;
      validate_non_negative_index("X_p", "k", k);
      Eigen::Matrix<double, -1, -1> X_p;
      X_p = Eigen::Matrix<double, -1, -1>(n, k);
      stan::math::fill(X_p, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> X_p_flat__;
        current_statement__ = 7;
        assign(X_p_flat__, nil_index_list(), context__.vals_r("X_p"),
          "assigning variable X_p_flat__");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          current_statement__ = 7;
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            current_statement__ = 7;
            assign(X_p,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              X_p_flat__[(pos__ - 1)], "assigning variable X_p");
            current_statement__ = 7;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 8;
      validate_non_negative_index("beta_m", "n", n);
      current_statement__ = 8;
      validate_non_negative_index("beta_m", "k", k);
      Eigen::Matrix<double, -1, -1> beta_m;
      beta_m = Eigen::Matrix<double, -1, -1>(n, k);
      stan::math::fill(beta_m, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> beta_m_flat__;
        current_statement__ = 8;
        assign(beta_m_flat__, nil_index_list(), context__.vals_r("beta_m"),
          "assigning variable beta_m_flat__");
        current_statement__ = 8;
        pos__ = 1;
        current_statement__ = 8;
        for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
          current_statement__ = 8;
          for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
            current_statement__ = 8;
            assign(beta_m,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              beta_m_flat__[(pos__ - 1)], "assigning variable beta_m");
            current_statement__ = 8;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 9;
      validate_non_negative_index("X_rv_p", "n", n);
      Eigen::Matrix<double, 1, -1> X_rv_p;
      X_rv_p = Eigen::Matrix<double, 1, -1>(n);
      stan::math::fill(X_rv_p, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> X_rv_p_flat__;
        current_statement__ = 9;
        assign(X_rv_p_flat__, nil_index_list(), context__.vals_r("X_rv_p"),
          "assigning variable X_rv_p_flat__");
        current_statement__ = 9;
        pos__ = 1;
        current_statement__ = 9;
        for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
          current_statement__ = 9;
          assign(X_rv_p, cons_list(index_uni(sym1__), nil_index_list()),
            X_rv_p_flat__[(pos__ - 1)], "assigning variable X_rv_p");
          current_statement__ = 9;
          pos__ = (pos__ + 1);}
      }
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        vars__.push_back(alpha_v[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        vars__.push_back(beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        vars__.push_back(cuts[(sym1__ - 1)]);}
      vars__.push_back(sigma);
      vars__.push_back(alpha);
      vars__.push_back(phi);
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          vars__.push_back(
            rvalue(X_p,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "X_p"));}}
      for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          vars__.push_back(
            rvalue(beta_m,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "beta_m"));}
      }
      for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
        vars__.push_back(X_rv_p[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("alpha_v");
    names__.push_back("beta");
    names__.push_back("cuts");
    names__.push_back("sigma");
    names__.push_back("alpha");
    names__.push_back("phi");
    names__.push_back("X_p");
    names__.push_back("beta_m");
    names__.push_back("X_rv_p");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dims__.push_back(k);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(k);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(k);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n);
    
    dims__.push_back(k);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n);
    
    dims__.push_back(k);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const {
    
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      {
        param_names__.push_back(std::string() + "alpha_v" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      {
        param_names__.push_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      {
        param_names__.push_back(std::string() + "cuts" + '.' + std::to_string(sym1__));
      }}
    param_names__.push_back(std::string() + "sigma");
    param_names__.push_back(std::string() + "alpha");
    param_names__.push_back(std::string() + "phi");
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          {
            param_names__.push_back(std::string() + "X_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          {
            param_names__.push_back(std::string() + "beta_m" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
      {
        param_names__.push_back(std::string() + "X_rv_p" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const {
    
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      {
        param_names__.push_back(std::string() + "alpha_v" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      {
        param_names__.push_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      {
        param_names__.push_back(std::string() + "cuts" + '.' + std::to_string(sym1__));
      }}
    param_names__.push_back(std::string() + "sigma");
    param_names__.push_back(std::string() + "alpha");
    param_names__.push_back(std::string() + "phi");
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          {
            param_names__.push_back(std::string() + "X_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= k; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= n; ++sym2__) {
          {
            param_names__.push_back(std::string() + "beta_m" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= n; ++sym1__) {
      {
        param_names__.push_back(std::string() + "X_rv_p" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"alpha_v\",\"type\":{\"name\":\"vector\",\"length\":" << k << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << k << "},\"block\":\"parameters\"},{\"name\":\"cuts\",\"type\":{\"name\":\"vector\",\"length\":" << k << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" << n << ",\"cols\":" << k << "},\"block\":\"parameters\"},{\"name\":\"beta_m\",\"type\":{\"name\":\"matrix\",\"rows\":" << n << ",\"cols\":" << k << "},\"block\":\"parameters\"},{\"name\":\"X_rv_p\",\"type\":{\"name\":\"vector\",\"length\":" << n << "},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"alpha_v\",\"type\":{\"name\":\"vector\",\"length\":" << k << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << k << "},\"block\":\"parameters\"},{\"name\":\"cuts\",\"type\":{\"name\":\"vector\",\"length\":" << k << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" << n << ",\"cols\":" << k << "},\"block\":\"parameters\"},{\"name\":\"beta_m\",\"type\":{\"name\":\"matrix\",\"rows\":" << n << ",\"cols\":" << k << "},\"block\":\"parameters\"},{\"name\":\"X_rv_p\",\"type\":{\"name\":\"vector\",\"length\":" << n << "},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef optimize_glm_model_namespace::optimize_glm_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp reduce_sum_m1.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace reduce_sum_m1_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'reduce_sum_m1.stan', line 26, column 2 to column 13)",
                                                      " (in 'reduce_sum_m1.stan', line 27, column 2 to column 13)",
                                                      " (in 'reduce_sum_m1.stan', line 28, column 2 to column 13)",
                                                      " (in 'reduce_sum_m1.stan', line 32, column 2 to column 33)",
                                                      " (in 'reduce_sum_m1.stan', line 33, column 2 to column 37)",
                                                      " (in 'reduce_sum_m1.stan', line 34, column 2 to column 40)",
                                                      " (in 'reduce_sum_m1.stan', line 22, column 2 to column 14)",
                                                      " (in 'reduce_sum_m1.stan', line 6, column 6 to column 41)",
                                                      " (in 'reduce_sum_m1.stan', line 5, column 11 to line 7, column 5)",
                                                      " (in 'reduce_sum_m1.stan', line 4, column 6 to column 39)",
                                                      " (in 'reduce_sum_m1.stan', line 3, column 26 to line 5, column 5)",
                                                      " (in 'reduce_sum_m1.stan', line 3, column 4 to line 7, column 5)",
                                                      " (in 'reduce_sum_m1.stan', line 2, column 45 to line 8, column 3)",
                                                      " (in 'reduce_sum_m1.stan', line 13, column 6 to column 35)",
                                                      " (in 'reduce_sum_m1.stan', line 12, column 11 to line 14, column 5)",
                                                      " (in 'reduce_sum_m1.stan', line 11, column 6 to column 53)",
                                                      " (in 'reduce_sum_m1.stan', line 10, column 20 to line 12, column 5)",
                                                      " (in 'reduce_sum_m1.stan', line 10, column 4 to line 14, column 5)",
                                                      " (in 'reduce_sum_m1.stan', line 9, column 55 to line 15, column 3)",
                                                      " (in 'reduce_sum_m1.stan', line 17, column 4 to column 38)",
                                                      " (in 'reduce_sum_m1.stan', line 16, column 52 to line 18, column 3)"};

struct foo_lpdf_rsfunctor__;
struct g_rsfunctor__;
struct h_rsfunctor__;
template <typename T0__>
stan::promote_args_t<T0__>
g(const std::vector<T0__>& y_slice, const int& start, const int& end,
  std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 12;
    if (logical_gt(size(y_slice), 1)) {
      current_statement__ = 10;
      return reduce_sum<g_rsfunctor__>(y_slice, 1, pstream__);
    } else {
      current_statement__ = 8;
      return normal_lpdf<false>(y_slice, 0, 1);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return g(y_slice, start, end, pstream__);
}
};


struct g_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return g(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
h(const std::vector<T0__>& y_slice, const int& start, const int& end,
  const std::vector<T3__>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 18;
    if (logical_gt(size(a), 1)) {
      current_statement__ = 16;
      return reduce_sum<h_rsfunctor__>(y_slice, 1, pstream__,
               rvalue(a,
                 cons_list(index_min_max(start, end), nil_index_list()), "a"));
    } else {
      current_statement__ = 14;
      return normal_lpdf<false>(a, 0, 1);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct h_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, const std::vector<T3__>& a,
           std::ostream* pstream__)  const 
{
return h(y_slice, start, end, a, pstream__);
}
};


struct h_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__,
           const std::vector<T3__>& a)  const 
{
return h(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <bool propto__, typename T0__>
stan::promote_args_t<T0__>
foo_lpdf(const std::vector<T0__>& y_slice, const int& start, const int& end,
         std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 20;
    return normal_lpdf<false>(y_slice, 0, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_lpdf_functor__ {
template <bool propto__, typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return foo_lpdf(y_slice, start, end, pstream__);
}
};


struct foo_lpdf_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return foo_lpdf<false>(y_slice, start + 1, end + 1, pstream__);
}
};

class reduce_sum_m1_model : public model_base_crtp<reduce_sum_m1_model> {

 private:
  int pos__;
  int N;
 
 public:
  ~reduce_sum_m1_model() { }
  
  std::string model_name() const { return "reduce_sum_m1_model"; }
  
  reduce_sum_m1_model(stan::io::var_context& context__,
                      unsigned int random_seed__ = 0,
                      std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "reduce_sum_m1_model_namespace::reduce_sum_m1_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 7;
      N = 100;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      current_statement__ = 1;
      validate_non_negative_index("y1", "N", N);
      num_params_r__ += N;
      current_statement__ = 2;
      validate_non_negative_index("y2", "N", N);
      num_params_r__ += N;
      current_statement__ = 3;
      validate_non_negative_index("y3", "N", N);
      num_params_r__ += N;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  inline T__ log_prob(std::vector<T__>& params_r__,
                      std::vector<int>& params_i__,
                      std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "reduce_sum_m1_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      current_statement__ = 1;
      validate_non_negative_index("y1", "N", N);
      std::vector<local_scalar_t__> y1;
      y1 = std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 1;
        assign(y1, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable y1");}
      current_statement__ = 2;
      validate_non_negative_index("y2", "N", N);
      std::vector<local_scalar_t__> y2;
      y2 = std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 2;
        assign(y2, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable y2");}
      current_statement__ = 3;
      validate_non_negative_index("y3", "N", N);
      std::vector<local_scalar_t__> y3;
      y3 = std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 3;
        assign(y3, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable y3");}
      {
        current_statement__ = 4;
        lp_accum__.add(reduce_sum<g_rsfunctor__>(y1, 1, pstream__));
        current_statement__ = 5;
        lp_accum__.add(reduce_sum<h_rsfunctor__>(y2, 1, pstream__, y2));
        current_statement__ = 6;
        lp_accum__.add(reduce_sum<foo_lpdf_rsfunctor__>(y3, 1, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  inline void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                          std::vector<int>& params_i__,
                          std::vector<double>& vars__,
                          bool emit_transformed_parameters__ = true,
                          bool emit_generated_quantities__ = true,
                          std::ostream* pstream__ = 0) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "reduce_sum_m1_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      current_statement__ = 1;
      validate_non_negative_index("y1", "N", N);
      std::vector<double> y1;
      y1 = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 1;
        assign(y1, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable y1");}
      current_statement__ = 2;
      validate_non_negative_index("y2", "N", N);
      std::vector<double> y2;
      y2 = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 2;
        assign(y2, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable y2");}
      current_statement__ = 3;
      validate_non_negative_index("y3", "N", N);
      std::vector<double> y3;
      y3 = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 3;
        assign(y3, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable y3");}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y1[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y2[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y3[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  inline void transform_inits(const stan::io::var_context& context__,
                              std::vector<int>& params_i__,
                              std::vector<double>& vars__,
                              std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 1;
      validate_non_negative_index("y1", "N", N);
      std::vector<double> y1;
      y1 = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      assign(y1, nil_index_list(), context__.vals_r("y1"),
        "assigning variable y1");
      current_statement__ = 2;
      validate_non_negative_index("y2", "N", N);
      std::vector<double> y2;
      y2 = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      assign(y2, nil_index_list(), context__.vals_r("y2"),
        "assigning variable y2");
      current_statement__ = 3;
      validate_non_negative_index("y3", "N", N);
      std::vector<double> y3;
      y3 = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      assign(y3, nil_index_list(), context__.vals_r("y3"),
        "assigning variable y3");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y1[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y2[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y3[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("y1");
    names__.push_back("y2");
    names__.push_back("y3");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const {
    
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y1" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y2" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y3" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const {
    
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y1" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y2" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y3" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"y1\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y2\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y3\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"y1\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y2\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y3\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef reduce_sum_m1_model_namespace::reduce_sum_m1_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp reduce_sum_m2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace reduce_sum_m2_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'reduce_sum_m2.stan', line 130, column 2 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 131, column 2 to column 25)",
                                                      " (in 'reduce_sum_m2.stan', line 132, column 2 to column 21)",
                                                      " (in 'reduce_sum_m2.stan', line 133, column 2 to column 16)",
                                                      " (in 'reduce_sum_m2.stan', line 134, column 2 to column 21)",
                                                      " (in 'reduce_sum_m2.stan', line 135, column 2 to column 22)",
                                                      " (in 'reduce_sum_m2.stan', line 136, column 2 to column 18)",
                                                      " (in 'reduce_sum_m2.stan', line 137, column 2 to column 13)",
                                                      " (in 'reduce_sum_m2.stan', line 139, column 2 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 140, column 2 to column 25)",
                                                      " (in 'reduce_sum_m2.stan', line 141, column 2 to column 21)",
                                                      " (in 'reduce_sum_m2.stan', line 142, column 2 to column 16)",
                                                      " (in 'reduce_sum_m2.stan', line 143, column 2 to column 21)",
                                                      " (in 'reduce_sum_m2.stan', line 144, column 2 to column 22)",
                                                      " (in 'reduce_sum_m2.stan', line 145, column 2 to column 18)",
                                                      " (in 'reduce_sum_m2.stan', line 146, column 2 to column 13)",
                                                      " (in 'reduce_sum_m2.stan', line 150, column 2 to column 37)",
                                                      " (in 'reduce_sum_m2.stan', line 151, column 2 to column 37)",
                                                      " (in 'reduce_sum_m2.stan', line 152, column 2 to column 37)",
                                                      " (in 'reduce_sum_m2.stan', line 153, column 2 to column 37)",
                                                      " (in 'reduce_sum_m2.stan', line 154, column 2 to column 37)",
                                                      " (in 'reduce_sum_m2.stan', line 155, column 2 to column 37)",
                                                      " (in 'reduce_sum_m2.stan', line 156, column 2 to column 37)",
                                                      " (in 'reduce_sum_m2.stan', line 157, column 2 to column 37)",
                                                      " (in 'reduce_sum_m2.stan', line 159, column 2 to column 34)",
                                                      " (in 'reduce_sum_m2.stan', line 160, column 2 to column 34)",
                                                      " (in 'reduce_sum_m2.stan', line 161, column 2 to column 34)",
                                                      " (in 'reduce_sum_m2.stan', line 162, column 2 to column 34)",
                                                      " (in 'reduce_sum_m2.stan', line 163, column 2 to column 34)",
                                                      " (in 'reduce_sum_m2.stan', line 164, column 2 to column 34)",
                                                      " (in 'reduce_sum_m2.stan', line 165, column 2 to column 34)",
                                                      " (in 'reduce_sum_m2.stan', line 166, column 2 to column 34)",
                                                      " (in 'reduce_sum_m2.stan', line 125, column 2 to column 12)",
                                                      " (in 'reduce_sum_m2.stan', line 126, column 2 to column 12)",
                                                      " (in 'reduce_sum_m2.stan', line 3, column 4 to column 39)",
                                                      " (in 'reduce_sum_m2.stan', line 2, column 46 to line 4, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 6, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 8, column 6 to column 49)",
                                                      " (in 'reduce_sum_m2.stan', line 7, column 30 to line 9, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 7, column 4 to line 9, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 10, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 5, column 48 to line 11, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 13, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 15, column 6 to column 49)",
                                                      " (in 'reduce_sum_m2.stan', line 14, column 30 to line 16, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 14, column 4 to line 16, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 17, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 12, column 52 to line 18, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 20, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 22, column 6 to column 60)",
                                                      " (in 'reduce_sum_m2.stan', line 21, column 30 to line 23, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 21, column 4 to line 23, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 24, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 19, column 48 to line 25, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 27, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 30, column 8 to column 54)",
                                                      " (in 'reduce_sum_m2.stan', line 29, column 35 to line 31, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 29, column 6 to line 31, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 28, column 30 to line 32, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 28, column 4 to line 32, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 33, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 26, column 47 to line 34, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 36, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 39, column 8 to column 65)",
                                                      " (in 'reduce_sum_m2.stan', line 38, column 35 to line 40, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 38, column 6 to line 40, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 37, column 30 to line 41, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 37, column 4 to line 41, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 42, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 35, column 49 to line 43, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 45, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 48, column 8 to column 65)",
                                                      " (in 'reduce_sum_m2.stan', line 47, column 35 to line 49, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 47, column 6 to line 49, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 46, column 30 to line 50, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 46, column 4 to line 50, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 51, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 44, column 53 to line 52, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 54, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 57, column 8 to column 65)",
                                                      " (in 'reduce_sum_m2.stan', line 56, column 35 to line 58, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 56, column 6 to line 58, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 55, column 30 to line 59, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 55, column 4 to line 59, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 60, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 53, column 49 to line 61, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 63, column 4 to column 44)",
                                                      " (in 'reduce_sum_m2.stan', line 62, column 50 to line 64, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 66, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 68, column 6 to column 43)",
                                                      " (in 'reduce_sum_m2.stan', line 67, column 24 to line 69, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 67, column 4 to line 69, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 70, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 65, column 52 to line 71, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 73, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 75, column 6 to column 43)",
                                                      " (in 'reduce_sum_m2.stan', line 74, column 24 to line 76, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 74, column 4 to line 76, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 77, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 72, column 56 to line 78, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 80, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 82, column 6 to column 54)",
                                                      " (in 'reduce_sum_m2.stan', line 81, column 24 to line 83, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 81, column 4 to line 83, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 84, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 79, column 52 to line 85, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 87, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 90, column 8 to column 48)",
                                                      " (in 'reduce_sum_m2.stan', line 89, column 29 to line 91, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 89, column 6 to line 91, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 88, column 24 to line 92, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 88, column 4 to line 92, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 93, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 86, column 51 to line 94, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 96, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 99, column 8 to column 59)",
                                                      " (in 'reduce_sum_m2.stan', line 98, column 29 to line 100, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 98, column 6 to line 100, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 97, column 24 to line 101, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 97, column 4 to line 101, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 102, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 95, column 53 to line 103, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 105, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 108, column 8 to column 59)",
                                                      " (in 'reduce_sum_m2.stan', line 107, column 29 to line 109, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 107, column 6 to line 109, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 106, column 24 to line 110, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 106, column 4 to line 110, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 111, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 104, column 57 to line 112, column 3)",
                                                      " (in 'reduce_sum_m2.stan', line 114, column 4 to column 24)",
                                                      " (in 'reduce_sum_m2.stan', line 117, column 8 to column 59)",
                                                      " (in 'reduce_sum_m2.stan', line 116, column 29 to line 118, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 116, column 6 to line 118, column 7)",
                                                      " (in 'reduce_sum_m2.stan', line 115, column 24 to line 119, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 115, column 4 to line 119, column 5)",
                                                      " (in 'reduce_sum_m2.stan', line 120, column 4 to column 20)",
                                                      " (in 'reduce_sum_m2.stan', line 113, column 53 to line 121, column 3)"};

struct g1_rsfunctor__;
struct g2_rsfunctor__;
struct g3_rsfunctor__;
struct g4_rsfunctor__;
struct g5_rsfunctor__;
struct g6_rsfunctor__;
struct g7_rsfunctor__;
struct g8_rsfunctor__;
struct h1_rsfunctor__;
struct h2_rsfunctor__;
struct h3_rsfunctor__;
struct h4_rsfunctor__;
struct h5_rsfunctor__;
struct h6_rsfunctor__;
struct h7_rsfunctor__;
struct h8_rsfunctor__;
template <typename T0__>
stan::promote_args_t<T0__>
g1(const std::vector<T0__>& y_slice, const int& start, const int& end,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 35;
    return normal_lpdf<false>(y_slice, 0, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g1_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return g1(y_slice, start, end, pstream__);
}
};


struct g1_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return g1(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
g2(const std::vector<Eigen::Matrix<T0__, -1, 1>>& y_slice, const int& start,
   const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 37;
    sum_lpdf = 0.0;
    current_statement__ = 40;
    for (int n = 1; n <= size(y_slice); ++n) {
      current_statement__ = 38;
      sum_lpdf = (sum_lpdf +
                   normal_lpdf<false>(
                     rvalue(y_slice,
                       cons_list(index_uni(n), nil_index_list()), "y_slice"),
                     0, 1));}
    current_statement__ = 41;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g2_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<Eigen::Matrix<T0__, -1, 1>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return g2(y_slice, start, end, pstream__);
}
};


struct g2_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<Eigen::Matrix<T0__, -1, 1>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return g2(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
g3(const std::vector<Eigen::Matrix<T0__, 1, -1>>& y_slice, const int& start,
   const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 43;
    sum_lpdf = 0.0;
    current_statement__ = 46;
    for (int n = 1; n <= size(y_slice); ++n) {
      current_statement__ = 44;
      sum_lpdf = (sum_lpdf +
                   normal_lpdf<false>(
                     rvalue(y_slice,
                       cons_list(index_uni(n), nil_index_list()), "y_slice"),
                     0, 1));}
    current_statement__ = 47;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g3_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<Eigen::Matrix<T0__, 1, -1>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return g3(y_slice, start, end, pstream__);
}
};


struct g3_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<Eigen::Matrix<T0__, 1, -1>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return g3(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
g4(const std::vector<Eigen::Matrix<T0__, -1, -1>>& y_slice, const int& start,
   const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 49;
    sum_lpdf = 0.0;
    current_statement__ = 52;
    for (int n = 1; n <= size(y_slice); ++n) {
      current_statement__ = 50;
      sum_lpdf = (sum_lpdf +
                   normal_lpdf<false>(
                     to_vector(
                       rvalue(y_slice,
                         cons_list(index_uni(n), nil_index_list()),
                         "y_slice")), 0, 1));}
    current_statement__ = 53;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g4_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<Eigen::Matrix<T0__, -1, -1>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return g4(y_slice, start, end, pstream__);
}
};


struct g4_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<Eigen::Matrix<T0__, -1, -1>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return g4(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
g5(const std::vector<std::vector<T0__>>& y_slice, const int& start,
   const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 55;
    sum_lpdf = 0.0;
    current_statement__ = 60;
    for (int n = 1; n <= size(y_slice); ++n) {
      current_statement__ = 58;
      for (int m = 1;
           m <= size(
                  rvalue(y_slice, cons_list(index_uni(n), nil_index_list()),
                    "y_slice")); ++m) {
        current_statement__ = 56;
        sum_lpdf = (sum_lpdf +
                     normal_lpdf<false>(
                       rvalue(y_slice,
                         cons_list(index_uni(n),
                           cons_list(index_uni(m), nil_index_list())),
                         "y_slice"), 0, 1));}}
    current_statement__ = 61;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g5_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<T0__>>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return g5(y_slice, start, end, pstream__);
}
};


struct g5_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<T0__>>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return g5(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
g6(const std::vector<std::vector<Eigen::Matrix<T0__, -1, 1>>>& y_slice,
   const int& start, const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 63;
    sum_lpdf = 0.0;
    current_statement__ = 68;
    for (int n = 1; n <= size(y_slice); ++n) {
      current_statement__ = 66;
      for (int m = 1;
           m <= size(
                  rvalue(y_slice, cons_list(index_uni(n), nil_index_list()),
                    "y_slice")); ++m) {
        current_statement__ = 64;
        sum_lpdf = (sum_lpdf +
                     normal_lpdf<false>(
                       to_vector(
                         rvalue(y_slice,
                           cons_list(index_uni(n),
                             cons_list(index_uni(m), nil_index_list())),
                           "y_slice")), 0, 1));}}
    current_statement__ = 69;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g6_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<Eigen::Matrix<T0__, -1, 1>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return g6(y_slice, start, end, pstream__);
}
};


struct g6_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<Eigen::Matrix<T0__, -1, 1>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return g6(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
g7(const std::vector<std::vector<Eigen::Matrix<T0__, 1, -1>>>& y_slice,
   const int& start, const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 71;
    sum_lpdf = 0.0;
    current_statement__ = 76;
    for (int n = 1; n <= size(y_slice); ++n) {
      current_statement__ = 74;
      for (int m = 1;
           m <= size(
                  rvalue(y_slice, cons_list(index_uni(n), nil_index_list()),
                    "y_slice")); ++m) {
        current_statement__ = 72;
        sum_lpdf = (sum_lpdf +
                     normal_lpdf<false>(
                       to_vector(
                         rvalue(y_slice,
                           cons_list(index_uni(n),
                             cons_list(index_uni(m), nil_index_list())),
                           "y_slice")), 0, 1));}}
    current_statement__ = 77;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g7_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<Eigen::Matrix<T0__, 1, -1>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return g7(y_slice, start, end, pstream__);
}
};


struct g7_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<Eigen::Matrix<T0__, 1, -1>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return g7(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
g8(const std::vector<std::vector<Eigen::Matrix<T0__, -1, -1>>>& y_slice,
   const int& start, const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 79;
    sum_lpdf = 0.0;
    current_statement__ = 84;
    for (int n = 1; n <= size(y_slice); ++n) {
      current_statement__ = 82;
      for (int m = 1;
           m <= size(
                  rvalue(y_slice, cons_list(index_uni(n), nil_index_list()),
                    "y_slice")); ++m) {
        current_statement__ = 80;
        sum_lpdf = (sum_lpdf +
                     normal_lpdf<false>(
                       to_vector(
                         rvalue(y_slice,
                           cons_list(index_uni(n),
                             cons_list(index_uni(m), nil_index_list())),
                           "y_slice")), 0, 1));}}
    current_statement__ = 85;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g8_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<Eigen::Matrix<T0__, -1, -1>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return g8(y_slice, start, end, pstream__);
}
};


struct g8_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<Eigen::Matrix<T0__, -1, -1>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return g8(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
h1(const std::vector<T0__>& y, const int& start, const int& end,
   const std::vector<T3__>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 87;
    return normal_lpdf<false>(
             rvalue(a,
               cons_list(index_min_max(start, end), nil_index_list()), "a"),
             0, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct h1_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           const std::vector<T3__>& a, std::ostream* pstream__)  const 
{
return h1(y, start, end, a, pstream__);
}
};


struct h1_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           std::ostream* pstream__, const std::vector<T3__>& a)  const 
{
return h1(y, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
h2(const std::vector<T0__>& y, const int& start, const int& end,
   const std::vector<Eigen::Matrix<T3__, -1, 1>>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 89;
    sum_lpdf = 0.0;
    current_statement__ = 92;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 90;
      sum_lpdf = (sum_lpdf +
                   normal_lpdf<false>(
                     rvalue(a, cons_list(index_uni(n), nil_index_list()),
                       "a"), 0, 1));}
    current_statement__ = 93;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct h2_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           const std::vector<Eigen::Matrix<T3__, -1, 1>>& a,
           std::ostream* pstream__)  const 
{
return h2(y, start, end, a, pstream__);
}
};


struct h2_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           std::ostream* pstream__,
           const std::vector<Eigen::Matrix<T3__, -1, 1>>& a)  const 
{
return h2(y, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
h3(const std::vector<T0__>& y, const int& start, const int& end,
   const std::vector<Eigen::Matrix<T3__, 1, -1>>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 95;
    sum_lpdf = 0.0;
    current_statement__ = 98;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 96;
      sum_lpdf = (sum_lpdf +
                   normal_lpdf<false>(
                     rvalue(a, cons_list(index_uni(n), nil_index_list()),
                       "a"), 0, 1));}
    current_statement__ = 99;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct h3_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           const std::vector<Eigen::Matrix<T3__, 1, -1>>& a,
           std::ostream* pstream__)  const 
{
return h3(y, start, end, a, pstream__);
}
};


struct h3_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           std::ostream* pstream__,
           const std::vector<Eigen::Matrix<T3__, 1, -1>>& a)  const 
{
return h3(y, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
h4(const std::vector<T0__>& y, const int& start, const int& end,
   const std::vector<Eigen::Matrix<T3__, -1, -1>>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 101;
    sum_lpdf = 0.0;
    current_statement__ = 104;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 102;
      sum_lpdf = (sum_lpdf +
                   normal_lpdf<false>(
                     to_vector(
                       rvalue(a, cons_list(index_uni(n), nil_index_list()),
                         "a")), 0, 1));}
    current_statement__ = 105;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct h4_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           const std::vector<Eigen::Matrix<T3__, -1, -1>>& a,
           std::ostream* pstream__)  const 
{
return h4(y, start, end, a, pstream__);
}
};


struct h4_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           std::ostream* pstream__,
           const std::vector<Eigen::Matrix<T3__, -1, -1>>& a)  const 
{
return h4(y, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
h5(const std::vector<T0__>& y, const int& start, const int& end,
   const std::vector<std::vector<T3__>>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 107;
    sum_lpdf = 0.0;
    current_statement__ = 112;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 110;
      for (int m = 1;
           m <= size(
                  rvalue(a, cons_list(index_uni(n), nil_index_list()), "a"));
           ++m) {
        current_statement__ = 108;
        sum_lpdf = (sum_lpdf +
                     normal_lpdf<false>(
                       rvalue(a,
                         cons_list(index_uni(n),
                           cons_list(index_uni(m), nil_index_list())), "a"),
                       0, 1));}}
    current_statement__ = 113;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct h5_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           const std::vector<std::vector<T3__>>& a, std::ostream* pstream__)  const 
{
return h5(y, start, end, a, pstream__);
}
};


struct h5_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           std::ostream* pstream__, const std::vector<std::vector<T3__>>& a)  const 
{
return h5(y, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
h6(const std::vector<T0__>& y, const int& start, const int& end,
   const std::vector<std::vector<Eigen::Matrix<T3__, -1, 1>>>& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 115;
    sum_lpdf = 0.0;
    current_statement__ = 120;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 118;
      for (int m = 1;
           m <= size(
                  rvalue(a, cons_list(index_uni(n), nil_index_list()), "a"));
           ++m) {
        current_statement__ = 116;
        sum_lpdf = (sum_lpdf +
                     normal_lpdf<false>(
                       to_vector(
                         rvalue(a,
                           cons_list(index_uni(n),
                             cons_list(index_uni(m), nil_index_list())), "a")),
                       0, 1));}}
    current_statement__ = 121;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct h6_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           const std::vector<std::vector<Eigen::Matrix<T3__, -1, 1>>>& a,
           std::ostream* pstream__)  const 
{
return h6(y, start, end, a, pstream__);
}
};


struct h6_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           std::ostream* pstream__,
           const std::vector<std::vector<Eigen::Matrix<T3__, -1, 1>>>& a)  const 
{
return h6(y, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
h7(const std::vector<T0__>& y, const int& start, const int& end,
   const std::vector<std::vector<Eigen::Matrix<T3__, 1, -1>>>& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 123;
    sum_lpdf = 0.0;
    current_statement__ = 128;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 126;
      for (int m = 1;
           m <= size(
                  rvalue(a, cons_list(index_uni(n), nil_index_list()), "a"));
           ++m) {
        current_statement__ = 124;
        sum_lpdf = (sum_lpdf +
                     normal_lpdf<false>(
                       to_vector(
                         rvalue(a,
                           cons_list(index_uni(n),
                             cons_list(index_uni(m), nil_index_list())), "a")),
                       0, 1));}}
    current_statement__ = 129;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct h7_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           const std::vector<std::vector<Eigen::Matrix<T3__, 1, -1>>>& a,
           std::ostream* pstream__)  const 
{
return h7(y, start, end, a, pstream__);
}
};


struct h7_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           std::ostream* pstream__,
           const std::vector<std::vector<Eigen::Matrix<T3__, 1, -1>>>& a)  const 
{
return h7(y, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
h8(const std::vector<T0__>& y, const int& start, const int& end,
   const std::vector<std::vector<Eigen::Matrix<T3__, -1, -1>>>& a,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ sum_lpdf;
    sum_lpdf = DUMMY_VAR__;
    
    current_statement__ = 131;
    sum_lpdf = 0.0;
    current_statement__ = 136;
    for (int n = start; n <= end; ++n) {
      current_statement__ = 134;
      for (int m = 1;
           m <= size(
                  rvalue(a, cons_list(index_uni(n), nil_index_list()), "a"));
           ++m) {
        current_statement__ = 132;
        sum_lpdf = (sum_lpdf +
                     normal_lpdf<false>(
                       to_vector(
                         rvalue(a,
                           cons_list(index_uni(n),
                             cons_list(index_uni(m), nil_index_list())), "a")),
                       0, 1));}}
    current_statement__ = 137;
    return sum_lpdf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct h8_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           const std::vector<std::vector<Eigen::Matrix<T3__, -1, -1>>>& a,
           std::ostream* pstream__)  const 
{
return h8(y, start, end, a, pstream__);
}
};


struct h8_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y, const int& start, const int& end,
           std::ostream* pstream__,
           const std::vector<std::vector<Eigen::Matrix<T3__, -1, -1>>>& a)  const 
{
return h8(y, start + 1, end + 1, a, pstream__);
}
};

class reduce_sum_m2_model : public model_base_crtp<reduce_sum_m2_model> {

 private:
  int pos__;
  int N;
  std::vector<double> x;
 
 public:
  ~reduce_sum_m2_model() { }
  
  std::string model_name() const { return "reduce_sum_m2_model"; }
  
  reduce_sum_m2_model(stan::io::var_context& context__,
                      unsigned int random_seed__ = 0,
                      std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "reduce_sum_m2_model_namespace::reduce_sum_m2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 33;
      N = 2;
      current_statement__ = 34;
      validate_non_negative_index("x", "N", N);
      x = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      num_params_r__ += N * N * N * N;
      current_statement__ = 2;
      validate_non_negative_index("a7", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("a7", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("a7", "N", N);
      num_params_r__ += N * N * N;
      current_statement__ = 3;
      validate_non_negative_index("a6", "N", N);
      current_statement__ = 3;
      validate_non_negative_index("a6", "N", N);
      current_statement__ = 3;
      validate_non_negative_index("a6", "N", N);
      num_params_r__ += N * N * N;
      current_statement__ = 4;
      validate_non_negative_index("a5", "N", N);
      current_statement__ = 4;
      validate_non_negative_index("a5", "N", N);
      num_params_r__ += N * N;
      current_statement__ = 5;
      validate_non_negative_index("a4", "N", N);
      current_statement__ = 5;
      validate_non_negative_index("a4", "N", N);
      current_statement__ = 5;
      validate_non_negative_index("a4", "N", N);
      num_params_r__ += N * N * N;
      current_statement__ = 6;
      validate_non_negative_index("a3", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("a3", "N", N);
      num_params_r__ += N * N;
      current_statement__ = 7;
      validate_non_negative_index("a2", "N", N);
      current_statement__ = 7;
      validate_non_negative_index("a2", "N", N);
      num_params_r__ += N * N;
      current_statement__ = 8;
      validate_non_negative_index("a1", "N", N);
      num_params_r__ += N;
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      num_params_r__ += N * N * N * N;
      current_statement__ = 10;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 10;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 10;
      validate_non_negative_index("y7", "N", N);
      num_params_r__ += N * N * N;
      current_statement__ = 11;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("y6", "N", N);
      num_params_r__ += N * N * N;
      current_statement__ = 12;
      validate_non_negative_index("y5", "N", N);
      current_statement__ = 12;
      validate_non_negative_index("y5", "N", N);
      num_params_r__ += N * N;
      current_statement__ = 13;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y4", "N", N);
      num_params_r__ += N * N * N;
      current_statement__ = 14;
      validate_non_negative_index("y3", "N", N);
      current_statement__ = 14;
      validate_non_negative_index("y3", "N", N);
      num_params_r__ += N * N;
      current_statement__ = 15;
      validate_non_negative_index("y2", "N", N);
      current_statement__ = 15;
      validate_non_negative_index("y2", "N", N);
      num_params_r__ += N * N;
      current_statement__ = 16;
      validate_non_negative_index("y1", "N", N);
      num_params_r__ += N;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  inline T__ log_prob(std::vector<T__>& params_r__,
                      std::vector<int>& params_i__,
                      std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "reduce_sum_m2_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>> a8;
      a8 = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(N, Eigen::Matrix<local_scalar_t__, -1, -1>(N, N)));
      stan::math::fill(a8, DUMMY_VAR__);
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 1;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 1;
          assign(a8,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.matrix(N, N), "assigning variable a8");}}
      current_statement__ = 2;
      validate_non_negative_index("a7", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("a7", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("a7", "N", N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>> a7;
      a7 = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(N, Eigen::Matrix<local_scalar_t__, 1, -1>(N)));
      stan::math::fill(a7, DUMMY_VAR__);
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 2;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 2;
          assign(a7,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.row_vector(N), "assigning variable a7");}}
      current_statement__ = 3;
      validate_non_negative_index("a6", "N", N);
      current_statement__ = 3;
      validate_non_negative_index("a6", "N", N);
      current_statement__ = 3;
      validate_non_negative_index("a6", "N", N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> a6;
      a6 = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N)));
      stan::math::fill(a6, DUMMY_VAR__);
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 3;
          assign(a6,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.vector(N), "assigning variable a6");}}
      current_statement__ = 4;
      validate_non_negative_index("a5", "N", N);
      current_statement__ = 4;
      validate_non_negative_index("a5", "N", N);
      std::vector<std::vector<local_scalar_t__>> a5;
      a5 = std::vector<std::vector<local_scalar_t__>>(N, std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 4;
          assign(a5,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())), in__.scalar(),
            "assigning variable a5");}}
      current_statement__ = 5;
      validate_non_negative_index("a4", "N", N);
      current_statement__ = 5;
      validate_non_negative_index("a4", "N", N);
      current_statement__ = 5;
      validate_non_negative_index("a4", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> a4;
      a4 = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(N, Eigen::Matrix<local_scalar_t__, -1, -1>(N, N));
      stan::math::fill(a4, DUMMY_VAR__);
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 5;
        assign(a4, cons_list(index_uni(sym1__), nil_index_list()),
          in__.matrix(N, N), "assigning variable a4");}
      current_statement__ = 6;
      validate_non_negative_index("a3", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("a3", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>> a3;
      a3 = std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(N, Eigen::Matrix<local_scalar_t__, 1, -1>(N));
      stan::math::fill(a3, DUMMY_VAR__);
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 6;
        assign(a3, cons_list(index_uni(sym1__), nil_index_list()),
          in__.row_vector(N), "assigning variable a3");}
      current_statement__ = 7;
      validate_non_negative_index("a2", "N", N);
      current_statement__ = 7;
      validate_non_negative_index("a2", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> a2;
      a2 = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N));
      stan::math::fill(a2, DUMMY_VAR__);
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 7;
        assign(a2, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(N), "assigning variable a2");}
      current_statement__ = 8;
      validate_non_negative_index("a1", "N", N);
      std::vector<local_scalar_t__> a1;
      a1 = std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 8;
        assign(a1, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable a1");}
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>> y8;
      y8 = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(N, Eigen::Matrix<local_scalar_t__, -1, -1>(N, N)));
      stan::math::fill(y8, DUMMY_VAR__);
      
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 9;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 9;
          assign(y8,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.matrix(N, N), "assigning variable y8");}}
      current_statement__ = 10;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 10;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 10;
      validate_non_negative_index("y7", "N", N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>> y7;
      y7 = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(N, Eigen::Matrix<local_scalar_t__, 1, -1>(N)));
      stan::math::fill(y7, DUMMY_VAR__);
      
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 10;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 10;
          assign(y7,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.row_vector(N), "assigning variable y7");}}
      current_statement__ = 11;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("y6", "N", N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> y6;
      y6 = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N)));
      stan::math::fill(y6, DUMMY_VAR__);
      
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 11;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 11;
          assign(y6,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.vector(N), "assigning variable y6");}}
      current_statement__ = 12;
      validate_non_negative_index("y5", "N", N);
      current_statement__ = 12;
      validate_non_negative_index("y5", "N", N);
      std::vector<std::vector<local_scalar_t__>> y5;
      y5 = std::vector<std::vector<local_scalar_t__>>(N, std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 12;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 12;
          assign(y5,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())), in__.scalar(),
            "assigning variable y5");}}
      current_statement__ = 13;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y4", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> y4;
      y4 = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(N, Eigen::Matrix<local_scalar_t__, -1, -1>(N, N));
      stan::math::fill(y4, DUMMY_VAR__);
      
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 13;
        assign(y4, cons_list(index_uni(sym1__), nil_index_list()),
          in__.matrix(N, N), "assigning variable y4");}
      current_statement__ = 14;
      validate_non_negative_index("y3", "N", N);
      current_statement__ = 14;
      validate_non_negative_index("y3", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>> y3;
      y3 = std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(N, Eigen::Matrix<local_scalar_t__, 1, -1>(N));
      stan::math::fill(y3, DUMMY_VAR__);
      
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 14;
        assign(y3, cons_list(index_uni(sym1__), nil_index_list()),
          in__.row_vector(N), "assigning variable y3");}
      current_statement__ = 15;
      validate_non_negative_index("y2", "N", N);
      current_statement__ = 15;
      validate_non_negative_index("y2", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> y2;
      y2 = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N));
      stan::math::fill(y2, DUMMY_VAR__);
      
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 15;
        assign(y2, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(N), "assigning variable y2");}
      current_statement__ = 16;
      validate_non_negative_index("y1", "N", N);
      std::vector<local_scalar_t__> y1;
      y1 = std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 16;
        assign(y1, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable y1");}
      {
        current_statement__ = 17;
        lp_accum__.add(reduce_sum<h8_rsfunctor__>(x, 1, pstream__, a8));
        current_statement__ = 18;
        lp_accum__.add(reduce_sum<h7_rsfunctor__>(x, 1, pstream__, a7));
        current_statement__ = 19;
        lp_accum__.add(reduce_sum<h6_rsfunctor__>(x, 1, pstream__, a6));
        current_statement__ = 20;
        lp_accum__.add(reduce_sum<h5_rsfunctor__>(x, 1, pstream__, a5));
        current_statement__ = 21;
        lp_accum__.add(reduce_sum<h4_rsfunctor__>(x, 1, pstream__, a4));
        current_statement__ = 22;
        lp_accum__.add(reduce_sum<h3_rsfunctor__>(x, 1, pstream__, a3));
        current_statement__ = 23;
        lp_accum__.add(reduce_sum<h2_rsfunctor__>(x, 1, pstream__, a2));
        current_statement__ = 24;
        lp_accum__.add(reduce_sum<h1_rsfunctor__>(x, 1, pstream__, a1));
        current_statement__ = 25;
        lp_accum__.add(reduce_sum<g8_rsfunctor__>(y8, 1, pstream__));
        current_statement__ = 26;
        lp_accum__.add(reduce_sum<g7_rsfunctor__>(y7, 1, pstream__));
        current_statement__ = 27;
        lp_accum__.add(reduce_sum<g6_rsfunctor__>(y6, 1, pstream__));
        current_statement__ = 28;
        lp_accum__.add(reduce_sum<g5_rsfunctor__>(y5, 1, pstream__));
        current_statement__ = 29;
        lp_accum__.add(reduce_sum<g4_rsfunctor__>(y4, 1, pstream__));
        current_statement__ = 30;
        lp_accum__.add(reduce_sum<g3_rsfunctor__>(y3, 1, pstream__));
        current_statement__ = 31;
        lp_accum__.add(reduce_sum<g2_rsfunctor__>(y2, 1, pstream__));
        current_statement__ = 32;
        lp_accum__.add(reduce_sum<g1_rsfunctor__>(y1, 1, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  inline void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                          std::vector<int>& params_i__,
                          std::vector<double>& vars__,
                          bool emit_transformed_parameters__ = true,
                          bool emit_generated_quantities__ = true,
                          std::ostream* pstream__ = 0) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "reduce_sum_m2_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> a8;
      a8 = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(N, std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N)));
      stan::math::fill(a8, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 1;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 1;
          assign(a8,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.matrix(N, N), "assigning variable a8");}}
      current_statement__ = 2;
      validate_non_negative_index("a7", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("a7", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("a7", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, 1, -1>>> a7;
      a7 = std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(N, std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N)));
      stan::math::fill(a7, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 2;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 2;
          assign(a7,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.row_vector(N), "assigning variable a7");}}
      current_statement__ = 3;
      validate_non_negative_index("a6", "N", N);
      current_statement__ = 3;
      validate_non_negative_index("a6", "N", N);
      current_statement__ = 3;
      validate_non_negative_index("a6", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> a6;
      a6 = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(N, std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N)));
      stan::math::fill(a6, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 3;
          assign(a6,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.vector(N), "assigning variable a6");}}
      current_statement__ = 4;
      validate_non_negative_index("a5", "N", N);
      current_statement__ = 4;
      validate_non_negative_index("a5", "N", N);
      std::vector<std::vector<double>> a5;
      a5 = std::vector<std::vector<double>>(N, std::vector<double>(N, std::numeric_limits<double>::quiet_NaN()));
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 4;
          assign(a5,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())), in__.scalar(),
            "assigning variable a5");}}
      current_statement__ = 5;
      validate_non_negative_index("a4", "N", N);
      current_statement__ = 5;
      validate_non_negative_index("a4", "N", N);
      current_statement__ = 5;
      validate_non_negative_index("a4", "N", N);
      std::vector<Eigen::Matrix<double, -1, -1>> a4;
      a4 = std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N));
      stan::math::fill(a4, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 5;
        assign(a4, cons_list(index_uni(sym1__), nil_index_list()),
          in__.matrix(N, N), "assigning variable a4");}
      current_statement__ = 6;
      validate_non_negative_index("a3", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("a3", "N", N);
      std::vector<Eigen::Matrix<double, 1, -1>> a3;
      a3 = std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N));
      stan::math::fill(a3, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 6;
        assign(a3, cons_list(index_uni(sym1__), nil_index_list()),
          in__.row_vector(N), "assigning variable a3");}
      current_statement__ = 7;
      validate_non_negative_index("a2", "N", N);
      current_statement__ = 7;
      validate_non_negative_index("a2", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> a2;
      a2 = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(a2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 7;
        assign(a2, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(N), "assigning variable a2");}
      current_statement__ = 8;
      validate_non_negative_index("a1", "N", N);
      std::vector<double> a1;
      a1 = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 8;
        assign(a1, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable a1");}
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> y8;
      y8 = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(N, std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N)));
      stan::math::fill(y8, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 9;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 9;
          assign(y8,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.matrix(N, N), "assigning variable y8");}}
      current_statement__ = 10;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 10;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 10;
      validate_non_negative_index("y7", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, 1, -1>>> y7;
      y7 = std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(N, std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N)));
      stan::math::fill(y7, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 10;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 10;
          assign(y7,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.row_vector(N), "assigning variable y7");}}
      current_statement__ = 11;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("y6", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> y6;
      y6 = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(N, std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N)));
      stan::math::fill(y6, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 11;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 11;
          assign(y6,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.vector(N), "assigning variable y6");}}
      current_statement__ = 12;
      validate_non_negative_index("y5", "N", N);
      current_statement__ = 12;
      validate_non_negative_index("y5", "N", N);
      std::vector<std::vector<double>> y5;
      y5 = std::vector<std::vector<double>>(N, std::vector<double>(N, std::numeric_limits<double>::quiet_NaN()));
      
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 12;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 12;
          assign(y5,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())), in__.scalar(),
            "assigning variable y5");}}
      current_statement__ = 13;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y4", "N", N);
      std::vector<Eigen::Matrix<double, -1, -1>> y4;
      y4 = std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N));
      stan::math::fill(y4, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 13;
        assign(y4, cons_list(index_uni(sym1__), nil_index_list()),
          in__.matrix(N, N), "assigning variable y4");}
      current_statement__ = 14;
      validate_non_negative_index("y3", "N", N);
      current_statement__ = 14;
      validate_non_negative_index("y3", "N", N);
      std::vector<Eigen::Matrix<double, 1, -1>> y3;
      y3 = std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N));
      stan::math::fill(y3, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 14;
        assign(y3, cons_list(index_uni(sym1__), nil_index_list()),
          in__.row_vector(N), "assigning variable y3");}
      current_statement__ = 15;
      validate_non_negative_index("y2", "N", N);
      current_statement__ = 15;
      validate_non_negative_index("y2", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> y2;
      y2 = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(y2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 15;
        assign(y2, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(N), "assigning variable y2");}
      current_statement__ = 16;
      validate_non_negative_index("y1", "N", N);
      std::vector<double> y1;
      y1 = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 16;
        assign(y1, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable y1");}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                rvalue(a8,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  "a8"));}}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(a7[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(a6[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(a5[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(
              rvalue(a4,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))), "a4"));
          }}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(a3[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(a2[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(a1[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                rvalue(y8,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  "y8"));}}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(y7[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(y6[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(y5[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(
              rvalue(y4,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))), "y4"));
          }}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(y3[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(y2[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y1[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  inline void transform_inits(const stan::io::var_context& context__,
                              std::vector<int>& params_i__,
                              std::vector<double>& vars__,
                              std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("a8", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> a8;
      a8 = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(N, std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N)));
      stan::math::fill(a8, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> a8_flat__;
        current_statement__ = 1;
        assign(a8_flat__, nil_index_list(), context__.vals_r("a8"),
          "assigning variable a8_flat__");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 1;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 1;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 1;
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                current_statement__ = 1;
                assign(a8,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  a8_flat__[(pos__ - 1)], "assigning variable a8");
                current_statement__ = 1;
                pos__ = (pos__ + 1);}}}}
      }
      current_statement__ = 2;
      validate_non_negative_index("a7", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("a7", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("a7", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, 1, -1>>> a7;
      a7 = std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(N, std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N)));
      stan::math::fill(a7, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> a7_flat__;
        current_statement__ = 2;
        assign(a7_flat__, nil_index_list(), context__.vals_r("a7"),
          "assigning variable a7_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 2;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 2;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 2;
              assign(a7,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                a7_flat__[(pos__ - 1)], "assigning variable a7");
              current_statement__ = 2;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 3;
      validate_non_negative_index("a6", "N", N);
      current_statement__ = 3;
      validate_non_negative_index("a6", "N", N);
      current_statement__ = 3;
      validate_non_negative_index("a6", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> a6;
      a6 = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(N, std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N)));
      stan::math::fill(a6, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> a6_flat__;
        current_statement__ = 3;
        assign(a6_flat__, nil_index_list(), context__.vals_r("a6"),
          "assigning variable a6_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 3;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 3;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 3;
              assign(a6,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                a6_flat__[(pos__ - 1)], "assigning variable a6");
              current_statement__ = 3;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 4;
      validate_non_negative_index("a5", "N", N);
      current_statement__ = 4;
      validate_non_negative_index("a5", "N", N);
      std::vector<std::vector<double>> a5;
      a5 = std::vector<std::vector<double>>(N, std::vector<double>(N, std::numeric_limits<double>::quiet_NaN()));
      
      {
        std::vector<local_scalar_t__> a5_flat__;
        current_statement__ = 4;
        assign(a5_flat__, nil_index_list(), context__.vals_r("a5"),
          "assigning variable a5_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 4;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 4;
            assign(a5,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              a5_flat__[(pos__ - 1)], "assigning variable a5");
            current_statement__ = 4;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 5;
      validate_non_negative_index("a4", "N", N);
      current_statement__ = 5;
      validate_non_negative_index("a4", "N", N);
      current_statement__ = 5;
      validate_non_negative_index("a4", "N", N);
      std::vector<Eigen::Matrix<double, -1, -1>> a4;
      a4 = std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N));
      stan::math::fill(a4, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> a4_flat__;
        current_statement__ = 5;
        assign(a4_flat__, nil_index_list(), context__.vals_r("a4"),
          "assigning variable a4_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 5;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 5;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 5;
              assign(a4,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                a4_flat__[(pos__ - 1)], "assigning variable a4");
              current_statement__ = 5;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 6;
      validate_non_negative_index("a3", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("a3", "N", N);
      std::vector<Eigen::Matrix<double, 1, -1>> a3;
      a3 = std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N));
      stan::math::fill(a3, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> a3_flat__;
        current_statement__ = 6;
        assign(a3_flat__, nil_index_list(), context__.vals_r("a3"),
          "assigning variable a3_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 6;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 6;
            assign(a3,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              a3_flat__[(pos__ - 1)], "assigning variable a3");
            current_statement__ = 6;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 7;
      validate_non_negative_index("a2", "N", N);
      current_statement__ = 7;
      validate_non_negative_index("a2", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> a2;
      a2 = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(a2, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> a2_flat__;
        current_statement__ = 7;
        assign(a2_flat__, nil_index_list(), context__.vals_r("a2"),
          "assigning variable a2_flat__");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 7;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 7;
            assign(a2,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              a2_flat__[(pos__ - 1)], "assigning variable a2");
            current_statement__ = 7;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 8;
      validate_non_negative_index("a1", "N", N);
      std::vector<double> a1;
      a1 = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      assign(a1, nil_index_list(), context__.vals_r("a1"),
        "assigning variable a1");
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("y8", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> y8;
      y8 = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(N, std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N)));
      stan::math::fill(y8, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y8_flat__;
        current_statement__ = 9;
        assign(y8_flat__, nil_index_list(), context__.vals_r("y8"),
          "assigning variable y8_flat__");
        current_statement__ = 9;
        pos__ = 1;
        current_statement__ = 9;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 9;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 9;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 9;
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                current_statement__ = 9;
                assign(y8,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  y8_flat__[(pos__ - 1)], "assigning variable y8");
                current_statement__ = 9;
                pos__ = (pos__ + 1);}}}}
      }
      current_statement__ = 10;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 10;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 10;
      validate_non_negative_index("y7", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, 1, -1>>> y7;
      y7 = std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(N, std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N)));
      stan::math::fill(y7, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y7_flat__;
        current_statement__ = 10;
        assign(y7_flat__, nil_index_list(), context__.vals_r("y7"),
          "assigning variable y7_flat__");
        current_statement__ = 10;
        pos__ = 1;
        current_statement__ = 10;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 10;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 10;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 10;
              assign(y7,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                y7_flat__[(pos__ - 1)], "assigning variable y7");
              current_statement__ = 10;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 11;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("y6", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> y6;
      y6 = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(N, std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N)));
      stan::math::fill(y6, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y6_flat__;
        current_statement__ = 11;
        assign(y6_flat__, nil_index_list(), context__.vals_r("y6"),
          "assigning variable y6_flat__");
        current_statement__ = 11;
        pos__ = 1;
        current_statement__ = 11;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 11;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 11;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 11;
              assign(y6,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                y6_flat__[(pos__ - 1)], "assigning variable y6");
              current_statement__ = 11;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 12;
      validate_non_negative_index("y5", "N", N);
      current_statement__ = 12;
      validate_non_negative_index("y5", "N", N);
      std::vector<std::vector<double>> y5;
      y5 = std::vector<std::vector<double>>(N, std::vector<double>(N, std::numeric_limits<double>::quiet_NaN()));
      
      {
        std::vector<local_scalar_t__> y5_flat__;
        current_statement__ = 12;
        assign(y5_flat__, nil_index_list(), context__.vals_r("y5"),
          "assigning variable y5_flat__");
        current_statement__ = 12;
        pos__ = 1;
        current_statement__ = 12;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 12;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 12;
            assign(y5,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y5_flat__[(pos__ - 1)], "assigning variable y5");
            current_statement__ = 12;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 13;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y4", "N", N);
      std::vector<Eigen::Matrix<double, -1, -1>> y4;
      y4 = std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N));
      stan::math::fill(y4, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y4_flat__;
        current_statement__ = 13;
        assign(y4_flat__, nil_index_list(), context__.vals_r("y4"),
          "assigning variable y4_flat__");
        current_statement__ = 13;
        pos__ = 1;
        current_statement__ = 13;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 13;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 13;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 13;
              assign(y4,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                y4_flat__[(pos__ - 1)], "assigning variable y4");
              current_statement__ = 13;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 14;
      validate_non_negative_index("y3", "N", N);
      current_statement__ = 14;
      validate_non_negative_index("y3", "N", N);
      std::vector<Eigen::Matrix<double, 1, -1>> y3;
      y3 = std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N));
      stan::math::fill(y3, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y3_flat__;
        current_statement__ = 14;
        assign(y3_flat__, nil_index_list(), context__.vals_r("y3"),
          "assigning variable y3_flat__");
        current_statement__ = 14;
        pos__ = 1;
        current_statement__ = 14;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 14;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 14;
            assign(y3,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y3_flat__[(pos__ - 1)], "assigning variable y3");
            current_statement__ = 14;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 15;
      validate_non_negative_index("y2", "N", N);
      current_statement__ = 15;
      validate_non_negative_index("y2", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> y2;
      y2 = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(y2, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2_flat__;
        current_statement__ = 15;
        assign(y2_flat__, nil_index_list(), context__.vals_r("y2"),
          "assigning variable y2_flat__");
        current_statement__ = 15;
        pos__ = 1;
        current_statement__ = 15;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 15;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 15;
            assign(y2,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y2_flat__[(pos__ - 1)], "assigning variable y2");
            current_statement__ = 15;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 16;
      validate_non_negative_index("y1", "N", N);
      std::vector<double> y1;
      y1 = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 16;
      assign(y1, nil_index_list(), context__.vals_r("y1"),
        "assigning variable y1");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                rvalue(a8,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  "a8"));}}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(a7[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(a6[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(a5[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(
              rvalue(a4,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))), "a4"));
          }}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(a3[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(a2[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(a1[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                rvalue(y8,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  "y8"));}}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(y7[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(y6[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(y5[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(
              rvalue(y4,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))), "y4"));
          }}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(y3[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(y2[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y1[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("a8");
    names__.push_back("a7");
    names__.push_back("a6");
    names__.push_back("a5");
    names__.push_back("a4");
    names__.push_back("a3");
    names__.push_back("a2");
    names__.push_back("a1");
    names__.push_back("y8");
    names__.push_back("y7");
    names__.push_back("y6");
    names__.push_back("y5");
    names__.push_back("y4");
    names__.push_back("y3");
    names__.push_back("y2");
    names__.push_back("y1");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const {
    
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "a8" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "a7" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "a6" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "a5" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "a4" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "a3" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "a2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "a1" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "y8" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y7" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y6" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y5" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y4" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y3" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y1" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const {
    
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "a8" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "a7" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "a6" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "a5" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "a4" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "a3" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "a2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "a1" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "y8" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y7" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y6" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y5" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y4" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y3" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y1" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"a8\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"a7\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"a6\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"a5\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"a4\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"a3\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y8\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"y7\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"y6\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"y5\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"y4\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"y3\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"y2\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"y1\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"a8\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"a7\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"a6\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"a5\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"a4\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"a3\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y8\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"y7\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"y6\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"y5\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"y4\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"y3\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"y2\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"y1\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef reduce_sum_m2_model_namespace::reduce_sum_m2_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp reduce_sum_m3.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace reduce_sum_m3_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'reduce_sum_m3.stan', line 210, column 2 to column 13)",
                                                      " (in 'reduce_sum_m3.stan', line 211, column 2 to column 18)",
                                                      " (in 'reduce_sum_m3.stan', line 212, column 2 to column 22)",
                                                      " (in 'reduce_sum_m3.stan', line 213, column 2 to column 21)",
                                                      " (in 'reduce_sum_m3.stan', line 214, column 2 to column 16)",
                                                      " (in 'reduce_sum_m3.stan', line 215, column 2 to column 21)",
                                                      " (in 'reduce_sum_m3.stan', line 216, column 2 to column 25)",
                                                      " (in 'reduce_sum_m3.stan', line 217, column 2 to column 24)",
                                                      " (in 'reduce_sum_m3.stan', line 218, column 2 to column 10)",
                                                      " (in 'reduce_sum_m3.stan', line 219, column 2 to column 16)",
                                                      " (in 'reduce_sum_m3.stan', line 220, column 2 to column 20)",
                                                      " (in 'reduce_sum_m3.stan', line 221, column 2 to column 19)",
                                                      " (in 'reduce_sum_m3.stan', line 222, column 2 to column 20)",
                                                      " (in 'reduce_sum_m3.stan', line 260, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 261, column 2 to column 60)",
                                                      " (in 'reduce_sum_m3.stan', line 262, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 263, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 264, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 265, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 266, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 267, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 268, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 269, column 2 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 270, column 2 to column 38)",
                                                      " (in 'reduce_sum_m3.stan', line 271, column 2 to column 38)",
                                                      " (in 'reduce_sum_m3.stan', line 272, column 2 to column 37)",
                                                      " (in 'reduce_sum_m3.stan', line 273, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 274, column 2 to column 40)",
                                                      " (in 'reduce_sum_m3.stan', line 275, column 2 to column 40)",
                                                      " (in 'reduce_sum_m3.stan', line 276, column 2 to column 40)",
                                                      " (in 'reduce_sum_m3.stan', line 277, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 278, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 279, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 280, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 281, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 282, column 2 to column 41)",
                                                      " (in 'reduce_sum_m3.stan', line 283, column 2 to column 41)",
                                                      " (in 'reduce_sum_m3.stan', line 284, column 2 to column 41)",
                                                      " (in 'reduce_sum_m3.stan', line 285, column 2 to line 288, column 35)",
                                                      " (in 'reduce_sum_m3.stan', line 226, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 227, column 2 to column 60)",
                                                      " (in 'reduce_sum_m3.stan', line 228, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 229, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 230, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 231, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 232, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 233, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 234, column 2 to column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 235, column 2 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 236, column 2 to column 38)",
                                                      " (in 'reduce_sum_m3.stan', line 237, column 2 to column 38)",
                                                      " (in 'reduce_sum_m3.stan', line 238, column 2 to column 37)",
                                                      " (in 'reduce_sum_m3.stan', line 239, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 240, column 2 to column 40)",
                                                      " (in 'reduce_sum_m3.stan', line 241, column 2 to column 40)",
                                                      " (in 'reduce_sum_m3.stan', line 242, column 2 to column 40)",
                                                      " (in 'reduce_sum_m3.stan', line 243, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 244, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 245, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 246, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 247, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 248, column 2 to column 41)",
                                                      " (in 'reduce_sum_m3.stan', line 249, column 2 to column 41)",
                                                      " (in 'reduce_sum_m3.stan', line 250, column 2 to column 41)",
                                                      " (in 'reduce_sum_m3.stan', line 251, column 2 to line 254, column 34)",
                                                      " (in 'reduce_sum_m3.stan', line 256, column 2 to column 16)",
                                                      " (in 'reduce_sum_m3.stan', line 157, column 2 to column 8)",
                                                      " (in 'reduce_sum_m3.stan', line 158, column 2 to column 14)",
                                                      " (in 'reduce_sum_m3.stan', line 159, column 2 to column 19)",
                                                      " (in 'reduce_sum_m3.stan', line 160, column 2 to column 23)",
                                                      " (in 'reduce_sum_m3.stan', line 161, column 2 to column 22)",
                                                      " (in 'reduce_sum_m3.stan', line 162, column 2 to column 17)",
                                                      " (in 'reduce_sum_m3.stan', line 163, column 2 to column 22)",
                                                      " (in 'reduce_sum_m3.stan', line 164, column 2 to column 26)",
                                                      " (in 'reduce_sum_m3.stan', line 165, column 2 to column 25)",
                                                      " (in 'reduce_sum_m3.stan', line 166, column 2 to column 11)",
                                                      " (in 'reduce_sum_m3.stan', line 167, column 2 to column 17)",
                                                      " (in 'reduce_sum_m3.stan', line 168, column 2 to column 21)",
                                                      " (in 'reduce_sum_m3.stan', line 169, column 2 to column 20)",
                                                      " (in 'reduce_sum_m3.stan', line 170, column 2 to column 11)",
                                                      " (in 'reduce_sum_m3.stan', line 171, column 2 to column 14)",
                                                      " (in 'reduce_sum_m3.stan', line 172, column 2 to column 17)",
                                                      " (in 'reduce_sum_m3.stan', line 173, column 2 to column 20)",
                                                      " (in 'reduce_sum_m3.stan', line 174, column 2 to column 21)",
                                                      " (in 'reduce_sum_m3.stan', line 178, column 2 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 179, column 2 to column 63)",
                                                      " (in 'reduce_sum_m3.stan', line 180, column 2 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 181, column 2 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 182, column 2 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 183, column 2 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 184, column 2 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 185, column 2 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 186, column 2 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 187, column 2 to column 37)",
                                                      " (in 'reduce_sum_m3.stan', line 188, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 189, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 190, column 2 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 191, column 2 to column 42)",
                                                      " (in 'reduce_sum_m3.stan', line 192, column 2 to column 43)",
                                                      " (in 'reduce_sum_m3.stan', line 193, column 2 to column 43)",
                                                      " (in 'reduce_sum_m3.stan', line 194, column 2 to column 43)",
                                                      " (in 'reduce_sum_m3.stan', line 195, column 2 to column 42)",
                                                      " (in 'reduce_sum_m3.stan', line 196, column 2 to column 42)",
                                                      " (in 'reduce_sum_m3.stan', line 197, column 2 to column 42)",
                                                      " (in 'reduce_sum_m3.stan', line 198, column 2 to column 42)",
                                                      " (in 'reduce_sum_m3.stan', line 199, column 2 to column 42)",
                                                      " (in 'reduce_sum_m3.stan', line 200, column 2 to column 44)",
                                                      " (in 'reduce_sum_m3.stan', line 201, column 2 to column 44)",
                                                      " (in 'reduce_sum_m3.stan', line 202, column 2 to column 44)",
                                                      " (in 'reduce_sum_m3.stan', line 203, column 2 to line 206, column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 3, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 2, column 46 to line 4, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 6, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 5, column 47 to line 7, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 9, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 8, column 48 to line 10, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 12, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 11, column 52 to line 13, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 15, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 14, column 48 to line 16, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 18, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 17, column 47 to line 19, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 21, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 20, column 49 to line 22, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 24, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 23, column 53 to line 25, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 27, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 26, column 49 to line 28, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 30, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 29, column 45 to line 31, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 33, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 32, column 47 to line 34, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 36, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 35, column 48 to line 37, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 39, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 38, column 49 to line 40, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 42, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 41, column 54 to line 43, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 45, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 44, column 56 to line 46, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 48, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 47, column 60 to line 49, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 51, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 50, column 56 to line 52, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 54, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 53, column 56 to line 55, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 57, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 56, column 58 to line 58, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 60, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 59, column 62 to line 61, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 63, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 62, column 58 to line 64, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 66, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 65, column 57 to line 67, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 69, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 68, column 60 to line 70, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 72, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 71, column 64 to line 73, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 75, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 74, column 60 to line 76, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 82, column 4 to line 86, column 28)",
                                                      " (in 'reduce_sum_m3.stan', line 81, column 32 to line 87, column 3)",
                                                      " (in 'reduce_sum_m3.stan', line 89, column 4 to column 10)",
                                                      " (in 'reduce_sum_m3.stan', line 90, column 4 to column 16)",
                                                      " (in 'reduce_sum_m3.stan', line 91, column 4 to column 21)",
                                                      " (in 'reduce_sum_m3.stan', line 92, column 4 to column 25)",
                                                      " (in 'reduce_sum_m3.stan', line 93, column 4 to column 24)",
                                                      " (in 'reduce_sum_m3.stan', line 94, column 4 to column 19)",
                                                      " (in 'reduce_sum_m3.stan', line 95, column 4 to column 24)",
                                                      " (in 'reduce_sum_m3.stan', line 96, column 4 to column 28)",
                                                      " (in 'reduce_sum_m3.stan', line 97, column 4 to column 27)",
                                                      " (in 'reduce_sum_m3.stan', line 98, column 4 to column 13)",
                                                      " (in 'reduce_sum_m3.stan', line 99, column 4 to column 19)",
                                                      " (in 'reduce_sum_m3.stan', line 100, column 4 to column 23)",
                                                      " (in 'reduce_sum_m3.stan', line 101, column 4 to column 22)",
                                                      " (in 'reduce_sum_m3.stan', line 102, column 4 to column 13)",
                                                      " (in 'reduce_sum_m3.stan', line 103, column 4 to column 16)",
                                                      " (in 'reduce_sum_m3.stan', line 104, column 4 to column 19)",
                                                      " (in 'reduce_sum_m3.stan', line 105, column 4 to column 22)",
                                                      " (in 'reduce_sum_m3.stan', line 106, column 4 to column 23)",
                                                      " (in 'reduce_sum_m3.stan', line 108, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 109, column 4 to column 20)",
                                                      " (in 'reduce_sum_m3.stan', line 110, column 4 to column 24)",
                                                      " (in 'reduce_sum_m3.stan', line 111, column 4 to column 23)",
                                                      " (in 'reduce_sum_m3.stan', line 112, column 4 to column 18)",
                                                      " (in 'reduce_sum_m3.stan', line 113, column 4 to column 23)",
                                                      " (in 'reduce_sum_m3.stan', line 114, column 4 to column 27)",
                                                      " (in 'reduce_sum_m3.stan', line 115, column 4 to column 26)",
                                                      " (in 'reduce_sum_m3.stan', line 116, column 4 to column 12)",
                                                      " (in 'reduce_sum_m3.stan', line 117, column 4 to column 18)",
                                                      " (in 'reduce_sum_m3.stan', line 118, column 4 to column 22)",
                                                      " (in 'reduce_sum_m3.stan', line 119, column 4 to column 21)",
                                                      " (in 'reduce_sum_m3.stan', line 120, column 4 to column 22)",
                                                      " (in 'reduce_sum_m3.stan', line 122, column 4 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 123, column 4 to column 62)",
                                                      " (in 'reduce_sum_m3.stan', line 124, column 4 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 125, column 4 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 126, column 4 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 127, column 4 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 128, column 4 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 129, column 4 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 130, column 4 to column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 131, column 4 to column 38)",
                                                      " (in 'reduce_sum_m3.stan', line 132, column 4 to column 40)",
                                                      " (in 'reduce_sum_m3.stan', line 133, column 4 to column 40)",
                                                      " (in 'reduce_sum_m3.stan', line 134, column 4 to column 39)",
                                                      " (in 'reduce_sum_m3.stan', line 135, column 4 to column 41)",
                                                      " (in 'reduce_sum_m3.stan', line 136, column 4 to column 42)",
                                                      " (in 'reduce_sum_m3.stan', line 137, column 4 to column 42)",
                                                      " (in 'reduce_sum_m3.stan', line 138, column 4 to column 42)",
                                                      " (in 'reduce_sum_m3.stan', line 139, column 4 to column 41)",
                                                      " (in 'reduce_sum_m3.stan', line 140, column 4 to column 41)",
                                                      " (in 'reduce_sum_m3.stan', line 141, column 4 to column 41)",
                                                      " (in 'reduce_sum_m3.stan', line 142, column 4 to column 41)",
                                                      " (in 'reduce_sum_m3.stan', line 143, column 4 to column 41)",
                                                      " (in 'reduce_sum_m3.stan', line 144, column 4 to column 43)",
                                                      " (in 'reduce_sum_m3.stan', line 145, column 4 to column 43)",
                                                      " (in 'reduce_sum_m3.stan', line 146, column 4 to column 43)",
                                                      " (in 'reduce_sum_m3.stan', line 147, column 4 to line 150, column 36)",
                                                      " (in 'reduce_sum_m3.stan', line 152, column 4 to column 15)",
                                                      " (in 'reduce_sum_m3.stan', line 88, column 11 to line 153, column 3)"};

struct f10_rsfunctor__;
struct f11_rsfunctor__;
struct f12_rsfunctor__;
struct f1_rsfunctor__;
struct f1a_rsfunctor__;
struct f2_rsfunctor__;
struct f3_rsfunctor__;
struct f4_rsfunctor__;
struct f5_rsfunctor__;
struct f6_rsfunctor__;
struct f7_rsfunctor__;
struct f8_rsfunctor__;
struct f9_rsfunctor__;
struct g10_rsfunctor__;
struct g11_rsfunctor__;
struct g12_rsfunctor__;
struct g1_rsfunctor__;
struct g2_rsfunctor__;
struct g3_rsfunctor__;
struct g4_rsfunctor__;
struct g5_rsfunctor__;
struct g6_rsfunctor__;
struct g7_rsfunctor__;
struct g8_rsfunctor__;
struct g9_rsfunctor__;
struct s_rsfunctor__;
template <typename T0__>
stan::promote_args_t<T0__>
f1(const std::vector<T0__>& y_slice, const int& start, const int& end,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 111;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f1_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return f1(y_slice, start, end, pstream__);
}
};


struct f1_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return f1(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
f1a(const std::vector<T0__>& y_slice, const int& start, const int& end,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 113;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f1a_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return f1a(y_slice, start, end, pstream__);
}
};


struct f1a_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return f1a(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
f2(const std::vector<Eigen::Matrix<T0__, -1, 1>>& y_slice, const int& start,
   const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 115;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f2_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<Eigen::Matrix<T0__, -1, 1>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f2(y_slice, start, end, pstream__);
}
};


struct f2_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<Eigen::Matrix<T0__, -1, 1>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f2(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
f3(const std::vector<Eigen::Matrix<T0__, 1, -1>>& y_slice, const int& start,
   const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 117;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f3_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<Eigen::Matrix<T0__, 1, -1>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f3(y_slice, start, end, pstream__);
}
};


struct f3_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<Eigen::Matrix<T0__, 1, -1>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f3(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
f4(const std::vector<Eigen::Matrix<T0__, -1, -1>>& y_slice, const int& start,
   const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 119;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f4_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<Eigen::Matrix<T0__, -1, -1>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f4(y_slice, start, end, pstream__);
}
};


struct f4_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<Eigen::Matrix<T0__, -1, -1>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f4(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
f5(const std::vector<std::vector<T0__>>& y_slice, const int& start,
   const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 121;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f5_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<T0__>>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return f5(y_slice, start, end, pstream__);
}
};


struct f5_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<T0__>>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return f5(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
f6(const std::vector<std::vector<Eigen::Matrix<T0__, -1, 1>>>& y_slice,
   const int& start, const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 123;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f6_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<Eigen::Matrix<T0__, -1, 1>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f6(y_slice, start, end, pstream__);
}
};


struct f6_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<Eigen::Matrix<T0__, -1, 1>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f6(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
f7(const std::vector<std::vector<Eigen::Matrix<T0__, 1, -1>>>& y_slice,
   const int& start, const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 125;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f7_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<Eigen::Matrix<T0__, 1, -1>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f7(y_slice, start, end, pstream__);
}
};


struct f7_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<Eigen::Matrix<T0__, 1, -1>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f7(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
f8(const std::vector<std::vector<Eigen::Matrix<T0__, -1, -1>>>& y_slice,
   const int& start, const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 127;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f8_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<Eigen::Matrix<T0__, -1, -1>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f8(y_slice, start, end, pstream__);
}
};


struct f8_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<Eigen::Matrix<T0__, -1, -1>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f8(y_slice, start + 1, end + 1, pstream__);
}
};

double
f9(const std::vector<int>& y_slice, const int& start, const int& end,
   std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 129;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f9_functor__ {
double
operator()(const std::vector<int>& y_slice, const int& start, const int& end,
           std::ostream* pstream__)  const 
{
return f9(y_slice, start, end, pstream__);
}
};


struct f9_rsfunctor__ {
double
operator()(const std::vector<int>& y_slice, const int& start, const int& end,
           std::ostream* pstream__)  const 
{
return f9(y_slice, start + 1, end + 1, pstream__);
}
};

double
f10(const std::vector<std::vector<int>>& y_slice, const int& start,
    const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 131;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f10_functor__ {
double
operator()(const std::vector<std::vector<int>>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return f10(y_slice, start, end, pstream__);
}
};


struct f10_rsfunctor__ {
double
operator()(const std::vector<std::vector<int>>& y_slice, const int& start,
           const int& end, std::ostream* pstream__)  const 
{
return f10(y_slice, start + 1, end + 1, pstream__);
}
};

double
f11(const std::vector<std::vector<std::vector<int>>>& y_slice,
    const int& start, const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 133;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f11_functor__ {
double
operator()(const std::vector<std::vector<std::vector<int>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f11(y_slice, start, end, pstream__);
}
};


struct f11_rsfunctor__ {
double
operator()(const std::vector<std::vector<std::vector<int>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f11(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
f12(const std::vector<std::vector<std::vector<T0__>>>& y_slice,
    const int& start, const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 135;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct f12_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<std::vector<T0__>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f12(y_slice, start, end, pstream__);
}
};


struct f12_rsfunctor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<std::vector<std::vector<T0__>>>& y_slice,
           const int& start, const int& end, std::ostream* pstream__)  const 
{
return f12(y_slice, start + 1, end + 1, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
g1(const std::vector<T0__>& y_slice, const int& start, const int& end,
   const T3__& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 137;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g1_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, const T3__& a, std::ostream* pstream__)  const 
{
return g1(y_slice, start, end, a, pstream__);
}
};


struct g1_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__, const T3__& a)  const 
{
return g1(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
g2(const std::vector<T0__>& y_slice, const int& start, const int& end,
   const Eigen::Matrix<T3__, -1, 1>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 139;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g2_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, const Eigen::Matrix<T3__, -1, 1>& a,
           std::ostream* pstream__)  const 
{
return g2(y_slice, start, end, a, pstream__);
}
};


struct g2_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__,
           const Eigen::Matrix<T3__, -1, 1>& a)  const 
{
return g2(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
g3(const std::vector<T0__>& y_slice, const int& start, const int& end,
   const Eigen::Matrix<T3__, 1, -1>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 141;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g3_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, const Eigen::Matrix<T3__, 1, -1>& a,
           std::ostream* pstream__)  const 
{
return g3(y_slice, start, end, a, pstream__);
}
};


struct g3_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__,
           const Eigen::Matrix<T3__, 1, -1>& a)  const 
{
return g3(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
g4(const std::vector<T0__>& y_slice, const int& start, const int& end,
   const Eigen::Matrix<T3__, -1, -1>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 143;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g4_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, const Eigen::Matrix<T3__, -1, -1>& a,
           std::ostream* pstream__)  const 
{
return g4(y_slice, start, end, a, pstream__);
}
};


struct g4_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__,
           const Eigen::Matrix<T3__, -1, -1>& a)  const 
{
return g4(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
g5(const std::vector<T0__>& y_slice, const int& start, const int& end,
   const std::vector<T3__>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 145;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g5_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, const std::vector<T3__>& a,
           std::ostream* pstream__)  const 
{
return g5(y_slice, start, end, a, pstream__);
}
};


struct g5_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__,
           const std::vector<T3__>& a)  const 
{
return g5(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
g6(const std::vector<T0__>& y_slice, const int& start, const int& end,
   const std::vector<Eigen::Matrix<T3__, -1, 1>>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 147;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g6_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, const std::vector<Eigen::Matrix<T3__, -1, 1>>& a,
           std::ostream* pstream__)  const 
{
return g6(y_slice, start, end, a, pstream__);
}
};


struct g6_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__,
           const std::vector<Eigen::Matrix<T3__, -1, 1>>& a)  const 
{
return g6(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
g7(const std::vector<T0__>& y_slice, const int& start, const int& end,
   const std::vector<Eigen::Matrix<T3__, 1, -1>>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 149;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g7_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, const std::vector<Eigen::Matrix<T3__, 1, -1>>& a,
           std::ostream* pstream__)  const 
{
return g7(y_slice, start, end, a, pstream__);
}
};


struct g7_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__,
           const std::vector<Eigen::Matrix<T3__, 1, -1>>& a)  const 
{
return g7(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
g8(const std::vector<T0__>& y_slice, const int& start, const int& end,
   const std::vector<Eigen::Matrix<T3__, -1, -1>>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 151;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g8_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, const std::vector<Eigen::Matrix<T3__, -1, -1>>& a,
           std::ostream* pstream__)  const 
{
return g8(y_slice, start, end, a, pstream__);
}
};


struct g8_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__,
           const std::vector<Eigen::Matrix<T3__, -1, -1>>& a)  const 
{
return g8(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
g9(const std::vector<T0__>& y_slice, const int& start, const int& end,
   const std::vector<std::vector<T3__>>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 153;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g9_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, const std::vector<std::vector<T3__>>& a,
           std::ostream* pstream__)  const 
{
return g9(y_slice, start, end, a, pstream__);
}
};


struct g9_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__,
           const std::vector<std::vector<T3__>>& a)  const 
{
return g9(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
g10(const std::vector<T0__>& y_slice, const int& start, const int& end,
    const std::vector<std::vector<Eigen::Matrix<T3__, -1, 1>>>& a,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 155;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g10_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end,
           const std::vector<std::vector<Eigen::Matrix<T3__, -1, 1>>>& a,
           std::ostream* pstream__)  const 
{
return g10(y_slice, start, end, a, pstream__);
}
};


struct g10_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__,
           const std::vector<std::vector<Eigen::Matrix<T3__, -1, 1>>>& a)  const 
{
return g10(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
g11(const std::vector<T0__>& y_slice, const int& start, const int& end,
    const std::vector<std::vector<Eigen::Matrix<T3__, 1, -1>>>& a,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 157;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g11_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end,
           const std::vector<std::vector<Eigen::Matrix<T3__, 1, -1>>>& a,
           std::ostream* pstream__)  const 
{
return g11(y_slice, start, end, a, pstream__);
}
};


struct g11_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__,
           const std::vector<std::vector<Eigen::Matrix<T3__, 1, -1>>>& a)  const 
{
return g11(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
g12(const std::vector<T0__>& y_slice, const int& start, const int& end,
    const std::vector<std::vector<Eigen::Matrix<T3__, -1, -1>>>& a,
    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 159;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct g12_functor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end,
           const std::vector<std::vector<Eigen::Matrix<T3__, -1, -1>>>& a,
           std::ostream* pstream__)  const 
{
return g12(y_slice, start, end, a, pstream__);
}
};


struct g12_rsfunctor__ {
template <typename T0__, typename T3__>
stan::promote_args_t<T0__,
T3__>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__,
           const std::vector<std::vector<Eigen::Matrix<T3__, -1, -1>>>& a)  const 
{
return g12(y_slice, start + 1, end + 1, a, pstream__);
}
};

template <typename T0__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T9__, typename T10__, typename T11__, typename T12__,
typename T14__, typename T15__, typename T16__, typename T17__,
typename T19__>
stan::promote_args_t<T0__, T4__, T5__, T6__, T7__, stan::promote_args_t<T9__,
T10__, T11__, T12__, T14__, stan::promote_args_t<T15__, T16__, T17__,
T19__>>>
s(const std::vector<T0__>& y_slice, const int& start, const int& end,
  const int& a, const T4__& b, const Eigen::Matrix<T5__, -1, 1>& c,
  const Eigen::Matrix<T6__, 1, -1>& d, const Eigen::Matrix<T7__, -1, -1>& e,
  const std::vector<int>& f, const std::vector<T9__>& g,
  const std::vector<Eigen::Matrix<T10__, -1, 1>>& h,
  const std::vector<Eigen::Matrix<T11__, 1, -1>>& i,
  const std::vector<Eigen::Matrix<T12__, -1, -1>>& j,
  const std::vector<std::vector<int>>& k,
  const std::vector<std::vector<T14__>>& l,
  const std::vector<std::vector<Eigen::Matrix<T15__, -1, 1>>>& m,
  const std::vector<std::vector<Eigen::Matrix<T16__, 1, -1>>>& n,
  const std::vector<std::vector<Eigen::Matrix<T17__, -1, -1>>>& o,
  const std::vector<std::vector<std::vector<int>>>& p,
  const std::vector<std::vector<std::vector<T19__>>>& q,
  std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
          T4__,
          T5__,
          T6__,
          T7__, stan::promote_args_t<T9__,
          T10__,
          T11__,
          T12__,
          T14__, stan::promote_args_t<T15__,
          T16__,
          T17__,
          T19__>>>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 161;
    return reduce_sum<s_rsfunctor__>(y_slice, 1, pstream__, a, b, c, d, e, f,
             g, h, i, j, k, l, m, n, o, p, q);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct s_functor__ {
template <typename T0__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T9__, typename T10__, typename T11__, typename T12__,
typename T14__, typename T15__, typename T16__, typename T17__,
typename T19__>
stan::promote_args_t<T0__, T4__, T5__, T6__, T7__, stan::promote_args_t<T9__,
T10__, T11__, T12__, T14__, stan::promote_args_t<T15__, T16__, T17__,
T19__>>>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, const int& a, const T4__& b,
           const Eigen::Matrix<T5__, -1, 1>& c,
           const Eigen::Matrix<T6__, 1, -1>& d,
           const Eigen::Matrix<T7__, -1, -1>& e, const std::vector<int>& f,
           const std::vector<T9__>& g,
           const std::vector<Eigen::Matrix<T10__, -1, 1>>& h,
           const std::vector<Eigen::Matrix<T11__, 1, -1>>& i,
           const std::vector<Eigen::Matrix<T12__, -1, -1>>& j,
           const std::vector<std::vector<int>>& k,
           const std::vector<std::vector<T14__>>& l,
           const std::vector<std::vector<Eigen::Matrix<T15__, -1, 1>>>& m,
           const std::vector<std::vector<Eigen::Matrix<T16__, 1, -1>>>& n,
           const std::vector<std::vector<Eigen::Matrix<T17__, -1, -1>>>& o,
           const std::vector<std::vector<std::vector<int>>>& p,
           const std::vector<std::vector<std::vector<T19__>>>& q,
           std::ostream* pstream__)  const 
{
return s(y_slice, start, end, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p,
         q, pstream__);
}
};


struct s_rsfunctor__ {
template <typename T0__, typename T4__, typename T5__, typename T6__,
typename T7__, typename T9__, typename T10__, typename T11__, typename T12__,
typename T14__, typename T15__, typename T16__, typename T17__,
typename T19__>
stan::promote_args_t<T0__, T4__, T5__, T6__, T7__, stan::promote_args_t<T9__,
T10__, T11__, T12__, T14__, stan::promote_args_t<T15__, T16__, T17__,
T19__>>>
operator()(const std::vector<T0__>& y_slice, const int& start,
           const int& end, std::ostream* pstream__, const int& a,
           const T4__& b, const Eigen::Matrix<T5__, -1, 1>& c,
           const Eigen::Matrix<T6__, 1, -1>& d,
           const Eigen::Matrix<T7__, -1, -1>& e, const std::vector<int>& f,
           const std::vector<T9__>& g,
           const std::vector<Eigen::Matrix<T10__, -1, 1>>& h,
           const std::vector<Eigen::Matrix<T11__, 1, -1>>& i,
           const std::vector<Eigen::Matrix<T12__, -1, -1>>& j,
           const std::vector<std::vector<int>>& k,
           const std::vector<std::vector<T14__>>& l,
           const std::vector<std::vector<Eigen::Matrix<T15__, -1, 1>>>& m,
           const std::vector<std::vector<Eigen::Matrix<T16__, 1, -1>>>& n,
           const std::vector<std::vector<Eigen::Matrix<T17__, -1, -1>>>& o,
           const std::vector<std::vector<std::vector<int>>>& p,
           const std::vector<std::vector<std::vector<T19__>>>& q)  const 
{
return s(y_slice, start + 1, end + 1, a, b, c, d, e, f, g, h, i, j, k, l, m,
         n, o, p, q, pstream__);
}
};

double
r(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int N;
    N = std::numeric_limits<int>::min();
    
    current_statement__ = 164;
    validate_non_negative_index("y1d", "N", N);
    std::vector<local_scalar_t__> y1d;
    y1d = std::vector<local_scalar_t__>(N, DUMMY_VAR__);
    
    current_statement__ = 165;
    validate_non_negative_index("y2d", "N", N);
    current_statement__ = 165;
    validate_non_negative_index("y2d", "N", N);
    std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> y2d;
    y2d = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N));
    stan::math::fill(y2d, DUMMY_VAR__);
    
    current_statement__ = 166;
    validate_non_negative_index("y3d", "N", N);
    current_statement__ = 166;
    validate_non_negative_index("y3d", "N", N);
    std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>> y3d;
    y3d = std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(N, Eigen::Matrix<local_scalar_t__, 1, -1>(N));
    stan::math::fill(y3d, DUMMY_VAR__);
    
    current_statement__ = 167;
    validate_non_negative_index("y4d", "N", N);
    current_statement__ = 167;
    validate_non_negative_index("y4d", "N", N);
    current_statement__ = 167;
    validate_non_negative_index("y4d", "N", N);
    std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> y4d;
    y4d = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(N, Eigen::Matrix<local_scalar_t__, -1, -1>(N, N));
    stan::math::fill(y4d, DUMMY_VAR__);
    
    current_statement__ = 168;
    validate_non_negative_index("y5d", "N", N);
    current_statement__ = 168;
    validate_non_negative_index("y5d", "N", N);
    std::vector<std::vector<local_scalar_t__>> y5d;
    y5d = std::vector<std::vector<local_scalar_t__>>(N, std::vector<local_scalar_t__>(N, DUMMY_VAR__));
    
    current_statement__ = 169;
    validate_non_negative_index("y6d", "N", N);
    current_statement__ = 169;
    validate_non_negative_index("y6d", "N", N);
    current_statement__ = 169;
    validate_non_negative_index("y6d", "N", N);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> y6d;
    y6d = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N)));
    stan::math::fill(y6d, DUMMY_VAR__);
    
    current_statement__ = 170;
    validate_non_negative_index("y7d", "N", N);
    current_statement__ = 170;
    validate_non_negative_index("y7d", "N", N);
    current_statement__ = 170;
    validate_non_negative_index("y7d", "N", N);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>> y7d;
    y7d = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(N, Eigen::Matrix<local_scalar_t__, 1, -1>(N)));
    stan::math::fill(y7d, DUMMY_VAR__);
    
    current_statement__ = 171;
    validate_non_negative_index("y8d", "N", N);
    current_statement__ = 171;
    validate_non_negative_index("y8d", "N", N);
    current_statement__ = 171;
    validate_non_negative_index("y8d", "N", N);
    current_statement__ = 171;
    validate_non_negative_index("y8d", "N", N);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>> y8d;
    y8d = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(N, Eigen::Matrix<local_scalar_t__, -1, -1>(N, N)));
    stan::math::fill(y8d, DUMMY_VAR__);
    
    local_scalar_t__ y9d;
    y9d = DUMMY_VAR__;
    
    current_statement__ = 173;
    validate_non_negative_index("y10d", "N", N);
    Eigen::Matrix<local_scalar_t__, -1, 1> y10d;
    y10d = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
    stan::math::fill(y10d, DUMMY_VAR__);
    
    current_statement__ = 174;
    validate_non_negative_index("y11d", "N", N);
    Eigen::Matrix<local_scalar_t__, 1, -1> y11d;
    y11d = Eigen::Matrix<local_scalar_t__, 1, -1>(N);
    stan::math::fill(y11d, DUMMY_VAR__);
    
    current_statement__ = 175;
    validate_non_negative_index("y12d", "N", N);
    current_statement__ = 175;
    validate_non_negative_index("y12d", "N", N);
    Eigen::Matrix<local_scalar_t__, -1, -1> y12d;
    y12d = Eigen::Matrix<local_scalar_t__, -1, -1>(N, N);
    stan::math::fill(y12d, DUMMY_VAR__);
    
    int y13d;
    y13d = std::numeric_limits<int>::min();
    
    current_statement__ = 177;
    validate_non_negative_index("y14d", "N", N);
    std::vector<int> y14d;
    y14d = std::vector<int>(N, std::numeric_limits<int>::min());
    
    current_statement__ = 178;
    validate_non_negative_index("y15d", "N", N);
    current_statement__ = 178;
    validate_non_negative_index("y15d", "N", N);
    std::vector<std::vector<int>> y15d;
    y15d = std::vector<std::vector<int>>(N, std::vector<int>(N, std::numeric_limits<int>::min()));
    
    current_statement__ = 179;
    validate_non_negative_index("y16d", "N", N);
    current_statement__ = 179;
    validate_non_negative_index("y16d", "N", N);
    current_statement__ = 179;
    validate_non_negative_index("y16d", "N", N);
    std::vector<std::vector<std::vector<int>>> y16d;
    y16d = std::vector<std::vector<std::vector<int>>>(N, std::vector<std::vector<int>>(N, std::vector<int>(N, std::numeric_limits<int>::min())));
    
    current_statement__ = 180;
    validate_non_negative_index("y17d", "N", N);
    current_statement__ = 180;
    validate_non_negative_index("y17d", "N", N);
    current_statement__ = 180;
    validate_non_negative_index("y17d", "N", N);
    std::vector<std::vector<std::vector<local_scalar_t__>>> y17d;
    y17d = std::vector<std::vector<std::vector<local_scalar_t__>>>(N, std::vector<std::vector<local_scalar_t__>>(N, std::vector<local_scalar_t__>(N, DUMMY_VAR__)));
    
    current_statement__ = 181;
    validate_non_negative_index("y1", "N", N);
    std::vector<local_scalar_t__> y1;
    y1 = std::vector<local_scalar_t__>(N, DUMMY_VAR__);
    
    current_statement__ = 182;
    validate_non_negative_index("y2", "N", N);
    current_statement__ = 182;
    validate_non_negative_index("y2", "N", N);
    std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> y2;
    y2 = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N));
    stan::math::fill(y2, DUMMY_VAR__);
    
    current_statement__ = 183;
    validate_non_negative_index("y3", "N", N);
    current_statement__ = 183;
    validate_non_negative_index("y3", "N", N);
    std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>> y3;
    y3 = std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(N, Eigen::Matrix<local_scalar_t__, 1, -1>(N));
    stan::math::fill(y3, DUMMY_VAR__);
    
    current_statement__ = 184;
    validate_non_negative_index("y4", "N", N);
    current_statement__ = 184;
    validate_non_negative_index("y4", "N", N);
    current_statement__ = 184;
    validate_non_negative_index("y4", "N", N);
    std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> y4;
    y4 = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(N, Eigen::Matrix<local_scalar_t__, -1, -1>(N, N));
    stan::math::fill(y4, DUMMY_VAR__);
    
    current_statement__ = 185;
    validate_non_negative_index("y5", "N", N);
    current_statement__ = 185;
    validate_non_negative_index("y5", "N", N);
    std::vector<std::vector<local_scalar_t__>> y5;
    y5 = std::vector<std::vector<local_scalar_t__>>(N, std::vector<local_scalar_t__>(N, DUMMY_VAR__));
    
    current_statement__ = 186;
    validate_non_negative_index("y6", "N", N);
    current_statement__ = 186;
    validate_non_negative_index("y6", "N", N);
    current_statement__ = 186;
    validate_non_negative_index("y6", "N", N);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> y6;
    y6 = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N)));
    stan::math::fill(y6, DUMMY_VAR__);
    
    current_statement__ = 187;
    validate_non_negative_index("y7", "N", N);
    current_statement__ = 187;
    validate_non_negative_index("y7", "N", N);
    current_statement__ = 187;
    validate_non_negative_index("y7", "N", N);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>> y7;
    y7 = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(N, Eigen::Matrix<local_scalar_t__, 1, -1>(N)));
    stan::math::fill(y7, DUMMY_VAR__);
    
    current_statement__ = 188;
    validate_non_negative_index("y8", "N", N);
    current_statement__ = 188;
    validate_non_negative_index("y8", "N", N);
    current_statement__ = 188;
    validate_non_negative_index("y8", "N", N);
    current_statement__ = 188;
    validate_non_negative_index("y8", "N", N);
    std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>> y8;
    y8 = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(N, Eigen::Matrix<local_scalar_t__, -1, -1>(N, N)));
    stan::math::fill(y8, DUMMY_VAR__);
    
    local_scalar_t__ y9;
    y9 = DUMMY_VAR__;
    
    current_statement__ = 190;
    validate_non_negative_index("y10", "N", N);
    Eigen::Matrix<local_scalar_t__, -1, 1> y10;
    y10 = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
    stan::math::fill(y10, DUMMY_VAR__);
    
    current_statement__ = 191;
    validate_non_negative_index("y11", "N", N);
    Eigen::Matrix<local_scalar_t__, 1, -1> y11;
    y11 = Eigen::Matrix<local_scalar_t__, 1, -1>(N);
    stan::math::fill(y11, DUMMY_VAR__);
    
    current_statement__ = 192;
    validate_non_negative_index("y12", "N", N);
    current_statement__ = 192;
    validate_non_negative_index("y12", "N", N);
    Eigen::Matrix<local_scalar_t__, -1, -1> y12;
    y12 = Eigen::Matrix<local_scalar_t__, -1, -1>(N, N);
    stan::math::fill(y12, DUMMY_VAR__);
    
    current_statement__ = 193;
    validate_non_negative_index("y17", "N", N);
    current_statement__ = 193;
    validate_non_negative_index("y17", "N", N);
    current_statement__ = 193;
    validate_non_negative_index("y17", "N", N);
    std::vector<std::vector<std::vector<local_scalar_t__>>> y17;
    y17 = std::vector<std::vector<std::vector<local_scalar_t__>>>(N, std::vector<std::vector<local_scalar_t__>>(N, std::vector<local_scalar_t__>(N, DUMMY_VAR__)));
    
    local_scalar_t__ t1;
    t1 = DUMMY_VAR__;
    
    current_statement__ = 194;
    t1 = reduce_sum<f1_rsfunctor__>(y1, 1, pstream__);
    local_scalar_t__ t1a;
    t1a = DUMMY_VAR__;
    
    current_statement__ = 195;
    t1a = (reduce_sum<f1_rsfunctor__>(y1, 1, pstream__) +
            reduce_sum<f1a_rsfunctor__>(y1, 1, pstream__));
    local_scalar_t__ t2;
    t2 = DUMMY_VAR__;
    
    current_statement__ = 196;
    t2 = reduce_sum<f2_rsfunctor__>(y2, 1, pstream__);
    local_scalar_t__ t3;
    t3 = DUMMY_VAR__;
    
    current_statement__ = 197;
    t3 = reduce_sum<f3_rsfunctor__>(y3, 1, pstream__);
    local_scalar_t__ t4;
    t4 = DUMMY_VAR__;
    
    current_statement__ = 198;
    t4 = reduce_sum<f4_rsfunctor__>(y4, 1, pstream__);
    local_scalar_t__ t5;
    t5 = DUMMY_VAR__;
    
    current_statement__ = 199;
    t5 = reduce_sum<f5_rsfunctor__>(y5, 1, pstream__);
    local_scalar_t__ t6;
    t6 = DUMMY_VAR__;
    
    current_statement__ = 200;
    t6 = reduce_sum<f6_rsfunctor__>(y6, 1, pstream__);
    local_scalar_t__ t7;
    t7 = DUMMY_VAR__;
    
    current_statement__ = 201;
    t7 = reduce_sum<f7_rsfunctor__>(y7, 1, pstream__);
    local_scalar_t__ t8;
    t8 = DUMMY_VAR__;
    
    current_statement__ = 202;
    t8 = reduce_sum<f8_rsfunctor__>(y8, 1, pstream__);
    local_scalar_t__ t9;
    t9 = DUMMY_VAR__;
    
    current_statement__ = 203;
    t9 = reduce_sum<f9_rsfunctor__>(y14d, 1, pstream__);
    local_scalar_t__ t10;
    t10 = DUMMY_VAR__;
    
    current_statement__ = 204;
    t10 = reduce_sum<f10_rsfunctor__>(y15d, 1, pstream__);
    local_scalar_t__ t11;
    t11 = DUMMY_VAR__;
    
    current_statement__ = 205;
    t11 = reduce_sum<f11_rsfunctor__>(y16d, 1, pstream__);
    local_scalar_t__ t12;
    t12 = DUMMY_VAR__;
    
    current_statement__ = 206;
    t12 = reduce_sum<f12_rsfunctor__>(y17, 1, pstream__);
    local_scalar_t__ tg1;
    tg1 = DUMMY_VAR__;
    
    current_statement__ = 207;
    tg1 = reduce_sum<g1_rsfunctor__>(y1, 1, pstream__, y9);
    local_scalar_t__ tg2;
    tg2 = DUMMY_VAR__;
    
    current_statement__ = 208;
    tg2 = reduce_sum<g2_rsfunctor__>(y1, 1, pstream__, y10);
    local_scalar_t__ tg3;
    tg3 = DUMMY_VAR__;
    
    current_statement__ = 209;
    tg3 = reduce_sum<g3_rsfunctor__>(y1, 1, pstream__, y11);
    local_scalar_t__ tg4;
    tg4 = DUMMY_VAR__;
    
    current_statement__ = 210;
    tg4 = reduce_sum<g4_rsfunctor__>(y1, 1, pstream__, y12);
    local_scalar_t__ tg5;
    tg5 = DUMMY_VAR__;
    
    current_statement__ = 211;
    tg5 = reduce_sum<g5_rsfunctor__>(y1, 1, pstream__, y1);
    local_scalar_t__ tg6;
    tg6 = DUMMY_VAR__;
    
    current_statement__ = 212;
    tg6 = reduce_sum<g6_rsfunctor__>(y1, 1, pstream__, y2);
    local_scalar_t__ tg7;
    tg7 = DUMMY_VAR__;
    
    current_statement__ = 213;
    tg7 = reduce_sum<g7_rsfunctor__>(y1, 1, pstream__, y3);
    local_scalar_t__ tg8;
    tg8 = DUMMY_VAR__;
    
    current_statement__ = 214;
    tg8 = reduce_sum<g8_rsfunctor__>(y1, 1, pstream__, y4);
    local_scalar_t__ tg9;
    tg9 = DUMMY_VAR__;
    
    current_statement__ = 215;
    tg9 = reduce_sum<g9_rsfunctor__>(y1, 1, pstream__, y5);
    local_scalar_t__ tg10;
    tg10 = DUMMY_VAR__;
    
    current_statement__ = 216;
    tg10 = reduce_sum<g10_rsfunctor__>(y1, 1, pstream__, y6);
    local_scalar_t__ tg11;
    tg11 = DUMMY_VAR__;
    
    current_statement__ = 217;
    tg11 = reduce_sum<g11_rsfunctor__>(y1, 1, pstream__, y7);
    local_scalar_t__ tg12;
    tg12 = DUMMY_VAR__;
    
    current_statement__ = 218;
    tg12 = reduce_sum<g12_rsfunctor__>(y1, 1, pstream__, y8);
    local_scalar_t__ ts;
    ts = DUMMY_VAR__;
    
    current_statement__ = 219;
    ts = reduce_sum<s_rsfunctor__>(y1d, 1, pstream__, y13d, y9, y10, y11,
           y12, y14d, y1, y2, y3, y4, y15d, y5, y6, y7, y8, y16d, y17);
    current_statement__ = 220;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct r_functor__ {
double
operator()(std::ostream* pstream__)  const 
{
return r(pstream__);
}
};

class reduce_sum_m3_model : public model_base_crtp<reduce_sum_m3_model> {

 private:
  int pos__;
  int N;
  std::vector<double> y1d;
  std::vector<Eigen::Matrix<double, -1, 1>> y2d;
  std::vector<Eigen::Matrix<double, 1, -1>> y3d;
  std::vector<Eigen::Matrix<double, -1, -1>> y4d;
  std::vector<std::vector<double>> y5d;
  std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> y6d;
  std::vector<std::vector<Eigen::Matrix<double, 1, -1>>> y7d;
  std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> y8d;
  double y9d;
  Eigen::Matrix<double, -1, 1> y10d;
  Eigen::Matrix<double, 1, -1> y11d;
  Eigen::Matrix<double, -1, -1> y12d;
  int y13d;
  std::vector<int> y14d;
  std::vector<std::vector<int>> y15d;
  std::vector<std::vector<std::vector<int>>> y16d;
  std::vector<std::vector<std::vector<double>>> y17d;
  double td1;
  double td1a;
  double td2;
  double td3;
  double td4;
  double td5;
  double td6;
  double td7;
  double td8;
  double td9;
  double td10;
  double td11;
  double td12;
  double tgd1;
  double tgd2;
  double tgd3;
  double tgd4;
  double tgd5;
  double tgd6;
  double tgd7;
  double tgd8;
  double tgd9;
  double tgd10;
  double tgd11;
  double tgd12;
  double tsd;
 
 public:
  ~reduce_sum_m3_model() { }
  
  std::string model_name() const { return "reduce_sum_m3_model"; }
  
  reduce_sum_m3_model(stan::io::var_context& context__,
                      unsigned int random_seed__ = 0,
                      std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "reduce_sum_m3_model_namespace::reduce_sum_m3_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 67;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 68;
      validate_non_negative_index("y1d", "N", N);
      context__.validate_dims("data initialization","y1d","double",
          context__.to_vec(N));
      y1d = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 68;
      assign(y1d, nil_index_list(), context__.vals_r("y1d"),
        "assigning variable y1d");
      current_statement__ = 69;
      validate_non_negative_index("y2d", "N", N);
      current_statement__ = 69;
      validate_non_negative_index("y2d", "N", N);
      context__.validate_dims("data initialization","y2d","double",
          context__.to_vec(N, N));
      y2d = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(y2d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2d_flat__;
        current_statement__ = 69;
        assign(y2d_flat__, nil_index_list(), context__.vals_r("y2d"),
          "assigning variable y2d_flat__");
        current_statement__ = 69;
        pos__ = 1;
        current_statement__ = 69;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 69;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 69;
            assign(y2d,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y2d_flat__[(pos__ - 1)], "assigning variable y2d");
            current_statement__ = 69;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 70;
      validate_non_negative_index("y3d", "N", N);
      current_statement__ = 70;
      validate_non_negative_index("y3d", "N", N);
      context__.validate_dims("data initialization","y3d","double",
          context__.to_vec(N, N));
      y3d = std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N));
      stan::math::fill(y3d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y3d_flat__;
        current_statement__ = 70;
        assign(y3d_flat__, nil_index_list(), context__.vals_r("y3d"),
          "assigning variable y3d_flat__");
        current_statement__ = 70;
        pos__ = 1;
        current_statement__ = 70;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 70;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 70;
            assign(y3d,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y3d_flat__[(pos__ - 1)], "assigning variable y3d");
            current_statement__ = 70;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 71;
      validate_non_negative_index("y4d", "N", N);
      current_statement__ = 71;
      validate_non_negative_index("y4d", "N", N);
      current_statement__ = 71;
      validate_non_negative_index("y4d", "N", N);
      context__.validate_dims("data initialization","y4d","double",
          context__.to_vec(N, N, N));
      y4d = std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N));
      stan::math::fill(y4d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y4d_flat__;
        current_statement__ = 71;
        assign(y4d_flat__, nil_index_list(), context__.vals_r("y4d"),
          "assigning variable y4d_flat__");
        current_statement__ = 71;
        pos__ = 1;
        current_statement__ = 71;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 71;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 71;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 71;
              assign(y4d,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                y4d_flat__[(pos__ - 1)], "assigning variable y4d");
              current_statement__ = 71;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 72;
      validate_non_negative_index("y5d", "N", N);
      current_statement__ = 72;
      validate_non_negative_index("y5d", "N", N);
      context__.validate_dims("data initialization","y5d","double",
          context__.to_vec(N, N));
      y5d = std::vector<std::vector<double>>(N, std::vector<double>(N, std::numeric_limits<double>::quiet_NaN()));
      
      {
        std::vector<local_scalar_t__> y5d_flat__;
        current_statement__ = 72;
        assign(y5d_flat__, nil_index_list(), context__.vals_r("y5d"),
          "assigning variable y5d_flat__");
        current_statement__ = 72;
        pos__ = 1;
        current_statement__ = 72;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 72;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 72;
            assign(y5d,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y5d_flat__[(pos__ - 1)], "assigning variable y5d");
            current_statement__ = 72;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 73;
      validate_non_negative_index("y6d", "N", N);
      current_statement__ = 73;
      validate_non_negative_index("y6d", "N", N);
      current_statement__ = 73;
      validate_non_negative_index("y6d", "N", N);
      context__.validate_dims("data initialization","y6d","double",
          context__.to_vec(N, N, N));
      y6d = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(N, std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N)));
      stan::math::fill(y6d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y6d_flat__;
        current_statement__ = 73;
        assign(y6d_flat__, nil_index_list(), context__.vals_r("y6d"),
          "assigning variable y6d_flat__");
        current_statement__ = 73;
        pos__ = 1;
        current_statement__ = 73;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 73;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 73;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 73;
              assign(y6d,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                y6d_flat__[(pos__ - 1)], "assigning variable y6d");
              current_statement__ = 73;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 74;
      validate_non_negative_index("y7d", "N", N);
      current_statement__ = 74;
      validate_non_negative_index("y7d", "N", N);
      current_statement__ = 74;
      validate_non_negative_index("y7d", "N", N);
      context__.validate_dims("data initialization","y7d","double",
          context__.to_vec(N, N, N));
      y7d = std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(N, std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N)));
      stan::math::fill(y7d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y7d_flat__;
        current_statement__ = 74;
        assign(y7d_flat__, nil_index_list(), context__.vals_r("y7d"),
          "assigning variable y7d_flat__");
        current_statement__ = 74;
        pos__ = 1;
        current_statement__ = 74;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 74;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 74;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 74;
              assign(y7d,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                y7d_flat__[(pos__ - 1)], "assigning variable y7d");
              current_statement__ = 74;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 75;
      validate_non_negative_index("y8d", "N", N);
      current_statement__ = 75;
      validate_non_negative_index("y8d", "N", N);
      current_statement__ = 75;
      validate_non_negative_index("y8d", "N", N);
      current_statement__ = 75;
      validate_non_negative_index("y8d", "N", N);
      context__.validate_dims("data initialization","y8d","double",
          context__.to_vec(N, N, N, N));
      y8d = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(N, std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N)));
      stan::math::fill(y8d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y8d_flat__;
        current_statement__ = 75;
        assign(y8d_flat__, nil_index_list(), context__.vals_r("y8d"),
          "assigning variable y8d_flat__");
        current_statement__ = 75;
        pos__ = 1;
        current_statement__ = 75;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 75;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 75;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 75;
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                current_statement__ = 75;
                assign(y8d,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  y8d_flat__[(pos__ - 1)], "assigning variable y8d");
                current_statement__ = 75;
                pos__ = (pos__ + 1);}}}}
      }
      context__.validate_dims("data initialization","y9d","double",
          context__.to_vec());
      y9d = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 76;
      y9d = context__.vals_r("y9d")[(1 - 1)];
      current_statement__ = 77;
      validate_non_negative_index("y10d", "N", N);
      context__.validate_dims("data initialization","y10d","double",
          context__.to_vec(N));
      y10d = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(y10d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y10d_flat__;
        current_statement__ = 77;
        assign(y10d_flat__, nil_index_list(), context__.vals_r("y10d"),
          "assigning variable y10d_flat__");
        current_statement__ = 77;
        pos__ = 1;
        current_statement__ = 77;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 77;
          assign(y10d, cons_list(index_uni(sym1__), nil_index_list()),
            y10d_flat__[(pos__ - 1)], "assigning variable y10d");
          current_statement__ = 77;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 78;
      validate_non_negative_index("y11d", "N", N);
      context__.validate_dims("data initialization","y11d","double",
          context__.to_vec(N));
      y11d = Eigen::Matrix<double, 1, -1>(N);
      stan::math::fill(y11d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y11d_flat__;
        current_statement__ = 78;
        assign(y11d_flat__, nil_index_list(), context__.vals_r("y11d"),
          "assigning variable y11d_flat__");
        current_statement__ = 78;
        pos__ = 1;
        current_statement__ = 78;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 78;
          assign(y11d, cons_list(index_uni(sym1__), nil_index_list()),
            y11d_flat__[(pos__ - 1)], "assigning variable y11d");
          current_statement__ = 78;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 79;
      validate_non_negative_index("y12d", "N", N);
      current_statement__ = 79;
      validate_non_negative_index("y12d", "N", N);
      context__.validate_dims("data initialization","y12d","double",
          context__.to_vec(N, N));
      y12d = Eigen::Matrix<double, -1, -1>(N, N);
      stan::math::fill(y12d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y12d_flat__;
        current_statement__ = 79;
        assign(y12d_flat__, nil_index_list(), context__.vals_r("y12d"),
          "assigning variable y12d_flat__");
        current_statement__ = 79;
        pos__ = 1;
        current_statement__ = 79;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 79;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 79;
            assign(y12d,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y12d_flat__[(pos__ - 1)], "assigning variable y12d");
            current_statement__ = 79;
            pos__ = (pos__ + 1);}}
      }
      context__.validate_dims("data initialization","y13d","int",
          context__.to_vec());
      y13d = std::numeric_limits<int>::min();
      
      current_statement__ = 80;
      y13d = context__.vals_i("y13d")[(1 - 1)];
      current_statement__ = 81;
      validate_non_negative_index("y14d", "N", N);
      context__.validate_dims("data initialization","y14d","int",
          context__.to_vec(N));
      y14d = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 81;
      assign(y14d, nil_index_list(), context__.vals_i("y14d"),
        "assigning variable y14d");
      current_statement__ = 82;
      validate_non_negative_index("y15d", "N", N);
      current_statement__ = 82;
      validate_non_negative_index("y15d", "N", N);
      context__.validate_dims("data initialization","y15d","int",
          context__.to_vec(N, N));
      y15d = std::vector<std::vector<int>>(N, std::vector<int>(N, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> y15d_flat__;
        current_statement__ = 82;
        assign(y15d_flat__, nil_index_list(), context__.vals_i("y15d"),
          "assigning variable y15d_flat__");
        current_statement__ = 82;
        pos__ = 1;
        current_statement__ = 82;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 82;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 82;
            assign(y15d,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y15d_flat__[(pos__ - 1)], "assigning variable y15d");
            current_statement__ = 82;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 83;
      validate_non_negative_index("y16d", "N", N);
      current_statement__ = 83;
      validate_non_negative_index("y16d", "N", N);
      current_statement__ = 83;
      validate_non_negative_index("y16d", "N", N);
      context__.validate_dims("data initialization","y16d","int",
          context__.to_vec(N, N, N));
      y16d = std::vector<std::vector<std::vector<int>>>(N, std::vector<std::vector<int>>(N, std::vector<int>(N, std::numeric_limits<int>::min())));
      
      {
        std::vector<int> y16d_flat__;
        current_statement__ = 83;
        assign(y16d_flat__, nil_index_list(), context__.vals_i("y16d"),
          "assigning variable y16d_flat__");
        current_statement__ = 83;
        pos__ = 1;
        current_statement__ = 83;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 83;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 83;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 83;
              assign(y16d,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                y16d_flat__[(pos__ - 1)], "assigning variable y16d");
              current_statement__ = 83;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 84;
      validate_non_negative_index("y17d", "N", N);
      current_statement__ = 84;
      validate_non_negative_index("y17d", "N", N);
      current_statement__ = 84;
      validate_non_negative_index("y17d", "N", N);
      context__.validate_dims("data initialization","y17d","double",
          context__.to_vec(N, N, N));
      y17d = std::vector<std::vector<std::vector<double>>>(N, std::vector<std::vector<double>>(N, std::vector<double>(N, std::numeric_limits<double>::quiet_NaN())));
      
      {
        std::vector<local_scalar_t__> y17d_flat__;
        current_statement__ = 84;
        assign(y17d_flat__, nil_index_list(), context__.vals_r("y17d"),
          "assigning variable y17d_flat__");
        current_statement__ = 84;
        pos__ = 1;
        current_statement__ = 84;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 84;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 84;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 84;
              assign(y17d,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                y17d_flat__[(pos__ - 1)], "assigning variable y17d");
              current_statement__ = 84;
              pos__ = (pos__ + 1);}}}
      }
      td1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 85;
      td1 = reduce_sum<f1_rsfunctor__>(y1d, 1, pstream__);
      td1a = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 86;
      td1a = (reduce_sum<f1_rsfunctor__>(y1d, 1, pstream__) +
               reduce_sum<f1a_rsfunctor__>(y1d, 1, pstream__));
      td2 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 87;
      td2 = reduce_sum<f2_rsfunctor__>(y2d, 1, pstream__);
      td3 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 88;
      td3 = reduce_sum<f3_rsfunctor__>(y3d, 1, pstream__);
      td4 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 89;
      td4 = reduce_sum<f4_rsfunctor__>(y4d, 1, pstream__);
      td5 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 90;
      td5 = reduce_sum<f5_rsfunctor__>(y5d, 1, pstream__);
      td6 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 91;
      td6 = reduce_sum<f6_rsfunctor__>(y6d, 1, pstream__);
      td7 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 92;
      td7 = reduce_sum<f7_rsfunctor__>(y7d, 1, pstream__);
      td8 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 93;
      td8 = reduce_sum<f8_rsfunctor__>(y8d, 1, pstream__);
      td9 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 94;
      td9 = reduce_sum<f9_rsfunctor__>(y14d, 1, pstream__);
      td10 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 95;
      td10 = reduce_sum<f10_rsfunctor__>(y15d, 1, pstream__);
      td11 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 96;
      td11 = reduce_sum<f11_rsfunctor__>(y16d, 1, pstream__);
      td12 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 97;
      td12 = reduce_sum<f12_rsfunctor__>(y17d, 1, pstream__);
      tgd1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 98;
      tgd1 = reduce_sum<g1_rsfunctor__>(y1d, 1, pstream__, y9d);
      tgd2 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 99;
      tgd2 = reduce_sum<g2_rsfunctor__>(y1d, 1, pstream__, y10d);
      tgd3 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 100;
      tgd3 = reduce_sum<g3_rsfunctor__>(y1d, 1, pstream__, y11d);
      tgd4 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 101;
      tgd4 = reduce_sum<g4_rsfunctor__>(y1d, 1, pstream__, y12d);
      tgd5 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 102;
      tgd5 = reduce_sum<g5_rsfunctor__>(y1d, 1, pstream__, y1d);
      tgd6 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 103;
      tgd6 = reduce_sum<g6_rsfunctor__>(y1d, 1, pstream__, y2d);
      tgd7 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 104;
      tgd7 = reduce_sum<g7_rsfunctor__>(y1d, 1, pstream__, y3d);
      tgd8 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 105;
      tgd8 = reduce_sum<g8_rsfunctor__>(y1d, 1, pstream__, y4d);
      tgd9 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 106;
      tgd9 = reduce_sum<g9_rsfunctor__>(y1d, 1, pstream__, y5d);
      tgd10 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 107;
      tgd10 = reduce_sum<g10_rsfunctor__>(y1d, 1, pstream__, y6d);
      tgd11 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 108;
      tgd11 = reduce_sum<g11_rsfunctor__>(y1d, 1, pstream__, y7d);
      tgd12 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 109;
      tgd12 = reduce_sum<g12_rsfunctor__>(y1d, 1, pstream__, y8d);
      tsd = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 110;
      tsd = reduce_sum<s_rsfunctor__>(y1d, 1, pstream__, y13d, y9d, y10d,
              y11d, y12d, y14d, y1d, y2d, y3d, y4d, y15d, y5d, y6d, y7d, y8d,
              y16d, y17d);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      current_statement__ = 1;
      validate_non_negative_index("y1", "N", N);
      num_params_r__ += N;
      current_statement__ = 2;
      validate_non_negative_index("y2", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("y2", "N", N);
      num_params_r__ += N * N;
      current_statement__ = 3;
      validate_non_negative_index("y3", "N", N);
      current_statement__ = 3;
      validate_non_negative_index("y3", "N", N);
      num_params_r__ += N * N;
      current_statement__ = 4;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 4;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 4;
      validate_non_negative_index("y4", "N", N);
      num_params_r__ += N * N * N;
      current_statement__ = 5;
      validate_non_negative_index("y5", "N", N);
      current_statement__ = 5;
      validate_non_negative_index("y5", "N", N);
      num_params_r__ += N * N;
      current_statement__ = 6;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("y6", "N", N);
      num_params_r__ += N * N * N;
      current_statement__ = 7;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 7;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 7;
      validate_non_negative_index("y7", "N", N);
      num_params_r__ += N * N * N;
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      num_params_r__ += N * N * N * N;
      num_params_r__ += 1;
      current_statement__ = 10;
      validate_non_negative_index("y10", "N", N);
      num_params_r__ += N;
      current_statement__ = 11;
      validate_non_negative_index("y11", "N", N);
      num_params_r__ += N;
      current_statement__ = 12;
      validate_non_negative_index("y12", "N", N);
      current_statement__ = 12;
      validate_non_negative_index("y12", "N", N);
      num_params_r__ += N * N;
      current_statement__ = 13;
      validate_non_negative_index("y17", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y17", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y17", "N", N);
      num_params_r__ += N * N * N;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  inline T__ log_prob(std::vector<T__>& params_r__,
                      std::vector<int>& params_i__,
                      std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "reduce_sum_m3_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      current_statement__ = 1;
      validate_non_negative_index("y1", "N", N);
      std::vector<local_scalar_t__> y1;
      y1 = std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 1;
        assign(y1, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable y1");}
      current_statement__ = 2;
      validate_non_negative_index("y2", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("y2", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> y2;
      y2 = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N));
      stan::math::fill(y2, DUMMY_VAR__);
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 2;
        assign(y2, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(N), "assigning variable y2");}
      current_statement__ = 3;
      validate_non_negative_index("y3", "N", N);
      current_statement__ = 3;
      validate_non_negative_index("y3", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>> y3;
      y3 = std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(N, Eigen::Matrix<local_scalar_t__, 1, -1>(N));
      stan::math::fill(y3, DUMMY_VAR__);
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 3;
        assign(y3, cons_list(index_uni(sym1__), nil_index_list()),
          in__.row_vector(N), "assigning variable y3");}
      current_statement__ = 4;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 4;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 4;
      validate_non_negative_index("y4", "N", N);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> y4;
      y4 = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(N, Eigen::Matrix<local_scalar_t__, -1, -1>(N, N));
      stan::math::fill(y4, DUMMY_VAR__);
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 4;
        assign(y4, cons_list(index_uni(sym1__), nil_index_list()),
          in__.matrix(N, N), "assigning variable y4");}
      current_statement__ = 5;
      validate_non_negative_index("y5", "N", N);
      current_statement__ = 5;
      validate_non_negative_index("y5", "N", N);
      std::vector<std::vector<local_scalar_t__>> y5;
      y5 = std::vector<std::vector<local_scalar_t__>>(N, std::vector<local_scalar_t__>(N, DUMMY_VAR__));
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 5;
          assign(y5,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())), in__.scalar(),
            "assigning variable y5");}}
      current_statement__ = 6;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("y6", "N", N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> y6;
      y6 = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N, Eigen::Matrix<local_scalar_t__, -1, 1>(N)));
      stan::math::fill(y6, DUMMY_VAR__);
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 6;
          assign(y6,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.vector(N), "assigning variable y6");}}
      current_statement__ = 7;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 7;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 7;
      validate_non_negative_index("y7", "N", N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>> y7;
      y7 = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(N, Eigen::Matrix<local_scalar_t__, 1, -1>(N)));
      stan::math::fill(y7, DUMMY_VAR__);
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 7;
          assign(y7,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.row_vector(N), "assigning variable y7");}}
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>> y8;
      y8 = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>>(N, std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(N, Eigen::Matrix<local_scalar_t__, -1, -1>(N, N)));
      stan::math::fill(y8, DUMMY_VAR__);
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 8;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 8;
          assign(y8,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.matrix(N, N), "assigning variable y8");}}
      local_scalar_t__ y9;
      y9 = DUMMY_VAR__;
      
      current_statement__ = 9;
      y9 = in__.scalar();
      current_statement__ = 10;
      validate_non_negative_index("y10", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> y10;
      y10 = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y10, DUMMY_VAR__);
      
      current_statement__ = 10;
      y10 = in__.vector(N);
      current_statement__ = 11;
      validate_non_negative_index("y11", "N", N);
      Eigen::Matrix<local_scalar_t__, 1, -1> y11;
      y11 = Eigen::Matrix<local_scalar_t__, 1, -1>(N);
      stan::math::fill(y11, DUMMY_VAR__);
      
      current_statement__ = 11;
      y11 = in__.row_vector(N);
      current_statement__ = 12;
      validate_non_negative_index("y12", "N", N);
      current_statement__ = 12;
      validate_non_negative_index("y12", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, -1> y12;
      y12 = Eigen::Matrix<local_scalar_t__, -1, -1>(N, N);
      stan::math::fill(y12, DUMMY_VAR__);
      
      current_statement__ = 12;
      y12 = in__.matrix(N, N);
      current_statement__ = 13;
      validate_non_negative_index("y17", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y17", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y17", "N", N);
      std::vector<std::vector<std::vector<local_scalar_t__>>> y17;
      y17 = std::vector<std::vector<std::vector<local_scalar_t__>>>(N, std::vector<std::vector<local_scalar_t__>>(N, std::vector<local_scalar_t__>(N, DUMMY_VAR__)));
      
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 13;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 13;
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 13;
            assign(y17,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              in__.scalar(), "assigning variable y17");}}}
      {
        local_scalar_t__ t1;
        t1 = DUMMY_VAR__;
        
        current_statement__ = 40;
        t1 = reduce_sum<f1_rsfunctor__>(y1, 1, pstream__);
        local_scalar_t__ t1a;
        t1a = DUMMY_VAR__;
        
        current_statement__ = 41;
        t1a = (reduce_sum<f1_rsfunctor__>(y1, 1, pstream__) +
                reduce_sum<f1a_rsfunctor__>(y1, 1, pstream__));
        local_scalar_t__ t2;
        t2 = DUMMY_VAR__;
        
        current_statement__ = 42;
        t2 = reduce_sum<f2_rsfunctor__>(y2, 1, pstream__);
        local_scalar_t__ t3;
        t3 = DUMMY_VAR__;
        
        current_statement__ = 43;
        t3 = reduce_sum<f3_rsfunctor__>(y3, 1, pstream__);
        local_scalar_t__ t4;
        t4 = DUMMY_VAR__;
        
        current_statement__ = 44;
        t4 = reduce_sum<f4_rsfunctor__>(y4, 1, pstream__);
        local_scalar_t__ t5;
        t5 = DUMMY_VAR__;
        
        current_statement__ = 45;
        t5 = reduce_sum<f5_rsfunctor__>(y5, 1, pstream__);
        local_scalar_t__ t6;
        t6 = DUMMY_VAR__;
        
        current_statement__ = 46;
        t6 = reduce_sum<f6_rsfunctor__>(y6, 1, pstream__);
        local_scalar_t__ t7;
        t7 = DUMMY_VAR__;
        
        current_statement__ = 47;
        t7 = reduce_sum<f7_rsfunctor__>(y7, 1, pstream__);
        local_scalar_t__ t8;
        t8 = DUMMY_VAR__;
        
        current_statement__ = 48;
        t8 = reduce_sum<f8_rsfunctor__>(y8, 1, pstream__);
        local_scalar_t__ t9;
        t9 = DUMMY_VAR__;
        
        current_statement__ = 49;
        t9 = reduce_sum<f9_rsfunctor__>(y14d, 1, pstream__);
        local_scalar_t__ t10;
        t10 = DUMMY_VAR__;
        
        current_statement__ = 50;
        t10 = reduce_sum<f10_rsfunctor__>(y15d, 1, pstream__);
        local_scalar_t__ t11;
        t11 = DUMMY_VAR__;
        
        current_statement__ = 51;
        t11 = reduce_sum<f11_rsfunctor__>(y16d, 1, pstream__);
        local_scalar_t__ t12;
        t12 = DUMMY_VAR__;
        
        current_statement__ = 52;
        t12 = reduce_sum<f12_rsfunctor__>(y17, 1, pstream__);
        local_scalar_t__ tg1;
        tg1 = DUMMY_VAR__;
        
        current_statement__ = 53;
        tg1 = reduce_sum<g1_rsfunctor__>(y1, 1, pstream__, y9);
        local_scalar_t__ tg2;
        tg2 = DUMMY_VAR__;
        
        current_statement__ = 54;
        tg2 = reduce_sum<g2_rsfunctor__>(y1, 1, pstream__, y10);
        local_scalar_t__ tg3;
        tg3 = DUMMY_VAR__;
        
        current_statement__ = 55;
        tg3 = reduce_sum<g3_rsfunctor__>(y1, 1, pstream__, y11);
        local_scalar_t__ tg4;
        tg4 = DUMMY_VAR__;
        
        current_statement__ = 56;
        tg4 = reduce_sum<g4_rsfunctor__>(y1, 1, pstream__, y12);
        local_scalar_t__ tg5;
        tg5 = DUMMY_VAR__;
        
        current_statement__ = 57;
        tg5 = reduce_sum<g5_rsfunctor__>(y1, 1, pstream__, y1);
        local_scalar_t__ tg6;
        tg6 = DUMMY_VAR__;
        
        current_statement__ = 58;
        tg6 = reduce_sum<g6_rsfunctor__>(y1, 1, pstream__, y2);
        local_scalar_t__ tg7;
        tg7 = DUMMY_VAR__;
        
        current_statement__ = 59;
        tg7 = reduce_sum<g7_rsfunctor__>(y1, 1, pstream__, y3);
        local_scalar_t__ tg8;
        tg8 = DUMMY_VAR__;
        
        current_statement__ = 60;
        tg8 = reduce_sum<g8_rsfunctor__>(y1, 1, pstream__, y4);
        local_scalar_t__ tg9;
        tg9 = DUMMY_VAR__;
        
        current_statement__ = 61;
        tg9 = reduce_sum<g9_rsfunctor__>(y1, 1, pstream__, y5);
        local_scalar_t__ tg10;
        tg10 = DUMMY_VAR__;
        
        current_statement__ = 62;
        tg10 = reduce_sum<g10_rsfunctor__>(y1, 1, pstream__, y6);
        local_scalar_t__ tg11;
        tg11 = DUMMY_VAR__;
        
        current_statement__ = 63;
        tg11 = reduce_sum<g11_rsfunctor__>(y1, 1, pstream__, y7);
        local_scalar_t__ tg12;
        tg12 = DUMMY_VAR__;
        
        current_statement__ = 64;
        tg12 = reduce_sum<g12_rsfunctor__>(y1, 1, pstream__, y8);
        local_scalar_t__ ts;
        ts = DUMMY_VAR__;
        
        current_statement__ = 65;
        ts = reduce_sum<s_rsfunctor__>(y1d, 1, pstream__, y13d, y9, y10, y11,
               y12, y14d, y1, y2, y3, y4, y15d, y5, y6, y7, y8, y16d, y17);
        local_scalar_t__ tt;
        tt = DUMMY_VAR__;
        
        current_statement__ = 66;
        tt = r(pstream__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  inline void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                          std::vector<int>& params_i__,
                          std::vector<double>& vars__,
                          bool emit_transformed_parameters__ = true,
                          bool emit_generated_quantities__ = true,
                          std::ostream* pstream__ = 0) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "reduce_sum_m3_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      current_statement__ = 1;
      validate_non_negative_index("y1", "N", N);
      std::vector<double> y1;
      y1 = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 1;
        assign(y1, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable y1");}
      current_statement__ = 2;
      validate_non_negative_index("y2", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("y2", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> y2;
      y2 = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(y2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 2;
        assign(y2, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(N), "assigning variable y2");}
      current_statement__ = 3;
      validate_non_negative_index("y3", "N", N);
      current_statement__ = 3;
      validate_non_negative_index("y3", "N", N);
      std::vector<Eigen::Matrix<double, 1, -1>> y3;
      y3 = std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N));
      stan::math::fill(y3, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 3;
        assign(y3, cons_list(index_uni(sym1__), nil_index_list()),
          in__.row_vector(N), "assigning variable y3");}
      current_statement__ = 4;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 4;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 4;
      validate_non_negative_index("y4", "N", N);
      std::vector<Eigen::Matrix<double, -1, -1>> y4;
      y4 = std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N));
      stan::math::fill(y4, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 4;
        assign(y4, cons_list(index_uni(sym1__), nil_index_list()),
          in__.matrix(N, N), "assigning variable y4");}
      current_statement__ = 5;
      validate_non_negative_index("y5", "N", N);
      current_statement__ = 5;
      validate_non_negative_index("y5", "N", N);
      std::vector<std::vector<double>> y5;
      y5 = std::vector<std::vector<double>>(N, std::vector<double>(N, std::numeric_limits<double>::quiet_NaN()));
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 5;
          assign(y5,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())), in__.scalar(),
            "assigning variable y5");}}
      current_statement__ = 6;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("y6", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> y6;
      y6 = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(N, std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N)));
      stan::math::fill(y6, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 6;
          assign(y6,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.vector(N), "assigning variable y6");}}
      current_statement__ = 7;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 7;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 7;
      validate_non_negative_index("y7", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, 1, -1>>> y7;
      y7 = std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(N, std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N)));
      stan::math::fill(y7, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 7;
          assign(y7,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.row_vector(N), "assigning variable y7");}}
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> y8;
      y8 = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(N, std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N)));
      stan::math::fill(y8, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 8;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 8;
          assign(y8,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.matrix(N, N), "assigning variable y8");}}
      double y9;
      y9 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 9;
      y9 = in__.scalar();
      current_statement__ = 10;
      validate_non_negative_index("y10", "N", N);
      Eigen::Matrix<double, -1, 1> y10;
      y10 = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(y10, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 10;
      y10 = in__.vector(N);
      current_statement__ = 11;
      validate_non_negative_index("y11", "N", N);
      Eigen::Matrix<double, 1, -1> y11;
      y11 = Eigen::Matrix<double, 1, -1>(N);
      stan::math::fill(y11, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 11;
      y11 = in__.row_vector(N);
      current_statement__ = 12;
      validate_non_negative_index("y12", "N", N);
      current_statement__ = 12;
      validate_non_negative_index("y12", "N", N);
      Eigen::Matrix<double, -1, -1> y12;
      y12 = Eigen::Matrix<double, -1, -1>(N, N);
      stan::math::fill(y12, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 12;
      y12 = in__.matrix(N, N);
      current_statement__ = 13;
      validate_non_negative_index("y17", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y17", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y17", "N", N);
      std::vector<std::vector<std::vector<double>>> y17;
      y17 = std::vector<std::vector<std::vector<double>>>(N, std::vector<std::vector<double>>(N, std::vector<double>(N, std::numeric_limits<double>::quiet_NaN())));
      
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 13;
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          current_statement__ = 13;
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            current_statement__ = 13;
            assign(y17,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              in__.scalar(), "assigning variable y17");}}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y1[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(y2[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(y3[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(
              rvalue(y4,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))), "y4"));
          }}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(y5[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(y6[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(y7[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                rvalue(y8,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  "y8"));}}}}
      vars__.push_back(y9);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y10[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y11[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(
            rvalue(y12,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "y12"));}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(y17[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}
        }}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double t1;
      t1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 14;
      t1 = reduce_sum<f1_rsfunctor__>(y1, 1, pstream__);
      double t1a;
      t1a = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 15;
      t1a = (reduce_sum<f1_rsfunctor__>(y1, 1, pstream__) +
              reduce_sum<f1a_rsfunctor__>(y1, 1, pstream__));
      double t2;
      t2 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 16;
      t2 = reduce_sum<f2_rsfunctor__>(y2, 1, pstream__);
      double t3;
      t3 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 17;
      t3 = reduce_sum<f3_rsfunctor__>(y3, 1, pstream__);
      double t4;
      t4 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 18;
      t4 = reduce_sum<f4_rsfunctor__>(y4, 1, pstream__);
      double t5;
      t5 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 19;
      t5 = reduce_sum<f5_rsfunctor__>(y5, 1, pstream__);
      double t6;
      t6 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 20;
      t6 = reduce_sum<f6_rsfunctor__>(y6, 1, pstream__);
      double t7;
      t7 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 21;
      t7 = reduce_sum<f7_rsfunctor__>(y7, 1, pstream__);
      double t8;
      t8 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 22;
      t8 = reduce_sum<f8_rsfunctor__>(y8, 1, pstream__);
      double t9;
      t9 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 23;
      t9 = reduce_sum<f9_rsfunctor__>(y14d, 1, pstream__);
      double t10;
      t10 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 24;
      t10 = reduce_sum<f10_rsfunctor__>(y15d, 1, pstream__);
      double t11;
      t11 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 25;
      t11 = reduce_sum<f11_rsfunctor__>(y16d, 1, pstream__);
      double t12;
      t12 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 26;
      t12 = reduce_sum<f12_rsfunctor__>(y17, 1, pstream__);
      double tg1;
      tg1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 27;
      tg1 = reduce_sum<g1_rsfunctor__>(y1, 1, pstream__, y9);
      double tg2;
      tg2 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 28;
      tg2 = reduce_sum<g2_rsfunctor__>(y1, 1, pstream__, y10);
      double tg3;
      tg3 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 29;
      tg3 = reduce_sum<g3_rsfunctor__>(y1, 1, pstream__, y11);
      double tg4;
      tg4 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 30;
      tg4 = reduce_sum<g4_rsfunctor__>(y1, 1, pstream__, y12);
      double tg5;
      tg5 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 31;
      tg5 = reduce_sum<g5_rsfunctor__>(y1, 1, pstream__, y1);
      double tg6;
      tg6 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 32;
      tg6 = reduce_sum<g6_rsfunctor__>(y1, 1, pstream__, y2);
      double tg7;
      tg7 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 33;
      tg7 = reduce_sum<g7_rsfunctor__>(y1, 1, pstream__, y3);
      double tg8;
      tg8 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 34;
      tg8 = reduce_sum<g8_rsfunctor__>(y1, 1, pstream__, y4);
      double tg9;
      tg9 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 35;
      tg9 = reduce_sum<g9_rsfunctor__>(y1, 1, pstream__, y5);
      double tg10;
      tg10 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 36;
      tg10 = reduce_sum<g10_rsfunctor__>(y1, 1, pstream__, y6);
      double tg11;
      tg11 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 37;
      tg11 = reduce_sum<g11_rsfunctor__>(y1, 1, pstream__, y7);
      double tg12;
      tg12 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 38;
      tg12 = reduce_sum<g12_rsfunctor__>(y1, 1, pstream__, y8);
      double tgs;
      tgs = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 39;
      tgs = reduce_sum<s_rsfunctor__>(y1d, 1, pstream__, y13d, y9d, y10d,
              y11d, y12d, y14d, y1d, y2d, y3d, y4d, y15d, y5d, y6d, y7d, y8d,
              y16d, y17);
      vars__.push_back(t1);
      vars__.push_back(t1a);
      vars__.push_back(t2);
      vars__.push_back(t3);
      vars__.push_back(t4);
      vars__.push_back(t5);
      vars__.push_back(t6);
      vars__.push_back(t7);
      vars__.push_back(t8);
      vars__.push_back(t9);
      vars__.push_back(t10);
      vars__.push_back(t11);
      vars__.push_back(t12);
      vars__.push_back(tg1);
      vars__.push_back(tg2);
      vars__.push_back(tg3);
      vars__.push_back(tg4);
      vars__.push_back(tg5);
      vars__.push_back(tg6);
      vars__.push_back(tg7);
      vars__.push_back(tg8);
      vars__.push_back(tg9);
      vars__.push_back(tg10);
      vars__.push_back(tg11);
      vars__.push_back(tg12);
      vars__.push_back(tgs);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  inline void transform_inits(const stan::io::var_context& context__,
                              std::vector<int>& params_i__,
                              std::vector<double>& vars__,
                              std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 1;
      validate_non_negative_index("y1", "N", N);
      std::vector<double> y1;
      y1 = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      assign(y1, nil_index_list(), context__.vals_r("y1"),
        "assigning variable y1");
      current_statement__ = 2;
      validate_non_negative_index("y2", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("y2", "N", N);
      std::vector<Eigen::Matrix<double, -1, 1>> y2;
      y2 = std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N));
      stan::math::fill(y2, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2_flat__;
        current_statement__ = 2;
        assign(y2_flat__, nil_index_list(), context__.vals_r("y2"),
          "assigning variable y2_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 2;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 2;
            assign(y2,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y2_flat__[(pos__ - 1)], "assigning variable y2");
            current_statement__ = 2;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 3;
      validate_non_negative_index("y3", "N", N);
      current_statement__ = 3;
      validate_non_negative_index("y3", "N", N);
      std::vector<Eigen::Matrix<double, 1, -1>> y3;
      y3 = std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N));
      stan::math::fill(y3, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y3_flat__;
        current_statement__ = 3;
        assign(y3_flat__, nil_index_list(), context__.vals_r("y3"),
          "assigning variable y3_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 3;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 3;
            assign(y3,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y3_flat__[(pos__ - 1)], "assigning variable y3");
            current_statement__ = 3;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 4;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 4;
      validate_non_negative_index("y4", "N", N);
      current_statement__ = 4;
      validate_non_negative_index("y4", "N", N);
      std::vector<Eigen::Matrix<double, -1, -1>> y4;
      y4 = std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N));
      stan::math::fill(y4, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y4_flat__;
        current_statement__ = 4;
        assign(y4_flat__, nil_index_list(), context__.vals_r("y4"),
          "assigning variable y4_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 4;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 4;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 4;
              assign(y4,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                y4_flat__[(pos__ - 1)], "assigning variable y4");
              current_statement__ = 4;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 5;
      validate_non_negative_index("y5", "N", N);
      current_statement__ = 5;
      validate_non_negative_index("y5", "N", N);
      std::vector<std::vector<double>> y5;
      y5 = std::vector<std::vector<double>>(N, std::vector<double>(N, std::numeric_limits<double>::quiet_NaN()));
      
      {
        std::vector<local_scalar_t__> y5_flat__;
        current_statement__ = 5;
        assign(y5_flat__, nil_index_list(), context__.vals_r("y5"),
          "assigning variable y5_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 5;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 5;
            assign(y5,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y5_flat__[(pos__ - 1)], "assigning variable y5");
            current_statement__ = 5;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 6;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("y6", "N", N);
      current_statement__ = 6;
      validate_non_negative_index("y6", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> y6;
      y6 = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(N, std::vector<Eigen::Matrix<double, -1, 1>>(N, Eigen::Matrix<double, -1, 1>(N)));
      stan::math::fill(y6, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y6_flat__;
        current_statement__ = 6;
        assign(y6_flat__, nil_index_list(), context__.vals_r("y6"),
          "assigning variable y6_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 6;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 6;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 6;
              assign(y6,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                y6_flat__[(pos__ - 1)], "assigning variable y6");
              current_statement__ = 6;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 7;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 7;
      validate_non_negative_index("y7", "N", N);
      current_statement__ = 7;
      validate_non_negative_index("y7", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, 1, -1>>> y7;
      y7 = std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(N, std::vector<Eigen::Matrix<double, 1, -1>>(N, Eigen::Matrix<double, 1, -1>(N)));
      stan::math::fill(y7, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y7_flat__;
        current_statement__ = 7;
        assign(y7_flat__, nil_index_list(), context__.vals_r("y7"),
          "assigning variable y7_flat__");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 7;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 7;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 7;
              assign(y7,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                y7_flat__[(pos__ - 1)], "assigning variable y7");
              current_statement__ = 7;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      current_statement__ = 8;
      validate_non_negative_index("y8", "N", N);
      std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> y8;
      y8 = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(N, std::vector<Eigen::Matrix<double, -1, -1>>(N, Eigen::Matrix<double, -1, -1>(N, N)));
      stan::math::fill(y8, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y8_flat__;
        current_statement__ = 8;
        assign(y8_flat__, nil_index_list(), context__.vals_r("y8"),
          "assigning variable y8_flat__");
        current_statement__ = 8;
        pos__ = 1;
        current_statement__ = 8;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 8;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 8;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 8;
              for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                current_statement__ = 8;
                assign(y8,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  y8_flat__[(pos__ - 1)], "assigning variable y8");
                current_statement__ = 8;
                pos__ = (pos__ + 1);}}}}
      }
      double y9;
      y9 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 9;
      y9 = context__.vals_r("y9")[(1 - 1)];
      current_statement__ = 10;
      validate_non_negative_index("y10", "N", N);
      Eigen::Matrix<double, -1, 1> y10;
      y10 = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(y10, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y10_flat__;
        current_statement__ = 10;
        assign(y10_flat__, nil_index_list(), context__.vals_r("y10"),
          "assigning variable y10_flat__");
        current_statement__ = 10;
        pos__ = 1;
        current_statement__ = 10;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 10;
          assign(y10, cons_list(index_uni(sym1__), nil_index_list()),
            y10_flat__[(pos__ - 1)], "assigning variable y10");
          current_statement__ = 10;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 11;
      validate_non_negative_index("y11", "N", N);
      Eigen::Matrix<double, 1, -1> y11;
      y11 = Eigen::Matrix<double, 1, -1>(N);
      stan::math::fill(y11, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y11_flat__;
        current_statement__ = 11;
        assign(y11_flat__, nil_index_list(), context__.vals_r("y11"),
          "assigning variable y11_flat__");
        current_statement__ = 11;
        pos__ = 1;
        current_statement__ = 11;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 11;
          assign(y11, cons_list(index_uni(sym1__), nil_index_list()),
            y11_flat__[(pos__ - 1)], "assigning variable y11");
          current_statement__ = 11;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 12;
      validate_non_negative_index("y12", "N", N);
      current_statement__ = 12;
      validate_non_negative_index("y12", "N", N);
      Eigen::Matrix<double, -1, -1> y12;
      y12 = Eigen::Matrix<double, -1, -1>(N, N);
      stan::math::fill(y12, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y12_flat__;
        current_statement__ = 12;
        assign(y12_flat__, nil_index_list(), context__.vals_r("y12"),
          "assigning variable y12_flat__");
        current_statement__ = 12;
        pos__ = 1;
        current_statement__ = 12;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 12;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 12;
            assign(y12,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y12_flat__[(pos__ - 1)], "assigning variable y12");
            current_statement__ = 12;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 13;
      validate_non_negative_index("y17", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y17", "N", N);
      current_statement__ = 13;
      validate_non_negative_index("y17", "N", N);
      std::vector<std::vector<std::vector<double>>> y17;
      y17 = std::vector<std::vector<std::vector<double>>>(N, std::vector<std::vector<double>>(N, std::vector<double>(N, std::numeric_limits<double>::quiet_NaN())));
      
      {
        std::vector<local_scalar_t__> y17_flat__;
        current_statement__ = 13;
        assign(y17_flat__, nil_index_list(), context__.vals_r("y17"),
          "assigning variable y17_flat__");
        current_statement__ = 13;
        pos__ = 1;
        current_statement__ = 13;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 13;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 13;
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              current_statement__ = 13;
              assign(y17,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                y17_flat__[(pos__ - 1)], "assigning variable y17");
              current_statement__ = 13;
              pos__ = (pos__ + 1);}}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y1[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(y2[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(y3[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(
              rvalue(y4,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))), "y4"));
          }}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(y5[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(y6[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(y7[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
              vars__.push_back(
                rvalue(y8,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  "y8"));}}}}
      vars__.push_back(y9);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y10[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.push_back(y11[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          vars__.push_back(
            rvalue(y12,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "y12"));}}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
            vars__.push_back(y17[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}
        }}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("y1");
    names__.push_back("y2");
    names__.push_back("y3");
    names__.push_back("y4");
    names__.push_back("y5");
    names__.push_back("y6");
    names__.push_back("y7");
    names__.push_back("y8");
    names__.push_back("y9");
    names__.push_back("y10");
    names__.push_back("y11");
    names__.push_back("y12");
    names__.push_back("y17");
    names__.push_back("t1");
    names__.push_back("t1a");
    names__.push_back("t2");
    names__.push_back("t3");
    names__.push_back("t4");
    names__.push_back("t5");
    names__.push_back("t6");
    names__.push_back("t7");
    names__.push_back("t8");
    names__.push_back("t9");
    names__.push_back("t10");
    names__.push_back("t11");
    names__.push_back("t12");
    names__.push_back("tg1");
    names__.push_back("tg2");
    names__.push_back("tg3");
    names__.push_back("tg4");
    names__.push_back("tg5");
    names__.push_back("tg6");
    names__.push_back("tg7");
    names__.push_back("tg8");
    names__.push_back("tg9");
    names__.push_back("tg10");
    names__.push_back("tg11");
    names__.push_back("tg12");
    names__.push_back("tgs");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    
    dims__.push_back(N);
    
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const {
    
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y1" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y3" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y4" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y5" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y6" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y7" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "y8" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    param_names__.push_back(std::string() + "y9");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y10" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y11" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y12" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y17" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "t1");
      param_names__.push_back(std::string() + "t1a");
      param_names__.push_back(std::string() + "t2");
      param_names__.push_back(std::string() + "t3");
      param_names__.push_back(std::string() + "t4");
      param_names__.push_back(std::string() + "t5");
      param_names__.push_back(std::string() + "t6");
      param_names__.push_back(std::string() + "t7");
      param_names__.push_back(std::string() + "t8");
      param_names__.push_back(std::string() + "t9");
      param_names__.push_back(std::string() + "t10");
      param_names__.push_back(std::string() + "t11");
      param_names__.push_back(std::string() + "t12");
      param_names__.push_back(std::string() + "tg1");
      param_names__.push_back(std::string() + "tg2");
      param_names__.push_back(std::string() + "tg3");
      param_names__.push_back(std::string() + "tg4");
      param_names__.push_back(std::string() + "tg5");
      param_names__.push_back(std::string() + "tg6");
      param_names__.push_back(std::string() + "tg7");
      param_names__.push_back(std::string() + "tg8");
      param_names__.push_back(std::string() + "tg9");
      param_names__.push_back(std::string() + "tg10");
      param_names__.push_back(std::string() + "tg11");
      param_names__.push_back(std::string() + "tg12");
      param_names__.push_back(std::string() + "tgs");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const {
    
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y1" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y3" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y4" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y5" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y6" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y7" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                for (int sym4__ = 1; sym4__ <= N; ++sym4__) {
                  {
                    param_names__.push_back(std::string() + "y8" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }}
              }}
          }}
      }}
    param_names__.push_back(std::string() + "y9");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y10" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.push_back(std::string() + "y11" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.push_back(std::string() + "y12" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= N; ++sym3__) {
              {
                param_names__.push_back(std::string() + "y17" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "t1");
      param_names__.push_back(std::string() + "t1a");
      param_names__.push_back(std::string() + "t2");
      param_names__.push_back(std::string() + "t3");
      param_names__.push_back(std::string() + "t4");
      param_names__.push_back(std::string() + "t5");
      param_names__.push_back(std::string() + "t6");
      param_names__.push_back(std::string() + "t7");
      param_names__.push_back(std::string() + "t8");
      param_names__.push_back(std::string() + "t9");
      param_names__.push_back(std::string() + "t10");
      param_names__.push_back(std::string() + "t11");
      param_names__.push_back(std::string() + "t12");
      param_names__.push_back(std::string() + "tg1");
      param_names__.push_back(std::string() + "tg2");
      param_names__.push_back(std::string() + "tg3");
      param_names__.push_back(std::string() + "tg4");
      param_names__.push_back(std::string() + "tg5");
      param_names__.push_back(std::string() + "tg6");
      param_names__.push_back(std::string() + "tg7");
      param_names__.push_back(std::string() + "tg8");
      param_names__.push_back(std::string() + "tg9");
      param_names__.push_back(std::string() + "tg10");
      param_names__.push_back(std::string() + "tg11");
      param_names__.push_back(std::string() + "tg12");
      param_names__.push_back(std::string() + "tgs");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"y1\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y2\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"y3\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"y4\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"y5\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"y6\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"y7\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"y8\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"y9\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y10\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"y11\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"y12\",\"type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "},\"block\":\"parameters\"},{\"name\":\"y17\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"parameters\"},{\"name\":\"t1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t1a\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t3\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t4\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t5\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t6\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t7\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t8\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t9\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t10\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t11\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t12\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg3\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg4\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg5\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg6\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg7\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg8\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg9\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg10\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg11\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg12\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tgs\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"y1\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"y2\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"y3\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"y4\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "}},\"block\":\"parameters\"},{\"name\":\"y5\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"parameters\"},{\"name\":\"y6\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"y7\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"vector\",\"length\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"y8\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "}}},\"block\":\"parameters\"},{\"name\":\"y9\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y10\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"y11\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"y12\",\"type\":{\"name\":\"matrix\",\"rows\":" << N << ",\"cols\":" << N << "},\"block\":\"parameters\"},{\"name\":\"y17\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"parameters\"},{\"name\":\"t1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t1a\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t3\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t4\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t5\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t6\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t7\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t8\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t9\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t10\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t11\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"t12\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg3\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg4\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg5\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg6\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg7\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg8\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg9\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg10\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg11\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tg12\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tgs\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef reduce_sum_m3_model_namespace::reduce_sum_m3_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp tilde-block.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace tilde_block_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'tilde-block.stan', line 5, column 4 to column 20)",
                                                      " (in 'tilde-block.stan', line 11, column 27 to column 28)",
                                                      " (in 'tilde-block.stan', line 11, column 8 to column 31)",
                                                      " (in 'tilde-block.stan', line 8, column 4 to line 11, column 31)",
                                                      " (in 'tilde-block.stan', line 9, column 34 to column 35)",
                                                      " (in 'tilde-block.stan', line 9, column 8 to column 38)",
                                                      " (in 'tilde-block.stan', line 2, column 4 to column 10)"};



class tilde_block_model : public model_base_crtp<tilde_block_model> {

 private:
  int pos__;
  int t;
 
 public:
  ~tilde_block_model() { }
  
  std::string model_name() const { return "tilde_block_model"; }
  
  tilde_block_model(stan::io::var_context& context__,
                    unsigned int random_seed__ = 0,
                    std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "tilde_block_model_namespace::tilde_block_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      context__.validate_dims("data initialization","t","int",
          context__.to_vec());
      t = std::numeric_limits<int>::min();
      
      current_statement__ = 7;
      t = context__.vals_i("t")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  inline T__ log_prob(std::vector<T__>& params_r__,
                      std::vector<int>& params_i__,
                      std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "tilde_block_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ x;
      x = DUMMY_VAR__;
      
      current_statement__ = 1;
      x = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        x = stan::math::lb_constrain(x, 0, lp__);
      } else {
        current_statement__ = 1;
        x = stan::math::lb_constrain(x, 0);
      }
      {
        current_statement__ = 4;
        if (t) {
          current_statement__ = 5;
          if (logical_lt(x, 0)) {
            current_statement__ = 5;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 5;
            lp_accum__.add(-student_t_ccdf_log(0, 10, 0, 1));
          }
          current_statement__ = 6;
          lp_accum__.add(student_t_log<propto__>(x, 10, 0, 1));
        } else {
          current_statement__ = 2;
          if (logical_lt(x, 0)) {
            current_statement__ = 2;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 2;
            lp_accum__.add(-normal_ccdf_log(0, 0, 1));
          }
          current_statement__ = 3;
          lp_accum__.add(normal_log<propto__>(x, 0, 1));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  inline void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                          std::vector<int>& params_i__,
                          std::vector<double>& vars__,
                          bool emit_transformed_parameters__ = true,
                          bool emit_generated_quantities__ = true,
                          std::ostream* pstream__ = 0) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "tilde_block_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double x;
      x = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      x = in__.scalar();
      current_statement__ = 1;
      x = stan::math::lb_constrain(x, 0);
      vars__.push_back(x);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  inline void transform_inits(const stan::io::var_context& context__,
                              std::vector<int>& params_i__,
                              std::vector<double>& vars__,
                              std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double x;
      x = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      x = context__.vals_r("x")[(1 - 1)];
      current_statement__ = 1;
      x = stan::math::lb_free(x, 0);
      vars__.push_back(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("x");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "x");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "x");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef tilde_block_model_namespace::tilde_block_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp truncate.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace truncate_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'truncate.stan', line 6, column 4 to column 11)",
                                                      " (in 'truncate.stan', line 7, column 4 to column 20)",
                                                      " (in 'truncate.stan', line 10, column 4 to column 25)",
                                                      " (in 'truncate.stan', line 11, column 22 to column 25)",
                                                      " (in 'truncate.stan', line 11, column 4 to column 28)",
                                                      " (in 'truncate.stan', line 12, column 23 to column 27)",
                                                      " (in 'truncate.stan', line 12, column 4 to column 29)",
                                                      " (in 'truncate.stan', line 13, column 26 to column 30)",
                                                      " (in 'truncate.stan', line 13, column 22 to column 25)",
                                                      " (in 'truncate.stan', line 13, column 4 to column 32)",
                                                      " (in 'truncate.stan', line 14, column 4 to column 24)",
                                                      " (in 'truncate.stan', line 15, column 21 to column 23)",
                                                      " (in 'truncate.stan', line 15, column 4 to column 26)",
                                                      " (in 'truncate.stan', line 16, column 22 to column 24)",
                                                      " (in 'truncate.stan', line 16, column 4 to column 26)",
                                                      " (in 'truncate.stan', line 17, column 24 to column 26)",
                                                      " (in 'truncate.stan', line 17, column 21 to column 23)",
                                                      " (in 'truncate.stan', line 17, column 4 to column 28)",
                                                      " (in 'truncate.stan', line 2, column 4 to column 10)",
                                                      " (in 'truncate.stan', line 3, column 4 to column 11)"};



class truncate_model : public model_base_crtp<truncate_model> {

 private:
  int pos__;
  int n;
  double x;
 
 public:
  ~truncate_model() { }
  
  std::string model_name() const { return "truncate_model"; }
  
  truncate_model(stan::io::var_context& context__,
                 unsigned int random_seed__ = 0,
                 std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "truncate_model_namespace::truncate_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      context__.validate_dims("data initialization","n","int",
          context__.to_vec());
      n = std::numeric_limits<int>::min();
      
      current_statement__ = 19;
      n = context__.vals_i("n")[(1 - 1)];
      context__.validate_dims("data initialization","x","double",
          context__.to_vec());
      x = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 20;
      x = context__.vals_r("x")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  inline T__ log_prob(std::vector<T__>& params_r__,
                      std::vector<int>& params_i__,
                      std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "truncate_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ m;
      m = DUMMY_VAR__;
      
      current_statement__ = 1;
      m = in__.scalar();
      local_scalar_t__ y;
      y = DUMMY_VAR__;
      
      current_statement__ = 2;
      y = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        y = stan::math::lb_constrain(y, 0, lp__);
      } else {
        current_statement__ = 2;
        y = stan::math::lb_constrain(y, 0);
      }
      {
        current_statement__ = 3;
        lp_accum__.add(normal_log<propto__>(x, m, 1));
        current_statement__ = 4;
        if (logical_lt(x, 0.0)) {
          current_statement__ = 4;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 4;
          lp_accum__.add(-normal_ccdf_log(0.0, m, 1));
        }
        current_statement__ = 5;
        lp_accum__.add(normal_log<propto__>(x, m, 1));
        current_statement__ = 6;
        if (logical_gt(x, 10.0)) {
          current_statement__ = 6;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 6;
          lp_accum__.add(-normal_cdf_log(10.0, m, 1));
        }
        current_statement__ = 7;
        lp_accum__.add(normal_log<propto__>(x, m, 1));
        current_statement__ = 9;
        if (logical_lt(x, 0.0)) {
          current_statement__ = 9;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 8;
          if (logical_gt(x, 10.0)) {
            current_statement__ = 8;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 8;
            lp_accum__.add(
              -log_diff_exp(normal_cdf_log(10.0, m, 1),
                 normal_cdf_log(0.0, m, 1)));
          }
        }
        current_statement__ = 10;
        lp_accum__.add(normal_log<propto__>(x, m, 1));
        current_statement__ = 11;
        lp_accum__.add(poisson_log<propto__>(n, y));
        current_statement__ = 12;
        if (logical_lt(n, 10)) {
          current_statement__ = 12;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 12;
          lp_accum__.add(-poisson_ccdf_log((10 - 1), y));
        }
        current_statement__ = 13;
        lp_accum__.add(poisson_log<propto__>(n, y));
        current_statement__ = 14;
        if (logical_gt(n, 20)) {
          current_statement__ = 14;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 14;
          lp_accum__.add(-poisson_cdf_log(20, y));
        }
        current_statement__ = 15;
        lp_accum__.add(poisson_log<propto__>(n, y));
        current_statement__ = 17;
        if (logical_lt(n, 10)) {
          current_statement__ = 17;
          lp_accum__.add(stan::math::negative_infinity());
        } else {
          current_statement__ = 16;
          if (logical_gt(n, 20)) {
            current_statement__ = 16;
            lp_accum__.add(stan::math::negative_infinity());
          } else {
            current_statement__ = 16;
            lp_accum__.add(
              -log_diff_exp(poisson_cdf_log(20, y),
                 poisson_cdf_log((10 - 1), y)));
          }
        }
        current_statement__ = 18;
        lp_accum__.add(poisson_log<propto__>(n, y));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  inline void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                          std::vector<int>& params_i__,
                          std::vector<double>& vars__,
                          bool emit_transformed_parameters__ = true,
                          bool emit_generated_quantities__ = true,
                          std::ostream* pstream__ = 0) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "truncate_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double m;
      m = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      m = in__.scalar();
      double y;
      y = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      y = in__.scalar();
      current_statement__ = 2;
      y = stan::math::lb_constrain(y, 0);
      vars__.push_back(m);
      vars__.push_back(y);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  inline void transform_inits(const stan::io::var_context& context__,
                              std::vector<int>& params_i__,
                              std::vector<double>& vars__,
                              std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double m;
      m = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      m = context__.vals_r("m")[(1 - 1)];
      double y;
      y = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      y = context__.vals_r("y")[(1 - 1)];
      current_statement__ = 2;
      y = stan::math::lb_free(y, 0);
      vars__.push_back(m);
      vars__.push_back(y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("m");
    names__.push_back("y");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "m");
    param_names__.push_back(std::string() + "y");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "m");
    param_names__.push_back(std::string() + "y");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"m\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"m\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef truncate_model_namespace::truncate_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp user_constrain.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace user_constrain_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'user_constrain.stan', line 7, column 2 to column 18)",
                                                      " (in 'user_constrain.stan', line 10, column 2 to column 19)",
                                                      " (in 'user_constrain.stan', line 3, column 4 to column 13)",
                                                      " (in 'user_constrain.stan', line 2, column 36 to line 4, column 3)"};


template <typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
lb_constrain(const T0__& x, const T1__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 3;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct lb_constrain_functor__ {
template <typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
operator()(const T0__& x, const T1__& y, std::ostream* pstream__)  const 
{
return lb_constrain(x, y, pstream__);
}
};

class user_constrain_model : public model_base_crtp<user_constrain_model> {

 private:
  int pos__;
 
 public:
  ~user_constrain_model() { }
  
  std::string model_name() const { return "user_constrain_model"; }
  
  user_constrain_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "user_constrain_model_namespace::user_constrain_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  inline T__ log_prob(std::vector<T__>& params_r__,
                      std::vector<int>& params_i__,
                      std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "user_constrain_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ x;
      x = DUMMY_VAR__;
      
      current_statement__ = 1;
      x = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        x = stan::math::lb_constrain(x, 0, lp__);
      } else {
        current_statement__ = 1;
        x = stan::math::lb_constrain(x, 0);
      }
      {
        current_statement__ = 2;
        lp_accum__.add(std_normal_log<propto__>(x));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  inline void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                          std::vector<int>& params_i__,
                          std::vector<double>& vars__,
                          bool emit_transformed_parameters__ = true,
                          bool emit_generated_quantities__ = true,
                          std::ostream* pstream__ = 0) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "user_constrain_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double x;
      x = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      x = in__.scalar();
      current_statement__ = 1;
      x = stan::math::lb_constrain(x, 0);
      vars__.push_back(x);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  inline void transform_inits(const stan::io::var_context& context__,
                              std::vector<int>& params_i__,
                              std::vector<double>& vars__,
                              std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double x;
      x = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      x = context__.vals_r("x")[(1 - 1)];
      current_statement__ = 1;
      x = stan::math::lb_free(x, 0);
      vars__.push_back(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("x");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "x");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "x");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef user_constrain_model_namespace::user_constrain_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



