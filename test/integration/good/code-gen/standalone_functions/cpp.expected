  $ ../../../../../../install/default/bin/stanc --standalone-functions --print-cpp basic.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace basic_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 21> locations_array__ = 
{" (found before start of program)",
 " (in 'basic.stan', line 3, column 8 to column 28)",
 " (in 'basic.stan', line 2, column 30 to line 4, column 5)",
 " (in 'basic.stan', line 8, column 2 to column 16)",
 " (in 'basic.stan', line 7, column 1 to line 9, column 2)",
 " (in 'basic.stan', line 13, column 2 to column 16)",
 " (in 'basic.stan', line 12, column 1 to line 14, column 2)",
 " (in 'basic.stan', line 18, column 9 to column 24)",
 " (in 'basic.stan', line 18, column 2 to column 43)",
 " (in 'basic.stan', line 19, column 2 to column 16)",
 " (in 'basic.stan', line 17, column 1 to line 20, column 2)",
 " (in 'basic.stan', line 23, column 2 to column 13)",
 " (in 'basic.stan', line 22, column 43 to line 24, column 2)",
 " (in 'basic.stan', line 27, column 8 to column 25)",
 " (in 'basic.stan', line 26, column 26 to line 28, column 5)",
 " (in 'basic.stan', line 32, column 5 to column 22)",
 " (in 'basic.stan', line 31, column 22 to line 33, column 2)",
 " (in 'basic.stan', line 36, column 2 to column 26)",
 " (in 'basic.stan', line 35, column 23 to line 37, column 2)",
 " (in 'basic.stan', line 40, column 2 to column 31)",
 " (in 'basic.stan', line 39, column 32 to line 41, column 2)"};

template <typename T0__>
stan::promote_args_t<T0__>
my_log1p_exp(const T0__& x, std::ostream* pstream__) ;

struct my_log1p_exp_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return my_log1p_exp(x, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
array_fun(const std::vector<T0__>& a, std::ostream* pstream__) ;

struct array_fun_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<T0__>& a, std::ostream* pstream__)  const 
{
return array_fun(a, pstream__);
}
};

double
int_array_fun(const std::vector<int>& a, std::ostream* pstream__) ;

struct int_array_fun_functor__ {
double
operator()(const std::vector<int>& a, std::ostream* pstream__)  const 
{
return int_array_fun(a, pstream__);
}
};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
my_vector_mul_by_5(const T0__& x, std::ostream* pstream__) ;

struct my_vector_mul_by_5_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return my_vector_mul_by_5(x, pstream__);
}
};

int
int_only_multiplication(const int& a, const int& b, std::ostream* pstream__) ;

struct int_only_multiplication_functor__ {
int
operator()(const int& a, const int& b, std::ostream* pstream__)  const 
{
return int_only_multiplication(a, b, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
test_lgamma(const T0__& x, std::ostream* pstream__) ;

struct test_lgamma_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return test_lgamma(x, pstream__);
}
};

template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
test_lp(const T0__& a, T_lp__& lp__, T_lp_accum__& lp_accum__,
        std::ostream* pstream__) ;

struct test_lp_functor__ {
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
operator()(const T0__& a, T_lp__& lp__, T_lp_accum__& lp_accum__,
           std::ostream* pstream__)  const 
{
return test_lp<propto__>(a, lp__, lp_accum__, pstream__);
}
};

template <typename T0__, typename RNG>
stan::promote_args_t<T0__>
test_rng(const T0__& a, RNG& base_rng__, std::ostream* pstream__) ;

struct test_rng_functor__ {
template <typename T0__, typename RNG>
stan::promote_args_t<T0__>
operator()(const T0__& a, RNG& base_rng__, std::ostream* pstream__)  const 
{
return test_rng(a, base_rng__, pstream__);
}
};

template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
test_lpdf(const T0__& a, const T1__& b, std::ostream* pstream__) ;

struct test_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
operator()(const T0__& a, const T1__& b, std::ostream* pstream__)  const 
{
return test_lpdf<propto__>(a, b, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
my_log1p_exp(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 1;
    return log1p_exp(x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <typename T0__>
stan::promote_args_t<T0__>
array_fun(const std::vector<T0__>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 3;
    return sum(a);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
double
int_array_fun(const std::vector<int>& a, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 5;
    return sum(a);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
my_vector_mul_by_5(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  int current_statement__ = 0; 
  const auto& x = to_ref(x_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 7;
    validate_non_negative_index("result", "num_elements(x)", num_elements(x));
    Eigen::Matrix<local_scalar_t__, -1, 1> result;
    result = Eigen::Matrix<local_scalar_t__, -1, 1>(num_elements(x));
    stan::math::fill(result, DUMMY_VAR__);
    
    current_statement__ = 8;
    assign(result, multiply(x, 5.0), "assigning variable result");
    current_statement__ = 9;
    return result;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
int
int_only_multiplication(const int& a, const int& b, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 11;
    return (a * b);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <typename T0__>
stan::promote_args_t<T0__>
test_lgamma(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 13;
    return stan::math::lgamma(x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
test_lp(const T0__& a, T_lp__& lp__, T_lp_accum__& lp_accum__,
        std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 15;
    lp_accum__.add(normal_lpdf<propto__>(a, 0, 1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <typename T0__, typename RNG>
stan::promote_args_t<T0__>
test_rng(const T0__& a, RNG& base_rng__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 17;
    return normal_rng(a, 1, base_rng__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
test_lpdf(const T0__& a, const T1__& b, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 19;
    return normal_lpdf<false>(a, b, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}

}

// [[stan::function]]
auto my_log1p_exp(const double& x, std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::my_log1p_exp(x, pstream__);
}


// [[stan::function]]
auto array_fun(const std::vector<double>& a,
               std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::array_fun(a, pstream__);
}


// [[stan::function]]
auto int_array_fun(const std::vector<int>& a,
                   std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::int_array_fun(a, pstream__);
}


// [[stan::function]]
auto my_vector_mul_by_5(const Eigen::Matrix<double, -1, 1>& x,
                        std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::my_vector_mul_by_5(x, pstream__);
}


// [[stan::function]]
auto int_only_multiplication(const int& a, const int& b,
                             std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::int_only_multiplication(a, b, pstream__);
}


// [[stan::function]]
auto test_lgamma(const double& x, std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::test_lgamma(x, pstream__);
}


// [[stan::function]]
void test_lp(const double& a, double& lp__,
             stan::math::accumulator<double>& lp_accum__,
             std::ostream* pstream__ = nullptr)  
{
 basic_model_namespace::test_lp<false>(a, lp__, lp_accum__, pstream__);
}


// [[stan::function]]
auto test_rng(const double& a, boost::ecuyer1988& base_rng__,
              std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::test_rng(a, base_rng__, pstream__);
}


// [[stan::function]]
auto test_lpdf(const double& a, const double& b,
               std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::test_lpdf<false>(a, b, pstream__);
}


  $ ../../../../../../install/default/bin/stanc --standalone-functions --print-cpp integrate.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace integrate_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 11> locations_array__ = 
{" (found before start of program)",
 " (in 'integrate.stan', line 4, column 4 to column 27)",
 " (in 'integrate.stan', line 3, column 29 to line 5, column 3)",
 " (in 'integrate.stan', line 8, column 4 to column 18)",
 " (in 'integrate.stan', line 9, column 4 to column 22)",
 " (in 'integrate.stan', line 10, column 4 to column 47)",
 " (in 'integrate.stan', line 11, column 4 to column 18)",
 " (in 'integrate.stan', line 7, column 78 to line 12, column 3)",
 " (in 'integrate.stan', line 15, column 4 to column 15)",
 " (in 'integrate.stan', line 21, column 4 to column 142)",
 " (in 'integrate.stan', line 14, column 23 to line 22, column 3)"};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
integrand(const T0__& x, std::ostream* pstream__) ;

struct integrand_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return integrand(x, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<stan::promote_args_t<T0__, T1__, T2__,
T3__>>
integrand_ode(const T0__& r, const std::vector<T1__>& f,
              const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
              const std::vector<int>& x_i, std::ostream* pstream__) ;

struct integrand_ode_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<stan::promote_args_t<T0__, T1__, T2__,
T3__>>
operator()(const T0__& r, const std::vector<T1__>& f,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__)  const 
{
return integrand_ode(r, f, theta, x_r, x_i, pstream__);
}
};

double
ode_integrate(std::ostream* pstream__) ;

struct ode_integrate_functor__ {
double
operator()(std::ostream* pstream__)  const 
{
return ode_integrate(pstream__);
}
};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
integrand(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  int current_statement__ = 0; 
  const auto& x = to_ref(x_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 1;
    return stan::math::exp(minus(square(x)));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<stan::promote_args_t<T0__, T1__, T2__,
T3__>>
integrand_ode(const T0__& r, const std::vector<T1__>& f,
              const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
              const std::vector<int>& x_i, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    std::vector<local_scalar_t__> df_dx;
    df_dx = std::vector<local_scalar_t__>(1, DUMMY_VAR__);
    
    local_scalar_t__ x;
    x = DUMMY_VAR__;
    
    current_statement__ = 4;
    x = logit(r);
    current_statement__ = 5;
    assign(df_dx, ((stan::math::exp(-square(x)) * 1) / (r * (1 - r))),
      "assigning variable df_dx", index_uni(1));
    current_statement__ = 6;
    return df_dx;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
double
ode_integrate(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    std::vector<int> x_i;
    x_i = std::vector<int>(0, std::numeric_limits<int>::min());
    
    current_statement__ = 9;
    return rvalue(
             integrate_ode_bdf(integrand_ode_functor__(), rep_array(0.0, 1), 1E-5,
  rep_array((1.0 - 1E-5), 1), rep_array(0.0, 0), rep_array(0.0, 0), x_i,
  pstream__),
             "integrate_ode_bdf(integrand_ode, rep_array(0.0, 1), 1E-5,\nrep_array((1.0 - 1E-5), 1), rep_array(0.0, 0), rep_array(0.0, 0),\nx_i)",
             index_uni(1), index_uni(1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}

}

// [[stan::function]]
auto integrand(const Eigen::Matrix<double, -1, 1>& x,
               std::ostream* pstream__ = nullptr)  
{
 return integrate_model_namespace::integrand(x, pstream__);
}


// [[stan::function]]
auto integrand_ode(const double& r, const std::vector<double>& f,
                   const std::vector<double>& theta,
                   const std::vector<double>& x_r,
                   const std::vector<int>& x_i,
                   std::ostream* pstream__ = nullptr)  
{
 return integrate_model_namespace::integrand_ode(r, f, theta, x_r, x_i,
                                     pstream__);
}


// [[stan::function]]
auto ode_integrate(std::ostream* pstream__ = nullptr)  
{
 return integrate_model_namespace::ode_integrate(pstream__);
}


Warning in 'integrate.stan', line 21, column 11: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
