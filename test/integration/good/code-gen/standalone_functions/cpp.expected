  $ ../../../../../../install/default/bin/stanc --standalone-functions --print-cpp basic.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace basic_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 21> locations_array__ = 
{" (found before start of program)",
 " (in 'basic.stan', line 3, column 4 to column 24)",
 " (in 'basic.stan', line 2, column 28 to line 4, column 3)",
 " (in 'basic.stan', line 7, column 4 to column 18)",
 " (in 'basic.stan', line 6, column 33 to line 8, column 3)",
 " (in 'basic.stan', line 11, column 4 to column 18)",
 " (in 'basic.stan', line 10, column 36 to line 12, column 3)",
 " (in 'basic.stan', line 15, column 11 to column 26)",
 " (in 'basic.stan', line 15, column 4 to column 45)",
 " (in 'basic.stan', line 16, column 4 to column 18)",
 " (in 'basic.stan', line 14, column 38 to line 17, column 3)",
 " (in 'basic.stan', line 20, column 4 to column 17)",
 " (in 'basic.stan', line 19, column 44 to line 21, column 3)",
 " (in 'basic.stan', line 24, column 4 to column 21)",
 " (in 'basic.stan', line 23, column 27 to line 25, column 3)",
 " (in 'basic.stan', line 29, column 4 to column 21)",
 " (in 'basic.stan', line 28, column 23 to line 30, column 3)",
 " (in 'basic.stan', line 33, column 4 to column 28)",
 " (in 'basic.stan', line 32, column 24 to line 34, column 3)",
 " (in 'basic.stan', line 37, column 4 to column 33)",
 " (in 'basic.stan', line 36, column 33 to line 38, column 3)"};

struct int_only_multiplication_functor__ {
  inline int
  operator()(const int a, const int b, std::ostream* pstream__) const;
};
struct test_lgamma_functor__ {
  template <typename Tx__, stan::require_all_t<stan::is_stan_scalar<Tx__>>* = nullptr>
  inline stan::return_type_t<Tx__>
  operator()(const Tx__& x, std::ostream* pstream__) const;
};
struct test_lp_functor__ {
  template <bool propto__, typename Ta__, typename T_lp__,
            typename T_lp_accum__, stan::require_all_t<stan::is_stan_scalar<Ta__>>* = nullptr>
  inline void
  operator()(const Ta__& a, T_lp__& lp__, T_lp_accum__& lp_accum__,
             std::ostream* pstream__) const;
};
struct int_array_fun_functor__ {
  inline double
  operator()(const std::vector<int>& a, std::ostream* pstream__) const;
};
struct array_fun_functor__ {
  template <typename Ta__, stan::require_all_t<stan::is_std_vector<Ta__>, stan::is_stan_scalar<stan::value_type_t<Ta__>>>* = nullptr>
  inline stan::return_type_t<Ta__>
  operator()(const Ta__& a, std::ostream* pstream__) const;
};
struct my_log1p_exp_functor__ {
  template <typename Tx__, stan::require_all_t<stan::is_stan_scalar<Tx__>>* = nullptr>
  inline stan::return_type_t<Tx__>
  operator()(const Tx__& x, std::ostream* pstream__) const;
};
struct my_vector_mul_by_5_functor__ {
  template <typename Tx__, stan::require_all_t<stan::is_col_vector<Tx__>>* = nullptr>
  inline Eigen::Matrix<stan::return_type_t<Tx__>, -1, 1>
  operator()(const Tx__& x, std::ostream* pstream__) const;
};
struct test_lpdf_functor__ {
  template <bool propto__, typename Ta__,
            typename Tb__, stan::require_all_t<stan::is_stan_scalar<Ta__>,
            stan::is_stan_scalar<Tb__>>* = nullptr>
  inline stan::return_type_t<Ta__, Tb__>
  operator()(const Ta__& a, const Tb__& b, std::ostream* pstream__) const;
};
struct test_rng_functor__ {
  template <typename Ta__,
            typename RNG, stan::require_all_t<stan::is_stan_scalar<Ta__>>* = nullptr>
  inline stan::return_type_t<Ta__>
  operator()(const Ta__& a, RNG& base_rng__, std::ostream* pstream__) const;
};

template <typename Tx__, stan::require_all_t<stan::is_stan_scalar<Tx__>>* = nullptr>
  inline stan::return_type_t<Tx__>
  my_log1p_exp(const Tx__& x, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Tx__>;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 1;
      return stan::math::log1p_exp(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename Ta__, stan::require_all_t<stan::is_std_vector<Ta__>, stan::is_stan_scalar<stan::value_type_t<Ta__>>>* = nullptr>
  inline stan::return_type_t<Ta__>
  array_fun(const Ta__& a, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Ta__>;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 3;
      return stan::math::sum(a);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
inline double
  int_array_fun(const std::vector<int>& a, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 5;
      return stan::math::sum(a);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename Tx__, stan::require_all_t<stan::is_col_vector<Tx__>>* = nullptr>
  inline Eigen::Matrix<stan::return_type_t<Tx__>, -1, 1>
  my_vector_mul_by_5(const Tx__& x_arg__, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Tx__>;
    int current_statement__ = 0; 
    const auto& x = stan::math::to_ref(x_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 7;
      stan::math::validate_non_negative_index("result", "num_elements(x)",
                                              stan::math::num_elements(x));
      Eigen::Matrix<local_scalar_t__, -1, 1> result =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(
           stan::math::num_elements(x), DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(result, stan::math::multiply(x, 5.0),
        "assigning variable result");
      current_statement__ = 9;
      return result;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
inline int
  int_only_multiplication(const int a, const int b, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 11;
      return (a * b);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename Tx__, stan::require_all_t<stan::is_stan_scalar<Tx__>>* = nullptr>
  inline stan::return_type_t<Tx__>
  test_lgamma(const Tx__& x, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Tx__>;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 13;
      return stan::math::lgamma(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <bool propto__, typename Ta__, typename T_lp__,
          typename T_lp_accum__, stan::require_all_t<stan::is_stan_scalar<Ta__>>* = nullptr>
  inline void
  test_lp(const Ta__& a, T_lp__& lp__, T_lp_accum__& lp_accum__,
          std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Ta__>;
    int current_statement__ = 0; 
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 15;
      lp_accum__.add(stan::math::normal_lpdf<propto__>(a, 0, 1));
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename Ta__,
          typename RNG, stan::require_all_t<stan::is_stan_scalar<Ta__>>* = nullptr>
  inline stan::return_type_t<Ta__>
  test_rng(const Ta__& a, RNG& base_rng__, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Ta__>;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 17;
      return stan::math::normal_rng(a, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <bool propto__, typename Ta__,
          typename Tb__, stan::require_all_t<stan::is_stan_scalar<Ta__>,
          stan::is_stan_scalar<Tb__>>* = nullptr>
  inline stan::return_type_t<Ta__, Tb__>
  test_lpdf(const Ta__& a, const Tb__& b, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Ta__, Tb__>;
    int current_statement__ = 0; 
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 19;
      return stan::math::normal_lpdf<false>(a, b, 1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
inline int
int_only_multiplication_functor__::operator()(const int a, const int b,
                                              std::ostream* pstream__)  const
{
  return int_only_multiplication(a, b, pstream__);
}

template <typename Tx__, stan::require_all_t<stan::is_stan_scalar<Tx__>>*>
inline stan::return_type_t<Tx__>
test_lgamma_functor__::operator()(const Tx__& x, std::ostream* pstream__) 
const
{
  return test_lgamma(x, pstream__);
}

template <bool propto__, typename Ta__, typename T_lp__,
          typename T_lp_accum__, stan::require_all_t<stan::is_stan_scalar<Ta__>>*>
inline void
test_lp_functor__::operator()(const Ta__& a, T_lp__& lp__,
                              T_lp_accum__& lp_accum__,
                              std::ostream* pstream__)  const
{
  return test_lp<propto__>(a, lp__, lp_accum__, pstream__);
}

inline double
int_array_fun_functor__::operator()(const std::vector<int>& a,
                                    std::ostream* pstream__)  const
{
  return int_array_fun(a, pstream__);
}

template <typename Ta__, stan::require_all_t<stan::is_std_vector<Ta__>, stan::is_stan_scalar<stan::value_type_t<Ta__>>>*>
inline stan::return_type_t<Ta__>
array_fun_functor__::operator()(const Ta__& a, std::ostream* pstream__) 
const
{
  return array_fun(a, pstream__);
}

template <typename Tx__, stan::require_all_t<stan::is_stan_scalar<Tx__>>*>
inline stan::return_type_t<Tx__>
my_log1p_exp_functor__::operator()(const Tx__& x, std::ostream* pstream__) 
const
{
  return my_log1p_exp(x, pstream__);
}

template <typename Tx__, stan::require_all_t<stan::is_col_vector<Tx__>>*>
inline Eigen::Matrix<stan::return_type_t<Tx__>, -1, 1>
my_vector_mul_by_5_functor__::operator()(const Tx__& x,
                                         std::ostream* pstream__)  const
{
  return my_vector_mul_by_5(x, pstream__);
}

template <bool propto__, typename Ta__,
          typename Tb__, stan::require_all_t<stan::is_stan_scalar<Ta__>,
          stan::is_stan_scalar<Tb__>>*>
inline stan::return_type_t<Ta__, Tb__>
test_lpdf_functor__::operator()(const Ta__& a, const Tb__& b,
                                std::ostream* pstream__)  const
{
  return test_lpdf<propto__>(a, b, pstream__);
}

template <typename Ta__,
          typename RNG, stan::require_all_t<stan::is_stan_scalar<Ta__>>*>
inline stan::return_type_t<Ta__>
test_rng_functor__::operator()(const Ta__& a, RNG& base_rng__,
                               std::ostream* pstream__)  const
{
  return test_rng(a, base_rng__, pstream__);
}

  }

// [[stan::function]]
auto my_log1p_exp(const double& x, std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::my_log1p_exp(x, pstream__);
}


// [[stan::function]]
auto array_fun(const std::vector<double>& a,
               std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::array_fun(a, pstream__);
}


// [[stan::function]]
auto int_array_fun(const std::vector<int>& a,
                   std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::int_array_fun(a, pstream__);
}


// [[stan::function]]
auto my_vector_mul_by_5(const Eigen::Matrix<double, -1, 1>& x,
                        std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::my_vector_mul_by_5(x, pstream__);
}


// [[stan::function]]
auto int_only_multiplication(const int& a, const int& b,
                             std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::int_only_multiplication(a, b, pstream__);
}


// [[stan::function]]
auto test_lgamma(const double& x, std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::test_lgamma(x, pstream__);
}


// [[stan::function]]
void test_lp(const double& a, double& lp__,
             stan::math::accumulator<double>& lp_accum__,
             std::ostream* pstream__ = nullptr)  
{
 basic_model_namespace::test_lp<false>(a, lp__, lp_accum__, pstream__);
}


// [[stan::function]]
auto test_rng(const double& a, boost::ecuyer1988& base_rng__,
              std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::test_rng(a, base_rng__, pstream__);
}


// [[stan::function]]
auto test_lpdf(const double& a, const double& b,
               std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::test_lpdf<false>(a, b, pstream__);
}


  $ ../../../../../../install/default/bin/stanc --standalone-functions --print-cpp basic.stanfunctions

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace basic_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 21> locations_array__ = 
{" (found before start of program)",
 " (in 'basic.stanfunctions', line 2, column 2 to column 22)",
 " (in 'basic.stanfunctions', line 1, column 26 to line 3, column 1)",
 " (in 'basic.stanfunctions', line 6, column 2 to column 16)",
 " (in 'basic.stanfunctions', line 5, column 31 to line 7, column 1)",
 " (in 'basic.stanfunctions', line 10, column 2 to column 16)",
 " (in 'basic.stanfunctions', line 9, column 34 to line 11, column 1)",
 " (in 'basic.stanfunctions', line 14, column 9 to column 24)",
 " (in 'basic.stanfunctions', line 14, column 2 to column 43)",
 " (in 'basic.stanfunctions', line 15, column 2 to column 16)",
 " (in 'basic.stanfunctions', line 13, column 36 to line 16, column 1)",
 " (in 'basic.stanfunctions', line 19, column 2 to column 15)",
 " (in 'basic.stanfunctions', line 18, column 42 to line 20, column 1)",
 " (in 'basic.stanfunctions', line 23, column 2 to column 19)",
 " (in 'basic.stanfunctions', line 22, column 25 to line 24, column 1)",
 " (in 'basic.stanfunctions', line 28, column 2 to column 19)",
 " (in 'basic.stanfunctions', line 27, column 21 to line 29, column 1)",
 " (in 'basic.stanfunctions', line 32, column 2 to column 26)",
 " (in 'basic.stanfunctions', line 31, column 22 to line 33, column 1)",
 " (in 'basic.stanfunctions', line 36, column 2 to column 31)",
 " (in 'basic.stanfunctions', line 35, column 31 to line 37, column 1)"};

struct int_only_multiplication_functor__ {
  inline int
  operator()(const int a, const int b, std::ostream* pstream__) const;
};
struct test_lgamma_functor__ {
  template <typename Tx__, stan::require_all_t<stan::is_stan_scalar<Tx__>>* = nullptr>
  inline stan::return_type_t<Tx__>
  operator()(const Tx__& x, std::ostream* pstream__) const;
};
struct test_lp_functor__ {
  template <bool propto__, typename Ta__, typename T_lp__,
            typename T_lp_accum__, stan::require_all_t<stan::is_stan_scalar<Ta__>>* = nullptr>
  inline void
  operator()(const Ta__& a, T_lp__& lp__, T_lp_accum__& lp_accum__,
             std::ostream* pstream__) const;
};
struct int_array_fun_functor__ {
  inline double
  operator()(const std::vector<int>& a, std::ostream* pstream__) const;
};
struct array_fun_functor__ {
  template <typename Ta__, stan::require_all_t<stan::is_std_vector<Ta__>, stan::is_stan_scalar<stan::value_type_t<Ta__>>>* = nullptr>
  inline stan::return_type_t<Ta__>
  operator()(const Ta__& a, std::ostream* pstream__) const;
};
struct my_log1p_exp_functor__ {
  template <typename Tx__, stan::require_all_t<stan::is_stan_scalar<Tx__>>* = nullptr>
  inline stan::return_type_t<Tx__>
  operator()(const Tx__& x, std::ostream* pstream__) const;
};
struct my_vector_mul_by_5_functor__ {
  template <typename Tx__, stan::require_all_t<stan::is_col_vector<Tx__>>* = nullptr>
  inline Eigen::Matrix<stan::return_type_t<Tx__>, -1, 1>
  operator()(const Tx__& x, std::ostream* pstream__) const;
};
struct test_lpdf_functor__ {
  template <bool propto__, typename Ta__,
            typename Tb__, stan::require_all_t<stan::is_stan_scalar<Ta__>,
            stan::is_stan_scalar<Tb__>>* = nullptr>
  inline stan::return_type_t<Ta__, Tb__>
  operator()(const Ta__& a, const Tb__& b, std::ostream* pstream__) const;
};
struct test_rng_functor__ {
  template <typename Ta__,
            typename RNG, stan::require_all_t<stan::is_stan_scalar<Ta__>>* = nullptr>
  inline stan::return_type_t<Ta__>
  operator()(const Ta__& a, RNG& base_rng__, std::ostream* pstream__) const;
};

template <typename Tx__, stan::require_all_t<stan::is_stan_scalar<Tx__>>* = nullptr>
  inline stan::return_type_t<Tx__>
  my_log1p_exp(const Tx__& x, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Tx__>;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 1;
      return stan::math::log1p_exp(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename Ta__, stan::require_all_t<stan::is_std_vector<Ta__>, stan::is_stan_scalar<stan::value_type_t<Ta__>>>* = nullptr>
  inline stan::return_type_t<Ta__>
  array_fun(const Ta__& a, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Ta__>;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 3;
      return stan::math::sum(a);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
inline double
  int_array_fun(const std::vector<int>& a, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 5;
      return stan::math::sum(a);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename Tx__, stan::require_all_t<stan::is_col_vector<Tx__>>* = nullptr>
  inline Eigen::Matrix<stan::return_type_t<Tx__>, -1, 1>
  my_vector_mul_by_5(const Tx__& x_arg__, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Tx__>;
    int current_statement__ = 0; 
    const auto& x = stan::math::to_ref(x_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 7;
      stan::math::validate_non_negative_index("result", "num_elements(x)",
                                              stan::math::num_elements(x));
      Eigen::Matrix<local_scalar_t__, -1, 1> result =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(
           stan::math::num_elements(x), DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(result, stan::math::multiply(x, 5.0),
        "assigning variable result");
      current_statement__ = 9;
      return result;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
inline int
  int_only_multiplication(const int a, const int b, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 11;
      return (a * b);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename Tx__, stan::require_all_t<stan::is_stan_scalar<Tx__>>* = nullptr>
  inline stan::return_type_t<Tx__>
  test_lgamma(const Tx__& x, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Tx__>;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 13;
      return stan::math::lgamma(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <bool propto__, typename Ta__, typename T_lp__,
          typename T_lp_accum__, stan::require_all_t<stan::is_stan_scalar<Ta__>>* = nullptr>
  inline void
  test_lp(const Ta__& a, T_lp__& lp__, T_lp_accum__& lp_accum__,
          std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Ta__>;
    int current_statement__ = 0; 
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 15;
      lp_accum__.add(stan::math::normal_lpdf<propto__>(a, 0, 1));
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename Ta__,
          typename RNG, stan::require_all_t<stan::is_stan_scalar<Ta__>>* = nullptr>
  inline stan::return_type_t<Ta__>
  test_rng(const Ta__& a, RNG& base_rng__, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Ta__>;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 17;
      return stan::math::normal_rng(a, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <bool propto__, typename Ta__,
          typename Tb__, stan::require_all_t<stan::is_stan_scalar<Ta__>,
          stan::is_stan_scalar<Tb__>>* = nullptr>
  inline stan::return_type_t<Ta__, Tb__>
  test_lpdf(const Ta__& a, const Tb__& b, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Ta__, Tb__>;
    int current_statement__ = 0; 
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 19;
      return stan::math::normal_lpdf<false>(a, b, 1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
inline int
int_only_multiplication_functor__::operator()(const int a, const int b,
                                              std::ostream* pstream__)  const
{
  return int_only_multiplication(a, b, pstream__);
}

template <typename Tx__, stan::require_all_t<stan::is_stan_scalar<Tx__>>*>
inline stan::return_type_t<Tx__>
test_lgamma_functor__::operator()(const Tx__& x, std::ostream* pstream__) 
const
{
  return test_lgamma(x, pstream__);
}

template <bool propto__, typename Ta__, typename T_lp__,
          typename T_lp_accum__, stan::require_all_t<stan::is_stan_scalar<Ta__>>*>
inline void
test_lp_functor__::operator()(const Ta__& a, T_lp__& lp__,
                              T_lp_accum__& lp_accum__,
                              std::ostream* pstream__)  const
{
  return test_lp<propto__>(a, lp__, lp_accum__, pstream__);
}

inline double
int_array_fun_functor__::operator()(const std::vector<int>& a,
                                    std::ostream* pstream__)  const
{
  return int_array_fun(a, pstream__);
}

template <typename Ta__, stan::require_all_t<stan::is_std_vector<Ta__>, stan::is_stan_scalar<stan::value_type_t<Ta__>>>*>
inline stan::return_type_t<Ta__>
array_fun_functor__::operator()(const Ta__& a, std::ostream* pstream__) 
const
{
  return array_fun(a, pstream__);
}

template <typename Tx__, stan::require_all_t<stan::is_stan_scalar<Tx__>>*>
inline stan::return_type_t<Tx__>
my_log1p_exp_functor__::operator()(const Tx__& x, std::ostream* pstream__) 
const
{
  return my_log1p_exp(x, pstream__);
}

template <typename Tx__, stan::require_all_t<stan::is_col_vector<Tx__>>*>
inline Eigen::Matrix<stan::return_type_t<Tx__>, -1, 1>
my_vector_mul_by_5_functor__::operator()(const Tx__& x,
                                         std::ostream* pstream__)  const
{
  return my_vector_mul_by_5(x, pstream__);
}

template <bool propto__, typename Ta__,
          typename Tb__, stan::require_all_t<stan::is_stan_scalar<Ta__>,
          stan::is_stan_scalar<Tb__>>*>
inline stan::return_type_t<Ta__, Tb__>
test_lpdf_functor__::operator()(const Ta__& a, const Tb__& b,
                                std::ostream* pstream__)  const
{
  return test_lpdf<propto__>(a, b, pstream__);
}

template <typename Ta__,
          typename RNG, stan::require_all_t<stan::is_stan_scalar<Ta__>>*>
inline stan::return_type_t<Ta__>
test_rng_functor__::operator()(const Ta__& a, RNG& base_rng__,
                               std::ostream* pstream__)  const
{
  return test_rng(a, base_rng__, pstream__);
}

  }

// [[stan::function]]
auto my_log1p_exp(const double& x, std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::my_log1p_exp(x, pstream__);
}


// [[stan::function]]
auto array_fun(const std::vector<double>& a,
               std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::array_fun(a, pstream__);
}


// [[stan::function]]
auto int_array_fun(const std::vector<int>& a,
                   std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::int_array_fun(a, pstream__);
}


// [[stan::function]]
auto my_vector_mul_by_5(const Eigen::Matrix<double, -1, 1>& x,
                        std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::my_vector_mul_by_5(x, pstream__);
}


// [[stan::function]]
auto int_only_multiplication(const int& a, const int& b,
                             std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::int_only_multiplication(a, b, pstream__);
}


// [[stan::function]]
auto test_lgamma(const double& x, std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::test_lgamma(x, pstream__);
}


// [[stan::function]]
void test_lp(const double& a, double& lp__,
             stan::math::accumulator<double>& lp_accum__,
             std::ostream* pstream__ = nullptr)  
{
 basic_model_namespace::test_lp<false>(a, lp__, lp_accum__, pstream__);
}


// [[stan::function]]
auto test_rng(const double& a, boost::ecuyer1988& base_rng__,
              std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::test_rng(a, base_rng__, pstream__);
}


// [[stan::function]]
auto test_lpdf(const double& a, const double& b,
               std::ostream* pstream__ = nullptr)  
{
 return basic_model_namespace::test_lpdf<false>(a, b, pstream__);
}


  $ ../../../../../../install/default/bin/stanc --standalone-functions --print-cpp integrate.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace integrate_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 11> locations_array__ = 
{" (found before start of program)",
 " (in 'integrate.stan', line 3, column 4 to column 27)",
 " (in 'integrate.stan', line 2, column 29 to line 4, column 3)",
 " (in 'integrate.stan', line 8, column 4 to column 24)",
 " (in 'integrate.stan', line 9, column 4 to column 22)",
 " (in 'integrate.stan', line 10, column 4 to column 51)",
 " (in 'integrate.stan', line 11, column 4 to column 19)",
 " (in 'integrate.stan', line 7, column 64 to line 12, column 3)",
 " (in 'integrate.stan', line 15, column 4 to column 21)",
 " (in 'integrate.stan', line 21, column 4 to line 23, column 61)",
 " (in 'integrate.stan', line 14, column 23 to line 24, column 3)"};

struct integrand_ode_functor__ {
  template <typename Tr__, typename Tf__, typename Ttheta__,
            typename Tx_r__, stan::require_all_t<stan::is_stan_scalar<Tr__>,
            stan::is_std_vector<Tf__>, stan::is_stan_scalar<stan::value_type_t<Tf__>>,
            stan::is_std_vector<Ttheta__>, stan::is_stan_scalar<stan::value_type_t<Ttheta__>>,
            stan::is_std_vector<Tx_r__>, stan::is_stan_scalar<stan::value_type_t<Tx_r__>>>* = nullptr>
  inline std::vector<stan::return_type_t<Tr__, Tf__, Ttheta__, Tx_r__>>
  operator()(const Tr__& r, const Tf__& f, const Ttheta__& theta,
             const Tx_r__& x_r, const std::vector<int>& x_i,
             std::ostream* pstream__) const;
};
struct ode_integrate_functor__ {
  inline double
  operator()(std::ostream* pstream__) const;
};
struct integrand_functor__ {
  template <typename Tx__, stan::require_all_t<stan::is_col_vector<Tx__>>* = nullptr>
  inline Eigen::Matrix<stan::return_type_t<Tx__>, -1, 1>
  operator()(const Tx__& x, std::ostream* pstream__) const;
};

template <typename Tx__, stan::require_all_t<stan::is_col_vector<Tx__>>* = nullptr>
  inline Eigen::Matrix<stan::return_type_t<Tx__>, -1, 1>
  integrand(const Tx__& x_arg__, std::ostream* pstream__) {
    using local_scalar_t__ = stan::return_type_t<Tx__>;
    int current_statement__ = 0; 
    const auto& x = stan::math::to_ref(x_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 1;
      return stan::math::exp(stan::math::minus(stan::math::square(x)));
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename Tr__, typename Tf__, typename Ttheta__,
          typename Tx_r__, stan::require_all_t<stan::is_stan_scalar<Tr__>,
          stan::is_std_vector<Tf__>, stan::is_stan_scalar<stan::value_type_t<Tf__>>,
          stan::is_std_vector<Ttheta__>, stan::is_stan_scalar<stan::value_type_t<Ttheta__>>,
          stan::is_std_vector<Tx_r__>, stan::is_stan_scalar<stan::value_type_t<Tx_r__>>>* = nullptr>
  inline std::vector<stan::return_type_t<Tr__, Tf__, Ttheta__, Tx_r__>>
  integrand_ode(const Tr__& r, const Tf__& f, const Ttheta__& theta,
                const Tx_r__& x_r, const std::vector<int>& x_i,
                std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::return_type_t<Tr__, Tf__, Ttheta__, Tx_r__>;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      std::vector<local_scalar_t__> df_dx =
         std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 4;
      x = stan::math::logit(r);
      current_statement__ = 5;
      stan::model::assign(df_dx,
        ((stan::math::exp(-stan::math::square(x)) * 1) / (r * (1 - r))),
        "assigning variable df_dx", stan::model::index_uni(1));
      current_statement__ = 6;
      return df_dx;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
inline double ode_integrate(std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      std::vector<int> x_i =
         std::vector<int>(0, std::numeric_limits<int>::min());
      current_statement__ = 9;
      return stan::model::rvalue(
               stan::math::integrate_ode_bdf(integrand_ode_functor__(),
  stan::math::rep_array(0.0, 1), 1E-5,
  stan::math::rep_array((1.0 - 1E-5), 1), stan::math::rep_array(0.0, 0),
  stan::math::rep_array(0.0, 0), x_i, pstream__),
               "integrate_ode_bdf(integrand_ode, rep_array(0.0, 1), 1E-5,\nrep_array((1.0 - 1E-5), 1), rep_array(0.0, 0), rep_array(0.0, 0),\nx_i)",
               stan::model::index_uni(1), stan::model::index_uni(1));
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename Tr__, typename Tf__, typename Ttheta__,
          typename Tx_r__, stan::require_all_t<stan::is_stan_scalar<Tr__>,
          stan::is_std_vector<Tf__>, stan::is_stan_scalar<stan::value_type_t<Tf__>>,
          stan::is_std_vector<Ttheta__>, stan::is_stan_scalar<stan::value_type_t<Ttheta__>>,
          stan::is_std_vector<Tx_r__>, stan::is_stan_scalar<stan::value_type_t<Tx_r__>>>*>
inline std::vector<stan::return_type_t<Tr__, Tf__, Ttheta__, Tx_r__>>
integrand_ode_functor__::operator()(const Tr__& r, const Tf__& f,
                                    const Ttheta__& theta, const Tx_r__& x_r,
                                    const std::vector<int>& x_i,
                                    std::ostream* pstream__)  const
{
  return integrand_ode(r, f, theta, x_r, x_i, pstream__);
}

inline double ode_integrate_functor__::operator()(std::ostream* pstream__) 
const
{
  return ode_integrate(pstream__);
}

template <typename Tx__, stan::require_all_t<stan::is_col_vector<Tx__>>*>
inline Eigen::Matrix<stan::return_type_t<Tx__>, -1, 1>
integrand_functor__::operator()(const Tx__& x, std::ostream* pstream__) 
const
{
  return integrand(x, pstream__);
}

  }

// [[stan::function]]
auto integrand(const Eigen::Matrix<double, -1, 1>& x,
               std::ostream* pstream__ = nullptr)  
{
 return integrate_model_namespace::integrand(x, pstream__);
}


// [[stan::function]]
auto integrand_ode(const double& r, const std::vector<double>& f,
                   const std::vector<double>& theta,
                   const std::vector<double>& x_r,
                   const std::vector<int>& x_i,
                   std::ostream* pstream__ = nullptr)  
{
 return integrate_model_namespace::integrand_ode(r, f, theta, x_r, x_i,
                                     pstream__);
}


// [[stan::function]]
auto ode_integrate(std::ostream* pstream__ = nullptr)  
{
 return integrate_model_namespace::ode_integrate(pstream__);
}


Warning in 'integrate.stan', line 21, column 12: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
