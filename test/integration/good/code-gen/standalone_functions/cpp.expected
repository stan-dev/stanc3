  $ ../../../../../../install/default/bin/stanc --standalone-functions --allow-undefined --print-cpp basic.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace basic_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 25> locations_array__ =
  {" (found before start of program)",
  " (in 'basic.stan', line 4, column 4 to column 24)",
  " (in 'basic.stan', line 3, column 28 to line 5, column 3)",
  " (in 'basic.stan', line 8, column 4 to column 18)",
  " (in 'basic.stan', line 7, column 33 to line 9, column 3)",
  " (in 'basic.stan', line 12, column 4 to column 18)",
  " (in 'basic.stan', line 11, column 36 to line 13, column 3)",
  " (in 'basic.stan', line 16, column 11 to column 26)",
  " (in 'basic.stan', line 16, column 4 to column 45)",
  " (in 'basic.stan', line 17, column 4 to column 18)",
  " (in 'basic.stan', line 15, column 38 to line 18, column 3)",
  " (in 'basic.stan', line 21, column 4 to column 17)",
  " (in 'basic.stan', line 20, column 44 to line 22, column 3)",
  " (in 'basic.stan', line 25, column 4 to column 21)",
  " (in 'basic.stan', line 24, column 27 to line 26, column 3)",
  " (in 'basic.stan', line 30, column 4 to column 21)",
  " (in 'basic.stan', line 29, column 23 to line 31, column 3)",
  " (in 'basic.stan', line 34, column 4 to column 28)",
  " (in 'basic.stan', line 33, column 24 to line 35, column 3)",
  " (in 'basic.stan', line 38, column 4 to column 33)",
  " (in 'basic.stan', line 37, column 33 to line 39, column 3)",
  " (in 'basic.stan', line 42, column 4 to column 17)",
  " (in 'basic.stan', line 41, column 47 to line 43, column 3)",
  " (in 'basic.stan', line 46, column 4 to column 13)",
  " (in 'basic.stan', line 45, column 51 to line 47, column 3)"};
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__>
my_log1p_exp(const T0__& x, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
array_fun(const T0__& a, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              std::is_integral<stan::value_type_t<T0__>>>* = nullptr>
double int_array_fun(const T0__& a, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
my_vector_mul_by_5(const T0__& x_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>>* = nullptr>
int
int_only_multiplication(const T0__& a, const T1__& b, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__>
test_lgamma(const T0__& x, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
void
test_lp(const T0__& a, T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream*
        pstream__);
template <typename T0__, typename RNG,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__>
test_rng(const T0__& a, RNG& base_rng__, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>* = nullptr>
stan::promote_args_t<T0__, T1__>
test_lpdf(const T0__& a, const T1__& b, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_complex<T0__>>* = nullptr>
Eigen::Matrix<std::complex<stan::promote_args_t<stan::base_type_t<T0__>>>,-1,-1>
test_complex(const T0__& a_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::is_complex<stan::value_type_t<stan::value_type_t<
                                                                    stan::value_type_t<T0__>>>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::base_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<
                                                            stan::value_type_t<T0__>>>>>,
                                                      std::is_floating_point<
                                                      stan::base_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<
                                                            stan::value_type_t<T0__>>>>>>>* = nullptr>
std::vector<
  std::vector<
    std::vector<std::complex<stan::promote_args_t<stan::base_type_t<T0__>>>>>>
array_fun(const T0__& a, std::ostream* pstream__);
// real my_log1p_exp(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__>
my_log1p_exp(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 1;
    return stan::math::log1p_exp(x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real array_fun(array[] real)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
array_fun(const T0__& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 3;
    return stan::math::sum(a);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real int_array_fun(array[] int)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              std::is_integral<stan::value_type_t<T0__>>>*>
double int_array_fun(const T0__& a, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 5;
    return stan::math::sum(a);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector my_vector_mul_by_5(vector)
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
my_vector_mul_by_5(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& x = stan::math::to_ref(x_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 7;
    stan::math::validate_non_negative_index("result", "num_elements(x)",
      stan::math::num_elements(x));
    Eigen::Matrix<local_scalar_t__,-1,1> result =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(stan::math::num_elements(
                                                       x), DUMMY_VAR__);
    current_statement__ = 8;
    stan::model::assign(result, stan::math::multiply(x, 5.0),
      "assigning variable result");
    current_statement__ = 9;
    return result;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// int int_only_multiplication(int, int)
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>>*>
int
int_only_multiplication(const T0__& a, const T1__& b, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 11;
    return (a * b);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real test_lgamma(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__>
test_lgamma(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 13;
    return stan::math::lgamma(x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// void test_lp(real)
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
void
test_lp(const T0__& a, T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream*
        pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 15;
    lp_accum__.add(stan::math::normal_lpdf<propto__>(a, 0, 1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real test_rng(real)
template <typename T0__, typename RNG,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__>
test_rng(const T0__& a, RNG& base_rng__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 17;
    return stan::math::normal_rng(a, 1, base_rng__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real test_lpdf(real, real)
template <bool propto__, typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>*>
stan::promote_args_t<T0__, T1__>
test_lpdf(const T0__& a, const T1__& b, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 19;
    return stan::math::normal_lpdf<false>(a, b, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// complex_matrix test_complex(complex_matrix)
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_complex<T0__>>*>
Eigen::Matrix<std::complex<stan::promote_args_t<stan::base_type_t<T0__>>>,-1,-1>
test_complex(const T0__& a_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& a = stan::math::to_ref(a_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 21;
    return stan::math::add(a, a);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// array[,,] complex array_fun(array[,,] complex)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::is_std_vector<stan::value_type_t<T0__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T0__>>>,
                              stan::is_complex<stan::value_type_t<stan::value_type_t<
                                                                    stan::value_type_t<T0__>>>>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::base_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<
                                                            stan::value_type_t<T0__>>>>>,
                                                      std::is_floating_point<
                                                      stan::base_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<
                                                            stan::value_type_t<T0__>>>>>>>*>
std::vector<
  std::vector<
    std::vector<std::complex<stan::promote_args_t<stan::base_type_t<T0__>>>>>>
array_fun(const T0__& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 23;
    return a;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
}
// [[stan::function]]
double my_log1p_exp(const double& x, std::ostream* pstream__ = nullptr) {
  return basic_model_namespace::my_log1p_exp(x, pstream__);
}
// [[stan::function]]
double
array_fun(const std::vector<double>& a, std::ostream* pstream__ = nullptr) {
  return basic_model_namespace::array_fun(a, pstream__);
}
// [[stan::function]]
double
int_array_fun(const std::vector<int>& a, std::ostream* pstream__ = nullptr) {
  return basic_model_namespace::int_array_fun(a, pstream__);
}
// [[stan::function]]
Eigen::Matrix<double,-1,1>
my_vector_mul_by_5(const Eigen::Matrix<double,-1,1>& x, std::ostream*
                   pstream__ = nullptr) {
  return basic_model_namespace::my_vector_mul_by_5(x, pstream__);
}
// [[stan::function]]
int
int_only_multiplication(const int& a, const int& b, std::ostream*
                        pstream__ = nullptr) {
  return basic_model_namespace::int_only_multiplication(a, b, pstream__);
}
// [[stan::function]]
double test_lgamma(const double& x, std::ostream* pstream__ = nullptr) {
  return basic_model_namespace::test_lgamma(x, pstream__);
}
// [[stan::function]]
void
test_lp(const double& a, double& lp__, stan::math::accumulator<double>&
        lp_accum__, std::ostream* pstream__ = nullptr) {
  basic_model_namespace::test_lp<false>(a, lp__, lp_accum__, pstream__);
}
// [[stan::function]]
double
test_rng(const double& a, boost::ecuyer1988& base_rng__, std::ostream*
         pstream__ = nullptr) {
  return basic_model_namespace::test_rng(a, base_rng__, pstream__);
}
// [[stan::function]]
double
test_lpdf(const double& a, const double& b, std::ostream* pstream__ = nullptr) {
  return basic_model_namespace::test_lpdf<false>(a, b, pstream__);
}
// [[stan::function]]
Eigen::Matrix<std::complex<double>,-1,-1>
test_complex(const Eigen::Matrix<std::complex<double>,-1,-1>& a,
             std::ostream* pstream__ = nullptr) {
  return basic_model_namespace::test_complex(a, pstream__);
}
// [[stan::function]]
std::vector<std::vector<std::vector<std::complex<double>>>>
array_fun(const std::vector<std::vector<std::vector<std::complex<double>>>>&
          a, std::ostream* pstream__ = nullptr) {
  return basic_model_namespace::array_fun(a, pstream__);
}
  $ ../../../../../../install/default/bin/stanc --standalone-functions --allow-undefined --print-cpp basic.stanfunctions
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace basic_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 21> locations_array__ =
  {" (found before start of program)",
  " (in 'basic.stanfunctions', line 2, column 2 to column 22)",
  " (in 'basic.stanfunctions', line 1, column 26 to line 3, column 1)",
  " (in 'basic.stanfunctions', line 6, column 2 to column 16)",
  " (in 'basic.stanfunctions', line 5, column 31 to line 7, column 1)",
  " (in 'basic.stanfunctions', line 10, column 2 to column 16)",
  " (in 'basic.stanfunctions', line 9, column 34 to line 11, column 1)",
  " (in 'basic.stanfunctions', line 14, column 9 to column 24)",
  " (in 'basic.stanfunctions', line 14, column 2 to column 43)",
  " (in 'basic.stanfunctions', line 15, column 2 to column 16)",
  " (in 'basic.stanfunctions', line 13, column 36 to line 16, column 1)",
  " (in 'basic.stanfunctions', line 19, column 2 to column 15)",
  " (in 'basic.stanfunctions', line 18, column 42 to line 20, column 1)",
  " (in 'basic.stanfunctions', line 23, column 2 to column 19)",
  " (in 'basic.stanfunctions', line 22, column 25 to line 24, column 1)",
  " (in 'basic.stanfunctions', line 28, column 2 to column 19)",
  " (in 'basic.stanfunctions', line 27, column 21 to line 29, column 1)",
  " (in 'basic.stanfunctions', line 32, column 2 to column 26)",
  " (in 'basic.stanfunctions', line 31, column 22 to line 33, column 1)",
  " (in 'basic.stanfunctions', line 36, column 2 to column 31)",
  " (in 'basic.stanfunctions', line 35, column 31 to line 37, column 1)"};
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__>
my_log1p_exp(const T0__& x, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
array_fun(const T0__& a, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              std::is_integral<stan::value_type_t<T0__>>>* = nullptr>
double int_array_fun(const T0__& a, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
my_vector_mul_by_5(const T0__& x_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>>* = nullptr>
int
int_only_multiplication(const T0__& a, const T1__& b, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__>
test_lgamma(const T0__& x, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
void
test_lp(const T0__& a, T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream*
        pstream__);
template <typename T0__, typename RNG,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>* = nullptr>
stan::promote_args_t<T0__>
test_rng(const T0__& a, RNG& base_rng__, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>* = nullptr>
stan::promote_args_t<T0__, T1__>
test_lpdf(const T0__& a, const T1__& b, std::ostream* pstream__);
// real my_log1p_exp(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__>
my_log1p_exp(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 1;
    return stan::math::log1p_exp(x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real array_fun(array[] real)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T0__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T0__>>>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
array_fun(const T0__& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 3;
    return stan::math::sum(a);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real int_array_fun(array[] int)
template <typename T0__,
          stan::require_all_t<stan::is_std_vector<T0__>,
                              std::is_integral<stan::value_type_t<T0__>>>*>
double int_array_fun(const T0__& a, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 5;
    return stan::math::sum(a);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector my_vector_mul_by_5(vector)
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
my_vector_mul_by_5(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& x = stan::math::to_ref(x_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 7;
    stan::math::validate_non_negative_index("result", "num_elements(x)",
      stan::math::num_elements(x));
    Eigen::Matrix<local_scalar_t__,-1,1> result =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(stan::math::num_elements(
                                                       x), DUMMY_VAR__);
    current_statement__ = 8;
    stan::model::assign(result, stan::math::multiply(x, 5.0),
      "assigning variable result");
    current_statement__ = 9;
    return result;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// int int_only_multiplication(int, int)
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>>*>
int
int_only_multiplication(const T0__& a, const T1__& b, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 11;
    return (a * b);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real test_lgamma(real)
template <typename T0__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__>
test_lgamma(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 13;
    return stan::math::lgamma(x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// void test_lp(real)
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
void
test_lp(const T0__& a, T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream*
        pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 15;
    lp_accum__.add(stan::math::normal_lpdf<propto__>(a, 0, 1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real test_rng(real)
template <typename T0__, typename RNG,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>>*>
stan::promote_args_t<T0__>
test_rng(const T0__& a, RNG& base_rng__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 17;
    return stan::math::normal_rng(a, 1, base_rng__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real test_lpdf(real, real)
template <bool propto__, typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>*>
stan::promote_args_t<T0__, T1__>
test_lpdf(const T0__& a, const T1__& b, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 19;
    return stan::math::normal_lpdf<false>(a, b, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
}
// [[stan::function]]
double my_log1p_exp(const double& x, std::ostream* pstream__ = nullptr) {
  return basic_model_namespace::my_log1p_exp(x, pstream__);
}
// [[stan::function]]
double
array_fun(const std::vector<double>& a, std::ostream* pstream__ = nullptr) {
  return basic_model_namespace::array_fun(a, pstream__);
}
// [[stan::function]]
double
int_array_fun(const std::vector<int>& a, std::ostream* pstream__ = nullptr) {
  return basic_model_namespace::int_array_fun(a, pstream__);
}
// [[stan::function]]
Eigen::Matrix<double,-1,1>
my_vector_mul_by_5(const Eigen::Matrix<double,-1,1>& x, std::ostream*
                   pstream__ = nullptr) {
  return basic_model_namespace::my_vector_mul_by_5(x, pstream__);
}
// [[stan::function]]
int
int_only_multiplication(const int& a, const int& b, std::ostream*
                        pstream__ = nullptr) {
  return basic_model_namespace::int_only_multiplication(a, b, pstream__);
}
// [[stan::function]]
double test_lgamma(const double& x, std::ostream* pstream__ = nullptr) {
  return basic_model_namespace::test_lgamma(x, pstream__);
}
// [[stan::function]]
void
test_lp(const double& a, double& lp__, stan::math::accumulator<double>&
        lp_accum__, std::ostream* pstream__ = nullptr) {
  basic_model_namespace::test_lp<false>(a, lp__, lp_accum__, pstream__);
}
// [[stan::function]]
double
test_rng(const double& a, boost::ecuyer1988& base_rng__, std::ostream*
         pstream__ = nullptr) {
  return basic_model_namespace::test_rng(a, base_rng__, pstream__);
}
// [[stan::function]]
double
test_lpdf(const double& a, const double& b, std::ostream* pstream__ = nullptr) {
  return basic_model_namespace::test_lpdf<false>(a, b, pstream__);
}
  $ ../../../../../../install/default/bin/stanc --standalone-functions --allow-undefined --print-cpp integrate.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace integrate_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 11> locations_array__ =
  {" (found before start of program)",
  " (in 'integrate.stan', line 3, column 4 to column 27)",
  " (in 'integrate.stan', line 2, column 29 to line 4, column 3)",
  " (in 'integrate.stan', line 8, column 4 to column 24)",
  " (in 'integrate.stan', line 9, column 4 to column 22)",
  " (in 'integrate.stan', line 10, column 4 to column 51)",
  " (in 'integrate.stan', line 11, column 4 to column 19)",
  " (in 'integrate.stan', line 7, column 64 to line 12, column 3)",
  " (in 'integrate.stan', line 15, column 4 to column 21)",
  " (in 'integrate.stan', line 21, column 4 to line 23, column 61)",
  " (in 'integrate.stan', line 14, column 23 to line 24, column 3)"};
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
integrand(const T0__& x_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_std_vector<T1__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T1__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T1__>>>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>,
                              stan::is_std_vector<T4__>,
                              std::is_integral<stan::value_type_t<T4__>>>* = nullptr>
std::vector<
  stan::promote_args_t<T0__, stan::base_type_t<T1__>,
    stan::base_type_t<T2__>, stan::base_type_t<T3__>>>
integrand_ode(const T0__& r, const T1__& f, const T2__& theta, const T3__&
              x_r, const T4__& x_i, std::ostream* pstream__);
double ode_integrate(std::ostream* pstream__);
struct integrand_ode_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            typename T4__,
            stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                        std::is_floating_point<T0__>>,
                                stan::is_std_vector<T1__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T1__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T1__>>>,
                                stan::is_std_vector<T2__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T2__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T2__>>>,
                                stan::is_std_vector<T3__>,
                                stan::math::disjunction<stan::is_autodiff<
                                                        stan::value_type_t<T3__>>,
                                                        std::is_floating_point<
                                                        stan::value_type_t<T3__>>>,
                                stan::is_std_vector<T4__>,
                                std::is_integral<stan::value_type_t<T4__>>>* = nullptr>
  std::vector<
    stan::promote_args_t<T0__, stan::base_type_t<T1__>,
      stan::base_type_t<T2__>, stan::base_type_t<T3__>>>
  operator()(const T0__& r, const T1__& f, const T2__& theta, const T3__&
             x_r, const T4__& x_i, std::ostream* pstream__) const {
    return integrand_ode(r, f, theta, x_r, x_i, pstream__);
  }
};
// vector integrand(vector)
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
integrand(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& x = stan::math::to_ref(x_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 1;
    return stan::math::exp(stan::math::minus(stan::math::square(x)));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* array[] real
   integrand_ode(real, array[] real, array[] real, array[] real, array[] int)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::is_std_vector<T1__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T1__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T1__>>>,
                              stan::is_std_vector<T2__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T2__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T2__>>>,
                              stan::is_std_vector<T3__>,
                              stan::math::disjunction<stan::is_autodiff<
                                                      stan::value_type_t<T3__>>,
                                                      std::is_floating_point<
                                                      stan::value_type_t<T3__>>>,
                              stan::is_std_vector<T4__>,
                              std::is_integral<stan::value_type_t<T4__>>>*>
std::vector<
  stan::promote_args_t<T0__, stan::base_type_t<T1__>,
    stan::base_type_t<T2__>, stan::base_type_t<T3__>>>
integrand_ode(const T0__& r, const T1__& f, const T2__& theta, const T3__&
              x_r, const T4__& x_i, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
                             stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    std::vector<local_scalar_t__> df_dx =
      std::vector<local_scalar_t__>(1, DUMMY_VAR__);
    local_scalar_t__ x = DUMMY_VAR__;
    current_statement__ = 4;
    x = stan::math::logit(r);
    current_statement__ = 5;
    stan::model::assign(df_dx, ((stan::math::exp(-(stan::math::square(x))) *
      1) / (r * (1 - r))), "assigning variable df_dx",
      stan::model::index_uni(1));
    current_statement__ = 6;
    return df_dx;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real ode_integrate()
double ode_integrate(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    std::vector<int> x_i =
      std::vector<int>(0, std::numeric_limits<int>::min());
    current_statement__ = 9;
    return stan::model::rvalue(
             stan::math::integrate_ode_bdf(integrand_ode_functor__(),
               stan::math::rep_array(0.0, 1), 1E-5,
               stan::math::rep_array((1.0 - 1E-5), 1),
               stan::math::rep_array(0.0, 0), stan::math::rep_array(0.0, 0),
               x_i, pstream__),
             "integrate_ode_bdf(integrand_ode, rep_array(0.0, 1), 1E-5,\n                  rep_array((1.0 - 1E-5), 1), rep_array(0.0, 0),\n                  rep_array(0.0, 0), x_i)",
             stan::model::index_uni(1), stan::model::index_uni(1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
}
// [[stan::function]]
Eigen::Matrix<double,-1,1>
integrand(const Eigen::Matrix<double,-1,1>& x, std::ostream*
          pstream__ = nullptr) {
  return integrate_model_namespace::integrand(x, pstream__);
}
// [[stan::function]]
std::vector<double>
integrand_ode(const double& r, const std::vector<double>& f,
              const std::vector<double>& theta, const std::vector<double>&
              x_r, const std::vector<int>& x_i, std::ostream*
              pstream__ = nullptr) {
  return integrate_model_namespace::integrand_ode(r, f, theta, x_r, x_i,
           pstream__);
}
// [[stan::function]]
double ode_integrate(std::ostream* pstream__ = nullptr) {
  return integrate_model_namespace::ode_integrate(pstream__);
}
Warning in 'integrate.stan', line 21, column 12: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
