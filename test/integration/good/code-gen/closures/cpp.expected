  $ ../../../../../../install/default/bin/stanc --print-cpp closures1.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace closures1_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 30> locations_array__ = 
{" (found before start of program)",
 " (in 'closures1.stan', line 8, column 4 to line 14, column 5)",
 " (in 'closures1.stan', line 17, column 4 to column 11)",
 " (in 'closures1.stan', line 18, column 4 to column 15)",
 " (in 'closures1.stan', line 19, column 4 to column 17)",
 " (in 'closures1.stan', line 22, column 4 to line 30, column 5)",
 " (in 'closures1.stan', line 31, column 4 to column 29)",
 " (in 'closures1.stan', line 32, column 4 to column 27)",
 " (in 'closures1.stan', line 33, column 4 to column 29)",
 " (in 'closures1.stan', line 34, column 4 to column 27)",
 " (in 'closures1.stan', line 2, column 4 to column 10)",
 " (in 'closures1.stan', line 3, column 4 to column 11)",
 " (in 'closures1.stan', line 4, column 11 to column 12)",
 " (in 'closures1.stan', line 4, column 4 to column 14)",
 " (in 'closures1.stan', line 5, column 11 to column 12)",
 " (in 'closures1.stan', line 5, column 4 to column 16)",
 " (in 'closures1.stan', line 18, column 12 to column 13)",
 " (in 'closures1.stan', line 19, column 11 to column 12)",
 " (in 'closures1.stan', line 24, column 8 to column 25)",
 " (in 'closures1.stan', line 25, column 8 to column 25)",
 " (in 'closures1.stan', line 26, column 8 to column 25)",
 " (in 'closures1.stan', line 27, column 8 to column 27)",
 " (in 'closures1.stan', line 28, column 8 to column 27)",
 " (in 'closures1.stan', line 29, column 8 to column 52)",
 " (in 'closures1.stan', line 23, column 35 to line 30, column 5)",
 " (in 'closures1.stan', line 10, column 8 to column 25)",
 " (in 'closures1.stan', line 11, column 8 to column 25)",
 " (in 'closures1.stan', line 12, column 8 to column 25)",
 " (in 'closures1.stan', line 13, column 8 to column 36)",
 " (in 'closures1.stan', line 9, column 35 to line 14, column 5)"};

template <typename T0__, typename T1__, typename T2__, typename T3__,
typename T6__, typename T7__>
stan::promote_args_t<T0__, T1__, stan::value_type_t<T2__>,
stan::value_type_t<T3__>,
T6__, stan::promote_args_t<stan::value_type_t<T7__>>>
bar_L23C9_impl__(const T0__& p, const std::vector<T1__>& pa, const T2__& pv,
                 const T3__& v, const double& x,
                 const std::vector<double>& y, const T6__& z, const T7__& r,
                 std::ostream* pstream__)  ;

template<bool ref__, typename F0__, typename F1__, typename F2__>
class bar_L23C9_cfunctor__ {
  stan::capture_type_t<F0__, ref__> p;
  stan::capture_type_t<std::vector<F1__>, ref__> pa;
  stan::capture_type_t<Eigen::Matrix<F2__, -1, 1>, ref__> pv;
  const Eigen::Matrix<double, -1, 1>& v;
  stan::capture_type_t<double, ref__> x;
  const std::vector<double>& y;
  public:
  const size_t vars_count__;
  bar_L23C9_cfunctor__(const bar_L23C9_cfunctor__<ref__, F0__, F1__, F2__>&) = default ;
  bar_L23C9_cfunctor__(bar_L23C9_cfunctor__<ref__, F0__, F1__, F2__>&&) = default ;
  bar_L23C9_cfunctor__(const F0__& p__, const std::vector<F1__>& pa__,
                       const Eigen::Matrix<F2__, -1, 1>& pv__,
                       const Eigen::Matrix<double, -1, 1>& v__,
                       const double& x__, const std::vector<double>& y__)
  : p(p__), pa(pa__), pv(pv__), v(v__), x(x__), y(y__),
    vars_count__(count_vars(p__, pa__, pv__, v__, x__, y__)) {}
  template <typename T0__, typename T1__>
  stan::promote_args_t<F0__, F1__, F2__, T0__,
stan::value_type_t<T1__>>
  operator()(std::ostream* pstream__, const T0__& z, const T1__& r)  const 
  {
  return bar_L23C9_impl__(p, pa, pv, v, x, y, z, r, pstream__);
  }
  
  using captured_scalar_t__ = stan::return_type_t<F0__, F1__, F2__>;
  using ValueOf__ = bar_L23C9_cfunctor__<false, double, double, double>;
  using CopyOf__ = bar_L23C9_cfunctor__<false,
                                        stan::capture_type_t<F0__, false>,
                                        stan::capture_type_t<F1__, false>,
                                        stan::capture_type_t<F2__, false>>;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__(eval(value_of(p)), eval(value_of(pa)), eval(value_of(pv)),
                   v, x, y);
  }
  auto deep_copy_vars__() const {
  return CopyOf__(eval(deep_copy_vars(p)), eval(deep_copy_vars(pa)),
                  eval(deep_copy_vars(pv)), v, x, y);
  }
  void zero_adjoints__() {
  stan::math::zero_adjoints(p);
  stan::math::zero_adjoints(pa);
  stan::math::zero_adjoints(pv);
  stan::math::zero_adjoints(v);
  stan::math::zero_adjoints(x);
  stan::math::zero_adjoints(y);
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest, p, pa, pv, v, x, y);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest, p, pa, pv, v, x, y);
  }
  
  
  };
template<typename F0__,
typename F1__,
typename F2__>
auto bar_L23C9_make__(const F0__& p, const std::vector<F1__>& pa,
                      const Eigen::Matrix<F2__, -1, 1>& pv,
                      const Eigen::Matrix<double, -1, 1>& v, const double& x,
                      const std::vector<double>& y) {
return bar_L23C9_cfunctor__<false,
F0__,
F1__,
F2__>(p, pa, pv, v, x, y);
}

template <typename T0__, typename T3__, typename T4__>
stan::promote_args_t<stan::value_type_t<T0__>, T3__,
stan::value_type_t<T4__>>
foo_L9C9_impl__(const T0__& v, const double& x, const std::vector<double>& y,
                const T3__& z, const T4__& r, std::ostream* pstream__)  ;

class foo_L9C9_cfunctor__ {
  const Eigen::Matrix<double, -1, 1>& v;
  double x;
  const std::vector<double>& y;
  public:
  const size_t vars_count__;
  foo_L9C9_cfunctor__(const foo_L9C9_cfunctor__&) = default ;
  foo_L9C9_cfunctor__(foo_L9C9_cfunctor__&&) = default ;
  foo_L9C9_cfunctor__(const Eigen::Matrix<double, -1, 1>& v__,
                      const double& x__, const std::vector<double>& y__)
  : v(v__), x(x__), y(y__), vars_count__(count_vars(v__, x__, y__)) {}
  template <typename T0__, typename T1__>
  stan::promote_args_t<T0__,
stan::value_type_t<T1__>>
  operator()(std::ostream* pstream__, const T0__& z, const T1__& r)  const 
  {
  return foo_L9C9_impl__(v, x, y, z, r, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = foo_L9C9_cfunctor__;
  using CopyOf__ = foo_L9C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__(v, x, y);
  }
  auto deep_copy_vars__() const {
  return CopyOf__(v, x, y);
  }
  void zero_adjoints__() {
  stan::math::zero_adjoints(v);
  stan::math::zero_adjoints(x);
  stan::math::zero_adjoints(y);
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest, v, x, y);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest, v, x, y);
  }
  
  
  };
auto foo_L9C9_make__(const Eigen::Matrix<double, -1, 1>& v, const double& x,
                     const std::vector<double>& y) {
return foo_L9C9_cfunctor__(v, x, y);
}

template <typename T0__, typename T1__, typename T2__, typename T3__,
typename T6__, typename T7__>
stan::promote_args_t<T0__, T1__, stan::value_type_t<T2__>,
stan::value_type_t<T3__>,
T6__, stan::promote_args_t<stan::value_type_t<T7__>>>
bar_L23C9_impl__(const T0__& p, const std::vector<T1__>& pa,
                 const T2__& pv_arg__, const T3__& v_arg__, const double& x,
                 const std::vector<double>& y, const T6__& z,
                 const T7__& r_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
          T1__,
          stan::value_type_t<T2__>,
          stan::value_type_t<T3__>,
          T6__, stan::promote_args_t<stan::value_type_t<T7__>>>;
  int current_statement__ = 0; 
  const auto& pv = to_ref(pv_arg__);
  const auto& v = to_ref(v_arg__);
  const auto& r = to_ref(r_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    local_scalar_t__ rs;
    rs = DUMMY_VAR__;
    
    current_statement__ = 18;
    rs = sum(r);
    local_scalar_t__ ys;
    ys = DUMMY_VAR__;
    
    current_statement__ = 19;
    ys = sum(y);
    local_scalar_t__ vs;
    vs = DUMMY_VAR__;
    
    current_statement__ = 20;
    vs = sum(v);
    local_scalar_t__ pas;
    pas = DUMMY_VAR__;
    
    current_statement__ = 21;
    pas = sum(pa);
    local_scalar_t__ pvs;
    pvs = DUMMY_VAR__;
    
    current_statement__ = 22;
    pvs = sum(pv);
    current_statement__ = 23;
    return (((((((z + rs) + x) + ys) + vs) + p) + pas) + pvs);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__, typename T3__, typename T4__>
stan::promote_args_t<stan::value_type_t<T0__>, T3__,
stan::value_type_t<T4__>>
foo_L9C9_impl__(const T0__& v_arg__, const double& x,
                const std::vector<double>& y, const T3__& z,
                const T4__& r_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T3__,
          stan::value_type_t<T4__>>;
  int current_statement__ = 0; 
  const auto& v = to_ref(v_arg__);
  const auto& r = to_ref(r_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    local_scalar_t__ rs;
    rs = DUMMY_VAR__;
    
    current_statement__ = 25;
    rs = sum(r);
    local_scalar_t__ ys;
    ys = DUMMY_VAR__;
    
    current_statement__ = 26;
    ys = sum(y);
    local_scalar_t__ vs;
    vs = DUMMY_VAR__;
    
    current_statement__ = 27;
    vs = sum(v);
    current_statement__ = 28;
    return ((((z + rs) + x) + ys) + vs);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
class closures1_model final : public model_base_crtp<closures1_model> {

 private:
  int N;
  double x;
  std::vector<double> y;
  Eigen::Matrix<double, -1, 1> v__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> v{nullptr, 0};
 
 public:
  ~closures1_model() { }
  
  inline std::string model_name() const final { return "closures1_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp"};
  }
  
  
  closures1_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "closures1_model_namespace::closures1_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 10;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 10;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 11;
      context__.validate_dims("data initialization","x","double",
           std::vector<size_t>{});
      x = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      x = context__.vals_r("x")[(1 - 1)];
      current_statement__ = 12;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 13;
      context__.validate_dims("data initialization","y","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      y = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 13;
      y = context__.vals_r("y");
      current_statement__ = 14;
      validate_non_negative_index("v", "N", N);
      current_statement__ = 15;
      context__.validate_dims("data initialization","v","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      v__ = Eigen::Matrix<double, -1, 1>(N);
      new (&v) Eigen::Map<Eigen::Matrix<double, -1, 1>>(v__.data(), N);
      
      {
        std::vector<local_scalar_t__> v_flat__;
        current_statement__ = 15;
        v_flat__ = context__.vals_r("v");
        current_statement__ = 15;
        pos__ = 1;
        current_statement__ = 15;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 15;
          assign(v, v_flat__[(pos__ - 1)],
            "assigning variable v", index_uni(sym1__));
          current_statement__ = 15;
          pos__ = (pos__ + 1);
        }
      }
      
      current_statement__ = 1;
      auto foo = foo_L9C9_make__(v, x, y);
      current_statement__ = 16;
      validate_non_negative_index("pa", "N", N);
      current_statement__ = 17;
      validate_non_negative_index("pv", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 1 + N + N;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures1_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      
      current_statement__ = 1;
      auto foo = foo_L9C9_make__(v, x, y);
      local_scalar_t__ p;
      p = DUMMY_VAR__;
      
      current_statement__ = 2;
      p = in__.template read<local_scalar_t__>();
      std::vector<local_scalar_t__> pa;
      pa = std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      
      current_statement__ = 3;
      pa = in__.template read<std::vector<local_scalar_t__>>(N);
      Eigen::Matrix<local_scalar_t__, -1, 1> pv;
      pv = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(pv, DUMMY_VAR__);
      
      current_statement__ = 4;
      pv = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(N);
      {
        
        current_statement__ = 5;
        auto bar = bar_L23C9_make__(p, pa, pv, v, x, y);
        current_statement__ = 6;
        lp_accum__.add(
          foo(pstream__, 0.0, (Eigen::Matrix<double,1,-1>(1) <<
            1.0).finished()));
        current_statement__ = 7;
        lp_accum__.add(
          foo(pstream__, p, (Eigen::Matrix<double,1,-1>(1) <<
            1.0).finished()));
        current_statement__ = 8;
        lp_accum__.add(
          bar(pstream__, 0.0, (Eigen::Matrix<double,1,-1>(1) <<
            1.0).finished()));
        current_statement__ = 9;
        lp_accum__.add(
          bar(pstream__, p, (Eigen::Matrix<double,1,-1>(1) <<
            1.0).finished()));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures1_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      
      current_statement__ = 1;
      auto foo = foo_L9C9_make__(v, x, y);
      double p;
      p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      p = in__.template read<local_scalar_t__>();
      std::vector<double> pa;
      pa = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      pa = in__.template read<std::vector<local_scalar_t__>>(N);
      Eigen::Matrix<double, -1, 1> pv;
      pv = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(pv, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      pv = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(N);
      vars__.emplace_back(p);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(pa[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(pv[(sym1__ - 1)]);
      }
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    int current_statement__ = 0; 
    
    try {
      
      current_statement__ = 1;
      auto foo = foo_L9C9_make__(v, x, y);
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double p;
      p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      p = context__.vals_r("p")[(1 - 1)];
      std::vector<double> pa;
      pa = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      pa = context__.vals_r("pa");
      Eigen::Matrix<double, -1, 1> pv;
      pv = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(pv, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> pv_flat__;
        current_statement__ = 4;
        pv_flat__ = context__.vals_r("pv");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 4;
          assign(pv, pv_flat__[(pos__ - 1)],
            "assigning variable pv", index_uni(sym1__));
          current_statement__ = 4;
          pos__ = (pos__ + 1);
        }
      }
      vars__.emplace_back(p);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(pa[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(pv[(sym1__ - 1)]);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"p", "pa", "pv"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "p");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pa" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pv" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "p");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pa" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pv" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"pa\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"pv\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"pa\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"pv\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec;
      vars_vec.reserve(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars,
       emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec;
      params_r_vec.reserve(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }

};
}
using stan_model = closures1_model_namespace::closures1_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return closures1_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc --print-cpp closures2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace closures2_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 20> locations_array__ = 
{" (found before start of program)",
 " (in 'closures2.stan', line 2, column 4 to line 5, column 5)",
 " (in 'closures2.stan', line 6, column 4 to line 9, column 5)",
 " (in 'closures2.stan', line 12, column 4 to column 15)",
 " (in 'closures2.stan', line 15, column 4 to line 18, column 5)",
 " (in 'closures2.stan', line 19, column 4 to line 26, column 5)",
 " (in 'closures2.stan', line 27, column 4 to column 23)",
 " (in 'closures2.stan', line 28, column 4 to column 23)",
 " (in 'closures2.stan', line 29, column 4 to column 23)",
 " (in 'closures2.stan', line 8, column 8 to column 22)",
 " (in 'closures2.stan', line 7, column 21 to line 9, column 5)",
 " (in 'closures2.stan', line 17, column 8 to column 22)",
 " (in 'closures2.stan', line 16, column 21 to line 18, column 5)",
 " (in 'closures2.stan', line 4, column 8 to column 17)",
 " (in 'closures2.stan', line 3, column 21 to line 5, column 5)",
 " (in 'closures2.stan', line 23, column 12 to column 21)",
 " (in 'closures2.stan', line 22, column 25 to line 24, column 9)",
 " (in 'closures2.stan', line 21, column 8 to line 24, column 9)",
 " (in 'closures2.stan', line 25, column 8 to column 22)",
 " (in 'closures2.stan', line 20, column 21 to line 26, column 5)"};

template <typename T0__, typename T1__>
stan::promote_args_t<typename T0__::captured_scalar_t__,
T1__>
bar_L7C9_impl__(const T0__& foo, const T1__& y, std::ostream* pstream__)  ;

template<bool ref__, typename F0__>
class bar_L7C9_cfunctor__ {
  stan::capture_type_t<F0__, ref__> foo;
  public:
  const size_t vars_count__;
  bar_L7C9_cfunctor__(const bar_L7C9_cfunctor__<ref__, F0__>&) = default ;
  bar_L7C9_cfunctor__(bar_L7C9_cfunctor__<ref__, F0__>&&) = default ;
  bar_L7C9_cfunctor__(const F0__& foo__)
  : foo(foo__), vars_count__(count_vars(foo__)) {}
  template <typename T0__>
  stan::promote_args_t<typename F0__::captured_scalar_t__,
T0__>
  operator()(std::ostream* pstream__, const T0__& y)  const 
  {
  return bar_L7C9_impl__(foo, y, pstream__);
  }
  
  using captured_scalar_t__ = stan::return_type_t<F0__>;
  using ValueOf__ = bar_L7C9_cfunctor__<false, typename F0__::ValueOf__>;
  using CopyOf__ = bar_L7C9_cfunctor__<false,
                                       stan::capture_type_t<F0__, false>>;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__(eval(value_of(foo)));
  }
  auto deep_copy_vars__() const {
  return CopyOf__(eval(deep_copy_vars(foo)));
  }
  void zero_adjoints__() {
  stan::math::zero_adjoints(foo);
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest, foo);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest, foo);
  }
  
  
  };
template<typename F0__>
auto bar_L7C9_make__(const F0__& foo) {
return bar_L7C9_cfunctor__<false,
F0__>(foo);
}

template <typename T0__, typename T1__>
stan::promote_args_t<typename T0__::captured_scalar_t__,
T1__>
baz_L16C9_impl__(const T0__& foo, const T1__& y, std::ostream* pstream__)  ;

template<bool ref__, typename F0__>
class baz_L16C9_cfunctor__ {
  stan::capture_type_t<F0__, ref__> foo;
  public:
  const size_t vars_count__;
  baz_L16C9_cfunctor__(const baz_L16C9_cfunctor__<ref__, F0__>&) = default ;
  baz_L16C9_cfunctor__(baz_L16C9_cfunctor__<ref__, F0__>&&) = default ;
  baz_L16C9_cfunctor__(const F0__& foo__)
  : foo(foo__), vars_count__(count_vars(foo__)) {}
  template <typename T0__>
  stan::promote_args_t<typename F0__::captured_scalar_t__,
T0__>
  operator()(std::ostream* pstream__, const T0__& y)  const 
  {
  return baz_L16C9_impl__(foo, y, pstream__);
  }
  
  using captured_scalar_t__ = stan::return_type_t<F0__>;
  using ValueOf__ = baz_L16C9_cfunctor__<false, typename F0__::ValueOf__>;
  using CopyOf__ = baz_L16C9_cfunctor__<false,
                                        stan::capture_type_t<F0__, false>>;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__(eval(value_of(foo)));
  }
  auto deep_copy_vars__() const {
  return CopyOf__(eval(deep_copy_vars(foo)));
  }
  void zero_adjoints__() {
  stan::math::zero_adjoints(foo);
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest, foo);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest, foo);
  }
  
  
  };
template<typename F0__>
auto baz_L16C9_make__(const F0__& foo) {
return baz_L16C9_cfunctor__<false,
F0__>(foo);
}

template <typename T0__>
stan::promote_args_t<T0__>
foo_L3C9_impl__(const T0__& x, std::ostream* pstream__)  ;

class foo_L3C9_cfunctor__ {
  
  public:
  const size_t vars_count__;
  foo_L3C9_cfunctor__(const foo_L3C9_cfunctor__&) = default ;
  foo_L3C9_cfunctor__(foo_L3C9_cfunctor__&&) = default ;
  foo_L3C9_cfunctor__()
  : vars_count__(count_vars()) {}
  template <typename T0__>
  stan::promote_args_t<T0__>
  operator()(std::ostream* pstream__, const T0__& x)  const 
  {
  return foo_L3C9_impl__(x, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = foo_L3C9_cfunctor__;
  using CopyOf__ = foo_L3C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  
  
  };
auto foo_L3C9_make__() {
return foo_L3C9_cfunctor__();
}

template <typename T0__>
stan::promote_args_t<T0__>
gar_L22C13_impl__(const T0__& b, std::ostream* pstream__)  ;

class gar_L22C13_cfunctor__ {
  
  public:
  const size_t vars_count__;
  gar_L22C13_cfunctor__(const gar_L22C13_cfunctor__&) = default ;
  gar_L22C13_cfunctor__(gar_L22C13_cfunctor__&&) = default ;
  gar_L22C13_cfunctor__()
  : vars_count__(count_vars()) {}
  template <typename T0__>
  stan::promote_args_t<T0__>
  operator()(std::ostream* pstream__, const T0__& b)  const 
  {
  return gar_L22C13_impl__(b, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = gar_L22C13_cfunctor__;
  using CopyOf__ = gar_L22C13_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  
  
  };
auto gar_L22C13_make__() {
return gar_L22C13_cfunctor__();
}

template <typename T0__>
stan::promote_args_t<T0__>
goo_L20C9_impl__(const T0__& s, std::ostream* pstream__)  ;

class goo_L20C9_cfunctor__ {
  
  public:
  const size_t vars_count__;
  goo_L20C9_cfunctor__(const goo_L20C9_cfunctor__&) = default ;
  goo_L20C9_cfunctor__(goo_L20C9_cfunctor__&&) = default ;
  goo_L20C9_cfunctor__()
  : vars_count__(count_vars()) {}
  template <typename T0__>
  stan::promote_args_t<T0__>
  operator()(std::ostream* pstream__, const T0__& s)  const 
  {
  return goo_L20C9_impl__(s, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = goo_L20C9_cfunctor__;
  using CopyOf__ = goo_L20C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  
  
  };
auto goo_L20C9_make__() {
return goo_L20C9_cfunctor__();
}

template <typename T0__, typename T1__>
stan::promote_args_t<typename T0__::captured_scalar_t__,
T1__>
bar_L7C9_impl__(const T0__& foo, const T1__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<typename T0__::captured_scalar_t__,
          T1__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 9;
    return foo(pstream__, y);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__, typename T1__>
stan::promote_args_t<typename T0__::captured_scalar_t__,
T1__>
baz_L16C9_impl__(const T0__& foo, const T1__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<typename T0__::captured_scalar_t__,
          T1__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 11;
    return foo(pstream__, y);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__>
stan::promote_args_t<T0__>
foo_L3C9_impl__(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 13;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__>
stan::promote_args_t<T0__>
gar_L22C13_impl__(const T0__& b, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 15;
    return b;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__>
stan::promote_args_t<T0__>
goo_L20C9_impl__(const T0__& s, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    
    current_statement__ = 17;
    auto gar = gar_L22C13_make__();
    current_statement__ = 18;
    return gar(pstream__, s);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
class closures2_model final : public model_base_crtp<closures2_model> {

 private:
   
  
 
 public:
  ~closures2_model() { }
  
  inline std::string model_name() const final { return "closures2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp"};
  }
  
  
  closures2_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "closures2_model_namespace::closures2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      
      current_statement__ = 1;
      auto foo = foo_L3C9_make__();
      
      current_statement__ = 2;
      auto bar = bar_L7C9_make__(foo);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures2_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      
      current_statement__ = 1;
      auto foo = foo_L3C9_make__();
      
      current_statement__ = 2;
      auto bar = bar_L7C9_make__(foo);
      local_scalar_t__ alpha;
      alpha = DUMMY_VAR__;
      
      current_statement__ = 3;
      alpha = in__.template read<local_scalar_t__>();
      
      current_statement__ = 4;
      auto baz = baz_L16C9_make__(foo);
      
      current_statement__ = 5;
      auto goo = goo_L20C9_make__();
      local_scalar_t__ s1;
      s1 = DUMMY_VAR__;
      
      current_statement__ = 6;
      s1 = bar(pstream__, 1.0);
      local_scalar_t__ s2;
      s2 = DUMMY_VAR__;
      
      current_statement__ = 7;
      s2 = baz(pstream__, 1.0);
      local_scalar_t__ s3;
      s3 = DUMMY_VAR__;
      
      current_statement__ = 8;
      s3 = goo(pstream__, 1.0);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures2_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      
      current_statement__ = 1;
      auto foo = foo_L3C9_make__();
      
      current_statement__ = 2;
      auto bar = bar_L7C9_make__(foo);
      double alpha;
      alpha = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      alpha = in__.template read<local_scalar_t__>();
      
      
      double s1;
      s1 = std::numeric_limits<double>::quiet_NaN();
      
      double s2;
      s2 = std::numeric_limits<double>::quiet_NaN();
      
      double s3;
      s3 = std::numeric_limits<double>::quiet_NaN();
      
      vars__.emplace_back(alpha);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 4;
      auto baz = baz_L16C9_make__(foo);
      current_statement__ = 5;
      auto goo = goo_L20C9_make__();
      current_statement__ = 6;
      s1 = bar(pstream__, 1.0);
      current_statement__ = 7;
      s2 = baz(pstream__, 1.0);
      current_statement__ = 8;
      s3 = goo(pstream__, 1.0);
      if (emit_transformed_parameters__) {
        vars__.emplace_back(s1);
        vars__.emplace_back(s2);
        vars__.emplace_back(s3);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    int current_statement__ = 0; 
    
    try {
      
      current_statement__ = 1;
      auto foo = foo_L3C9_make__();
      
      current_statement__ = 2;
      auto bar = bar_L7C9_make__(foo);
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double alpha;
      alpha = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      alpha = context__.vals_r("alpha")[(1 - 1)];
      vars__.emplace_back(alpha);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"alpha", "s1", "s2", "s3"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "s1");
      param_names__.emplace_back(std::string() + "s2");
      param_names__.emplace_back(std::string() + "s3");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "s1");
      param_names__.emplace_back(std::string() + "s2");
      param_names__.emplace_back(std::string() + "s3");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"s1\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"s2\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"s3\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"s1\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"s2\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"s3\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec;
      vars_vec.reserve(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars,
       emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec;
      params_r_vec.reserve(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }

};
}
using stan_model = closures2_model_namespace::closures2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return closures2_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc --print-cpp closures3.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace closures3_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 18> locations_array__ = 
{" (found before start of program)",
 " (in 'closures3.stan', line 15, column 4 to line 18, column 5)",
 " (in 'closures3.stan', line 22, column 4 to column 11)",
 " (in 'closures3.stan', line 25, column 4 to line 28, column 5)",
 " (in 'closures3.stan', line 29, column 4 to column 27)",
 " (in 'closures3.stan', line 14, column 4 to column 28)",
 " (in 'closures3.stan', line 19, column 4 to column 27)",
 " (in 'closures3.stan', line 3, column 8 to line 6, column 9)",
 " (in 'closures3.stan', line 7, column 8 to column 23)",
 " (in 'closures3.stan', line 2, column 35 to line 8, column 5)",
 " (in 'closures3.stan', line 10, column 8 to column 17)",
 " (in 'closures3.stan', line 9, column 22 to line 11, column 5)",
 " (in 'closures3.stan', line 17, column 8 to column 19)",
 " (in 'closures3.stan', line 16, column 21 to line 18, column 5)",
 " (in 'closures3.stan', line 27, column 8 to column 19)",
 " (in 'closures3.stan', line 26, column 21 to line 28, column 5)",
 " (in 'closures3.stan', line 5, column 12 to column 28)",
 " (in 'closures3.stan', line 4, column 24 to line 6, column 9)"};

template <typename T0__, typename T1__>
stan::promote_args_t<typename T0__::captured_scalar_t__,
T1__>
foo(const T0__& g, const T1__& x, std::ostream* pstream__) ;

struct foo_functor__ {
template <typename T0__, typename T1__>
stan::promote_args_t<typename T0__::captured_scalar_t__,
T1__>
operator()(const T0__& g, const T1__& x, std::ostream* pstream__)  const 
{
return foo(g, x, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
foo2(const T0__& x, std::ostream* pstream__) ;

struct foo2_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return foo2(x, pstream__);
}
};

template <typename T1__>
stan::promote_args_t<T1__>
bar_L16C9_impl__(const double& x, const T1__& y, std::ostream* pstream__)  ;

class bar_L16C9_cfunctor__ {
  double x;
  public:
  const size_t vars_count__;
  bar_L16C9_cfunctor__(const bar_L16C9_cfunctor__&) = default ;
  bar_L16C9_cfunctor__(bar_L16C9_cfunctor__&&) = default ;
  bar_L16C9_cfunctor__(const double& x__)
  : x(x__), vars_count__(count_vars(x__)) {}
  template <typename T0__>
  stan::promote_args_t<T0__>
  operator()(std::ostream* pstream__, const T0__& y)  const 
  {
  return bar_L16C9_impl__(x, y, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = bar_L16C9_cfunctor__;
  using CopyOf__ = bar_L16C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__(x);
  }
  auto deep_copy_vars__() const {
  return CopyOf__(x);
  }
  void zero_adjoints__() {
  stan::math::zero_adjoints(x);
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest, x);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest, x);
  }
  
  
  };
auto bar_L16C9_make__(const double& x) {
return bar_L16C9_cfunctor__(x);
}

template <typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
baz_L26C9_impl__(const T0__& p, const T1__& y, std::ostream* pstream__)  ;

template<bool ref__, typename F0__>
class baz_L26C9_cfunctor__ {
  stan::capture_type_t<F0__, ref__> p;
  public:
  const size_t vars_count__;
  baz_L26C9_cfunctor__(const baz_L26C9_cfunctor__<ref__, F0__>&) = default ;
  baz_L26C9_cfunctor__(baz_L26C9_cfunctor__<ref__, F0__>&&) = default ;
  baz_L26C9_cfunctor__(const F0__& p__)
  : p(p__), vars_count__(count_vars(p__)) {}
  template <typename T0__>
  stan::promote_args_t<F0__,
T0__>
  operator()(std::ostream* pstream__, const T0__& y)  const 
  {
  return baz_L26C9_impl__(p, y, pstream__);
  }
  
  using captured_scalar_t__ = stan::return_type_t<F0__>;
  using ValueOf__ = baz_L26C9_cfunctor__<false, double>;
  using CopyOf__ = baz_L26C9_cfunctor__<false,
                                        stan::capture_type_t<F0__, false>>;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__(eval(value_of(p)));
  }
  auto deep_copy_vars__() const {
  return CopyOf__(eval(deep_copy_vars(p)));
  }
  void zero_adjoints__() {
  stan::math::zero_adjoints(p);
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest, p);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest, p);
  }
  
  
  };
template<typename F0__>
auto baz_L26C9_make__(const F0__& p) {
return baz_L26C9_cfunctor__<false,
F0__>(p);
}

template <typename T0__, typename T1__, typename T2__>
stan::promote_args_t<typename T0__::captured_scalar_t__, T1__,
T2__>
g2_L4C13_impl__(const T0__& g, const T1__& x, const T2__& y,
                std::ostream* pstream__)  ;

template<bool ref__, typename F0__, typename F1__>
class g2_L4C13_cfunctor__ {
  stan::capture_type_t<F0__, ref__> g;
  stan::capture_type_t<F1__, ref__> x;
  public:
  const size_t vars_count__;
  g2_L4C13_cfunctor__(const g2_L4C13_cfunctor__<ref__, F0__, F1__>&) = default ;
  g2_L4C13_cfunctor__(g2_L4C13_cfunctor__<ref__, F0__, F1__>&&) = default ;
  g2_L4C13_cfunctor__(const F0__& g__, const F1__& x__)
  : g(g__), x(x__), vars_count__(count_vars(g__, x__)) {}
  template <typename T0__>
  stan::promote_args_t<typename F0__::captured_scalar_t__, F1__,
T0__>
  operator()(std::ostream* pstream__, const T0__& y)  const 
  {
  return g2_L4C13_impl__(g, x, y, pstream__);
  }
  
  using captured_scalar_t__ = stan::return_type_t<F0__, F1__>;
  using ValueOf__ = g2_L4C13_cfunctor__<false, typename F0__::ValueOf__,
                                        double>;
  using CopyOf__ = g2_L4C13_cfunctor__<false,
                                       stan::capture_type_t<F0__, false>,
                                       stan::capture_type_t<F1__, false>>;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__(eval(value_of(g)), eval(value_of(x)));
  }
  auto deep_copy_vars__() const {
  return CopyOf__(eval(deep_copy_vars(g)), eval(deep_copy_vars(x)));
  }
  void zero_adjoints__() {
  stan::math::zero_adjoints(g);
  stan::math::zero_adjoints(x);
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest, g, x);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest, g, x);
  }
  
  
  };
template<typename F0__,
typename F1__>
auto g2_L4C13_make__(const F0__& g, const F1__& x) {
return g2_L4C13_cfunctor__<false,
F0__,
F1__>(g, x);
}

template <typename T0__, typename T1__>
stan::promote_args_t<typename T0__::captured_scalar_t__,
T1__>
foo(const T0__& g, const T1__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<typename T0__::captured_scalar_t__,
          T1__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    
    current_statement__ = 7;
    auto g2 = g2_L4C13_make__(g, x);
    current_statement__ = 8;
    return g2(pstream__, 1.0);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__>
stan::promote_args_t<T0__>
foo2(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 10;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T1__>
stan::promote_args_t<T1__>
bar_L16C9_impl__(const double& x, const T1__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 12;
    return (x * y);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
baz_L26C9_impl__(const T0__& p, const T1__& y, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 14;
    return (p * y);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__, typename T1__, typename T2__>
stan::promote_args_t<typename T0__::captured_scalar_t__, T1__,
T2__>
g2_L4C13_impl__(const T0__& g, const T1__& x, const T2__& y,
                std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<typename T0__::captured_scalar_t__,
          T1__,
          T2__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 16;
    return (g(pstream__, y) * x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
class closures3_model final : public model_base_crtp<closures3_model> {

 private:
  double x;
  double z; 
  
 
 public:
  ~closures3_model() { }
  
  inline std::string model_name() const final { return "closures3_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp"};
  }
  
  
  closures3_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "closures3_model_namespace::closures3_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 5;
      x = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      x = foo(from_lambda(foo2_functor__()), 2.0, pstream__);
      
      current_statement__ = 1;
      auto bar = bar_L16C9_make__(x);
      current_statement__ = 6;
      z = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      z = foo(bar, 1.0, pstream__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures3_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      
      current_statement__ = 1;
      auto bar = bar_L16C9_make__(x);
      local_scalar_t__ p;
      p = DUMMY_VAR__;
      
      current_statement__ = 2;
      p = in__.template read<local_scalar_t__>();
      
      current_statement__ = 3;
      auto baz = baz_L26C9_make__(p);
      local_scalar_t__ w;
      w = DUMMY_VAR__;
      
      current_statement__ = 4;
      w = foo(baz, 1.0, pstream__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures3_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      
      current_statement__ = 1;
      auto bar = bar_L16C9_make__(x);
      double p;
      p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      p = in__.template read<local_scalar_t__>();
      
      double w;
      w = std::numeric_limits<double>::quiet_NaN();
      
      vars__.emplace_back(p);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 3;
      auto baz = baz_L26C9_make__(p);
      current_statement__ = 4;
      w = foo(baz, 1.0, pstream__);
      if (emit_transformed_parameters__) {
        vars__.emplace_back(w);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    int current_statement__ = 0; 
    
    try {
      
      current_statement__ = 1;
      auto bar = bar_L16C9_make__(x);
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double p;
      p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      p = context__.vals_r("p")[(1 - 1)];
      vars__.emplace_back(p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"p", "w"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "p");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "w");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "p");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "w");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"w\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"w\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec;
      vars_vec.reserve(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars,
       emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec;
      params_r_vec.reserve(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }

};
}
using stan_model = closures3_model_namespace::closures3_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return closures3_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc --print-cpp closures4.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace closures4_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 11> locations_array__ = 
{" (found before start of program)",
 " (in 'closures4.stan', line 14, column 4 to column 19)",
 " (in 'closures4.stan', line 15, column 4 to column 19)",
 " (in 'closures4.stan', line 18, column 4 to column 44)",
 " (in 'closures4.stan', line 11, column 4 to column 15)",
 " (in 'closures4.stan', line 14, column 16 to column 17)",
 " (in 'closures4.stan', line 3, column 8 to line 6, column 9)",
 " (in 'closures4.stan', line 7, column 8 to column 47)",
 " (in 'closures4.stan', line 2, column 59 to line 8, column 5)",
 " (in 'closures4.stan', line 5, column 12 to column 30)",
 " (in 'closures4.stan', line 4, column 42 to line 6, column 9)"};

template <typename T0__, typename T1__, typename T2__>
std::vector<Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T1__>,
T2__>, -1, 1>>
integrate(const std::vector<Eigen::Matrix<T0__, -1, 1>>& k, const T1__& init,
          const std::vector<T2__>& ts, std::ostream* pstream__) ;

struct integrate_functor__ {
template <typename T0__, typename T1__, typename T2__>
std::vector<Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T1__>,
T2__>, -1, 1>>
operator()(const std::vector<Eigen::Matrix<T0__, -1, 1>>& k,
           const T1__& init, const std::vector<T2__>& ts,
           std::ostream* pstream__)  const 
{
return integrate(k, init, ts, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<T0__, T1__,
stan::value_type_t<T2__>>, -1, 1>
harmonic_L4C15_impl__(const std::vector<Eigen::Matrix<T0__, -1, 1>>& k,
                      const T1__& t, const T2__& y, std::ostream* pstream__)  ;

template<bool ref__, typename F0__>
class harmonic_L4C15_cfunctor__ {
  stan::capture_type_t<std::vector<Eigen::Matrix<F0__, -1, 1>>, ref__> k;
  public:
  const size_t vars_count__;
  harmonic_L4C15_cfunctor__(const harmonic_L4C15_cfunctor__<ref__, F0__>&) = default ;
  harmonic_L4C15_cfunctor__(harmonic_L4C15_cfunctor__<ref__, F0__>&&) = default ;
  harmonic_L4C15_cfunctor__(const std::vector<Eigen::Matrix<F0__, -1, 1>>& k__)
  : k(k__), vars_count__(count_vars(k__)) {}
  template <typename T0__, typename T1__>
  Eigen::Matrix<stan::promote_args_t<F0__, T0__,
stan::value_type_t<T1__>>, -1, 1>
  operator()(std::ostream* pstream__, const T0__& t, const T1__& y)  const 
  {
  return harmonic_L4C15_impl__(k, t, y, pstream__);
  }
  
  using captured_scalar_t__ = stan::return_type_t<F0__>;
  using ValueOf__ = harmonic_L4C15_cfunctor__<false, double>;
  using CopyOf__ = harmonic_L4C15_cfunctor__<false,
                                             stan::capture_type_t<F0__, false>>;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__(eval(value_of(k)));
  }
  auto deep_copy_vars__() const {
  return CopyOf__(eval(deep_copy_vars(k)));
  }
  void zero_adjoints__() {
  stan::math::zero_adjoints(k);
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest, k);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest, k);
  }
  
  
  };
template<typename F0__>
auto harmonic_L4C15_make__(const std::vector<Eigen::Matrix<F0__, -1, 1>>& k) {
return harmonic_L4C15_cfunctor__<false,
F0__>(k);
}

template <typename T0__, typename T1__, typename T2__>
std::vector<Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T1__>,
T2__>, -1, 1>>
integrate(const std::vector<Eigen::Matrix<T0__, -1, 1>>& k,
          const T1__& init_arg__, const std::vector<T2__>& ts,
          std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
          stan::value_type_t<T1__>,
          T2__>;
  int current_statement__ = 0; 
  const auto& init = to_ref(init_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    
    current_statement__ = 6;
    auto harmonic = harmonic_L4C15_make__(k);
    current_statement__ = 7;
    return ode_rk45(stan::math::ode_closure_adapter(), init, 0, ts,
             pstream__, harmonic);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<T0__, T1__,
stan::value_type_t<T2__>>, -1, 1>
harmonic_L4C15_impl__(const std::vector<Eigen::Matrix<T0__, -1, 1>>& k,
                      const T1__& t, const T2__& y_arg__,
                      std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
          T1__,
          stan::value_type_t<T2__>>;
  int current_statement__ = 0; 
  const auto& y = to_ref(y_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 9;
    return elt_multiply(minus(rvalue(k, "k", index_uni(1))), y);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
class closures4_model final : public model_base_crtp<closures4_model> {

 private:
  std::vector<double> ts; 
  
 
 public:
  ~closures4_model() { }
  
  inline std::string model_name() const final { return "closures4_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp"};
  }
  
  
  closures4_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "closures4_model_namespace::closures4_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 4;
      context__.validate_dims("data initialization","ts","double",
           std::vector<size_t>{static_cast<size_t>(5)});
      ts = std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      ts = context__.vals_r("ts");
      current_statement__ = 5;
      validate_non_negative_index("k", "1", 1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = (1 * 2) + 2;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures4_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> k;
      k = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(1, Eigen::Matrix<local_scalar_t__, -1, 1>(2));
      stan::math::fill(k, DUMMY_VAR__);
      
      current_statement__ = 1;
      k = in__.template read<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(
            1, 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> init;
      init = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(init, DUMMY_VAR__);
      
      current_statement__ = 2;
      init = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(2);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> y;
      y = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(5, Eigen::Matrix<local_scalar_t__, -1, 1>(2));
      stan::math::fill(y, DUMMY_VAR__);
      
      current_statement__ = 3;
      assign(y, integrate(k, init, ts, pstream__), "assigning variable y");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures4_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      std::vector<Eigen::Matrix<double, -1, 1>> k;
      k = std::vector<Eigen::Matrix<double, -1, 1>>(1, Eigen::Matrix<double, -1, 1>(2));
      stan::math::fill(k, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      k = in__.template read<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(
            1, 2);
      Eigen::Matrix<double, -1, 1> init;
      init = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(init, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      init = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(2);
      std::vector<Eigen::Matrix<double, -1, 1>> y;
      y = std::vector<Eigen::Matrix<double, -1, 1>>(5, Eigen::Matrix<double, -1, 1>(2));
      stan::math::fill(y, std::numeric_limits<double>::quiet_NaN());
      
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
          vars__.emplace_back(k[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.emplace_back(init[(sym1__ - 1)]);
      }
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 3;
      assign(y, integrate(k, init, ts, pstream__), "assigning variable y");
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            vars__.emplace_back(y[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    int current_statement__ = 0; 
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      std::vector<Eigen::Matrix<double, -1, 1>> k;
      k = std::vector<Eigen::Matrix<double, -1, 1>>(1, Eigen::Matrix<double, -1, 1>(2));
      stan::math::fill(k, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> k_flat__;
        current_statement__ = 1;
        k_flat__ = context__.vals_r("k");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 1;
          for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
            current_statement__ = 1;
            assign(k, k_flat__[(pos__ - 1)],
              "assigning variable k", index_uni(sym2__), index_uni(sym1__));
            current_statement__ = 1;
            pos__ = (pos__ + 1);
          }
        }
      }
      Eigen::Matrix<double, -1, 1> init;
      init = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(init, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> init_flat__;
        current_statement__ = 2;
        init_flat__ = context__.vals_r("init");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 2;
          assign(init, init_flat__[(pos__ - 1)],
            "assigning variable init", index_uni(sym1__));
          current_statement__ = 2;
          pos__ = (pos__ + 1);
        }
      }
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          vars__.emplace_back(k[(sym1__ - 1)][(sym2__ - 1)]);
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.emplace_back(init[(sym1__ - 1)]);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"k", "init", "y"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(1)
                                                                   ,
                                                                   static_cast<size_t>(2)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(2)},
      std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(2)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "k" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "init" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "k" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "init" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"k\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(1) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"parameters\"},{\"name\":\"init\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"k\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(1) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"parameters\"},{\"name\":\"init\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(5) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec;
      vars_vec.reserve(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars,
       emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec;
      params_r_vec.reserve(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }

};
}
using stan_model = closures4_model_namespace::closures4_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return closures4_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc --print-cpp closures5.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace closures5_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 14> locations_array__ = 
{" (found before start of program)",
 " (in 'closures5.stan', line 5, column 4 to column 12)",
 " (in 'closures5.stan', line 6, column 4 to column 14)",
 " (in 'closures5.stan', line 9, column 4 to line 12, column 5)",
 " (in 'closures5.stan', line 13, column 4 to line 16, column 5)",
 " (in 'closures5.stan', line 17, column 4 to column 36)",
 " (in 'closures5.stan', line 18, column 4 to column 41)",
 " (in 'closures5.stan', line 19, column 4 to column 42)",
 " (in 'closures5.stan', line 2, column 4 to column 10)",
 " (in 'closures5.stan', line 6, column 11 to column 12)",
 " (in 'closures5.stan', line 15, column 8 to column 41)",
 " (in 'closures5.stan', line 14, column 52 to line 16, column 5)",
 " (in 'closures5.stan', line 11, column 8 to column 39)",
 " (in 'closures5.stan', line 10, column 47 to line 12, column 5)"};
struct foo_rsfunctor__;
template <bool propto__>
struct bar_lpdf_rsfunctor__;
template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
bar_lpdf_L14C9_impl__(const T0__& mu, const std::vector<T1__>& slice,
                      const int& start, const int& end,
                      std::ostream* pstream__)  ;

template<bool ref__, typename F0__>
class bar_lpdf_L14C9_cfunctor__ {
  stan::capture_type_t<F0__, ref__> mu;
  public:
  const size_t vars_count__;
  bar_lpdf_L14C9_cfunctor__(const bar_lpdf_L14C9_cfunctor__<ref__, F0__>&) = default ;
  bar_lpdf_L14C9_cfunctor__(bar_lpdf_L14C9_cfunctor__<ref__, F0__>&&) = default ;
  bar_lpdf_L14C9_cfunctor__(const F0__& mu__)
  : mu(mu__), vars_count__(count_vars(mu__)) {}
  template <bool propto__, typename T0__>
  stan::promote_args_t<F0__,
T0__>
  operator()(std::ostream* pstream__, const std::vector<T0__>& slice,
             const int& start, const int& end)  const 
  {
  return bar_lpdf_L14C9_impl__<propto__>(mu, slice, start, end, pstream__);
  }
  
  using captured_scalar_t__ = stan::return_type_t<F0__>;
  using ValueOf__ = bar_lpdf_L14C9_cfunctor__<false, double>;
  using CopyOf__ = bar_lpdf_L14C9_cfunctor__<false,
                                             stan::capture_type_t<F0__, false>>;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__(eval(value_of(mu)));
  }
  auto deep_copy_vars__() const {
  return CopyOf__(eval(deep_copy_vars(mu)));
  }
  void zero_adjoints__() {
  stan::math::zero_adjoints(mu);
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest, mu);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest, mu);
  }
  template<bool propto>
  auto with_propto() {
  return stan::math::lpdf_wrapper<propto, bar_lpdf_L14C9_cfunctor__<ref__,
                                                                    F0__>, true>(*this);
  }
  auto copy_of__() {
  return CopyOf__(mu);
  }
  
  };
template<typename F0__>
auto bar_lpdf_L14C9_make__(const F0__& mu) {
return bar_lpdf_L14C9_cfunctor__<false,
F0__>(mu);
}

template <typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
foo_L10C9_impl__(const T0__& mu, const std::vector<T1__>& slice,
                 const int& start, const int& end, std::ostream* pstream__)  ;

template<bool ref__, typename F0__>
class foo_L10C9_cfunctor__ {
  stan::capture_type_t<F0__, ref__> mu;
  public:
  const size_t vars_count__;
  foo_L10C9_cfunctor__(const foo_L10C9_cfunctor__<ref__, F0__>&) = default ;
  foo_L10C9_cfunctor__(foo_L10C9_cfunctor__<ref__, F0__>&&) = default ;
  foo_L10C9_cfunctor__(const F0__& mu__)
  : mu(mu__), vars_count__(count_vars(mu__)) {}
  template <typename T0__>
  stan::promote_args_t<F0__,
T0__>
  operator()(std::ostream* pstream__, const std::vector<T0__>& slice,
             const int& start, const int& end)  const 
  {
  return foo_L10C9_impl__(mu, slice, start, end, pstream__);
  }
  
  using captured_scalar_t__ = stan::return_type_t<F0__>;
  using ValueOf__ = foo_L10C9_cfunctor__<false, double>;
  using CopyOf__ = foo_L10C9_cfunctor__<false,
                                        stan::capture_type_t<F0__, false>>;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__(eval(value_of(mu)));
  }
  auto deep_copy_vars__() const {
  return CopyOf__(eval(deep_copy_vars(mu)));
  }
  void zero_adjoints__() {
  stan::math::zero_adjoints(mu);
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest, mu);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest, mu);
  }
  
  
  };
template<typename F0__>
auto foo_L10C9_make__(const F0__& mu) {
return foo_L10C9_cfunctor__<false,
F0__>(mu);
}

template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
bar_lpdf_L14C9_impl__(const T0__& mu, const std::vector<T1__>& slice,
                      const int& start, const int& end,
                      std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 10;
    return normal_lpdf<propto__>(slice, mu, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
foo_L10C9_impl__(const T0__& mu, const std::vector<T1__>& slice,
                 const int& start, const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 12;
    return normal_lpdf<false>(slice, mu, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
class closures5_model final : public model_base_crtp<closures5_model> {

 private:
  int N; 
  
 
 public:
  ~closures5_model() { }
  
  inline std::string model_name() const final { return "closures5_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp"};
  }
  
  
  closures5_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "closures5_model_namespace::closures5_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 8;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 8;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 9;
      validate_non_negative_index("x", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 1 + N;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures5_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ mu;
      mu = DUMMY_VAR__;
      
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      std::vector<local_scalar_t__> x;
      x = std::vector<local_scalar_t__>(N, DUMMY_VAR__);
      
      current_statement__ = 2;
      x = in__.template read<std::vector<local_scalar_t__>>(N);
      {
        
        current_statement__ = 3;
        auto foo = foo_L10C9_make__(mu);
        
        current_statement__ = 4;
        auto bar_lpdf = bar_lpdf_L14C9_make__(mu);
        current_statement__ = 5;
        lp_accum__.add(
          reduce_sum<stan::math::reduce_sum_closure_adapter>(x, 1, pstream__,
            foo));
        current_statement__ = 6;
        lp_accum__.add(
          reduce_sum<stan::math::reduce_sum_closure_adapter>(x, 1, pstream__,
            bar_lpdf.template with_propto<false>()));
        current_statement__ = 7;
        lp_accum__.add(
          reduce_sum<stan::math::reduce_sum_closure_adapter>(x, 1, pstream__,
            bar_lpdf.template with_propto<propto__>()));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures5_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double mu;
      mu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      std::vector<double> x;
      x = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      x = in__.template read<std::vector<local_scalar_t__>>(N);
      vars__.emplace_back(mu);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(x[(sym1__ - 1)]);
      }
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    int current_statement__ = 0; 
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double mu;
      mu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mu = context__.vals_r("mu")[(1 - 1)];
      std::vector<double> x;
      x = std::vector<double>(N, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      x = context__.vals_r("x");
      vars__.emplace_back(mu);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(x[(sym1__ - 1)]);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mu", "x"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(N)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec;
      vars_vec.reserve(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars,
       emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec;
      params_r_vec.reserve(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }

};
}
using stan_model = closures5_model_namespace::closures5_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return closures5_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc --print-cpp closures6.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace closures6_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 12> locations_array__ = 
{" (found before start of program)",
 " (in 'closures6.stan', line 2, column 4 to column 11)",
 " (in 'closures6.stan', line 3, column 4 to column 11)",
 " (in 'closures6.stan', line 6, column 4 to line 9, column 5)",
 " (in 'closures6.stan', line 10, column 4 to line 13, column 5)",
 " (in 'closures6.stan', line 20, column 4 to column 24)",
 " (in 'closures6.stan', line 16, column 4 to column 28)",
 " (in 'closures6.stan', line 17, column 4 to column 29)",
 " (in 'closures6.stan', line 12, column 8 to column 35)",
 " (in 'closures6.stan', line 11, column 34 to line 13, column 5)",
 " (in 'closures6.stan', line 8, column 8 to column 31)",
 " (in 'closures6.stan', line 7, column 25 to line 9, column 5)"};

template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
foo_lpdf_L11C9_impl__(const T0__& y, const T1__& x, std::ostream* pstream__)  ;

class foo_lpdf_L11C9_cfunctor__ {
  
  public:
  const size_t vars_count__;
  foo_lpdf_L11C9_cfunctor__(const foo_lpdf_L11C9_cfunctor__&) = default ;
  foo_lpdf_L11C9_cfunctor__(foo_lpdf_L11C9_cfunctor__&&) = default ;
  foo_lpdf_L11C9_cfunctor__()
  : vars_count__(count_vars()) {}
  template <bool propto__, typename T0__, typename T1__>
  stan::promote_args_t<T0__,
T1__>
  operator()(std::ostream* pstream__, const T0__& y, const T1__& x)  const 
  {
  return foo_lpdf_L11C9_impl__<propto__>(y, x, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = foo_lpdf_L11C9_cfunctor__;
  using CopyOf__ = foo_lpdf_L11C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  template<bool propto>
  auto with_propto() {
  return stan::math::lpdf_wrapper<propto, foo_lpdf_L11C9_cfunctor__, true>(*this);
  }
  auto copy_of__() {
  return CopyOf__();
  }
  
  };
auto foo_lpdf_L11C9_make__() {
return foo_lpdf_L11C9_cfunctor__();
}

template <typename T0__, typename RNG>
stan::promote_args_t<T0__>
foo_rng_L7C9_impl__(const T0__& x, RNG& base_rng__, std::ostream* pstream__)  ;

class foo_rng_L7C9_cfunctor__ {
  
  public:
  const size_t vars_count__;
  foo_rng_L7C9_cfunctor__(const foo_rng_L7C9_cfunctor__&) = default ;
  foo_rng_L7C9_cfunctor__(foo_rng_L7C9_cfunctor__&&) = default ;
  foo_rng_L7C9_cfunctor__()
  : vars_count__(count_vars()) {}
  template <typename T0__, typename RNG>
  stan::promote_args_t<T0__>
  operator()(RNG& base_rng__, std::ostream* pstream__, const T0__& x)  const 
  {
  return foo_rng_L7C9_impl__(x, base_rng__, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = foo_rng_L7C9_cfunctor__;
  using CopyOf__ = foo_rng_L7C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  
  
  };
auto foo_rng_L7C9_make__() {
return foo_rng_L7C9_cfunctor__();
}

template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
foo_lpdf_L11C9_impl__(const T0__& y, const T1__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 8;
    return normal_lpdf<propto__>(y, x, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__, typename RNG>
stan::promote_args_t<T0__>
foo_rng_L7C9_impl__(const T0__& x, RNG& base_rng__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 10;
    return normal_rng(x, 1, base_rng__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
class closures6_model final : public model_base_crtp<closures6_model> {

 private:
   
  
 
 public:
  ~closures6_model() { }
  
  inline std::string model_name() const final { return "closures6_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp"};
  }
  
  
  closures6_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "closures6_model_namespace::closures6_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures6_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ s;
      s = DUMMY_VAR__;
      
      current_statement__ = 1;
      s = in__.template read<local_scalar_t__>();
      local_scalar_t__ k;
      k = DUMMY_VAR__;
      
      current_statement__ = 2;
      k = in__.template read<local_scalar_t__>();
      
      current_statement__ = 3;
      auto foo_rng = foo_rng_L7C9_make__();
      
      current_statement__ = 4;
      auto foo_lpdf = foo_lpdf_L11C9_make__();
      {
        current_statement__ = 6;
        lp_accum__.add(foo_lpdf.template operator()<false>(pstream__, s, k));
        current_statement__ = 7;
        lp_accum__.add(
          foo_lpdf.template operator()<propto__>(pstream__, s, k));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures6_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double s;
      s = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      s = in__.template read<local_scalar_t__>();
      double k;
      k = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      k = in__.template read<local_scalar_t__>();
      
      
      vars__.emplace_back(s);
      vars__.emplace_back(k);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 3;
      auto foo_rng = foo_rng_L7C9_make__();
      current_statement__ = 4;
      auto foo_lpdf = foo_lpdf_L11C9_make__();
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double m;
      m = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      m = foo_rng(base_rng__, pstream__, k);
      vars__.emplace_back(m);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    int current_statement__ = 0; 
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double s;
      s = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      s = context__.vals_r("s")[(1 - 1)];
      double k;
      k = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      k = context__.vals_r("k")[(1 - 1)];
      vars__.emplace_back(s);
      vars__.emplace_back(k);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"s", "k", "m"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "s");
    param_names__.emplace_back(std::string() + "k");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "m");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "s");
    param_names__.emplace_back(std::string() + "k");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "m");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"s\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"k\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"m\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"s\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"k\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"m\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec;
      vars_vec.reserve(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars,
       emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec;
      params_r_vec.reserve(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }

};
}
using stan_model = closures6_model_namespace::closures6_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return closures6_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc --print-cpp closures7.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace closures7_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 37> locations_array__ = 
{" (found before start of program)",
 " (in 'closures7.stan', line 16, column 4 to line 17, column 68)",
 " (in 'closures7.stan', line 20, column 4 to line 23, column 5)",
 " (in 'closures7.stan', line 24, column 4 to line 27, column 5)",
 " (in 'closures7.stan', line 28, column 4 to line 31, column 5)",
 " (in 'closures7.stan', line 32, column 4 to line 35, column 5)",
 " (in 'closures7.stan', line 36, column 4 to line 39, column 5)",
 " (in 'closures7.stan', line 40, column 4 to line 43, column 5)",
 " (in 'closures7.stan', line 44, column 4 to line 47, column 5)",
 " (in 'closures7.stan', line 51, column 4 to column 27)",
 " (in 'closures7.stan', line 54, column 4 to column 36)",
 " (in 'closures7.stan', line 18, column 4 to column 30)",
 " (in 'closures7.stan', line 48, column 4 to column 30)",
 " (in 'closures7.stan', line 3, column 8 to column 38)",
 " (in 'closures7.stan', line 4, column 8 to column 17)",
 " (in 'closures7.stan', line 2, column 25 to line 5, column 5)",
 " (in 'closures7.stan', line 7, column 8 to column 34)",
 " (in 'closures7.stan', line 8, column 8 to column 17)",
 " (in 'closures7.stan', line 6, column 24 to line 9, column 5)",
 " (in 'closures7.stan', line 11, column 8 to column 26)",
 " (in 'closures7.stan', line 12, column 8 to column 17)",
 " (in 'closures7.stan', line 10, column 23 to line 13, column 5)",
 " (in 'closures7.stan', line 34, column 8 to column 17)",
 " (in 'closures7.stan', line 33, column 20 to line 35, column 5)",
 " (in 'closures7.stan', line 38, column 8 to column 17)",
 " (in 'closures7.stan', line 37, column 25 to line 39, column 5)",
 " (in 'closures7.stan', line 42, column 8 to column 17)",
 " (in 'closures7.stan', line 41, column 24 to line 43, column 5)",
 " (in 'closures7.stan', line 46, column 8 to column 17)",
 " (in 'closures7.stan', line 45, column 23 to line 47, column 5)",
 " (in 'closures7.stan', line 30, column 8 to column 25)",
 " (in 'closures7.stan', line 29, column 35 to line 31, column 5)",
 " (in 'closures7.stan', line 26, column 8 to column 28)",
 " (in 'closures7.stan', line 25, column 48 to line 27, column 5)",
 " (in 'closures7.stan', line 22, column 8 to column 27)",
 " (in 'closures7.stan', line 21, column 38 to line 23, column 5)",
 " (in 'closures7.stan', line 17, column 66 to column 68)"};

template <bool propto__, typename T0__>
stan::promote_args_t<T0__>
ff_lpdf(const T0__& x, std::ostream* pstream__) ;

struct ff_lpdf_functor__ {
template <bool propto__, typename T0__>
stan::promote_args_t<T0__>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return ff_lpdf<propto__>(x, pstream__);
}
};

template <typename T0__, typename RNG>
stan::promote_args_t<T0__>
ff_rng(const T0__& x, RNG& base_rng__, std::ostream* pstream__) ;

struct ff_rng_functor__ {
template <typename T0__, typename RNG>
stan::promote_args_t<T0__>
operator()(const T0__& x, RNG& base_rng__, std::ostream* pstream__)  const 
{
return ff_rng(x, pstream__);
}
};

template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
stan::promote_args_t<T0__>
ff_lp(const T0__& x, T_lp__& lp__, T_lp_accum__& lp_accum__,
      std::ostream* pstream__) ;

struct ff_lp_functor__ {
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
stan::promote_args_t<T0__>
operator()(const T0__& x, T_lp__& lp__, T_lp_accum__& lp_accum__,
           std::ostream* pstream__)  const 
{
return ff_lp(x, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
f2_L33C9_impl__(const T0__& x, std::ostream* pstream__)  ;

class f2_L33C9_cfunctor__ {
  
  public:
  const size_t vars_count__;
  f2_L33C9_cfunctor__(const f2_L33C9_cfunctor__&) = default ;
  f2_L33C9_cfunctor__(f2_L33C9_cfunctor__&&) = default ;
  f2_L33C9_cfunctor__()
  : vars_count__(count_vars()) {}
  template <typename T0__>
  stan::promote_args_t<T0__>
  operator()(std::ostream* pstream__, const T0__& x)  const 
  {
  return f2_L33C9_impl__(x, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = f2_L33C9_cfunctor__;
  using CopyOf__ = f2_L33C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  
  
  };
auto f2_L33C9_make__() {
return f2_L33C9_cfunctor__();
}

template <bool propto__, typename T0__>
stan::promote_args_t<T0__>
f3_lpdf_L37C9_impl__(const T0__& x, std::ostream* pstream__)  ;

class f3_lpdf_L37C9_cfunctor__ {
  
  public:
  const size_t vars_count__;
  f3_lpdf_L37C9_cfunctor__(const f3_lpdf_L37C9_cfunctor__&) = default ;
  f3_lpdf_L37C9_cfunctor__(f3_lpdf_L37C9_cfunctor__&&) = default ;
  f3_lpdf_L37C9_cfunctor__()
  : vars_count__(count_vars()) {}
  template <bool propto__, typename T0__>
  stan::promote_args_t<T0__>
  operator()(std::ostream* pstream__, const T0__& x)  const 
  {
  return f3_lpdf_L37C9_impl__<propto__>(x, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = f3_lpdf_L37C9_cfunctor__;
  using CopyOf__ = f3_lpdf_L37C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  template<bool propto>
  auto with_propto() {
  return stan::math::lpdf_wrapper<propto, f3_lpdf_L37C9_cfunctor__, true>(*this);
  }
  auto copy_of__() {
  return CopyOf__();
  }
  
  };
auto f3_lpdf_L37C9_make__() {
return f3_lpdf_L37C9_cfunctor__();
}

template <typename T0__, typename RNG>
stan::promote_args_t<T0__>
f4_rng_L41C9_impl__(const T0__& x, RNG& base_rng__, std::ostream* pstream__)  ;

class f4_rng_L41C9_cfunctor__ {
  
  public:
  const size_t vars_count__;
  f4_rng_L41C9_cfunctor__(const f4_rng_L41C9_cfunctor__&) = default ;
  f4_rng_L41C9_cfunctor__(f4_rng_L41C9_cfunctor__&&) = default ;
  f4_rng_L41C9_cfunctor__()
  : vars_count__(count_vars()) {}
  template <typename T0__, typename RNG>
  stan::promote_args_t<T0__>
  operator()(RNG& base_rng__, std::ostream* pstream__, const T0__& x)  const 
  {
  return f4_rng_L41C9_impl__(x, base_rng__, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = f4_rng_L41C9_cfunctor__;
  using CopyOf__ = f4_rng_L41C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  
  
  };
auto f4_rng_L41C9_make__() {
return f4_rng_L41C9_cfunctor__();
}

template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
stan::promote_args_t<T0__>
f5_lp_L45C9_impl__(const T0__& x, T_lp__& lp__, T_lp_accum__& lp_accum__,
                   std::ostream* pstream__)  ;

class f5_lp_L45C9_cfunctor__ {
  
  public:
  const size_t vars_count__;
  f5_lp_L45C9_cfunctor__(const f5_lp_L45C9_cfunctor__&) = default ;
  f5_lp_L45C9_cfunctor__(f5_lp_L45C9_cfunctor__&&) = default ;
  f5_lp_L45C9_cfunctor__()
  : vars_count__(count_vars()) {}
  template <bool propto__, typename T0__, typename T_lp__,
  typename T_lp_accum__>
  stan::promote_args_t<T0__>
  operator()(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__,
             const T0__& x)  const 
  {
  return f5_lp_L45C9_impl__<propto__>(x, lp__, lp_accum__, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = f5_lp_L45C9_cfunctor__;
  using CopyOf__ = f5_lp_L45C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  
  
  };
auto f5_lp_L45C9_make__() {
return f5_lp_L45C9_cfunctor__();
}

template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
stan::promote_args_t<typename T0__::captured_scalar_t__>
foo_lp_L29C9_impl__(const T0__& bar_lp, T_lp__& lp__,
                    T_lp_accum__& lp_accum__, std::ostream* pstream__)  ;

class foo_lp_L29C9_cfunctor__ {
  
  public:
  const size_t vars_count__;
  foo_lp_L29C9_cfunctor__(const foo_lp_L29C9_cfunctor__&) = default ;
  foo_lp_L29C9_cfunctor__(foo_lp_L29C9_cfunctor__&&) = default ;
  foo_lp_L29C9_cfunctor__()
  : vars_count__(count_vars()) {}
  template <bool propto__, typename T0__, typename T_lp__,
  typename T_lp_accum__>
  stan::promote_args_t<typename T0__::captured_scalar_t__>
  operator()(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__,
             const T0__& bar_lp)  const 
  {
  return foo_lp_L29C9_impl__<propto__>(bar_lp, lp__, lp_accum__, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = foo_lp_L29C9_cfunctor__;
  using CopyOf__ = foo_lp_L29C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  
  
  };
auto foo_lp_L29C9_make__() {
return foo_lp_L29C9_cfunctor__();
}

template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
typename T1__::captured_scalar_t__>
foo_lpdf_L25C9_impl__(const T0__& zz, const T1__& bar_lpdf,
                      std::ostream* pstream__)  ;

class foo_lpdf_L25C9_cfunctor__ {
  
  public:
  const size_t vars_count__;
  foo_lpdf_L25C9_cfunctor__(const foo_lpdf_L25C9_cfunctor__&) = default ;
  foo_lpdf_L25C9_cfunctor__(foo_lpdf_L25C9_cfunctor__&&) = default ;
  foo_lpdf_L25C9_cfunctor__()
  : vars_count__(count_vars()) {}
  template <bool propto__, typename T0__, typename T1__>
  stan::promote_args_t<T0__,
typename T1__::captured_scalar_t__>
  operator()(std::ostream* pstream__, const T0__& zz, const T1__& bar_lpdf)  const 
  {
  return foo_lpdf_L25C9_impl__<propto__>(zz, bar_lpdf, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = foo_lpdf_L25C9_cfunctor__;
  using CopyOf__ = foo_lpdf_L25C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  template<bool propto>
  auto with_propto() {
  return stan::math::lpdf_wrapper<propto, foo_lpdf_L25C9_cfunctor__, true>(*this);
  }
  auto copy_of__() {
  return CopyOf__();
  }
  
  };
auto foo_lpdf_L25C9_make__() {
return foo_lpdf_L25C9_cfunctor__();
}

template <typename T0__, typename RNG>
stan::promote_args_t<typename T0__::captured_scalar_t__>
foo_rng_L21C9_impl__(const T0__& bar_lpdf, RNG& base_rng__,
                     std::ostream* pstream__)  ;

class foo_rng_L21C9_cfunctor__ {
  
  public:
  const size_t vars_count__;
  foo_rng_L21C9_cfunctor__(const foo_rng_L21C9_cfunctor__&) = default ;
  foo_rng_L21C9_cfunctor__(foo_rng_L21C9_cfunctor__&&) = default ;
  foo_rng_L21C9_cfunctor__()
  : vars_count__(count_vars()) {}
  template <typename T0__, typename RNG>
  stan::promote_args_t<typename T0__::captured_scalar_t__>
  operator()(RNG& base_rng__, std::ostream* pstream__, const T0__& bar_lpdf)  const 
  {
  return foo_rng_L21C9_impl__(bar_lpdf, base_rng__, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = foo_rng_L21C9_cfunctor__;
  using CopyOf__ = foo_rng_L21C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  
  
  };
auto foo_rng_L21C9_make__() {
return foo_rng_L21C9_cfunctor__();
}

template <typename T0__, typename T1__, typename T2__>
void
hof_L17C9_impl__(const T0__& s_rng, const T1__& s_lpdf, const T2__& s_lp,
                 std::ostream* pstream__)  ;

class hof_L17C9_cfunctor__ {
  
  public:
  const size_t vars_count__;
  hof_L17C9_cfunctor__(const hof_L17C9_cfunctor__&) = default ;
  hof_L17C9_cfunctor__(hof_L17C9_cfunctor__&&) = default ;
  hof_L17C9_cfunctor__()
  : vars_count__(count_vars()) {}
  template <typename T0__, typename T1__, typename T2__>
  void
  operator()(std::ostream* pstream__, const T0__& s_rng, const T1__& s_lpdf,
             const T2__& s_lp)  const 
  {
  return hof_L17C9_impl__(s_rng, s_lpdf, s_lp, pstream__);
  }
  
  using captured_scalar_t__ = double;
  using ValueOf__ = hof_L17C9_cfunctor__;
  using CopyOf__ = hof_L17C9_cfunctor__;
  size_t count_vars__() const {
  return vars_count__;
  }
  auto value_of__() const {
  return ValueOf__();
  }
  auto deep_copy_vars__() const {
  return CopyOf__();
  }
  void zero_adjoints__() {
  
  }
  double* accumulate_adjoints__(double *dest) const {
  return stan::math::accumulate_adjoints(dest);
  }
  stan::math::vari** save_varis__(stan::math::vari **dest) const {
  return stan::math::save_varis(dest);
  }
  
  
  };
auto hof_L17C9_make__() {
return hof_L17C9_cfunctor__();
}

template <bool propto__, typename T0__>
stan::promote_args_t<T0__>
ff_lpdf(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    local_scalar_t__ s;
    s = DUMMY_VAR__;
    
    current_statement__ = 13;
    s = std_normal_lpdf<propto__>(0);
    current_statement__ = 14;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__, typename RNG>
stan::promote_args_t<T0__>
ff_rng(const T0__& x, RNG& base_rng__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    local_scalar_t__ s;
    s = DUMMY_VAR__;
    
    current_statement__ = 16;
    s = std_normal_rng(base_rng__);
    current_statement__ = 17;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
stan::promote_args_t<T0__>
ff_lp(const T0__& x, T_lp__& lp__, T_lp_accum__& lp_accum__,
      std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    local_scalar_t__ s;
    s = DUMMY_VAR__;
    
    current_statement__ = 19;
    s = get_lp(lp__, lp_accum__);
    current_statement__ = 20;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__>
stan::promote_args_t<T0__>
f2_L33C9_impl__(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 22;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <bool propto__, typename T0__>
stan::promote_args_t<T0__>
f3_lpdf_L37C9_impl__(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 24;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__, typename RNG>
stan::promote_args_t<T0__>
f4_rng_L41C9_impl__(const T0__& x, RNG& base_rng__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 26;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
stan::promote_args_t<T0__>
f5_lp_L45C9_impl__(const T0__& x, T_lp__& lp__, T_lp_accum__& lp_accum__,
                   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 28;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
stan::promote_args_t<typename T0__::captured_scalar_t__>
foo_lp_L29C9_impl__(const T0__& bar_lp, T_lp__& lp__,
                    T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<typename T0__::captured_scalar_t__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 30;
    return bar_lp.template operator()<propto__>(lp__, lp_accum__, pstream__, 
             1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
typename T1__::captured_scalar_t__>
foo_lpdf_L25C9_impl__(const T0__& zz, const T1__& bar_lpdf,
                      std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
          typename T1__::captured_scalar_t__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 32;
    return bar_lpdf.template operator()<propto__>(pstream__, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__, typename RNG>
stan::promote_args_t<typename T0__::captured_scalar_t__>
foo_rng_L21C9_impl__(const T0__& bar_lpdf, RNG& base_rng__,
                     std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<typename T0__::captured_scalar_t__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 34;
    return bar_lpdf.template operator()<false>(pstream__, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
template <typename T0__, typename T1__, typename T2__>
void
hof_L17C9_impl__(const T0__& s_rng, const T1__& s_lpdf, const T2__& s_lp,
                 std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<typename T0__::captured_scalar_t__,
          typename T1__::captured_scalar_t__,
          typename T2__::captured_scalar_t__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
class closures7_model final : public model_base_crtp<closures7_model> {

 private:
  double z; 
  
 
 public:
  ~closures7_model() { }
  
  inline std::string model_name() const final { return "closures7_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp"};
  }
  
  
  closures7_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "closures7_model_namespace::closures7_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      
      current_statement__ = 1;
      auto hof = hof_L17C9_make__();
      current_statement__ = 11;
      hof(pstream__, rng_from_lambda(ff_rng_functor__()),
        lpdf_from_lambda(ff_lpdf_functor__()),
        lp_from_lambda(ff_lp_functor__()));
      
      current_statement__ = 2;
      auto foo_rng = foo_rng_L21C9_make__();
      
      current_statement__ = 3;
      auto foo_lpdf = foo_lpdf_L25C9_make__();
      
      current_statement__ = 4;
      auto foo_lp = foo_lp_L29C9_make__();
      
      current_statement__ = 5;
      auto f2 = f2_L33C9_make__();
      
      current_statement__ = 6;
      auto f3_lpdf = f3_lpdf_L37C9_make__();
      
      current_statement__ = 7;
      auto f4_rng = f4_rng_L41C9_make__();
      
      current_statement__ = 8;
      auto f5_lp = f5_lp_L45C9_make__();
      current_statement__ = 12;
      z = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 12;
      z = foo_rng(base_rng__, pstream__, 
            f3_lpdf.template with_propto<false>());
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures7_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      
      current_statement__ = 1;
      auto hof = hof_L17C9_make__();
      
      current_statement__ = 2;
      auto foo_rng = foo_rng_L21C9_make__();
      
      current_statement__ = 3;
      auto foo_lpdf = foo_lpdf_L25C9_make__();
      
      current_statement__ = 4;
      auto foo_lp = foo_lp_L29C9_make__();
      
      current_statement__ = 5;
      auto f2 = f2_L33C9_make__();
      
      current_statement__ = 6;
      auto f3_lpdf = f3_lpdf_L37C9_make__();
      
      current_statement__ = 7;
      auto f4_rng = f4_rng_L41C9_make__();
      
      current_statement__ = 8;
      auto f5_lp = f5_lp_L45C9_make__();
      local_scalar_t__ s;
      s = DUMMY_VAR__;
      
      current_statement__ = 9;
      s = foo_lp.template operator()<propto__>(lp__, lp_accum__, pstream__, 
            f5_lp);
      {
        current_statement__ = 10;
        lp_accum__.add(
          foo_lpdf.template operator()<propto__>(pstream__, 1,
            f3_lpdf.template with_propto<propto__>()));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "closures7_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      
      current_statement__ = 1;
      auto hof = hof_L17C9_make__();
      
      current_statement__ = 2;
      auto foo_rng = foo_rng_L21C9_make__();
      
      current_statement__ = 3;
      auto foo_lpdf = foo_lpdf_L25C9_make__();
      
      current_statement__ = 4;
      auto foo_lp = foo_lp_L29C9_make__();
      
      current_statement__ = 5;
      auto f2 = f2_L33C9_make__();
      
      current_statement__ = 6;
      auto f3_lpdf = f3_lpdf_L37C9_make__();
      
      current_statement__ = 7;
      auto f4_rng = f4_rng_L41C9_make__();
      
      current_statement__ = 8;
      auto f5_lp = f5_lp_L45C9_make__();
      double s;
      s = std::numeric_limits<double>::quiet_NaN();
      
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 9;
      s = foo_lp.template operator()<propto__>(lp__, lp_accum__, pstream__, 
            f5_lp);
      if (emit_transformed_parameters__) {
        vars__.emplace_back(s);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    int current_statement__ = 0; 
    
    try {
      
      current_statement__ = 1;
      auto hof = hof_L17C9_make__();
      
      current_statement__ = 2;
      auto foo_rng = foo_rng_L21C9_make__();
      
      current_statement__ = 3;
      auto foo_lpdf = foo_lpdf_L25C9_make__();
      
      current_statement__ = 4;
      auto foo_lp = foo_lp_L29C9_make__();
      
      current_statement__ = 5;
      auto f2 = f2_L33C9_make__();
      
      current_statement__ = 6;
      auto f3_lpdf = f3_lpdf_L37C9_make__();
      
      current_statement__ = 7;
      auto f4_rng = f4_rng_L41C9_make__();
      
      current_statement__ = 8;
      auto f5_lp = f5_lp_L45C9_make__();
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"s"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "s");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "s");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"s\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"s\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec;
      vars_vec.reserve(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars,
       emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec;
      params_r_vec.reserve(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }

};
}
using stan_model = closures7_model_namespace::closures7_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return closures7_model_namespace::profiles__;
}

#endif



