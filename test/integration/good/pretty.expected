  $ ../../../../install/default/bin/stanc --auto-format abs-deprecate.stan
transformed data {
  real mu;
  mu = abs(-1.2);
}
parameters {
  real y;
}
model {
  y ~ normal(mu, 1);
}

Warning in 'abs-deprecate.stan', line 3, column 7: Use of the `abs` function with real-valued arguments is deprecated; use functions `fabs` instead.
  $ ../../../../install/default/bin/stanc --auto-format algebra_solver_good.stan
functions {
  real algebra_solverfake(real x) {
    return 2 * x;
  }
  vector algebra_system(vector x, vector y, array[] real dat,
                        array[] int dat_int) {
    vector[2] f_x;
    f_x[1] = x[1] - y[1];
    f_x[2] = x[2] - y[2];
    return f_x;
  }
}
data {

}
transformed data {
  vector[2] x;
  vector[2] y;
  array[0] real dat;
  array[0] int dat_int;
  vector[2] theta;
  theta = algebra_solver(algebra_system, x, y, dat, dat_int);
  theta = algebra_solver(algebra_system, x, y, dat, dat_int, 0.01, 0.01, 10);
}
parameters {
  vector[2] x_p;
  vector[2] y_p;
  real dummy_parameter;
}
transformed parameters {
  real abc_tp = algebra_solverfake(2.9);
  vector[2] theta_p;
  theta_p = algebra_solver(algebra_system, x, y, dat, dat_int);
  theta_p = algebra_solver(algebra_system, x, y, dat, dat_int, 0.01, 0.01,
                           10);
  theta_p = algebra_solver(algebra_system, x, y_p, dat, dat_int);
  theta_p = algebra_solver(algebra_system, x, y_p, dat, dat_int, 0.01, 0.01,
                           10);
  theta_p = algebra_solver(algebra_system, x_p, y, dat, dat_int);
  theta_p = algebra_solver(algebra_system, x_p, y, dat, dat_int, 0.01, 0.01,
                           10);
  theta_p = algebra_solver(algebra_system, x_p, y_p, dat, dat_int);
  theta_p = algebra_solver(algebra_system, x_p, y_p, dat, dat_int, 0.01,
                           0.01, 10);
}
model {
  dummy_parameter ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format algebra_solver_newton_good.stan
functions {
  real algebra_solverfake(real x) {
    return 2 * x;
  }
  vector algebra_system(vector x, vector y, array[] real dat,
                        array[] int dat_int) {
    vector[2] f_x;
    f_x[1] = x[1] - y[1];
    f_x[2] = x[2] - y[2];
    return f_x;
  }
}
data {

}
transformed data {
  vector[2] x;
  vector[2] y;
  array[0] real dat;
  array[0] int dat_int;
  vector[2] theta;
  theta = algebra_solver_newton(algebra_system, x, y, dat, dat_int);
  theta = algebra_solver_newton(algebra_system, x, y, dat, dat_int, 0.01,
                                0.01, 10);
}
parameters {
  vector[2] x_p;
  vector[2] y_p;
  real dummy_parameter;
}
transformed parameters {
  real abc_tp = algebra_solverfake(2.9);
  vector[2] theta_p;
  theta_p = algebra_solver_newton(algebra_system, x, y, dat, dat_int);
  theta_p = algebra_solver_newton(algebra_system, x, y, dat, dat_int, 0.01,
                                  0.01, 10);
  theta_p = algebra_solver_newton(algebra_system, x, y_p, dat, dat_int);
  theta_p = algebra_solver_newton(algebra_system, x, y_p, dat, dat_int, 0.01,
                                  0.01, 10);
  theta_p = algebra_solver_newton(algebra_system, x_p, y, dat, dat_int);
  theta_p = algebra_solver_newton(algebra_system, x_p, y, dat, dat_int, 0.01,
                                  0.01, 10);
  theta_p = algebra_solver_newton(algebra_system, x_p, y_p, dat, dat_int);
  theta_p = algebra_solver_newton(algebra_system, x_p, y_p, dat, dat_int,
                                  0.01, 0.01, 10);
}
model {
  dummy_parameter ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format assignment-deprecated.stan
transformed data {
  real mu;
  real<lower=0> sigma;
  mu <- -1;
  sigma <- 3;
}
parameters {
  real y;
}
model {
  y ~ normal(mu, sigma);
}

Warning in 'assignment-deprecated.stan', line 4, column 5: assignment operator <- is deprecated in the Stan language; use = instead.
Warning in 'assignment-deprecated.stan', line 5, column 8: assignment operator <- is deprecated in the Stan language; use = instead.
  $ ../../../../install/default/bin/stanc --auto-format assignment-new.stan
transformed data {
  real mu;
  real<lower=0> sigma;
  mu = -1;
  sigma = 3;
}
parameters {
  real y;
}
model {
  y ~ normal(mu, sigma);
}

  $ ../../../../install/default/bin/stanc --auto-format assignment_double_index_lhs.stan
transformed data {
  array[109, 307] real a;
  array[17] vector[5] b;
  array[17] row_vector[5] c;
  matrix[15, 27] d;
  array[12, 12, 12] real aa;
  array[12, 12] vector[5] bb;
  array[12, 12] row_vector[5] cc;
  array[12] matrix[5, 12] dd;
  a[1][1] = 118.22;
  b[1][1] = 13;
  c[1][1] = 0;
  d[1][1] = 12;
  aa[1][1][1] = 118.22;
  bb[1][1][1] = 13;
  cc[1][1][1] = 0;
  dd[1][1][1] = 12;
}
parameters {
  real y;
}
transformed parameters {
  array[109, 307] real ap;
  array[17] vector[5] bp;
  array[17] row_vector[5] cp;
  matrix[15, 27] dp;
  array[12, 12, 12] real aap;
  array[12, 12] vector[5] bbp;
  array[12, 12] row_vector[5] ccp;
  array[12] matrix[5, 12] ddp;
  ap[1][1] = 118.22;
  bp[1][1] = 13;
  cp[1][1] = 0;
  dp[1][1] = 12;
  aap[1][1][1] = 118.22;
  bbp[1][1][1] = 13;
  ccp[1][1][1] = 0;
  ddp[1][1][1] = 12;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format assignments.stan
data {
  real x;
  vector[5] y;
  row_vector[6] z;
  matrix[5, 6] m;
  array[2] real x1;
  array[2] vector[5] y1;
  array[2] row_vector[6] z1;
  array[2] matrix[5, 6] m1;
  array[2, 3] real x2;
  array[2, 3] vector[5] y2;
  array[2, 3] row_vector[6] z2;
  array[2, 3] matrix[5, 6] m2;
  array[2, 3, 4] real x3;
  array[2, 3, 4] vector[5] y3;
  array[2, 3, 4] row_vector[6] z3;
  array[2, 3, 4] matrix[5, 6] m3;
}
transformed data {
  real tx;
  vector[5] ty;
  row_vector[6] tz;
  matrix[5, 6] tm;
  array[2] real tx1;
  array[2] vector[5] ty1;
  array[2] row_vector[6] tz1;
  array[2] matrix[5, 6] tm1;
  array[2, 3] real tx2;
  array[2, 3] vector[5] ty2;
  array[2, 3] row_vector[6] tz2;
  array[2, 3] matrix[5, 6] tm2;
  array[2, 3, 4] real tx3;
  array[2, 3, 4] vector[5] ty3;
  array[2, 3, 4] row_vector[6] tz3;
  array[2, 3, 4] matrix[5, 6] tm3;
  tx = x;
  tx = y[1];
  tx = z[1];
  tx = m[1, 2];
  tx = x1[1];
  tx = y1[1, 1];
  tx = z1[1, 1];
  tx = m1[1, 1, 2];
  tx = x2[1, 1];
  tx = y2[1, 1, 1];
  tx = z2[1, 1, 1];
  tx = m2[1, 1, 1, 2];
  tx = x3[1, 1, 1];
  tx = y3[1, 1, 1, 1];
  tx = z3[1, 1, 1, 1];
  tx = m3[1, 1, 1, 1, 2];
  tx1[1] = x;
  tx1[1] = y[1];
  tx1[1] = z[1];
  tx1[1] = m[1, 2];
  tx1[1] = x1[1];
  tx1[1] = y1[1, 1];
  tx1[1] = z1[1, 1];
  tx1[1] = m1[1, 1, 2];
  tx1[1] = x2[1, 1];
  tx1[1] = y2[1, 1, 1];
  tx1[1] = z2[1, 1, 1];
  tx1[1] = m2[1, 1, 1, 2];
  tx1[1] = x3[1, 1, 1];
  tx1[1] = y3[1, 1, 1, 1];
  tx1[1] = z3[1, 1, 1, 1];
  tx1[1] = m3[1, 1, 1, 1, 2];
  tx2[1, 1] = x;
  tx2[1, 1] = y[1];
  tx2[1, 1] = z[1];
  tx2[1, 1] = m[1, 2];
  tx2[1, 1] = x1[1];
  tx2[1, 1] = y1[1, 1];
  tx2[1, 1] = z1[1, 1];
  tx2[1, 1] = m1[1, 1, 2];
  tx2[1, 1] = x2[1, 1];
  tx2[1, 1] = y2[1, 1, 1];
  tx2[1, 1] = z2[1, 1, 1];
  tx2[1, 1] = m2[1, 1, 1, 2];
  tx2[1, 1] = x3[1, 1, 1];
  tx2[1, 1] = y3[1, 1, 1, 1];
  tx2[1, 1] = z3[1, 1, 1, 1];
  tx2[1, 1] = m3[1, 1, 1, 1, 2];
  tx3[1, 1, 1] = x;
  tx3[1, 1, 1] = y[1];
  tx3[1, 1, 1] = z[1];
  tx3[1, 1, 1] = m[1, 2];
  tx3[1, 1, 1] = x1[1];
  tx3[1, 1, 1] = y1[1, 1];
  tx3[1, 1, 1] = z1[1, 1];
  tx3[1, 1, 1] = m1[1, 1, 2];
  tx3[1, 1, 1] = x2[1, 1];
  tx3[1, 1, 1] = y2[1, 1, 1];
  tx3[1, 1, 1] = z2[1, 1, 1];
  tx3[1, 1, 1] = m2[1, 1, 1, 2];
  tx3[1, 1, 1] = x3[1, 1, 1];
  tx3[1, 1, 1] = y3[1, 1, 1, 1];
  tx3[1, 1, 1] = z3[1, 1, 1, 1];
  tx3[1, 1, 1] = m3[1, 1, 1, 1, 2];
  ty = y;
  ty = y1[1];
  ty = y2[1, 1];
  ty = y3[1, 1, 1];
  ty = col(m, 1);
  ty = col(m1[1], 1);
  ty = col(m2[1, 1], 1);
  ty = col(m3[1, 1, 1], 1);
  ty1[1] = y;
  ty1[1] = y1[1];
  ty1[1] = y2[1, 1];
  ty1[1] = y3[1, 1, 1];
  ty1[1] = col(m, 1);
  ty1[1] = col(m1[1], 1);
  ty1[1] = col(m2[1, 1], 1);
  ty1[1] = col(m3[1, 1, 1], 1);
  ty2[1, 1] = y;
  ty2[1, 1] = y1[1];
  ty2[1, 1] = y2[1, 1];
  ty2[1, 1] = y3[1, 1, 1];
  ty2[1, 1] = col(m, 1);
  ty2[1, 1] = col(m1[1], 1);
  ty2[1, 1] = col(m2[1, 1], 1);
  ty2[1, 1] = col(m3[1, 1, 1], 1);
  ty3[1, 1, 1] = y;
  ty3[1, 1, 1] = y1[1];
  ty3[1, 1, 1] = y2[1, 1];
  ty3[1, 1, 1] = y3[1, 1, 1];
  ty3[1, 1, 1] = col(m, 1);
  ty3[1, 1, 1] = col(m1[1], 1);
  ty3[1, 1, 1] = col(m2[1, 1], 1);
  ty3[1, 1, 1] = col(m3[1, 1, 1], 1);
  tz = z;
  tz = z1[1];
  tz = z2[1, 1];
  tz = z3[1, 1, 1];
  tz = row(m, 1);
  tz = row(m1[1], 1);
  tz = row(m2[1, 1], 1);
  tz = row(m3[1, 1, 1], 1);
  tz = m[1];
  tz = m1[1, 1];
  tz = m2[1, 1, 1];
  tz = m3[1, 1, 1, 1];
  tz1[1] = z;
  tz1[1] = z1[1];
  tz1[1] = z2[1, 1];
  tz1[1] = z3[1, 1, 1];
  tz1[1] = row(m, 1);
  tz1[1] = row(m1[1], 1);
  tz1[1] = row(m2[1, 1], 1);
  tz1[1] = row(m3[1, 1, 1], 1);
  tz1[1] = m[1];
  tz1[1] = m1[1, 1];
  tz1[1] = m2[1, 1, 1];
  tz1[1] = m3[1, 1, 1, 1];
  tz2[1, 1] = z;
  tz2[1, 1] = z1[1];
  tz2[1, 1] = z2[1, 1];
  tz2[1, 1] = z3[1, 1, 1];
  tz2[1, 1] = row(m, 1);
  tz2[1, 1] = row(m1[1], 1);
  tz2[1, 1] = row(m2[1, 1], 1);
  tz2[1, 1] = row(m3[1, 1, 1], 1);
  tz2[1, 1] = m[1];
  tz2[1, 1] = m1[1, 1];
  tz2[1, 1] = m2[1, 1, 1];
  tz2[1, 1] = m3[1, 1, 1, 1];
  tz3[1, 1, 1] = z;
  tz3[1, 1, 1] = z1[1];
  tz3[1, 1, 1] = z2[1, 1];
  tz3[1, 1, 1] = z3[1, 1, 1];
  tz3[1, 1, 1] = row(m, 1);
  tz3[1, 1, 1] = row(m1[1], 1);
  tz3[1, 1, 1] = row(m2[1, 1], 1);
  tz3[1, 1, 1] = row(m3[1, 1, 1], 1);
  tz3[1, 1, 1] = m[1];
  tz3[1, 1, 1] = m1[1, 1];
  tz3[1, 1, 1] = m2[1, 1, 1];
  tz3[1, 1, 1] = m3[1, 1, 1, 1];
  tm = m;
  tm = m1[1];
  tm = m2[1, 1];
  tm = m3[1, 1, 1];
  tm1[1] = m;
  tm1[1] = m1[1];
  tm1[1] = m2[1, 1];
  tm1[1] = m3[1, 1, 1];
  tm2[1, 1] = m;
  tm2[1, 1] = m1[1];
  tm2[1, 1] = m2[1, 1];
  tm2[1, 1] = m3[1, 1, 1];
  tm3[1, 1, 1] = m;
  tm3[1, 1, 1] = m1[1];
  tm3[1, 1, 1] = m2[1, 1];
  tm3[1, 1, 1] = m3[1, 1, 1];
  tx1 = x1;
  tx1 = x2[1];
  tx1 = x3[1, 1];
  tx2[1] = x1;
  tx2[1] = x2[1];
  tx2[1] = x3[1, 1];
  tx3[1, 1] = x1;
  tx3[1, 1] = x2[1];
  tx3[1, 1] = x3[1, 1];
  ty1 = y1;
  ty1 = y2[1];
  ty1 = y3[1, 1];
  ty2[1] = y1;
  ty2[1] = y2[1];
  ty2[1] = y3[1, 1];
  ty3[1, 1] = y1;
  ty3[1, 1] = y2[1];
  ty3[1, 1] = y3[1, 1];
  tz1 = z1;
  tz1 = z2[1];
  tz1 = z3[1, 1];
  tz2[1] = z1;
  tz2[1] = z2[1];
  tz2[1] = z3[1, 1];
  tz3[1, 1] = z1;
  tz3[1, 1] = z2[1];
  tz3[1, 1] = z3[1, 1];
  tm1 = m1;
  tm1 = m2[1];
  tm1 = m3[1, 1];
  tm2[1] = m1;
  tm2[1] = m2[1];
  tm2[1] = m3[1, 1];
  tm3[1, 1] = m1;
  tm3[1, 1] = m2[1];
  tm3[1, 1] = m3[1, 1];
  tx2 = x2;
  tx2 = x3[1];
  tx3[1] = x2;
  tx3[1] = x3[1];
  ty2 = y2;
  ty2 = y3[1];
  ty3[1] = y2;
  ty3[1] = y3[1];
  tz2 = z2;
  tz2 = z3[1];
  tz3[1] = z2;
  tz3[1] = z3[1];
  tm2 = m2;
  tm2 = m3[1];
  tm3[1] = m2;
  tm3[1] = m3[1];
  tx3 = x3;
  ty3 = y3;
  tz3 = z3;
  tm3 = m3;
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format assignments_double_var.stan
data {
  real x;
  vector[5] y;
  row_vector[6] z;
  matrix[5, 6] m;
  array[2] real x1;
  array[2] vector[5] y1;
  array[2] row_vector[6] z1;
  array[2] matrix[5, 6] m1;
  array[2, 3] real x2;
  array[2, 3] vector[5] y2;
  array[2, 3] row_vector[6] z2;
  array[2, 3] matrix[5, 6] m2;
  array[2, 3, 4] real x3;
  array[2, 3, 4] vector[5] y3;
  array[2, 3, 4] row_vector[6] z3;
  array[2, 3, 4] matrix[5, 6] m3;
}
transformed parameters {
  real tx;
  vector[5] ty;
  row_vector[6] tz;
  matrix[5, 6] tm;
  array[2] real tx1;
  array[2] vector[5] ty1;
  array[2] row_vector[6] tz1;
  array[2] matrix[5, 6] tm1;
  array[2, 3] real tx2;
  array[2, 3] vector[5] ty2;
  array[2, 3] row_vector[6] tz2;
  array[2, 3] matrix[5, 6] tm2;
  array[2, 3, 4] real tx3;
  array[2, 3, 4] vector[5] ty3;
  array[2, 3, 4] row_vector[6] tz3;
  array[2, 3, 4] matrix[5, 6] tm3;
  tx = x;
  tx = y[1];
  tx = z[1];
  tx = m[1, 2];
  tx = x1[1];
  tx = y1[1, 1];
  tx = z1[1, 1];
  tx = m1[1, 1, 2];
  tx = x2[1, 1];
  tx = y2[1, 1, 1];
  tx = z2[1, 1, 1];
  tx = m2[1, 1, 1, 2];
  tx = x3[1, 1, 1];
  tx = y3[1, 1, 1, 1];
  tx = z3[1, 1, 1, 1];
  tx = m3[1, 1, 1, 1, 2];
  tx1[1] = x;
  tx1[1] = y[1];
  tx1[1] = z[1];
  tx1[1] = m[1, 2];
  tx1[1] = x1[1];
  tx1[1] = y1[1, 1];
  tx1[1] = z1[1, 1];
  tx1[1] = m1[1, 1, 2];
  tx1[1] = x2[1, 1];
  tx1[1] = y2[1, 1, 1];
  tx1[1] = z2[1, 1, 1];
  tx1[1] = m2[1, 1, 1, 2];
  tx1[1] = x3[1, 1, 1];
  tx1[1] = y3[1, 1, 1, 1];
  tx1[1] = z3[1, 1, 1, 1];
  tx1[1] = m3[1, 1, 1, 1, 2];
  tx2[1, 1] = x;
  tx2[1, 1] = y[1];
  tx2[1, 1] = z[1];
  tx2[1, 1] = m[1, 2];
  tx2[1, 1] = x1[1];
  tx2[1, 1] = y1[1, 1];
  tx2[1, 1] = z1[1, 1];
  tx2[1, 1] = m1[1, 1, 2];
  tx2[1, 1] = x2[1, 1];
  tx2[1, 1] = y2[1, 1, 1];
  tx2[1, 1] = z2[1, 1, 1];
  tx2[1, 1] = m2[1, 1, 1, 2];
  tx2[1, 1] = x3[1, 1, 1];
  tx2[1, 1] = y3[1, 1, 1, 1];
  tx2[1, 1] = z3[1, 1, 1, 1];
  tx2[1, 1] = m3[1, 1, 1, 1, 2];
  tx3[1, 1, 1] = x;
  tx3[1, 1, 1] = y[1];
  tx3[1, 1, 1] = z[1];
  tx3[1, 1, 1] = m[1, 2];
  tx3[1, 1, 1] = x1[1];
  tx3[1, 1, 1] = y1[1, 1];
  tx3[1, 1, 1] = z1[1, 1];
  tx3[1, 1, 1] = m1[1, 1, 2];
  tx3[1, 1, 1] = x2[1, 1];
  tx3[1, 1, 1] = y2[1, 1, 1];
  tx3[1, 1, 1] = z2[1, 1, 1];
  tx3[1, 1, 1] = m2[1, 1, 1, 2];
  tx3[1, 1, 1] = x3[1, 1, 1];
  tx3[1, 1, 1] = y3[1, 1, 1, 1];
  tx3[1, 1, 1] = z3[1, 1, 1, 1];
  tx3[1, 1, 1] = m3[1, 1, 1, 1, 2];
  ty = y;
  ty = y1[1];
  ty = y2[1, 1];
  ty = y3[1, 1, 1];
  ty = col(m, 1);
  ty = col(m1[1], 1);
  ty = col(m2[1, 1], 1);
  ty = col(m3[1, 1, 1], 1);
  ty1[1] = y;
  ty1[1] = y1[1];
  ty1[1] = y2[1, 1];
  ty1[1] = y3[1, 1, 1];
  ty1[1] = col(m, 1);
  ty1[1] = col(m1[1], 1);
  ty1[1] = col(m2[1, 1], 1);
  ty1[1] = col(m3[1, 1, 1], 1);
  ty2[1, 1] = y;
  ty2[1, 1] = y1[1];
  ty2[1, 1] = y2[1, 1];
  ty2[1, 1] = y3[1, 1, 1];
  ty2[1, 1] = col(m, 1);
  ty2[1, 1] = col(m1[1], 1);
  ty2[1, 1] = col(m2[1, 1], 1);
  ty2[1, 1] = col(m3[1, 1, 1], 1);
  ty3[1, 1, 1] = y;
  ty3[1, 1, 1] = y1[1];
  ty3[1, 1, 1] = y2[1, 1];
  ty3[1, 1, 1] = y3[1, 1, 1];
  ty3[1, 1, 1] = col(m, 1);
  ty3[1, 1, 1] = col(m1[1], 1);
  ty3[1, 1, 1] = col(m2[1, 1], 1);
  ty3[1, 1, 1] = col(m3[1, 1, 1], 1);
  tz = z;
  tz = z1[1];
  tz = z2[1, 1];
  tz = z3[1, 1, 1];
  tz = row(m, 1);
  tz = row(m1[1], 1);
  tz = row(m2[1, 1], 1);
  tz = row(m3[1, 1, 1], 1);
  tz = m[1];
  tz = m1[1, 1];
  tz = m2[1, 1, 1];
  tz = m3[1, 1, 1, 1];
  tz1[1] = z;
  tz1[1] = z1[1];
  tz1[1] = z2[1, 1];
  tz1[1] = z3[1, 1, 1];
  tz1[1] = row(m, 1);
  tz1[1] = row(m1[1], 1);
  tz1[1] = row(m2[1, 1], 1);
  tz1[1] = row(m3[1, 1, 1], 1);
  tz1[1] = m[1];
  tz1[1] = m1[1, 1];
  tz1[1] = m2[1, 1, 1];
  tz1[1] = m3[1, 1, 1, 1];
  tz2[1, 1] = z;
  tz2[1, 1] = z1[1];
  tz2[1, 1] = z2[1, 1];
  tz2[1, 1] = z3[1, 1, 1];
  tz2[1, 1] = row(m, 1);
  tz2[1, 1] = row(m1[1], 1);
  tz2[1, 1] = row(m2[1, 1], 1);
  tz2[1, 1] = row(m3[1, 1, 1], 1);
  tz2[1, 1] = m[1];
  tz2[1, 1] = m1[1, 1];
  tz2[1, 1] = m2[1, 1, 1];
  tz2[1, 1] = m3[1, 1, 1, 1];
  tz3[1, 1, 1] = z;
  tz3[1, 1, 1] = z1[1];
  tz3[1, 1, 1] = z2[1, 1];
  tz3[1, 1, 1] = z3[1, 1, 1];
  tz3[1, 1, 1] = row(m, 1);
  tz3[1, 1, 1] = row(m1[1], 1);
  tz3[1, 1, 1] = row(m2[1, 1], 1);
  tz3[1, 1, 1] = row(m3[1, 1, 1], 1);
  tz3[1, 1, 1] = m[1];
  tz3[1, 1, 1] = m1[1, 1];
  tz3[1, 1, 1] = m2[1, 1, 1];
  tz3[1, 1, 1] = m3[1, 1, 1, 1];
  tm = m;
  tm = m1[1];
  tm = m2[1, 1];
  tm = m3[1, 1, 1];
  tm1[1] = m;
  tm1[1] = m1[1];
  tm1[1] = m2[1, 1];
  tm1[1] = m3[1, 1, 1];
  tm2[1, 1] = m;
  tm2[1, 1] = m1[1];
  tm2[1, 1] = m2[1, 1];
  tm2[1, 1] = m3[1, 1, 1];
  tm3[1, 1, 1] = m;
  tm3[1, 1, 1] = m1[1];
  tm3[1, 1, 1] = m2[1, 1];
  tm3[1, 1, 1] = m3[1, 1, 1];
  tx1 = x1;
  tx1 = x2[1];
  tx1 = x3[1, 1];
  tx2[1] = x1;
  tx2[1] = x2[1];
  tx2[1] = x3[1, 1];
  tx3[1, 1] = x1;
  tx3[1, 1] = x2[1];
  tx3[1, 1] = x3[1, 1];
  ty1 = y1;
  ty1 = y2[1];
  ty1 = y3[1, 1];
  ty2[1] = y1;
  ty2[1] = y2[1];
  ty2[1] = y3[1, 1];
  ty3[1, 1] = y1;
  ty3[1, 1] = y2[1];
  ty3[1, 1] = y3[1, 1];
  tz1 = z1;
  tz1 = z2[1];
  tz1 = z3[1, 1];
  tz2[1] = z1;
  tz2[1] = z2[1];
  tz2[1] = z3[1, 1];
  tz3[1, 1] = z1;
  tz3[1, 1] = z2[1];
  tz3[1, 1] = z3[1, 1];
  tm1 = m1;
  tm1 = m2[1];
  tm1 = m3[1, 1];
  tm2[1] = m1;
  tm2[1] = m2[1];
  tm2[1] = m3[1, 1];
  tm3[1, 1] = m1;
  tm3[1, 1] = m2[1];
  tm3[1, 1] = m3[1, 1];
  tx2 = x2;
  tx2 = x3[1];
  tx3[1] = x2;
  tx3[1] = x3[1];
  ty2 = y2;
  ty2 = y3[1];
  ty3[1] = y2;
  ty3[1] = y3[1];
  tz2 = z2;
  tz2 = z3[1];
  tz3[1] = z2;
  tz3[1] = z3[1];
  tm2 = m2;
  tm2 = m3[1];
  tm3[1] = m2;
  tm3[1] = m3[1];
  tx3 = x3;
  ty3 = y3;
  tz3 = z3;
  tm3 = m3;
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format assignments_var.stan
parameters {
  real x;
  vector[5] y;
  row_vector[6] z;
  matrix[5, 6] m;
  array[2] real x1;
  array[2] vector[5] y1;
  array[2] row_vector[6] z1;
  array[2] matrix[5, 6] m1;
  array[2, 3] real x2;
  array[2, 3] vector[5] y2;
  array[2, 3] row_vector[6] z2;
  array[2, 3] matrix[5, 6] m2;
  array[2, 3, 4] real x3;
  array[2, 3, 4] vector[5] y3;
  array[2, 3, 4] row_vector[6] z3;
  array[2, 3, 4] matrix[5, 6] m3;
}
transformed parameters {
  real tx;
  vector[5] ty;
  row_vector[6] tz;
  matrix[5, 6] tm;
  array[2] real tx1;
  array[2] vector[5] ty1;
  array[2] row_vector[6] tz1;
  array[2] matrix[5, 6] tm1;
  array[2, 3] real tx2;
  array[2, 3] vector[5] ty2;
  array[2, 3] row_vector[6] tz2;
  array[2, 3] matrix[5, 6] tm2;
  array[2, 3, 4] real tx3;
  array[2, 3, 4] vector[5] ty3;
  array[2, 3, 4] row_vector[6] tz3;
  array[2, 3, 4] matrix[5, 6] tm3;
  tx = x;
  tx = y[1];
  tx = z[1];
  tx = m[1, 2];
  tx = x1[1];
  tx = y1[1, 1];
  tx = z1[1, 1];
  tx = m1[1, 1, 2];
  tx = x2[1, 1];
  tx = y2[1, 1, 1];
  tx = z2[1, 1, 1];
  tx = m2[1, 1, 1, 2];
  tx = x3[1, 1, 1];
  tx = y3[1, 1, 1, 1];
  tx = z3[1, 1, 1, 1];
  tx = m3[1, 1, 1, 1, 2];
  tx1[1] = x;
  tx1[1] = y[1];
  tx1[1] = z[1];
  tx1[1] = m[1, 2];
  tx1[1] = x1[1];
  tx1[1] = y1[1, 1];
  tx1[1] = z1[1, 1];
  tx1[1] = m1[1, 1, 2];
  tx1[1] = x2[1, 1];
  tx1[1] = y2[1, 1, 1];
  tx1[1] = z2[1, 1, 1];
  tx1[1] = m2[1, 1, 1, 2];
  tx1[1] = x3[1, 1, 1];
  tx1[1] = y3[1, 1, 1, 1];
  tx1[1] = z3[1, 1, 1, 1];
  tx1[1] = m3[1, 1, 1, 1, 2];
  tx2[1, 1] = x;
  tx2[1, 1] = y[1];
  tx2[1, 1] = z[1];
  tx2[1, 1] = m[1, 2];
  tx2[1, 1] = x1[1];
  tx2[1, 1] = y1[1, 1];
  tx2[1, 1] = z1[1, 1];
  tx2[1, 1] = m1[1, 1, 2];
  tx2[1, 1] = x2[1, 1];
  tx2[1, 1] = y2[1, 1, 1];
  tx2[1, 1] = z2[1, 1, 1];
  tx2[1, 1] = m2[1, 1, 1, 2];
  tx2[1, 1] = x3[1, 1, 1];
  tx2[1, 1] = y3[1, 1, 1, 1];
  tx2[1, 1] = z3[1, 1, 1, 1];
  tx2[1, 1] = m3[1, 1, 1, 1, 2];
  tx3[1, 1, 1] = x;
  tx3[1, 1, 1] = y[1];
  tx3[1, 1, 1] = z[1];
  tx3[1, 1, 1] = m[1, 2];
  tx3[1, 1, 1] = x1[1];
  tx3[1, 1, 1] = y1[1, 1];
  tx3[1, 1, 1] = z1[1, 1];
  tx3[1, 1, 1] = m1[1, 1, 2];
  tx3[1, 1, 1] = x2[1, 1];
  tx3[1, 1, 1] = y2[1, 1, 1];
  tx3[1, 1, 1] = z2[1, 1, 1];
  tx3[1, 1, 1] = m2[1, 1, 1, 2];
  tx3[1, 1, 1] = x3[1, 1, 1];
  tx3[1, 1, 1] = y3[1, 1, 1, 1];
  tx3[1, 1, 1] = z3[1, 1, 1, 1];
  tx3[1, 1, 1] = m3[1, 1, 1, 1, 2];
  ty = y;
  ty = y1[1];
  ty = y2[1, 1];
  ty = y3[1, 1, 1];
  ty = col(m, 1);
  ty = col(m1[1], 1);
  ty = col(m2[1, 1], 1);
  ty = col(m3[1, 1, 1], 1);
  ty1[1] = y;
  ty1[1] = y1[1];
  ty1[1] = y2[1, 1];
  ty1[1] = y3[1, 1, 1];
  ty1[1] = col(m, 1);
  ty1[1] = col(m1[1], 1);
  ty1[1] = col(m2[1, 1], 1);
  ty1[1] = col(m3[1, 1, 1], 1);
  ty2[1, 1] = y;
  ty2[1, 1] = y1[1];
  ty2[1, 1] = y2[1, 1];
  ty2[1, 1] = y3[1, 1, 1];
  ty2[1, 1] = col(m, 1);
  ty2[1, 1] = col(m1[1], 1);
  ty2[1, 1] = col(m2[1, 1], 1);
  ty2[1, 1] = col(m3[1, 1, 1], 1);
  ty3[1, 1, 1] = y;
  ty3[1, 1, 1] = y1[1];
  ty3[1, 1, 1] = y2[1, 1];
  ty3[1, 1, 1] = y3[1, 1, 1];
  ty3[1, 1, 1] = col(m, 1);
  ty3[1, 1, 1] = col(m1[1], 1);
  ty3[1, 1, 1] = col(m2[1, 1], 1);
  ty3[1, 1, 1] = col(m3[1, 1, 1], 1);
  tz = z;
  tz = z1[1];
  tz = z2[1, 1];
  tz = z3[1, 1, 1];
  tz = row(m, 1);
  tz = row(m1[1], 1);
  tz = row(m2[1, 1], 1);
  tz = row(m3[1, 1, 1], 1);
  tz = m[1];
  tz = m1[1, 1];
  tz = m2[1, 1, 1];
  tz = m3[1, 1, 1, 1];
  tz1[1] = z;
  tz1[1] = z1[1];
  tz1[1] = z2[1, 1];
  tz1[1] = z3[1, 1, 1];
  tz1[1] = row(m, 1);
  tz1[1] = row(m1[1], 1);
  tz1[1] = row(m2[1, 1], 1);
  tz1[1] = row(m3[1, 1, 1], 1);
  tz1[1] = m[1];
  tz1[1] = m1[1, 1];
  tz1[1] = m2[1, 1, 1];
  tz1[1] = m3[1, 1, 1, 1];
  tz2[1, 1] = z;
  tz2[1, 1] = z1[1];
  tz2[1, 1] = z2[1, 1];
  tz2[1, 1] = z3[1, 1, 1];
  tz2[1, 1] = row(m, 1);
  tz2[1, 1] = row(m1[1], 1);
  tz2[1, 1] = row(m2[1, 1], 1);
  tz2[1, 1] = row(m3[1, 1, 1], 1);
  tz2[1, 1] = m[1];
  tz2[1, 1] = m1[1, 1];
  tz2[1, 1] = m2[1, 1, 1];
  tz2[1, 1] = m3[1, 1, 1, 1];
  tz3[1, 1, 1] = z;
  tz3[1, 1, 1] = z1[1];
  tz3[1, 1, 1] = z2[1, 1];
  tz3[1, 1, 1] = z3[1, 1, 1];
  tz3[1, 1, 1] = row(m, 1);
  tz3[1, 1, 1] = row(m1[1], 1);
  tz3[1, 1, 1] = row(m2[1, 1], 1);
  tz3[1, 1, 1] = row(m3[1, 1, 1], 1);
  tz3[1, 1, 1] = m[1];
  tz3[1, 1, 1] = m1[1, 1];
  tz3[1, 1, 1] = m2[1, 1, 1];
  tz3[1, 1, 1] = m3[1, 1, 1, 1];
  tm = m;
  tm = m1[1];
  tm = m2[1, 1];
  tm = m3[1, 1, 1];
  tm1[1] = m;
  tm1[1] = m1[1];
  tm1[1] = m2[1, 1];
  tm1[1] = m3[1, 1, 1];
  tm2[1, 1] = m;
  tm2[1, 1] = m1[1];
  tm2[1, 1] = m2[1, 1];
  tm2[1, 1] = m3[1, 1, 1];
  tm3[1, 1, 1] = m;
  tm3[1, 1, 1] = m1[1];
  tm3[1, 1, 1] = m2[1, 1];
  tm3[1, 1, 1] = m3[1, 1, 1];
  tx1 = x1;
  tx1 = x2[1];
  tx1 = x3[1, 1];
  tx2[1] = x1;
  tx2[1] = x2[1];
  tx2[1] = x3[1, 1];
  tx3[1, 1] = x1;
  tx3[1, 1] = x2[1];
  tx3[1, 1] = x3[1, 1];
  ty1 = y1;
  ty1 = y2[1];
  ty1 = y3[1, 1];
  ty2[1] = y1;
  ty2[1] = y2[1];
  ty2[1] = y3[1, 1];
  ty3[1, 1] = y1;
  ty3[1, 1] = y2[1];
  ty3[1, 1] = y3[1, 1];
  tz1 = z1;
  tz1 = z2[1];
  tz1 = z3[1, 1];
  tz2[1] = z1;
  tz2[1] = z2[1];
  tz2[1] = z3[1, 1];
  tz3[1, 1] = z1;
  tz3[1, 1] = z2[1];
  tz3[1, 1] = z3[1, 1];
  tm1 = m1;
  tm1 = m2[1];
  tm1 = m3[1, 1];
  tm2[1] = m1;
  tm2[1] = m2[1];
  tm2[1] = m3[1, 1];
  tm3[1, 1] = m1;
  tm3[1, 1] = m2[1];
  tm3[1, 1] = m3[1, 1];
  tx2 = x2;
  tx2 = x3[1];
  tx3[1] = x2;
  tx3[1] = x3[1];
  ty2 = y2;
  ty2 = y3[1];
  ty3[1] = y2;
  ty3[1] = y3[1];
  tz2 = z2;
  tz2 = z3[1];
  tz3[1] = z2;
  tz3[1] = z3[1];
  tm2 = m2;
  tm2 = m3[1];
  tm3[1] = m2;
  tm3[1] = m3[1];
  tx3 = x3;
  ty3 = y3;
  tz3 = z3;
  tm3 = m3;
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format bernoulli_logit_glm_old_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  array[N] int<lower=0, upper=1> y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = bernoulli_logit_rng((x * beta_true + alpha_true)[i]);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  y ~ bernoulli_logit(x * beta_inferred + alpha_inferred);
}

Warning in 'bernoulli_logit_glm_old_performance.stan', line 10, column 19: Found int division:
  j / M
Values will be rounded towards zero. If rounding is not desired you can write
the division as
  j * 1.0 / M
If rounding is intended please use the integer division operator %/%.
  $ ../../../../install/default/bin/stanc --auto-format bernoulli_logit_glm_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  array[N] int<lower=0, upper=1> y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = bernoulli_logit_rng((x * beta_true + alpha_true)[i]);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  y ~ bernoulli_logit_glm(x, alpha_inferred, beta_inferred);
}

Warning in 'bernoulli_logit_glm_performance.stan', line 10, column 19: Found int division:
  j / M
Values will be rounded towards zero. If rounding is not desired you can write
the division as
  j * 1.0 / M
If rounding is intended please use the integer division operator %/%.
  $ ../../../../install/default/bin/stanc --auto-format break-continue.stan
functions {
  int foo(int a) {
    while (1) break;
    while (0) continue;
    for (i in 1 : 10) 
      break;
    for (i in 1 : 10) 
      continue;
    while (1) {
      int b;
      b = 5;
      break;
    }
    while (1) {
      if (0) 
        break;
      else if (1) 
        break;
      else 
        break;
    }
    while (1) while (0) break;
    while (1) {
      for (i in 1 : 10) 
        break;
    }
    while (1) {
      array[2, 3] int vs;
      int z;
      for (v in vs) {
        z = 0;
        break;
      }
      for (v in vs) {
        z = 0;
        continue;
      }
      for (v in vs) {
        for (vv in v) {
          z = 0;
          break;
        }
        z = 1;
      }
    }
    while (1) {
      real z;
      matrix[2, 3] vs;
      for (v in vs) {
        z = 0;
        break;
      }
      for (v in vs) {
        z = 3.2;
        continue;
      }
    }
    while (1) {
      real z;
      vector[2] vs;
      for (v in vs) {
        z = 0;
        break;
      }
      for (v in vs) {
        z = 3.2;
        continue;
      }
    }
    while (1) {
      real z;
      row_vector[2] vs;
      for (v in vs) {
        z = 0;
        break;
      }
      for (v in vs) {
        z = 3.2;
        continue;
      }
    }
    while (1) {
      int b;
      b = 5;
      {
        int c;
        c = 6;
        break;
      }
    }
    while (1) {
      while (1) {
        
      }
      break;
    }
    while (1) {
      while (1) {
        
      }
      continue;
    }
    return 0;
  }
}
transformed data {
  int x;
  x = 0;
  while (0) break;
  while (1) continue;
}
parameters {
  real y;
}
transformed parameters {
  real z;
  z = 1;
  while (0) break;
  while (1) continue;
}
model {

}
generated quantities {
  real u;
  u = 1;
  while (1) break;
  while (0) continue;
}

  $ ../../../../install/default/bin/stanc --auto-format conditional_condition_good.stan
parameters {
  real y;
}
model {
  int x;
  if (x) 
    y ~ normal(0, 1);
  else if (!x) 
    y ~ normal(0, 1);
  else 
    y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format conditional_op_fun_promote.stan
functions {
  real foo(real y) {
    return 1 ? y : 2;
  }
}
parameters {
  real y;
}
transformed parameters {
  real z;
  z = foo(y);
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format declarations.stan
data {
  int a0;
  array[1] int a1;
  array[2, 3] int a2;
  array[1] int a3;
  array[2, 3] int a4;
  real b0;
  array[4] real b1;
  array[5, 6] real b2;
  array[4] real b3;
  array[5, 6] real b4;
  vector[7] c0;
  array[8] vector[7] c1;
  array[8, 9] vector[7] c2;
  array[8] vector[7] c3;
  array[8, 9] vector[7] c4;
  row_vector[7] d0;
  array[8] row_vector[7] d1;
  array[8, 9] row_vector[7] d2;
  array[8] row_vector[7] d3;
  array[8, 9] row_vector[7] d4;
  matrix[8, 9] e;
  array[11] matrix[8, 9] e1;
  array[11, 12] matrix[8, 9] e2;
  array[11] matrix[8, 9] e3;
  array[11, 12] matrix[8, 9] e4;
  simplex[8] f;
  array[9] simplex[8] f1;
  array[9, 10] simplex[8] f2;
  array[9] simplex[8] f3;
  array[9, 10] simplex[8] f4;
  ordered[9] g;
  array[11] ordered[9] g1;
  array[12, 13] ordered[9] g2;
  array[11] ordered[9] g3;
  array[12, 13] ordered[9] g4;
  positive_ordered[9] h;
  array[11] positive_ordered[9] h1;
  array[12, 13] positive_ordered[9] h2;
  array[11] positive_ordered[9] h3;
  array[12, 13] positive_ordered[9] h4;
  corr_matrix[10] j;
  array[3] corr_matrix[10] j1;
  array[5, 6] corr_matrix[10] j2;
  array[3] corr_matrix[10] j3;
  array[5, 6] corr_matrix[10] j4;
  cov_matrix[10] k;
  array[3] cov_matrix[10] k1;
  array[5, 6] cov_matrix[10] k2;
  array[3] cov_matrix[10] k3;
  array[5, 6] cov_matrix[10] k4;
}
transformed data {
  int td_a0;
  array[1] int td_a1;
  array[2, 3] int td_a2;
  array[1] int td_a3;
  array[2, 3] int td_a4;
  real td_b0;
  array[4] real td_b1;
  array[5, 6] real td_b2;
  array[4] real td_b3;
  array[5, 6] real td_b4;
  vector[7] td_c0;
  array[8] vector[7] td_c1;
  array[8, 9] vector[7] td_c2;
  array[8] vector[7] td_c3;
  array[8, 9] vector[7] td_c4;
  row_vector[7] td_d0;
  array[8] row_vector[7] td_d1;
  array[8, 9] row_vector[7] td_d2;
  array[8] row_vector[7] td_d3;
  array[8, 9] row_vector[7] td_d4;
  matrix[8, 9] td_e;
  array[11] matrix[8, 9] td_e1;
  array[11, 12] matrix[8, 9] td_e2;
  array[11] matrix[8, 9] td_e3;
  array[11, 12] matrix[8, 9] td_e4;
  simplex[8] td_f;
  array[9] simplex[8] td_f1;
  array[9, 10] simplex[8] td_f2;
  array[9] simplex[8] td_f3;
  array[9, 10] simplex[8] td_f4;
  ordered[9] td_g;
  array[11] ordered[9] td_g1;
  array[12, 13] ordered[9] td_g2;
  array[11] ordered[9] td_g3;
  array[12, 13] ordered[9] td_g4;
  positive_ordered[9] td_h;
  array[11] positive_ordered[9] td_h1;
  array[12, 13] positive_ordered[9] td_h2;
  array[11] positive_ordered[9] td_h3;
  array[12, 13] positive_ordered[9] td_h4;
  corr_matrix[10] td_j;
  array[3] corr_matrix[10] td_j1;
  array[5, 6] corr_matrix[10] td_j2;
  array[3] corr_matrix[10] td_j3;
  array[5, 6] corr_matrix[10] td_j4;
  cov_matrix[10] td_k;
  array[3] cov_matrix[10] td_k1;
  array[5, 6] cov_matrix[10] td_k2;
  array[3] cov_matrix[10] td_k3;
  array[5, 6] cov_matrix[10] td_k4;
  {
    int loc_td_a0;
    array[1] int loc_td_a1;
    array[2, 3] int loc_td_a2;
    array[1] int loc_td_a3;
    array[2, 3] int loc_td_a4;
    real loc_td_b0;
    array[4] real loc_td_b1;
    array[5, 6] real loc_td_b2;
    array[4] real loc_td_b3;
    array[5, 6] real loc_td_b4;
    vector[7] loc_td_c0;
    array[8] vector[7] loc_td_c1;
    array[8, 9] vector[7] loc_td_c2;
    array[8] vector[7] loc_td_c3;
    array[8, 9] vector[7] loc_td_c4;
    row_vector[7] loc_td_d0;
    array[8] row_vector[7] loc_td_d1;
    array[8, 9] row_vector[7] loc_td_d2;
    array[8] row_vector[7] loc_td_d3;
    array[8, 9] row_vector[7] loc_td_d4;
    matrix[8, 9] loc_td_e;
    array[11] matrix[8, 9] loc_td_e1;
    array[11, 12] matrix[8, 9] loc_td_e2;
    array[11] matrix[8, 9] loc_td_e3;
    array[11, 12] matrix[8, 9] loc_td_e4;
  }
}
parameters {
  real par_b0;
  array[4] real par_b1;
  array[5, 6] real par_b2;
  array[4] real par_b3;
  array[5, 6] real par_b4;
  vector[7] par_c0;
  array[8] vector[7] par_c1;
  array[8, 9] vector[7] par_c2;
  array[8] vector[7] par_c3;
  array[8, 9] vector[7] par_c4;
  row_vector[7] par_d0;
  array[8] row_vector[7] par_d1;
  array[8, 9] row_vector[7] par_d2;
  array[8] row_vector[7] par_d3;
  array[8, 9] row_vector[7] par_d4;
  matrix[8, 9] par_e;
  array[11] matrix[8, 9] par_e1;
  array[11, 12] matrix[8, 9] par_e2;
  array[11] matrix[8, 9] par_e3;
  array[11, 12] matrix[8, 9] par_e4;
  simplex[8] par_f;
  array[9] simplex[8] par_f1;
  array[9, 10] simplex[8] par_f2;
  array[9] simplex[8] par_f3;
  array[9, 10] simplex[8] par_f4;
  ordered[9] par_g;
  array[11] ordered[9] par_g1;
  array[12, 13] ordered[9] par_g2;
  array[11] ordered[9] par_g3;
  array[12, 13] ordered[9] par_g4;
  positive_ordered[9] par_h;
  array[11] positive_ordered[9] par_h1;
  array[12, 13] positive_ordered[9] par_h2;
  array[11] positive_ordered[9] par_h3;
  array[12, 13] positive_ordered[9] par_h4;
  corr_matrix[10] par_j;
  array[3] corr_matrix[10] par_j1;
  array[5, 6] corr_matrix[10] par_j2;
  array[3] corr_matrix[10] par_j3;
  array[5, 6] corr_matrix[10] par_j4;
  cov_matrix[10] par_k;
  array[3] cov_matrix[10] par_k1;
  array[5, 6] cov_matrix[10] par_k2;
  array[3] cov_matrix[10] par_k3;
  array[5, 6] cov_matrix[10] par_k4;
}
transformed parameters {
  real tpar_b0;
  array[4] real tpar_b1;
  array[5, 6] real tpar_b2;
  array[4] real tpar_b3;
  array[5, 6] real tpar_b4;
  vector[7] tpar_c0;
  array[8] vector[7] tpar_c1;
  array[8, 9] vector[7] tpar_c2;
  array[8] vector[7] tpar_c3;
  array[8, 9] vector[7] tpar_c4;
  row_vector[7] tpar_d0;
  array[8] row_vector[7] tpar_d1;
  array[8, 9] row_vector[7] tpar_d2;
  array[8] row_vector[7] tpar_d3;
  array[8, 9] row_vector[7] tpar_d4;
  matrix[8, 9] tpar_e;
  array[11] matrix[8, 9] tpar_e1;
  array[11, 12] matrix[8, 9] tpar_e2;
  array[11] matrix[8, 9] tpar_e3;
  array[11, 12] matrix[8, 9] tpar_e4;
  simplex[8] tpar_f;
  array[9] simplex[8] tpar_f1;
  array[9, 10] simplex[8] tpar_f2;
  array[9] simplex[8] tpar_f3;
  array[9, 10] simplex[8] tpar_f4;
  ordered[9] tpar_g;
  array[11] ordered[9] tpar_g1;
  array[12, 13] ordered[9] tpar_g2;
  array[11] ordered[9] tpar_g3;
  array[12, 13] ordered[9] tpar_g4;
  positive_ordered[9] tpar_h;
  array[11] positive_ordered[9] tpar_h1;
  array[12, 13] positive_ordered[9] tpar_h2;
  array[11] positive_ordered[9] tpar_h3;
  array[12, 13] positive_ordered[9] tpar_h4;
  corr_matrix[10] tpar_j;
  array[3] corr_matrix[10] tpar_j1;
  array[5, 6] corr_matrix[10] tpar_j2;
  array[3] corr_matrix[10] tpar_j3;
  array[5, 6] corr_matrix[10] tpar_j4;
  cov_matrix[10] tpar_k;
  array[3] cov_matrix[10] tpar_k1;
  array[5, 6] cov_matrix[10] tpar_k2;
  array[3] cov_matrix[10] tpar_k3;
  array[5, 6] cov_matrix[10] tpar_k4;
  {
    int loc_tpar_a0;
    array[1] int loc_tpar_a1;
    array[2, 3] int loc_tpar_a2;
    array[1] int loc_tpar_a3;
    array[2, 3] int loc_tpar_a4;
    real loc_tpar_b0;
    array[4] real loc_tpar_b1;
    array[5, 6] real loc_tpar_b2;
    array[4] real loc_tpar_b3;
    array[5, 6] real loc_tpar_b4;
    vector[7] loc_tpar_c0;
    array[8] vector[7] loc_tpar_c1;
    array[8, 9] vector[7] loc_tpar_c2;
    array[8] vector[7] loc_tpar_c3;
    array[8, 9] vector[7] loc_tpar_c4;
    row_vector[7] loc_tpar_d0;
    array[8] row_vector[7] loc_tpar_d1;
    array[8, 9] row_vector[7] loc_tpar_d2;
    array[8] row_vector[7] loc_tpar_d3;
    array[8, 9] row_vector[7] loc_tpar_d4;
    matrix[8, 9] loc_tpar_e;
    array[11] matrix[8, 9] loc_tpar_e1;
    array[11, 12] matrix[8, 9] loc_tpar_e2;
    array[11] matrix[8, 9] loc_tpar_e3;
    array[11, 12] matrix[8, 9] loc_tpar_e4;
  }
}
model {
  {
    int loc_model_a0;
    array[1] int loc_model_a1;
    array[2, 3] int loc_model_a2;
    array[1] int loc_model_a3;
    array[2, 3] int loc_model_a4;
    real loc_model_b0;
    array[4] real loc_model_b1;
    array[5, 6] real loc_model_b2;
    array[4] real loc_model_b3;
    array[5, 6] real loc_model_b4;
    vector[7] loc_model_c0;
    array[8] vector[7] loc_model_c1;
    array[8, 9] vector[7] loc_model_c2;
    array[8] vector[7] loc_model_c3;
    array[8, 9] vector[7] loc_model_c4;
    row_vector[7] loc_model_d0;
    array[8] row_vector[7] loc_model_d1;
    array[8, 9] row_vector[7] loc_model_d2;
    array[8] row_vector[7] loc_model_d3;
    array[8, 9] row_vector[7] loc_model_d4;
    matrix[8, 9] loc_model_e;
    array[11] matrix[8, 9] loc_model_e1;
    array[11, 12] matrix[8, 9] loc_model_e2;
    array[11] matrix[8, 9] loc_model_e3;
    array[11, 12] matrix[8, 9] loc_model_e4;
  }
}
generated quantities {
  real gq_b0;
  array[4] real gq_b1;
  array[5, 6] real gq_b2;
  array[4] real gq_b3;
  array[5, 6] real gq_b4;
  vector[7] gq_c0;
  array[8] vector[7] gq_c1;
  array[8, 9] vector[7] gq_c2;
  array[8] vector[7] gq_c3;
  array[8, 9] vector[7] gq_c4;
  row_vector[7] gq_d0;
  array[8] row_vector[7] gq_d1;
  array[8, 9] row_vector[7] gq_d2;
  array[8] row_vector[7] gq_d3;
  array[8, 9] row_vector[7] gq_d4;
  matrix[8, 9] gq_e;
  array[11] matrix[8, 9] gq_e1;
  array[11, 12] matrix[8, 9] gq_e2;
  array[11] matrix[8, 9] gq_e3;
  array[11, 12] matrix[8, 9] gq_e4;
  simplex[8] gq_f;
  array[9] simplex[8] gq_f1;
  array[9, 10] simplex[8] gq_f2;
  array[9] simplex[8] gq_f3;
  array[9, 10] simplex[8] gq_f4;
  ordered[9] gq_g;
  array[11] ordered[9] gq_g1;
  array[12, 13] ordered[9] gq_g2;
  array[11] ordered[9] gq_g3;
  array[12, 13] ordered[9] gq_g4;
  positive_ordered[9] gq_h;
  array[11] positive_ordered[9] gq_h1;
  array[12, 13] positive_ordered[9] gq_h2;
  array[11] positive_ordered[9] gq_h3;
  array[12, 13] positive_ordered[9] gq_h4;
  corr_matrix[10] gq_j;
  array[3] corr_matrix[10] gq_j1;
  array[5, 6] corr_matrix[10] gq_j2;
  array[3] corr_matrix[10] gq_j3;
  array[5, 6] corr_matrix[10] gq_j4;
  cov_matrix[10] gq_k;
  array[3] cov_matrix[10] gq_k1;
  array[5, 6] cov_matrix[10] gq_k2;
  array[3] cov_matrix[10] gq_k3;
  array[5, 6] cov_matrix[10] gq_k4;
  {
    int loc_gq_a0;
    array[1] int loc_gq_a1;
    array[2, 3] int loc_gq_a2;
    array[1] int loc_gq_a3;
    array[2, 3] int loc_gq_a4;
    real loc_gq_b0;
    array[4] real loc_gq_b1;
    array[5, 6] real loc_gq_b2;
    array[4] real loc_gq_b3;
    array[5, 6] real loc_gq_b4;
    vector[7] loc_gq_c0;
    array[8] vector[7] loc_gq_c1;
    array[8, 9] vector[7] loc_gq_c2;
    array[8] vector[7] loc_gq_c3;
    array[8, 9] vector[7] loc_gq_c4;
    row_vector[7] loc_gq_d0;
    array[8] row_vector[7] loc_gq_d1;
    array[8, 9] row_vector[7] loc_gq_d2;
    array[8] row_vector[7] loc_gq_d3;
    array[8, 9] row_vector[7] loc_gq_d4;
    matrix[8, 9] loc_gq_e;
    array[11] matrix[8, 9] loc_gq_e1;
    array[11, 12] matrix[8, 9] loc_gq_e2;
    array[11] matrix[8, 9] loc_gq_e3;
    array[11, 12] matrix[8, 9] loc_gq_e4;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-conditional-op.stan
data {
  int<lower=0> N;
  array[N] int<lower=0, upper=1> y;
  real x;
}
transformed data {
  int td_i1 = 1 ? N : N;
  int td_i2 = 1 ? N : y[1];
  int td_i3 = 1 ? N : -3;
  int td_i4 = 1 ? 1 : 4;
  real td_r1 = 1 ? 1.0 : 2.0;
  real td_r2 = 1 ? 1.0 : x;
  real td_r3 = 1 ? x : 2.0;
  real td_r4 = 0 ? x : x;
  real td_r5 = 0 ? N : x;
}
parameters {
  real<lower=0, upper=1> theta;
  real z;
}
transformed parameters {
  real tp_r1 = 1 ? 1.0 : 2.0;
  real tp_r2 = 1 ? 1.0 : x;
  real tp_r3 = 1 ? x : 2.0;
  real tp_r4 = 0 ? x : x;
  real tp_r5 = 0 ? N : x;
  real tp_r6 = 1 ? x : tp_r1;
  real tp_r7 = 1 ? tp_r1 : tp_r2;
  real tp_r8 = 1 ? N : tp_r1;
  {
    real local_r1 = 1 ? 1.0 : 2.0;
    real local_r2 = 1 ? 1.0 : x;
    real local_r3 = 1 ? x : 2.0;
    real local_r4 = 0 ? x : x;
    real local_r5 = 0 ? N : x;
    real local_r6 = 1 ? x : tp_r1;
    real local_r7 = 1 ? tp_r1 : tp_r2;
    real local_r8 = 1 ? N : tp_r1;
  }
}
model {
  theta ~ beta(1, 1);
  for (n in 1 : N) 
    y[n] ~ bernoulli(theta);
}
generated quantities {
  int gq_i1 = 1 ? N : N;
  int gq_i2 = 1 ? N : y[1];
  int gq_i3 = 1 ? N : -3;
  int gq_i4 = 1 ? 1 : 4;
  real gq_r1 = 1 ? 1.0 : 2.0;
  real gq_r2 = 1 ? 1.0 : x;
  real gq_r3 = 1 ? x : 2.0;
  real gq_r4 = 0 ? x : x;
  real gq_r5 = 0 ? N : x;
  real gq_r6 = 1 ? x : tp_r1;
  real gq_r7 = 1 ? tp_r1 : tp_r2;
  real gq_r8 = 1 ? N : tp_r1;
  {
    real local_r1 = 1 ? 1.0 : 2.0;
    real local_r2 = 1 ? 1.0 : x;
    real local_r3 = 1 ? x : 2.0;
    real local_r4 = 0 ? x : x;
    real local_r5 = 0 ? N : x;
    real local_r6 = 1 ? x : tp_r1;
    real local_r7 = 1 ? tp_r1 : tp_r2;
    real local_r8 = 1 ? N : tp_r1;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-gq-local-rng.stan
transformed data {
  int a = categorical_rng(rep_vector(0.1, 10));
  {
    int b = categorical_rng(rep_vector(0.1, 10));
  }
}
parameters {
  real y;
}
transformed parameters {
  {
    int k;
  }
}
model {
  y ~ normal(0, 1);
}
generated quantities {
  {
    int y_tilde = categorical_rng(rep_vector(0.1, 10));
  }
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-multi.stan
data {
  int a0;
  int a1;
  int a2;
  array[5] real b0;
  array[5] real b1;
  array[5] real b3;
  array[3, 2] vector[5] c0;
  array[3, 2] vector[5] c1;
  array[3, 2] vector[5] c2;
  array[3, 2] vector[5] c4;
  array[3, 2] matrix[5, 4] d0;
  array[3, 2] matrix[5, 4] d1;
}
transformed data {
  int td_a0 = 0;
  int td_a1 = 2;
  int td_a2;
  int td_a3;
  int td_a4 = 4;
  int td_a5;
  int td_a6 = 6;
  real td_b0 = 0.5;
  real td_b1 = 2.5;
  real td_b2;
  real td_b3;
  real td_b4 = 4.5;
  real td_b5;
  real td_b6 = 6.5;
  vector[2] td_c0 = [-1.5, -2.5]';
  vector[2] td_c1 = [1.5, 2.5]';
  vector[2] td_c2;
  vector[2] td_c3;
  vector[2] td_c4 = [-1.5, -2.5]';
  vector[2] td_c5;
  vector[2] td_c6 = [1.5, 2.5]';
  array[2] real td_d0 = {-1.5, -2.5};
  array[2] real td_d1 = {1.5, 2.5};
  array[2] real td_d2;
  array[2] real td_d3;
  array[2] real td_d4 = {-1.5, -2.5};
  array[2] real td_d5;
  array[2] real td_d6 = {1.5, 2.5};
  {
    int loc_a0 = 0;
    int loc_a1 = 2;
    int loc_a2;
    int loc_a3;
    int loc_a4 = 4;
    int loc_a5;
    int loc_a6 = 6;
    real loc_b0 = 0.5;
    real loc_b1 = 2.5;
    real loc_b2;
    real loc_b3;
    real loc_b4 = 4.5;
    real loc_b5;
    real loc_b6 = 6.5;
    vector[2] loc_c0 = [-1.5, -2.5]';
    vector[2] loc_c1 = [1.5, 2.5]';
    vector[2] loc_c2;
    vector[2] loc_c3;
    vector[2] loc_c4 = [-1.5, -2.5]';
    vector[2] loc_c5;
    vector[2] loc_c6 = [1.5, 2.5]';
    array[2] real loc_d0 = {-1.5, -2.5};
    array[2] real loc_d1 = {1.5, 2.5};
    array[2] real loc_d2;
    array[2] real loc_d3;
    array[2] real loc_d4 = {-1.5, -2.5};
    array[2] real loc_d5;
    array[2] real loc_d6 = {1.5, 2.5};
  }
}
parameters {
  array[5] real par_b0;
  array[5] real par_b1;
  array[5] real par_b3;
  array[3, 2] vector[5] par_c0;
  array[3, 2] vector[5] par_c1;
  array[3, 2] vector[5] par_c2;
  array[3, 2] vector[5] par_c4;
  array[3, 2] matrix[5, 4] par_d0;
  array[3, 2] matrix[5, 4] par_d1;
}
transformed parameters {
  real tpar_b0 = 0.5;
  real tpar_b1 = 2.5;
  real tpar_b2;
  real tpar_b3;
  real tpar_b4 = 4.5;
  real tpar_b5;
  real tpar_b6 = 6.5;
  vector[2] tpar_c0 = [-1.5, -2.5]';
  vector[2] tpar_c1 = [1.5, 2.5]';
  vector[2] tpar_c2;
  vector[2] tpar_c3;
  vector[2] tpar_c4 = [-1.5, -2.5]';
  vector[2] tpar_c5;
  vector[2] tpar_c6 = [1.5, 2.5]';
  array[2] real tpar_d0 = {-1.5, -2.5};
  array[2] real tpar_d1 = {1.5, 2.5};
  array[2] real tpar_d2;
  array[2] real tpar_d3;
  array[2] real tpar_d4 = {-1.5, -2.5};
  array[2] real tpar_d5;
  array[2] real tpar_d6 = {1.5, 2.5};
  {
    int loc_tpar_a0 = 0;
    int loc_tpar_a1 = 2;
    int loc_tpar_a2;
    int loc_tpar_a3;
    int loc_tpar_a4 = 4;
    int loc_tpar_a5;
    int loc_tpar_a6 = 6;
    real loc_tpar_b0 = 0.5;
    real loc_tpar_b1 = 2.5;
    real loc_tpar_b2;
    real loc_tpar_b3;
    real loc_tpar_b4 = 4.5;
    real loc_tpar_b5;
    real loc_tpar_b6 = 6.5;
    vector[2] loc_tpar_c0 = [-1.5, -2.5]';
    vector[2] loc_tpar_c1 = [1.5, 2.5]';
    vector[2] loc_tpar_c2;
    vector[2] loc_tpar_c3;
    vector[2] loc_tpar_c4 = [-1.5, -2.5]';
    vector[2] loc_tpar_c5;
    vector[2] loc_tpar_c6 = [1.5, 2.5]';
    array[2] real loc_tpar_d0 = {-1.5, -2.5};
    array[2] real loc_tpar_d1 = {1.5, 2.5};
    array[2] real loc_tpar_d2;
    array[2] real loc_tpar_d3;
    array[2] real loc_tpar_d4 = {-1.5, -2.5};
    array[2] real loc_tpar_d5;
    array[2] real loc_tpar_d6 = {1.5, 2.5};
  }
}
model {
  int model_a0 = 0;
  int model_a1 = 2;
  int model_a2;
  int model_a3;
  int model_a4 = 4;
  int model_a5;
  int model_a6 = 6;
  real model_b0 = 0.5;
  real model_b1 = 2.5;
  real model_b2;
  real model_b3;
  real model_b4 = 4.5;
  real model_b5;
  real model_b6 = 6.5;
  vector[2] model_c0 = [-1.5, -2.5]';
  vector[2] model_c1 = [1.5, 2.5]';
  vector[2] model_c2;
  vector[2] model_c3;
  vector[2] model_c4 = [-1.5, -2.5]';
  vector[2] model_c5;
  vector[2] model_c6 = [1.5, 2.5]';
  array[2] real model_d0 = {-1.5, -2.5};
  array[2] real model_d1 = {1.5, 2.5};
  array[2] real model_d2;
  array[2] real model_d3;
  array[2] real model_d4 = {-1.5, -2.5};
  array[2] real model_d5;
  array[2] real model_d6 = {1.5, 2.5};
  {
    int loc_model_a0 = 0;
    int loc_model_a1 = 2;
    int loc_model_a2;
    int loc_model_a3;
    int loc_model_a4 = 4;
    int loc_model_a5;
    int loc_model_a6 = 6;
    real loc_model_b0 = 0.5;
    real loc_model_b1 = 2.5;
    real loc_model_b2;
    real loc_model_b3;
    real loc_model_b4 = 4.5;
    real loc_model_b5;
    real loc_model_b6 = 6.5;
    vector[2] loc_model_c0 = [-1.5, -2.5]';
    vector[2] loc_model_c1 = [1.5, 2.5]';
    vector[2] loc_model_c2;
    vector[2] loc_model_c3;
    vector[2] loc_model_c4 = [-1.5, -2.5]';
    vector[2] loc_model_c5;
    vector[2] loc_model_c6 = [1.5, 2.5]';
    array[2] real loc_model_d0 = {-1.5, -2.5};
    array[2] real loc_model_d1 = {1.5, 2.5};
    array[2] real loc_model_d2;
    array[2] real loc_model_d3;
    array[2] real loc_model_d4 = {-1.5, -2.5};
    array[2] real loc_model_d5;
    array[2] real loc_model_d6 = {1.5, 2.5};
  }
}
generated quantities {
  int gq_a0 = 0;
  int gq_a1 = 2;
  int gq_a2;
  int gq_a3;
  int gq_a4 = 4;
  int gq_a5;
  int gq_a6 = 6;
  real gq_b0 = 0.5;
  real gq_b1 = 2.5;
  real gq_b2;
  real gq_b3;
  real gq_b4 = 4.5;
  real gq_b5;
  real gq_b6 = 6.5;
  vector[2] gq_c0 = [-1.5, -2.5]';
  vector[2] gq_c1 = [1.5, 2.5]';
  vector[2] gq_c2;
  vector[2] gq_c3;
  vector[2] gq_c4 = [-1.5, -2.5]';
  vector[2] gq_c5;
  vector[2] gq_c6 = [1.5, 2.5]';
  array[2] real gq_d0 = {-1.5, -2.5};
  array[2] real gq_d1 = {1.5, 2.5};
  array[2] real gq_d2;
  array[2] real gq_d3;
  array[2] real gq_d4 = {-1.5, -2.5};
  array[2] real gq_d5;
  array[2] real gq_d6 = {1.5, 2.5};
  {
    int loc_gq_a0 = 0;
    int loc_gq_a1 = 2;
    int loc_gq_a2;
    int loc_gq_a3;
    int loc_gq_a4 = 4;
    int loc_gq_a5;
    int loc_gq_a6 = 6;
    real loc_gq_b0 = 0.5;
    real loc_gq_b1 = 2.5;
    real loc_gq_b2;
    real loc_gq_b3;
    real loc_gq_b4 = 4.5;
    real loc_gq_b5;
    real loc_gq_b6 = 6.5;
    vector[2] loc_gq_c0 = [-1.5, -2.5]';
    vector[2] loc_gq_c1 = [1.5, 2.5]';
    vector[2] loc_gq_c2;
    vector[2] loc_gq_c3;
    vector[2] loc_gq_c4 = [-1.5, -2.5]';
    vector[2] loc_gq_c5;
    vector[2] loc_gq_c6 = [1.5, 2.5]';
    array[2] real loc_gq_d0 = {-1.5, -2.5};
    array[2] real loc_gq_d1 = {1.5, 2.5};
    array[2] real loc_gq_d2;
    array[2] real loc_gq_d3;
    array[2] real loc_gq_d4 = {-1.5, -2.5};
    array[2] real loc_gq_d5;
    array[2] real loc_gq_d6 = {1.5, 2.5};
  }
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-constrained-matrix.stan
data {
  int d;
  corr_matrix[d] d_corr_matrix;
  array[1] corr_matrix[d] d_corr_matrix_ar;
  cov_matrix[d] d_cov_matrix;
  array[1] cov_matrix[d] d_cov_matrix_ar;
  cholesky_factor_corr[d] d_cholesky_factor_corr;
  array[1] cholesky_factor_corr[d] d_cholesky_factor_corr_ar;
  cholesky_factor_cov[d] d_cholesky_factor_cov;
  array[1] cholesky_factor_cov[d] d_cholesky_factor_cov_ar;
}
transformed data {
  corr_matrix[d] td_corr_matrix1 = d_corr_matrix;
  corr_matrix[d] td_corr_matrix2 = d_corr_matrix_ar[1];
  array[1] corr_matrix[d] td_corr_matrix_ar = d_corr_matrix_ar;
  cov_matrix[d] td_cov_matrix1 = d_cov_matrix;
  cov_matrix[d] td_cov_matrix2 = d_cov_matrix_ar[1];
  array[1] cov_matrix[d] td_cov_matrix_ar = d_cov_matrix_ar;
  cholesky_factor_corr[d] td_cholesky_factor_corr1 = d_cholesky_factor_corr;
  cholesky_factor_corr[d] td_cholesky_factor_corr2 = d_cholesky_factor_corr_ar[1];
  array[1] cholesky_factor_corr[d] td_cholesky_factor_corr_ar = d_cholesky_factor_corr_ar;
  cholesky_factor_cov[d] td_cholesky_factor_cov1 = d_cholesky_factor_cov;
  cholesky_factor_cov[d] td_cholesky_factor_cov2 = d_cholesky_factor_cov_ar[1];
  array[1] cholesky_factor_cov[d] td_cholesky_factor_cov_ar = d_cholesky_factor_cov_ar;
  print("td_corr_matrix1 = ", td_corr_matrix1);
  print("td_corr_matrix2 = ", td_corr_matrix2);
  print("td_corr_matrix_ar = ", td_corr_matrix_ar);
  print("td_cov_matrix1 = ", td_cov_matrix1);
  print("td_cov_matrix2 = ", td_cov_matrix2);
  print("td_cov_matrix_ar = ", td_cov_matrix_ar);
  print("td_cholesky_factor_corr1 = ", td_cholesky_factor_corr1);
  print("td_cholesky_factor_corr2 = ", td_cholesky_factor_corr2);
  print("td_cholesky_factor_corr_ar = ", td_cholesky_factor_corr_ar);
  print("td_cholesky_factor_cov1 = ", td_cholesky_factor_cov1);
  print("td_cholesky_factor_cov2 = ", td_cholesky_factor_cov2);
  print("td_cholesky_factor_cov_ar = ", td_cholesky_factor_cov_ar);
}
transformed parameters {
  corr_matrix[d] tp_corr_matrix1 = d_corr_matrix;
  corr_matrix[d] tp_corr_matrix2 = d_corr_matrix_ar[1];
  array[1] corr_matrix[d] tp_corr_matrix_ar = d_corr_matrix_ar;
  cov_matrix[d] tp_cov_matrix1 = d_cov_matrix;
  cov_matrix[d] tp_cov_matrix2 = d_cov_matrix_ar[1];
  array[1] cov_matrix[d] tp_cov_matrix_ar = d_cov_matrix_ar;
  cholesky_factor_corr[d] tp_cholesky_factor_corr1 = d_cholesky_factor_corr;
  cholesky_factor_corr[d] tp_cholesky_factor_corr2 = d_cholesky_factor_corr_ar[1];
  array[1] cholesky_factor_corr[d] tp_cholesky_factor_corr_ar = d_cholesky_factor_corr_ar;
  cholesky_factor_cov[d] tp_cholesky_factor_cov1 = d_cholesky_factor_cov;
  cholesky_factor_cov[d] tp_cholesky_factor_cov2 = d_cholesky_factor_cov_ar[1];
  array[1] cholesky_factor_cov[d] tp_cholesky_factor_cov_ar = d_cholesky_factor_cov_ar;
  print("tp_corr_matrix1 = ", tp_corr_matrix1);
  print("tp_corr_matrix2 = ", tp_corr_matrix2);
  print("tp_corr_matrix_ar = ", tp_corr_matrix_ar);
  print("tp_cov_matrix1 = ", tp_cov_matrix1);
  print("tp_cov_matrix2 = ", tp_cov_matrix2);
  print("tp_cov_matrix_ar = ", tp_cov_matrix_ar);
  print("tp_cholesky_factor_corr1 = ", tp_cholesky_factor_corr1);
  print("tp_cholesky_factor_corr2 = ", tp_cholesky_factor_corr2);
  print("tp_cholesky_factor_corr_ar = ", tp_cholesky_factor_corr_ar);
  print("tp_cholesky_factor_cov1 = ", tp_cholesky_factor_cov1);
  print("tp_cholesky_factor_cov2 = ", tp_cholesky_factor_cov2);
  print("tp_cholesky_factor_cov_ar = ", tp_cholesky_factor_cov_ar);
}
model {

}
generated quantities {
  corr_matrix[d] gq_corr_matrix1 = d_corr_matrix;
  corr_matrix[d] gq_corr_matrix2 = d_corr_matrix_ar[1];
  array[1] corr_matrix[d] gq_corr_matrix_ar = d_corr_matrix_ar;
  cov_matrix[d] gq_cov_matrix1 = d_cov_matrix;
  cov_matrix[d] gq_cov_matrix2 = d_cov_matrix_ar[1];
  array[1] cov_matrix[d] gq_cov_matrix_ar = d_cov_matrix_ar;
  cholesky_factor_corr[d] gq_cholesky_factor_corr1 = d_cholesky_factor_corr;
  cholesky_factor_corr[d] gq_cholesky_factor_corr2 = d_cholesky_factor_corr_ar[1];
  array[1] cholesky_factor_corr[d] gq_cholesky_factor_corr_ar = d_cholesky_factor_corr_ar;
  cholesky_factor_cov[d] gq_cholesky_factor_cov1 = d_cholesky_factor_cov;
  cholesky_factor_cov[d] gq_cholesky_factor_cov2 = d_cholesky_factor_cov_ar[1];
  array[1] cholesky_factor_cov[d] gq_cholesky_factor_cov_ar = d_cholesky_factor_cov_ar;
  print("gq_corr_matrix1 = ", gq_corr_matrix1);
  print("gq_corr_matrix2 = ", gq_corr_matrix2);
  print("gq_corr_matrix_ar = ", gq_corr_matrix_ar);
  print("gq_cov_matrix1 = ", gq_cov_matrix1);
  print("gq_cov_matrix2 = ", gq_cov_matrix2);
  print("gq_cov_matrix_ar = ", gq_cov_matrix_ar);
  print("gq_cholesky_factor_corr1 = ", gq_cholesky_factor_corr1);
  print("gq_cholesky_factor_corr2 = ", gq_cholesky_factor_corr2);
  print("gq_cholesky_factor_corr_ar = ", gq_cholesky_factor_corr_ar);
  print("gq_cholesky_factor_cov1 = ", gq_cholesky_factor_cov1);
  print("gq_cholesky_factor_cov2 = ", gq_cholesky_factor_cov2);
  print("gq_cholesky_factor_cov_ar = ", gq_cholesky_factor_cov_ar);
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-constrained-vector.stan
data {
  int d;
  simplex[d] d_simplex;
  array[d] simplex[d] d_simplex_ar;
  unit_vector[d] d_unit_vector;
  array[d] unit_vector[d] d_unit_vector_ar;
  ordered[d] d_ordered;
  array[d] ordered[d] d_ordered_ar;
  positive_ordered[d] d_positive_ordered;
  array[d] positive_ordered[d] d_positive_ordered_ar;
}
transformed data {
  simplex[d] td_simplex1 = d_simplex;
  simplex[d] td_simplex2 = d_simplex_ar[1];
  array[d] simplex[d] td_simplex_ar = d_simplex_ar;
  unit_vector[d] td_unit_vector1 = d_unit_vector;
  unit_vector[d] td_unit_vector2 = d_unit_vector_ar[1];
  array[d] unit_vector[d] td_unit_vector_ar = d_unit_vector_ar;
  ordered[d] td_ordered1 = d_ordered;
  ordered[d] td_ordered2 = d_ordered_ar[1];
  array[d] ordered[d] td_ordered_ar = d_ordered_ar;
  positive_ordered[d] td_positive_ordered1 = d_positive_ordered;
  positive_ordered[d] td_positive_ordered2 = d_positive_ordered_ar[1];
  array[d] positive_ordered[d] td_positive_ordered_ar = d_positive_ordered_ar;
  print("td_simplex1 = ", td_simplex1);
  print("td_simplex2 = ", td_simplex2);
  print("td_simplex_ar = ", td_simplex_ar);
  print("td_unit_vector1 = ", td_unit_vector1);
  print("td_unit_vector2 = ", td_unit_vector2);
  print("td_unit_vector_ar = ", td_unit_vector_ar);
  print("td_ordered1 = ", td_ordered1);
  print("td_ordered2 = ", td_ordered2);
  print("td_ordered_ar = ", td_ordered_ar);
  print("td_positive_ordered1 = ", td_positive_ordered1);
  print("td_positive_ordered2 = ", td_positive_ordered2);
  print("td_positive_ordered_ar = ", td_positive_ordered_ar);
}
transformed parameters {
  simplex[d] tp_simplex1 = d_simplex;
  simplex[d] tp_simplex2 = d_simplex_ar[1];
  array[d] simplex[d] tp_simplex_ar3 = d_simplex_ar;
  simplex[d] tp_simplex4 = tp_simplex1;
  simplex[d] tp_simplex5 = d_simplex_ar[1];
  array[d] simplex[d] tp_simplex_ar6 = tp_simplex_ar3;
  unit_vector[d] tp_unit_vector1 = d_unit_vector;
  unit_vector[d] tp_unit_vector2 = d_unit_vector_ar[1];
  array[d] unit_vector[d] tp_unit_vector_ar3 = d_unit_vector_ar;
  unit_vector[d] tp_unit_vector4 = tp_unit_vector1;
  unit_vector[d] tp_unit_vector5 = tp_unit_vector_ar3[2];
  array[d] unit_vector[d] tp_unit_vector_ar6 = tp_unit_vector_ar3;
  ordered[d] tp_ordered1 = d_ordered;
  ordered[d] tp_ordered2 = d_ordered_ar[1];
  array[d] ordered[d] tp_ordered_ar3 = d_ordered_ar;
  ordered[d] tp_ordered4 = tp_ordered1;
  ordered[d] tp_ordered5 = tp_ordered_ar3[3];
  array[d] ordered[d] tp_ordered_ar6 = tp_ordered_ar3;
  positive_ordered[d] tp_positive_ordered1 = d_positive_ordered;
  positive_ordered[d] tp_positive_ordered2 = d_positive_ordered_ar[1];
  array[d] positive_ordered[d] tp_positive_ordered_ar3 = d_positive_ordered_ar;
  positive_ordered[d] tp_positive_ordered4 = tp_positive_ordered1;
  positive_ordered[d] tp_positive_ordered5 = tp_positive_ordered_ar3[1];
  array[d] positive_ordered[d] tp_positive_ordered_ar6 = tp_positive_ordered_ar3;
  print("tp_simplex1 = ", tp_simplex1);
  print("tp_simplex2 = ", tp_simplex2);
  print("tp_simplex_ar3 = ", tp_simplex_ar3);
  print("tp_simplex4 = ", tp_simplex4);
  print("tp_simplex5 = ", tp_simplex5);
  print("tp_simplex_ar6 = ", tp_simplex_ar6);
  print("tp_unit_vector1 = ", tp_unit_vector1);
  print("tp_unit_vector2 = ", tp_unit_vector2);
  print("tp_unit_vector_ar3 = ", tp_unit_vector_ar3);
  print("tp_unit_vector4 = ", tp_unit_vector4);
  print("tp_unit_vector5 = ", tp_unit_vector5);
  print("tp_unit_vector_ar6 = ", tp_unit_vector_ar6);
  print("tp_ordered1 = ", tp_ordered1);
  print("tp_ordered2 = ", tp_ordered2);
  print("tp_ordered_ar3 = ", tp_ordered_ar3);
  print("tp_ordered4 = ", tp_ordered4);
  print("tp_ordered5 = ", tp_ordered5);
  print("tp_ordered_ar6 = ", tp_ordered_ar6);
  print("tp_positive_ordered1 = ", tp_positive_ordered1);
  print("tp_positive_ordered2 = ", tp_positive_ordered2);
  print("tp_positive_ordered_ar3 = ", tp_positive_ordered_ar3);
  print("tp_positive_ordered4 = ", tp_positive_ordered4);
  print("tp_positive_ordered5 = ", tp_positive_ordered5);
  print("tp_positive_ordered_ar6 = ", tp_positive_ordered_ar6);
}
model {

}
generated quantities {
  simplex[d] gq_simplex1 = d_simplex;
  simplex[d] gq_simplex2 = d_simplex_ar[1];
  array[d] simplex[d] gq_simplex_ar = d_simplex_ar;
  unit_vector[d] gq_unit_vector1 = d_unit_vector;
  unit_vector[d] gq_unit_vector2 = d_unit_vector_ar[1];
  array[d] unit_vector[d] gq_unit_vector_ar = d_unit_vector_ar;
  ordered[d] gq_ordered1 = d_ordered;
  ordered[d] gq_ordered2 = d_ordered_ar[1];
  array[d] ordered[d] gq_ordered_ar = d_ordered_ar;
  positive_ordered[d] gq_positive_ordered1 = d_positive_ordered;
  positive_ordered[d] gq_positive_ordered2 = d_positive_ordered_ar[1];
  array[d] positive_ordered[d] gq_positive_ordered_ar = d_positive_ordered_ar;
  print("gq_simplex1 = ", gq_simplex1);
  print("gq_simplex2 = ", gq_simplex2);
  print("gq_simplex_ar = ", gq_simplex_ar);
  print("gq_unit_vector1 = ", gq_unit_vector1);
  print("gq_unit_vector2 = ", gq_unit_vector2);
  print("gq_unit_vector_ar = ", gq_unit_vector_ar);
  print("gq_ordered1 = ", gq_ordered1);
  print("gq_ordered2 = ", gq_ordered2);
  print("gq_ordered_ar = ", gq_ordered_ar);
  print("gq_positive_ordered1 = ", gq_positive_ordered1);
  print("gq_positive_ordered2 = ", gq_positive_ordered2);
  print("gq_positive_ordered_ar = ", gq_positive_ordered_ar);
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-double.stan
functions {
  real foo(real a1) {
    int lf0 = 2;
    real lf1 = a1;
    real lf2 = lf1;
    array[lf0] real lf3;
    array[lf0] real lf4 = lf3;
    print("foo, lf1: ", lf1);
    print("foo, lf2: ", lf1);
    print("foo, lf4: ", lf4);
    lf1 = lf3[1] + lf4[1];
    return lf1;
  }
}
data {
  int<lower=0> N;
  array[N] int<lower=0, upper=1> y;
  array[3, 3] real d;
}
transformed data {
  int td0 = 3;
  real td1 = 123;
  real td2 = 2.0;
  real td3 = td0;
  real td4 = td3;
  array[3] real td_a1;
  array[3] real td_a2 = td_a1;
  real td5 = td_a2[1];
  array[3, 3] real td_a3 = d;
  array[3] real td_a4 = td_a3[2];
  print("td1: ", td1);
  print("td2: ", td2);
  print("td3: ", td3);
  print("td4: ", td4);
  print("td5: ", td5);
  print("td_a2: ", td_a2);
  print("td_a4: ", td_a4);
  {
    real ltd1 = 1;
    real ltd2 = 2.0;
    real ltd3 = td1;
    array[td0] real ltd4;
    array[td0] real ltd5 = ltd4;
    print("ltd1: ", ltd1);
    print("ltd2: ", ltd2);
    print("ltd3: ", ltd3);
    print("ltd5: ", ltd5);
  }
}
parameters {
  real<lower=0, upper=1> theta;
}
transformed parameters {
  real d_tp1 = 1.0;
  real d_tp2 = td1;
  real d_tp3 = td0;
  real d_tp4 = d[1, 2];
  array[3] real d_tp_a1 = td_a4;
  array[3] real d_tp_a2 = td_a3[1];
  array[3, 3] real d_tp_a3 = d;
  real p_tp2 = d_tp1;
  real p_tp4 = d_tp_a1[1];
  array[3] real p_tp_a1 = d_tp_a1;
  array[3] real p_tp_a2 = d_tp_a3[3];
  real tp1 = 1;
  real tp2 = 2.0;
  real tp3 = tp2;
  array[td0] real tp4;
  array[td0] real tp5 = tp4;
  print("d_tp1 = ", d_tp1);
  print("d_tp2 = ", d_tp2, " should be td1 = ", td1, " which should be 123");
  print("d_tp3 = ", d_tp3);
  print("d_tp4 = ", d_tp4);
  print("d_tp_a1 = ", d_tp_a1);
  print("d_tp_a2 = ", d_tp_a2);
  print("d_tp_a3 = ", d_tp_a3);
  print("p_tp2 = ", p_tp2);
  print("p_tp4 = ", p_tp4);
  print("p_tp_a1 = ", p_tp_a1);
  print("p_tp_a2 = ", p_tp_a2);
  print("tp1: ", tp1);
  print("tp2: ", tp2);
  print("tp3: ", tp3);
  print("tp5: ", tp5);
  tp1 = foo(tp3);
  print("tp1: ", tp1);
  {
    real lp1 = td0;
    real lp2 = 9.0;
    real lp3 = tp2;
    array[td0] real lp4;
    array[td0] real lp5 = lp4;
    print("lp1: ", lp1);
    print("lp2: ", lp2);
    print("lp3: ", lp3);
    print("lp5: ", lp5);
  }
}
model {
  real lm1 = 1;
  real lm2 = 2.0;
  real lm3 = tp2;
  theta ~ beta(1, 1);
  for (n in 1 : N) 
    y[n] ~ bernoulli(theta);
}
generated quantities {
  real gq_d_tp1 = 1.0;
  real gq_d_tp2 = td1;
  real gq_d_tp3 = td0;
  real gq_d_tp4 = d[1, 2];
  array[3] real gq_d_tp_a1 = td_a4;
  array[3] real gq_d_tp_a2 = td_a3[1];
  array[3, 3] real gq_d_tp_a3 = d;
  real gq_p_tp2 = d_tp1;
  real gq_p_tp4 = d_tp_a1[1];
  array[3] real gq_p_tp_a1 = d_tp_a1;
  array[3] real gq_p_tp_a2 = d_tp_a3[3];
  print("gq_d_tp1 = ", gq_d_tp1);
  print("gq_d_tp2 = ", gq_d_tp2, " should be td1 = ", td1, " which should be 123");
  print("gq_d_tp3 = ", gq_d_tp3);
  print("gq_d_tp4 = ", gq_d_tp4);
  print("gq_d_tp_a1 = ", gq_d_tp_a1);
  print("gq_d_tp_a2 = ", gq_d_tp_a2);
  print("gq_d_tp_a3 = ", gq_d_tp_a3);
  print("gq_p_tp2 = ", gq_p_tp2);
  print("gq_p_tp4 = ", gq_p_tp4);
  print("gq_p_tp_a1 = ", gq_p_tp_a1);
  print("gq_p_tp_a2 = ", gq_p_tp_a2);
  {
    real lgq1 = 1;
    real lgq2 = 2.0;
    real lqd2a = lgq2;
    array[td0] real lgq3;
    real lgq3a = lgq3[1];
    array[td0] real lgq4 = lgq3;
    array[3] real lgq5 = d[1];
    print("lgq1: ", lgq1);
    print("lgq2: ", lgq2);
    print("lgq2a: ", lqd2a);
    print("lgq3: ", lgq3);
    print("lgq3a: ", lgq3a);
    print("lgq4: ", lgq4);
    print("lgq5: ", lgq5);
  }
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-int.stan
functions {
  int foo() {
    int lf1 = 3;
    print("foo ", lf1);
    return lf1;
  }
}
data {
  int n;
  array[n, n] int d;
}
transformed data {
  int td1 = 1;
  int td2 = td1;
  array[n] int td_a1 = d[1];
  array[n] int td_a2 = td_a1;
  array[n, n] int td_a3 = d;
  array[n] int td_a4 = td_a3[n];
  int td3 = td_a3[2, 2];
  print("td1 = ", td1);
  print("td2 = ", td2);
  print("td3 = ", td3);
  print("td_a3 = ", td_a3);
  print("transformed data td2 ", td2);
  print("transformed data td_a2 ", td_a2);
  print("transformed data td_a4 ", td_a4);
}
transformed parameters {
  real p1;
  {
    int lp1 = 1;
    print("transformed param ", lp1);
  }
}
model {
  int lm1 = 4;
  print("local int ", lm1);
  print(foo());
}
generated quantities {
  int gq1 = 1;
  print("gq1 ", gq1);
  gq1 = 2;
  {
    int lgq1 = 2;
    print("gq2 ", lgq1);
    lgq1 = 2;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-matrix.stan
functions {
  matrix foo(int a) {
    matrix[a, a] lf0;
    matrix[a, a] lf1 = lf0;
    return lf1;
  }
}
data {
  int d;
  matrix[d, d] d_m;
  array[d] matrix[d, d] d_m_ar;
}
transformed data {
  matrix[d, d] td_m1 = d_m;
  matrix[d, d] td_m2 = d_m_ar[1];
  array[d] matrix[d, d] td_m_ar3 = d_m_ar;
  print("td_m1 = ", td_m1);
  print("td_m2 = ", td_m2);
  print("td_m_ar3 = ", td_m_ar3);
}
transformed parameters {
  matrix[d, d] tp_m1 = d_m;
  matrix[d, d] tp_m2 = d_m_ar[1];
  array[d] matrix[d, d] tp_m_ar3 = d_m_ar;
  matrix[d, d] tp_m4 = tp_m1;
  matrix[d, d] tp_m5 = tp_m_ar3[1];
  array[d] matrix[d, d] tp_m_ar6 = tp_m_ar3;
  print("tp_m1 = ", tp_m1);
  print("tp_m2 = ", tp_m2);
  print("tp_m_ar3 = ", tp_m_ar3);
  print("tp_m4 = ", tp_m4);
  print("tp_m5 = ", tp_m5);
  print("tp_m_ar6 = ", tp_m_ar6);
  {
    matrix[d, d] local_m1 = d_m;
    matrix[d, d] local_m2 = d_m_ar[1];
    array[d] matrix[d, d] local_m_ar3 = d_m_ar;
    matrix[d, d] local_m4 = tp_m1;
    matrix[d, d] local_m5 = tp_m_ar3[1];
    array[d] matrix[d, d] local_m_ar6 = tp_m_ar3;
    print("local_m1 = ", local_m1);
    print("local_m2 = ", local_m2);
    print("local_m_ar3 = ", local_m_ar3);
    print("local_m4 = ", local_m4);
    print("local_m5 = ", local_m5);
    print("local_m_ar6 = ", local_m_ar6);
  }
}
model {

}
generated quantities {
  matrix[d, d] gq_m1 = d_m;
  matrix[d, d] gq_m2 = d_m_ar[1];
  array[d] matrix[d, d] gq_m_ar3 = d_m_ar;
  matrix[d, d] gq_m4 = tp_m1;
  matrix[d, d] gq_m5 = tp_m_ar3[1];
  array[d] matrix[d, d] gq_m_ar6 = tp_m_ar3;
  print("gq_m1 = ", gq_m1);
  print("gq_m2 = ", gq_m2);
  print("gq_m_ar3 = ", gq_m_ar3);
  print("gq_m4 = ", gq_m4);
  print("gq_m5 = ", gq_m5);
  print("gq_m_ar6 = ", gq_m_ar6);
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-vec-runtime-error.stan
data {
  vector[7] b0;
}
transformed data {
  vector[8] td_b2 = b0;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-vec-types.stan
functions {
  void foo1() {
    vector[2] lf1;
    vector[2] lf2 = lf1;
    print("i am void");
  }
  vector foo2(int x) {
    vector[x] lf1;
    return lf1;
  }
}
data {
  int d;
  vector[d] d_v;
  row_vector[d] d_rv;
  array[d] vector[d] d_v_ar;
  array[d] row_vector[d] d_rv_ar;
  matrix[d, d] d_m;
}
transformed data {
  vector[d] td_v1 = d_v;
  vector[d] td_v2 = d_v_ar[1];
  vector[d] td_v3 = d_m[ : , 1];
  array[d] vector[d] td_v_ar = d_v_ar;
  row_vector[d] td_rv1 = d_rv;
  row_vector[d] td_rv2 = d_rv_ar[1];
  row_vector[d] td_rv3 = d_m[2];
  array[d] row_vector[d] td_rv_ar = d_rv_ar;
  print("td_v1 = ", td_v1);
  print("td_v2 = ", td_v2);
  print("td_v3 = ", td_v3);
  print("td_v_ar = ", td_v_ar);
  print("td_rv1 = ", td_rv1);
  print("td_rv2 = ", td_rv2);
  print("td_rv3 = ", td_rv3);
  print("td_rv_ar = ", td_rv_ar);
  {
    vector[d] local_v1 = d_v;
    vector[d] local_v2 = d_v_ar[1];
    vector[d] local_v3 = d_m[ : , 1];
    array[d] vector[d] local_v_ar = d_v_ar;
    row_vector[d] local_rv1 = d_rv;
    row_vector[d] local_rv2 = d_rv_ar[1];
    row_vector[d] local_rv3 = d_m[2];
    array[d] row_vector[d] local_rv_ar = d_rv_ar;
    print("local_v1 = ", local_v1);
    print("local_v2 = ", local_v2);
    print("local_v3 = ", local_v3);
    print("local_v_ar = ", local_v_ar);
    print("local_rv1 = ", local_rv1);
    print("local_rv2 = ", local_rv2);
    print("local_rv3 = ", local_rv3);
    print("local_rv_ar = ", local_rv_ar);
  }
  foo1();
}
parameters {
  matrix<lower=0, upper=1>[d, d] p_m;
}
transformed parameters {
  vector[d] tp_v1 = d_v;
  vector[d] tp_v2 = d_v_ar[1];
  vector[d] tp_v3 = d_m[ : , 1];
  array[d] vector[d] tp_v_ar4 = d_v_ar;
  vector[d] tp_v5 = tp_v1;
  vector[d] tp_v6 = tp_v_ar4[1];
  vector[d] tp_v7 = p_m[ : , 1];
  array[d] vector[d] tp_v_ar8 = tp_v_ar4;
  row_vector[d] tp_rv1 = d_rv;
  row_vector[d] tp_rv2 = d_rv_ar[1];
  row_vector[d] tp_rv3 = d_m[2];
  array[d] row_vector[d] tp_rv_ar4 = d_rv_ar;
  row_vector[d] tp_rv5 = tp_rv1;
  row_vector[d] tp_rv6 = tp_rv_ar4[1];
  row_vector[d] tp_rv7 = p_m[2,  : ];
  array[d] row_vector[d] tp_rv_ar8 = tp_rv_ar4;
  print("tp_v1 = ", tp_v1);
  print("tp_v2 = ", tp_v2);
  print("tp_v3 = ", tp_v3);
  print("tp_v_ar4 = ", tp_v_ar4);
  print("tp_v5 = ", tp_v5);
  print("tp_v6 = ", tp_v6);
  print("tp_v7 = ", tp_v7);
  print("tp_v_ar8 = ", tp_v_ar8);
  print("tp_rv1 = ", tp_rv1);
  print("tp_rv2 = ", tp_rv2);
  print("tp_rv3 = ", tp_rv3);
  print("tp_rv_ar = ", tp_rv_ar4);
  print("tp_rv5 = ", tp_rv5);
  print("tp_rv6 = ", tp_rv6);
  print("tp_rv7 = ", tp_rv7);
  print("tp_rv_ar8 = ", tp_rv_ar8);
  {
    vector[d] local_v1 = d_v;
    vector[d] local_v2 = d_v_ar[1];
    vector[d] local_v3 = d_m[ : , 1];
    array[d] vector[d] local_v_ar4 = d_v_ar;
    vector[d] local_v5 = tp_v1;
    vector[d] local_v6 = tp_v_ar4[1];
    vector[d] local_v7 = p_m[ : , 1];
    array[d] vector[d] local_v_ar8 = tp_v_ar4;
    row_vector[d] local_rv1 = d_rv;
    row_vector[d] local_rv2 = d_rv_ar[1];
    row_vector[d] local_rv3 = d_m[2];
    array[d] row_vector[d] local_rv_ar4 = d_rv_ar;
    row_vector[d] local_rv5 = tp_rv1;
    row_vector[d] local_rv6 = tp_rv_ar4[1];
    row_vector[d] local_rv7 = p_m[1];
    array[d] row_vector[d] local_rv_ar8 = tp_rv_ar4;
    print("local_v1 = ", local_v1);
    print("local_v2 = ", local_v2);
    print("local_v3 = ", local_v3);
    print("local_v_ar4 = ", local_v_ar4);
    print("local_v5 = ", local_v5);
    print("local_v6 = ", local_v6);
    print("local_v7 = ", local_v7);
    print("local_v_ar8 = ", local_v_ar8);
    print("local_rv1 = ", local_rv1);
    print("local_rv2 = ", local_rv2);
    print("local_rv3 = ", local_rv3);
    print("local_rv_ar4 = ", local_rv_ar4);
    print("local_rv5 = ", local_rv5);
    print("local_rv6 = ", local_rv6);
    print("local_rv7 = ", local_rv7);
    print("local_rv_ar8 = ", local_rv_ar8);
  }
}
model {

}
generated quantities {

}

  $ ../../../../install/default/bin/stanc --auto-format deprecate-increment-log-prob.stan
data {
  real a;
  vector[3] b;
  array[7] real c;
  array[8, 9] real d;
}
parameters {
  real e;
  vector[3] f;
  array[7] real g;
  array[8, 9] real h;
}
model {
  increment_log_prob(a);
  increment_log_prob(b);
  increment_log_prob(b);
  increment_log_prob(c);
  increment_log_prob(d);
  increment_log_prob(e);
  increment_log_prob(f);
  increment_log_prob(g);
  increment_log_prob(h);
}

Warning in 'deprecate-increment-log-prob.stan', line 15, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'deprecate-increment-log-prob.stan', line 16, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'deprecate-increment-log-prob.stan', line 17, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'deprecate-increment-log-prob.stan', line 18, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'deprecate-increment-log-prob.stan', line 19, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'deprecate-increment-log-prob.stan', line 20, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'deprecate-increment-log-prob.stan', line 21, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'deprecate-increment-log-prob.stan', line 22, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'deprecate-increment-log-prob.stan', line 23, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
  $ ../../../../install/default/bin/stanc --auto-format deprecate-old-prob-funs.stan
parameters {
  real y;
}
model {
  target += normal_log(y, 0, 1) + normal_cdf_log(2, 0, 1)
            + normal_ccdf_log(3, 0, 1);
}

Warning in 'deprecate-old-prob-funs.stan', line 5, column 12: normal_log is deprecated and will be removed in the future. Use normal_lpdf instead.
Warning in 'deprecate-old-prob-funs.stan', line 6, column 6: normal_cdf_log is deprecated and will be removed in the future. Use normal_lcdf instead.
Warning in 'deprecate-old-prob-funs.stan', line 7, column 6: normal_ccdf_log is deprecated and will be removed in the future. Use normal_lccdf instead.
  $ ../../../../install/default/bin/stanc --auto-format duplicate-warns.stan
model {
  real foo;
  foo = 1;
  increment_log_prob(0);
  foo = get_lp();
  foo = multiply_log(1, 1);
  foo = binomial_coefficient_log(1, 1);
  foo = normal_log(0.5, 0, 1);
  foo = normal_cdf_log(0.5, 0, 1);
  foo = normal_ccdf_log(0.5, 0, 1);
}

Warning in 'duplicate-warns.stan', line 4, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'duplicate-warns.stan', line 5, column 8: get_lp() function is deprecated. It will be removed in a future release. Use target() instead.
Warning in 'duplicate-warns.stan', line 5, column 8: The no-argument function `get_lp()` is deprecated. Use the no-argument function `target()` instead.
Warning in 'duplicate-warns.stan', line 6, column 8: multiply_log is deprecated and will be removed in the future. Use lmultiply instead.
Warning in 'duplicate-warns.stan', line 7, column 8: binomial_coefficient_log is deprecated and will be removed in the future. Use lchoose instead.
Warning in 'duplicate-warns.stan', line 9, column 8: normal_log is deprecated and will be removed in the future. Use normal_lpdf instead.
Warning in 'duplicate-warns.stan', line 10, column 8: normal_cdf_log is deprecated and will be removed in the future. Use normal_lcdf instead.
Warning in 'duplicate-warns.stan', line 11, column 8: normal_ccdf_log is deprecated and will be removed in the future. Use normal_lccdf instead.
  $ ../../../../install/default/bin/stanc --auto-format fun-defs-lpdf.stan
functions {
  real bar_baz_lpdf(real a, real b) {
    return a / b;
  }
}
parameters {
  real y;
}
model {
  y ~ bar_baz(3.2);
}

  $ ../../../../install/default/bin/stanc --auto-format fun-return-typ1.stan
functions {
  real foo() {
    reject("");
  }
}

  $ ../../../../install/default/bin/stanc --auto-format fun-return-typ2.stan
functions {
  real foo() {
    if (1) 
      reject("");
    reject("");
  }
}

  $ ../../../../install/default/bin/stanc --auto-format fun-return-typ4.stan
functions {
  real foo() {
    if (1) 
      reject("");
    else {
      if (1) 
        ;
      else 
        reject("");
    }
    reject("");
  }
}

  $ ../../../../install/default/bin/stanc --auto-format fun-var-constraints.stan
functions {
  real foo() {
    return 0;
  }
}
data {
  real<lower=foo(), upper=1> b;
}
transformed data {
  real<lower=-100, upper=foo()> bt;
}
parameters {
  real<lower=foo(), upper=1> y;
}
transformed parameters {
  real<lower=-100, upper=foo()> yt;
}
model {
  y ~ normal(0, 1);
}
generated quantities {
  real<lower=-100, upper=foo()> g;
}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_0.stan
functions {
  real foo() {
    return 1.7;
  }
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_0_lp.stan
functions {
  real foo_lp() {
    return 1.0;
  }
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_1.stan
functions {
  real foo(real x) {
    return x;
  }
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_4.stan
functions {
  real foo(real x1, real x2, real x3, real x4) {
    return x1;
  }
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_4_lp.stan
functions {
  real foo_lp(real x1, real x2, real x3, real x4) {
    return x1;
  }
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_5.stan
functions {
  real foo(real x1, real x2, real x3, real x4, real x5) {
    return x1;
  }
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_5_lp.stan
functions {
  real foo_lp(real x1, real x2, real x3, real x4, real x5) {
    return x1;
  }
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_int0.stan
functions {
  int foo() {
    return 3;
  }
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_int_1_int.stan
functions {
  int foo(int x) {
    return x;
  }
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_int_1_real.stan
functions {
  int foo(real x) {
    return 3;
  }
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format fun_as_lhs_sampling.stan
transformed data {
  matrix[2, 2] M = rep_matrix(0, 2, 2);
}
model {
  to_vector(M) ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format fun_as_stmt.stan
functions {
  void foo_lp() {
    
  }
}
model {
  foo_lp();
}

  $ ../../../../install/default/bin/stanc --auto-format fun_log_forward_decl.stan
functions {
  real n_log(real y);
  real n_log(real y) {
    return -0.5 * square(y);
  }
}
parameters {
  real mu;
}
model {
  mu ~ n();
  increment_log_prob(n_log(mu));
}

Warning in 'fun_log_forward_decl.stan', line 17, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'fun_log_forward_decl.stan', line 17, column 21: Use of the _log suffix in user defined function n_log is deprecated, use n_lpdf instead.
  $ ../../../../install/default/bin/stanc --auto-format functions-fwd-ref.stan
functions {
  int foo(int n);
  int foo(int n) {
    if (n == 0) 
      return 1;
    return n * foo(n - 1);
  }
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format functions-good-void.stan
functions {
  void linear_regression_lp(vector x, vector y, real alpha, real beta,
                            real sigma) {
    y ~ normal(x * alpha + beta, sigma);
    sigma ~ cauchy(0, 2.5);
    alpha ~ normal(0, 10);
    beta ~ normal(0, 10);
  }
}
data {
  int<lower=0> N;
  vector[N] x;
  vector[N] y;
}
parameters {
  real alpha;
  real beta;
  real<lower=0> sigma;
}
model {
  linear_regression_lp(x, y, alpha, beta, sigma);
}

  $ ../../../../install/default/bin/stanc --auto-format functions-good1.stan
functions {
  real foo0() {
    return 0.0;
  }
  real foo1(real x) {
    return 1.0;
  }
  real foo2(real x, real y) {
    return 2.0;
  }
  real foo0_lp() {
    return 0.0;
  }
  real foo1_lp(real x) {
    return 1.0;
  }
  real foo2_lp(real x, real y) {
    return 2.0;
  }
  real foo0_rng() {
    return 0.0;
  }
  real foo1_rng(real x) {
    return 2.0 * x;
  }
  real foo2_rng(real x, real y) {
    return x * y - 2.0;
  }
  real foo0_log(int y) {
    return -5;
  }
  real foo1_log(real x) {
    return -exp(x * x);
  }
  real foo2_log(real x, real y) {
    real diff;
    diff = x - y;
    return -exp(diff * diff);
  }
}
data {
  array[6] int<lower=0> N;
}
transformed data {
  real a;
  real b;
  real c;
  a = foo0();
  b = foo1(N[6]);
  c = foo2(a, b);
  c = foo2(a, 1);
  c = foo2(2, b);
  c = foo2(2, 3);
  a = foo0_log(2);
  b = foo1_log(N[6]);
  c = foo2_log(a, b);
  c = foo2_log(a, 1);
  c = foo2_log(2, b);
  c = foo2_log(2, 3);
  a = foo0_rng();
  b = foo1_rng(a);
  b = foo1_rng(1);
  c = foo2_rng(a, b);
  c = foo2_rng(1, b);
  c = foo2_rng(a, 2);
  c = foo2_rng(1, 2);
}
parameters {
  array[10] real<lower=0, upper=1> theta;
}
transformed parameters {
  real phi1;
  real phi2;
  real phi3;
  phi1 = foo0();
  phi2 = foo1(1);
  phi2 = foo1(2.0);
  phi2 = foo1(phi1);
  phi3 = foo2(1.0, 2.0);
  phi3 = foo2(1.0, 2);
  phi3 = foo2(1, 2.0);
  phi3 = foo2(1, 2);
  phi3 = foo2(phi1, 2.0);
  phi3 = foo2(phi1, 2);
  phi3 = foo2(1.0, phi2);
  phi3 = foo2(1, phi2);
  phi3 = foo2(phi1, phi2);
  phi1 = foo0_log(3);
  phi2 = foo1_log(1);
  phi2 = foo1_log(2.0);
  phi2 = foo1_log(phi1);
  phi3 = foo2_log(1.0, 2.0);
  phi3 = foo2_log(1.0, 2);
  phi3 = foo2_log(1, 2.0);
  phi3 = foo2_log(1, 2);
  phi3 = foo2_log(phi1, 2.0);
  phi3 = foo2_log(phi1, 2);
  phi3 = foo2_log(1.0, phi2);
  phi3 = foo2_log(1, phi2);
  phi3 = foo2_log(phi1, phi2);
}
model {
  real psi1;
  real psi2;
  real psi3;
  psi1 = foo0();
  psi2 = foo1(1);
  psi2 = foo1(2.0);
  psi2 = foo1(psi1);
  psi3 = foo2(1.0, 2.0);
  psi3 = foo2(1.0, 2);
  psi3 = foo2(1, 2.0);
  psi3 = foo2(1, 2);
  psi3 = foo2(psi1, 2.0);
  psi3 = foo2(psi1, 2);
  psi3 = foo2(1.0, psi2);
  psi3 = foo2(1, psi2);
  psi3 = foo2(psi1, psi2);
  psi1 = foo0_lp();
  psi2 = foo1_lp(1);
  psi2 = foo1_lp(2.0);
  psi2 = foo1_lp(psi1);
  psi3 = foo2_lp(1.0, 2.0);
  psi3 = foo2_lp(1.0, 2);
  psi3 = foo2_lp(1, 2.0);
  psi3 = foo2_lp(1, 2);
  psi3 = foo2_lp(psi1, 2.0);
  psi3 = foo2_lp(psi1, 2);
  psi3 = foo2_lp(1.0, psi2);
  psi3 = foo2_lp(1, psi2);
  psi3 = foo2_lp(psi1, psi2);
  psi1 = foo0_log(3);
  psi2 = foo1_log(1);
  psi2 = foo1_log(2.0);
  psi2 = foo1_log(psi1);
  psi3 = foo2_log(1.0, 2.0);
  psi3 = foo2_log(1.0, 2);
  psi3 = foo2_log(1, 2.0);
  psi3 = foo2_log(1, 2);
  psi3 = foo2_log(psi1, 2.0);
  psi3 = foo2_log(psi1, 2);
  psi3 = foo2_log(1.0, psi2);
  psi3 = foo2_log(1, psi2);
  psi3 = foo2_log(psi1, psi2);
  theta[1] ~ foo1();
  theta[2] ~ foo2(theta[1]);
}
generated quantities {
  real x;
  real y;
  real z;
  x = foo0();
  y = foo1(x);
  y = foo1(1);
  z = foo2(x, y);
  z = foo2(1, y);
  z = foo2(x, 2);
  z = foo2(1, 2);
  x = foo0_log(3);
  y = foo1_log(x);
  y = foo1_log(1);
  z = foo2_log(x, y);
  z = foo2_log(1, y);
  z = foo2_log(x, 2);
  z = foo2_log(1, 2);
  x = foo0_rng();
  y = foo1_rng(x);
  y = foo1_rng(1);
  z = foo2_rng(x, y);
  z = foo2_rng(1, y);
  z = foo2_rng(x, 2);
  z = foo2_rng(1, 2);
}

Warning in 'functions-good1.stan', line 63, column 6: Use of the _log suffix in user defined function foo0_log is deprecated, use foo0_lpmf instead.
Warning in 'functions-good1.stan', line 64, column 6: Use of the _log suffix in user defined function foo1_log is deprecated, use foo1_lpdf instead.
Warning in 'functions-good1.stan', line 65, column 6: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 66, column 6: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 67, column 6: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 68, column 6: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 124, column 9: Use of the _log suffix in user defined function foo0_log is deprecated, use foo0_lpmf instead.
Warning in 'functions-good1.stan', line 126, column 9: Use of the _log suffix in user defined function foo1_log is deprecated, use foo1_lpdf instead.
Warning in 'functions-good1.stan', line 127, column 9: Use of the _log suffix in user defined function foo1_log is deprecated, use foo1_lpdf instead.
Warning in 'functions-good1.stan', line 128, column 9: Use of the _log suffix in user defined function foo1_log is deprecated, use foo1_lpdf instead.
Warning in 'functions-good1.stan', line 130, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 131, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 132, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 133, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 135, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 136, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 138, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 139, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 141, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 186, column 9: Use of the _log suffix in user defined function foo0_log is deprecated, use foo0_lpmf instead.
Warning in 'functions-good1.stan', line 187, column 9: Use of the _log suffix in user defined function foo1_log is deprecated, use foo1_lpdf instead.
Warning in 'functions-good1.stan', line 188, column 9: Use of the _log suffix in user defined function foo1_log is deprecated, use foo1_lpdf instead.
Warning in 'functions-good1.stan', line 189, column 9: Use of the _log suffix in user defined function foo1_log is deprecated, use foo1_lpdf instead.
Warning in 'functions-good1.stan', line 191, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 192, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 193, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 194, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 196, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 197, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 199, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 200, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 202, column 9: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 221, column 6: Use of the _log suffix in user defined function foo0_log is deprecated, use foo0_lpmf instead.
Warning in 'functions-good1.stan', line 222, column 6: Use of the _log suffix in user defined function foo1_log is deprecated, use foo1_lpdf instead.
Warning in 'functions-good1.stan', line 223, column 6: Use of the _log suffix in user defined function foo1_log is deprecated, use foo1_lpdf instead.
Warning in 'functions-good1.stan', line 224, column 6: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 225, column 6: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 226, column 6: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
Warning in 'functions-good1.stan', line 227, column 6: Use of the _log suffix in user defined function foo2_log is deprecated, use foo2_lpdf instead.
  $ ../../../../install/default/bin/stanc --auto-format functions-good2.stan
functions {
  real foo_bar0() {
    return 0.0;
  }
  real foo_bar1(real x) {
    return 1.0;
  }
  real foo_bar2(real x, real y) {
    return 2.0;
  }
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format functions-good3.stan
functions {
  real unit_normal_rng() {
    return normal_rng(0, 1);
  }
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}
generated quantities {
  real z;
  z = unit_normal_rng();
}

  $ ../../../../install/default/bin/stanc --auto-format functions-promote-return.stan
functions {
  vector foo(vector x, real y) {
    if (y < 10) 
      return log(x);
    else 
      return log(y * x);
  }
}
transformed data {
  vector[3] x;
  x = rep_vector(0, 3);
}
parameters {
  real y;
}
model {
  foo(x, y) ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format funs1.stan
functions {
  void unit_normal_lp(real u) {
    increment_log_prob(normal_log(u, 0, 1));
    u ~ uniform(-100, 100);
  }
}
parameters {
  real y;
}
model {
  unit_normal_lp(y);
}

Warning in 'funs1.stan', line 3, column 4: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'funs1.stan', line 3, column 23: normal_log is deprecated and will be removed in the future. Use normal_lpdf instead.
  $ ../../../../install/default/bin/stanc --auto-format funs2.stan
functions {
  real unit_normal_rng() {
    return normal_rng(0, 1);
  }
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}
generated quantities {
  real z;
  z = unit_normal_rng();
}

  $ ../../../../install/default/bin/stanc --auto-format funs3.stan
functions {
  real unit_normal_log(real y) {
    return normal_log(y, 0, 1);
  }
}
parameters {
  real y;
}
model {
  y ~ unit_normal();
}

Warning in 'funs3.stan', line 3, column 11: normal_log is deprecated and will be removed in the future. Use normal_lpdf instead.
  $ ../../../../install/default/bin/stanc --auto-format funs4.stan
functions {
  real unit_normal_log(real y) {
    return normal_log(y, 0, 1);
  }
}
parameters {
  real y;
}
model {
  increment_log_prob(unit_normal_log(y));
}

Warning in 'funs4.stan', line 10, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'funs4.stan', line 3, column 11: normal_log is deprecated and will be removed in the future. Use normal_lpdf instead.
Warning in 'funs4.stan', line 10, column 21: Use of the _log suffix in user defined function unit_normal_log is deprecated, use unit_normal_lpdf instead.
  $ ../../../../install/default/bin/stanc --auto-format funs5.stan
functions {
  void foo(real x) {
    print("x=", x);
  }
}
parameters {
  real y;
}
model {
  foo(y);
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format funs6.stan
functions {
  real foo(real x) {
    return x * 2;
  }
}
parameters {
  real y;
}
model {
  foo(y) ~ normal(0, 2);
}

  $ ../../../../install/default/bin/stanc --auto-format funs7.stan
functions {
  real foo(real z) {
    real y;
    y = 1 ? z : 1;
    return y;
  }
}
parameters {
  real y;
}
transformed parameters {
  real z = foo(y);
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format genquant-data-only.stan
functions {
  real f(data real x) {
    return x + 1;
  }
}
parameters {
  real x;
}
generated quantities {
  real y = f(x);
}

  $ ../../../../install/default/bin/stanc --auto-format get-lp-deprecate.stan
parameters {
  real<lower=0> y;
}
model {
  print("target=", get_lp());
  y ~ normal(0, 1);
}

Warning in 'get-lp-deprecate.stan', line 5, column 19: get_lp() function is deprecated. It will be removed in a future release. Use target() instead.
Warning in 'get-lp-deprecate.stan', line 5, column 19: The no-argument function `get_lp()` is deprecated. Use the no-argument function `target()` instead.
  $ ../../../../install/default/bin/stanc --auto-format get-lp-target.stan
parameters {
  real<lower=0> y;
}
transformed parameters {
  print("target = ", target());
  print("get_lp = ", get_lp());
}
model {
  print("target = ", target());
  print("get_lp = ", get_lp());
  y ~ normal(0, 1);
}

Warning in 'get-lp-target.stan', line 6, column 21: get_lp() function is deprecated. It will be removed in a future release. Use target() instead.
Warning in 'get-lp-target.stan', line 10, column 21: get_lp() function is deprecated. It will be removed in a future release. Use target() instead.
Warning in 'get-lp-target.stan', line 6, column 21: The no-argument function `get_lp()` is deprecated. Use the no-argument function `target()` instead.
Warning in 'get-lp-target.stan', line 10, column 21: The no-argument function `get_lp()` is deprecated. Use the no-argument function `target()` instead.
  $ ../../../../install/default/bin/stanc --auto-format get_lp_good.stan
functions {
  real foo_lp(real x) {
    return x + get_lp();
  }
}
parameters {
  real y;
}
transformed parameters {
  real z;
  z = get_lp();
}
model {
  real w;
  w = get_lp();
  y ~ normal(0, 1);
}

Warning in 'get_lp_good.stan', line 10, column 15: get_lp() function is deprecated. It will be removed in a future release. Use target() instead.
Warning in 'get_lp_good.stan', line 18, column 6: get_lp() function is deprecated. It will be removed in a future release. Use target() instead.
Warning in 'get_lp_good.stan', line 22, column 6: get_lp() function is deprecated. It will be removed in a future release. Use target() instead.
Warning in 'get_lp_good.stan', line 10, column 15: The no-argument function `get_lp()` is deprecated. Use the no-argument function `target()` instead.
Warning in 'get_lp_good.stan', line 18, column 6: The no-argument function `get_lp()` is deprecated. Use the no-argument function `target()` instead.
Warning in 'get_lp_good.stan', line 22, column 6: The no-argument function `get_lp()` is deprecated. Use the no-argument function `target()` instead.
  $ ../../../../install/default/bin/stanc --auto-format good_fundef_returntypes1.stan
functions {
  real foo() {
    if (215) 
      return 24;
    return 24;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format good_fundef_returntypes2.stan
functions {
  void foo() {
    if (215) 
      return;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format good_fundef_returntypes3.stan
functions {
  real foo() {
    if (215) 
      return 24;
    reject("");
  }
}

  $ ../../../../install/default/bin/stanc --auto-format good_fundef_returntypes4.stan
functions {
  real foo() {
    if (215) 
      return 24;
    else 
      reject("");
  }
}

  $ ../../../../install/default/bin/stanc --auto-format good_inf.stan
data {
  real L;
  real U;
}
parameters {
  real<lower=L, upper=U> infty;
}
model {
  infty ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format identifiers.stan
data {
  int upper;
  int lower;
  int multiplier;
  int offset;
}

  $ ../../../../install/default/bin/stanc --auto-format illegal_generated_quantities.stan
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}
generated quantities {
  real<lower=0> x;
  x = -1;
}

  $ ../../../../install/default/bin/stanc --auto-format illegal_transformed_data.stan
transformed data {
  real<lower=0> x;
  x = -1;
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format illegal_transformed_parameters.stan
transformed parameters {
  real<lower=0> x;
  x = -1;
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format increment-target.stan
data {
  real a;
  vector[3] b;
  array[7] real c;
  array[8, 9] real d;
}
parameters {
  real e;
  vector[3] f;
  array[7] real g;
  array[8, 9] real h;
}
model {
  target += -e ^ 2 / 2;
  target += a;
  target += b;
  target += b;
  target += c;
  target += d;
  target += e;
  target += f;
  target += g;
  target += h;
}

  $ ../../../../install/default/bin/stanc --auto-format increment_log_prob.stan
transformed data {
  int n;
  array[2] int nn;
  array[3, 4] int nnn;
  real x;
  array[5] real xx;
  array[6, 7] real xxx;
  array[8, 9, 10] real xxxx;
  vector[2] v;
  array[4] vector[3] vv;
  array[5, 6] vector[4] vvv;
  row_vector[2] rv;
  array[4] row_vector[3] rvv;
  array[5, 6] row_vector[4] rvvv;
  matrix[7, 8] m;
  array[2] matrix[7, 8] mm;
  array[3, 4] matrix[7, 8] mmm;
}
parameters {
  real p_x;
  array[5] real p_xx;
  array[6, 7] real p_xxx;
  array[8, 9, 10] real p_xxxx;
  vector[2] p_v;
  array[4] vector[3] p_vv;
  array[5, 6] vector[4] p_vvv;
  row_vector[2] p_rv;
  array[4] row_vector[3] p_rvv;
  array[5, 6] row_vector[4] p_rvvv;
  matrix[7, 8] p_m;
  array[2] matrix[7, 8] p_mm;
  array[3, 4] matrix[7, 8] p_mmm;
}
model {
  increment_log_prob(n);
  increment_log_prob(nn);
  increment_log_prob(nnn);
  increment_log_prob(x);
  increment_log_prob(xx);
  increment_log_prob(xxx);
  increment_log_prob(xxxx);
  increment_log_prob(v);
  increment_log_prob(vv);
  increment_log_prob(vvv);
  increment_log_prob(rv);
  increment_log_prob(rvv);
  increment_log_prob(rvvv);
  increment_log_prob(m);
  increment_log_prob(mm);
  increment_log_prob(mmm);
  increment_log_prob(p_x);
  increment_log_prob(p_xx);
  increment_log_prob(p_xxx);
  increment_log_prob(p_xxxx);
  increment_log_prob(p_v);
  increment_log_prob(p_vv);
  increment_log_prob(p_vvv);
  increment_log_prob(p_rv);
  increment_log_prob(p_rvv);
  increment_log_prob(p_rvvv);
  increment_log_prob(p_m);
  increment_log_prob(p_mm);
  increment_log_prob(p_mmm);
}

Warning in 'increment_log_prob.stan', line 42, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 43, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 44, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 46, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 47, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 48, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 49, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 51, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 52, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 53, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 55, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 56, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 57, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 59, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 60, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 61, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 64, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 65, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 66, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 67, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 69, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 70, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 71, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 73, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 74, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 75, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 77, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 78, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
Warning in 'increment_log_prob.stan', line 79, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
  $ ../../../../install/default/bin/stanc --auto-format int_div_user.stan
data {
  array[4] int a;
  array[3] int b;
}
transformed data {
  int c;
  c = a[1] / b[2];
}
model {

}

Warning in 'int_div_user.stan', line 7, column 6: Found int division:
  a[1] / b[2]
Values will be rounded towards zero. If rounding is not desired you can write
the division as
  a[1] * 1.0 / b[2]
If rounding is intended please use the integer division operator %/%.
  $ ../../../../install/default/bin/stanc --auto-format int_fun.stan
functions {
  int foo(int x) {
    return x + 1;
  }
}
transformed data {
  int x;
  x = foo(2);
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format integrate_ode_adams.stan
functions {
  array[] real sho(real t, array[] real y, array[] real theta,
                   array[] real x, array[] int x_int) {
    array[2] real dydt;
    dydt[1] = y[2];
    dydt[2] = -y[1] - theta[1] * y[2];
    return dydt;
  }
}
data {
  int<lower=1> T;
  array[2] real y0_d;
  real t0;
  array[T] real ts;
  array[1] real theta_d;
  array[0] real x;
  array[0] int x_int;
}
parameters {
  array[2] real y0_p;
  array[1] real theta_p;
}
model {
  array[T, 2] real y_hat;
  y_hat = integrate_ode_adams(sho, y0_d, t0, ts, theta_p, x, x_int);
  y_hat = integrate_ode_adams(sho, y0_p, t0, ts, theta_d, x, x_int);
  y_hat = integrate_ode_adams(sho, y0_p, t0, ts, theta_p, x, x_int);
  y_hat = integrate_ode_adams(sho, y0_d, t0, ts, theta_p, x, x_int, 1e-10,
                              1e-10, 1e8);
  y_hat = integrate_ode_adams(sho, y0_p, t0, ts, theta_d, x, x_int, 1e-10,
                              1e-10, 1e8);
  y_hat = integrate_ode_adams(sho, y0_p, t0, ts, theta_p, x, x_int, 1e-10,
                              1e-10, 1e8);
}
generated quantities {
  array[T, 2] real y_hat;
  y_hat = integrate_ode_adams(sho, y0_d, t0, ts, theta_d, x, x_int);
  y_hat = integrate_ode_adams(sho, y0_d, t0, ts, theta_p, x, x_int);
  y_hat = integrate_ode_adams(sho, y0_p, t0, ts, theta_d, x, x_int);
  y_hat = integrate_ode_adams(sho, y0_p, t0, ts, theta_p, x, x_int);
  y_hat = integrate_ode_adams(sho, y0_d, t0, ts, theta_d, x, x_int, 1e-10,
                              1e-10, 1e8);
  y_hat = integrate_ode_adams(sho, y0_d, t0, ts, theta_p, x, x_int, 1e-10,
                              1e-10, 1e8);
  y_hat = integrate_ode_adams(sho, y0_p, t0, ts, theta_d, x, x_int, 1e-10,
                              1e-10, 1e8);
  y_hat = integrate_ode_adams(sho, y0_p, t0, ts, theta_p, x, x_int, 1e-10,
                              1e-10, 1e8);
}

Warning in 'integrate_ode_adams.stan', line 28, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 29, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 30, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 32, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 33, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 34, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 38, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 39, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 40, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 41, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 43, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 44, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 45, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_adams.stan', line 46, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../install/default/bin/stanc --auto-format integrate_ode_bdf.stan
functions {
  array[] real sho(real t, array[] real y, array[] real theta,
                   array[] real x, array[] int x_int) {
    array[2] real dydt;
    dydt[1] = y[2];
    dydt[2] = -y[1] - theta[1] * y[2];
    return dydt;
  }
}
data {
  int<lower=1> T;
  array[2] real y0_d;
  real t0;
  array[T] real ts;
  array[1] real theta_d;
  array[0] real x;
  array[0] int x_int;
}
parameters {
  array[2] real y0_p;
  array[1] real theta_p;
}
model {
  array[T, 2] real y_hat;
  y_hat = integrate_ode_bdf(sho, y0_d, t0, ts, theta_d, x, x_int);
  y_hat = integrate_ode_bdf(sho, y0_d, t0, ts, theta_p, x, x_int);
  y_hat = integrate_ode_bdf(sho, y0_p, t0, ts, theta_d, x, x_int);
  y_hat = integrate_ode_bdf(sho, y0_p, t0, ts, theta_p, x, x_int);
  y_hat = integrate_ode_bdf(sho, y0_d, t0, ts, theta_d, x, x_int, 1e-10,
                            1e-10, 1e8);
  y_hat = integrate_ode_bdf(sho, y0_d, t0, ts, theta_p, x, x_int, 1e-10,
                            1e-10, 1e8);
  y_hat = integrate_ode_bdf(sho, y0_p, t0, ts, theta_d, x, x_int, 1e-10,
                            1e-10, 1e8);
  y_hat = integrate_ode_bdf(sho, y0_p, t0, ts, theta_p, x, x_int, 1e-10,
                            1e-10, 1e8);
}
generated quantities {
  array[T, 2] real y_hat;
  y_hat = integrate_ode_bdf(sho, y0_d, t0, ts, theta_d, x, x_int);
  y_hat = integrate_ode_bdf(sho, y0_d, t0, ts, theta_p, x, x_int);
  y_hat = integrate_ode_bdf(sho, y0_p, t0, ts, theta_d, x, x_int);
  y_hat = integrate_ode_bdf(sho, y0_p, t0, ts, theta_p, x, x_int);
  y_hat = integrate_ode_bdf(sho, y0_d, t0, ts, theta_d, x, x_int, 1e-10,
                            1e-10, 1e8);
  y_hat = integrate_ode_bdf(sho, y0_d, t0, ts, theta_p, x, x_int, 1e-10,
                            1e-10, 1e8);
  y_hat = integrate_ode_bdf(sho, y0_p, t0, ts, theta_d, x, x_int, 1e-10,
                            1e-10, 1e8);
  y_hat = integrate_ode_bdf(sho, y0_p, t0, ts, theta_p, x, x_int, 1e-10,
                            1e-10, 1e8);
}

Warning in 'integrate_ode_bdf.stan', line 28, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 29, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 30, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 31, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 33, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 34, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 35, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 36, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 40, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 41, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 42, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 43, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 45, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 46, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 47, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_bdf.stan', line 48, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../install/default/bin/stanc --auto-format integrate_ode_deprecation.stan
functions {
  array[] real sho(real t, array[] real y, array[] real theta,
                   array[] real x, array[] int x_int) {
    array[2] real dydt;
    dydt[1] = y[2];
    dydt[2] = -y[1] - theta[1] * y[2];
    return dydt;
  }
}
data {
  int<lower=1> T;
  array[2] real y0;
  real t0;
  array[T] real ts;
  array[1] real theta;
}
transformed data {
  array[0] real x;
  array[0] int x_int;
}
model {

}
generated quantities {
  array[T, 2] real y_hat;
  y_hat = integrate_ode(sho, y0, t0, ts, theta, x, x_int);
  for (t in 1 : T) {
    y_hat[t, 1] = y_hat[t, 1] + normal_rng(0, 0.1);
    y_hat[t, 2] = y_hat[t, 2] + normal_rng(0, 0.1);
  }
}

Warning in 'integrate_ode_deprecation.stan', line 28, column 10: integrate_ode is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../install/default/bin/stanc --auto-format integrate_ode_rk45.stan
functions {
  array[] real sho(real t, array[] real y, array[] real theta,
                   array[] real x, array[] int x_int) {
    array[2] real dydt;
    dydt[1] = y[2];
    dydt[2] = -y[1] - theta[1] * y[2];
    return dydt;
  }
}
data {
  int<lower=1> T;
  array[2] real y0_d;
  real t0;
  array[T] real ts;
  array[1] real theta_d;
  array[0] real x;
  array[0] int x_int;
}
parameters {
  array[2] real y0_p;
  array[1] real theta_p;
}
model {
  array[T, 2] real y_hat;
  y_hat = integrate_ode_rk45(sho, y0_d, t0, ts, theta_d, x, x_int);
  y_hat = integrate_ode_rk45(sho, y0_d, t0, ts, theta_p, x, x_int);
  y_hat = integrate_ode_rk45(sho, y0_p, t0, ts, theta_d, x, x_int);
  y_hat = integrate_ode_rk45(sho, y0_p, t0, ts, theta_p, x, x_int);
}
generated quantities {
  array[T, 2] real y_hat;
  y_hat = integrate_ode_rk45(sho, y0_d, t0, ts, theta_d, x, x_int);
  y_hat = integrate_ode_rk45(sho, y0_d, t0, ts, theta_p, x, x_int);
  y_hat = integrate_ode_rk45(sho, y0_p, t0, ts, theta_d, x, x_int);
  y_hat = integrate_ode_rk45(sho, y0_p, t0, ts, theta_p, x, x_int);
}

Warning in 'integrate_ode_rk45.stan', line 28, column 10: integrate_ode_rk45 is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_rk45.stan', line 29, column 10: integrate_ode_rk45 is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_rk45.stan', line 30, column 10: integrate_ode_rk45 is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_rk45.stan', line 31, column 10: integrate_ode_rk45 is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_rk45.stan', line 35, column 10: integrate_ode_rk45 is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_rk45.stan', line 36, column 10: integrate_ode_rk45 is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_rk45.stan', line 37, column 10: integrate_ode_rk45 is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'integrate_ode_rk45.stan', line 38, column 10: integrate_ode_rk45 is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../install/default/bin/stanc --auto-format io_example.stan
transformed data {
  vector[2] y;
}
parameters {
  real mu1;
  real mu2;
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format keywords-else-if.stan
parameters {
  real a;
  real if2;
}
model {
  if (1 > 2) {
    a ~ normal(0, 1);
  }
  else 
    if2 ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-else.stan
parameters {
  real a;
  real elseif;
}
model {
  if (1 > 2) {
    a ~ normal(0, 1);
  }
  elseif ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-for.stan
parameters {
  real force;
}
model {
  force ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-if.stan
parameters {
  real iffy;
}
model {
  iffy ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-increment-log-prob.stan
parameters {
  real increment_log_prob2;
}
model {
  increment_log_prob2 ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-integrate-ode.stan
parameters {
  real integrate_ode_foo;
}
model {
  integrate_ode_foo ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-print.stan
parameters {
  real printer;
}
model {
  printer ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-reject.stan
parameters {
  real rejection;
}
model {
  rejection ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-return.stan
parameters {
  real returning;
}
model {
  returning ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-while.stan
parameters {
  real whiley;
}
model {
  whiley ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format lkj_cov_deprecation1.stan
parameters {
  cov_matrix[3] Sigma;
  vector[3] mu;
  vector[3] sigma;
  real<lower=0> eta;
}
model {
  Sigma ~ lkj_cov(mu, sigma, eta);
}

  $ ../../../../install/default/bin/stanc --auto-format lkj_cov_deprecation2.stan
parameters {
  cov_matrix[3] Sigma;
  vector[3] mu;
  vector[3] sigma;
  real<lower=0> eta;
}
model {
  increment_log_prob(lkj_cov_log(Sigma, mu, sigma, eta));
}

Warning in 'lkj_cov_deprecation2.stan', line 8, column 2: increment_log_prob(...); is deprecated and will be removed in the future. Use target += ...; instead.
  $ ../../../../install/default/bin/stanc --auto-format lower-trunc-discrete.stan
functions {
  real foo_lpmf(int y, real lambda) {
    return 1.0;
  }
  real foo_lcdf(int y, real lambda) {
    return 1.0;
  }
  real foo_lccdf(int y, real lambda) {
    return 1.0;
  }
  real bar_log(int y, real lambda) {
    return 1.0;
  }
  real bar_cdf_log(int y, real lambda) {
    return 1.0;
  }
  real bar_ccdf_log(int y, real lambda) {
    return 1.0;
  }
  real baz_lpdf(real y, real lambda) {
    return 1.0;
  }
  real baz_lcdf(real y, real lambda) {
    return 1.0;
  }
  real baz_lccdf(real y, real lambda) {
    return 1.0;
  }
  real quux_log(real y, real lambda) {
    return 1.0;
  }
  real quux_cdf_log(real y, real lambda) {
    return 1.0;
  }
  real quux_ccdf_log(real y, real lambda) {
    return 1.0;
  }
}
data {
  int N;
  array[N] int y;
  array[N] real u;
  int L;
  int U;
}
parameters {
  real<lower=0> lambda;
}
model {
  for (n in 1 : N) {
    y[n] ~ poisson(lambda) T[L, ];
    y[n] ~ poisson(lambda) T[L, U];
    y[n] ~ poisson(lambda) T[ , U];
    y[n] ~ foo(lambda) T[L, ];
    y[n] ~ foo(lambda) T[L, U];
    y[n] ~ foo(lambda) T[ , U];
    y[n] ~ bar(lambda) T[L, ];
    y[n] ~ bar(lambda) T[L, U];
    y[n] ~ bar(lambda) T[ , U];
    u[n] ~ normal(0, 1) T[L, ];
    u[n] ~ normal(0, 1) T[ , U];
    u[n] ~ normal(0, 1) T[L, U];
    y[n] ~ baz(lambda) T[L, ];
    y[n] ~ baz(lambda) T[L, U];
    y[n] ~ baz(lambda) T[ , U];
    y[n] ~ quux(lambda) T[L, ];
    y[n] ~ quux(lambda) T[L, U];
    y[n] ~ quux(lambda) T[ , U];
  }
}

  $ ../../../../install/default/bin/stanc --auto-format lp_in_fun.stan
functions {
  void foo_lp() {
    print("lp__ = ", get_lp());
  }
}
model {

}

Warning in 'lp_in_fun.stan', line 3, column 21: get_lp() function is deprecated. It will be removed in a future release. Use target() instead.
Warning in 'lp_in_fun.stan', line 3, column 21: The no-argument function `get_lp()` is deprecated. Use the no-argument function `target()` instead.
  $ ../../../../install/default/bin/stanc --auto-format lp_transformed_param.stan
functions {
  real test_lp(real r) {
    target += normal_lpdf(r| 0, 1);
    return r;
  }
  void nr_test_lp(real r) {
    target += normal_lpdf(r| 0, 1);
  }
}
parameters {
  real y;
}
transformed parameters {
  real alpha = test_lp(5.0);
  nr_test_lp(5.0);
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format map_rect.stan
functions {
  vector foo(vector shared_params, vector job_params, array[] real data_r,
             array[] int data_i) {
    return [1, 2, 3]';
  }
  real map_rectfake(real x) {
    return 2 * x;
  }
}
data {
  vector[3] shared_params_d;
  array[3] vector[3] job_params_d;
  array[3, 3] real data_r;
  array[3, 3] int data_i;
}
parameters {
  vector[3] shared_params_p;
  array[3] vector[3] job_params_p;
}
transformed parameters {
  real abc1_p = 3;
  real abc2_p = map_rectfake(abc1_p);
  real abc3_p = map_rectfake(12);
  vector[3] y_hat_tp1 = map_rect(foo, shared_params_p, job_params_d, data_r,
                                 data_i);
  vector[3] y_hat_tp2 = map_rect(foo, shared_params_d, job_params_p, data_r,
                                 data_i);
  vector[3] y_hat_tp3 = map_rect(foo, shared_params_p, job_params_d, data_r,
                                 data_i);
}
model {
  real abc_m = map_rectfake(abc1_p);
}
generated quantities {
  real abc1_gq = map_rectfake(12);
  real abc2_gq = map_rectfake(abc1_p);
  vector[3] y_hat_gq = map_rect(foo, shared_params_d, job_params_d, data_r,
                                data_i);
}

  $ ../../../../install/default/bin/stanc --auto-format mat_assign.stan
transformed data {
  matrix[2, 2] X;
  row_vector[2] y;
  y[1] = 10;
  y[2] = 100;
  X[1] = y;
  X[2] = y;
  print("X=", X);
}
parameters {
  real z;
}
transformed parameters {
  matrix[2, 2] Xvar;
  matrix[2, 2] Xvar2;
  row_vector[2] yvar;
  yvar[1] = 15.9;
  yvar[2] = 42.7;
  Xvar[1] = y;
  Xvar[2] = y;
  Xvar2[1] = yvar;
  Xvar2[2] = yvar;
}
model {
  z ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format min-max-types.stan
parameters {
  matrix[max(1, 3), min(2, 5)] a;
}
transformed parameters {
  real z;
  z = max(9, 10);
  z = min(9, 10);
}
model {
  int b;
  b = max(9, 10);
  to_vector(a) ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format model_block_empty.stan
functions {
  real foo(real x) {
    return x;
  }
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format multiple_funs.stan
functions {
  int foo(int a);
  int foo(int a) {
    return a;
  }
  int bar(int a) {
    return a;
  }
}
parameters {
  real theta;
}
model {
  theta ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format neg_binomial_2_log_glm_old_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  real<lower=0> sigma = 0.5;
  array[N] int<lower=0> y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = neg_binomial_2_log_rng((x * beta_true + alpha_true)[i], sigma);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  y ~ neg_binomial_2_log(x * beta_inferred + alpha_inferred, sigma);
}

Warning in 'neg_binomial_2_log_glm_old_performance.stan', line 11, column 19: Found int division:
  j / M
Values will be rounded towards zero. If rounding is not desired you can write
the division as
  j * 1.0 / M
If rounding is intended please use the integer division operator %/%.
  $ ../../../../install/default/bin/stanc --auto-format neg_binomial_2_log_glm_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  real<lower=0> sigma = 0.5;
  array[N] int<lower=0> y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = neg_binomial_2_log_rng((x * beta_true + alpha_true)[i], sigma);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  y ~ neg_binomial_2_log_glm(x, alpha_inferred, beta_inferred, sigma);
}

Warning in 'neg_binomial_2_log_glm_performance.stan', line 11, column 19: Found int division:
  j / M
Values will be rounded towards zero. If rounding is not desired you can write
the division as
  j * 1.0 / M
If rounding is intended please use the integer division operator %/%.
  $ ../../../../install/default/bin/stanc --auto-format new-prob-fun-suffixes.stan
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
  target += normal_lpdf(1| -1.5, 2.9);
  target += poisson_lpmf(2| 3);
  target += normal_lcdf(1| 2, 3);
  target += normal_lccdf(1| 2, 3);
  target += poisson_lcdf(1| 2);
  target += poisson_lccdf(1| 2);
}

  $ ../../../../install/default/bin/stanc --auto-format normal_id_glm_old_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  real<lower=0> sigma = 0.5;
  vector[N] y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = normal_rng((x * beta_true + alpha_true)[i], sigma);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  y ~ normal(x * beta_inferred + alpha_inferred, sigma);
}

Warning in 'normal_id_glm_old_performance.stan', line 11, column 19: Found int division:
  j / M
Values will be rounded towards zero. If rounding is not desired you can write
the division as
  j * 1.0 / M
If rounding is intended please use the integer division operator %/%.
  $ ../../../../install/default/bin/stanc --auto-format normal_id_glm_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  real<lower=0> sigma = 0.5;
  vector[N] y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = normal_rng((x * beta_true + alpha_true)[i], sigma);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  y ~ normal_id_glm(x, alpha_inferred, beta_inferred, sigma);
}

Warning in 'normal_id_glm_performance.stan', line 11, column 19: Found int division:
  j / M
Values will be rounded towards zero. If rounding is not desired you can write
the division as
  j * 1.0 / M
If rounding is intended please use the integer division operator %/%.
  $ ../../../../install/default/bin/stanc --auto-format nullary-unconflicted.stan
parameters {
  real e;
  real pi;
  real log2;
  real log10;
  real sqrt2;
  real not_a_number;
  real positive_infinity;
  real negative_infinity;
  real machine_precision;
  real inv_logit;
  real logit;
  real bernoulli_logit_glm_lpmf;
  real reduce_sum;
  real ode_bdf;
  real ode_bdf_tol;
}
transformed parameters {
  real mu;
  mu = e() + pi() + log2() + log10() + sqrt2() + not_a_number()
       + positive_infinity() + negative_infinity() + machine_precision(
       );
  mu += logit + bernoulli_logit_glm_lpmf + reduce_sum;
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format numeric-literal.stan
transformed data {
  int a = 0;
  int b = 10_000;
  real c = .12;
  real d = 1.;
  real e = 1.002_345;
  real f = .99_99_99e+1_25;
  real g = 1_100_100.0_345;
}

  $ ../../../../install/default/bin/stanc --auto-format ode-int-segments.stan
functions {
  array[] real ode(real t, array[] real y, array[] real theta,
                   array[] real x, array[] int x_int) {
    array[0] real dydt;
    return dydt;
  }
}
data {
  int<lower=1> T;
  real t0;
  array[0] real y0;
  array[T] real ts;
  array[T, 2] real y;
}
transformed data {
  array[0] real x;
  array[0] int x_int;
}
parameters {
  array[0] real theta;
}
transformed parameters {
  array[T, 2] real y_hat;
  {
    int N = 0;
    y_hat = integrate_ode(ode, y0, t0, segment(ts, 0, N), theta, x, x_int);
  }
}
model {

}

Warning in 'ode-int-segments.stan', line 25, column 12: integrate_ode is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../install/default/bin/stanc --auto-format ode-nested-quotes.stan
functions {
  array[] real foo(real t, array[] real y, array[] real theta,
                   array[] real x_r, array[] int x_i) {
    return rep_array(1.0, 1);
  }
}
transformed data {
  real y;
  array[2, 2] real t;
  y = integrate_ode(foo, rep_array(1.0, 1), 1.0, t[1], rep_array(1.0, 1),
                    rep_array(1.0, 1), rep_array(1, 1))[1, 1];
}
model {

}

Warning in 'ode-nested-quotes.stan', line 17, column 6: integrate_ode is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../install/default/bin/stanc --auto-format ode_good.stan
functions {
  array[] real harm_osc_ode(real t, array[] real y, array[] real theta,
                            array[] real x, array[] int x_int) {
    array[2] real dydt;
    dydt[1] = x[1] * y[2];
    dydt[2] = -y[1] - theta[1] * y[2];
    return dydt;
  }
}
data {
  array[2] real y0;
  real t0;
  array[10] real ts;
  array[1] real x;
  array[0] int x_int;
  array[10, 2] real y;
}
parameters {
  array[1] real theta;
  real<lower=0> sigma;
}
transformed parameters {
  array[10, 2] real y_hat;
  y_hat = integrate_ode(harm_osc_ode, y0, t0, ts, theta, x, x_int);
  y_hat = integrate_ode_rk45(harm_osc_ode, y0, t0, ts, theta, x, x_int);
  y_hat = integrate_ode_bdf(harm_osc_ode, y0, t0, ts, theta, x, x_int);
  y_hat = integrate_ode_adams(harm_osc_ode, y0, t0, ts, theta, x, x_int);
  y_hat = integrate_ode_rk45(harm_osc_ode, y0, t0, ts, theta, x, x_int, 0.01,
                             0.01, 10);
  y_hat = integrate_ode_bdf(harm_osc_ode, y0, t0, ts, theta, x, x_int, 0.01,
                            0.01, 10);
  y_hat = integrate_ode_adams(harm_osc_ode, y0, t0, ts, theta, x, x_int,
                              0.01, 0.01, 10);
}
model {
  for (t in 1 : 10) 
    y[t] ~ normal(y_hat[t], sigma);
}

Warning in 'ode_good.stan', line 27, column 10: integrate_ode is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'ode_good.stan', line 34, column 10: integrate_ode_rk45 is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'ode_good.stan', line 41, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'ode_good.stan', line 48, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'ode_good.stan', line 55, column 10: integrate_ode_rk45 is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'ode_good.stan', line 62, column 10: integrate_ode_bdf is deprecated and will be removed in the future. Use ode_bdf instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'ode_good.stan', line 69, column 10: integrate_ode_adams is deprecated and will be removed in the future. Use ode_adams instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../install/default/bin/stanc --auto-format old-log-funs.stan
transformed data {
  real x;
  x = multiply_log(x, x);
  x = binomial_coefficient_log(x, x);
  x = lmultiply(x, x);
  x = lchoose(x, x);
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

Warning in 'old-log-funs.stan', line 3, column 6: multiply_log is deprecated and will be removed in the future. Use lmultiply instead.
Warning in 'old-log-funs.stan', line 4, column 6: binomial_coefficient_log is deprecated and will be removed in the future. Use lchoose instead.
  $ ../../../../install/default/bin/stanc --auto-format poisson_log_glm_old_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  array[N] int<lower=0> y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = poisson_log_rng((x * beta_true + alpha_true)[i]);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  y ~ poisson_log(x * beta_inferred + alpha_inferred);
}

Warning in 'poisson_log_glm_old_performance.stan', line 10, column 19: Found int division:
  j / M
Values will be rounded towards zero. If rounding is not desired you can write
the division as
  j * 1.0 / M
If rounding is intended please use the integer division operator %/%.
  $ ../../../../install/default/bin/stanc --auto-format poisson_log_glm_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  array[N] int<lower=0> y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = poisson_log_rng((x * beta_true + alpha_true)[i]);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  y ~ poisson_log_glm(x, alpha_inferred, beta_inferred);
}

Warning in 'poisson_log_glm_performance.stan', line 10, column 19: Found int division:
  j / M
Values will be rounded towards zero. If rounding is not desired you can write
the division as
  j * 1.0 / M
If rounding is intended please use the integer division operator %/%.
  $ ../../../../install/default/bin/stanc --auto-format pound-comment-deprecated.stan
data {
  int N;
}
model {

}

Warning in 'pound-comment-deprecated.stan', line 2, column 2: Comments beginning with # are deprecated. Please use // in place of # for line comments.
  $ ../../../../install/default/bin/stanc --auto-format print_chars.stan
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
  print("a e z A R Z 0 4 9 / ~ ! @ # $ % ^ & * ( ) ` _ + - = { } | [ ] : ; ' < > ? , . / ");
}

  $ ../../../../install/default/bin/stanc --auto-format print_indexing.stan
data {
  array[2] int<lower=1> N;
  array[N[1]] int<lower=0> y_1;
  array[N[2]] int<lower=0> y_2;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format profiling.stan
data {
  int<lower=1> N;
  array[N] real x;
  vector[N] y;
}
transformed data {
  real sum_y;
  profile("sum") {
    sum_y = sum(y);
  }
}
parameters {
  real<lower=0> rho;
  real<lower=0> alpha;
  real<lower=0> sigma;
}
model {
  matrix[N, N] cov;
  matrix[N, N] L_cov;
  profile("cov_exp_quad") {
    cov = gp_exp_quad_cov(x, alpha, rho) + diag_matrix(rep_vector(sigma, N));
  }
  profile("cholesky_decompose") {
    L_cov = cholesky_decompose(cov);
  }
  profile("multi_normal_cholesky") {
    rho ~ gamma(25, 4);
    alpha ~ normal(0, 2);
    sigma ~ normal(0, 1);
    y ~ multi_normal_cholesky(rep_vector(0, N), L_cov);
  }
}

  $ ../../../../install/default/bin/stanc --auto-format prophet.stan
functions {
  array[,] real get_changepoint_matrix(array[] real t, array[] real t_change,
                                       int T, int S) {
    array[T, S] real A;
    array[S] real a_row;
    int cp_idx;
    A = rep_array(0, T, S);
    a_row = rep_array(0, S);
    cp_idx = 1;
    for (i in 1 : T) {
      while ((cp_idx <= S) && (t[i] >= t_change[cp_idx])) {
        a_row[cp_idx] = 1;
        cp_idx = cp_idx + 1;
      }
      A[i] = a_row;
    }
    return A;
  }
  array[] real logistic_gamma(real k, real m, array[] real delta,
                              array[] real t_change, int S) {
    array[S] real gamma;
    array[S + 1] real k_s;
    real m_pr;
    k_s[1] = k;
    for (i in 1 : S) {
      k_s[i + 1] = k_s[i] + delta[i];
    }
    m_pr = m;
    for (i in 1 : S) {
      gamma[i] = (t_change[i] - m_pr) * (1 - k_s[i] / k_s[i + 1]);
      m_pr = m_pr + gamma[i];
    }
    return gamma;
  }
  array[] real logistic_trend(real k, real m, array[] real delta,
                              array[] real t, array[] real cap,
                              array[,] real A, array[] real t_change, int S,
                              int T) {
    array[S] real gamma;
    array[T] real Y;
    gamma = logistic_gamma(k, m, delta, t_change, S);
    for (i in 1 : T) {
      Y[i] = cap[i]
             / (1
                + exp(-(k + dot_product(A[i], delta))
                      * (t[i] - (m + dot_product(A[i], gamma)))));
    }
    return Y;
  }
  array[] real linear_trend(real k, real m, array[] real delta,
                            array[] real t, array[,] real A,
                            array[] real t_change, int S, int T) {
    array[S] real gamma;
    array[T] real Y;
    for (i in 1 : S) {
      gamma[i] = -t_change[i] * delta[i];
    }
    for (i in 1 : T) {
      Y[i] = (k + dot_product(A[i], delta)) * t[i]
             + (m + dot_product(A[i], gamma));
    }
    return Y;
  }
}
data {
  int T;
  int<lower=1> K;
  array[T] real t;
  array[T] real cap;
  array[T] real y;
  int S;
  array[S] real t_change;
  array[T, K] real X;
  vector[K] sigmas;
  real<lower=0> tau;
  int trend_indicator;
  array[K] real s_a;
  array[K] real s_m;
}
transformed data {
  array[T, S] real A;
  A = get_changepoint_matrix(t, t_change, T, S);
}
parameters {
  real k;
  real m;
  array[S] real delta;
  real<lower=0> sigma_obs;
  array[K] real beta;
}
transformed parameters {
  array[T] real trend;
  array[T] real Y;
  array[K] real beta_m;
  array[K] real beta_a;
  if (trend_indicator == 0) {
    trend = linear_trend(k, m, delta, t, A, t_change, S, T);
  }
  else if (trend_indicator == 1) {
    trend = logistic_trend(k, m, delta, t, cap, A, t_change, S, T);
  }
  for (i in 1 : K) {
    beta_m[i] = beta[i] * s_m[i];
    beta_a[i] = beta[i] * s_a[i];
  }
  for (i in 1 : T) {
    Y[i] = (trend[i] * (1 + dot_product(X[i], beta_m))
            + dot_product(X[i], beta_a));
  }
}
model {
  k ~ normal(0, 5);
  m ~ normal(0, 5);
  delta ~ double_exponential(0, tau);
  sigma_obs ~ normal(0, 0.5);
  beta ~ normal(0, sigmas);
  y ~ normal(Y, sigma_obs);
}

  $ ../../../../install/default/bin/stanc --auto-format propto-good.stan
model {
  target += normal_lupdf(1| 0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format rng_loc.stan
functions {
  real foo_rng(real mu, real sigma) {
    return normal_rng(mu, sigma);
  }
}
transformed data {
  real y;
  y = normal_rng(0, 1);
}
parameters {

}
model {

}
generated quantities {
  real z;
  z = normal_rng(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format rng_transformed_data.stan
data {
  int<lower=0> N;
}
transformed data {
  vector[N] y;
  for (n in 1 : N) 
    y[n] = normal_rng(0, 1);
  print(y);
}
parameters {
  real mu;
  real<lower=0> sigma;
}
model {
  y ~ normal(mu, sigma);
}
generated quantities {
  real mean_y = mean(y);
  real sd_y = sd(y);
}

  $ ../../../../install/default/bin/stanc --auto-format single-arg-conddist.stan
functions {
  real foo_lpdf(real x) {
    return -square(x);
  }
  real goo_lpmf(int x) {
    return -square(x);
  }
}
data {
  int y;
}
parameters {
  real x;
}
model {
  target += std_normal_lpdf(x| );
  target += std_normal_lpdf(x| );
  target += std_normal_lupdf(x| );
  target += std_normal_lupdf(x| );
  target += foo_lpdf(x| );
  target += foo_lpdf(x| );
  target += goo_lpmf(y| );
  target += goo_lpmf(y| );
  target += goo_lupmf(y| );
  target += goo_lupmf(y| );
}

  $ ../../../../install/default/bin/stanc --auto-format stanc_helper.stan
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format tern_op_contains_var.stan
data {
  int N;
  int y_max;
  array[N] int<lower=0> y;
  array[N] int<lower=0, upper=1> group;
}
parameters {
  vector<lower=0, upper=1>[2] param;
}
model {
  to_vector(param) ~ uniform(0, 1);
  for (i in 1 : N) {
    y[i] ~ binomial(y_max, group[i] == 0 ? param[1] : param[2]);
  }
}

  $ ../../../../install/default/bin/stanc --auto-format truncation-user-defined.stan
functions {
  real foo_log(real y, real theta) {
    return 1;
  }
  real foo_cdf_log(real y, real theta) {
    return 1;
  }
  real foo_ccdf_log(real y, real theta) {
    return 1;
  }
}
data {
  real y;
}
parameters {
  real theta;
  real L;
  real U;
}
model {
  y ~ foo(theta) T[L, ];
  y ~ foo(theta) T[ , U];
  y ~ foo(theta) T[L, U];
}

  $ ../../../../install/default/bin/stanc --auto-format truncation-wild.stan
model {
  array[1, 1] real T = {{42.0}};
  1 ~ normal(0, 1) T[1, T[1, 1]];
  print(T[1, 1]);
}

  $ ../../../../install/default/bin/stanc --auto-format unconstrained_params_var.stan
parameters {
  real mu;
  real<lower=0> sigma;
}
model {
  1 ~ normal(mu, sigma);
  2 ~ normal(mu, sigma);
  3 ~ normal(mu, sigma);
}

  $ ../../../../install/default/bin/stanc --auto-format unnormalized_math_fun_lpdf.stan
functions {
  real foo_lpdf(real y1, real y2, vector vy1, vector vy2, matrix my1,
                matrix my2, array[] real ay1) {
    real r;
    r += beta_lupdf(y1| y2, y2);
    r += beta_proportion_lupdf(y1| y2, y2);
    r += cauchy_lupdf(y1| y2, y2);
    r += chi_square_lupdf(y1| y2);
    r += dirichlet_lupdf(vy1| vy2);
    r += double_exponential_lupdf(y1| y2, y2);
    r += exp_mod_normal_lupdf(y1| y2, y2, y2);
    r += exponential_lupdf(y1| y2);
    r += frechet_lupdf(y1| y2, y2);
    r += gamma_lupdf(y1| y2, y2);
    r += gaussian_dlm_obs_lupdf(my1| my2, my2, vy2, my2, vy2, my2);
    r += gumbel_lupdf(y1| y2, y2);
    r += inv_chi_square_lupdf(y1| y2);
    r += inv_gamma_lupdf(y1| y2, y2);
    r += inv_wishart_lupdf(my1| y2, my2);
    r += lkj_corr_cholesky_lupdf(my1| y2);
    r += lkj_corr_lupdf(my1| y2);
    r += logistic_lupdf(y1| y2, y2);
    r += lognormal_lupdf(y1| y2, y2);
    r += multi_gp_cholesky_lupdf(my1| my2, vy2);
    r += multi_gp_lupdf(my1| my2, vy2);
    r += multi_normal_cholesky_lupdf(vy1| vy2, my2);
    r += multi_normal_lupdf(vy1| vy2, my2);
    r += multi_normal_prec_lupdf(vy1| vy2, my2);
    r += multi_student_t_lupdf(vy1| y2, vy2, my2);
    r += normal_id_glm_lupdf(y1| my2, y2, vy2, vy2);
    r += normal_lupdf(y1| y2, y2);
    r += normal_lupdf(ay1| y2, y2);
    r += pareto_lupdf(y1| y2, y2);
    r += pareto_type_2_lupdf(y1| y2, y2, y2);
    r += rayleigh_lupdf(y1| y2);
    r += scaled_inv_chi_square_lupdf(y1| y2, y2);
    r += skew_normal_lupdf(y1| y2, y2, y2);
    r += std_normal_lupdf(y1| );
    r += student_t_lupdf(y1| y2, y2, y2);
    r += uniform_lupdf(y1| y2, y2);
    r += von_mises_lupdf(y1| y2, y2);
    r += weibull_lupdf(y1| y2, y2);
    r += wiener_lupdf(y1| y2, y2, y2, y2);
    r += wishart_lupdf(my1| y2, my2);
    return r;
  }
}
parameters {
  real y1;
  real y2;
  array[5] real ay1;
  vector[5] vy1;
  vector[5] vy2;
  matrix[5, 5] my1;
  matrix[5, 5] my2;
}
model {
  real r;
  r += beta_lupdf(y1| y2, y2);
  r += beta_proportion_lupdf(y1| y2, y2);
  r += cauchy_lupdf(y1| y2, y2);
  r += chi_square_lupdf(y1| y2);
  r += dirichlet_lupdf(vy1| vy2);
  r += double_exponential_lupdf(y1| y2, y2);
  r += exp_mod_normal_lupdf(y1| y2, y2, y2);
  r += exponential_lupdf(y1| y2);
  r += frechet_lupdf(y1| y2, y2);
  r += gamma_lupdf(y1| y2, y2);
  r += gaussian_dlm_obs_lupdf(my1| my2, my2, vy2, my2, vy2, my2);
  r += gumbel_lupdf(y1| y2, y2);
  r += inv_chi_square_lupdf(y1| y2);
  r += inv_gamma_lupdf(y1| y2, y2);
  r += inv_wishart_lupdf(my1| y2, my2);
  r += lkj_corr_cholesky_lupdf(my1| y2);
  r += lkj_corr_lupdf(my1| y2);
  r += logistic_lupdf(y1| y2, y2);
  r += lognormal_lupdf(y1| y2, y2);
  r += multi_gp_cholesky_lupdf(my1| my2, vy2);
  r += multi_gp_lupdf(my1| my2, vy2);
  r += multi_normal_cholesky_lupdf(vy1| vy2, my2);
  r += multi_normal_lupdf(vy1| vy2, my2);
  r += multi_normal_prec_lupdf(vy1| vy2, my2);
  r += multi_student_t_lupdf(vy1| y2, vy2, my2);
  r += normal_id_glm_lupdf(y1| my2, y2, vy2, vy2);
  r += normal_lupdf(y1| y2, y2);
  r += normal_lupdf(ay1| y2, y2);
  r += pareto_lupdf(y1| y2, y2);
  r += pareto_type_2_lupdf(y1| y2, y2, y2);
  r += rayleigh_lupdf(y1| y2);
  r += scaled_inv_chi_square_lupdf(y1| y2, y2);
  r += skew_normal_lupdf(y1| y2, y2, y2);
  r += std_normal_lupdf(y1| );
  r += student_t_lupdf(y1| y2, y2, y2);
  r += uniform_lupdf(y1| y2, y2);
  r += von_mises_lupdf(y1| y2, y2);
  r += weibull_lupdf(y1| y2, y2);
  r += wiener_lupdf(y1| y2, y2, y2, y2);
  r += wishart_lupdf(my1| y2, my2);
  r += foo_lupdf(y1| y2, vy1, vy2, my1, my2, ay1);
}

  $ ../../../../install/default/bin/stanc --auto-format unnormalized_math_fun_lpmf.stan
functions {
  real foo_lpmf(int i1, real r1, matrix m1, vector v1, array[] int ai1,
                row_vector rv1) {
    real r;
    r += bernoulli_logit_glm_lupmf(i1| m1, r1, v1);
    r += bernoulli_logit_lupmf(i1| r1);
    r += bernoulli_lupmf(i1| r1);
    r += beta_binomial_lupmf(i1| i1, r1, r1);
    r += binomial_logit_lupmf(i1| i1, r1);
    r += binomial_lupmf(i1| i1, r1);
    r += categorical_logit_glm_lupmf(i1| rv1, v1, m1);
    r += categorical_logit_lupmf(i1| v1);
    r += categorical_lupmf(i1| v1);
    r += hypergeometric_lupmf(i1| i1, i1, i1);
    r += multinomial_lupmf(ai1| v1);
    r += neg_binomial_2_log_glm_lupmf(i1| m1, r1, v1, r1);
    r += neg_binomial_2_log_lupmf(i1| r1, r1);
    r += neg_binomial_2_lupmf(i1| r1, r1);
    r += neg_binomial_lupmf(i1| r1, r1);
    r += ordered_logistic_glm_lupmf(i1| rv1, v1, v1);
    r += ordered_logistic_lupmf(i1| r1, v1);
    r += ordered_probit_lupmf(i1| r1, v1);
    r += poisson_log_glm_lupmf(i1| m1, r1, v1);
    r += poisson_log_lupmf(i1| r1);
    r += poisson_lupmf(i1| r1);
    return r;
  }
}
data {
  int i1;
  array[5] int ai1;
}
parameters {
  real r1;
  vector[5] v1;
  row_vector[5] rv1;
  matrix[5, 5] m1;
}
model {
  real r;
  r += bernoulli_logit_glm_lupmf(i1| m1, r1, v1);
  r += bernoulli_logit_lupmf(i1| r1);
  r += bernoulli_lupmf(i1| r1);
  r += beta_binomial_lupmf(i1| i1, r1, r1);
  r += binomial_logit_lupmf(i1| i1, r1);
  r += binomial_lupmf(i1| i1, r1);
  r += categorical_logit_glm_lupmf(i1| rv1, v1, m1);
  r += categorical_logit_lupmf(i1| v1);
  r += categorical_lupmf(i1| v1);
  r += hypergeometric_lupmf(i1| i1, i1, i1);
  r += multinomial_lupmf(ai1| v1);
  r += neg_binomial_2_log_glm_lupmf(i1| m1, r1, v1, r1);
  r += neg_binomial_2_log_lupmf(i1| r1, r1);
  r += neg_binomial_2_lupmf(i1| r1, r1);
  r += neg_binomial_lupmf(i1| r1, r1);
  r += ordered_logistic_glm_lupmf(i1| rv1, v1, v1);
  r += ordered_logistic_lupmf(i1| r1, v1);
  r += ordered_probit_lupmf(i1| r1, v1);
  r += poisson_log_glm_lupmf(i1| m1, r1, v1);
  r += poisson_log_lupmf(i1| r1);
  r += poisson_lupmf(i1| r1);
  r += foo_lupmf(i1| r1, m1, v1, ai1, rv1);
}

  $ ../../../../install/default/bin/stanc --auto-format unreserved-array-keyword.stan
functions {
  real f(array[,,] real array) {
    return array[1, 2, 3];
  }
}
model {
  real array;
  array[1, 2, 3] real abc;
}

  $ ../../../../install/default/bin/stanc --auto-format user-defined-lpdf-fun.stan
functions {
  real bar_lpmf(int y, real z) {
    return 1.0;
  }
  real bar_lcdf(int y, real z) {
    return 1.0;
  }
  real bar_lccdf(int y, real z) {
    return 1.0;
  }
  real foo_lpdf(real y, real sigma) {
    return 1.0;
  }
  real foo_lcdf(real y, real sigma) {
    return 1.0;
  }
  real foo_lccdf(real y, real sigma) {
    return 1.0;
  }
}
parameters {
  real y;
}
model {
  target += foo_lpdf(y| 7.0);
  target += foo_lcdf(y| 7.0);
  target += foo_lccdf(y| 7.0);
  target += normal_lpdf(y| 7.0, 1.0);
  target += normal_lcdf(y| 7.0, 1.0);
  target += normal_lccdf(y| 7.0, 1.0);
  target += bar_lpmf(2| 7.0);
  target += bar_lcdf(2| 7.0);
  target += bar_lccdf(2| 7.0);
  target += poisson_lpmf(2| 7.0);
  target += poisson_lcdf(2| 7.0);
  target += poisson_lccdf(2| 7.0);
}

  $ ../../../../install/default/bin/stanc --auto-format user-distro-truncate.stan
functions {
  real foo_lpdf(real y, real mu) {
    return -(y - mu) ^ 2;
  }
  real foo_lcdf(real y, real mu) {
    return -1.7;
  }
  real foo_lccdf(real y, real mu) {
    return -0.02;
  }
}
parameters {
  real<lower=1, upper=5> y;
  real mu;
}
model {
  y ~ foo(mu);
  y ~ foo(mu) T[1, ];
  y ~ foo(mu) T[ , 5];
  y ~ foo(mu) T[1, 5];
}

  $ ../../../../install/default/bin/stanc --auto-format validate_add_expression_dimss_good.stan
transformed data {
  real x;
  vector[3] v;
  x = v[1];
}
parameters {
  real y;
}
transformed parameters {
  real xt;
  vector[3] vt;
  xt = vt[1];
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_add_var_good.stan
data {
  int n;
  real x;
  array[3, 2] int nn;
  array[5, 2] real y;
  vector[3] v;
  row_vector[3] rv;
  simplex[5] sv;
  unit_vector[7] uv;
  ordered[3] ov;
  matrix[4, 5] m;
  cov_matrix[3] covm;
  corr_matrix[3] corrm;
}
transformed data {
  int n_td;
  real x_td;
  array[3, 2] int nn_td;
  array[5, 2] real y_td;
  vector[3] v_td;
  row_vector[3] rv_td;
  simplex[5] sv_td;
  unit_vector[7] uv_td;
  ordered[3] ov_td;
  matrix[4, 5] m_td;
  cov_matrix[3] covm_td;
  corr_matrix[3] corrm_td;
}
parameters {
  real x_p;
  array[5, 2] real y_p;
  vector[3] v_p;
  row_vector[3] rv_p;
  simplex[5] sv_p;
  unit_vector[7] uv_p;
  ordered[3] ov_p;
  matrix[4, 5] m_p;
  cov_matrix[3] covm_p;
  corr_matrix[3] corrm_p;
}
transformed parameters {
  real x_tp;
  array[5, 2] real y_tp;
  vector[3] v_tp;
  row_vector[3] rv_tp;
  simplex[5] sv_tp;
  unit_vector[7] uv_tp;
  ordered[3] ov_tp;
  matrix[4, 5] m_tp;
  cov_matrix[3] covm_tp;
  corr_matrix[3] corrm_tp;
}
model {
  int n_l;
  real x_l;
  array[3, 2] int nn_l;
  array[5, 2] real y_l;
  vector[3] v_l;
  row_vector[3] rv_l;
  matrix[4, 5] m_l;
  x_p ~ normal(0, 1);
}
generated quantities {
  int n_gq;
  real x_gq;
  array[3, 2] int nn_gq;
  array[5, 2] real y_gq;
  vector[3] v_gq;
  row_vector[3] rv_gq;
  simplex[5] sv_gq;
  unit_vector[7] uv_gq;
  ordered[3] ov_gq;
  matrix[4, 5] m_gq;
  cov_matrix[3] covm_gq;
  corr_matrix[3] corrm_gq;
}

  $ ../../../../install/default/bin/stanc --auto-format validate_bounds_comparison.stan
data {
  real<lower=if_else(1 < 2, -1, -2)> a;
  real<upper=if_else(1 < 2, -1, -2)> b;
  real<lower=(1 && 3), upper=if_else(1 < 2, -1, -2)> c;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

Warning in 'validate_bounds_comparison.stan', line 2, column 13: The function `if_else` is deprecated. Use the conditional operator (x ? y : z) instead.
Warning in 'validate_bounds_comparison.stan', line 3, column 13: The function `if_else` is deprecated. Use the conditional operator (x ? y : z) instead.
Warning in 'validate_bounds_comparison.stan', line 4, column 29: The function `if_else` is deprecated. Use the conditional operator (x ? y : z) instead.
  $ ../../../../install/default/bin/stanc --auto-format validate_conditional_op_good.stan
functions {
  real foo(real fa_x, int fa_y) {
    real fl_x;
    int fl_y;
    fl_x = 1 ? fl_x : fl_y;
    fl_y = 1 ? fl_y : 0;
    fl_x = 1 ? fa_x : fl_x;
    fl_y = 1 ? fa_y : fl_y;
    return 2.0;
  }
}
data {
  int x;
  real y;
  array[2] real ya1;
  array[2, 2] real ya2;
  vector[5] z;
  array[2] vector[5] za1;
  array[2, 2] vector[5] za2;
  row_vector[6] w;
  array[2] row_vector[6] wa1;
  array[2, 2] row_vector[6] wa2;
  matrix[5, 6] m;
  array[2] matrix[5, 6] ma1;
  array[2, 2] matrix[5, 6] ma2;
}
transformed data {
  int tx;
  real ty;
  vector[5] tza;
  vector[5] tzb;
  vector[5] tzc;
  row_vector[6] twa;
  row_vector[6] twb;
  row_vector[6] twc;
  matrix[5, 6] tma;
  matrix[5, 6] tmb;
  matrix[5, 6] tmc;
  array[2] int tx1;
  array[2] real tya1;
  array[2] real tyb1;
  array[2] real tyc1;
  array[2] vector[5] tza1;
  array[2] vector[5] tzb1;
  array[2] row_vector[6] twa1;
  array[2] row_vector[6] twb1;
  array[2] row_vector[6] twc1;
  array[2] matrix[5, 6] tm1;
  array[2, 3] int txa2;
  array[2, 3] int txb2;
  array[2, 3] int txc2;
  array[2, 2] real tya2;
  array[2, 2] real tyb2;
  array[2, 2] vector[5] tza2;
  array[2, 2] vector[5] tzb2;
  array[2, 2] vector[5] tzc2;
  array[2, 2] row_vector[6] twa2;
  array[2, 2] row_vector[6] twb2;
  array[2, 2] matrix[5, 6] tma2;
  array[2, 2] matrix[5, 6] tmb2;
  array[2, 2] matrix[5, 6] tmc2;
  tx = 1 ? 2 : 3;
  ty = 1 ? 2.0 : 3.0;
  tx = x < 100 ? x : 100;
  ty = y > 100 ? 100 : y;
  ty = y < 100 ? y : 100;
  ty = y < 100 ? y : ty;
  tzc = x < 100 ? tza : tzb;
  twc = x < 100 ? twa : twb;
  tmc = x < 100 ? tma : tmb;
  tx1 = x < 100 ? txa2[1] : txb2[2];
  txc2 = x < 100 ? txa2 : txb2;
  tyc1 = x < 100 ? tya1 : tyb1;
  tya2 = x < 100 ? tya2 : tyb2;
  twc1 = x < 100 ? twa1 : twb1;
  twa2 = x < 100 ? twa2 : twb2;
  tm1 = x < 100 ? tma2[1] : tmb2[1];
  tma2 = x < 100 ? tma2 : tmb2;
  {
    real abcd;
    abcd = 1 ? abcd : 2.0;
  }
}
parameters {
  real py;
  vector[5] pz;
  row_vector[6] pw;
  matrix[5, 6] pm;
  array[2] real pya1;
  array[2, 2] real pya2;
  array[2] vector[5] pza1;
  array[2, 2] vector[5] pza2;
  array[2] matrix[5, 6] pma1;
  array[2, 2] matrix[5, 6] pma2;
}
transformed parameters {
  real tpy;
  vector[5] tpza;
  vector[5] tpzb;
  vector[5] tpzc;
  row_vector[6] tpwa;
  row_vector[6] tpwb;
  row_vector[6] tpwc;
  matrix[5, 6] tpma;
  matrix[5, 6] tpmb;
  matrix[5, 6] tpmc;
  array[2] real tpya1;
  array[2] real tpyb1;
  array[2] real tpyc1;
  array[2] vector[5] tpza1;
  array[2] vector[5] tpzb1;
  array[2] row_vector[6] tpwa1;
  array[2] row_vector[6] tpwb1;
  array[2] row_vector[6] tpwc1;
  array[2] matrix[5, 6] tpm1;
  array[2, 2] real tpya2;
  array[2, 2] real tpyb2;
  array[2, 2] vector[5] tpza2;
  array[2, 2] vector[5] tpzb2;
  array[2, 2] vector[5] tpzc2;
  array[2, 2] row_vector[6] tpwa2;
  array[2, 2] row_vector[6] tpwb2;
  array[2, 2] matrix[5, 6] tpma2;
  array[2, 2] matrix[5, 6] tpmb2;
  array[2, 2] matrix[5, 6] tpmc2;
  tpy = y < 100 ? x : y;
  tpy = y < 100 ? y : x;
  tpy = y < 100 ? y : py;
  tpy = y < 100 ? x : py;
  tpzc = x < 100 ? tpza : tpzb;
  tpwc = x < 100 ? tpwa : tpwb;
  tpmc = x < 100 ? tpma : tpmb;
  tpzc = x < 100 ? z : pz;
  tpzc = x < 100 ? pz : z;
  tpwc = x < 100 ? w : pw;
  tpwc = x < 100 ? pw : w;
  tpmc = x < 100 ? m : pm;
  tpmc = x < 100 ? pm : m;
  tpyc1 = ya1;
  tpyc1 = x < 100 ? tpya1 : tpyb1;
  tpyc1 = x < 100 ? ya1 : pya1;
  tpyc1 = x < 100 ? pya1 : ya1;
  tpya2 = x < 100 ? tpya2 : tpyb2;
  tpya2 = x < 100 ? ya2 : tpyb2;
  tpya2 = x < 100 ? tpya2 : ya2;
  tpwc1 = x < 100 ? tpwa1 : tpwb1;
  tpwc1 = x < 100 ? wa1 : tpwb1;
  tpwc1 = x < 100 ? tpwb1 : wa1;
  tpwa2 = x < 100 ? tpwa2 : tpwb2;
  tpwa2 = x < 100 ? wa2 : tpwb2;
  tpwa2 = x < 100 ? tpwb2 : wa2;
  tpm1 = x < 100 ? tpma2[1] : tpmb2[1];
  tpm1 = x < 100 ? ma2[1] : tpmb2[1];
  tpm1 = x < 100 ? tpmb2[1] : ma2[1];
  tpma2 = x < 100 ? tpma2 : tpmb2;
  tpma2 = x < 100 ? ma2 : pma2;
  tpma2 = x < 100 ? pma2 : ma2;
  {
    real abcde;
    abcde = 1 ? abcde : 2.0;
  }
}
model {
  py ~ normal(0, 1);
  {
    real abcdefg;
    abcdefg = 1 ? abcdefg : 2.0;
  }
}
generated quantities {
  int gqx;
  real gqy;
  vector[5] gqza;
  vector[5] gqzb;
  vector[5] gqzc;
  gqy = y < 100 ? x : y;
  gqy = y < 100 ? y : x;
  gqzc = x < 100 ? gqza : gqzb;
  {
    real abcdef;
    abcdef = 1 ? abcdef : 2.0;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format validate_division_good.stan
transformed data {
  real u;
  matrix[3, 3] m;
  row_vector[3] v;
  u = 2.1 / 3;
  u = 2 / 3.1;
  u = 2.1 / 3.1;
  m = m / m;
  v = v / m;
}
parameters {
  real y;
}
transformed parameters {
  real xt;
  real ut;
  matrix[3, 3] mt;
  row_vector[3] vt;
  xt = 2 / 3;
  ut = 2.1 / 3;
  ut = 2 / 3.1;
  ut = 2.1 / 3.1;
  mt = mt / mt;
  vt = vt / mt;
}
model {
  y ~ normal(0, 1);
}

Warning in 'validate_division_good.stan', line 19, column 7: Found int division:
  2 / 3
Values will be rounded towards zero. If rounding is not desired you can write
the division as
  2.0 / 3
If rounding is intended please use the integer division operator %/%.
  $ ../../../../install/default/bin/stanc --auto-format validate_division_int_warning.stan
transformed data {
  real u;
  int j;
  int k;
  j = 2;
  k = 3;
  u = j / k;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

Warning in 'validate_division_int_warning.stan', line 7, column 6: Found int division:
  j / k
Values will be rounded towards zero. If rounding is not desired you can write
the division as
  j * 1.0 / k
If rounding is intended please use the integer division operator %/%.
  $ ../../../../install/default/bin/stanc --auto-format validate_elt_division_good.stan
transformed data {
  matrix[3, 3] m;
  vector[3] v;
  row_vector[3] rv;
  real c;
  m = m ./ m;
  m = m ./ c;
  m = c ./ m;
  v = v ./ v;
  v = c ./ v;
  v = v ./ c;
  rv = rv ./ rv;
  rv = c ./ rv;
  rv = rv ./ c;
}
parameters {
  real y;
}
transformed parameters {
  matrix[3, 3] mt;
  vector[3] vt;
  row_vector[3] rvt;
  real ct;
  mt = mt ./ mt;
  mt = mt ./ ct;
  mt = ct ./ mt;
  vt = vt ./ vt;
  vt = ct ./ vt;
  vt = vt ./ ct;
  rvt = rvt ./ rvt;
  rvt = ct ./ rvt;
  rvt = rvt ./ ct;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_elt_multiplication_good.stan
transformed data {
  matrix[3, 3] m;
  vector[3] v;
  row_vector[3] rv;
  m = m .* m;
  v = v .* v;
  rv = rv .* rv;
}
parameters {
  real y;
}
transformed parameters {
  matrix[3, 3] mt;
  vector[3] vt;
  row_vector[3] rvt;
  mt = mt .* mt;
  vt = vt .* vt;
  rvt = rvt .* rvt;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_exponentiation_good.stan
data {
  int i;
  int j;
  real x;
  real y;
}
transformed data {
  real z;
  z = x ^ y;
  z = x ^ j;
  z = j ^ x;
  z = i ^ j;
}
parameters {
  real a;
  real b;
}
transformed parameters {
  real z2;
  z2 = a * b;
  z2 = x ^ y;
  z2 = x ^ j;
  z2 = x ^ a;
  z2 = i ^ x;
  z2 = i ^ j;
  z2 = i ^ b;
  z2 = a ^ x;
  z2 = a ^ j;
  z2 = a ^ b;
}
model {
  a ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_exponentiation_precedence.stan
data {

}
transformed data {
  vector[3] a;
  vector[3] b;
  real c;
  int i;
  real x;
  a[1] = 2.1;
  a[2] = 2.2;
  a[3] = 2.3;
  b[1] = 2;
  b[2] = 3;
  b[3] = 4;
  i = 5;
  x = 6.66;
  c = a[1] ^ b[1];
  c = a[1] ^ x;
  c = a[1] ^ i;
  c = i ^ a[1];
  c = x ^ a[1];
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_functions.stan
functions {
  real my_fun(real x);
  real my_fun2(real x, real y);
  real my_fun3(data real x);
  real my_fun(real x) {
    return 2 * x;
  }
  real my_fun2(real x, real y) {
    return 2 * x;
  }
  real my_fun3(data real x) {
    return 2 * x;
  }
}
transformed data {
  real td_d1 = 1;
  real td_d2 = my_fun(td_d1);
  real td_d3 = my_fun2(td_d1, td_d2);
  td_d3 = my_fun3(my_fun2(td_d1, td_d2));
}
parameters {
  real p_d1;
}
transformed parameters {
  real tp_d1 = my_fun(p_d1);
  real tp_d2 = my_fun2(p_d1, tp_d1);
}
generated quantities {
  real gq_d1 = my_fun(p_d1);
  real gq_d2 = my_fun(gq_d1);
  gq_d2 = my_fun3(gq_d1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_int_divide_good.stan
data {
  int i;
  int j;
}
transformed data {
  int k;
  k = i %/% j;
}
parameters {
  real y;
}
model {
  int i2;
  int j2;
  int k2;
  k2 = i2 %/% j2;
  y ~ normal(0, 1);
}
generated quantities {
  int i3;
  int j3;
  int k3;
  k3 = i3 %/% j3;
}

  $ ../../../../install/default/bin/stanc --auto-format validate_int_expr2_good.stan
parameters {
  vector[10] y;
}
model {
  for (n in 1 : 10) 
    y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_jacobian_warning1.stan
parameters {
  real y;
}
model {
  log(y) ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_jacobian_warning2.stan
parameters {
  real y;
}
model {
  (y * y) ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_jacobian_warning3.stan
parameters {
  vector[5] v;
}
model {
  (v' * v) ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_jacobian_warning4.stan
parameters {
  real y;
}
model {
  1 + (y * y) ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_jacobian_warning5.stan
parameters {
  vector[10] y;
}
model {
  head((y .* y), 2) ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_jacobian_warning6.stan
parameters {
  real y;
}
model {
  -(y * y) ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_jacobian_warning_good.stan
data {
  int N;
  real x;
}
parameters {
  vector[3] v;
  array[4, 5] real a;
  matrix[6, 6] m;
  real y;
  real z;
}
model {
  1 ~ normal(y, 1);
  2.7 ~ normal(z, 1);
  y ~ normal(0, 1);
  m ~ lkj_corr(2.0);
  (m + m) ~ lkj_corr(2.0);
  (m - m) ~ lkj_corr(2.0);
  (v + v) ~ multi_normal(v, m);
  (v - v) ~ multi_normal(v, m);
  block(m, 1, 1, 1, 1) ~ lkj_corr(2.0);
  col(m, 1) ~ normal(0, 1);
  cols(m) ~ normal(0, 1);
  row(m, 1) ~ normal(0, 1);
  rows(m) ~ normal(0, 1);
  diagonal(m) ~ multi_normal(v, m);
  head(v, 2) ~ multi_normal(v, m);
  negative_infinity() ~ normal(0, 1);
  not_a_number() ~ normal(0, 1);
  rep_matrix(1, 3, 3) ~ lkj_corr(2.0);
  (v')' ~ multi_normal(v, m);
  positive_infinity() ~ normal(0, 1);
  segment(v, 2, 4) ~ normal(0, 1);
  sum(v) ~ normal(0, 1);
  tail(v, 3) ~ normal(0, 1);
  to_vector(m) ~ normal(0, 1);
  v[1] ~ normal(0, 1);
  m[1] ~ normal(0, 1);
  m[1, 2] ~ normal(0, 1);
  a[1, 2] ~ normal(0, 1);
  a[1][2] ~ normal(0, 1);
  y + z ~ normal(0, 1);
  y - z ~ normal(0, 1);
  1 * z ~ normal(0, 1);
  z * 1 ~ normal(0, 1);
  1 / (1 / z) ~ normal(0, 1);
  y + ((z / 2) * 3) ~ normal(0, 1);
  2.0 * 3 ~ normal(y, 1);
  (-y) ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_jacobian_warning_user.stan
parameters {
  vector[1] y;
}
model {
  exp(y[1]) ~ normal(0, 2);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_left_division_good.stan
transformed data {
  matrix[3, 3] m;
  vector[3] v;
  m = m \ m;
  v = m \ v;
}
parameters {
  real y;
}
transformed parameters {
  matrix[3, 3] mt;
  vector[3] vt;
  mt = mt \ mt;
  vt = mt \ vt;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_logical_negate_expr_good.stan
transformed data {
  int n;
  real x;
  n = !n;
  x = !x;
}
parameters {
  real y;
}
transformed parameters {
  real xt;
  xt = !xt;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_modulus_good.stan
data {
  int i;
  int j;
}
transformed data {
  int k;
  k = i % j;
}
parameters {
  real y;
}
model {
  int i2;
  int j2;
  int k2;
  k2 = i2 % j2;
  y ~ normal(0, 1);
}
generated quantities {
  int i3;
  int j3;
  int k3;
  k3 = i3 % j3;
}

  $ ../../../../install/default/bin/stanc --auto-format validate_multiplication.stan
transformed data {
  real x;
  x = 1.3;
  x = x * 2.7;
  x = x * x * x;
}
parameters {
  real y;
}
model {
  y ~ normal(x * 3, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_negate_expr_good.stan
transformed data {
  int n;
  real x;
  matrix[3, 3] m;
  vector[3] v;
  row_vector[3] rv;
  n = -n;
  x = -x;
  m = -m;
  v = -v;
  rv = -rv;
}
parameters {
  real y;
}
transformed parameters {
  real xt;
  matrix[3, 3] mt;
  vector[3] vt;
  row_vector[3] rvt;
  xt = -xt;
  mt = -mt;
  vt = -vt;
  rvt = -rvt;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_set_double_offset_multiplier_good.stan
transformed data {
  real<offset=2> a = 3;
}
parameters {
  array[2] matrix<offset=-412, multiplier=3>[3, 1] theta_;
  array[2] matrix<offset=-412, multiplier=3>[3, 1] theta;
  real<offset=1, multiplier=5> x;
  real<offset=42> w;
  vector<multiplier=242>[3] ww;
  row_vector<multiplier=242>[3] www;
}
transformed parameters {
  real<offset=23> y = x ^ 2;
}
model {
  y ~ normal(0, 1);
}
generated quantities {
  real<offset=1> z;
  z = 3;
}

  $ ../../../../install/default/bin/stanc --auto-format validate_set_double_range_lower_good.stan
data {
  real<lower=1.2> a;
  real<lower=1> b;
  real<lower=1.2, upper=2> c;
  real<lower=1, upper=1.2> d;
  real<lower=1.1, upper=1.2> e;
  real<lower=1, upper=2> f;
  real<lower=1, upper=2> g;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_set_double_range_upper_good.stan
data {
  real<upper=1.2> a;
  real<upper=1> b;
  real<lower=1.2, upper=2> c;
  real<lower=1, upper=1.2> d;
  real<lower=1.1, upper=1.2> e;
  real<lower=1, upper=2> f;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_set_fun_type_named_good.stan
transformed data {
  real x;
  x = exp(x);
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_set_int_range_lower_good.stan
data {
  int<lower=1> a;
  int<lower=1, upper=3> b;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_set_int_range_upper_good.stan
data {
  int<upper=1> a;
  int<lower=1, upper=3> b;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_validate_int_expr_good.stan
data {
  vector[3] a;
  row_vector[3] b;
  matrix[3, 3] c;
  unit_vector[3] d;
  simplex[3] e;
  ordered[3] f;
  positive_ordered[3] g;
  cholesky_factor_cov[4, 5] h;
  cholesky_factor_cov[3] j;
  cov_matrix[3] k;
  corr_matrix[3] l;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format var-decl-after-statement.stan
transformed data {
  real y;
  y = 3;
  real z;
  z = 3;
}
model {

}

  $ ../../../../install/default/bin/stanc --auto-format var-decls-in-functions.stan
functions {
  array[] real harm_osc_ode(real t, array[] real y, array[] real theta,
                            array[] real x, array[] int x_int) {
    array[size(y)] real dydt;
    return dydt;
  }
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format var-ending-lpdf.stan
parameters {
  real mu_lpdf;
}
model {
  target += mu_lpdf;
}

  $ ../../../../install/default/bin/stanc --auto-format vars-with-type-prefixes.stan
parameters {
  real int_x;
  real real_x;
  real vector_x;
  real row_vector_x;
  real matrix_x;
  real unit_vector_x;
  real simplex_x;
  real ordered_x;
  real positive_ordered_x;
  real cholesky_factor_cov_x;
  real cholesky_factor_corr_x;
  real cov_matrix_x;
  real corr_matrix_x;
}
model {
  int_x ~ normal(0, 1);
  real_x ~ normal(0, 1);
  vector_x ~ normal(0, 1);
  row_vector_x ~ normal(0, 1);
  matrix_x ~ normal(0, 1);
  unit_vector_x ~ normal(0, 1);
  simplex_x ~ normal(0, 1);
  ordered_x ~ normal(0, 1);
  positive_ordered_x ~ normal(0, 1);
  cholesky_factor_cov_x ~ normal(0, 1);
  cholesky_factor_corr_x ~ normal(0, 1);
  cov_matrix_x ~ normal(0, 1);
  corr_matrix_x ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format vector-size-stmts.stan
functions {
  void test_vector(int vlen1, int vlen2, int arrlen) {
    vector[vlen1] lf1;
    array[arrlen] vector[vlen2] lf2;
  }
  void test_row_vector(int vlen1, int vlen2, int arrlen) {
    row_vector[vlen1] lf1;
    array[arrlen] row_vector[vlen2] lf2;
  }
  void test_matrix(int nrow1, int ncol1, int nrow2, int ncol2, int arrlen) {
    matrix[nrow1, ncol1] lf1;
    array[arrlen] matrix[nrow2, ncol2] lf2;
  }
}
data {
  int veclen;
  int arrlen;
  int nrows;
  int ncols;
  array[arrlen] real d_real_ar;
  vector[veclen] d_v;
  array[arrlen] vector[veclen] d_v_ar;
  row_vector[veclen] d_rv;
  array[arrlen] row_vector[veclen] d_rv_ar;
  matrix[nrows, ncols] d_m;
  array[arrlen] matrix[nrows, ncols] d_m_ar;
}
transformed data {
  array[arrlen] real td_real_ar = d_real_ar;
  vector[veclen] td_v = d_v;
  array[arrlen] vector[veclen] td_v_ar = d_v_ar;
  row_vector[veclen] td_rv = d_rv;
  array[arrlen] row_vector[veclen] td_rv_ar = d_rv_ar;
  matrix[nrows, ncols] td_m = d_m;
  array[arrlen] matrix[nrows, ncols] td_m_ar = d_m_ar;
  {
    array[arrlen] real local_real_ar = d_real_ar;
    vector[veclen] local_v = d_v;
    array[arrlen] vector[veclen] local_v_ar = d_v_ar;
    row_vector[veclen] local_rv = d_rv;
    array[arrlen] row_vector[veclen] local_rv_ar = d_rv_ar;
    matrix[nrows, ncols] local_m = d_m;
    array[arrlen] matrix[nrows, ncols] local_m_ar = d_m_ar;
  }
}
parameters {
  array[2] real<lower=-10, upper=10> y;
  array[arrlen] real p_real_ar;
  vector[veclen] p_v1;
  array[arrlen] vector[veclen] p_v_ar;
  row_vector[veclen] p_rv;
  array[arrlen] row_vector[veclen] p_rv_ar;
  matrix[nrows, ncols] p_m;
  array[arrlen] matrix[nrows, ncols] p_m_ar;
}
transformed parameters {
  array[arrlen] real tp_real_ar = td_real_ar;
  vector[veclen] tp_v1 = d_v;
  array[arrlen] vector[veclen] tp_v_ar4 = d_v_ar;
  row_vector[veclen] tp_rv = d_rv;
  array[arrlen] row_vector[veclen] tp_rv_ar = d_rv_ar;
  matrix[nrows, ncols] tp_m = d_m;
  array[arrlen] matrix[nrows, ncols] tp_m_ar = d_m_ar;
  {
    array[arrlen] real local2_real_ar = d_real_ar;
    vector[veclen] local2_v = d_v;
    array[arrlen] vector[veclen] local2_v_ar = d_v_ar;
    row_vector[veclen] local2_rv = d_rv;
    array[arrlen] row_vector[veclen] local2_rv_ar = d_rv_ar;
    matrix[nrows, ncols] local2_m = d_m;
    array[arrlen] matrix[nrows, ncols] local2_m_ar = d_m_ar;
  }
}
model {
  array[arrlen] real local3_real_ar = d_real_ar;
  vector[veclen] local3_v = d_v;
  array[arrlen] vector[veclen] local3_v_ar = d_v_ar;
  row_vector[veclen] local3_rv = d_rv;
  array[arrlen] row_vector[veclen] local3_rv_ar = d_rv_ar;
  matrix[nrows, ncols] local3_m = d_m;
  array[arrlen] matrix[nrows, ncols] local3_m_ar = d_m_ar;
  y ~ normal(0, 1);
}
generated quantities {
  array[arrlen] real gq_real_ar = td_real_ar;
  vector[veclen] gq_v1 = d_v;
  array[arrlen] vector[veclen] gq_v_ar4 = d_v_ar;
  row_vector[veclen] gq_rv = d_rv;
  array[arrlen] row_vector[veclen] gq_rv_ar = d_rv_ar;
  matrix[nrows, ncols] gq_m = d_m;
  array[arrlen] matrix[nrows, ncols] gq_m_ar = d_m_ar;
  {
    array[arrlen] real local4_real_ar = d_real_ar;
    vector[veclen] local4_v = d_v;
    array[arrlen] vector[veclen] local4_v_ar = d_v_ar;
    row_vector[veclen] local4_rv = d_rv;
    array[arrlen] row_vector[veclen] local4_rv_ar = d_rv_ar;
    matrix[nrows, ncols] local4_m = d_m;
    array[arrlen] matrix[nrows, ncols] local4_m_ar = d_m_ar;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format vector-zero.stan
data {
  vector[0] d_v;
  row_vector[0] d_rv;
  matrix[0, 2] d_m1;
  matrix[3, 0] d_m2;
  matrix[0, 0] d_m12;
  array[0] real d_r1;
  array[0, 4] real d_r2a;
  array[2, 0] real d_r2b;
  array[0, 0] real d_r2c;
  array[0] int d_i1;
  array[4, 0] int d_i2a;
  array[0, 3] int d_i2b;
  array[0, 0] int d_i2c;
}
transformed data {
  vector[0] td_v;
  row_vector[0] td_rv;
  matrix[0, 2] td_m1;
  matrix[3, 0] td_m2;
  matrix[0, 0] td_m12;
  array[0] real td_r1;
  array[0, 4] real td_r2a;
  array[2, 0] real td_r2b;
  array[0, 0] real td_r2c;
  array[0] int td_i1;
  array[4, 0] int td_i2a;
  array[0, 3] int td_i2b;
  array[0, 0] int td_i2c;
}
parameters {
  vector[0] p_v;
  row_vector[0] p_rv;
  matrix[0, 2] p_m1;
  matrix[3, 0] p_m2;
  matrix[0, 0] p_m12;
  array[0] real p_r1;
  array[0, 4] real p_r2a;
  array[2, 0] real p_r2b;
  array[0, 0] real p_r2c;
}
transformed parameters {
  vector[0] tp_v;
  row_vector[0] tp_rv;
  matrix[0, 2] tp_m1;
  matrix[3, 0] tp_m2;
  matrix[0, 0] tp_m12;
  array[0] real tp_r1;
  array[0, 4] real tp_r2a;
  array[2, 0] real tp_r2b;
  array[0, 0] real tp_r2c;
}
model {

}
generated quantities {
  vector[0] gq_v;
  row_vector[0] gq_rv;
  matrix[0, 2] gq_m1;
  matrix[3, 0] gq_m2;
  matrix[0, 0] gq_m12;
  array[0] real gq_r1;
  array[0, 4] real gq_r2a;
  array[2, 0] real gq_r2b;
  array[0, 0] real gq_r2c;
  array[0] int gq_i1;
  array[4, 0] int gq_i2a;
  array[0, 3] int gq_i2b;
  array[0, 0] int gq_i2c;
}

  $ ../../../../install/default/bin/stanc --auto-format vector_size_lt_zero.stan
data {
  int d;
}
parameters {
  vector[d] p_ltzero;
}
model {

}

