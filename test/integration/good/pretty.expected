  $ ../../../../install/default/bin/stanc --auto-format algebra_solver_good.stan
functions {
  real algebra_solverfake(real x) {
    return 2 * x;
  }
  vector algebra_system(vector x, vector y, array[] real dat,
                        array[] int dat_int) {
    vector[2] f_x;
    f_x[1] = x[1] - y[1];
    f_x[2] = x[2] - y[2];
    return f_x;
  }
}
data {
  
}
transformed data {
  vector[2] x;
  vector[2] y;
  array[0] real dat;
  array[0] int dat_int;
  vector[2] theta;
  
  theta = algebra_solver(algebra_system, x, y, dat, dat_int);
  theta = algebra_solver(algebra_system, x, y, dat, dat_int, 0.01, 0.01, 10);
}
parameters {
  vector[2] x_p;
  vector[2] y_p;
  real dummy_parameter;
}
transformed parameters {
  real abc_tp = algebra_solverfake(2.9);
  vector[2] theta_p;
  
  theta_p = algebra_solver(algebra_system, x, y, dat, dat_int);
  theta_p = algebra_solver(algebra_system, x, y, dat, dat_int, 0.01, 0.01,
                           10);
  
  theta_p = algebra_solver(algebra_system, x, y_p, dat, dat_int);
  theta_p = algebra_solver(algebra_system, x, y_p, dat, dat_int, 0.01, 0.01,
                           10);
  
  theta_p = algebra_solver(algebra_system, x_p, y, dat, dat_int);
  theta_p = algebra_solver(algebra_system, x_p, y, dat, dat_int, 0.01, 0.01,
                           10);
  
  theta_p = algebra_solver(algebra_system, x_p, y_p, dat, dat_int);
  theta_p = algebra_solver(algebra_system, x_p, y_p, dat, dat_int, 0.01,
                           0.01, 10);
}
model {
  dummy_parameter ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format algebra_solver_newton_good.stan
functions {
  real algebra_solverfake(real x) {
    return 2 * x;
  }
  vector algebra_system(vector x, vector y, array[] real dat,
                        array[] int dat_int) {
    vector[2] f_x;
    f_x[1] = x[1] - y[1];
    f_x[2] = x[2] - y[2];
    return f_x;
  }
}
data {
  
}
transformed data {
  vector[2] x;
  vector[2] y;
  array[0] real dat;
  array[0] int dat_int;
  vector[2] theta;
  
  theta = algebra_solver_newton(algebra_system, x, y, dat, dat_int);
  theta = algebra_solver_newton(algebra_system, x, y, dat, dat_int, 0.01,
                                0.01, 10);
}
parameters {
  vector[2] x_p;
  vector[2] y_p;
  real dummy_parameter;
}
transformed parameters {
  real abc_tp = algebra_solverfake(2.9);
  vector[2] theta_p;
  
  theta_p = algebra_solver_newton(algebra_system, x, y, dat, dat_int);
  theta_p = algebra_solver_newton(algebra_system, x, y, dat, dat_int, 0.01,
                                  0.01, 10);
  
  theta_p = algebra_solver_newton(algebra_system, x, y_p, dat, dat_int);
  theta_p = algebra_solver_newton(algebra_system, x, y_p, dat, dat_int, 0.01,
                                  0.01, 10);
  
  theta_p = algebra_solver_newton(algebra_system, x_p, y, dat, dat_int);
  theta_p = algebra_solver_newton(algebra_system, x_p, y, dat, dat_int, 0.01,
                                  0.01, 10);
  
  theta_p = algebra_solver_newton(algebra_system, x_p, y_p, dat, dat_int);
  theta_p = algebra_solver_newton(algebra_system, x_p, y_p, dat, dat_int,
                                  0.01, 0.01, 10);
}
model {
  dummy_parameter ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format assignment-new.stan
transformed data {
  real mu;
  real<lower=0> sigma;
  mu = -1;
  sigma = 3;
}
parameters {
  real y;
}
model {
  y ~ normal(mu, sigma);
}

  $ ../../../../install/default/bin/stanc --auto-format assignment_double_index_lhs.stan
transformed data {
  array[109, 307] real a;
  array[17] vector[5] b;
  array[17] row_vector[5] c;
  matrix[15, 27] d;
  
  array[12, 12, 12] real aa;
  array[12, 12] vector[5] bb;
  array[12, 12] row_vector[5] cc;
  array[12] matrix[5, 12] dd;
  
  a[1][1] = 118.22;
  b[1][1] = 13;
  c[1][1] = 0;
  d[1][1] = 12;
  
  aa[1][1][1] = 118.22;
  bb[1][1][1] = 13;
  cc[1][1][1] = 0;
  dd[1][1][1] = 12;
}
parameters {
  real y;
}
transformed parameters {
  array[109, 307] real ap;
  array[17] vector[5] bp;
  array[17] row_vector[5] cp;
  matrix[15, 27] dp;
  
  array[12, 12, 12] real aap;
  array[12, 12] vector[5] bbp;
  array[12, 12] row_vector[5] ccp;
  array[12] matrix[5, 12] ddp;
  
  ap[1][1] = 118.22;
  bp[1][1] = 13;
  cp[1][1] = 0;
  dp[1][1] = 12;
  
  aap[1][1][1] = 118.22;
  bbp[1][1][1] = 13;
  ccp[1][1][1] = 0;
  ddp[1][1][1] = 12;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format assignments.stan
data {
  real x;
  vector[5] y;
  row_vector[6] z;
  matrix[5, 6] m;
  
  array[2] real x1;
  array[2] vector[5] y1;
  array[2] row_vector[6] z1;
  array[2] matrix[5, 6] m1;
  
  array[2, 3] real x2;
  array[2, 3] vector[5] y2;
  array[2, 3] row_vector[6] z2;
  array[2, 3] matrix[5, 6] m2;
  
  array[2, 3, 4] real x3;
  array[2, 3, 4] vector[5] y3;
  array[2, 3, 4] row_vector[6] z3;
  array[2, 3, 4] matrix[5, 6] m3;
}
transformed data {
  real tx;
  vector[5] ty;
  row_vector[6] tz;
  matrix[5, 6] tm;
  
  array[2] real tx1;
  array[2] vector[5] ty1;
  array[2] row_vector[6] tz1;
  array[2] matrix[5, 6] tm1;
  
  array[2, 3] real tx2;
  array[2, 3] vector[5] ty2;
  array[2, 3] row_vector[6] tz2;
  array[2, 3] matrix[5, 6] tm2;
  
  array[2, 3, 4] real tx3;
  array[2, 3, 4] vector[5] ty3;
  array[2, 3, 4] row_vector[6] tz3;
  array[2, 3, 4] matrix[5, 6] tm3;
  
  tx = x;
  tx = y[1];
  tx = z[1];
  tx = m[1, 2];
  
  tx = x1[1];
  tx = y1[1, 1];
  tx = z1[1, 1];
  tx = m1[1, 1, 2];
  
  tx = x2[1, 1];
  tx = y2[1, 1, 1];
  tx = z2[1, 1, 1];
  tx = m2[1, 1, 1, 2];
  
  tx = x3[1, 1, 1];
  tx = y3[1, 1, 1, 1];
  tx = z3[1, 1, 1, 1];
  tx = m3[1, 1, 1, 1, 2];
  
  tx1[1] = x;
  tx1[1] = y[1];
  tx1[1] = z[1];
  tx1[1] = m[1, 2];
  
  tx1[1] = x1[1];
  tx1[1] = y1[1, 1];
  tx1[1] = z1[1, 1];
  tx1[1] = m1[1, 1, 2];
  
  tx1[1] = x2[1, 1];
  tx1[1] = y2[1, 1, 1];
  tx1[1] = z2[1, 1, 1];
  tx1[1] = m2[1, 1, 1, 2];
  
  tx1[1] = x3[1, 1, 1];
  tx1[1] = y3[1, 1, 1, 1];
  tx1[1] = z3[1, 1, 1, 1];
  tx1[1] = m3[1, 1, 1, 1, 2];
  
  tx2[1, 1] = x;
  tx2[1, 1] = y[1];
  tx2[1, 1] = z[1];
  tx2[1, 1] = m[1, 2];
  
  tx2[1, 1] = x1[1];
  tx2[1, 1] = y1[1, 1];
  tx2[1, 1] = z1[1, 1];
  tx2[1, 1] = m1[1, 1, 2];
  
  tx2[1, 1] = x2[1, 1];
  tx2[1, 1] = y2[1, 1, 1];
  tx2[1, 1] = z2[1, 1, 1];
  tx2[1, 1] = m2[1, 1, 1, 2];
  
  tx2[1, 1] = x3[1, 1, 1];
  tx2[1, 1] = y3[1, 1, 1, 1];
  tx2[1, 1] = z3[1, 1, 1, 1];
  tx2[1, 1] = m3[1, 1, 1, 1, 2];
  
  tx3[1, 1, 1] = x;
  tx3[1, 1, 1] = y[1];
  tx3[1, 1, 1] = z[1];
  tx3[1, 1, 1] = m[1, 2];
  
  tx3[1, 1, 1] = x1[1];
  tx3[1, 1, 1] = y1[1, 1];
  tx3[1, 1, 1] = z1[1, 1];
  tx3[1, 1, 1] = m1[1, 1, 2];
  
  tx3[1, 1, 1] = x2[1, 1];
  tx3[1, 1, 1] = y2[1, 1, 1];
  tx3[1, 1, 1] = z2[1, 1, 1];
  tx3[1, 1, 1] = m2[1, 1, 1, 2];
  
  tx3[1, 1, 1] = x3[1, 1, 1];
  tx3[1, 1, 1] = y3[1, 1, 1, 1];
  tx3[1, 1, 1] = z3[1, 1, 1, 1];
  tx3[1, 1, 1] = m3[1, 1, 1, 1, 2];
  
  ty = y;
  ty = y1[1];
  ty = y2[1, 1];
  ty = y3[1, 1, 1];
  ty = col(m, 1);
  ty = col(m1[1], 1);
  ty = col(m2[1, 1], 1);
  ty = col(m3[1, 1, 1], 1);
  
  ty1[1] = y;
  ty1[1] = y1[1];
  ty1[1] = y2[1, 1];
  ty1[1] = y3[1, 1, 1];
  ty1[1] = col(m, 1);
  ty1[1] = col(m1[1], 1);
  ty1[1] = col(m2[1, 1], 1);
  ty1[1] = col(m3[1, 1, 1], 1);
  
  ty2[1, 1] = y;
  ty2[1, 1] = y1[1];
  ty2[1, 1] = y2[1, 1];
  ty2[1, 1] = y3[1, 1, 1];
  ty2[1, 1] = col(m, 1);
  ty2[1, 1] = col(m1[1], 1);
  ty2[1, 1] = col(m2[1, 1], 1);
  ty2[1, 1] = col(m3[1, 1, 1], 1);
  
  ty3[1, 1, 1] = y;
  ty3[1, 1, 1] = y1[1];
  ty3[1, 1, 1] = y2[1, 1];
  ty3[1, 1, 1] = y3[1, 1, 1];
  ty3[1, 1, 1] = col(m, 1);
  ty3[1, 1, 1] = col(m1[1], 1);
  ty3[1, 1, 1] = col(m2[1, 1], 1);
  ty3[1, 1, 1] = col(m3[1, 1, 1], 1);
  
  tz = z;
  tz = z1[1];
  tz = z2[1, 1];
  tz = z3[1, 1, 1];
  tz = row(m, 1);
  tz = row(m1[1], 1);
  tz = row(m2[1, 1], 1);
  tz = row(m3[1, 1, 1], 1);
  tz = m[1];
  tz = m1[1, 1];
  tz = m2[1, 1, 1];
  tz = m3[1, 1, 1, 1];
  
  tz1[1] = z;
  tz1[1] = z1[1];
  tz1[1] = z2[1, 1];
  tz1[1] = z3[1, 1, 1];
  tz1[1] = row(m, 1);
  tz1[1] = row(m1[1], 1);
  tz1[1] = row(m2[1, 1], 1);
  tz1[1] = row(m3[1, 1, 1], 1);
  tz1[1] = m[1];
  tz1[1] = m1[1, 1];
  tz1[1] = m2[1, 1, 1];
  tz1[1] = m3[1, 1, 1, 1];
  
  tz2[1, 1] = z;
  tz2[1, 1] = z1[1];
  tz2[1, 1] = z2[1, 1];
  tz2[1, 1] = z3[1, 1, 1];
  tz2[1, 1] = row(m, 1);
  tz2[1, 1] = row(m1[1], 1);
  tz2[1, 1] = row(m2[1, 1], 1);
  tz2[1, 1] = row(m3[1, 1, 1], 1);
  tz2[1, 1] = m[1];
  tz2[1, 1] = m1[1, 1];
  tz2[1, 1] = m2[1, 1, 1];
  tz2[1, 1] = m3[1, 1, 1, 1];
  
  tz3[1, 1, 1] = z;
  tz3[1, 1, 1] = z1[1];
  tz3[1, 1, 1] = z2[1, 1];
  tz3[1, 1, 1] = z3[1, 1, 1];
  tz3[1, 1, 1] = row(m, 1);
  tz3[1, 1, 1] = row(m1[1], 1);
  tz3[1, 1, 1] = row(m2[1, 1], 1);
  tz3[1, 1, 1] = row(m3[1, 1, 1], 1);
  tz3[1, 1, 1] = m[1];
  tz3[1, 1, 1] = m1[1, 1];
  tz3[1, 1, 1] = m2[1, 1, 1];
  tz3[1, 1, 1] = m3[1, 1, 1, 1];
  
  tm = m;
  tm = m1[1];
  tm = m2[1, 1];
  tm = m3[1, 1, 1];
  
  tm1[1] = m;
  tm1[1] = m1[1];
  tm1[1] = m2[1, 1];
  tm1[1] = m3[1, 1, 1];
  
  tm2[1, 1] = m;
  tm2[1, 1] = m1[1];
  tm2[1, 1] = m2[1, 1];
  tm2[1, 1] = m3[1, 1, 1];
  
  tm3[1, 1, 1] = m;
  tm3[1, 1, 1] = m1[1];
  tm3[1, 1, 1] = m2[1, 1];
  tm3[1, 1, 1] = m3[1, 1, 1];
  
  tx1 = x1;
  tx1 = x2[1];
  tx1 = x3[1, 1];
  
  tx2[1] = x1;
  tx2[1] = x2[1];
  tx2[1] = x3[1, 1];
  
  tx3[1, 1] = x1;
  tx3[1, 1] = x2[1];
  tx3[1, 1] = x3[1, 1];
  
  ty1 = y1;
  ty1 = y2[1];
  ty1 = y3[1, 1];
  
  ty2[1] = y1;
  ty2[1] = y2[1];
  ty2[1] = y3[1, 1];
  
  ty3[1, 1] = y1;
  ty3[1, 1] = y2[1];
  ty3[1, 1] = y3[1, 1];
  
  tz1 = z1;
  tz1 = z2[1];
  tz1 = z3[1, 1];
  
  tz2[1] = z1;
  tz2[1] = z2[1];
  tz2[1] = z3[1, 1];
  
  tz3[1, 1] = z1;
  tz3[1, 1] = z2[1];
  tz3[1, 1] = z3[1, 1];
  
  tm1 = m1;
  tm1 = m2[1];
  tm1 = m3[1, 1];
  
  tm2[1] = m1;
  tm2[1] = m2[1];
  tm2[1] = m3[1, 1];
  
  tm3[1, 1] = m1;
  tm3[1, 1] = m2[1];
  tm3[1, 1] = m3[1, 1];
  
  tx2 = x2;
  tx2 = x3[1];
  
  tx3[1] = x2;
  tx3[1] = x3[1];
  
  ty2 = y2;
  ty2 = y3[1];
  
  ty3[1] = y2;
  ty3[1] = y3[1];
  
  tz2 = z2;
  tz2 = z3[1];
  
  tz3[1] = z2;
  tz3[1] = z3[1];
  
  tm2 = m2;
  tm2 = m3[1];
  
  tm3[1] = m2;
  tm3[1] = m3[1];
  
  tx3 = x3;
  
  ty3 = y3;
  
  tz3 = z3;
  
  tm3 = m3;
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format assignments_double_var.stan
data {
  real x;
  vector[5] y;
  row_vector[6] z;
  matrix[5, 6] m;
  
  array[2] real x1;
  array[2] vector[5] y1;
  array[2] row_vector[6] z1;
  array[2] matrix[5, 6] m1;
  
  array[2, 3] real x2;
  array[2, 3] vector[5] y2;
  array[2, 3] row_vector[6] z2;
  array[2, 3] matrix[5, 6] m2;
  
  array[2, 3, 4] real x3;
  array[2, 3, 4] vector[5] y3;
  array[2, 3, 4] row_vector[6] z3;
  array[2, 3, 4] matrix[5, 6] m3;
}
transformed parameters {
  real tx;
  vector[5] ty;
  row_vector[6] tz;
  matrix[5, 6] tm;
  
  array[2] real tx1;
  array[2] vector[5] ty1;
  array[2] row_vector[6] tz1;
  array[2] matrix[5, 6] tm1;
  
  array[2, 3] real tx2;
  array[2, 3] vector[5] ty2;
  array[2, 3] row_vector[6] tz2;
  array[2, 3] matrix[5, 6] tm2;
  
  array[2, 3, 4] real tx3;
  array[2, 3, 4] vector[5] ty3;
  array[2, 3, 4] row_vector[6] tz3;
  array[2, 3, 4] matrix[5, 6] tm3;
  
  tx = x;
  tx = y[1];
  tx = z[1];
  tx = m[1, 2];
  
  tx = x1[1];
  tx = y1[1, 1];
  tx = z1[1, 1];
  tx = m1[1, 1, 2];
  
  tx = x2[1, 1];
  tx = y2[1, 1, 1];
  tx = z2[1, 1, 1];
  tx = m2[1, 1, 1, 2];
  
  tx = x3[1, 1, 1];
  tx = y3[1, 1, 1, 1];
  tx = z3[1, 1, 1, 1];
  tx = m3[1, 1, 1, 1, 2];
  
  tx1[1] = x;
  tx1[1] = y[1];
  tx1[1] = z[1];
  tx1[1] = m[1, 2];
  
  tx1[1] = x1[1];
  tx1[1] = y1[1, 1];
  tx1[1] = z1[1, 1];
  tx1[1] = m1[1, 1, 2];
  
  tx1[1] = x2[1, 1];
  tx1[1] = y2[1, 1, 1];
  tx1[1] = z2[1, 1, 1];
  tx1[1] = m2[1, 1, 1, 2];
  
  tx1[1] = x3[1, 1, 1];
  tx1[1] = y3[1, 1, 1, 1];
  tx1[1] = z3[1, 1, 1, 1];
  tx1[1] = m3[1, 1, 1, 1, 2];
  
  tx2[1, 1] = x;
  tx2[1, 1] = y[1];
  tx2[1, 1] = z[1];
  tx2[1, 1] = m[1, 2];
  
  tx2[1, 1] = x1[1];
  tx2[1, 1] = y1[1, 1];
  tx2[1, 1] = z1[1, 1];
  tx2[1, 1] = m1[1, 1, 2];
  
  tx2[1, 1] = x2[1, 1];
  tx2[1, 1] = y2[1, 1, 1];
  tx2[1, 1] = z2[1, 1, 1];
  tx2[1, 1] = m2[1, 1, 1, 2];
  
  tx2[1, 1] = x3[1, 1, 1];
  tx2[1, 1] = y3[1, 1, 1, 1];
  tx2[1, 1] = z3[1, 1, 1, 1];
  tx2[1, 1] = m3[1, 1, 1, 1, 2];
  
  tx3[1, 1, 1] = x;
  tx3[1, 1, 1] = y[1];
  tx3[1, 1, 1] = z[1];
  tx3[1, 1, 1] = m[1, 2];
  
  tx3[1, 1, 1] = x1[1];
  tx3[1, 1, 1] = y1[1, 1];
  tx3[1, 1, 1] = z1[1, 1];
  tx3[1, 1, 1] = m1[1, 1, 2];
  
  tx3[1, 1, 1] = x2[1, 1];
  tx3[1, 1, 1] = y2[1, 1, 1];
  tx3[1, 1, 1] = z2[1, 1, 1];
  tx3[1, 1, 1] = m2[1, 1, 1, 2];
  
  tx3[1, 1, 1] = x3[1, 1, 1];
  tx3[1, 1, 1] = y3[1, 1, 1, 1];
  tx3[1, 1, 1] = z3[1, 1, 1, 1];
  tx3[1, 1, 1] = m3[1, 1, 1, 1, 2];
  
  ty = y;
  ty = y1[1];
  ty = y2[1, 1];
  ty = y3[1, 1, 1];
  ty = col(m, 1);
  ty = col(m1[1], 1);
  ty = col(m2[1, 1], 1);
  ty = col(m3[1, 1, 1], 1);
  
  ty1[1] = y;
  ty1[1] = y1[1];
  ty1[1] = y2[1, 1];
  ty1[1] = y3[1, 1, 1];
  ty1[1] = col(m, 1);
  ty1[1] = col(m1[1], 1);
  ty1[1] = col(m2[1, 1], 1);
  ty1[1] = col(m3[1, 1, 1], 1);
  
  ty2[1, 1] = y;
  ty2[1, 1] = y1[1];
  ty2[1, 1] = y2[1, 1];
  ty2[1, 1] = y3[1, 1, 1];
  ty2[1, 1] = col(m, 1);
  ty2[1, 1] = col(m1[1], 1);
  ty2[1, 1] = col(m2[1, 1], 1);
  ty2[1, 1] = col(m3[1, 1, 1], 1);
  
  ty3[1, 1, 1] = y;
  ty3[1, 1, 1] = y1[1];
  ty3[1, 1, 1] = y2[1, 1];
  ty3[1, 1, 1] = y3[1, 1, 1];
  ty3[1, 1, 1] = col(m, 1);
  ty3[1, 1, 1] = col(m1[1], 1);
  ty3[1, 1, 1] = col(m2[1, 1], 1);
  ty3[1, 1, 1] = col(m3[1, 1, 1], 1);
  
  tz = z;
  tz = z1[1];
  tz = z2[1, 1];
  tz = z3[1, 1, 1];
  tz = row(m, 1);
  tz = row(m1[1], 1);
  tz = row(m2[1, 1], 1);
  tz = row(m3[1, 1, 1], 1);
  tz = m[1];
  tz = m1[1, 1];
  tz = m2[1, 1, 1];
  tz = m3[1, 1, 1, 1];
  
  tz1[1] = z;
  tz1[1] = z1[1];
  tz1[1] = z2[1, 1];
  tz1[1] = z3[1, 1, 1];
  tz1[1] = row(m, 1);
  tz1[1] = row(m1[1], 1);
  tz1[1] = row(m2[1, 1], 1);
  tz1[1] = row(m3[1, 1, 1], 1);
  tz1[1] = m[1];
  tz1[1] = m1[1, 1];
  tz1[1] = m2[1, 1, 1];
  tz1[1] = m3[1, 1, 1, 1];
  
  tz2[1, 1] = z;
  tz2[1, 1] = z1[1];
  tz2[1, 1] = z2[1, 1];
  tz2[1, 1] = z3[1, 1, 1];
  tz2[1, 1] = row(m, 1);
  tz2[1, 1] = row(m1[1], 1);
  tz2[1, 1] = row(m2[1, 1], 1);
  tz2[1, 1] = row(m3[1, 1, 1], 1);
  tz2[1, 1] = m[1];
  tz2[1, 1] = m1[1, 1];
  tz2[1, 1] = m2[1, 1, 1];
  tz2[1, 1] = m3[1, 1, 1, 1];
  
  tz3[1, 1, 1] = z;
  tz3[1, 1, 1] = z1[1];
  tz3[1, 1, 1] = z2[1, 1];
  tz3[1, 1, 1] = z3[1, 1, 1];
  tz3[1, 1, 1] = row(m, 1);
  tz3[1, 1, 1] = row(m1[1], 1);
  tz3[1, 1, 1] = row(m2[1, 1], 1);
  tz3[1, 1, 1] = row(m3[1, 1, 1], 1);
  tz3[1, 1, 1] = m[1];
  tz3[1, 1, 1] = m1[1, 1];
  tz3[1, 1, 1] = m2[1, 1, 1];
  tz3[1, 1, 1] = m3[1, 1, 1, 1];
  
  tm = m;
  tm = m1[1];
  tm = m2[1, 1];
  tm = m3[1, 1, 1];
  
  tm1[1] = m;
  tm1[1] = m1[1];
  tm1[1] = m2[1, 1];
  tm1[1] = m3[1, 1, 1];
  
  tm2[1, 1] = m;
  tm2[1, 1] = m1[1];
  tm2[1, 1] = m2[1, 1];
  tm2[1, 1] = m3[1, 1, 1];
  
  tm3[1, 1, 1] = m;
  tm3[1, 1, 1] = m1[1];
  tm3[1, 1, 1] = m2[1, 1];
  tm3[1, 1, 1] = m3[1, 1, 1];
  
  tx1 = x1;
  tx1 = x2[1];
  tx1 = x3[1, 1];
  
  tx2[1] = x1;
  tx2[1] = x2[1];
  tx2[1] = x3[1, 1];
  
  tx3[1, 1] = x1;
  tx3[1, 1] = x2[1];
  tx3[1, 1] = x3[1, 1];
  
  ty1 = y1;
  ty1 = y2[1];
  ty1 = y3[1, 1];
  
  ty2[1] = y1;
  ty2[1] = y2[1];
  ty2[1] = y3[1, 1];
  
  ty3[1, 1] = y1;
  ty3[1, 1] = y2[1];
  ty3[1, 1] = y3[1, 1];
  
  tz1 = z1;
  tz1 = z2[1];
  tz1 = z3[1, 1];
  
  tz2[1] = z1;
  tz2[1] = z2[1];
  tz2[1] = z3[1, 1];
  
  tz3[1, 1] = z1;
  tz3[1, 1] = z2[1];
  tz3[1, 1] = z3[1, 1];
  
  tm1 = m1;
  tm1 = m2[1];
  tm1 = m3[1, 1];
  
  tm2[1] = m1;
  tm2[1] = m2[1];
  tm2[1] = m3[1, 1];
  
  tm3[1, 1] = m1;
  tm3[1, 1] = m2[1];
  tm3[1, 1] = m3[1, 1];
  
  tx2 = x2;
  tx2 = x3[1];
  
  tx3[1] = x2;
  tx3[1] = x3[1];
  
  ty2 = y2;
  ty2 = y3[1];
  
  ty3[1] = y2;
  ty3[1] = y3[1];
  
  tz2 = z2;
  tz2 = z3[1];
  
  tz3[1] = z2;
  tz3[1] = z3[1];
  
  tm2 = m2;
  tm2 = m3[1];
  
  tm3[1] = m2;
  tm3[1] = m3[1];
  
  tx3 = x3;
  
  ty3 = y3;
  
  tz3 = z3;
  
  tm3 = m3;
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format assignments_var.stan
parameters {
  real x;
  vector[5] y;
  row_vector[6] z;
  matrix[5, 6] m;
  
  array[2] real x1;
  array[2] vector[5] y1;
  array[2] row_vector[6] z1;
  array[2] matrix[5, 6] m1;
  
  array[2, 3] real x2;
  array[2, 3] vector[5] y2;
  array[2, 3] row_vector[6] z2;
  array[2, 3] matrix[5, 6] m2;
  
  array[2, 3, 4] real x3;
  array[2, 3, 4] vector[5] y3;
  array[2, 3, 4] row_vector[6] z3;
  array[2, 3, 4] matrix[5, 6] m3;
}
transformed parameters {
  real tx;
  vector[5] ty;
  row_vector[6] tz;
  matrix[5, 6] tm;
  
  array[2] real tx1;
  array[2] vector[5] ty1;
  array[2] row_vector[6] tz1;
  array[2] matrix[5, 6] tm1;
  
  array[2, 3] real tx2;
  array[2, 3] vector[5] ty2;
  array[2, 3] row_vector[6] tz2;
  array[2, 3] matrix[5, 6] tm2;
  
  array[2, 3, 4] real tx3;
  array[2, 3, 4] vector[5] ty3;
  array[2, 3, 4] row_vector[6] tz3;
  array[2, 3, 4] matrix[5, 6] tm3;
  
  tx = x;
  tx = y[1];
  tx = z[1];
  tx = m[1, 2];
  
  tx = x1[1];
  tx = y1[1, 1];
  tx = z1[1, 1];
  tx = m1[1, 1, 2];
  
  tx = x2[1, 1];
  tx = y2[1, 1, 1];
  tx = z2[1, 1, 1];
  tx = m2[1, 1, 1, 2];
  
  tx = x3[1, 1, 1];
  tx = y3[1, 1, 1, 1];
  tx = z3[1, 1, 1, 1];
  tx = m3[1, 1, 1, 1, 2];
  
  tx1[1] = x;
  tx1[1] = y[1];
  tx1[1] = z[1];
  tx1[1] = m[1, 2];
  
  tx1[1] = x1[1];
  tx1[1] = y1[1, 1];
  tx1[1] = z1[1, 1];
  tx1[1] = m1[1, 1, 2];
  
  tx1[1] = x2[1, 1];
  tx1[1] = y2[1, 1, 1];
  tx1[1] = z2[1, 1, 1];
  tx1[1] = m2[1, 1, 1, 2];
  
  tx1[1] = x3[1, 1, 1];
  tx1[1] = y3[1, 1, 1, 1];
  tx1[1] = z3[1, 1, 1, 1];
  tx1[1] = m3[1, 1, 1, 1, 2];
  
  tx2[1, 1] = x;
  tx2[1, 1] = y[1];
  tx2[1, 1] = z[1];
  tx2[1, 1] = m[1, 2];
  
  tx2[1, 1] = x1[1];
  tx2[1, 1] = y1[1, 1];
  tx2[1, 1] = z1[1, 1];
  tx2[1, 1] = m1[1, 1, 2];
  
  tx2[1, 1] = x2[1, 1];
  tx2[1, 1] = y2[1, 1, 1];
  tx2[1, 1] = z2[1, 1, 1];
  tx2[1, 1] = m2[1, 1, 1, 2];
  
  tx2[1, 1] = x3[1, 1, 1];
  tx2[1, 1] = y3[1, 1, 1, 1];
  tx2[1, 1] = z3[1, 1, 1, 1];
  tx2[1, 1] = m3[1, 1, 1, 1, 2];
  
  tx3[1, 1, 1] = x;
  tx3[1, 1, 1] = y[1];
  tx3[1, 1, 1] = z[1];
  tx3[1, 1, 1] = m[1, 2];
  
  tx3[1, 1, 1] = x1[1];
  tx3[1, 1, 1] = y1[1, 1];
  tx3[1, 1, 1] = z1[1, 1];
  tx3[1, 1, 1] = m1[1, 1, 2];
  
  tx3[1, 1, 1] = x2[1, 1];
  tx3[1, 1, 1] = y2[1, 1, 1];
  tx3[1, 1, 1] = z2[1, 1, 1];
  tx3[1, 1, 1] = m2[1, 1, 1, 2];
  
  tx3[1, 1, 1] = x3[1, 1, 1];
  tx3[1, 1, 1] = y3[1, 1, 1, 1];
  tx3[1, 1, 1] = z3[1, 1, 1, 1];
  tx3[1, 1, 1] = m3[1, 1, 1, 1, 2];
  
  ty = y;
  ty = y1[1];
  ty = y2[1, 1];
  ty = y3[1, 1, 1];
  ty = col(m, 1);
  ty = col(m1[1], 1);
  ty = col(m2[1, 1], 1);
  ty = col(m3[1, 1, 1], 1);
  
  ty1[1] = y;
  ty1[1] = y1[1];
  ty1[1] = y2[1, 1];
  ty1[1] = y3[1, 1, 1];
  ty1[1] = col(m, 1);
  ty1[1] = col(m1[1], 1);
  ty1[1] = col(m2[1, 1], 1);
  ty1[1] = col(m3[1, 1, 1], 1);
  
  ty2[1, 1] = y;
  ty2[1, 1] = y1[1];
  ty2[1, 1] = y2[1, 1];
  ty2[1, 1] = y3[1, 1, 1];
  ty2[1, 1] = col(m, 1);
  ty2[1, 1] = col(m1[1], 1);
  ty2[1, 1] = col(m2[1, 1], 1);
  ty2[1, 1] = col(m3[1, 1, 1], 1);
  
  ty3[1, 1, 1] = y;
  ty3[1, 1, 1] = y1[1];
  ty3[1, 1, 1] = y2[1, 1];
  ty3[1, 1, 1] = y3[1, 1, 1];
  ty3[1, 1, 1] = col(m, 1);
  ty3[1, 1, 1] = col(m1[1], 1);
  ty3[1, 1, 1] = col(m2[1, 1], 1);
  ty3[1, 1, 1] = col(m3[1, 1, 1], 1);
  
  tz = z;
  tz = z1[1];
  tz = z2[1, 1];
  tz = z3[1, 1, 1];
  tz = row(m, 1);
  tz = row(m1[1], 1);
  tz = row(m2[1, 1], 1);
  tz = row(m3[1, 1, 1], 1);
  tz = m[1];
  tz = m1[1, 1];
  tz = m2[1, 1, 1];
  tz = m3[1, 1, 1, 1];
  
  tz1[1] = z;
  tz1[1] = z1[1];
  tz1[1] = z2[1, 1];
  tz1[1] = z3[1, 1, 1];
  tz1[1] = row(m, 1);
  tz1[1] = row(m1[1], 1);
  tz1[1] = row(m2[1, 1], 1);
  tz1[1] = row(m3[1, 1, 1], 1);
  tz1[1] = m[1];
  tz1[1] = m1[1, 1];
  tz1[1] = m2[1, 1, 1];
  tz1[1] = m3[1, 1, 1, 1];
  
  tz2[1, 1] = z;
  tz2[1, 1] = z1[1];
  tz2[1, 1] = z2[1, 1];
  tz2[1, 1] = z3[1, 1, 1];
  tz2[1, 1] = row(m, 1);
  tz2[1, 1] = row(m1[1], 1);
  tz2[1, 1] = row(m2[1, 1], 1);
  tz2[1, 1] = row(m3[1, 1, 1], 1);
  tz2[1, 1] = m[1];
  tz2[1, 1] = m1[1, 1];
  tz2[1, 1] = m2[1, 1, 1];
  tz2[1, 1] = m3[1, 1, 1, 1];
  
  tz3[1, 1, 1] = z;
  tz3[1, 1, 1] = z1[1];
  tz3[1, 1, 1] = z2[1, 1];
  tz3[1, 1, 1] = z3[1, 1, 1];
  tz3[1, 1, 1] = row(m, 1);
  tz3[1, 1, 1] = row(m1[1], 1);
  tz3[1, 1, 1] = row(m2[1, 1], 1);
  tz3[1, 1, 1] = row(m3[1, 1, 1], 1);
  tz3[1, 1, 1] = m[1];
  tz3[1, 1, 1] = m1[1, 1];
  tz3[1, 1, 1] = m2[1, 1, 1];
  tz3[1, 1, 1] = m3[1, 1, 1, 1];
  
  tm = m;
  tm = m1[1];
  tm = m2[1, 1];
  tm = m3[1, 1, 1];
  
  tm1[1] = m;
  tm1[1] = m1[1];
  tm1[1] = m2[1, 1];
  tm1[1] = m3[1, 1, 1];
  
  tm2[1, 1] = m;
  tm2[1, 1] = m1[1];
  tm2[1, 1] = m2[1, 1];
  tm2[1, 1] = m3[1, 1, 1];
  
  tm3[1, 1, 1] = m;
  tm3[1, 1, 1] = m1[1];
  tm3[1, 1, 1] = m2[1, 1];
  tm3[1, 1, 1] = m3[1, 1, 1];
  
  tx1 = x1;
  tx1 = x2[1];
  tx1 = x3[1, 1];
  
  tx2[1] = x1;
  tx2[1] = x2[1];
  tx2[1] = x3[1, 1];
  
  tx3[1, 1] = x1;
  tx3[1, 1] = x2[1];
  tx3[1, 1] = x3[1, 1];
  
  ty1 = y1;
  ty1 = y2[1];
  ty1 = y3[1, 1];
  
  ty2[1] = y1;
  ty2[1] = y2[1];
  ty2[1] = y3[1, 1];
  
  ty3[1, 1] = y1;
  ty3[1, 1] = y2[1];
  ty3[1, 1] = y3[1, 1];
  
  tz1 = z1;
  tz1 = z2[1];
  tz1 = z3[1, 1];
  
  tz2[1] = z1;
  tz2[1] = z2[1];
  tz2[1] = z3[1, 1];
  
  tz3[1, 1] = z1;
  tz3[1, 1] = z2[1];
  tz3[1, 1] = z3[1, 1];
  
  tm1 = m1;
  tm1 = m2[1];
  tm1 = m3[1, 1];
  
  tm2[1] = m1;
  tm2[1] = m2[1];
  tm2[1] = m3[1, 1];
  
  tm3[1, 1] = m1;
  tm3[1, 1] = m2[1];
  tm3[1, 1] = m3[1, 1];
  
  tx2 = x2;
  tx2 = x3[1];
  
  tx3[1] = x2;
  tx3[1] = x3[1];
  
  ty2 = y2;
  ty2 = y3[1];
  
  ty3[1] = y2;
  ty3[1] = y3[1];
  
  tz2 = z2;
  tz2 = z3[1];
  
  tz3[1] = z2;
  tz3[1] = z3[1];
  
  tm2 = m2;
  tm2 = m3[1];
  
  tm3[1] = m2;
  tm3[1] = m3[1];
  
  tx3 = x3;
  
  ty3 = y3;
  
  tz3 = z3;
  
  tm3 = m3;
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format bernoulli_logit_glm_old_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  array[N] int<lower=0, upper=1> y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j * 1.0 / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = bernoulli_logit_rng((x * beta_true + alpha_true)[i]);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  
  y ~ bernoulli_logit(x * beta_inferred + alpha_inferred);
}

  $ ../../../../install/default/bin/stanc --auto-format bernoulli_logit_glm_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  array[N] int<lower=0, upper=1> y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j * 1.0 / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = bernoulli_logit_rng((x * beta_true + alpha_true)[i]);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  
  y ~ bernoulli_logit_glm(x, alpha_inferred, beta_inferred);
}

  $ ../../../../install/default/bin/stanc --auto-format break-continue.stan
// test right value passed through for, while and embedded
functions {
  int foo(int a) {
    // direct while
    while (1) break;
    while (0) continue;
    
    // direct for
    for (i in 1 : 10) 
      break;
    for (i in 1 : 10) 
      continue;
    
    // in statement seq
    while (1) {
      int b;
      b = 5;
      break;
    }
    
    // if, else if, else body
    while (1) {
      if (0) 
        break;
      else if (1) 
        break;
      else 
        break;
    }
    
    // nested while
    while (1) while (0) break;
    
    // nested for
    while (1) {
      for (i in 1 : 10) 
        break;
    }
    
    // nested foreach (array)
    while (1) {
      array[2, 3] int vs;
      int z;
      for (v in vs) {
        z = 0;
        break;
      }
      for (v in vs) {
        z = 0;
        continue;
      }
      for (v in vs) {
        for (vv in v) {
          z = 0;
          break;
        }
        z = 1;
      }
    }
    
    // nested foreach (matrix)
    while (1) {
      real z;
      matrix[2, 3] vs;
      for (v in vs) {
        z = 0;
        break;
      }
      for (v in vs) {
        z = 3.2;
        continue;
      }
    }
    
    // nested foreach (vector)
    while (1) {
      real z;
      vector[2] vs;
      for (v in vs) {
        z = 0;
        break;
      }
      for (v in vs) {
        z = 3.2;
        continue;
      }
    }
    
    // nested foreach (rowvector)
    while (1) {
      real z;
      row_vector[2] vs;
      for (v in vs) {
        z = 0;
        break;
      }
      for (v in vs) {
        z = 3.2;
        continue;
      }
    }
    
    // nested block
    while (1) {
      int b;
      b = 5;
      {
        int c;
        c = 6;
        break;
      }
    }
    
    // nested loop exit
    while (1) {
      while (1) {
        
      }
      break;
    }
    while (1) {
      while (1) {
        
      }
      continue;
    }
    
    return 0;
  }
}
transformed data {
  int x;
  x = 0;
  while (0) break;
  while (1) continue;
}
parameters {
  real y;
}
transformed parameters {
  real z;
  z = 1;
  while (0) break;
  while (1) continue;
}
model {
  
}
generated quantities {
  real u;
  u = 1;
  while (1) break;
  while (0) continue;
}

  $ ../../../../install/default/bin/stanc --auto-format comments.stan
// this is a line comment */ should stay // /**/

// how ugly # can */ we make /* this one // #

/* one line block */

/* a weird
      ly formated
          block
                */

/**
 * Doc comment
 * @return nothing
 */

data {
  //nothing here either
}
transformed data {
  int N;
  array[N /*test1*/, //test1.5
        N] real arr;
  
  /* ^^^:test2*/
}

  $ ../../../../install/default/bin/stanc --auto-format conditional_condition_good.stan
parameters {
  real y;
}
model {
  int x;
  if (x) 
    y ~ normal(0, 1);
  else if (!x) 
    y ~ normal(0, 1);
  else 
    y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format conditional_op_fun_promote.stan
functions {
  real foo(real y) {
    return 1 ? y : 2;
  }
}
parameters {
  real y;
}
transformed parameters {
  real z;
  z = foo(y);
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format dae_good.stan
functions {
  vector chem_dae(real t, vector yy, vector yp, array[] real p,
                  array[] real x) {
    vector[3] res;
    res[1] = yp[1] + p[1] * yy[1] - p[2] * yy[2] * yy[3];
    res[2] = yp[2] - p[1] * yy[1] + p[2] * yy[2] * yy[3]
             + p[3] * yy[2] * yy[2];
    res[3] = yy[1] + yy[2] + yy[3] - 1.0;
    return res;
  }
}
data {
  vector[3] yy0;
  vector[3] yp0;
  real t0;
  array[1] real x;
  array[4] vector[3] y;
}
transformed data {
  array[4] real ts;
}
parameters {
  array[3] real theta;
  vector[3] yy0_var;
  vector[3] yp0_var;
  real<lower=0> sigma;
}
transformed parameters {
  array[4] vector[3] y_hat;
  {
    y_hat = dae(chem_dae, yy0, yp0, t0, ts, theta, x);
  }
  {
    y_hat = dae_tol(chem_dae, yy0, yp0, t0, ts, 0.01, 0.01, 100, theta, x);
  }
  {
    y_hat = dae(chem_dae, yy0_var, yp0_var, t0, ts, theta, x);
  }
  {
    y_hat = dae_tol(chem_dae, yy0_var, yp0_var, t0, ts, 0.01, 0.01, 100,
                    theta, x);
  }
  {
    y_hat = dae(chem_dae, yy0_var, yp0, t0, ts, theta, x);
  }
  {
    y_hat = dae_tol(chem_dae, yy0, yp0_var, t0, ts, 0.01, 0.01, 100, theta,
                    x);
  }
}
model {
  for (t in 1 : 4) 
    y[t] ~ normal(y_hat[t], sigma); // independent normal noise
}

  $ ../../../../install/default/bin/stanc --auto-format dataonly-int-return.stan
parameters {
  vector[5] x;
}
model {
  x ~ normal(0, linspaced_array(size(x), 1.0, 10.0));
}

  $ ../../../../install/default/bin/stanc --auto-format declarations.stan
data {
  int a0;
  array[1] int a1;
  array[2, 3] int a2;
  
  real b0;
  array[4] real b1;
  array[5, 6] real b2;
  
  vector[7] c0;
  array[8] vector[7] c1;
  array[8, 9] vector[7] c2;
  
  row_vector[7] d0;
  array[8] row_vector[7] d1;
  array[8, 9] row_vector[7] d2;
  
  matrix[8, 9] e;
  array[11] matrix[8, 9] e1;
  array[11, 12] matrix[8, 9] e2;
  
  simplex[8] f;
  array[9] simplex[8] f1;
  array[9, 10] simplex[8] f2;
  
  ordered[9] g;
  array[11] ordered[9] g1;
  array[12, 13] ordered[9] g2;
  
  positive_ordered[9] h;
  array[11] positive_ordered[9] h1;
  array[12, 13] positive_ordered[9] h2;
  
  corr_matrix[10] j;
  array[3] corr_matrix[10] j1;
  array[5, 6] corr_matrix[10] j2;
  
  cov_matrix[10] k;
  array[3] cov_matrix[10] k1;
  array[5, 6] cov_matrix[10] k2;
}
transformed data {
  int td_a0;
  array[1] int td_a1;
  array[2, 3] int td_a2;
  
  real td_b0;
  array[4] real td_b1;
  array[5, 6] real td_b2;
  
  vector[7] td_c0;
  array[8] vector[7] td_c1;
  array[8, 9] vector[7] td_c2;
  
  row_vector[7] td_d0;
  array[8] row_vector[7] td_d1;
  array[8, 9] row_vector[7] td_d2;
  
  matrix[8, 9] td_e;
  array[11] matrix[8, 9] td_e1;
  array[11, 12] matrix[8, 9] td_e2;
  
  simplex[8] td_f;
  array[9] simplex[8] td_f1;
  array[9, 10] simplex[8] td_f2;
  
  ordered[9] td_g;
  array[11] ordered[9] td_g1;
  array[12, 13] ordered[9] td_g2;
  
  positive_ordered[9] td_h;
  array[11] positive_ordered[9] td_h1;
  array[12, 13] positive_ordered[9] td_h2;
  
  corr_matrix[10] td_j;
  array[3] corr_matrix[10] td_j1;
  array[5, 6] corr_matrix[10] td_j2;
  
  cov_matrix[10] td_k;
  array[3] cov_matrix[10] td_k1;
  array[5, 6] cov_matrix[10] td_k2;
  
  {
    int loc_td_a0;
    array[1] int loc_td_a1;
    array[2, 3] int loc_td_a2;
    
    real loc_td_b0;
    array[4] real loc_td_b1;
    array[5, 6] real loc_td_b2;
    
    vector[7] loc_td_c0;
    array[8] vector[7] loc_td_c1;
    array[8, 9] vector[7] loc_td_c2;
    
    row_vector[7] loc_td_d0;
    array[8] row_vector[7] loc_td_d1;
    array[8, 9] row_vector[7] loc_td_d2;
    
    matrix[8, 9] loc_td_e;
    array[11] matrix[8, 9] loc_td_e1;
    array[11, 12] matrix[8, 9] loc_td_e2;
  }
}
parameters {
  real par_b0;
  array[4] real par_b1;
  array[5, 6] real par_b2;
  
  vector[7] par_c0;
  array[8] vector[7] par_c1;
  array[8, 9] vector[7] par_c2;
  
  row_vector[7] par_d0;
  array[8] row_vector[7] par_d1;
  array[8, 9] row_vector[7] par_d2;
  
  matrix[8, 9] par_e;
  array[11] matrix[8, 9] par_e1;
  array[11, 12] matrix[8, 9] par_e2;
  
  simplex[8] par_f;
  array[9] simplex[8] par_f1;
  array[9, 10] simplex[8] par_f2;
  
  ordered[9] par_g;
  array[11] ordered[9] par_g1;
  array[12, 13] ordered[9] par_g2;
  
  positive_ordered[9] par_h;
  array[11] positive_ordered[9] par_h1;
  array[12, 13] positive_ordered[9] par_h2;
  
  corr_matrix[10] par_j;
  array[3] corr_matrix[10] par_j1;
  array[5, 6] corr_matrix[10] par_j2;
  
  cov_matrix[10] par_k;
  array[3] cov_matrix[10] par_k1;
  array[5, 6] cov_matrix[10] par_k2;
}
transformed parameters {
  real tpar_b0;
  array[4] real tpar_b1;
  array[5, 6] real tpar_b2;
  
  vector[7] tpar_c0;
  array[8] vector[7] tpar_c1;
  array[8, 9] vector[7] tpar_c2;
  
  row_vector[7] tpar_d0;
  array[8] row_vector[7] tpar_d1;
  array[8, 9] row_vector[7] tpar_d2;
  
  matrix[8, 9] tpar_e;
  array[11] matrix[8, 9] tpar_e1;
  array[11, 12] matrix[8, 9] tpar_e2;
  
  simplex[8] tpar_f;
  array[9] simplex[8] tpar_f1;
  array[9, 10] simplex[8] tpar_f2;
  
  ordered[9] tpar_g;
  array[11] ordered[9] tpar_g1;
  array[12, 13] ordered[9] tpar_g2;
  
  positive_ordered[9] tpar_h;
  array[11] positive_ordered[9] tpar_h1;
  array[12, 13] positive_ordered[9] tpar_h2;
  
  corr_matrix[10] tpar_j;
  array[3] corr_matrix[10] tpar_j1;
  array[5, 6] corr_matrix[10] tpar_j2;
  
  cov_matrix[10] tpar_k;
  array[3] cov_matrix[10] tpar_k1;
  array[5, 6] cov_matrix[10] tpar_k2;
  
  {
    int loc_tpar_a0;
    array[1] int loc_tpar_a1;
    array[2, 3] int loc_tpar_a2;
    
    real loc_tpar_b0;
    array[4] real loc_tpar_b1;
    array[5, 6] real loc_tpar_b2;
    
    vector[7] loc_tpar_c0;
    array[8] vector[7] loc_tpar_c1;
    array[8, 9] vector[7] loc_tpar_c2;
    
    row_vector[7] loc_tpar_d0;
    array[8] row_vector[7] loc_tpar_d1;
    array[8, 9] row_vector[7] loc_tpar_d2;
    
    matrix[8, 9] loc_tpar_e;
    array[11] matrix[8, 9] loc_tpar_e1;
    array[11, 12] matrix[8, 9] loc_tpar_e2;
  }
}
model {
  {
    int loc_model_a0;
    array[1] int loc_model_a1;
    array[2, 3] int loc_model_a2;
    
    real loc_model_b0;
    array[4] real loc_model_b1;
    array[5, 6] real loc_model_b2;
    
    vector[7] loc_model_c0;
    array[8] vector[7] loc_model_c1;
    array[8, 9] vector[7] loc_model_c2;
    
    row_vector[7] loc_model_d0;
    array[8] row_vector[7] loc_model_d1;
    array[8, 9] row_vector[7] loc_model_d2;
    
    matrix[8, 9] loc_model_e;
    array[11] matrix[8, 9] loc_model_e1;
    array[11, 12] matrix[8, 9] loc_model_e2;
  }
}
generated quantities {
  real gq_b0;
  array[4] real gq_b1;
  array[5, 6] real gq_b2;
  
  vector[7] gq_c0;
  array[8] vector[7] gq_c1;
  array[8, 9] vector[7] gq_c2;
  
  row_vector[7] gq_d0;
  array[8] row_vector[7] gq_d1;
  array[8, 9] row_vector[7] gq_d2;
  
  matrix[8, 9] gq_e;
  array[11] matrix[8, 9] gq_e1;
  array[11, 12] matrix[8, 9] gq_e2;
  
  simplex[8] gq_f;
  array[9] simplex[8] gq_f1;
  array[9, 10] simplex[8] gq_f2;
  
  ordered[9] gq_g;
  array[11] ordered[9] gq_g1;
  array[12, 13] ordered[9] gq_g2;
  
  positive_ordered[9] gq_h;
  array[11] positive_ordered[9] gq_h1;
  array[12, 13] positive_ordered[9] gq_h2;
  
  corr_matrix[10] gq_j;
  array[3] corr_matrix[10] gq_j1;
  array[5, 6] corr_matrix[10] gq_j2;
  
  cov_matrix[10] gq_k;
  array[3] cov_matrix[10] gq_k1;
  array[5, 6] cov_matrix[10] gq_k2;
  
  {
    int loc_gq_a0;
    array[1] int loc_gq_a1;
    array[2, 3] int loc_gq_a2;
    
    real loc_gq_b0;
    array[4] real loc_gq_b1;
    array[5, 6] real loc_gq_b2;
    
    vector[7] loc_gq_c0;
    array[8] vector[7] loc_gq_c1;
    array[8, 9] vector[7] loc_gq_c2;
    
    row_vector[7] loc_gq_d0;
    array[8] row_vector[7] loc_gq_d1;
    array[8, 9] row_vector[7] loc_gq_d2;
    
    matrix[8, 9] loc_gq_e;
    array[11] matrix[8, 9] loc_gq_e1;
    array[11, 12] matrix[8, 9] loc_gq_e2;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-conditional-op.stan
data {
  int<lower=0> N;
  array[N] int<lower=0, upper=1> y;
  real x;
}
transformed data {
  int td_i1 = 1 ? N : N;
  int td_i2 = 1 ? N : y[1];
  int td_i3 = 1 ? N : -3;
  int td_i4 = 1 ? 1 : 4;
  real td_r1 = 1 ? 1.0 : 2.0;
  real td_r2 = 1 ? 1.0 : x;
  real td_r3 = 1 ? x : 2.0;
  real td_r4 = 0 ? x : x;
  real td_r5 = 0 ? N : x;
}
parameters {
  real<lower=0, upper=1> theta;
  real z;
}
transformed parameters {
  real tp_r1 = 1 ? 1.0 : 2.0;
  real tp_r2 = 1 ? 1.0 : x;
  real tp_r3 = 1 ? x : 2.0;
  real tp_r4 = 0 ? x : x;
  real tp_r5 = 0 ? N : x;
  
  real tp_r6 = 1 ? x : tp_r1;
  real tp_r7 = 1 ? tp_r1 : tp_r2;
  real tp_r8 = 1 ? N : tp_r1;
  
  {
    real local_r1 = 1 ? 1.0 : 2.0;
    real local_r2 = 1 ? 1.0 : x;
    real local_r3 = 1 ? x : 2.0;
    real local_r4 = 0 ? x : x;
    real local_r5 = 0 ? N : x;
    
    real local_r6 = 1 ? x : tp_r1;
    real local_r7 = 1 ? tp_r1 : tp_r2;
    real local_r8 = 1 ? N : tp_r1;
  }
}
model {
  theta ~ beta(1, 1);
  for (n in 1 : N) 
    y[n] ~ bernoulli(theta);
}
generated quantities {
  int gq_i1 = 1 ? N : N;
  int gq_i2 = 1 ? N : y[1];
  int gq_i3 = 1 ? N : -3;
  int gq_i4 = 1 ? 1 : 4;
  
  real gq_r1 = 1 ? 1.0 : 2.0;
  real gq_r2 = 1 ? 1.0 : x;
  real gq_r3 = 1 ? x : 2.0;
  real gq_r4 = 0 ? x : x;
  real gq_r5 = 0 ? N : x;
  
  real gq_r6 = 1 ? x : tp_r1;
  real gq_r7 = 1 ? tp_r1 : tp_r2;
  real gq_r8 = 1 ? N : tp_r1;
  
  {
    real local_r1 = 1 ? 1.0 : 2.0;
    real local_r2 = 1 ? 1.0 : x;
    real local_r3 = 1 ? x : 2.0;
    real local_r4 = 0 ? x : x;
    real local_r5 = 0 ? N : x;
    
    real local_r6 = 1 ? x : tp_r1;
    real local_r7 = 1 ? tp_r1 : tp_r2;
    real local_r8 = 1 ? N : tp_r1;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-gq-local-rng.stan
transformed data {
  int a = categorical_rng(rep_vector(0.1, 10));
  {
    int b = categorical_rng(rep_vector(0.1, 10));
  }
}
parameters {
  real y;
}
transformed parameters {
  {
    int k;
  }
}
model {
  y ~ normal(0, 1);
}
generated quantities {
  {
    int y_tilde = categorical_rng(rep_vector(0.1, 10));
  }
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-multi.stan
data {
  int a0, a1, a2;
  array[5] real b0, b1, b3;
  array[3, 2] vector[5] c0, c1, c2, c4;
  array[3, 2] matrix[5, 4] d0, d1;
}
transformed data {
  int td_a0 = 0, td_a1 = 2;
  int td_a2, td_a3;
  int td_a4 = 4, td_a5, td_a6 = 6;
  
  real td_b0 = 0.5, td_b1 = 2.5;
  real td_b2, td_b3;
  real td_b4 = 4.5, td_b5, td_b6 = 6.5;
  
  vector[2] td_c0 = [-1.5, -2.5]', td_c1 = [1.5, 2.5]';
  vector[2] td_c2, td_c3;
  vector[2] td_c4 = [-1.5, -2.5]', td_c5, td_c6 = [1.5, 2.5]';
  
  array[2] real td_d0 = {-1.5, -2.5}, td_d1 = {1.5, 2.5};
  array[2] real td_d2, td_d3;
  array[2] real td_d4 = {-1.5, -2.5}, td_d5, td_d6 = {1.5, 2.5};
  
  {
    int loc_a0 = 0, loc_a1 = 2;
    int loc_a2, loc_a3;
    int loc_a4 = 4, loc_a5, loc_a6 = 6;
    
    real loc_b0 = 0.5, loc_b1 = 2.5;
    real loc_b2, loc_b3;
    real loc_b4 = 4.5, loc_b5, loc_b6 = 6.5;
    
    vector[2] loc_c0 = [-1.5, -2.5]', loc_c1 = [1.5, 2.5]';
    vector[2] loc_c2, loc_c3;
    vector[2] loc_c4 = [-1.5, -2.5]', loc_c5, loc_c6 = [1.5, 2.5]';
    
    array[2] real loc_d0 = {-1.5, -2.5}, loc_d1 = {1.5, 2.5};
    array[2] real loc_d2, loc_d3;
    array[2] real loc_d4 = {-1.5, -2.5}, loc_d5, loc_d6 = {1.5, 2.5};
  }
}
parameters {
  array[5] real par_b0, par_b1, par_b3;
  array[3, 2] vector[5] par_c0, par_c1, par_c2, par_c4;
  array[3, 2] matrix[5, 4] par_d0, par_d1;
}
transformed parameters {
  real tpar_b0 = 0.5, tpar_b1 = 2.5;
  real tpar_b2, tpar_b3;
  real tpar_b4 = 4.5, tpar_b5, tpar_b6 = 6.5;
  
  vector[2] tpar_c0 = [-1.5, -2.5]', tpar_c1 = [1.5, 2.5]';
  vector[2] tpar_c2, tpar_c3;
  vector[2] tpar_c4 = [-1.5, -2.5]', tpar_c5, tpar_c6 = [1.5, 2.5]';
  
  array[2] real tpar_d0 = {-1.5, -2.5}, tpar_d1 = {1.5, 2.5};
  array[2] real tpar_d2, tpar_d3;
  array[2] real tpar_d4 = {-1.5, -2.5}, tpar_d5, tpar_d6 = {1.5, 2.5};
  
  {
    int loc_tpar_a0 = 0, loc_tpar_a1 = 2;
    int loc_tpar_a2, loc_tpar_a3;
    int loc_tpar_a4 = 4, loc_tpar_a5, loc_tpar_a6 = 6;
    
    real loc_tpar_b0 = 0.5, loc_tpar_b1 = 2.5;
    real loc_tpar_b2, loc_tpar_b3;
    real loc_tpar_b4 = 4.5, loc_tpar_b5, loc_tpar_b6 = 6.5;
    
    vector[2] loc_tpar_c0 = [-1.5, -2.5]', loc_tpar_c1 = [1.5, 2.5]';
    vector[2] loc_tpar_c2, loc_tpar_c3;
    vector[2] loc_tpar_c4 = [-1.5, -2.5]', loc_tpar_c5, loc_tpar_c6 = [1.5,
                                                                    2.5]';
    
    array[2] real loc_tpar_d0 = {-1.5, -2.5}, loc_tpar_d1 = {1.5, 2.5};
    array[2] real loc_tpar_d2, loc_tpar_d3;
    array[2] real loc_tpar_d4 = {-1.5, -2.5}, loc_tpar_d5, loc_tpar_d6 = {1.5,
                                                                    2.5};
  }
}
model {
  int model_a0 = 0, model_a1 = 2;
  int model_a2, model_a3;
  int model_a4 = 4, model_a5, model_a6 = 6;
  
  real model_b0 = 0.5, model_b1 = 2.5;
  real model_b2, model_b3;
  real model_b4 = 4.5, model_b5, model_b6 = 6.5;
  
  vector[2] model_c0 = [-1.5, -2.5]', model_c1 = [1.5, 2.5]';
  vector[2] model_c2, model_c3;
  vector[2] model_c4 = [-1.5, -2.5]', model_c5, model_c6 = [1.5, 2.5]';
  
  array[2] real model_d0 = {-1.5, -2.5}, model_d1 = {1.5, 2.5};
  array[2] real model_d2, model_d3;
  array[2] real model_d4 = {-1.5, -2.5}, model_d5, model_d6 = {1.5, 2.5};
  
  {
    int loc_model_a0 = 0, loc_model_a1 = 2;
    int loc_model_a2, loc_model_a3;
    int loc_model_a4 = 4, loc_model_a5, loc_model_a6 = 6;
    
    real loc_model_b0 = 0.5, loc_model_b1 = 2.5;
    real loc_model_b2, loc_model_b3;
    real loc_model_b4 = 4.5, loc_model_b5, loc_model_b6 = 6.5;
    
    vector[2] loc_model_c0 = [-1.5, -2.5]', loc_model_c1 = [1.5, 2.5]';
    vector[2] loc_model_c2, loc_model_c3;
    vector[2] loc_model_c4 = [-1.5, -2.5]', loc_model_c5, loc_model_c6 = [1.5,
                                                                    2.5]';
    
    array[2] real loc_model_d0 = {-1.5, -2.5}, loc_model_d1 = {1.5, 2.5};
    array[2] real loc_model_d2, loc_model_d3;
    array[2] real loc_model_d4 = {-1.5, -2.5}, loc_model_d5, loc_model_d6 = {1.5,
                                                                    2.5};
  }
}
generated quantities {
  int gq_a0 = 0, gq_a1 = 2;
  int gq_a2, gq_a3;
  int gq_a4 = 4, gq_a5, gq_a6 = 6;
  
  real gq_b0 = 0.5, gq_b1 = 2.5;
  real gq_b2, gq_b3;
  real gq_b4 = 4.5, gq_b5, gq_b6 = 6.5;
  
  vector[2] gq_c0 = [-1.5, -2.5]', gq_c1 = [1.5, 2.5]';
  vector[2] gq_c2, gq_c3;
  vector[2] gq_c4 = [-1.5, -2.5]', gq_c5, gq_c6 = [1.5, 2.5]';
  
  array[2] real gq_d0 = {-1.5, -2.5}, gq_d1 = {1.5, 2.5};
  array[2] real gq_d2, gq_d3;
  array[2] real gq_d4 = {-1.5, -2.5}, gq_d5, gq_d6 = {1.5, 2.5};
  
  {
    int loc_gq_a0 = 0, loc_gq_a1 = 2;
    int loc_gq_a2, loc_gq_a3;
    int loc_gq_a4 = 4, loc_gq_a5, loc_gq_a6 = 6;
    
    real loc_gq_b0 = 0.5, loc_gq_b1 = 2.5;
    real loc_gq_b2, loc_gq_b3;
    real loc_gq_b4 = 4.5, loc_gq_b5, loc_gq_b6 = 6.5;
    
    vector[2] loc_gq_c0 = [-1.5, -2.5]', loc_gq_c1 = [1.5, 2.5]';
    vector[2] loc_gq_c2, loc_gq_c3;
    vector[2] loc_gq_c4 = [-1.5, -2.5]', loc_gq_c5, loc_gq_c6 = [1.5, 2.5]';
    
    array[2] real loc_gq_d0 = {-1.5, -2.5}, loc_gq_d1 = {1.5, 2.5};
    array[2] real loc_gq_d2, loc_gq_d3;
    array[2] real loc_gq_d4 = {-1.5, -2.5}, loc_gq_d5, loc_gq_d6 = {1.5, 2.5};
  }
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-constrained-matrix.stan
data {
  int d;
  
  corr_matrix[d] d_corr_matrix;
  array[1] corr_matrix[d] d_corr_matrix_ar;
  
  cov_matrix[d] d_cov_matrix;
  array[1] cov_matrix[d] d_cov_matrix_ar;
  
  cholesky_factor_corr[d] d_cholesky_factor_corr;
  array[1] cholesky_factor_corr[d] d_cholesky_factor_corr_ar;
  
  cholesky_factor_cov[d] d_cholesky_factor_cov;
  array[1] cholesky_factor_cov[d] d_cholesky_factor_cov_ar;
}
transformed data {
  corr_matrix[d] td_corr_matrix1 = d_corr_matrix;
  corr_matrix[d] td_corr_matrix2 = d_corr_matrix_ar[1];
  array[1] corr_matrix[d] td_corr_matrix_ar = d_corr_matrix_ar;
  
  cov_matrix[d] td_cov_matrix1 = d_cov_matrix;
  cov_matrix[d] td_cov_matrix2 = d_cov_matrix_ar[1];
  array[1] cov_matrix[d] td_cov_matrix_ar = d_cov_matrix_ar;
  
  cholesky_factor_corr[d] td_cholesky_factor_corr1 = d_cholesky_factor_corr;
  cholesky_factor_corr[d] td_cholesky_factor_corr2 = d_cholesky_factor_corr_ar[1];
  array[1] cholesky_factor_corr[d] td_cholesky_factor_corr_ar = d_cholesky_factor_corr_ar;
  
  cholesky_factor_cov[d] td_cholesky_factor_cov1 = d_cholesky_factor_cov;
  cholesky_factor_cov[d] td_cholesky_factor_cov2 = d_cholesky_factor_cov_ar[1];
  array[1] cholesky_factor_cov[d] td_cholesky_factor_cov_ar = d_cholesky_factor_cov_ar;
  
  print("td_corr_matrix1 = ", td_corr_matrix1);
  print("td_corr_matrix2 = ", td_corr_matrix2);
  print("td_corr_matrix_ar = ", td_corr_matrix_ar);
  
  print("td_cov_matrix1 = ", td_cov_matrix1);
  print("td_cov_matrix2 = ", td_cov_matrix2);
  print("td_cov_matrix_ar = ", td_cov_matrix_ar);
  
  print("td_cholesky_factor_corr1 = ", td_cholesky_factor_corr1);
  print("td_cholesky_factor_corr2 = ", td_cholesky_factor_corr2);
  print("td_cholesky_factor_corr_ar = ", td_cholesky_factor_corr_ar);
  
  print("td_cholesky_factor_cov1 = ", td_cholesky_factor_cov1);
  print("td_cholesky_factor_cov2 = ", td_cholesky_factor_cov2);
  print("td_cholesky_factor_cov_ar = ", td_cholesky_factor_cov_ar);
}
transformed parameters {
  corr_matrix[d] tp_corr_matrix1 = d_corr_matrix;
  corr_matrix[d] tp_corr_matrix2 = d_corr_matrix_ar[1];
  array[1] corr_matrix[d] tp_corr_matrix_ar = d_corr_matrix_ar;
  
  cov_matrix[d] tp_cov_matrix1 = d_cov_matrix;
  cov_matrix[d] tp_cov_matrix2 = d_cov_matrix_ar[1];
  array[1] cov_matrix[d] tp_cov_matrix_ar = d_cov_matrix_ar;
  
  cholesky_factor_corr[d] tp_cholesky_factor_corr1 = d_cholesky_factor_corr;
  cholesky_factor_corr[d] tp_cholesky_factor_corr2 = d_cholesky_factor_corr_ar[1];
  array[1] cholesky_factor_corr[d] tp_cholesky_factor_corr_ar = d_cholesky_factor_corr_ar;
  
  cholesky_factor_cov[d] tp_cholesky_factor_cov1 = d_cholesky_factor_cov;
  cholesky_factor_cov[d] tp_cholesky_factor_cov2 = d_cholesky_factor_cov_ar[1];
  array[1] cholesky_factor_cov[d] tp_cholesky_factor_cov_ar = d_cholesky_factor_cov_ar;
  
  print("tp_corr_matrix1 = ", tp_corr_matrix1);
  print("tp_corr_matrix2 = ", tp_corr_matrix2);
  print("tp_corr_matrix_ar = ", tp_corr_matrix_ar);
  
  print("tp_cov_matrix1 = ", tp_cov_matrix1);
  print("tp_cov_matrix2 = ", tp_cov_matrix2);
  print("tp_cov_matrix_ar = ", tp_cov_matrix_ar);
  
  print("tp_cholesky_factor_corr1 = ", tp_cholesky_factor_corr1);
  print("tp_cholesky_factor_corr2 = ", tp_cholesky_factor_corr2);
  print("tp_cholesky_factor_corr_ar = ", tp_cholesky_factor_corr_ar);
  
  print("tp_cholesky_factor_cov1 = ", tp_cholesky_factor_cov1);
  print("tp_cholesky_factor_cov2 = ", tp_cholesky_factor_cov2);
  print("tp_cholesky_factor_cov_ar = ", tp_cholesky_factor_cov_ar);
}
model {
  
}
generated quantities {
  corr_matrix[d] gq_corr_matrix1 = d_corr_matrix;
  corr_matrix[d] gq_corr_matrix2 = d_corr_matrix_ar[1];
  array[1] corr_matrix[d] gq_corr_matrix_ar = d_corr_matrix_ar;
  
  cov_matrix[d] gq_cov_matrix1 = d_cov_matrix;
  cov_matrix[d] gq_cov_matrix2 = d_cov_matrix_ar[1];
  array[1] cov_matrix[d] gq_cov_matrix_ar = d_cov_matrix_ar;
  
  cholesky_factor_corr[d] gq_cholesky_factor_corr1 = d_cholesky_factor_corr;
  cholesky_factor_corr[d] gq_cholesky_factor_corr2 = d_cholesky_factor_corr_ar[1];
  array[1] cholesky_factor_corr[d] gq_cholesky_factor_corr_ar = d_cholesky_factor_corr_ar;
  
  cholesky_factor_cov[d] gq_cholesky_factor_cov1 = d_cholesky_factor_cov;
  cholesky_factor_cov[d] gq_cholesky_factor_cov2 = d_cholesky_factor_cov_ar[1];
  array[1] cholesky_factor_cov[d] gq_cholesky_factor_cov_ar = d_cholesky_factor_cov_ar;
  
  print("gq_corr_matrix1 = ", gq_corr_matrix1);
  print("gq_corr_matrix2 = ", gq_corr_matrix2);
  print("gq_corr_matrix_ar = ", gq_corr_matrix_ar);
  
  print("gq_cov_matrix1 = ", gq_cov_matrix1);
  print("gq_cov_matrix2 = ", gq_cov_matrix2);
  print("gq_cov_matrix_ar = ", gq_cov_matrix_ar);
  
  print("gq_cholesky_factor_corr1 = ", gq_cholesky_factor_corr1);
  print("gq_cholesky_factor_corr2 = ", gq_cholesky_factor_corr2);
  print("gq_cholesky_factor_corr_ar = ", gq_cholesky_factor_corr_ar);
  
  print("gq_cholesky_factor_cov1 = ", gq_cholesky_factor_cov1);
  print("gq_cholesky_factor_cov2 = ", gq_cholesky_factor_cov2);
  print("gq_cholesky_factor_cov_ar = ", gq_cholesky_factor_cov_ar);
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-constrained-vector.stan
// no constrained types in functions or local variables

data {
  int d;
  simplex[d] d_simplex;
  array[d] simplex[d] d_simplex_ar;
  unit_vector[d] d_unit_vector;
  array[d] unit_vector[d] d_unit_vector_ar;
  ordered[d] d_ordered;
  array[d] ordered[d] d_ordered_ar;
  positive_ordered[d] d_positive_ordered;
  array[d] positive_ordered[d] d_positive_ordered_ar;
}
transformed data {
  simplex[d] td_simplex1 = d_simplex;
  simplex[d] td_simplex2 = d_simplex_ar[1];
  array[d] simplex[d] td_simplex_ar = d_simplex_ar;
  
  unit_vector[d] td_unit_vector1 = d_unit_vector;
  unit_vector[d] td_unit_vector2 = d_unit_vector_ar[1];
  array[d] unit_vector[d] td_unit_vector_ar = d_unit_vector_ar;
  
  ordered[d] td_ordered1 = d_ordered;
  ordered[d] td_ordered2 = d_ordered_ar[1];
  array[d] ordered[d] td_ordered_ar = d_ordered_ar;
  
  positive_ordered[d] td_positive_ordered1 = d_positive_ordered;
  positive_ordered[d] td_positive_ordered2 = d_positive_ordered_ar[1];
  array[d] positive_ordered[d] td_positive_ordered_ar = d_positive_ordered_ar;
  
  print("td_simplex1 = ", td_simplex1);
  print("td_simplex2 = ", td_simplex2);
  print("td_simplex_ar = ", td_simplex_ar);
  
  print("td_unit_vector1 = ", td_unit_vector1);
  print("td_unit_vector2 = ", td_unit_vector2);
  print("td_unit_vector_ar = ", td_unit_vector_ar);
  
  print("td_ordered1 = ", td_ordered1);
  print("td_ordered2 = ", td_ordered2);
  print("td_ordered_ar = ", td_ordered_ar);
  
  print("td_positive_ordered1 = ", td_positive_ordered1);
  print("td_positive_ordered2 = ", td_positive_ordered2);
  print("td_positive_ordered_ar = ", td_positive_ordered_ar);
}
transformed parameters {
  simplex[d] tp_simplex1 = d_simplex;
  simplex[d] tp_simplex2 = d_simplex_ar[1];
  array[d] simplex[d] tp_simplex_ar3 = d_simplex_ar;
  
  simplex[d] tp_simplex4 = tp_simplex1;
  simplex[d] tp_simplex5 = d_simplex_ar[1];
  array[d] simplex[d] tp_simplex_ar6 = tp_simplex_ar3;
  
  unit_vector[d] tp_unit_vector1 = d_unit_vector;
  unit_vector[d] tp_unit_vector2 = d_unit_vector_ar[1];
  array[d] unit_vector[d] tp_unit_vector_ar3 = d_unit_vector_ar;
  
  unit_vector[d] tp_unit_vector4 = tp_unit_vector1;
  unit_vector[d] tp_unit_vector5 = tp_unit_vector_ar3[2];
  array[d] unit_vector[d] tp_unit_vector_ar6 = tp_unit_vector_ar3;
  
  ordered[d] tp_ordered1 = d_ordered;
  ordered[d] tp_ordered2 = d_ordered_ar[1];
  array[d] ordered[d] tp_ordered_ar3 = d_ordered_ar;
  
  ordered[d] tp_ordered4 = tp_ordered1;
  ordered[d] tp_ordered5 = tp_ordered_ar3[3];
  array[d] ordered[d] tp_ordered_ar6 = tp_ordered_ar3;
  
  positive_ordered[d] tp_positive_ordered1 = d_positive_ordered;
  positive_ordered[d] tp_positive_ordered2 = d_positive_ordered_ar[1];
  array[d] positive_ordered[d] tp_positive_ordered_ar3 = d_positive_ordered_ar;
  
  positive_ordered[d] tp_positive_ordered4 = tp_positive_ordered1;
  positive_ordered[d] tp_positive_ordered5 = tp_positive_ordered_ar3[1];
  array[d] positive_ordered[d] tp_positive_ordered_ar6 = tp_positive_ordered_ar3;
  
  print("tp_simplex1 = ", tp_simplex1);
  print("tp_simplex2 = ", tp_simplex2);
  print("tp_simplex_ar3 = ", tp_simplex_ar3);
  print("tp_simplex4 = ", tp_simplex4);
  print("tp_simplex5 = ", tp_simplex5);
  print("tp_simplex_ar6 = ", tp_simplex_ar6);
  
  print("tp_unit_vector1 = ", tp_unit_vector1);
  print("tp_unit_vector2 = ", tp_unit_vector2);
  print("tp_unit_vector_ar3 = ", tp_unit_vector_ar3);
  print("tp_unit_vector4 = ", tp_unit_vector4);
  print("tp_unit_vector5 = ", tp_unit_vector5);
  print("tp_unit_vector_ar6 = ", tp_unit_vector_ar6);
  
  print("tp_ordered1 = ", tp_ordered1);
  print("tp_ordered2 = ", tp_ordered2);
  print("tp_ordered_ar3 = ", tp_ordered_ar3);
  print("tp_ordered4 = ", tp_ordered4);
  print("tp_ordered5 = ", tp_ordered5);
  print("tp_ordered_ar6 = ", tp_ordered_ar6);
  
  print("tp_positive_ordered1 = ", tp_positive_ordered1);
  print("tp_positive_ordered2 = ", tp_positive_ordered2);
  print("tp_positive_ordered_ar3 = ", tp_positive_ordered_ar3);
  print("tp_positive_ordered4 = ", tp_positive_ordered4);
  print("tp_positive_ordered5 = ", tp_positive_ordered5);
  print("tp_positive_ordered_ar6 = ", tp_positive_ordered_ar6);
}
model {
  
}
generated quantities {
  simplex[d] gq_simplex1 = d_simplex;
  simplex[d] gq_simplex2 = d_simplex_ar[1];
  array[d] simplex[d] gq_simplex_ar = d_simplex_ar;
  
  unit_vector[d] gq_unit_vector1 = d_unit_vector;
  unit_vector[d] gq_unit_vector2 = d_unit_vector_ar[1];
  array[d] unit_vector[d] gq_unit_vector_ar = d_unit_vector_ar;
  
  ordered[d] gq_ordered1 = d_ordered;
  ordered[d] gq_ordered2 = d_ordered_ar[1];
  array[d] ordered[d] gq_ordered_ar = d_ordered_ar;
  
  positive_ordered[d] gq_positive_ordered1 = d_positive_ordered;
  positive_ordered[d] gq_positive_ordered2 = d_positive_ordered_ar[1];
  array[d] positive_ordered[d] gq_positive_ordered_ar = d_positive_ordered_ar;
  
  print("gq_simplex1 = ", gq_simplex1);
  print("gq_simplex2 = ", gq_simplex2);
  print("gq_simplex_ar = ", gq_simplex_ar);
  
  print("gq_unit_vector1 = ", gq_unit_vector1);
  print("gq_unit_vector2 = ", gq_unit_vector2);
  print("gq_unit_vector_ar = ", gq_unit_vector_ar);
  
  print("gq_ordered1 = ", gq_ordered1);
  print("gq_ordered2 = ", gq_ordered2);
  print("gq_ordered_ar = ", gq_ordered_ar);
  
  print("gq_positive_ordered1 = ", gq_positive_ordered1);
  print("gq_positive_ordered2 = ", gq_positive_ordered2);
  print("gq_positive_ordered_ar = ", gq_positive_ordered_ar);
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-double.stan
functions {
  real foo(real a1) {
    int lf0 = 2;
    real lf1 = a1;
    real lf2 = lf1;
    array[lf0] real lf3;
    array[lf0] real lf4 = lf3;
    print("foo, lf1: ", lf1);
    print("foo, lf2: ", lf1);
    print("foo, lf4: ", lf4);
    lf1 = lf3[1] + lf4[1];
    return lf1;
  }
}
data {
  int<lower=0> N;
  array[N] int<lower=0, upper=1> y;
  array[3, 3] real d;
}
transformed data {
  int td0 = 3;
  real td1 = 123; // real_d = int_d
  real td2 = 2.0; // real_d = real_d
  real td3 = td0;
  real td4 = td3;
  array[3] real td_a1;
  array[3] real td_a2 = td_a1; // real_arr_d = real_arr_d
  real td5 = td_a2[1];
  array[3, 3] real td_a3 = d;
  array[3] real td_a4 = td_a3[2];
  print("td1: ", td1);
  print("td2: ", td2);
  print("td3: ", td3);
  print("td4: ", td4);
  print("td5: ", td5);
  print("td_a2: ", td_a2);
  print("td_a4: ", td_a4);
  {
    real ltd1 = 1; // real_d = int_d 
    real ltd2 = 2.0; // real_d = real_d
    real ltd3 = td1;
    array[td0] real ltd4;
    array[td0] real ltd5 = ltd4;
    print("ltd1: ", ltd1);
    print("ltd2: ", ltd2);
    print("ltd3: ", ltd3);
    print("ltd5: ", ltd5);
  }
}
parameters {
  real<lower=0, upper=1> theta;
}
transformed parameters {
  real d_tp1 = 1.0;
  real d_tp2 = td1;
  real d_tp3 = td0;
  real d_tp4 = d[1, 2];
  array[3] real d_tp_a1 = td_a4;
  array[3] real d_tp_a2 = td_a3[1];
  array[3, 3] real d_tp_a3 = d;
  
  real p_tp2 = d_tp1;
  real p_tp4 = d_tp_a1[1];
  array[3] real p_tp_a1 = d_tp_a1;
  array[3] real p_tp_a2 = d_tp_a3[3];
  
  real tp1 = 1; // real_p = int_d 
  real tp2 = 2.0; // real_p = real_d
  real tp3 = tp2; // real_p = real_p
  array[td0] real tp4;
  array[td0] real tp5 = tp4;
  
  print("d_tp1 = ", d_tp1);
  print("d_tp2 = ", d_tp2, " should be td1 = ", td1, " which should be 123");
  print("d_tp3 = ", d_tp3);
  print("d_tp4 = ", d_tp4);
  print("d_tp_a1 = ", d_tp_a1);
  print("d_tp_a2 = ", d_tp_a2);
  print("d_tp_a3 = ", d_tp_a3);
  
  print("p_tp2 = ", p_tp2);
  print("p_tp4 = ", p_tp4);
  print("p_tp_a1 = ", p_tp_a1);
  print("p_tp_a2 = ", p_tp_a2);
  
  print("tp1: ", tp1);
  print("tp2: ", tp2);
  print("tp3: ", tp3);
  print("tp5: ", tp5);
  tp1 = foo(tp3);
  print("tp1: ", tp1);
  {
    real lp1 = td0; // real_p = int_d 
    real lp2 = 9.0; // real_p = real_d
    real lp3 = tp2; // real_p = real_p
    array[td0] real lp4;
    array[td0] real lp5 = lp4;
    print("lp1: ", lp1);
    print("lp2: ", lp2);
    print("lp3: ", lp3);
    print("lp5: ", lp5);
  }
}
model {
  // local variables
  real lm1 = 1; // real_p = int_d 
  real lm2 = 2.0; // real_p = real_d
  real lm3 = tp2; // real_p = real_p
  theta ~ beta(1, 1);
  for (n in 1 : N) 
    y[n] ~ bernoulli(theta);
}
generated quantities {
  real gq_d_tp1 = 1.0;
  real gq_d_tp2 = td1;
  real gq_d_tp3 = td0;
  real gq_d_tp4 = d[1, 2];
  array[3] real gq_d_tp_a1 = td_a4;
  array[3] real gq_d_tp_a2 = td_a3[1];
  array[3, 3] real gq_d_tp_a3 = d;
  
  real gq_p_tp2 = d_tp1;
  real gq_p_tp4 = d_tp_a1[1];
  array[3] real gq_p_tp_a1 = d_tp_a1;
  array[3] real gq_p_tp_a2 = d_tp_a3[3];
  print("gq_d_tp1 = ", gq_d_tp1);
  print("gq_d_tp2 = ", gq_d_tp2, " should be td1 = ", td1,
        " which should be 123");
  print("gq_d_tp3 = ", gq_d_tp3);
  print("gq_d_tp4 = ", gq_d_tp4);
  print("gq_d_tp_a1 = ", gq_d_tp_a1);
  print("gq_d_tp_a2 = ", gq_d_tp_a2);
  print("gq_d_tp_a3 = ", gq_d_tp_a3);
  
  print("gq_p_tp2 = ", gq_p_tp2);
  print("gq_p_tp4 = ", gq_p_tp4);
  print("gq_p_tp_a1 = ", gq_p_tp_a1);
  print("gq_p_tp_a2 = ", gq_p_tp_a2);
  {
    real lgq1 = 1; // real_d = int_d
    real lgq2 = 2.0; // real_d = real_d
    real lqd2a = lgq2;
    array[td0] real lgq3;
    real lgq3a = lgq3[1];
    array[td0] real lgq4 = lgq3;
    array[3] real lgq5 = d[1];
    print("lgq1: ", lgq1);
    print("lgq2: ", lgq2);
    print("lgq2a: ", lqd2a);
    print("lgq3: ", lgq3);
    print("lgq3a: ", lgq3a);
    print("lgq4: ", lgq4);
    print("lgq5: ", lgq5);
  }
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-int.stan
functions {
  int foo() {
    int lf1 = 3;
    print("foo ", lf1);
    return lf1;
  }
}
data {
  int n;
  array[n, n] int d;
}
transformed data {
  int td1 = 1;
  int td2 = td1;
  array[n] int td_a1 = d[1];
  array[n] int td_a2 = td_a1;
  array[n, n] int td_a3 = d;
  array[n] int td_a4 = td_a3[n];
  int td3 = td_a3[2, 2];
  print("td1 = ", td1);
  print("td2 = ", td2);
  print("td3 = ", td3);
  print("td_a3 = ", td_a3);
  print("transformed data td2 ", td2);
  print("transformed data td_a2 ", td_a2);
  print("transformed data td_a4 ", td_a4);
}
transformed parameters {
  real p1;
  {
    int lp1 = 1;
    print("transformed param ", lp1);
  }
}
model {
  // local variables
  int lm1 = 4;
  print("local int ", lm1);
  print(foo());
}
generated quantities {
  int gq1 = 1;
  print("gq1 ", gq1);
  gq1 = 2;
  {
    int lgq1 = 2;
    print("gq2 ", lgq1);
    lgq1 = 2;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-matrix.stan
functions {
  matrix foo(int a) {
    matrix[a, a] lf0;
    matrix[a, a] lf1 = lf0;
    return lf1;
  }
}
data {
  int d;
  matrix[d, d] d_m;
  array[d] matrix[d, d] d_m_ar;
}
transformed data {
  matrix[d, d] td_m1 = d_m;
  matrix[d, d] td_m2 = d_m_ar[1];
  array[d] matrix[d, d] td_m_ar3 = d_m_ar;
  
  print("td_m1 = ", td_m1);
  print("td_m2 = ", td_m2);
  print("td_m_ar3 = ", td_m_ar3);
}
transformed parameters {
  matrix[d, d] tp_m1 = d_m;
  matrix[d, d] tp_m2 = d_m_ar[1];
  array[d] matrix[d, d] tp_m_ar3 = d_m_ar;
  matrix[d, d] tp_m4 = tp_m1;
  matrix[d, d] tp_m5 = tp_m_ar3[1];
  array[d] matrix[d, d] tp_m_ar6 = tp_m_ar3;
  
  print("tp_m1 = ", tp_m1);
  print("tp_m2 = ", tp_m2);
  print("tp_m_ar3 = ", tp_m_ar3);
  print("tp_m4 = ", tp_m4);
  print("tp_m5 = ", tp_m5);
  print("tp_m_ar6 = ", tp_m_ar6);
  {
    matrix[d, d] local_m1 = d_m;
    matrix[d, d] local_m2 = d_m_ar[1];
    array[d] matrix[d, d] local_m_ar3 = d_m_ar;
    matrix[d, d] local_m4 = tp_m1;
    matrix[d, d] local_m5 = tp_m_ar3[1];
    array[d] matrix[d, d] local_m_ar6 = tp_m_ar3;
    print("local_m1 = ", local_m1);
    print("local_m2 = ", local_m2);
    print("local_m_ar3 = ", local_m_ar3);
    print("local_m4 = ", local_m4);
    print("local_m5 = ", local_m5);
    print("local_m_ar6 = ", local_m_ar6);
  }
}
model {
  
}
generated quantities {
  matrix[d, d] gq_m1 = d_m;
  matrix[d, d] gq_m2 = d_m_ar[1];
  array[d] matrix[d, d] gq_m_ar3 = d_m_ar;
  matrix[d, d] gq_m4 = tp_m1;
  matrix[d, d] gq_m5 = tp_m_ar3[1];
  array[d] matrix[d, d] gq_m_ar6 = tp_m_ar3;
  
  print("gq_m1 = ", gq_m1);
  print("gq_m2 = ", gq_m2);
  print("gq_m_ar3 = ", gq_m_ar3);
  print("gq_m4 = ", gq_m4);
  print("gq_m5 = ", gq_m5);
  print("gq_m_ar6 = ", gq_m_ar6);
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-vec-runtime-error.stan
data {
  vector[7] b0;
}
transformed data {
  vector[8] td_b2 = b0; // can't check dimension sizes at compile time
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format declare-define-var-vec-types.stan
functions {
  void foo1() {
    vector[2] lf1;
    vector[2] lf2 = lf1;
    print("i am void");
  }
  vector foo2(int x) {
    vector[x] lf1;
    return lf1;
  }
}
data {
  int d;
  vector[d] d_v;
  row_vector[d] d_rv;
  array[d] vector[d] d_v_ar;
  array[d] row_vector[d] d_rv_ar;
  matrix[d, d] d_m;
}
transformed data {
  vector[d] td_v1 = d_v;
  vector[d] td_v2 = d_v_ar[1];
  vector[d] td_v3 = d_m[ : , 1];
  array[d] vector[d] td_v_ar = d_v_ar;
  
  row_vector[d] td_rv1 = d_rv;
  row_vector[d] td_rv2 = d_rv_ar[1];
  row_vector[d] td_rv3 = d_m[2];
  array[d] row_vector[d] td_rv_ar = d_rv_ar;
  
  print("td_v1 = ", td_v1);
  print("td_v2 = ", td_v2);
  print("td_v3 = ", td_v3);
  print("td_v_ar = ", td_v_ar);
  print("td_rv1 = ", td_rv1);
  print("td_rv2 = ", td_rv2);
  print("td_rv3 = ", td_rv3);
  print("td_rv_ar = ", td_rv_ar);
  
  {
    vector[d] local_v1 = d_v;
    vector[d] local_v2 = d_v_ar[1];
    vector[d] local_v3 = d_m[ : , 1];
    array[d] vector[d] local_v_ar = d_v_ar;
    
    row_vector[d] local_rv1 = d_rv;
    row_vector[d] local_rv2 = d_rv_ar[1];
    row_vector[d] local_rv3 = d_m[2];
    array[d] row_vector[d] local_rv_ar = d_rv_ar;
    
    print("local_v1 = ", local_v1);
    print("local_v2 = ", local_v2);
    print("local_v3 = ", local_v3);
    print("local_v_ar = ", local_v_ar);
    print("local_rv1 = ", local_rv1);
    print("local_rv2 = ", local_rv2);
    print("local_rv3 = ", local_rv3);
    print("local_rv_ar = ", local_rv_ar);
  }
  foo1();
}
parameters {
  matrix<lower=0, upper=1>[d, d] p_m;
}
transformed parameters {
  vector[d] tp_v1 = d_v;
  vector[d] tp_v2 = d_v_ar[1];
  vector[d] tp_v3 = d_m[ : , 1];
  array[d] vector[d] tp_v_ar4 = d_v_ar;
  
  vector[d] tp_v5 = tp_v1;
  vector[d] tp_v6 = tp_v_ar4[1];
  vector[d] tp_v7 = p_m[ : , 1];
  array[d] vector[d] tp_v_ar8 = tp_v_ar4;
  
  row_vector[d] tp_rv1 = d_rv;
  row_vector[d] tp_rv2 = d_rv_ar[1];
  row_vector[d] tp_rv3 = d_m[2];
  array[d] row_vector[d] tp_rv_ar4 = d_rv_ar;
  
  row_vector[d] tp_rv5 = tp_rv1;
  row_vector[d] tp_rv6 = tp_rv_ar4[1];
  row_vector[d] tp_rv7 = p_m[2,  : ];
  array[d] row_vector[d] tp_rv_ar8 = tp_rv_ar4;
  
  print("tp_v1 = ", tp_v1);
  print("tp_v2 = ", tp_v2);
  print("tp_v3 = ", tp_v3);
  print("tp_v_ar4 = ", tp_v_ar4);
  print("tp_v5 = ", tp_v5);
  print("tp_v6 = ", tp_v6);
  print("tp_v7 = ", tp_v7);
  print("tp_v_ar8 = ", tp_v_ar8);
  
  print("tp_rv1 = ", tp_rv1);
  print("tp_rv2 = ", tp_rv2);
  print("tp_rv3 = ", tp_rv3);
  print("tp_rv_ar = ", tp_rv_ar4);
  print("tp_rv5 = ", tp_rv5);
  print("tp_rv6 = ", tp_rv6);
  print("tp_rv7 = ", tp_rv7);
  print("tp_rv_ar8 = ", tp_rv_ar8);
  
  {
    vector[d] local_v1 = d_v;
    vector[d] local_v2 = d_v_ar[1];
    vector[d] local_v3 = d_m[ : , 1];
    array[d] vector[d] local_v_ar4 = d_v_ar;
    vector[d] local_v5 = tp_v1;
    vector[d] local_v6 = tp_v_ar4[1];
    vector[d] local_v7 = p_m[ : , 1];
    array[d] vector[d] local_v_ar8 = tp_v_ar4;
    
    row_vector[d] local_rv1 = d_rv;
    row_vector[d] local_rv2 = d_rv_ar[1];
    row_vector[d] local_rv3 = d_m[2];
    array[d] row_vector[d] local_rv_ar4 = d_rv_ar;
    row_vector[d] local_rv5 = tp_rv1;
    row_vector[d] local_rv6 = tp_rv_ar4[1];
    row_vector[d] local_rv7 = p_m[1];
    array[d] row_vector[d] local_rv_ar8 = tp_rv_ar4;
    
    print("local_v1 = ", local_v1);
    print("local_v2 = ", local_v2);
    print("local_v3 = ", local_v3);
    print("local_v_ar4 = ", local_v_ar4);
    print("local_v5 = ", local_v5);
    print("local_v6 = ", local_v6);
    print("local_v7 = ", local_v7);
    print("local_v_ar8 = ", local_v_ar8);
    print("local_rv1 = ", local_rv1);
    print("local_rv2 = ", local_rv2);
    print("local_rv3 = ", local_rv3);
    print("local_rv_ar4 = ", local_rv_ar4);
    print("local_rv5 = ", local_rv5);
    print("local_rv6 = ", local_rv6);
    print("local_rv7 = ", local_rv7);
    print("local_rv_ar8 = ", local_rv_ar8);
  }
}
model {
  
}
generated quantities {
  
}

  $ ../../../../install/default/bin/stanc --auto-format fun-defs-lpdf.stan
functions {
  real bar_baz_lpdf(real a, real b) {
    return a / b;
  }
  real foo_bar_lpdf(array[,,,] real x) {
    return 1.0;
  }
  real baz_foo_lpdf(complex z, real a) {
    return get_imag(z) * a;
  }
}
parameters {
  real y;
  complex z;
  array[1, 1, 1, 1] real arr;
}
model {
  y ~ bar_baz(3.2);
  z ~ baz_foo(1.5);
  arr ~ foo_bar();
}

  $ ../../../../install/default/bin/stanc --auto-format fun-return-typ1.stan
functions {
  real foo() {
    reject("");
  }
}

  $ ../../../../install/default/bin/stanc --auto-format fun-return-typ2.stan
functions {
  real foo() {
    if (1) 
      reject("");
    reject("");
  }
}

  $ ../../../../install/default/bin/stanc --auto-format fun-return-typ4.stan
functions {
  real foo() {
    if (1) 
      reject("");
    else {
      if (1) 
        ;
      else 
        reject("");
    }
    reject("");
  }
}

  $ ../../../../install/default/bin/stanc --auto-format fun-var-constraints.stan
functions {
  real foo() {
    return 0;
  }
}
data {
  real<lower=foo(), upper=1> b;
}
transformed data {
  real<lower=-100, upper=foo()> bt;
}
parameters {
  real<lower=foo(), upper=1> y;
}
transformed parameters {
  real<lower=-100, upper=foo()> yt;
}
model {
  y ~ normal(0, 1);
}
generated quantities {
  real<lower=-100, upper=foo()> g;
}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_0.stan
functions {
  real foo() {
    return 1.7;
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_0_lp.stan
functions {
  real foo_lp() {
    return 1.0;
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_1.stan
functions {
  real foo(real x) {
    return x;
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_4.stan
functions {
  real foo(real x1, real x2, real x3, real x4) {
    return x1;
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_4_lp.stan
functions {
  real foo_lp(real x1, real x2, real x3, real x4) {
    return x1;
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_5.stan
functions {
  real foo(real x1, real x2, real x3, real x4, real x5) {
    return x1;
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_5_lp.stan
functions {
  real foo_lp(real x1, real x2, real x3, real x4, real x5) {
    return x1;
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_int0.stan
functions {
  int foo() {
    return 3;
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_int_1_int.stan
functions {
  int foo(int x) {
    return x;
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format fun_args_int_1_real.stan
functions {
  int foo(real x) {
    return 3;
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format fun_as_lhs_sampling.stan
// programs to tickle bug 2612
// sampling stmts w/ function calls

transformed data {
  matrix[2, 2] M = rep_matrix(0, 2, 2);
}
model {
  to_vector(M) ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format fun_as_stmt.stan
// programs to tickle bug 2612
functions {
  void foo_lp() {
    // does nothing
  }
}
model {
  foo_lp();
}

  $ ../../../../install/default/bin/stanc --auto-format functions-good-void.stan
functions {
  void linear_regression_lp(vector x, vector y, real alpha, real beta,
                            real sigma) {
    y ~ normal(x * alpha + beta, sigma);
    sigma ~ cauchy(0, 2.5);
    alpha ~ normal(0, 10);
    beta ~ normal(0, 10);
  }
}
data {
  int<lower=0> N;
  vector[N] x;
  vector[N] y;
}
parameters {
  real alpha;
  real beta;
  real<lower=0> sigma;
}
model {
  linear_regression_lp(x, y, alpha, beta, sigma);
}

  $ ../../../../install/default/bin/stanc --auto-format functions-good1.stan
/**
 * Tests for 0, 1, 2 arity functions void and non-void returns
 * and calls.
 */
functions {
  real foo0() {
    return 0.0;
  }
  real foo1(real x) {
    return 1.0;
  }
  real foo2(real x, real y) {
    return 2.0;
  }
  
  real foo0_lp() {
    return 0.0;
  }
  real foo1_lp(real x) {
    return 1.0;
  }
  real foo2_lp(real x, real y) {
    return 2.0;
  }
  
  real foo0_rng() {
    return 0.0;
  }
  real foo1_rng(real x) {
    return 2.0 * x;
  }
  real foo2_rng(real x, real y) {
    return x * y - 2.0;
  }
  
  real foo0_lpmf(int y) {
    return -5;
  }
  real foo1_lpdf(real x) {
    return -exp(x * x);
  }
  real foo2_lpdf(real x, real y) {
    real diff;
    diff = x - y;
    return -exp(diff * diff);
  }
}
data {
  array[6] int<lower=0> N;
}
transformed data {
  real a;
  real b;
  real c;
  // double, int arguments
  a = foo0();
  b = foo1(N[6]);
  c = foo2(a, b);
  c = foo2(a, 1);
  c = foo2(2, b);
  c = foo2(2, 3);
  
  a = foo0_lpmf(2);
  b = foo1_lpdf(N[6]);
  c = foo2_lpdf(a | b);
  c = foo2_lpdf(a | 1);
  c = foo2_lpdf(2 | b);
  c = foo2_lpdf(2 | 3);
  
  a = foo0_rng();
  b = foo1_rng(a);
  b = foo1_rng(1);
  c = foo2_rng(a, b);
  c = foo2_rng(1, b);
  c = foo2_rng(a, 2);
  c = foo2_rng(1, 2);
}
parameters {
  array[10] real<lower=0, upper=1> theta;
}
transformed parameters {
  real phi1;
  real phi2;
  real phi3;
  // var, double and mixed instantiations
  phi1 = foo0();
  phi2 = foo1(1);
  phi2 = foo1(2.0);
  phi2 = foo1(phi1);
  
  phi3 = foo2(1.0, 2.0);
  phi3 = foo2(1.0, 2);
  phi3 = foo2(1, 2.0);
  phi3 = foo2(1, 2);
  
  phi3 = foo2(phi1, 2.0);
  phi3 = foo2(phi1, 2);
  
  phi3 = foo2(1.0, phi2);
  phi3 = foo2(1, phi2);
  
  phi3 = foo2(phi1, phi2);
  
  //   phi1 = foo0_lp();
  //   phi2 = foo1_lp(1);
  //   phi2 = foo1_lp(2.0);
  //   phi2 = foo1_lp(phi1);
  
  //   phi3 = foo2_lp(1.0,2.0);
  //   phi3 = foo2_lp(1.0,2);
  //   phi3 = foo2_lp(1,2.0);
  //   phi3 = foo2_lp(1,2);
  
  //   phi3 = foo2_lp(phi1,2.0);
  //   phi3 = foo2_lp(phi1,2);
  
  //   phi3 = foo2_lp(1.0,phi2);
  //   phi3 = foo2_lp(1,phi2);
  
  //   phi3 = foo2_lp(phi1,phi2);
  
  phi1 = foo0_lpmf(3);
  
  phi2 = foo1_lpdf(1);
  phi2 = foo1_lpdf(2.0);
  phi2 = foo1_lpdf(phi1);
  
  phi3 = foo2_lpdf(1.0 | 2.0);
  phi3 = foo2_lpdf(1.0 | 2);
  phi3 = foo2_lpdf(1 | 2.0);
  phi3 = foo2_lpdf(1 | 2);
  
  phi3 = foo2_lpdf(phi1 | 2.0);
  phi3 = foo2_lpdf(phi1 | 2);
  
  phi3 = foo2_lpdf(1.0 | phi2);
  phi3 = foo2_lpdf(1 | phi2);
  
  phi3 = foo2_lpdf(phi1 | phi2);
}
model {
  real psi1;
  real psi2;
  real psi3;
  
  psi1 = foo0();
  psi2 = foo1(1);
  psi2 = foo1(2.0);
  psi2 = foo1(psi1);
  
  psi3 = foo2(1.0, 2.0);
  psi3 = foo2(1.0, 2);
  psi3 = foo2(1, 2.0);
  psi3 = foo2(1, 2);
  
  psi3 = foo2(psi1, 2.0);
  psi3 = foo2(psi1, 2);
  
  psi3 = foo2(1.0, psi2);
  psi3 = foo2(1, psi2);
  
  psi3 = foo2(psi1, psi2);
  
  psi1 = foo0_lp();
  psi2 = foo1_lp(1);
  psi2 = foo1_lp(2.0);
  psi2 = foo1_lp(psi1);
  
  psi3 = foo2_lp(1.0, 2.0);
  psi3 = foo2_lp(1.0, 2);
  psi3 = foo2_lp(1, 2.0);
  psi3 = foo2_lp(1, 2);
  
  psi3 = foo2_lp(psi1, 2.0);
  psi3 = foo2_lp(psi1, 2);
  
  psi3 = foo2_lp(1.0, psi2);
  psi3 = foo2_lp(1, psi2);
  
  psi3 = foo2_lp(psi1, psi2);
  
  psi1 = foo0_lpmf(3);
  psi2 = foo1_lpdf(1);
  psi2 = foo1_lpdf(2.0);
  psi2 = foo1_lpdf(psi1);
  
  psi3 = foo2_lpdf(1.0 | 2.0);
  psi3 = foo2_lpdf(1.0 | 2);
  psi3 = foo2_lpdf(1 | 2.0);
  psi3 = foo2_lpdf(1 | 2);
  
  psi3 = foo2_lpdf(psi1 | 2.0);
  psi3 = foo2_lpdf(psi1 | 2);
  
  psi3 = foo2_lpdf(1.0 | psi2);
  psi3 = foo2_lpdf(1 | psi2);
  
  psi3 = foo2_lpdf(psi1 | psi2);
  
  // use _log as sampling statements
  theta[1] ~ foo1();
  theta[2] ~ foo2(theta[1]);
}
generated quantities {
  real x;
  real y;
  real z;
  // double instantiations
  x = foo0();
  y = foo1(x);
  y = foo1(1);
  z = foo2(x, y);
  z = foo2(1, y);
  z = foo2(x, 2);
  z = foo2(1, 2);
  
  x = foo0_lpmf(3);
  y = foo1_lpdf(x);
  y = foo1_lpdf(1);
  z = foo2_lpdf(x | y);
  z = foo2_lpdf(1 | y);
  z = foo2_lpdf(x | 2);
  z = foo2_lpdf(1 | 2);
  
  x = foo0_rng();
  y = foo1_rng(x);
  y = foo1_rng(1);
  z = foo2_rng(x, y);
  z = foo2_rng(1, y);
  z = foo2_rng(x, 2);
  z = foo2_rng(1, 2);
}

  $ ../../../../install/default/bin/stanc --auto-format functions-good2.stan
functions {
  real foo_bar0() {
    return 0.0;
  }
  real foo_bar1(real x) {
    return 1.0;
  }
  real foo_bar2(real x, real y) {
    return 2.0;
  }
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format functions-good3.stan
/**
 * test return statement source propagation
 */
functions {
  real unit_normal_rng() {
    return normal_rng(0, 1);
  }
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}
generated quantities {
  real z;
  z = unit_normal_rng();
}

  $ ../../../../install/default/bin/stanc --auto-format functions-promote-return.stan
functions {
  vector foo(vector x, real y) {
    if (y < 10) 
      return log(x); // problem is here if x data and y parameter
    else 
      return log(y * x); // this promotes OK given x and y scalars
  }
}
transformed data {
  vector[3] x;
  x = rep_vector(0, 3);
}
parameters {
  real y;
}
model {
  foo(x, y) ~ normal(0, 1); // foo(x,y) has x double, y var, and return type var
}

  $ ../../../../install/default/bin/stanc --auto-format funs1.stan
functions {
  void unit_normal_lp(real u) {
    target += normal_lpdf(u | 0, 1);
    u ~ uniform(-100, 100);
  }
}
parameters {
  real y;
}
model {
  unit_normal_lp(y);
}

  $ ../../../../install/default/bin/stanc --auto-format funs2.stan
functions {
  real unit_normal_rng() {
    return normal_rng(0, 1);
  }
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}
generated quantities {
  real z;
  z = unit_normal_rng();
}

  $ ../../../../install/default/bin/stanc --auto-format funs3.stan
functions {
  real unit_normal_lpdf(real y) {
    return normal_lpdf(y | 0, 1);
  }
}
parameters {
  real y;
}
model {
  y ~ unit_normal();
}

  $ ../../../../install/default/bin/stanc --auto-format funs4.stan
functions {
  real unit_normal_lpdf(real y) {
    return normal_lpdf(y | 0, 1);
  }
}
parameters {
  real y;
}
model {
  target += unit_normal_lpdf(y);
}

  $ ../../../../install/default/bin/stanc --auto-format funs5.stan
functions {
  void foo(real x) {
    print("x=", x);
  }
}
parameters {
  real y;
}
model {
  foo(y);
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format funs6.stan
functions {
  real foo(real x) {
    return x * 2;
  }
}
parameters {
  real y;
}
model {
  foo(y) ~ normal(0, 2);
}

  $ ../../../../install/default/bin/stanc --auto-format funs7.stan
functions {
  real foo(real z) {
    real y;
    y = 1 ? z : 1;
    return y;
  }
}
parameters {
  real y;
}
transformed parameters {
  real z = foo(y);
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format genquant-data-only.stan
functions {
  real f(data real x) {
    return x + 1;
  }
}
parameters {
  real x;
}
generated quantities {
  real y = f(x);
}

  $ ../../../../install/default/bin/stanc --auto-format good_fundef_returntypes1.stan
functions {
  real foo() {
    if (215) 
      return 24;
    return 24;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format good_fundef_returntypes2.stan
functions {
  void foo() {
    if (215) 
      return;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format good_fundef_returntypes3.stan
functions {
  real foo() {
    if (215) 
      return 24;
    reject("");
  }
}

  $ ../../../../install/default/bin/stanc --auto-format good_fundef_returntypes4.stan
functions {
  real foo() {
    if (215) 
      return 24;
    else 
      reject("");
  }
}

  $ ../../../../install/default/bin/stanc --auto-format good_inf.stan
/*
 * tests to make sure variables with prefix "inf" can
 * be used in models.
 */
data {
  real L;
  real U;
}
parameters {
  real<lower=L, upper=U> infty;
}
model {
  infty ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format if-else-formatting.stan
generated quantities {
  // make sure pp_recursive_ifthenelse properly places else
  // should be formatted like `} else {` unless a comment is in way
  if (1) {
    // something
  } else {
    // something else
  }
  
  if (1) {
    // something
  } else {
    // something else
  }
  
  if (1) {
    // something
  } else {
    /* something else */
  }
  
  if (1) {
    // something
  } else if (0) {
    /* something else */
  } // test
  else {
    
  }
  
  int x;
  if (0) 
    x = 1; /* test */
  else 
    x = 2;
  
  if (1) {
    // something
  } else {
    // something else
  }
}

  $ ../../../../install/default/bin/stanc --auto-format illegal_generated_quantities.stan
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}
generated quantities {
  real<lower=0> x;
  x = -1;
}

  $ ../../../../install/default/bin/stanc --auto-format illegal_transformed_data.stan
transformed data {
  real<lower=0> x;
  
  x = -1;
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format illegal_transformed_parameters.stan
transformed parameters {
  real<lower=0> x;
  
  x = -1;
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format increment-target.stan
data {
  real a;
  vector[3] b;
  array[7] real c;
  array[8, 9] real d;
}
parameters {
  real e;
  vector[3] f;
  array[7] real g;
  array[8, 9] real h;
}
model {
  target += -e ^ 2 / 2;
  target += a;
  target += b;
  target += b;
  target += c;
  target += d;
  target += e;
  target += f;
  target += g;
  target += h;
}

  $ ../../../../install/default/bin/stanc --auto-format infinite_loop_return.stan
functions {
  int bin_search(real x, int min_val, int max_val) {
    if (min_val > x || max_val < x) 
      reject("require min < x < max, found min = ", min_val, "; max = ",
             max_val, "; x = ", x);
    real y = round(x);
    int range = max_val - min_val;
    int mid_pt = min_val;
    while (1) {
      if (range == 0) 
        return mid_pt;
      range = (range + 1) %/% 2;
      mid_pt += y > mid_pt ? range : -range;
    }
  }
}
transformed data {
  int N = bin_search(34.5, 0, 50);
  print(N);
}

  $ ../../../../install/default/bin/stanc --auto-format int_fun.stan
functions {
  int foo(int x) {
    return x + 1;
  }
}
transformed data {
  int x;
  x = foo(2);
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format int_overloads.stan
data {
  int d_int;
  real d_real;
}
transformed data {
  int transformed_data_int;
  real transformed_data_real;
  transformed_data_real = abs(d_int);
  transformed_data_real = abs(d_real);
  transformed_data_real = abs(d_int);
  transformed_data_real = abs(d_real);
  transformed_data_real = exp(d_int);
  transformed_data_real = exp(d_real);
  transformed_data_real = exp2(d_int);
  transformed_data_real = exp2(d_real);
  transformed_data_real = expm1(d_int);
  transformed_data_real = expm1(d_real);
  transformed_data_real = log(d_int);
  transformed_data_real = log(d_real);
  transformed_data_real = log1p(d_int);
  transformed_data_real = log1p(d_real);
  transformed_data_real = log2(d_int);
  transformed_data_real = log2(d_real);
  transformed_data_real = log10(d_int);
  transformed_data_real = log10(d_real);
  transformed_data_real = pow(d_int, d_int);
  transformed_data_real = pow(d_real, d_int);
  transformed_data_real = pow(d_int, d_real);
  transformed_data_real = pow(d_real, d_real);
  transformed_data_real = sqrt(d_int);
  transformed_data_real = sqrt(d_real);
  transformed_data_real = cbrt(d_int);
  transformed_data_real = cbrt(d_real);
  transformed_data_real = sin(d_int);
  transformed_data_real = sin(d_real);
  transformed_data_real = cos(d_int);
  transformed_data_real = cos(d_real);
  transformed_data_real = tan(d_int);
  transformed_data_real = tan(d_real);
  transformed_data_real = asin(d_int);
  transformed_data_real = asin(d_real);
  transformed_data_real = acos(d_int);
  transformed_data_real = acos(d_real);
  transformed_data_real = atan(d_int);
  transformed_data_real = atan(d_real);
  transformed_data_real = atan2(d_int, d_int);
  transformed_data_real = atan2(d_real, d_int);
  transformed_data_real = atan2(d_int, d_real);
  transformed_data_real = atan2(d_real, d_real);
  transformed_data_real = sinh(d_int);
  transformed_data_real = sinh(d_real);
  transformed_data_real = cosh(d_int);
  transformed_data_real = cosh(d_real);
  transformed_data_real = tanh(d_int);
  transformed_data_real = tanh(d_real);
  transformed_data_real = asinh(d_int);
  transformed_data_real = asinh(d_real);
  transformed_data_real = acosh(d_int);
  transformed_data_real = acosh(d_real);
  transformed_data_real = atanh(d_int);
  transformed_data_real = atanh(d_real);
  transformed_data_real = erf(d_int);
  transformed_data_real = erf(d_real);
  transformed_data_real = erfc(d_int);
  transformed_data_real = erfc(d_real);
  transformed_data_real = tgamma(d_int);
  transformed_data_real = tgamma(d_real);
  transformed_data_real = ceil(d_int);
  transformed_data_real = ceil(d_real);
  transformed_data_real = floor(d_int);
  transformed_data_real = floor(d_real);
  transformed_data_real = trunc(d_int);
  transformed_data_real = trunc(d_real);
  transformed_data_real = round(d_int);
  transformed_data_real = round(d_real);
  transformed_data_real = trigamma(d_int);
  transformed_data_real = trigamma(d_real);
}
parameters {
  real p_real;
  real y_p;
}
transformed parameters {
  real transformed_param_real;
  transformed_param_real = abs(p_real);
  transformed_param_real = abs(p_real);
  transformed_param_real = exp(p_real);
  transformed_param_real = exp2(p_real);
  transformed_param_real = expm1(p_real);
  transformed_param_real = log(p_real);
  transformed_param_real = log1p(p_real);
  transformed_param_real = log2(p_real);
  transformed_param_real = log10(p_real);
  transformed_param_real = pow(d_int, p_real);
  transformed_param_real = pow(p_real, d_int);
  transformed_param_real = pow(p_real, p_real);
  transformed_param_real = sqrt(p_real);
  transformed_param_real = cbrt(p_real);
  transformed_param_real = sin(p_real);
  transformed_param_real = cos(p_real);
  transformed_param_real = tan(p_real);
  transformed_param_real = asin(p_real);
  transformed_param_real = acos(p_real);
  transformed_param_real = atan(p_real);
  transformed_param_real = sinh(p_real);
  transformed_param_real = cosh(p_real);
  transformed_param_real = tanh(p_real);
  transformed_param_real = asinh(p_real);
  transformed_param_real = acosh(p_real);
  transformed_param_real = atanh(p_real);
  transformed_param_real = erf(p_real);
  transformed_param_real = erfc(p_real);
  transformed_param_real = tgamma(p_real);
  transformed_param_real = ceil(p_real);
  transformed_param_real = floor(p_real);
  transformed_param_real = trunc(p_real);
  transformed_param_real = round(p_real);
  transformed_param_real = trigamma(p_real);
  transformed_param_real = trigamma(d_real);
}
model {
  y_p ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format io_example.stan
transformed data {
  vector[2] y;
}
parameters {
  real mu1;
  real mu2;
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-else-if.stan
parameters {
  real a;
  real if2;
}
model {
  if (1 > 2) {
    a ~ normal(0, 1);
  } else 
    if2 ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-else.stan
parameters {
  real a;
  real elseif;
}
model {
  if (1 > 2) {
    a ~ normal(0, 1);
  }
  elseif ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-for.stan
parameters {
  real force;
}
model {
  force ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-if.stan
parameters {
  real iffy;
}
model {
  iffy ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-increment-log-prob.stan
parameters {
  real increment_log_prob2;
}
model {
  increment_log_prob2 ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-integrate-ode.stan
parameters {
  real integrate_ode_foo;
}
model {
  integrate_ode_foo ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-print.stan
parameters {
  real printer;
}
model {
  printer ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-reject.stan
parameters {
  real rejection;
}
model {
  rejection ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-return.stan
parameters {
  real returning;
}
model {
  returning ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format keywords-while.stan
parameters {
  real whiley;
}
model {
  whiley ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format logistic_regression_reg_horseshoe.stan
data {
  int<lower=0> n;
  int<lower=0> d;
  array[n] int<lower=0, upper=1> y;
  matrix[n, d] x;
  real<lower=0> scale_icept;
  real<lower=0> scale_global;
  real<lower=1> nu_global;
  real<lower=1> nu_local;
  real<lower=0> slab_scale;
  real<lower=0> slab_df;
}
parameters {
  real beta0;
  vector[d] z;
  real<lower=0> tau;
  vector<lower=0>[d] lambda;
  real<lower=0> caux;
}
transformed parameters {
  vector[d] beta;
  {
    vector[d] lambda_tilde;
    real c = slab_scale * sqrt(caux);
    lambda_tilde = sqrt(c ^ 2 * square(lambda)
                        ./ (c ^ 2 + tau ^ 2 * square(lambda)));
    beta = z .* lambda_tilde * tau;
  }
}
model {
  z ~ std_normal();
  lambda ~ student_t(nu_local, 0, 1);
  tau ~ student_t(nu_global, 0, scale_global * 2);
  caux ~ inv_gamma(0.5 * slab_df, 0.5 * slab_df);
  beta0 ~ normal(0, scale_icept);
  y ~ bernoulli_logit_glm(x, beta0, beta);
}

  $ ../../../../install/default/bin/stanc --auto-format lower-trunc-discrete.stan
functions {
  // new syntax
  real foo_lpmf(int y, real lambda) {
    return 1.0;
  }
  real foo_lcdf(int y, real lambda) {
    return 1.0;
  }
  real foo_lccdf(int y, real lambda) {
    return 1.0;
  }
  
  // new syntax
  real baz_lpdf(real y, real lambda) {
    return 1.0;
  }
  real baz_lcdf(real y, real lambda) {
    return 1.0;
  }
  real baz_lccdf(real y, real lambda) {
    return 1.0;
  }
}
data {
  int N;
  array[N] int y;
  array[N] real u;
  int L;
  int U;
}
parameters {
  real<lower=0> lambda;
}
model {
  for (n in 1 : N) {
    // discrete, built-in
    y[n] ~ poisson(lambda) T[L, ];
    y[n] ~ poisson(lambda) T[L, U];
    y[n] ~ poisson(lambda) T[ , U];
    
    // discrete, user-defined, new syntax
    y[n] ~ foo(lambda) T[L, ];
    y[n] ~ foo(lambda) T[L, U];
    y[n] ~ foo(lambda) T[ , U];
    
    // continuous, built-in
    u[n] ~ normal(0, 1) T[L, ];
    u[n] ~ normal(0, 1) T[ , U];
    u[n] ~ normal(0, 1) T[L, U];
    
    // continuous, user-defined, new syntax
    y[n] ~ baz(lambda) T[L, ];
    y[n] ~ baz(lambda) T[L, U];
    y[n] ~ baz(lambda) T[ , U];
  }
}

  $ ../../../../install/default/bin/stanc --auto-format lp_in_fun.stan
functions {
  void foo_lp() {
    print("lp__ = ", target());
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format lp_transformed_param.stan
functions {
  real test_lp(real r) {
    target += normal_lpdf(r | 0, 1);
    return r;
  }
  void nr_test_lp(real r) {
    target += normal_lpdf(r | 0, 1);
  }
}
parameters {
  real y;
}
transformed parameters {
  real alpha = test_lp(5.0);
  nr_test_lp(5.0);
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format map_rect.stan
functions {
  vector foo(vector shared_params, vector job_params, array[] real data_r,
             array[] int data_i) {
    return [1, 2, 3]';
  }
  real map_rectfake(real x) {
    return 2 * x;
  }
}
data {
  vector[3] shared_params_d;
  array[3] vector[3] job_params_d;
  array[3, 3] real data_r;
  array[3, 3] int data_i;
}
parameters {
  vector[3] shared_params_p;
  array[3] vector[3] job_params_p;
}
transformed parameters {
  real abc1_p = 3;
  real abc2_p = map_rectfake(abc1_p);
  real abc3_p = map_rectfake(12);
  vector[3] y_hat_tp1 = map_rect(foo, shared_params_p, job_params_d, data_r,
                                 data_i);
  vector[3] y_hat_tp2 = map_rect(foo, shared_params_d, job_params_p, data_r,
                                 data_i);
  vector[3] y_hat_tp3 = map_rect(foo, shared_params_p, job_params_d, data_r,
                                 data_i);
}
model {
  real abc_m = map_rectfake(abc1_p);
}
generated quantities {
  real abc1_gq = map_rectfake(12);
  real abc2_gq = map_rectfake(abc1_p);
  vector[3] y_hat_gq = map_rect(foo, shared_params_d, job_params_d, data_r,
                                data_i);
}

  $ ../../../../install/default/bin/stanc --auto-format mat_assign.stan
transformed data {
  matrix[2, 2] X;
  row_vector[2] y;
  y[1] = 10;
  y[2] = 100;
  
  X[1] = y;
  X[2] = y;
  print("X=", X);
}
parameters {
  real z;
}
transformed parameters {
  matrix[2, 2] Xvar;
  matrix[2, 2] Xvar2;
  row_vector[2] yvar;
  
  yvar[1] = 15.9;
  yvar[2] = 42.7;
  
  Xvar[1] = y;
  Xvar[2] = y;
  
  Xvar2[1] = yvar;
  Xvar2[2] = yvar;
}
model {
  z ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format min-max-types.stan
parameters {
  matrix[max(1, 3), min(2, 5)] a;
}
transformed parameters {
  real z;
  z = max(9, 10);
  z = min(9, 10);
}
model {
  int b;
  
  // int
  b = max(9, 10);
  
  to_vector(a) ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format model2.stan
functions {
  real coupling(int t, int n, int N_node, matrix x1, matrix z, matrix K) {
    real s = 0.0;
    for (i in 1 : N_node) {
      s = s + K[n, i] * (x1[i, t] - x1[n, t]);
    }
    return s;
  }
}
data {
  int<lower=1> N_time;
  int<lower=1> N_node;
  matrix[N_node, N_time] x1_sim;
  matrix[N_node, N_node] K;
  real dt;
  real tau;
}
transformed data {
  real I1 = 3.1;
}
parameters {
  vector<lower=-3.5, upper=-1.5>[N_node] x0;
  vector[N_node] x1_init;
  vector[N_node] z_init;
}
model {
  matrix[N_node, N_time] x1;
  matrix[N_node, N_time] z;
  x1[ : , 1] = x1_init;
  z[ : , 1] = z_init;
  for (t in 1 : (N_time - 1)) {
    for (n in 1 : N_node) {
      x1[n, t + 1] = x1[n, t]
                     + dt
                       * (-(x1[n, t] ^ 3) - 2 * (x1[n, t] ^ 2) + 1 - z[n, t]
                          + I1);
      z[n, t + 1] = z[n, t]
                    + dt * tau
                      * (4 * (x1[n, t] - x0[n]) - z[n, t]
                         - coupling(t, n, N_node, x1, z, K));
    }
  }
  x1_init ~ normal(-2.0, 0.1);
  z_init ~ normal(4.0, 0.1);
  for (n in 1 : N_node) {
    x0[n] ~ cauchy(-1.3, 1.0);
  }
  for (i in 1 : N_time) {
    for (n in 1 : N_node) {
      x1_sim[n, i] ~ normal(x1[n, i], 1.0);
    }
  }
}

  $ ../../../../install/default/bin/stanc --auto-format model_block_empty.stan
functions {
  real foo(real x) {
    return x;
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format multiple_funs.stan
functions {
  int foo(int a) {
    return a;
  }
  int bar(int a) {
    return a;
  }
}
parameters {
  real theta;
}
model {
  theta ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format neg_binomial_2_log_glm_old_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  real<lower=0> sigma = 0.5;
  array[N] int<lower=0> y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j * 1.0 / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = neg_binomial_2_log_rng((x * beta_true + alpha_true)[i], sigma);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  
  y ~ neg_binomial_2_log(x * beta_inferred + alpha_inferred, sigma);
}

  $ ../../../../install/default/bin/stanc --auto-format neg_binomial_2_log_glm_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  real<lower=0> sigma = 0.5;
  array[N] int<lower=0> y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j * 1.0 / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = neg_binomial_2_log_rng((x * beta_true + alpha_true)[i], sigma);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  
  y ~ neg_binomial_2_log_glm(x, alpha_inferred, beta_inferred, sigma);
}

  $ ../../../../install/default/bin/stanc --auto-format new-prob-fun-suffixes.stan
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
  target += normal_lpdf(1 | -1.5, 2.9);
  target += poisson_lpmf(2 | 3);
  target += normal_lcdf(1 | 2, 3);
  target += normal_lccdf(1 | 2, 3);
  target += poisson_lcdf(1 | 2);
  target += poisson_lccdf(1 | 2);
}

  $ ../../../../install/default/bin/stanc --auto-format normal_id_glm_old_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  real<lower=0> sigma = 0.5;
  vector[N] y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j * 1.0 / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = normal_rng((x * beta_true + alpha_true)[i], sigma);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  
  y ~ normal(x * beta_inferred + alpha_inferred, sigma);
}

  $ ../../../../install/default/bin/stanc --auto-format normal_id_glm_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  real<lower=0> sigma = 0.5;
  vector[N] y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j * 1.0 / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = normal_rng((x * beta_true + alpha_true)[i], sigma);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  
  y ~ normal_id_glm(x, alpha_inferred, beta_inferred, sigma);
}

  $ ../../../../install/default/bin/stanc --auto-format numeric-literal.stan
transformed data {
  int a = 0;
  int b = 10_000;
  real c = .12;
  real d = 1.;
  real e = 1.002_345;
  real f = .99_99_99e+1_25;
  real g = 1_100_100.0_345;
}

  $ ../../../../install/default/bin/stanc --auto-format ode-int-segments.stan
functions {
  array[] real ode(real t, array[] real y, array[] real theta,
                   array[] real x, array[] int x_int) {
    array[0] real dydt;
    return dydt;
  }
}
data {
  int<lower=1> T;
  real t0;
  array[0] real y0;
  array[T] real ts;
  array[T, 2] real y;
}
transformed data {
  array[0] real x;
  array[0] int x_int;
}
parameters {
  array[0] real theta;
}
transformed parameters {
  array[T, 2] real y_hat;
  {
    int N = 0;
    y_hat = integrate_ode(ode, y0, t0, segment(ts, 0, N), theta, x, x_int);
  }
}
model {
  
}

Warning in 'ode-int-segments.stan', line 26, column 12: integrate_ode is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../install/default/bin/stanc --auto-format ode-nested-quotes.stan
/**
 * Minimal example derived from jimsinmss example brought
 * up on stan-users mailing list, Feb 2015.
 */
functions {
  array[] real foo(real t, array[] real y, array[] real theta,
                   array[] real x_r, array[] int x_i) {
    return rep_array(1.0, 1);
  }
}
transformed data {
  real y;
  array[2, 2] real t;
  y = integrate_ode(foo, rep_array(1.0, 1), 1.0, t[1], rep_array(1.0, 1),
                    rep_array(1.0, 1), rep_array(1, 1))[1, 1];
}
model {
  
}

Warning in 'ode-nested-quotes.stan', line 14, column 6: integrate_ode is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../install/default/bin/stanc --auto-format ode_good.stan
functions {
  array[] real harm_osc_ode(real t, array[] real y,
                            // state
                            array[] real theta, // parameters
                            array[] real x, // data
                            array[] int x_int) {
    // integer data
    array[2] real dydt;
    dydt[1] = x[1] * y[2];
    dydt[2] = -y[1] - theta[1] * y[2];
    return dydt;
  }
}
data {
  array[2] real y0;
  real t0;
  array[10] real ts;
  array[1] real x;
  array[0] int x_int;
  array[10, 2] real y;
}
parameters {
  array[1] real theta;
  real<lower=0> sigma;
}
transformed parameters {
  array[10, 2] real y_hat;
  y_hat = integrate_ode(harm_osc_ode, // system
                        y0, // initial state
                        t0, // initial time
                        ts, // solution times
                        theta, // parameters
                        x, // data
                        x_int); // integer data
  y_hat = integrate_ode_rk45(harm_osc_ode, // system
                             y0, // initial state
                             t0, // initial time
                             ts, // solution times
                             theta, // parameters
                             x, // data
                             x_int); // integer data
  y_hat = integrate_ode_bdf(harm_osc_ode, // system
                            y0, // initial state
                            t0, // initial time
                            ts, // solution times
                            theta, // parameters
                            x, // data
                            x_int); // integer data
  y_hat = integrate_ode_adams(harm_osc_ode, // system
                              y0, // initial state
                              t0, // initial time
                              ts, // solution times
                              theta, // parameters
                              x, // data
                              x_int); // integer data
  y_hat = integrate_ode_rk45(harm_osc_ode, // system
                             y0, // initial state
                             t0, // initial time
                             ts, // solution times
                             theta, // parameters
                             x, // data
                             x_int, 0.01, 0.01, 10); // integer data
  y_hat = integrate_ode_bdf(harm_osc_ode, // system
                            y0, // initial state
                            t0, // initial time
                            ts, // solution times
                            theta, // parameters
                            x, // data
                            x_int, 0.01, 0.01, 10); // integer data
  y_hat = integrate_ode_adams(harm_osc_ode, // system
                              y0, // initial state
                              t0, // initial time
                              ts, // solution times
                              theta, // parameters
                              x, // data
                              x_int, 0.01, 0.01, 10); // integer data
}
model {
  for (t in 1 : 10) 
    y[t] ~ normal(y_hat[t], sigma); // independent normal noise
}

Warning in 'ode_good.stan', line 28, column 10: integrate_ode is deprecated
    and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'ode_good.stan', line 35, column 10: integrate_ode_rk45 is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'ode_good.stan', line 42, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'ode_good.stan', line 49, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'ode_good.stan', line 56, column 10: integrate_ode_rk45 is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'ode_good.stan', line 63, column 10: integrate_ode_bdf is
    deprecated and will be removed in Stan 3.0. Use ode_bdf instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
Warning in 'ode_good.stan', line 70, column 10: integrate_ode_adams is
    deprecated and will be removed in Stan 3.0. Use ode_adams instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../install/default/bin/stanc --auto-format poisson_log_glm_old_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  array[N] int<lower=0> y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j * 1.0 / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = poisson_log_rng((x * beta_true + alpha_true)[i]);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  
  y ~ poisson_log(x * beta_inferred + alpha_inferred);
}

  $ ../../../../install/default/bin/stanc --auto-format poisson_log_glm_performance.stan
transformed data {
  int<lower=0> N = 50;
  int<lower=0> M = 100;
  matrix[N, M] x;
  array[N] int<lower=0> y;
  vector[M] beta_true;
  real alpha_true = 1.5;
  for (j in 1 : M) {
    beta_true[j] = j * 1.0 / M;
  }
  for (i in 1 : N) {
    for (j in 1 : M) {
      x[i, j] = normal_rng(0, 1);
    }
    y[i] = poisson_log_rng((x * beta_true + alpha_true)[i]);
  }
}
parameters {
  real alpha_inferred;
  vector[M] beta_inferred;
}
model {
  beta_inferred ~ normal(0, 2);
  alpha_inferred ~ normal(0, 4);
  
  y ~ poisson_log_glm(x, alpha_inferred, beta_inferred);
}

  $ ../../../../install/default/bin/stanc --auto-format print_chars.stan
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
  print("a e z A R Z 0 4 9 / ~ ! @ # $ % ^ & * ( ) ` _ + - = { } | [ ] : ; ' < > ? , . / ");
}

  $ ../../../../install/default/bin/stanc --auto-format print_indexing.stan
data {
  array[2] int<lower=1> N;
  array[N[1]] int<lower=0> y_1;
  array[N[2]] int<lower=0> y_2;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format profiling.stan
data {
  int<lower=1> N;
  array[N] real x;
  vector[N] y;
}
transformed data {
  real sum_y;
  profile("sum") {
    sum_y = sum(y);
  }
}
parameters {
  real<lower=0> rho;
  real<lower=0> alpha;
  real<lower=0> sigma;
}
model {
  matrix[N, N] cov;
  matrix[N, N] L_cov;
  profile("cov_exp_quad") {
    cov = gp_exp_quad_cov(x, alpha, rho) + diag_matrix(rep_vector(sigma, N));
  }
  profile("cholesky_decompose") {
    L_cov = cholesky_decompose(cov);
  }
  profile("multi_normal_cholesky") {
    rho ~ gamma(25, 4);
    alpha ~ normal(0, 2);
    sigma ~ normal(0, 1);
    
    y ~ multi_normal_cholesky(rep_vector(0, N), L_cov);
  }
}

  $ ../../../../install/default/bin/stanc --auto-format propto-good.stan
model {
  target += normal_lupdf(1 | 0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format recursive-functions.stan
functions {
  // no forward declarations
  real foo(real baz) {
    return bar(baz);
  }
  real bar(real bar) {
    return foo(bar);
  }
  real baz(real foo) {
    return baz(foo);
  }
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format rng_loc.stan
functions {
  real foo_rng(real mu, real sigma) {
    return normal_rng(mu, sigma);
  }
}
transformed data {
  real y;
  y = normal_rng(0, 1);
}
parameters {
  
}
model {
  
}
generated quantities {
  real z;
  z = normal_rng(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format rng_transformed_data.stan
data {
  int<lower=0> N;
}
transformed data {
  vector[N] y;
  for (n in 1 : N) 
    y[n] = normal_rng(0, 1);
  print(y);
}
parameters {
  real mu;
  real<lower=0> sigma;
}
model {
  y ~ normal(mu, sigma);
}
generated quantities {
  real mean_y = mean(y);
  real sd_y = sd(y);
}

  $ ../../../../install/default/bin/stanc --auto-format single-arg-conddist.stan
functions {
  real foo_lpdf(real x) {
    return -square(x);
  }
  real goo_lpmf(int x) {
    return -square(x);
  }
}
data {
  int y;
}
parameters {
  real x;
}
model {
  target += std_normal_lpdf(x);
  target += std_normal_lpdf(x);
  target += std_normal_lupdf(x);
  target += std_normal_lupdf(x);
  target += foo_lpdf(x);
  target += foo_lpdf(x);
  target += goo_lpmf(y);
  target += goo_lpmf(y);
  target += goo_lupmf(y);
  target += goo_lupmf(y);
}

  $ ../../../../install/default/bin/stanc --auto-format solve_newton_good.stan
functions {
  real algebra_solverfake(real x) {
    return 2 * x;
  }
  vector algebra_system(vector x, vector y, array[] real dat,
                        array[] int dat_int) {
    vector[2] f_x;
    f_x[1] = x[1] - y[1];
    f_x[2] = x[2] - y[2];
    return f_x;
  }
}
data {
  
}
transformed data {
  vector[2] x;
  vector[2] y;
  array[0] real dat;
  array[0] int dat_int;
  vector[2] theta;
  real rel_tol;
  real fun_tol;
  int max_steps;
  
  theta = solve_newton(algebra_system, x, y, dat, dat_int);
  theta = solve_newton_tol(algebra_system, x, rel_tol, fun_tol, max_steps, y,
                           dat, dat_int);
}
parameters {
  vector[2] x_p;
  vector[2] y_p;
  real dummy_parameter;
}
transformed parameters {
  real abc_tp = algebra_solverfake(2.9);
  vector[2] theta_p;
  
  theta_p = solve_newton(algebra_system, x, y, dat, dat_int);
  theta_p = solve_newton_tol(algebra_system, x, rel_tol, fun_tol, max_steps,
                             y, dat, dat_int);
  
  theta_p = solve_newton(algebra_system, x, y_p, dat, dat_int);
  theta_p = solve_newton_tol(algebra_system, x, rel_tol, fun_tol, max_steps,
                             y, dat, dat_int);
  
  theta_p = solve_newton(algebra_system, x_p, y, dat, dat_int);
  theta_p = solve_newton_tol(algebra_system, x_p, rel_tol, fun_tol,
                             max_steps, y, dat, dat_int);
  
  theta_p = solve_newton(algebra_system, x_p, y_p, dat, dat_int);
  theta_p = solve_newton_tol(algebra_system, x_p, rel_tol, fun_tol,
                             max_steps, y_p, dat, dat_int);
}
model {
  dummy_parameter ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format solve_powell_good.stan
functions {
  real algebra_solverfake(real x) {
    return 2 * x;
  }
  vector algebra_system(vector x, vector y, array[] real dat,
                        array[] int dat_int) {
    vector[2] f_x;
    f_x[1] = x[1] - y[1];
    f_x[2] = x[2] - y[2];
    return f_x;
  }
}
data {
  
}
transformed data {
  vector[2] x;
  vector[2] y;
  array[0] real dat;
  array[0] int dat_int;
  vector[2] theta;
  real rel_tol;
  real fun_tol;
  int max_steps;
  
  theta = solve_powell(algebra_system, x, y, dat, dat_int);
  theta = solve_powell_tol(algebra_system, x, rel_tol, fun_tol, max_steps, y,
                           dat, dat_int);
}
parameters {
  vector[2] x_p;
  vector[2] y_p;
  real dummy_parameter;
}
transformed parameters {
  real abc_tp = algebra_solverfake(2.9);
  vector[2] theta_p;
  
  theta_p = solve_powell(algebra_system, x, y, dat, dat_int);
  theta_p = solve_powell_tol(algebra_system, x, rel_tol, fun_tol, max_steps,
                             y, dat, dat_int);
  
  theta_p = solve_powell(algebra_system, x, y_p, dat, dat_int);
  theta_p = solve_powell_tol(algebra_system, x, rel_tol, fun_tol, max_steps,
                             y, dat, dat_int);
  
  theta_p = solve_powell(algebra_system, x_p, y, dat, dat_int);
  theta_p = solve_powell_tol(algebra_system, x_p, rel_tol, fun_tol,
                             max_steps, y, dat, dat_int);
  
  theta_p = solve_powell(algebra_system, x_p, y_p, dat, dat_int);
  theta_p = solve_powell_tol(algebra_system, x_p, rel_tol, fun_tol,
                             max_steps, y_p, dat, dat_int);
}
model {
  dummy_parameter ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format stanc_helper.stan
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format target.stan
parameters {
  real<lower=0> y;
}
transformed parameters {
  print("target = ", target());
}
model {
  print("target = ", target());
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format target_good.stan
/**
 * get_lp() allowed in:
 *  - functions ending in _lp
 *  transformed parameter block
 *  model block
 */
functions {
  // allowed in functions ending in _lp
  real foo_lp(real x) {
    return x + target();
  }
}
parameters {
  real y;
}
transformed parameters {
  real z;
  z = target();
}
model {
  real w;
  w = target();
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format tern_op_contains_var.stan
data {
  int N;
  int y_max;
  array[N] int<lower=0> y;
  array[N] int<lower=0, upper=1> group;
}
parameters {
  vector<lower=0, upper=1>[2] param;
}
model {
  to_vector(param) ~ uniform(0, 1);
  for (i in 1 : N) {
    y[i] ~ binomial(y_max, group[i] == 0 ? param[1] : param[2]);
  }
}

  $ ../../../../install/default/bin/stanc --auto-format to_matrix_exp.stan
functions {
  matrix foo(matrix t) {
    return t;
  }
}
data {
  int N;
  row_vector[N] b;
}
transformed parameters {
  matrix[N, N] log_lik = foo(to_matrix(b));
}

  $ ../../../../install/default/bin/stanc --auto-format truncation-user-defined.stan
functions {
  real foo_lpdf(real y, real theta) {
    return 1;
  }
  real foo_lcdf(real y, real theta) {
    return 1;
  }
  real foo_lccdf(real y, real theta) {
    return 1;
  }
}
data {
  real y;
}
parameters {
  real theta;
  real L;
  real U;
}
model {
  y ~ foo(theta) T[L, ];
  y ~ foo(theta) T[ , U];
  y ~ foo(theta) T[L, U];
}

  $ ../../../../install/default/bin/stanc --auto-format truncation-wild.stan
model {
  array[1, 1] real T = {{42.0}};
  1 ~ normal(0, 1) T[1, T[1, 1]];
  print(T[1, 1]);
}

  $ ../../../../install/default/bin/stanc --auto-format unconstrained_params_var.stan
parameters {
  real mu;
  real<lower=0> sigma;
}
model {
  // TODO(carpenter): why can't we get this unconstrained var out?
  // params_r__ ~ normal(0, 1);
  1 ~ normal(mu, sigma);
  2 ~ normal(mu, sigma);
  3 ~ normal(mu, sigma);
}

  $ ../../../../install/default/bin/stanc --auto-format unnormalized_math_fun_lpdf.stan
functions {
  real foo_lpdf(real y1, real y2, vector vy1, vector vy2, matrix my1,
                matrix my2, array[] real ay1) {
    real r;
    r += beta_lupdf(y1 | y2, y2);
    r += beta_proportion_lupdf(y1 | y2, y2);
    r += cauchy_lupdf(y1 | y2, y2);
    r += chi_square_lupdf(y1 | y2);
    r += dirichlet_lupdf(vy1 | vy2);
    r += double_exponential_lupdf(y1 | y2, y2);
    r += exp_mod_normal_lupdf(y1 | y2, y2, y2);
    r += exponential_lupdf(y1 | y2);
    r += frechet_lupdf(y1 | y2, y2);
    r += gamma_lupdf(y1 | y2, y2);
    r += gaussian_dlm_obs_lupdf(my1 | my2, my2, vy2, my2, vy2, my2);
    r += gumbel_lupdf(y1 | y2, y2);
    r += inv_chi_square_lupdf(y1 | y2);
    r += inv_gamma_lupdf(y1 | y2, y2);
    r += inv_wishart_lupdf(my1 | y2, my2);
    r += lkj_corr_cholesky_lupdf(my1 | y2);
    r += lkj_corr_lupdf(my1 | y2);
    r += logistic_lupdf(y1 | y2, y2);
    r += lognormal_lupdf(y1 | y2, y2);
    r += multi_gp_cholesky_lupdf(my1 | my2, vy2);
    r += multi_gp_lupdf(my1 | my2, vy2);
    r += multi_normal_cholesky_lupdf(vy1 | vy2, my2);
    r += multi_normal_lupdf(vy1 | vy2, my2);
    r += multi_normal_prec_lupdf(vy1 | vy2, my2);
    r += multi_student_t_lupdf(vy1 | y2, vy2, my2);
    r += normal_id_glm_lupdf(y1 | my2, y2, vy2, vy2);
    r += normal_lupdf(y1 | y2, y2);
    r += normal_lupdf(ay1 | y2, y2);
    r += pareto_lupdf(y1 | y2, y2);
    r += pareto_type_2_lupdf(y1 | y2, y2, y2);
    r += rayleigh_lupdf(y1 | y2);
    r += scaled_inv_chi_square_lupdf(y1 | y2, y2);
    r += skew_normal_lupdf(y1 | y2, y2, y2);
    r += std_normal_lupdf(y1);
    r += student_t_lupdf(y1 | y2, y2, y2);
    r += uniform_lupdf(y1 | y2, y2);
    r += von_mises_lupdf(y1 | y2, y2);
    r += weibull_lupdf(y1 | y2, y2);
    r += wiener_lupdf(y1 | y2, y2, y2, y2);
    r += wishart_lupdf(my1 | y2, my2);
    return r;
  }
}
parameters {
  real y1;
  real y2;
  array[5] real ay1;
  vector[5] vy1;
  vector[5] vy2;
  matrix[5, 5] my1;
  matrix[5, 5] my2;
}
model {
  real r;
  r += beta_lupdf(y1 | y2, y2);
  r += beta_proportion_lupdf(y1 | y2, y2);
  r += cauchy_lupdf(y1 | y2, y2);
  r += chi_square_lupdf(y1 | y2);
  r += dirichlet_lupdf(vy1 | vy2);
  r += double_exponential_lupdf(y1 | y2, y2);
  r += exp_mod_normal_lupdf(y1 | y2, y2, y2);
  r += exponential_lupdf(y1 | y2);
  r += frechet_lupdf(y1 | y2, y2);
  r += gamma_lupdf(y1 | y2, y2);
  r += gaussian_dlm_obs_lupdf(my1 | my2, my2, vy2, my2, vy2, my2);
  r += gumbel_lupdf(y1 | y2, y2);
  r += inv_chi_square_lupdf(y1 | y2);
  r += inv_gamma_lupdf(y1 | y2, y2);
  r += inv_wishart_lupdf(my1 | y2, my2);
  r += lkj_corr_cholesky_lupdf(my1 | y2);
  r += lkj_corr_lupdf(my1 | y2);
  r += logistic_lupdf(y1 | y2, y2);
  r += lognormal_lupdf(y1 | y2, y2);
  r += multi_gp_cholesky_lupdf(my1 | my2, vy2);
  r += multi_gp_lupdf(my1 | my2, vy2);
  r += multi_normal_cholesky_lupdf(vy1 | vy2, my2);
  r += multi_normal_lupdf(vy1 | vy2, my2);
  r += multi_normal_prec_lupdf(vy1 | vy2, my2);
  r += multi_student_t_lupdf(vy1 | y2, vy2, my2);
  r += normal_id_glm_lupdf(y1 | my2, y2, vy2, vy2);
  r += normal_lupdf(y1 | y2, y2);
  r += normal_lupdf(ay1 | y2, y2);
  r += pareto_lupdf(y1 | y2, y2);
  r += pareto_type_2_lupdf(y1 | y2, y2, y2);
  r += rayleigh_lupdf(y1 | y2);
  r += scaled_inv_chi_square_lupdf(y1 | y2, y2);
  r += skew_normal_lupdf(y1 | y2, y2, y2);
  r += std_normal_lupdf(y1);
  r += student_t_lupdf(y1 | y2, y2, y2);
  r += uniform_lupdf(y1 | y2, y2);
  r += von_mises_lupdf(y1 | y2, y2);
  r += weibull_lupdf(y1 | y2, y2);
  r += wiener_lupdf(y1 | y2, y2, y2, y2);
  r += wishart_lupdf(my1 | y2, my2);
  r += foo_lupdf(y1 | y2, vy1, vy2, my1, my2, ay1);
}

  $ ../../../../install/default/bin/stanc --auto-format unnormalized_math_fun_lpmf.stan
functions {
  real foo_lpmf(int i1, real r1, matrix m1, vector v1, array[] int ai1,
                row_vector rv1) {
    real r;
    r += bernoulli_logit_glm_lupmf(i1 | m1, r1, v1);
    r += bernoulli_logit_lupmf(i1 | r1);
    r += bernoulli_lupmf(i1 | r1);
    r += beta_binomial_lupmf(i1 | i1, r1, r1);
    r += binomial_logit_lupmf(i1 | i1, r1);
    r += binomial_lupmf(i1 | i1, r1);
    r += categorical_logit_glm_lupmf(i1 | rv1, v1, m1);
    r += categorical_logit_lupmf(i1 | v1);
    r += categorical_lupmf(i1 | v1);
    r += hypergeometric_lupmf(i1 | i1, i1, i1);
    r += multinomial_lupmf(ai1 | v1);
    r += neg_binomial_2_log_glm_lupmf(i1 | m1, r1, v1, r1);
    r += neg_binomial_2_log_lupmf(i1 | r1, r1);
    r += neg_binomial_2_lupmf(i1 | r1, r1);
    r += neg_binomial_lupmf(i1 | r1, r1);
    r += ordered_logistic_glm_lupmf(i1 | rv1, v1, v1);
    r += ordered_logistic_lupmf(i1 | r1, v1);
    r += ordered_probit_lupmf(i1 | r1, v1);
    r += poisson_log_glm_lupmf(i1 | m1, r1, v1);
    r += poisson_log_lupmf(i1 | r1);
    r += poisson_lupmf(i1 | r1);
    return r;
  }
}
data {
  int i1;
  array[5] int ai1;
}
parameters {
  real r1;
  vector[5] v1;
  row_vector[5] rv1;
  matrix[5, 5] m1;
}
model {
  real r;
  r += bernoulli_logit_glm_lupmf(i1 | m1, r1, v1);
  r += bernoulli_logit_lupmf(i1 | r1);
  r += bernoulli_lupmf(i1 | r1);
  r += beta_binomial_lupmf(i1 | i1, r1, r1);
  r += binomial_logit_lupmf(i1 | i1, r1);
  r += binomial_lupmf(i1 | i1, r1);
  r += categorical_logit_glm_lupmf(i1 | rv1, v1, m1);
  r += categorical_logit_lupmf(i1 | v1);
  r += categorical_lupmf(i1 | v1);
  r += hypergeometric_lupmf(i1 | i1, i1, i1);
  r += multinomial_lupmf(ai1 | v1);
  r += neg_binomial_2_log_glm_lupmf(i1 | m1, r1, v1, r1);
  r += neg_binomial_2_log_lupmf(i1 | r1, r1);
  r += neg_binomial_2_lupmf(i1 | r1, r1);
  r += neg_binomial_lupmf(i1 | r1, r1);
  r += ordered_logistic_glm_lupmf(i1 | rv1, v1, v1);
  r += ordered_logistic_lupmf(i1 | r1, v1);
  r += ordered_probit_lupmf(i1 | r1, v1);
  r += poisson_log_glm_lupmf(i1 | m1, r1, v1);
  r += poisson_log_lupmf(i1 | r1);
  r += poisson_lupmf(i1 | r1);
  r += foo_lupmf(i1 | r1, m1, v1, ai1, rv1);
}

  $ ../../../../install/default/bin/stanc --auto-format user-defined-lpdf-fun.stan
functions {
  real bar_lpmf(int y, real z) {
    return 1.0;
  }
  real bar_lcdf(int y, real z) {
    return 1.0;
  }
  real bar_lccdf(int y, real z) {
    return 1.0;
  }
  
  real foo_lpdf(real y, real sigma) {
    return 1.0;
  }
  real foo_lcdf(real y, real sigma) {
    return 1.0;
  }
  real foo_lccdf(real y, real sigma) {
    return 1.0;
  }
}
parameters {
  real y;
}
model {
  target += foo_lpdf(y | 7.0);
  target += foo_lcdf(y | 7.0);
  target += foo_lccdf(y | 7.0);
  
  target += normal_lpdf(y | 7.0, 1.0);
  target += normal_lcdf(y | 7.0, 1.0);
  target += normal_lccdf(y | 7.0, 1.0);
  
  target += bar_lpmf(2 | 7.0);
  target += bar_lcdf(2 | 7.0);
  target += bar_lccdf(2 | 7.0);
  
  target += poisson_lpmf(2 | 7.0);
  target += poisson_lcdf(2 | 7.0);
  target += poisson_lccdf(2 | 7.0);
}

  $ ../../../../install/default/bin/stanc --auto-format user-distro-truncate.stan
functions {
  real foo_lpdf(real y, real mu) {
    return -(y - mu) ^ 2;
  }
  
  real foo_lcdf(real y, real mu) {
    return -1.7;
  }
  
  real foo_lccdf(real y, real mu) {
    return -0.02;
  }
}
parameters {
  real<lower=1, upper=5> y;
  real mu;
}
model {
  y ~ foo(mu);
  y ~ foo(mu) T[1, ];
  y ~ foo(mu) T[ , 5];
  y ~ foo(mu) T[1, 5];
}

  $ ../../../../install/default/bin/stanc --auto-format validate_add_expression_dimss_good.stan
transformed data {
  real x;
  vector[3] v;
  x = v[1];
}
parameters {
  real y;
}
transformed parameters {
  real xt;
  vector[3] vt;
  xt = vt[1];
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_add_var_good.stan
data {
  int n;
  real x;
  array[3, 2] int nn;
  array[5, 2] real y;
  vector[3] v;
  row_vector[3] rv;
  simplex[5] sv;
  unit_vector[7] uv;
  ordered[3] ov;
  matrix[4, 5] m;
  cov_matrix[3] covm;
  corr_matrix[3] corrm;
}
transformed data {
  int n_td;
  real x_td;
  array[3, 2] int nn_td;
  array[5, 2] real y_td;
  vector[3] v_td;
  row_vector[3] rv_td;
  simplex[5] sv_td;
  unit_vector[7] uv_td;
  ordered[3] ov_td;
  matrix[4, 5] m_td;
  cov_matrix[3] covm_td;
  corr_matrix[3] corrm_td;
}
parameters {
  real x_p;
  array[5, 2] real y_p;
  vector[3] v_p;
  row_vector[3] rv_p;
  simplex[5] sv_p;
  unit_vector[7] uv_p;
  ordered[3] ov_p;
  matrix[4, 5] m_p;
  cov_matrix[3] covm_p;
  corr_matrix[3] corrm_p;
}
transformed parameters {
  real x_tp;
  array[5, 2] real y_tp;
  vector[3] v_tp;
  row_vector[3] rv_tp;
  simplex[5] sv_tp;
  unit_vector[7] uv_tp;
  ordered[3] ov_tp;
  matrix[4, 5] m_tp;
  cov_matrix[3] covm_tp;
  corr_matrix[3] corrm_tp;
}
model {
  int n_l;
  real x_l;
  array[3, 2] int nn_l;
  array[5, 2] real y_l;
  vector[3] v_l;
  row_vector[3] rv_l;
  matrix[4, 5] m_l;
  
  x_p ~ normal(0, 1);
}
generated quantities {
  int n_gq;
  real x_gq;
  array[3, 2] int nn_gq;
  array[5, 2] real y_gq;
  vector[3] v_gq;
  row_vector[3] rv_gq;
  simplex[5] sv_gq;
  unit_vector[7] uv_gq;
  ordered[3] ov_gq;
  matrix[4, 5] m_gq;
  cov_matrix[3] covm_gq;
  corr_matrix[3] corrm_gq;
}

  $ ../../../../install/default/bin/stanc --auto-format validate_bounds_comparison.stan
data {
  real<lower=((1 < 2) ? -1 : -2)> a;
  real<upper=((1 < 2) ? -1 : -2)> b;
  real<lower=(1 && 3), upper=((1 < 2) ? -1 : -2)> c;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_conditional_op_good.stan
functions {
  real foo(real fa_x, int fa_y) {
    real fl_x;
    int fl_y;
    fl_x = 1 ? fl_x : fl_y;
    fl_y = 1 ? fl_y : 0;
    
    fl_x = 1 ? fa_x : fl_x;
    fl_y = 1 ? fa_y : fl_y;
    
    return 2.0;
  }
}
data {
  int x;
  real y;
  array[2] real ya1;
  array[2, 2] real ya2;
  vector[5] z;
  array[2] vector[5] za1;
  array[2, 2] vector[5] za2;
  row_vector[6] w;
  array[2] row_vector[6] wa1;
  array[2, 2] row_vector[6] wa2;
  matrix[5, 6] m;
  array[2] matrix[5, 6] ma1;
  array[2, 2] matrix[5, 6] ma2;
}
transformed data {
  int tx;
  real ty;
  vector[5] tza;
  vector[5] tzb;
  vector[5] tzc;
  row_vector[6] twa;
  row_vector[6] twb;
  row_vector[6] twc;
  matrix[5, 6] tma;
  matrix[5, 6] tmb;
  matrix[5, 6] tmc;
  
  array[2] int tx1;
  array[2] real tya1;
  array[2] real tyb1;
  array[2] real tyc1;
  array[2] vector[5] tza1;
  array[2] vector[5] tzb1;
  array[2] row_vector[6] twa1;
  array[2] row_vector[6] twb1;
  array[2] row_vector[6] twc1;
  array[2] matrix[5, 6] tm1;
  
  array[2, 3] int txa2;
  array[2, 3] int txb2;
  array[2, 3] int txc2;
  array[2, 2] real tya2;
  array[2, 2] real tyb2;
  array[2, 2] vector[5] tza2;
  array[2, 2] vector[5] tzb2;
  array[2, 2] vector[5] tzc2;
  array[2, 2] row_vector[6] twa2;
  array[2, 2] row_vector[6] twb2;
  array[2, 2] matrix[5, 6] tma2;
  array[2, 2] matrix[5, 6] tmb2;
  array[2, 2] matrix[5, 6] tmc2;
  
  tx = 1 ? 2 : 3;
  ty = 1 ? 2.0 : 3.0;
  
  tx = x < 100 ? x : 100; // t,f : int,int
  ty = y > 100 ? 100 : y; // t,f : int,real
  ty = y < 100 ? y : 100; // t,f : real,int
  ty = y < 100 ? y : ty; // t,f : real,real
  
  tzc = x < 100 ? tza : tzb; // tf vector, vector
  twc = x < 100 ? twa : twb; // tf row_vector, row_vector
  tmc = x < 100 ? tma : tmb; // tf matrix, matrix
  
  tx1 = x < 100 ? txa2[1] : txb2[2]; // t,f : int[2],int[2]
  txc2 = x < 100 ? txa2 : txb2; // t,f : int[2,2],int[2,2]
  tyc1 = x < 100 ? tya1 : tyb1; // t,f : real[2],real[2]
  tya2 = x < 100 ? tya2 : tyb2; // t,f : real[2,2],real[2,2]
  twc1 = x < 100 ? twa1 : twb1; // tf row_vector, row_vector
  twa2 = x < 100 ? twa2 : twb2; // tf row_vector[,], row_vector[,]
  tm1 = x < 100 ? tma2[1] : tmb2[1]; // tf matrix[], matrix[]
  tma2 = x < 100 ? tma2 : tmb2; // tf matrix[,], matrix[,]
  
  {
    real abcd;
    abcd = 1 ? abcd : 2.0;
  }
}
parameters {
  real py;
  vector[5] pz;
  row_vector[6] pw;
  matrix[5, 6] pm;
  
  array[2] real pya1;
  array[2, 2] real pya2;
  array[2] vector[5] pza1;
  array[2, 2] vector[5] pza2;
  array[2] matrix[5, 6] pma1;
  array[2, 2] matrix[5, 6] pma2;
}
transformed parameters {
  real tpy;
  vector[5] tpza;
  vector[5] tpzb;
  vector[5] tpzc;
  row_vector[6] tpwa;
  row_vector[6] tpwb;
  row_vector[6] tpwc;
  matrix[5, 6] tpma;
  matrix[5, 6] tpmb;
  matrix[5, 6] tpmc;
  
  array[2] real tpya1;
  array[2] real tpyb1;
  array[2] real tpyc1;
  array[2] vector[5] tpza1;
  array[2] vector[5] tpzb1;
  array[2] row_vector[6] tpwa1;
  array[2] row_vector[6] tpwb1;
  array[2] row_vector[6] tpwc1;
  array[2] matrix[5, 6] tpm1;
  
  array[2, 2] real tpya2;
  array[2, 2] real tpyb2;
  array[2, 2] vector[5] tpza2;
  array[2, 2] vector[5] tpzb2;
  array[2, 2] vector[5] tpzc2;
  array[2, 2] row_vector[6] tpwa2;
  array[2, 2] row_vector[6] tpwb2;
  array[2, 2] matrix[5, 6] tpma2;
  array[2, 2] matrix[5, 6] tpmb2;
  array[2, 2] matrix[5, 6] tpmc2;
  
  tpy = y < 100 ? x : y; // t,f : int,real
  tpy = y < 100 ? y : x; // t,f : real,int
  tpy = y < 100 ? y : py; // t,f : real,var
  tpy = y < 100 ? x : py; // t,f : int,var
  
  tpzc = x < 100 ? tpza : tpzb; // tf var vector
  tpwc = x < 100 ? tpwa : tpwb; // tf var row_vector
  tpmc = x < 100 ? tpma : tpmb; // tf var matrix
  
  tpzc = x < 100 ? z : pz; // tf real/var vector
  tpzc = x < 100 ? pz : z;
  tpwc = x < 100 ? w : pw; // tf real/var row_vector
  tpwc = x < 100 ? pw : w;
  tpmc = x < 100 ? m : pm; // tf real/var var matrix
  tpmc = x < 100 ? pm : m;
  
  tpyc1 = ya1;
  
  tpyc1 = x < 100 ? tpya1 : tpyb1; // t,f : var[2],var[2]
  
  tpyc1 = x < 100 ? ya1 : pya1; // t,f : real[2],var[2]
  tpyc1 = x < 100 ? pya1 : ya1;
  
  tpya2 = x < 100 ? tpya2 : tpyb2; // t,f : var[2,2],var[2,2]
  
  tpya2 = x < 100 ? ya2 : tpyb2; // t,f : real[2,2],var[2,2]
  tpya2 = x < 100 ? tpya2 : ya2;
  
  tpwc1 = x < 100 ? tpwa1 : tpwb1; // tf var row_vector
  
  tpwc1 = x < 100 ? wa1 : tpwb1; // tf real/var row_vector
  tpwc1 = x < 100 ? tpwb1 : wa1;
  
  tpwa2 = x < 100 ? tpwa2 : tpwb2; // tf var row_vector[,]
  
  tpwa2 = x < 100 ? wa2 : tpwb2; // tf real/var row_vector[,]
  tpwa2 = x < 100 ? tpwb2 : wa2;
  
  tpm1 = x < 100 ? tpma2[1] : tpmb2[1]; // tf var matrix[]
  
  tpm1 = x < 100 ? ma2[1] : tpmb2[1]; // tf real/var matrix[]
  tpm1 = x < 100 ? tpmb2[1] : ma2[1];
  
  tpma2 = x < 100 ? tpma2 : tpmb2; // tf var matrix[,]
  
  tpma2 = x < 100 ? ma2 : pma2; // tf real/var matrix[,]
  tpma2 = x < 100 ? pma2 : ma2; // tf real/var matrix[,]
  
  {
    real abcde;
    abcde = 1 ? abcde : 2.0;
  }
}
model {
  py ~ normal(0, 1);
  
  {
    real abcdefg;
    abcdefg = 1 ? abcdefg : 2.0;
  }
}
generated quantities {
  int gqx;
  real gqy;
  vector[5] gqza;
  vector[5] gqzb;
  vector[5] gqzc;
  
  gqy = y < 100 ? x : y; // t,f : int,real
  gqy = y < 100 ? y : x; // t,f : real,int
  
  gqzc = x < 100 ? gqza : gqzb; // tf var vector
  
  {
    real abcdef;
    abcdef = 1 ? abcdef : 2.0;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format validate_division_good.stan
transformed data {
  real u;
  matrix[3, 3] m;
  row_vector[3] v;
  u = 2.1 / 3;
  u = 2 / 3.1;
  u = 2.1 / 3.1;
  m = m / m;
  v = v / m;
}
parameters {
  real y;
}
transformed parameters {
  real xt;
  real ut;
  matrix[3, 3] mt;
  row_vector[3] vt;
  xt = 2 %/% 3;
  ut = 2.1 / 3;
  ut = 2 / 3.1;
  ut = 2.1 / 3.1;
  mt = mt / mt;
  vt = vt / mt;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_elt_division_good.stan
transformed data {
  matrix[3, 3] m;
  vector[3] v;
  row_vector[3] rv;
  real c;
  m = m ./ m;
  m = m ./ c;
  m = c ./ m;
  v = v ./ v;
  v = c ./ v;
  v = v ./ c;
  rv = rv ./ rv;
  rv = c ./ rv;
  rv = rv ./ c;
}
parameters {
  real y;
}
transformed parameters {
  matrix[3, 3] mt;
  vector[3] vt;
  row_vector[3] rvt;
  real ct;
  mt = mt ./ mt;
  mt = mt ./ ct;
  mt = ct ./ mt;
  vt = vt ./ vt;
  vt = ct ./ vt;
  vt = vt ./ ct;
  rvt = rvt ./ rvt;
  rvt = ct ./ rvt;
  rvt = rvt ./ ct;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_elt_multiplication_good.stan
transformed data {
  matrix[3, 3] m;
  vector[3] v;
  row_vector[3] rv;
  m = m .* m;
  v = v .* v;
  rv = rv .* rv;
}
parameters {
  real y;
}
transformed parameters {
  matrix[3, 3] mt;
  vector[3] vt;
  row_vector[3] rvt;
  mt = mt .* mt;
  vt = vt .* vt;
  rvt = rvt .* rvt;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_exponentiation_good.stan
data {
  int i;
  int j;
  real x;
  real y;
}
transformed data {
  real z;
  z = x ^ y; // double, double
  z = x ^ j; // double, int
  z = j ^ x; // int, double
  z = i ^ j; // int, int
}
parameters {
  real a;
  real b;
}
transformed parameters {
  real z2;
  z2 = a * b;
  z2 = x ^ y; // double, double
  z2 = x ^ j; // double, int
  z2 = x ^ a; // double, var
  z2 = i ^ x; // int, double
  z2 = i ^ j; // int, int
  z2 = i ^ b; // int, var
  z2 = a ^ x; // var, double
  z2 = a ^ j; // var, int
  z2 = a ^ b; // var, var
}
model {
  a ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_exponentiation_precedence.stan
data {
  
}
transformed data {
  vector[3] a;
  vector[3] b;
  real c;
  int i;
  real x;
  a[1] = 2.1;
  a[2] = 2.2;
  a[3] = 2.3;
  b[1] = 2;
  b[2] = 3;
  b[3] = 4;
  i = 5;
  x = 6.66;
  c = a[1] ^ b[1];
  c = a[1] ^ x;
  c = a[1] ^ i;
  c = i ^ a[1];
  c = x ^ a[1];
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_functions.stan
functions {
  real my_fun(real x) {
    return 2 * x;
  }
  real my_fun2(real x, real y) {
    return 2 * x;
  }
  real my_fun3(data real x) {
    return 2 * x;
  }
}
transformed data {
  real td_d1 = 1;
  real td_d2 = my_fun(td_d1);
  real td_d3 = my_fun2(td_d1, td_d2);
  td_d3 = my_fun3(my_fun2(td_d1, td_d2));
}
parameters {
  real p_d1;
}
transformed parameters {
  real tp_d1 = my_fun(p_d1);
  real tp_d2 = my_fun2(p_d1, tp_d1);
}
generated quantities {
  real gq_d1 = my_fun(p_d1);
  real gq_d2 = my_fun(gq_d1);
  gq_d2 = my_fun3(gq_d1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_int_divide_good.stan
data {
  int i;
  int j;
}
transformed data {
  int k;
  k = i %/% j; // int, int
}
parameters {
  real y;
}
model {
  int i2;
  int j2;
  int k2;
  k2 = i2 %/% j2;
  y ~ normal(0, 1);
}
generated quantities {
  int i3;
  int j3;
  int k3;
  k3 = i3 %/% j3;
}

  $ ../../../../install/default/bin/stanc --auto-format validate_int_expr2_good.stan
parameters {
  vector[10] y;
}
model {
  for (n in 1 : 10) 
    y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_jacobian_warning_good.stan
data {
  int N;
  real x;
}
parameters {
  vector[3] v;
  array[4, 5] real a;
  matrix[6, 6] m;
  real y;
  real z;
}
model {
  // int_literal
  1 ~ normal(y, 1);
  
  // double_literal
  2.7 ~ normal(z, 1);
  
  // variable
  y ~ normal(0, 1);
  
  // fun
  m ~ lkj_corr(2.0);
  (m + m) ~ lkj_corr(2.0);
  (m - m) ~ lkj_corr(2.0);
  (v + v) ~ multi_normal(v, m);
  (v - v) ~ multi_normal(v, m);
  block(m, 1, 1, 1, 1) ~ lkj_corr(2.0);
  col(m, 1) ~ normal(0, 1);
  cols(m) ~ normal(0, 1);
  row(m, 1) ~ normal(0, 1);
  rows(m) ~ normal(0, 1);
  diagonal(m) ~ multi_normal(v, m);
  head(v, 2) ~ multi_normal(v, m);
  negative_infinity() ~ normal(0, 1);
  not_a_number() ~ normal(0, 1);
  rep_matrix(1, 3, 3) ~ lkj_corr(2.0);
  (v')' ~ multi_normal(v, m);
  positive_infinity() ~ normal(0, 1);
  segment(v, 2, 4) ~ normal(0, 1);
  sum(v) ~ normal(0, 1);
  tail(v, 3) ~ normal(0, 1);
  to_vector(m) ~ normal(0, 1);
  
  // index_op
  v[1] ~ normal(0, 1);
  m[1] ~ normal(0, 1);
  m[1, 2] ~ normal(0, 1);
  a[1, 2] ~ normal(0, 1);
  a[1][2] ~ normal(0, 1);
  
  // binary_op
  y + z ~ normal(0, 1);
  y - z ~ normal(0, 1);
  1 * z ~ normal(0, 1);
  z * 1 ~ normal(0, 1);
  1 / (1 / z) ~ normal(0, 1);
  y + ((z / 2) * 3) ~ normal(0, 1);
  2.0 * 3 ~ normal(y, 1);
  
  // unary_op
  (-y) ~ normal(0, 1);
  // -(-y) ~ normal(0,1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_left_division_good.stan
transformed data {
  matrix[3, 3] m;
  vector[3] v;
  m = m \ m;
  v = m \ v;
}
parameters {
  real y;
}
transformed parameters {
  matrix[3, 3] mt;
  vector[3] vt;
  mt = mt \ mt;
  vt = mt \ vt;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_logical_negate_expr_good.stan
transformed data {
  int n;
  n = !n;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_modulus_good.stan
data {
  int i;
  int j;
}
transformed data {
  int k;
  k = i % j; // int, int
}
parameters {
  real y;
}
model {
  int i2;
  int j2;
  int k2;
  k2 = i2 % j2;
  y ~ normal(0, 1);
}
generated quantities {
  int i3;
  int j3;
  int k3;
  k3 = i3 % j3;
}

  $ ../../../../install/default/bin/stanc --auto-format validate_multiplication.stan
transformed data {
  real x;
  x = 1.3;
  x = x * 2.7;
  x = x * x * x;
}
parameters {
  real y;
}
model {
  y ~ normal(x * 3, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_negate_expr_good.stan
transformed data {
  int n;
  real x;
  matrix[3, 3] m;
  vector[3] v;
  row_vector[3] rv;
  n = -n;
  x = -x;
  m = -m;
  v = -v;
  rv = -rv;
}
parameters {
  real y;
}
transformed parameters {
  real xt;
  matrix[3, 3] mt;
  vector[3] vt;
  row_vector[3] rvt;
  xt = -xt;
  mt = -mt;
  vt = -vt;
  rvt = -rvt;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_set_double_offset_multiplier_good.stan
transformed data {
  real<offset=2> a = 3;
}
parameters {
  array[2] matrix<offset=-412, multiplier=3>[3, 1] theta_;
  array[2] matrix<offset=-412, multiplier=3>[3, 1] theta;
  real<offset=1, multiplier=5> x;
  real<offset=42> w;
  vector<multiplier=242>[3] ww;
  row_vector<multiplier=242>[3] www;
}
transformed parameters {
  real<offset=23> y = x ^ 2;
}
model {
  y ~ normal(0, 1);
}
generated quantities {
  real<offset=1> z;
  z = 3;
}

  $ ../../../../install/default/bin/stanc --auto-format validate_set_double_range_lower_good.stan
data {
  real<lower=1.2> a;
  real<lower=1> b;
  real<lower=1.2, upper=2> c;
  real<lower=1, upper=1.2> d;
  real<lower=1.1, upper=1.2> e;
  real<lower=1, upper=2> f;
  real<lower=1, upper=2> g;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_set_double_range_upper_good.stan
data {
  real<upper=1.2> a;
  real<upper=1> b;
  real<lower=1.2, upper=2> c;
  real<lower=1, upper=1.2> d;
  real<lower=1.1, upper=1.2> e;
  real<lower=1, upper=2> f;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_set_fun_type_named_good.stan
transformed data {
  real x;
  x = exp(x);
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_set_int_range_lower_good.stan
data {
  int<lower=1> a;
  int<lower=1, upper=3> b;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_set_int_range_upper_good.stan
data {
  int<upper=1> a;
  int<lower=1, upper=3> b;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format validate_validate_int_expr_good.stan
data {
  vector[3] a;
  row_vector[3] b;
  matrix[3, 3] c;
  unit_vector[3] d;
  simplex[3] e;
  ordered[3] f;
  positive_ordered[3] g;
  cholesky_factor_cov[4, 5] h;
  cholesky_factor_cov[3] j;
  cov_matrix[3] k;
  corr_matrix[3] l;
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format var-decl-after-statement.stan
transformed data {
  real y;
  y = 3;
  real z;
  z = 3;
}
model {
  
}

  $ ../../../../install/default/bin/stanc --auto-format var-decls-in-functions.stan
functions {
  array[] real harm_osc_ode(real t, // time
                            array[] real y, // state
                            array[] real theta, // parameters
                            array[] real x, // data
                            array[] int x_int) {
    // integer data
    array[size(y)] real dydt;
    // ... set dydt at state y and time t ...
    return dydt;
  }
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format var-ending-lpdf.stan
parameters {
  real mu_lpdf;
}
model {
  target += mu_lpdf;
}

  $ ../../../../install/default/bin/stanc --auto-format vars-with-type-prefixes.stan
parameters {
  real int_x;
  real real_x;
  real vector_x;
  real row_vector_x;
  real matrix_x;
  real unit_vector_x;
  real simplex_x;
  real ordered_x;
  real positive_ordered_x;
  real cholesky_factor_cov_x;
  real cholesky_factor_corr_x;
  real cov_matrix_x;
  real corr_matrix_x;
}
model {
  int_x ~ normal(0, 1);
  real_x ~ normal(0, 1);
  vector_x ~ normal(0, 1);
  row_vector_x ~ normal(0, 1);
  matrix_x ~ normal(0, 1);
  unit_vector_x ~ normal(0, 1);
  simplex_x ~ normal(0, 1);
  ordered_x ~ normal(0, 1);
  positive_ordered_x ~ normal(0, 1);
  cholesky_factor_cov_x ~ normal(0, 1);
  cholesky_factor_corr_x ~ normal(0, 1);
  cov_matrix_x ~ normal(0, 1);
  corr_matrix_x ~ normal(0, 1);
}

  $ ../../../../install/default/bin/stanc --auto-format vector-size-stmts.stan
functions {
  void test_vector(int vlen1, int vlen2, int arrlen) {
    vector[vlen1] lf1;
    array[arrlen] vector[vlen2] lf2;
  }
  void test_row_vector(int vlen1, int vlen2, int arrlen) {
    row_vector[vlen1] lf1;
    array[arrlen] row_vector[vlen2] lf2;
  }
  void test_matrix(int nrow1, int ncol1, int nrow2, int ncol2, int arrlen) {
    matrix[nrow1, ncol1] lf1;
    array[arrlen] matrix[nrow2, ncol2] lf2;
  }
}
data {
  int veclen;
  int arrlen;
  int nrows;
  int ncols;
  array[arrlen] real d_real_ar;
  vector[veclen] d_v;
  array[arrlen] vector[veclen] d_v_ar;
  row_vector[veclen] d_rv;
  array[arrlen] row_vector[veclen] d_rv_ar;
  matrix[nrows, ncols] d_m;
  array[arrlen] matrix[nrows, ncols] d_m_ar;
}
transformed data {
  array[arrlen] real td_real_ar = d_real_ar;
  vector[veclen] td_v = d_v;
  array[arrlen] vector[veclen] td_v_ar = d_v_ar;
  row_vector[veclen] td_rv = d_rv;
  array[arrlen] row_vector[veclen] td_rv_ar = d_rv_ar;
  matrix[nrows, ncols] td_m = d_m;
  array[arrlen] matrix[nrows, ncols] td_m_ar = d_m_ar;
  {
    array[arrlen] real local_real_ar = d_real_ar;
    vector[veclen] local_v = d_v;
    array[arrlen] vector[veclen] local_v_ar = d_v_ar;
    row_vector[veclen] local_rv = d_rv;
    array[arrlen] row_vector[veclen] local_rv_ar = d_rv_ar;
    matrix[nrows, ncols] local_m = d_m;
    array[arrlen] matrix[nrows, ncols] local_m_ar = d_m_ar;
  }
}
parameters {
  array[2] real<lower=-10, upper=10> y;
  
  array[arrlen] real p_real_ar;
  vector[veclen] p_v1;
  array[arrlen] vector[veclen] p_v_ar;
  row_vector[veclen] p_rv;
  array[arrlen] row_vector[veclen] p_rv_ar;
  matrix[nrows, ncols] p_m;
  array[arrlen] matrix[nrows, ncols] p_m_ar;
}
transformed parameters {
  array[arrlen] real tp_real_ar = td_real_ar;
  vector[veclen] tp_v1 = d_v;
  array[arrlen] vector[veclen] tp_v_ar4 = d_v_ar;
  row_vector[veclen] tp_rv = d_rv;
  array[arrlen] row_vector[veclen] tp_rv_ar = d_rv_ar;
  matrix[nrows, ncols] tp_m = d_m;
  array[arrlen] matrix[nrows, ncols] tp_m_ar = d_m_ar;
  {
    array[arrlen] real local2_real_ar = d_real_ar;
    vector[veclen] local2_v = d_v;
    array[arrlen] vector[veclen] local2_v_ar = d_v_ar;
    row_vector[veclen] local2_rv = d_rv;
    array[arrlen] row_vector[veclen] local2_rv_ar = d_rv_ar;
    matrix[nrows, ncols] local2_m = d_m;
    array[arrlen] matrix[nrows, ncols] local2_m_ar = d_m_ar;
  }
}
model {
  array[arrlen] real local3_real_ar = d_real_ar;
  vector[veclen] local3_v = d_v;
  array[arrlen] vector[veclen] local3_v_ar = d_v_ar;
  row_vector[veclen] local3_rv = d_rv;
  array[arrlen] row_vector[veclen] local3_rv_ar = d_rv_ar;
  matrix[nrows, ncols] local3_m = d_m;
  array[arrlen] matrix[nrows, ncols] local3_m_ar = d_m_ar;
  
  y ~ normal(0, 1);
}
generated quantities {
  array[arrlen] real gq_real_ar = td_real_ar;
  vector[veclen] gq_v1 = d_v;
  array[arrlen] vector[veclen] gq_v_ar4 = d_v_ar;
  row_vector[veclen] gq_rv = d_rv;
  array[arrlen] row_vector[veclen] gq_rv_ar = d_rv_ar;
  matrix[nrows, ncols] gq_m = d_m;
  array[arrlen] matrix[nrows, ncols] gq_m_ar = d_m_ar;
  {
    array[arrlen] real local4_real_ar = d_real_ar;
    vector[veclen] local4_v = d_v;
    array[arrlen] vector[veclen] local4_v_ar = d_v_ar;
    row_vector[veclen] local4_rv = d_rv;
    array[arrlen] row_vector[veclen] local4_rv_ar = d_rv_ar;
    matrix[nrows, ncols] local4_m = d_m;
    array[arrlen] matrix[nrows, ncols] local4_m_ar = d_m_ar;
  }
}

  $ ../../../../install/default/bin/stanc --auto-format vector-zero.stan
data {
  vector[0] d_v;
  row_vector[0] d_rv;
  matrix[0, 2] d_m1;
  matrix[3, 0] d_m2;
  matrix[0, 0] d_m12;
  array[0] real d_r1;
  array[0, 4] real d_r2a;
  array[2, 0] real d_r2b;
  array[0, 0] real d_r2c;
  array[0] int d_i1;
  array[4, 0] int d_i2a;
  array[0, 3] int d_i2b;
  array[0, 0] int d_i2c;
}
transformed data {
  vector[0] td_v;
  row_vector[0] td_rv;
  matrix[0, 2] td_m1;
  matrix[3, 0] td_m2;
  matrix[0, 0] td_m12;
  array[0] real td_r1;
  array[0, 4] real td_r2a;
  array[2, 0] real td_r2b;
  array[0, 0] real td_r2c;
  array[0] int td_i1;
  array[4, 0] int td_i2a;
  array[0, 3] int td_i2b;
  array[0, 0] int td_i2c;
}
parameters {
  vector[0] p_v;
  row_vector[0] p_rv;
  matrix[0, 2] p_m1;
  matrix[3, 0] p_m2;
  matrix[0, 0] p_m12;
  array[0] real p_r1;
  array[0, 4] real p_r2a;
  array[2, 0] real p_r2b;
  array[0, 0] real p_r2c;
}
transformed parameters {
  vector[0] tp_v;
  row_vector[0] tp_rv;
  matrix[0, 2] tp_m1;
  matrix[3, 0] tp_m2;
  matrix[0, 0] tp_m12;
  array[0] real tp_r1;
  array[0, 4] real tp_r2a;
  array[2, 0] real tp_r2b;
  array[0, 0] real tp_r2c;
}
model {
  
}
generated quantities {
  vector[0] gq_v;
  row_vector[0] gq_rv;
  matrix[0, 2] gq_m1;
  matrix[3, 0] gq_m2;
  matrix[0, 0] gq_m12;
  array[0] real gq_r1;
  array[0, 4] real gq_r2a;
  array[2, 0] real gq_r2b;
  array[0, 0] real gq_r2c;
  array[0] int gq_i1;
  array[4, 0] int gq_i2a;
  array[0, 3] int gq_i2b;
  array[0, 0] int gq_i2c;
}

  $ ../../../../install/default/bin/stanc --auto-format vector_size_lt_zero.stan
data {
  int d;
}
parameters {
  vector[d] p_ltzero;
}
model {
  
}

