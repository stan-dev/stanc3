  $ ../../../../../install/default/bin/stanc --O --print-cpp ad-level-failing.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace ad_level_failing_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 35> locations_array__ = 
{" (found before start of program)",
 " (in 'ad-level-failing.stan', line 45, column 2 to column 21)",
 " (in 'ad-level-failing.stan', line 46, column 2 to column 22)",
 " (in 'ad-level-failing.stan', line 47, column 2 to column 19)",
 " (in 'ad-level-failing.stan', line 48, column 2 to column 22)",
 " (in 'ad-level-failing.stan', line 52, column 2 to column 26)",
 " (in 'ad-level-failing.stan', line 54, column 4 to column 52)",
 " (in 'ad-level-failing.stan', line 53, column 2 to line 56, column 3)",
 " (in 'ad-level-failing.stan', line 60, column 2 to column 24)",
 " (in 'ad-level-failing.stan', line 61, column 2 to column 23)",
 " (in 'ad-level-failing.stan', line 62, column 2 to column 21)",
 " (in 'ad-level-failing.stan', line 63, column 2 to column 23)",
 " (in 'ad-level-failing.stan', line 65, column 2 to column 41)",
 " (in 'ad-level-failing.stan', line 67, column 4 to column 49)",
 " (in 'ad-level-failing.stan', line 66, column 2 to line 67, column 49)",
 " (in 'ad-level-failing.stan', line 69, column 2 to column 53)",
 " (in 'ad-level-failing.stan', line 29, column 2 to column 19)",
 " (in 'ad-level-failing.stan', line 30, column 9 to column 12)",
 " (in 'ad-level-failing.stan', line 30, column 2 to column 14)",
 " (in 'ad-level-failing.stan', line 31, column 2 to column 13)",
 " (in 'ad-level-failing.stan', line 32, column 15 to column 18)",
 " (in 'ad-level-failing.stan', line 32, column 2 to column 20)",
 " (in 'ad-level-failing.stan', line 33, column 13 to column 16)",
 " (in 'ad-level-failing.stan', line 33, column 2 to column 18)",
 " (in 'ad-level-failing.stan', line 37, column 2 to column 14)",
 " (in 'ad-level-failing.stan', line 38, column 2 to column 32)",
 " (in 'ad-level-failing.stan', line 40, column 2 to column 14)",
 " (in 'ad-level-failing.stan', line 41, column 2 to column 13)",
 " (in 'ad-level-failing.stan', line 52, column 18 to column 21)",
 " (in 'ad-level-failing.stan', line 17, column 4 to column 17)",
 " (in 'ad-level-failing.stan', line 19, column 4 to column 59)",
 " (in 'ad-level-failing.stan', line 21, column 4 to column 30)",
 " (in 'ad-level-failing.stan', line 22, column 4 to column 48)",
 " (in 'ad-level-failing.stan', line 24, column 4 to column 16)",
 " (in 'ad-level-failing.stan', line 15, column 31 to line 25, column 3)"};

template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<stan::promote_args_t<T0__, T1__, T2__,
T3__>>
simple_SIR(const T0__& t, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__) ;

struct simple_SIR_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<stan::promote_args_t<T0__, T1__, T2__,
T3__>>
operator()(const T0__& t, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__)  const 
{
return simple_SIR(t, y, theta, x_r, x_i, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<stan::promote_args_t<T0__, T1__, T2__,
T3__>>
simple_SIR(const T0__& t, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    local_scalar_t__ lcm_sym4__;
    double lcm_sym3__;
    double lcm_sym2__;
    double lcm_sym1__;
    {
      std::vector<local_scalar_t__> dydt;
      dydt = std::vector<local_scalar_t__>(4, DUMMY_VAR__);
      
      current_statement__ = 30;
      assign(dydt,
        (((-rvalue(theta, "theta", index_uni(1)) *
            rvalue(y, "y", index_uni(4))) /
           (rvalue(y, "y", index_uni(4)) +
             rvalue(theta, "theta", index_uni(2)))) *
          rvalue(y, "y", index_uni(1))),
        "assigning variable dydt", index_uni(1));
      lcm_sym4__ = (rvalue(theta, "theta", index_uni(3)) *
                     rvalue(y, "y", index_uni(2)));
      assign(dydt,
        ((((rvalue(theta, "theta", index_uni(1)) *
             rvalue(y, "y", index_uni(4))) /
            (rvalue(y, "y", index_uni(4)) +
              rvalue(theta, "theta", index_uni(2)))) *
           rvalue(y, "y", index_uni(1))) - lcm_sym4__),
        "assigning variable dydt", index_uni(2));
      current_statement__ = 31;
      assign(dydt, lcm_sym4__, "assigning variable dydt", index_uni(3));
      current_statement__ = 32;
      assign(dydt,
        ((rvalue(theta, "theta", index_uni(4)) *
           rvalue(y, "y", index_uni(2))) -
          (rvalue(theta, "theta", index_uni(5)) *
            rvalue(y, "y", index_uni(4)))),
        "assigning variable dydt", index_uni(4));
      current_statement__ = 33;
      return dydt;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
class ad_level_failing_model final : public model_base_crtp<ad_level_failing_model> {

 private:
  int N_t;
  std::vector<double> t;
  std::vector<double> y0;
  std::vector<int> stoi_hat;
  std::vector<double> B_hat;
  double t0;
  double kappa;
  std::vector<double> x_r;
  std::vector<int> x_i; 
  
 
 public:
  ~ad_level_failing_model() { }
  
  inline std::string model_name() const final { return "ad_level_failing_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  ad_level_failing_model(stan::io::var_context& context__,
                         unsigned int random_seed__ = 0,
                         std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "ad_level_failing_model_namespace::ad_level_failing_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 16;
      context__.validate_dims("data initialization","N_t","int",
           std::vector<size_t>{});
      N_t = std::numeric_limits<int>::min();
      
      current_statement__ = 16;
      N_t = context__.vals_i("N_t")[(1 - 1)];
      current_statement__ = 16;
      check_greater_or_equal(function__, "N_t", N_t, 0);
      current_statement__ = 17;
      validate_non_negative_index("t", "N_t", N_t);
      current_statement__ = 18;
      context__.validate_dims("data initialization","t","double",
           std::vector<size_t>{static_cast<size_t>(N_t)});
      t = std::vector<double>(N_t, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 18;
      t = context__.vals_r("t");
      current_statement__ = 19;
      context__.validate_dims("data initialization","y0","double",
           std::vector<size_t>{static_cast<size_t>(4)});
      y0 = std::vector<double>(4, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 19;
      y0 = context__.vals_r("y0");
      current_statement__ = 20;
      validate_non_negative_index("stoi_hat", "N_t", N_t);
      current_statement__ = 21;
      context__.validate_dims("data initialization","stoi_hat","int",
           std::vector<size_t>{static_cast<size_t>(N_t)});
      stoi_hat = std::vector<int>(N_t, std::numeric_limits<int>::min());
      
      current_statement__ = 21;
      stoi_hat = context__.vals_i("stoi_hat");
      current_statement__ = 22;
      validate_non_negative_index("B_hat", "N_t", N_t);
      current_statement__ = 23;
      context__.validate_dims("data initialization","B_hat","double",
           std::vector<size_t>{static_cast<size_t>(N_t)});
      B_hat = std::vector<double>(N_t, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 23;
      B_hat = context__.vals_r("B_hat");
      current_statement__ = 24;
      t0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 24;
      t0 = 0;
      current_statement__ = 25;
      kappa = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 25;
      kappa = 1000000;
      current_statement__ = 26;
      x_r = std::vector<double>(0, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 27;
      x_i = std::vector<int>(0, std::numeric_limits<int>::min());
      
      current_statement__ = 25;
      check_greater_or_equal(function__, "kappa", 1000000, 0);
      current_statement__ = 28;
      validate_non_negative_index("y", "N_t", N_t);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "ad_level_failing_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ lcm_sym32__;
      double lcm_sym31__;
      double lcm_sym30__;
      double lcm_sym29__;
      std::vector<local_scalar_t__> lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      double lcm_sym24__;
      std::vector<std::vector<local_scalar_t__>> lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      int lcm_sym18__;
      int lcm_sym17__;
      local_scalar_t__ beta;
      current_statement__ = 1;
      beta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      local_scalar_t__ gamma;
      current_statement__ = 2;
      gamma = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                0, lp__);
      local_scalar_t__ xi;
      current_statement__ = 3;
      xi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
             lp__);
      local_scalar_t__ delta;
      current_statement__ = 4;
      delta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                0, lp__);
      std::vector<std::vector<local_scalar_t__>> y;
      {
        std::vector<double> theta;
        assign(lcm_sym28__, std::vector<local_scalar_t__>{beta,
          stan::math::promote_scalar<local_scalar_t__>(1000000), gamma, xi,
          delta}, "assigning variable lcm_sym28__");
        assign(lcm_sym23__,
          integrate_ode_rk45(simple_SIR_functor__(), y0, 0, t, lcm_sym28__,
            x_r, x_i, pstream__), "assigning variable lcm_sym23__");
        assign(y, lcm_sym23__, "assigning variable y");
      }
      current_statement__ = 5;
      if (logical_gte(N_t, 1)) {
        {
          {
            {
              lcm_sym32__ = rvalue(lcm_sym23__, "lcm_sym23__",
                              index_uni(1), index_uni(1));
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     lcm_sym32__, 0);
              {
                current_statement__ = 5;
                check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                       rvalue(lcm_sym23__, "lcm_sym23__",
                                         index_uni(1), index_uni(2)), 0);
              }
              {
                current_statement__ = 5;
                check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                       rvalue(lcm_sym23__, "lcm_sym23__",
                                         index_uni(1), index_uni(3)), 0);
              }
              {
                current_statement__ = 5;
                check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                       rvalue(lcm_sym23__, "lcm_sym23__",
                                         index_uni(1), index_uni(4)), 0);
              }
            }
          }
          for (int sym1__ = 2; sym1__ <= N_t; ++sym1__) {
            {
              current_statement__ = 5;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     rvalue(lcm_sym23__, "lcm_sym23__",
                                       index_uni(sym1__), index_uni(1)), 0);
              {
                current_statement__ = 5;
                check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                       rvalue(lcm_sym23__, "lcm_sym23__",
                                         index_uni(sym1__), index_uni(2)), 0);
              }
              {
                current_statement__ = 5;
                check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                       rvalue(lcm_sym23__, "lcm_sym23__",
                                         index_uni(sym1__), index_uni(3)), 0);
              }
              {
                current_statement__ = 5;
                check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                       rvalue(lcm_sym23__, "lcm_sym23__",
                                         index_uni(sym1__), index_uni(4)), 0);
              }
            }
          }
        }
      } else {
        lcm_sym32__ = rvalue(lcm_sym23__, "lcm_sym23__",
                        index_uni(1), index_uni(1));
      }
      {
        current_statement__ = 8;
        lp_accum__.add(cauchy_lpdf<propto__>(beta, 0, 2.5));
        current_statement__ = 9;
        lp_accum__.add(cauchy_lpdf<propto__>(gamma, 0, 1));
        current_statement__ = 10;
        lp_accum__.add(cauchy_lpdf<propto__>(xi, 0, 25));
        current_statement__ = 11;
        lp_accum__.add(cauchy_lpdf<propto__>(delta, 0, 1));
        current_statement__ = 12;
        lp_accum__.add(
          poisson_lpmf<propto__>(rvalue(stoi_hat, "stoi_hat", index_uni(1)),
            (rvalue(y0, "y0", index_uni(1)) - lcm_sym32__)));
        current_statement__ = 14;
        if (logical_gte(N_t, 2)) {
          current_statement__ = 13;
          lp_accum__.add(
            poisson_lpmf<propto__>(
              rvalue(stoi_hat, "stoi_hat", index_uni(2)),
              (lcm_sym32__ -
                rvalue(lcm_sym23__, "lcm_sym23__",
                  index_uni(2), index_uni(1)))));
          for (int n = 3; n <= N_t; ++n) {
            current_statement__ = 13;
            lp_accum__.add(
              poisson_lpmf<propto__>(
                rvalue(stoi_hat, "stoi_hat", index_uni(n)),
                (rvalue(lcm_sym23__, "lcm_sym23__",
                   index_uni((n - 1)), index_uni(1)) -
                  rvalue(lcm_sym23__, "lcm_sym23__",
                    index_uni(n), index_uni(1)))));
          }
        } 
        current_statement__ = 15;
        lp_accum__.add(
          lognormal_lpdf<propto__>(B_hat,
            stan::math::log(col(to_matrix(lcm_sym23__), 4)), 0.15));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "ad_level_failing_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      double lcm_sym12__;
      double lcm_sym11__;
      double lcm_sym10__;
      std::vector<double> lcm_sym9__;
      std::vector<std::vector<double>> lcm_sym8__;
      int lcm_sym7__;
      int lcm_sym6__;
      int lcm_sym5__;
      double beta;
      current_statement__ = 1;
      beta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      double gamma;
      current_statement__ = 2;
      gamma = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                0, lp__);
      double xi;
      current_statement__ = 3;
      xi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
             lp__);
      double delta;
      current_statement__ = 4;
      delta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                0, lp__);
      std::vector<std::vector<double>> y;
      y = std::vector<std::vector<double>>(N_t, std::vector<double>(4, std::numeric_limits<double>::quiet_NaN()));
      
      
      out__.write(beta);
      out__.write(gamma);
      out__.write(xi);
      out__.write(delta);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      {
        std::vector<double> theta;
        assign(lcm_sym9__, std::vector<double>{beta,
          stan::math::promote_scalar<double>(1000000), gamma, xi, delta},
          "assigning variable lcm_sym9__");
        assign(lcm_sym8__,
          integrate_ode_rk45(simple_SIR_functor__(), y0, 0, t, lcm_sym9__,
            x_r, x_i, pstream__), "assigning variable lcm_sym8__");
        assign(y, lcm_sym8__, "assigning variable y");
      }
      lcm_sym5__ = logical_gte(N_t, 1);
      if (lcm_sym5__) {
        {
          current_statement__ = 5;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 rvalue(lcm_sym8__, "lcm_sym8__",
                                   index_uni(1), index_uni(1)), 0);
          {
            current_statement__ = 5;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(lcm_sym8__, "lcm_sym8__",
                                     index_uni(1), index_uni(2)), 0);
          }
          {
            current_statement__ = 5;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(lcm_sym8__, "lcm_sym8__",
                                     index_uni(1), index_uni(3)), 0);
          }
          {
            current_statement__ = 5;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(lcm_sym8__, "lcm_sym8__",
                                     index_uni(1), index_uni(4)), 0);
          }
        }
        for (int sym1__ = 2; sym1__ <= N_t; ++sym1__) {
          {
            current_statement__ = 5;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(lcm_sym8__, "lcm_sym8__",
                                     index_uni(sym1__), index_uni(1)), 0);
            {
              current_statement__ = 5;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     rvalue(lcm_sym8__, "lcm_sym8__",
                                       index_uni(sym1__), index_uni(2)), 0);
            }
            {
              current_statement__ = 5;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     rvalue(lcm_sym8__, "lcm_sym8__",
                                       index_uni(sym1__), index_uni(3)), 0);
            }
            {
              current_statement__ = 5;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     rvalue(lcm_sym8__, "lcm_sym8__",
                                       index_uni(sym1__), index_uni(4)), 0);
            }
          }
        }
      } 
      if (emit_transformed_parameters__) {
        {
          if (lcm_sym5__) {
            out__.write(
              rvalue(lcm_sym8__, "lcm_sym8__", index_uni(1), index_uni(1)));
            for (int sym2__ = 2; sym2__ <= N_t; ++sym2__) {
              out__.write(
                rvalue(lcm_sym8__, "lcm_sym8__",
                  index_uni(sym2__), index_uni(1)));
            }
          } 
          {
            if (lcm_sym5__) {
              out__.write(
                rvalue(lcm_sym8__, "lcm_sym8__", index_uni(1), index_uni(2)));
              for (int sym2__ = 2; sym2__ <= N_t; ++sym2__) {
                out__.write(
                  rvalue(lcm_sym8__, "lcm_sym8__",
                    index_uni(sym2__), index_uni(2)));
              }
            } 
          }
          {
            if (lcm_sym5__) {
              out__.write(
                rvalue(lcm_sym8__, "lcm_sym8__", index_uni(1), index_uni(3)));
              for (int sym2__ = 2; sym2__ <= N_t; ++sym2__) {
                out__.write(
                  rvalue(lcm_sym8__, "lcm_sym8__",
                    index_uni(sym2__), index_uni(3)));
              }
            } 
          }
          {
            if (lcm_sym5__) {
              out__.write(
                rvalue(lcm_sym8__, "lcm_sym8__", index_uni(1), index_uni(4)));
              for (int sym2__ = 2; sym2__ <= N_t; ++sym2__) {
                out__.write(
                  rvalue(lcm_sym8__, "lcm_sym8__",
                    index_uni(sym2__), index_uni(4)));
              }
            } 
          }
        }
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__;
      pos__ = 1;
      local_scalar_t__ beta;
      beta = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, beta);
      local_scalar_t__ gamma;
      gamma = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, gamma);
      local_scalar_t__ xi;
      xi = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, xi);
      local_scalar_t__ delta;
      delta = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, delta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"beta", "gamma", "xi", "delta", "y"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      },
      std::vector<size_t>{static_cast<size_t>(N_t), static_cast<size_t>(4)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta");
    param_names__.emplace_back(std::string() + "gamma");
    param_names__.emplace_back(std::string() + "xi");
    param_names__.emplace_back(std::string() + "delta");
    if (emit_transformed_parameters__) {
      for (int sym33__ = 1; sym33__ <= 4; ++sym33__) {
        {
          for (int sym34__ = 1; sym34__ <= N_t; ++sym34__) {
            {
              param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym34__) + '.' + std::to_string(sym33__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta");
    param_names__.emplace_back(std::string() + "gamma");
    param_names__.emplace_back(std::string() + "xi");
    param_names__.emplace_back(std::string() + "delta");
    if (emit_transformed_parameters__) {
      for (int sym33__ = 1; sym33__ <= 4; ++sym33__) {
        {
          for (int sym34__ = 1; sym34__ <= N_t; ++sym34__) {
            {
              param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym34__) + '.' + std::to_string(sym33__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"xi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N_t) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"xi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N_t) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((1 + 1) + 1) + 1);
      const size_t num_transformed = (N_t * 4);
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((1 + 1) + 1) + 1);
      const size_t num_transformed = (N_t * 4);
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 4> names__{"beta", "gamma", "xi",
      "delta"};
      const std::array<Eigen::Index, 4> constrain_param_sizes__{1, 1, 1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = ad_level_failing_model_namespace::ad_level_failing_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return ad_level_failing_model_namespace::profiles__;
}

#endif



Warning in 'ad-level-failing.stan', line 55, column 8: integrate_ode_rk45 is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../../install/default/bin/stanc --O --print-cpp copy_fail.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace copy_fail_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 68> locations_array__ = 
{" (found before start of program)",
 " (in 'copy_fail.stan', line 71, column 2 to column 31)",
 " (in 'copy_fail.stan', line 72, column 2 to column 40)",
 " (in 'copy_fail.stan', line 76, column 2 to column 51)",
 " (in 'copy_fail.stan', line 77, column 2 to column 49)",
 " (in 'copy_fail.stan', line 78, column 2 to column 49)",
 " (in 'copy_fail.stan', line 83, column 6 to column 20)",
 " (in 'copy_fail.stan', line 84, column 6 to column 18)",
 " (in 'copy_fail.stan', line 82, column 32 to line 85, column 5)",
 " (in 'copy_fail.stan', line 87, column 6 to column 32)",
 " (in 'copy_fail.stan', line 88, column 6 to column 23)",
 " (in 'copy_fail.stan', line 86, column 38 to line 89, column 5)",
 " (in 'copy_fail.stan', line 86, column 4 to line 89, column 5)",
 " (in 'copy_fail.stan', line 81, column 20 to line 90, column 3)",
 " (in 'copy_fail.stan', line 26, column 11 to column 15)",
 " (in 'copy_fail.stan', line 26, column 17 to column 28)",
 " (in 'copy_fail.stan', line 26, column 4 to column 34)",
 " (in 'copy_fail.stan', line 29, column 6 to column 32)",
 " (in 'copy_fail.stan', line 32, column 8 to column 37)",
 " (in 'copy_fail.stan', line 33, column 8 to column 32)",
 " (in 'copy_fail.stan', line 41, column 8 to line 42, column 83)",
 " (in 'copy_fail.stan', line 30, column 37 to line 43, column 7)",
 " (in 'copy_fail.stan', line 28, column 22 to line 44, column 5)",
 " (in 'copy_fail.stan', line 25, column 47 to line 46, column 3)",
 " (in 'copy_fail.stan', line 105, column 8 to column 37)",
 " (in 'copy_fail.stan', line 106, column 8 to column 41)",
 " (in 'copy_fail.stan', line 104, column 40 to line 107, column 7)",
 " (in 'copy_fail.stan', line 108, column 6 to column 37)",
 " (in 'copy_fail.stan', line 103, column 22 to line 109, column 5)",
 " (in 'copy_fail.stan', line 102, column 20 to line 110, column 3)",
 " (in 'copy_fail.stan', line 102, column 2 to line 110, column 3)",
 " (in 'copy_fail.stan', line 50, column 2 to column 20)",
 " (in 'copy_fail.stan', line 51, column 2 to column 27)",
 " (in 'copy_fail.stan', line 52, column 25 to column 29)",
 " (in 'copy_fail.stan', line 52, column 31 to column 42)",
 " (in 'copy_fail.stan', line 52, column 2 to column 44)",
 " (in 'copy_fail.stan', line 53, column 2 to column 23)",
 " (in 'copy_fail.stan', line 54, column 31 to column 35)",
 " (in 'copy_fail.stan', line 54, column 2 to column 54)",
 " (in 'copy_fail.stan', line 58, column 2 to column 38)",
 " (in 'copy_fail.stan', line 60, column 39 to column 43)",
 " (in 'copy_fail.stan', line 60, column 2 to column 45)",
 " (in 'copy_fail.stan', line 61, column 38 to column 42)",
 " (in 'copy_fail.stan', line 61, column 2 to column 44)",
 " (in 'copy_fail.stan', line 8, column 8 to column 17)",
 " (in 'copy_fail.stan', line 7, column 6 to line 8, column 17)",
 " (in 'copy_fail.stan', line 5, column 31 to line 10, column 3)",
 " (in 'copy_fail.stan', line 65, column 4 to column 35)",
 " (in 'copy_fail.stan', line 64, column 2 to line 65, column 35)",
 " (in 'copy_fail.stan', line 15, column 6 to column 32)",
 " (in 'copy_fail.stan', line 19, column 8 to column 17)",
 " (in 'copy_fail.stan', line 18, column 6 to line 19, column 17)",
 " (in 'copy_fail.stan', line 13, column 37 to line 20, column 5)",
 " (in 'copy_fail.stan', line 12, column 30 to line 22, column 3)",
 " (in 'copy_fail.stan', line 67, column 4 to column 33)",
 " (in 'copy_fail.stan', line 66, column 2 to line 67, column 33)",
 " (in 'copy_fail.stan', line 72, column 26 to column 33)",
 " (in 'copy_fail.stan', line 76, column 26 to column 30)",
 " (in 'copy_fail.stan', line 76, column 32 to column 45)",
 " (in 'copy_fail.stan', line 77, column 26 to column 30)",
 " (in 'copy_fail.stan', line 77, column 32 to column 45)",
 " (in 'copy_fail.stan', line 78, column 26 to column 30)",
 " (in 'copy_fail.stan', line 78, column 32 to column 43)",
 " (in 'copy_fail.stan', line 9, column 4 to column 13)",
 " (in 'copy_fail.stan', line 21, column 4 to column 13)",
 " (in 'copy_fail.stan', line 30, column 6 to line 43, column 7)",
 " (in 'copy_fail.stan', line 28, column 4 to line 44, column 5)",
 " (in 'copy_fail.stan', line 45, column 4 to column 15)"};

int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) ;

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) ;

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p,
                const T3__& phi, std::ostream* pstream__) ;

struct prob_uncaptured_functor__ {
template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
operator()(const int& nind, const int& n_occasions, const T2__& p,
           const T3__& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}
};

int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym29__;
    int lcm_sym28__;
    int lcm_sym27__;
    int lcm_sym26__;
    {
      lcm_sym27__ = size(y_i);
      if (logical_gte(lcm_sym27__, 1)) {
        current_statement__ = 45;
        if (rvalue(y_i, "y_i", index_uni(1))) {
          current_statement__ = 44;
          return 1;
        } 
        for (int k = 2; k <= lcm_sym27__; ++k) {
          current_statement__ = 45;
          if (rvalue(y_i, "y_i", index_uni(k))) {
            current_statement__ = 44;
            return k;
          } 
        }
      } 
      current_statement__ = 63;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym35__;
    int lcm_sym34__;
    int lcm_sym33__;
    int lcm_sym32__;
    int lcm_sym31__;
    int lcm_sym30__;
    {
      lcm_sym33__ = (size(y_i) - 1);
      if (logical_gte(lcm_sym33__, 0)) {
        int k;
        lcm_sym32__ = (size(y_i) - 0);
        current_statement__ = 51;
        if (y_i[(lcm_sym32__ - 1)]) {
          current_statement__ = 50;
          return lcm_sym32__;
        } 
        for (int k_rev = 1; k_rev <= lcm_sym33__; ++k_rev) {
          int k;
          lcm_sym31__ = (size(y_i) - k_rev);
          current_statement__ = 51;
          if (y_i[(lcm_sym31__ - 1)]) {
            current_statement__ = 50;
            return lcm_sym31__;
          } 
        }
      } 
      current_statement__ = 64;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  int current_statement__ = 0; 
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    double lcm_sym45__;
    double lcm_sym44__;
    double lcm_sym43__;
    double lcm_sym42__;
    int lcm_sym41__;
    int lcm_sym40__;
    int lcm_sym39__;
    int lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    {
      current_statement__ = 14;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 15;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      current_statement__ = 66;
      if (logical_gte(nind, 1)) {
        current_statement__ = 17;
        assign(chi, 1.0,
          "assigning variable chi", index_uni(1), index_uni(n_occasions));
        lcm_sym39__ = (n_occasions - 1);
        lcm_sym37__ = logical_gte(lcm_sym39__, 1);
        if (lcm_sym37__) {
          int t_curr;
          int t_next;
          lcm_sym41__ = (lcm_sym39__ + 1);
          current_statement__ = 20;
          assign(chi,
            stan::math::fma(
              (rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym39__)) *
                (1 -
                  rvalue(p, "p", index_uni(1), index_uni((lcm_sym41__ - 1))))),
              rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym41__)),
              (1 - rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym39__)))),
            "assigning variable chi", index_uni(1), index_uni(lcm_sym39__));
          for (int t = 2; t <= lcm_sym39__; ++t) {
            int t_curr;
            lcm_sym38__ = (n_occasions - t);
            int t_next;
            lcm_sym40__ = (lcm_sym38__ + 1);
            current_statement__ = 20;
            assign(chi,
              stan::math::fma(
                (rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym38__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(1), index_uni((lcm_sym40__ - 1))))),
                rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym40__)),
                (1 -
                  rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym38__)))),
              "assigning variable chi", index_uni(1), index_uni(lcm_sym38__));
          }
        } 
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 17;
          assign(chi, 1.0,
            "assigning variable chi", index_uni(i), index_uni(n_occasions));
          current_statement__ = 65;
          if (lcm_sym37__) {
            int t_curr;
            int t_next;
            lcm_sym41__ = (lcm_sym39__ + 1);
            current_statement__ = 20;
            assign(chi,
              stan::math::fma(
                (rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym39__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(i), index_uni((lcm_sym41__ - 1))))),
                rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym41__)),
                (1 -
                  rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym39__)))),
              "assigning variable chi", index_uni(i), index_uni(lcm_sym39__));
            for (int t = 2; t <= lcm_sym39__; ++t) {
              int t_curr;
              lcm_sym38__ = (n_occasions - t);
              int t_next;
              lcm_sym40__ = (lcm_sym38__ + 1);
              current_statement__ = 20;
              assign(chi,
                stan::math::fma(
                  (rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym38__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(i), index_uni((lcm_sym40__ - 1))))),
                  rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym40__)),
                  (1 -
                    rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym38__)))),
                "assigning variable chi", index_uni(i),
                                            index_uni(lcm_sym38__));
            }
          } 
        }
      } 
      current_statement__ = 67;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
class copy_fail_model final : public model_base_crtp<copy_fail_model> {

 private:
  int lcm_sym167__;
  int lcm_sym166__;
  int lcm_sym165__;
  int lcm_sym164__;
  int lcm_sym163__;
  int lcm_sym162__;
  int lcm_sym161__;
  int lcm_sym160__;
  int lcm_sym159__;
  int lcm_sym158__;
  int lcm_sym157__;
  int lcm_sym156__;
  int lcm_sym155__;
  int lcm_sym154__;
  int lcm_sym153__;
  int lcm_sym152__;
  int lcm_sym151__;
  int lcm_sym150__;
  int lcm_sym149__;
  int lcm_sym148__;
  int lcm_sym147__;
  int lcm_sym146__;
  int lcm_sym145__;
  int lcm_sym144__;
  int lcm_sym143__;
  int lcm_sym142__;
  int lcm_sym141__;
  int lcm_sym140__;
  int lcm_sym139__;
  int lcm_sym138__;
  int lcm_sym137__;
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int max_age;
  std::vector<std::vector<int>> x;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last; 
  
 
 public:
  ~copy_fail_model() { }
  
  inline std::string model_name() const final { return "copy_fail_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  copy_fail_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "copy_fail_model_namespace::copy_fail_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 31;
      context__.validate_dims("data initialization","nind","int",
           std::vector<size_t>{});
      nind = std::numeric_limits<int>::min();
      
      current_statement__ = 31;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 31;
      check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 32;
      context__.validate_dims("data initialization","n_occasions","int",
           std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      
      current_statement__ = 32;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 32;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 2);
      current_statement__ = 33;
      validate_non_negative_index("y", "nind", nind);
      current_statement__ = 34;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 35;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(nind),
            static_cast<size_t>(n_occasions)});
      y = std::vector<std::vector<int>>(nind, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 35;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 35;
        pos__ = 1;
        lcm_sym137__ = logical_gte(n_occasions, 1);
        if (lcm_sym137__) {
          {
            lcm_sym138__ = logical_gte(nind, 1);
            if (lcm_sym138__) {
              current_statement__ = 35;
              assign(y, rvalue(y_flat__, "y_flat__", index_uni(1)),
                "assigning variable y", index_uni(1), index_uni(1));
              current_statement__ = 35;
              pos__ = 2;
              for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                current_statement__ = 35;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(sym2__), index_uni(1));
                current_statement__ = 35;
                pos__ = (pos__ + 1);
              }
            } 
            for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
              current_statement__ = 35;
              if (lcm_sym138__) {
                current_statement__ = 35;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(1), index_uni(sym1__));
                current_statement__ = 35;
                pos__ = (pos__ + 1);
                for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                  current_statement__ = 35;
                  assign(y, y_flat__[(pos__ - 1)],
                    "assigning variable y", index_uni(sym2__),
                                              index_uni(sym1__));
                  current_statement__ = 35;
                  pos__ = (pos__ + 1);
                }
              } 
            }
          }
        } else {
          lcm_sym138__ = logical_gte(nind, 1);
        }
      }
      current_statement__ = 35;
      if (lcm_sym138__) {
        current_statement__ = 35;
        if (lcm_sym137__) {
          current_statement__ = 35;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 rvalue(y, "y", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 35;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 35;
          if (lcm_sym137__) {
            current_statement__ = 35;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 35;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);
            }
          } 
        }
      } 
      current_statement__ = 35;
      if (lcm_sym138__) {
        current_statement__ = 35;
        if (lcm_sym137__) {
          current_statement__ = 35;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              rvalue(y, "y", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 35;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 35;
          if (lcm_sym137__) {
            current_statement__ = 35;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 35;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);
            }
          } 
        }
      } 
      current_statement__ = 36;
      context__.validate_dims("data initialization","max_age","int",
           std::vector<size_t>{});
      max_age = std::numeric_limits<int>::min();
      
      current_statement__ = 36;
      max_age = context__.vals_i("max_age")[(1 - 1)];
      current_statement__ = 36;
      check_greater_or_equal(function__, "max_age", max_age, 1);
      current_statement__ = 37;
      validate_non_negative_index("x", "nind", nind);
      lcm_sym140__ = (n_occasions - 1);
      validate_non_negative_index("x", "n_occasions - 1", lcm_sym140__);
      current_statement__ = 38;
      context__.validate_dims("data initialization","x","int",
           std::vector<size_t>{static_cast<size_t>(nind),
            static_cast<size_t>(lcm_sym140__)});
      x = std::vector<std::vector<int>>(nind, std::vector<int>(lcm_sym140__, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> x_flat__;
        current_statement__ = 38;
        x_flat__ = context__.vals_i("x");
        current_statement__ = 38;
        pos__ = 1;
        lcm_sym139__ = logical_gte(lcm_sym140__, 1);
        if (lcm_sym139__) {
          current_statement__ = 38;
          if (lcm_sym138__) {
            current_statement__ = 38;
            assign(x, rvalue(x_flat__, "x_flat__", index_uni(1)),
              "assigning variable x", index_uni(1), index_uni(1));
            current_statement__ = 38;
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
              current_statement__ = 38;
              assign(x, x_flat__[(pos__ - 1)],
                "assigning variable x", index_uni(sym2__), index_uni(1));
              current_statement__ = 38;
              pos__ = (pos__ + 1);
            }
          } 
          for (int sym1__ = 2; sym1__ <= lcm_sym140__; ++sym1__) {
            current_statement__ = 38;
            if (lcm_sym138__) {
              current_statement__ = 38;
              assign(x, x_flat__[(pos__ - 1)],
                "assigning variable x", index_uni(1), index_uni(sym1__));
              current_statement__ = 38;
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                current_statement__ = 38;
                assign(x, x_flat__[(pos__ - 1)],
                  "assigning variable x", index_uni(sym2__),
                                            index_uni(sym1__));
                current_statement__ = 38;
                pos__ = (pos__ + 1);
              }
            } 
          }
        } 
      }
      current_statement__ = 38;
      if (lcm_sym138__) {
        current_statement__ = 38;
        if (lcm_sym139__) {
          current_statement__ = 38;
          check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                 rvalue(x, "x", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym140__; ++sym2__) {
            current_statement__ = 38;
            check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                   rvalue(x, "x",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 38;
          if (lcm_sym139__) {
            current_statement__ = 38;
            check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                   rvalue(x, "x",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym140__; ++sym2__) {
              current_statement__ = 38;
              check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                     x[(sym1__ - 1)][(sym2__ - 1)], 0);
            }
          } 
        }
      } 
      current_statement__ = 38;
      if (lcm_sym138__) {
        current_statement__ = 38;
        if (lcm_sym139__) {
          current_statement__ = 38;
          check_less_or_equal(function__, "x[sym1__, sym2__]",
                              rvalue(x, "x", index_uni(1), index_uni(1)),
                              max_age);
          for (int sym2__ = 2; sym2__ <= lcm_sym140__; ++sym2__) {
            current_statement__ = 38;
            check_less_or_equal(function__, "x[sym1__, sym2__]",
                                rvalue(x, "x",
                                  index_uni(1), index_uni(sym2__)), max_age);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 38;
          if (lcm_sym139__) {
            current_statement__ = 38;
            check_less_or_equal(function__, "x[sym1__, sym2__]",
                                rvalue(x, "x",
                                  index_uni(sym1__), index_uni(1)), max_age);
            for (int sym2__ = 2; sym2__ <= lcm_sym140__; ++sym2__) {
              current_statement__ = 38;
              check_less_or_equal(function__, "x[sym1__, sym2__]",
                                  x[(sym1__ - 1)][(sym2__ - 1)], max_age);
            }
          } 
        }
      } 
      current_statement__ = 39;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      
      current_statement__ = 39;
      n_occ_minus_1 = lcm_sym140__;
      current_statement__ = 40;
      validate_non_negative_index("first", "nind", nind);
      current_statement__ = 41;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 42;
      validate_non_negative_index("last", "nind", nind);
      current_statement__ = 43;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 48;
      if (lcm_sym138__) {
        int inline_sym17__;
        int inline_sym19__;
        inline_sym19__ = 0;
        for (int inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
          lcm_sym147__ = size(rvalue(y, "y", index_uni(1)));
          for (int inline_sym18__ = 1; inline_sym18__ <= lcm_sym147__;
               ++inline_sym18__) {
            current_statement__ = 45;
            if (rvalue(y, "y", index_uni(1))[(inline_sym18__ - 1)]) {
              inline_sym19__ = 1;
              inline_sym17__ = inline_sym18__;
              break;
            } 
          }
          if (inline_sym19__) {
            break;
          } 
          inline_sym19__ = 1;
          inline_sym17__ = 0;
          break;
        }
        assign(first, inline_sym17__,
          "assigning variable first", index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          int inline_sym17__;
          int inline_sym19__;
          inline_sym19__ = 0;
          for (int inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
            lcm_sym146__ = size(rvalue(y, "y", index_uni(i)));
            for (int inline_sym18__ = 1; inline_sym18__ <= lcm_sym146__;
                 ++inline_sym18__) {
              current_statement__ = 45;
              if (rvalue(y, "y", index_uni(i))[(inline_sym18__ - 1)]) {
                inline_sym19__ = 1;
                inline_sym17__ = inline_sym18__;
                break;
              } 
            }
            if (inline_sym19__) {
              break;
            } 
            inline_sym19__ = 1;
            inline_sym17__ = 0;
            break;
          }
          assign(first, inline_sym17__,
            "assigning variable first", index_uni(i));
        }
      } 
      current_statement__ = 55;
      if (lcm_sym138__) {
        int inline_sym21__;
        int inline_sym24__;
        inline_sym24__ = 0;
        for (int inline_sym25__ = 1; inline_sym25__ <= 1; ++inline_sym25__) {
          lcm_sym147__ = size(rvalue(y, "y", index_uni(1)));
          lcm_sym144__ = (lcm_sym147__ - 1);
          for (int inline_sym23__ = 0; inline_sym23__ <= lcm_sym144__;
               ++inline_sym23__) {
            int inline_sym22__;
            lcm_sym143__ = (lcm_sym147__ - inline_sym23__);
            inline_sym22__ = lcm_sym143__;
            current_statement__ = 51;
            if (rvalue(y, "y", index_uni(1))[(lcm_sym143__ - 1)]) {
              inline_sym24__ = 1;
              inline_sym21__ = lcm_sym143__;
              break;
            } 
          }
          if (inline_sym24__) {
            break;
          } 
          inline_sym24__ = 1;
          inline_sym21__ = 0;
          break;
        }
        assign(last, inline_sym21__, "assigning variable last", index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          int inline_sym21__;
          int inline_sym24__;
          inline_sym24__ = 0;
          for (int inline_sym25__ = 1; inline_sym25__ <= 1; ++inline_sym25__) {
            lcm_sym146__ = size(rvalue(y, "y", index_uni(i)));
            lcm_sym142__ = (lcm_sym146__ - 1);
            for (int inline_sym23__ = 0; inline_sym23__ <= lcm_sym142__;
                 ++inline_sym23__) {
              int inline_sym22__;
              lcm_sym141__ = (lcm_sym146__ - inline_sym23__);
              inline_sym22__ = lcm_sym141__;
              current_statement__ = 51;
              if (rvalue(y, "y", index_uni(i))[(lcm_sym141__ - 1)]) {
                inline_sym24__ = 1;
                inline_sym21__ = lcm_sym141__;
                break;
              } 
            }
            if (inline_sym24__) {
              break;
            } 
            inline_sym24__ = 1;
            inline_sym21__ = 0;
            break;
          }
          assign(last, inline_sym21__,
            "assigning variable last", index_uni(i));
        }
      } 
      current_statement__ = 41;
      if (lcm_sym138__) {
        current_statement__ = 41;
        check_greater_or_equal(function__, "first[sym1__]",
                               rvalue(first, "first", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 41;
          check_greater_or_equal(function__, "first[sym1__]",
                                 first[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 41;
      if (lcm_sym138__) {
        current_statement__ = 41;
        check_less_or_equal(function__, "first[sym1__]",
                            rvalue(first, "first", index_uni(1)), n_occasions);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 41;
          check_less_or_equal(function__, "first[sym1__]",
                              first[(sym1__ - 1)], n_occasions);
        }
      } 
      current_statement__ = 43;
      if (lcm_sym138__) {
        current_statement__ = 43;
        check_greater_or_equal(function__, "last[sym1__]",
                               rvalue(last, "last", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 43;
          check_greater_or_equal(function__, "last[sym1__]",
                                 last[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 43;
      if (lcm_sym138__) {
        current_statement__ = 43;
        check_less_or_equal(function__, "last[sym1__]",
                            rvalue(last, "last", index_uni(1)), n_occasions);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 43;
          check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                              n_occasions);
        }
      } 
      current_statement__ = 56;
      validate_non_negative_index("beta", "max_age", max_age);
      current_statement__ = 57;
      validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 58;
      validate_non_negative_index("phi", "n_occ_minus_1", lcm_sym140__);
      current_statement__ = 59;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 60;
      validate_non_negative_index("p", "n_occ_minus_1", lcm_sym140__);
      current_statement__ = 61;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 62;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + max_age;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "copy_fail_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym136__;
      double lcm_sym135__;
      double lcm_sym134__;
      double lcm_sym133__;
      double lcm_sym132__;
      double lcm_sym131__;
      double lcm_sym130__;
      double lcm_sym129__;
      int lcm_sym128__;
      int lcm_sym127__;
      double lcm_sym126__;
      double lcm_sym125__;
      double lcm_sym124__;
      double lcm_sym123__;
      int lcm_sym122__;
      int lcm_sym121__;
      double lcm_sym120__;
      double lcm_sym119__;
      double lcm_sym118__;
      double lcm_sym117__;
      double lcm_sym116__;
      double lcm_sym115__;
      double lcm_sym114__;
      double lcm_sym113__;
      double lcm_sym112__;
      double lcm_sym111__;
      double lcm_sym110__;
      double lcm_sym109__;
      double lcm_sym108__;
      double lcm_sym107__;
      double lcm_sym106__;
      double lcm_sym105__;
      int lcm_sym104__;
      int lcm_sym103__;
      int lcm_sym102__;
      int lcm_sym101__;
      int lcm_sym100__;
      int lcm_sym99__;
      int lcm_sym98__;
      int lcm_sym97__;
      int lcm_sym96__;
      int lcm_sym95__;
      int lcm_sym94__;
      int lcm_sym93__;
      int lcm_sym92__;
      int lcm_sym91__;
      int lcm_sym90__;
      int lcm_sym89__;
      int lcm_sym88__;
      int lcm_sym87__;
      int lcm_sym86__;
      int lcm_sym85__;
      int lcm_sym84__;
      local_scalar_t__ mean_p;
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                 0, 1, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
               0, 1, lp__, max_age);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(p, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      lcm_sym85__ = logical_gte(nind, 1);
      if (lcm_sym85__) {
        lcm_sym122__ = rvalue(first, "first", index_uni(1));
        lcm_sym98__ = (lcm_sym122__ - 1);
        if (logical_gte(lcm_sym98__, 1)) {
          current_statement__ = 6;
          assign(phi, 0, "assigning variable phi", index_uni(1), index_uni(1));
          current_statement__ = 7;
          assign(p, 0, "assigning variable p", index_uni(1), index_uni(1));
          for (int t = 2; t <= lcm_sym98__; ++t) {
            current_statement__ = 6;
            assign(phi, 0,
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 7;
            assign(p, 0, "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        lcm_sym96__ = (n_occasions - 1);
        if (logical_gte(lcm_sym96__, lcm_sym122__)) {
          current_statement__ = 9;
          assign(phi,
            rvalue(beta, "beta",
              index_uni(rvalue(x, "x", index_uni(1), index_uni(lcm_sym122__)))),
            "assigning variable phi", index_uni(1), index_uni(lcm_sym122__));
          lcm_sym104__ = (lcm_sym122__ + 1);
          assign(p, mean_p,
            "assigning variable p", index_uni(1), index_uni(lcm_sym122__));
          for (int t = lcm_sym104__; t <= lcm_sym96__; ++t) {
            current_statement__ = 9;
            assign(phi,
              rvalue(beta, "beta",
                index_uni(rvalue(x, "x", index_uni(1), index_uni(t)))),
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 10;
            assign(p, mean_p,
              "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        for (int i = 2; i <= nind; ++i) {
          lcm_sym121__ = rvalue(first, "first", index_uni(i));
          lcm_sym97__ = (lcm_sym121__ - 1);
          if (logical_gte(lcm_sym97__, 1)) {
            current_statement__ = 6;
            assign(phi, 0,
              "assigning variable phi", index_uni(i), index_uni(1));
            current_statement__ = 7;
            assign(p, 0, "assigning variable p", index_uni(i), index_uni(1));
            for (int t = 2; t <= lcm_sym97__; ++t) {
              current_statement__ = 6;
              assign(phi, 0,
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 7;
              assign(p, 0, "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
          current_statement__ = 12;
          if (logical_gte(lcm_sym96__, lcm_sym121__)) {
            current_statement__ = 9;
            assign(phi,
              rvalue(beta, "beta",
                index_uni(rvalue(x, "x",
                            index_uni(i), index_uni(lcm_sym121__)))),
              "assigning variable phi", index_uni(i), index_uni(lcm_sym121__));
            lcm_sym103__ = (lcm_sym121__ + 1);
            assign(p, mean_p,
              "assigning variable p", index_uni(i), index_uni(lcm_sym121__));
            for (int t = lcm_sym103__; t <= lcm_sym96__; ++t) {
              current_statement__ = 9;
              assign(phi,
                rvalue(beta, "beta",
                  index_uni(rvalue(x, "x", index_uni(i), index_uni(t)))),
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 10;
              assign(p, mean_p,
                "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
        }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym9__;
      int inline_sym15__;
      inline_sym15__ = 0;
      for (int inline_sym16__ = 1; inline_sym16__ <= 1; ++inline_sym16__) {
        current_statement__ = 14;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym10__;
        inline_sym10__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        stan::math::fill(inline_sym10__, DUMMY_VAR__);
        
        for (int inline_sym14__ = 1; inline_sym14__ <= nind; ++inline_sym14__) {
          current_statement__ = 17;
          assign(inline_sym10__, 1.0,
            "assigning variable inline_sym10__", index_uni(inline_sym14__),
                                                   index_uni(n_occasions));
          lcm_sym96__ = (n_occasions - 1);
          if (logical_gte(lcm_sym96__, 1)) {
            int inline_sym11__;
            int inline_sym12__;
            lcm_sym100__ = (lcm_sym96__ + 1);
            current_statement__ = 20;
            assign(inline_sym10__,
              stan::math::fma(
                (rvalue(phi, "phi",
                   index_uni(inline_sym14__), index_uni(lcm_sym96__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(inline_sym14__),
                        index_uni((lcm_sym100__ - 1))))),
                rvalue(inline_sym10__, "inline_sym10__",
                  index_uni(inline_sym14__), index_uni(lcm_sym100__)),
                (1 -
                  rvalue(phi, "phi",
                    index_uni(inline_sym14__), index_uni(lcm_sym96__)))),
              "assigning variable inline_sym10__", index_uni(inline_sym14__),
                                                     index_uni(lcm_sym96__));
            for (int inline_sym13__ = 2; inline_sym13__ <= lcm_sym96__;
                 ++inline_sym13__) {
              int inline_sym11__;
              lcm_sym95__ = (n_occasions - inline_sym13__);
              int inline_sym12__;
              lcm_sym99__ = (lcm_sym95__ + 1);
              current_statement__ = 20;
              assign(inline_sym10__,
                stan::math::fma(
                  (rvalue(phi, "phi",
                     index_uni(inline_sym14__), index_uni(lcm_sym95__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(inline_sym14__),
                          index_uni((lcm_sym99__ - 1))))),
                  rvalue(inline_sym10__, "inline_sym10__",
                    index_uni(inline_sym14__), index_uni(lcm_sym99__)),
                  (1 -
                    rvalue(phi, "phi",
                      index_uni(inline_sym14__), index_uni(lcm_sym95__)))),
                "assigning variable inline_sym10__", index_uni(inline_sym14__),
                                                       index_uni(lcm_sym95__));
            }
          } 
          if (inline_sym15__) {
            break;
          } 
        }
        if (inline_sym15__) {
          break;
        } 
        inline_sym15__ = 1;
        assign(inline_sym9__, inline_sym10__,
          "assigning variable inline_sym9__");
        break;
      }
      assign(chi, inline_sym9__, "assigning variable chi");
      current_statement__ = 3;
      if (lcm_sym85__) {
        lcm_sym96__ = (n_occasions - 1);
        lcm_sym86__ = logical_gte(lcm_sym96__, 1);
        if (lcm_sym86__) {
          current_statement__ = 3;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi, "phi",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
            current_statement__ = 3;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym86__) {
            current_statement__ = 3;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
              current_statement__ = 3;
              check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                     rvalue(phi, "phi",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 3;
      if (lcm_sym85__) {
        lcm_sym96__ = (n_occasions - 1);
        lcm_sym86__ = logical_gte(lcm_sym96__, 1);
        if (lcm_sym86__) {
          current_statement__ = 3;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi, "phi", index_uni(1), index_uni(1)),
                              1);
          for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
            current_statement__ = 3;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym86__) {
            current_statement__ = 3;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
              current_statement__ = 3;
              check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                  rvalue(phi, "phi",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 4;
      if (lcm_sym85__) {
        lcm_sym96__ = (n_occasions - 1);
        lcm_sym86__ = logical_gte(lcm_sym96__, 1);
        if (lcm_sym86__) {
          current_statement__ = 4;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p, "p", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
            current_statement__ = 4;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym86__) {
            current_statement__ = 4;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
              current_statement__ = 4;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(p, "p",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 4;
      if (lcm_sym85__) {
        lcm_sym96__ = (n_occasions - 1);
        lcm_sym86__ = logical_gte(lcm_sym96__, 1);
        if (lcm_sym86__) {
          current_statement__ = 4;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p, "p", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
            current_statement__ = 4;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym86__) {
            current_statement__ = 4;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
              current_statement__ = 4;
              check_less_or_equal(function__, "p[sym1__, sym2__]",
                                  rvalue(p, "p",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym85__) {
        lcm_sym84__ = logical_gte(n_occasions, 1);
        if (lcm_sym84__) {
          current_statement__ = 5;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(inline_sym9__, "inline_sym9__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym9__, "inline_sym9__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym84__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym9__, "inline_sym9__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                     rvalue(inline_sym9__, "inline_sym9__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym85__) {
        lcm_sym84__ = logical_gte(n_occasions, 1);
        if (lcm_sym84__) {
          current_statement__ = 5;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(inline_sym9__, "inline_sym9__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym9__, "inline_sym9__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym84__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym9__, "inline_sym9__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                  rvalue(inline_sym9__, "inline_sym9__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      {
        current_statement__ = 30;
        if (lcm_sym85__) {
          lcm_sym122__ = rvalue(first, "first", index_uni(1));
          if (logical_gt(lcm_sym122__, 0)) {
            lcm_sym128__ = rvalue(last, "last", index_uni(1));
            if (logical_gte(lcm_sym128__, (lcm_sym122__ + 1))) {
              current_statement__ = 24;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(phi, "phi",
                    index_uni(1), index_uni(((lcm_sym122__ + 1) - 1)))));
              lcm_sym102__ = ((lcm_sym122__ + 1) + 1);
              lp_accum__.add(
                bernoulli_lpmf<propto__>(
                  rvalue(y, "y", index_uni(1), index_uni((lcm_sym122__ + 1))),
                  rvalue(p, "p",
                    index_uni(1), index_uni(((lcm_sym122__ + 1) - 1)))));
              for (int t = lcm_sym102__; t <= lcm_sym128__; ++t) {
                current_statement__ = 24;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(phi, "phi", index_uni(1), index_uni((t - 1)))));
                current_statement__ = 25;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(
                    rvalue(y, "y", index_uni(1), index_uni(t)),
                    rvalue(p, "p", index_uni(1), index_uni((t - 1)))));
              }
            } 
            current_statement__ = 27;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                rvalue(inline_sym9__, "inline_sym9__",
                  index_uni(1), index_uni(lcm_sym128__))));
          } 
          for (int i = 2; i <= nind; ++i) {
            lcm_sym121__ = rvalue(first, "first", index_uni(i));
            if (logical_gt(lcm_sym121__, 0)) {
              lcm_sym127__ = rvalue(last, "last", index_uni(i));
              if (logical_gte(lcm_sym127__, (lcm_sym121__ + 1))) {
                current_statement__ = 24;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(phi, "phi",
                      index_uni(i), index_uni(((lcm_sym121__ + 1) - 1)))));
                lcm_sym101__ = ((lcm_sym121__ + 1) + 1);
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(
                    rvalue(y, "y",
                      index_uni(i), index_uni((lcm_sym121__ + 1))),
                    rvalue(p, "p",
                      index_uni(i), index_uni(((lcm_sym121__ + 1) - 1)))));
                for (int t = lcm_sym101__; t <= lcm_sym127__; ++t) {
                  current_statement__ = 24;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(1,
                      rvalue(phi, "phi", index_uni(i), index_uni((t - 1)))));
                  current_statement__ = 25;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(
                      rvalue(y, "y", index_uni(i), index_uni(t)),
                      rvalue(p, "p", index_uni(i), index_uni((t - 1)))));
                }
              } 
              current_statement__ = 27;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(inline_sym9__, "inline_sym9__",
                    index_uni(i), index_uni(lcm_sym127__))));
            } 
          }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "copy_fail_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym83__;
      double lcm_sym82__;
      double lcm_sym81__;
      double lcm_sym80__;
      double lcm_sym79__;
      double lcm_sym78__;
      double lcm_sym77__;
      double lcm_sym76__;
      double lcm_sym75__;
      double lcm_sym74__;
      double lcm_sym73__;
      double lcm_sym72__;
      int lcm_sym71__;
      int lcm_sym70__;
      double lcm_sym69__;
      double lcm_sym68__;
      double lcm_sym67__;
      double lcm_sym66__;
      double lcm_sym65__;
      double lcm_sym64__;
      int lcm_sym63__;
      int lcm_sym62__;
      int lcm_sym61__;
      int lcm_sym60__;
      int lcm_sym59__;
      int lcm_sym58__;
      int lcm_sym57__;
      int lcm_sym56__;
      int lcm_sym55__;
      int lcm_sym54__;
      int lcm_sym53__;
      int lcm_sym52__;
      int lcm_sym51__;
      int lcm_sym50__;
      int lcm_sym49__;
      int lcm_sym48__;
      int lcm_sym47__;
      double mean_p;
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                 0, 1, lp__);
      Eigen::Matrix<double, -1, 1> beta;
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
               0, 1, lp__, max_age);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(p, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      out__.write(mean_p);
      out__.write(beta);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym48__ = logical_gte(nind, 1);
      if (lcm_sym48__) {
        lcm_sym71__ = rvalue(first, "first", index_uni(1));
        lcm_sym57__ = (lcm_sym71__ - 1);
        if (logical_gte(lcm_sym57__, 1)) {
          current_statement__ = 6;
          assign(phi, 0, "assigning variable phi", index_uni(1), index_uni(1));
          current_statement__ = 7;
          assign(p, 0, "assigning variable p", index_uni(1), index_uni(1));
          for (int t = 2; t <= lcm_sym57__; ++t) {
            current_statement__ = 6;
            assign(phi, 0,
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 7;
            assign(p, 0, "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        lcm_sym55__ = (n_occasions - 1);
        if (logical_gte(lcm_sym55__, lcm_sym71__)) {
          current_statement__ = 9;
          assign(phi,
            rvalue(beta, "beta",
              index_uni(rvalue(x, "x", index_uni(1), index_uni(lcm_sym71__)))),
            "assigning variable phi", index_uni(1), index_uni(lcm_sym71__));
          lcm_sym63__ = (lcm_sym71__ + 1);
          assign(p, mean_p,
            "assigning variable p", index_uni(1), index_uni(lcm_sym71__));
          for (int t = lcm_sym63__; t <= lcm_sym55__; ++t) {
            current_statement__ = 9;
            assign(phi,
              rvalue(beta, "beta",
                index_uni(rvalue(x, "x", index_uni(1), index_uni(t)))),
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 10;
            assign(p, mean_p,
              "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        for (int i = 2; i <= nind; ++i) {
          lcm_sym70__ = rvalue(first, "first", index_uni(i));
          lcm_sym56__ = (lcm_sym70__ - 1);
          if (logical_gte(lcm_sym56__, 1)) {
            current_statement__ = 6;
            assign(phi, 0,
              "assigning variable phi", index_uni(i), index_uni(1));
            current_statement__ = 7;
            assign(p, 0, "assigning variable p", index_uni(i), index_uni(1));
            for (int t = 2; t <= lcm_sym56__; ++t) {
              current_statement__ = 6;
              assign(phi, 0,
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 7;
              assign(p, 0, "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
          current_statement__ = 12;
          if (logical_gte(lcm_sym55__, lcm_sym70__)) {
            current_statement__ = 9;
            assign(phi,
              rvalue(beta, "beta",
                index_uni(rvalue(x, "x",
                            index_uni(i), index_uni(lcm_sym70__)))),
              "assigning variable phi", index_uni(i), index_uni(lcm_sym70__));
            lcm_sym62__ = (lcm_sym70__ + 1);
            assign(p, mean_p,
              "assigning variable p", index_uni(i), index_uni(lcm_sym70__));
            for (int t = lcm_sym62__; t <= lcm_sym55__; ++t) {
              current_statement__ = 9;
              assign(phi,
                rvalue(beta, "beta",
                  index_uni(rvalue(x, "x", index_uni(i), index_uni(t)))),
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 10;
              assign(p, mean_p,
                "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
        }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym1__;
      int inline_sym7__;
      inline_sym7__ = 0;
      for (int inline_sym8__ = 1; inline_sym8__ <= 1; ++inline_sym8__) {
        current_statement__ = 14;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym2__;
        inline_sym2__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        stan::math::fill(inline_sym2__, DUMMY_VAR__);
        
        for (int inline_sym6__ = 1; inline_sym6__ <= nind; ++inline_sym6__) {
          current_statement__ = 17;
          assign(inline_sym2__, 1.0,
            "assigning variable inline_sym2__", index_uni(inline_sym6__),
                                                  index_uni(n_occasions));
          lcm_sym55__ = (n_occasions - 1);
          if (logical_gte(lcm_sym55__, 1)) {
            int inline_sym3__;
            int inline_sym4__;
            lcm_sym61__ = (lcm_sym55__ + 1);
            current_statement__ = 20;
            assign(inline_sym2__,
              stan::math::fma(
                (rvalue(phi, "phi",
                   index_uni(inline_sym6__), index_uni(lcm_sym55__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(inline_sym6__), index_uni((lcm_sym61__ - 1))))),
                rvalue(inline_sym2__, "inline_sym2__",
                  index_uni(inline_sym6__), index_uni(lcm_sym61__)),
                (1 -
                  rvalue(phi, "phi",
                    index_uni(inline_sym6__), index_uni(lcm_sym55__)))),
              "assigning variable inline_sym2__", index_uni(inline_sym6__),
                                                    index_uni(lcm_sym55__));
            for (int inline_sym5__ = 2; inline_sym5__ <= lcm_sym55__;
                 ++inline_sym5__) {
              int inline_sym3__;
              lcm_sym54__ = (n_occasions - inline_sym5__);
              int inline_sym4__;
              lcm_sym60__ = (lcm_sym54__ + 1);
              current_statement__ = 20;
              assign(inline_sym2__,
                stan::math::fma(
                  (rvalue(phi, "phi",
                     index_uni(inline_sym6__), index_uni(lcm_sym54__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(inline_sym6__),
                          index_uni((lcm_sym60__ - 1))))),
                  rvalue(inline_sym2__, "inline_sym2__",
                    index_uni(inline_sym6__), index_uni(lcm_sym60__)),
                  (1 -
                    rvalue(phi, "phi",
                      index_uni(inline_sym6__), index_uni(lcm_sym54__)))),
                "assigning variable inline_sym2__", index_uni(inline_sym6__),
                                                      index_uni(lcm_sym54__));
            }
          } 
          if (inline_sym7__) {
            break;
          } 
        }
        if (inline_sym7__) {
          break;
        } 
        inline_sym7__ = 1;
        assign(inline_sym1__, inline_sym2__,
          "assigning variable inline_sym1__");
        break;
      }
      assign(chi, inline_sym1__, "assigning variable chi");
      current_statement__ = 3;
      if (lcm_sym48__) {
        lcm_sym55__ = (n_occasions - 1);
        lcm_sym49__ = logical_gte(lcm_sym55__, 1);
        if (lcm_sym49__) {
          current_statement__ = 3;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi, "phi",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
            current_statement__ = 3;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym49__) {
            current_statement__ = 3;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
              current_statement__ = 3;
              check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                     rvalue(phi, "phi",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 3;
      if (lcm_sym48__) {
        lcm_sym55__ = (n_occasions - 1);
        lcm_sym49__ = logical_gte(lcm_sym55__, 1);
        if (lcm_sym49__) {
          current_statement__ = 3;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi, "phi", index_uni(1), index_uni(1)),
                              1);
          for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
            current_statement__ = 3;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym49__) {
            current_statement__ = 3;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
              current_statement__ = 3;
              check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                  rvalue(phi, "phi",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 4;
      if (lcm_sym48__) {
        lcm_sym55__ = (n_occasions - 1);
        lcm_sym49__ = logical_gte(lcm_sym55__, 1);
        if (lcm_sym49__) {
          current_statement__ = 4;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p, "p", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
            current_statement__ = 4;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym49__) {
            current_statement__ = 4;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
              current_statement__ = 4;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(p, "p",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 4;
      if (lcm_sym48__) {
        lcm_sym55__ = (n_occasions - 1);
        lcm_sym49__ = logical_gte(lcm_sym55__, 1);
        if (lcm_sym49__) {
          current_statement__ = 4;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p, "p", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
            current_statement__ = 4;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym49__) {
            current_statement__ = 4;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
              current_statement__ = 4;
              check_less_or_equal(function__, "p[sym1__, sym2__]",
                                  rvalue(p, "p",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym48__) {
        lcm_sym47__ = logical_gte(n_occasions, 1);
        if (lcm_sym47__) {
          current_statement__ = 5;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(inline_sym1__, "inline_sym1__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym1__, "inline_sym1__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym47__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym1__, "inline_sym1__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                     rvalue(inline_sym1__, "inline_sym1__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym48__) {
        lcm_sym47__ = logical_gte(n_occasions, 1);
        if (lcm_sym47__) {
          current_statement__ = 5;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(inline_sym1__, "inline_sym1__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym1__, "inline_sym1__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym47__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym1__, "inline_sym1__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                  rvalue(inline_sym1__, "inline_sym1__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(inline_sym1__);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym46__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ mean_p;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(max_age);
      stan::math::fill(beta, DUMMY_VAR__);
      
      if (logical_gte(max_age, 1)) {
        assign(beta, in__.read<local_scalar_t__>(),
          "assigning variable beta", index_uni(1));
        for (int sym1__ = 2; sym1__ <= max_age; ++sym1__) {
          assign(beta, in__.read<local_scalar_t__>(),
            "assigning variable beta", index_uni(sym1__));
        }
      } 
      out__.write_free_lub(0, 1, beta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mean_p", "beta", "phi", "p", "chi"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(max_age)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occasions)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym168__ = 1; sym168__ <= max_age; ++sym168__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym168__));
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym168__ = 1; sym168__ <= n_occ_minus_1; ++sym168__) {
        {
          for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym169__) + '.' + std::to_string(sym168__));
            } 
          }
        } 
      }
      for (int sym168__ = 1; sym168__ <= n_occ_minus_1; ++sym168__) {
        {
          for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym169__) + '.' + std::to_string(sym168__));
            } 
          }
        } 
      }
      for (int sym168__ = 1; sym168__ <= n_occasions; ++sym168__) {
        {
          for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym169__) + '.' + std::to_string(sym168__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym168__ = 1; sym168__ <= max_age; ++sym168__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym168__));
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym168__ = 1; sym168__ <= n_occ_minus_1; ++sym168__) {
        {
          for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym169__) + '.' + std::to_string(sym168__));
            } 
          }
        } 
      }
      for (int sym168__ = 1; sym168__ <= n_occ_minus_1; ++sym168__) {
        {
          for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym169__) + '.' + std::to_string(sym168__));
            } 
          }
        } 
      }
      for (int sym168__ = 1; sym168__ <= n_occasions; ++sym168__) {
        {
          for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym169__) + '.' + std::to_string(sym168__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(max_age) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(max_age) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + max_age);
      const size_t num_transformed = (((nind *
                                                          n_occ_minus_1) +
                                                         (nind *
                                                           n_occ_minus_1)) +
                                                        (nind * n_occasions));
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + max_age);
      const size_t num_transformed = (((nind *
                                                          n_occ_minus_1) +
                                                         (nind *
                                                           n_occ_minus_1)) +
                                                        (nind * n_occasions));
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"mean_p", "beta"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{1, max_age};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = copy_fail_model_namespace::copy_fail_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return copy_fail_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp dce-fail.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace dce_fail_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 66> locations_array__ = 
{" (found before start of program)",
 " (in 'dce-fail.stan', line 18, column 2 to column 22)",
 " (in 'dce-fail.stan', line 19, column 2 to column 26)",
 " (in 'dce-fail.stan', line 20, column 2 to column 26)",
 " (in 'dce-fail.stan', line 21, column 2 to column 28)",
 " (in 'dce-fail.stan', line 22, column 2 to column 29)",
 " (in 'dce-fail.stan', line 23, column 2 to column 30)",
 " (in 'dce-fail.stan', line 25, column 2 to column 11)",
 " (in 'dce-fail.stan', line 26, column 2 to column 16)",
 " (in 'dce-fail.stan', line 27, column 2 to column 15)",
 " (in 'dce-fail.stan', line 28, column 2 to column 22)",
 " (in 'dce-fail.stan', line 30, column 2 to column 16)",
 " (in 'dce-fail.stan', line 32, column 2 to column 22)",
 " (in 'dce-fail.stan', line 33, column 2 to column 22)",
 " (in 'dce-fail.stan', line 34, column 2 to column 28)",
 " (in 'dce-fail.stan', line 35, column 2 to column 32)",
 " (in 'dce-fail.stan', line 37, column 2 to column 24)",
 " (in 'dce-fail.stan', line 40, column 9 to column 10)",
 " (in 'dce-fail.stan', line 40, column 2 to column 14)",
 " (in 'dce-fail.stan', line 41, column 9 to column 16)",
 " (in 'dce-fail.stan', line 41, column 2 to column 30)",
 " (in 'dce-fail.stan', line 43, column 2 to column 23)",
 " (in 'dce-fail.stan', line 44, column 2 to column 28)",
 " (in 'dce-fail.stan', line 45, column 2 to column 27)",
 " (in 'dce-fail.stan', line 46, column 2 to column 34)",
 " (in 'dce-fail.stan', line 48, column 2 to column 31)",
 " (in 'dce-fail.stan', line 49, column 2 to column 31)",
 " (in 'dce-fail.stan', line 50, column 2 to column 37)",
 " (in 'dce-fail.stan', line 54, column 6 to column 48)",
 " (in 'dce-fail.stan', line 53, column 4 to line 54, column 48)",
 " (in 'dce-fail.stan', line 52, column 21 to line 55, column 3)",
 " (in 'dce-fail.stan', line 52, column 2 to line 55, column 3)",
 " (in 'dce-fail.stan', line 57, column 2 to column 28)",
 " (in 'dce-fail.stan', line 60, column 4 to column 64)",
 " (in 'dce-fail.stan', line 59, column 2 to line 60, column 64)",
 " (in 'dce-fail.stan', line 62, column 2 to column 43)",
 " (in 'dce-fail.stan', line 65, column 4 to line 68, column 25)",
 " (in 'dce-fail.stan', line 64, column 2 to line 68, column 25)",
 " (in 'dce-fail.stan', line 70, column 2 to column 19)",
 " (in 'dce-fail.stan', line 2, column 2 to column 17)",
 " (in 'dce-fail.stan', line 3, column 2 to column 21)",
 " (in 'dce-fail.stan', line 4, column 2 to column 21)",
 " (in 'dce-fail.stan', line 5, column 2 to column 24)",
 " (in 'dce-fail.stan', line 6, column 2 to column 23)",
 " (in 'dce-fail.stan', line 8, column 31 to column 32)",
 " (in 'dce-fail.stan', line 8, column 2 to column 34)",
 " (in 'dce-fail.stan', line 9, column 30 to column 31)",
 " (in 'dce-fail.stan', line 9, column 2 to column 33)",
 " (in 'dce-fail.stan', line 10, column 32 to column 33)",
 " (in 'dce-fail.stan', line 10, column 2 to column 35)",
 " (in 'dce-fail.stan', line 11, column 32 to column 33)",
 " (in 'dce-fail.stan', line 11, column 2 to column 35)",
 " (in 'dce-fail.stan', line 12, column 37 to column 44)",
 " (in 'dce-fail.stan', line 12, column 2 to column 46)",
 " (in 'dce-fail.stan', line 13, column 36 to column 37)",
 " (in 'dce-fail.stan', line 13, column 2 to column 39)",
 " (in 'dce-fail.stan', line 14, column 26 to column 27)",
 " (in 'dce-fail.stan', line 14, column 2 to column 29)",
 " (in 'dce-fail.stan', line 15, column 9 to column 16)",
 " (in 'dce-fail.stan', line 15, column 2 to column 25)",
 " (in 'dce-fail.stan', line 32, column 9 to column 14)",
 " (in 'dce-fail.stan', line 33, column 9 to column 14)",
 " (in 'dce-fail.stan', line 34, column 9 to column 17)",
 " (in 'dce-fail.stan', line 35, column 9 to column 14)",
 " (in 'dce-fail.stan', line 35, column 15 to column 20)",
 " (in 'dce-fail.stan', line 37, column 9 to column 16)"};



class dce_fail_model final : public model_base_crtp<dce_fail_model> {

 private:
  int lcm_sym47__;
  int lcm_sym46__;
  double lcm_sym45__;
  double lcm_sym44__;
  int lcm_sym43__;
  int lcm_sym42__;
  int lcm_sym41__;
  int lcm_sym40__;
  int lcm_sym39__;
  int lcm_sym38__;
  int lcm_sym37__;
  int lcm_sym36__;
  int lcm_sym35__;
  int lcm_sym34__;
  int lcm_sym33__;
  int lcm_sym32__;
  int lcm_sym31__;
  int lcm_sym30__;
  int lcm_sym29__;
  int N;
  int n_age;
  int n_edu;
  int n_region;
  int n_state;
  std::vector<int> female;
  std::vector<int> black;
  std::vector<int> age;
  std::vector<int> edu;
  std::vector<int> region;
  std::vector<int> state;
  std::vector<int> y;
  Eigen::Matrix<double, -1, 1> v_prev__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> v_prev{nullptr, 0};
 
 public:
  ~dce_fail_model() { }
  
  inline std::string model_name() const final { return "dce_fail_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  dce_fail_model(stan::io::var_context& context__,
                 unsigned int random_seed__ = 0,
                 std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "dce_fail_model_namespace::dce_fail_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 39;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 39;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 39;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 40;
      context__.validate_dims("data initialization","n_age","int",
           std::vector<size_t>{});
      n_age = std::numeric_limits<int>::min();
      
      current_statement__ = 40;
      n_age = context__.vals_i("n_age")[(1 - 1)];
      current_statement__ = 40;
      check_greater_or_equal(function__, "n_age", n_age, 0);
      current_statement__ = 41;
      context__.validate_dims("data initialization","n_edu","int",
           std::vector<size_t>{});
      n_edu = std::numeric_limits<int>::min();
      
      current_statement__ = 41;
      n_edu = context__.vals_i("n_edu")[(1 - 1)];
      current_statement__ = 41;
      check_greater_or_equal(function__, "n_edu", n_edu, 0);
      current_statement__ = 42;
      context__.validate_dims("data initialization","n_region","int",
           std::vector<size_t>{});
      n_region = std::numeric_limits<int>::min();
      
      current_statement__ = 42;
      n_region = context__.vals_i("n_region")[(1 - 1)];
      current_statement__ = 42;
      check_greater_or_equal(function__, "n_region", n_region, 0);
      current_statement__ = 43;
      context__.validate_dims("data initialization","n_state","int",
           std::vector<size_t>{});
      n_state = std::numeric_limits<int>::min();
      
      current_statement__ = 43;
      n_state = context__.vals_i("n_state")[(1 - 1)];
      current_statement__ = 43;
      check_greater_or_equal(function__, "n_state", n_state, 0);
      current_statement__ = 44;
      validate_non_negative_index("female", "N", N);
      current_statement__ = 45;
      context__.validate_dims("data initialization","female","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      female = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 45;
      female = context__.vals_i("female");
      lcm_sym29__ = logical_gte(N, 1);
      if (lcm_sym29__) {
        current_statement__ = 45;
        check_greater_or_equal(function__, "female[sym1__]",
                               rvalue(female, "female", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 45;
          check_greater_or_equal(function__, "female[sym1__]",
                                 female[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 45;
      if (lcm_sym29__) {
        current_statement__ = 45;
        check_less_or_equal(function__, "female[sym1__]",
                            rvalue(female, "female", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 45;
          check_less_or_equal(function__, "female[sym1__]",
                              female[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 46;
      validate_non_negative_index("black", "N", N);
      current_statement__ = 47;
      context__.validate_dims("data initialization","black","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      black = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 47;
      black = context__.vals_i("black");
      current_statement__ = 47;
      if (lcm_sym29__) {
        current_statement__ = 47;
        check_greater_or_equal(function__, "black[sym1__]",
                               rvalue(black, "black", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 47;
          check_greater_or_equal(function__, "black[sym1__]",
                                 black[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 47;
      if (lcm_sym29__) {
        current_statement__ = 47;
        check_less_or_equal(function__, "black[sym1__]",
                            rvalue(black, "black", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 47;
          check_less_or_equal(function__, "black[sym1__]",
                              black[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 48;
      validate_non_negative_index("age", "N", N);
      current_statement__ = 49;
      context__.validate_dims("data initialization","age","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      age = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 49;
      age = context__.vals_i("age");
      current_statement__ = 49;
      if (lcm_sym29__) {
        current_statement__ = 49;
        check_greater_or_equal(function__, "age[sym1__]",
                               rvalue(age, "age", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 49;
          check_greater_or_equal(function__, "age[sym1__]",
                                 age[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 49;
      if (lcm_sym29__) {
        current_statement__ = 49;
        check_less_or_equal(function__, "age[sym1__]",
                            rvalue(age, "age", index_uni(1)), n_age);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 49;
          check_less_or_equal(function__, "age[sym1__]", age[(sym1__ - 1)],
                              n_age);
        }
      } 
      current_statement__ = 50;
      validate_non_negative_index("edu", "N", N);
      current_statement__ = 51;
      context__.validate_dims("data initialization","edu","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      edu = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 51;
      edu = context__.vals_i("edu");
      current_statement__ = 51;
      if (lcm_sym29__) {
        current_statement__ = 51;
        check_greater_or_equal(function__, "edu[sym1__]",
                               rvalue(edu, "edu", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 51;
          check_greater_or_equal(function__, "edu[sym1__]",
                                 edu[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 51;
      if (lcm_sym29__) {
        current_statement__ = 51;
        check_less_or_equal(function__, "edu[sym1__]",
                            rvalue(edu, "edu", index_uni(1)), n_edu);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 51;
          check_less_or_equal(function__, "edu[sym1__]", edu[(sym1__ - 1)],
                              n_edu);
        }
      } 
      current_statement__ = 52;
      validate_non_negative_index("region", "n_state", n_state);
      current_statement__ = 53;
      context__.validate_dims("data initialization","region","int",
           std::vector<size_t>{static_cast<size_t>(n_state)});
      region = std::vector<int>(n_state, std::numeric_limits<int>::min());
      
      current_statement__ = 53;
      region = context__.vals_i("region");
      lcm_sym30__ = logical_gte(n_state, 1);
      if (lcm_sym30__) {
        current_statement__ = 53;
        check_greater_or_equal(function__, "region[sym1__]",
                               rvalue(region, "region", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= n_state; ++sym1__) {
          current_statement__ = 53;
          check_greater_or_equal(function__, "region[sym1__]",
                                 region[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 53;
      if (lcm_sym30__) {
        current_statement__ = 53;
        check_less_or_equal(function__, "region[sym1__]",
                            rvalue(region, "region", index_uni(1)), n_state);
        for (int sym1__ = 2; sym1__ <= n_state; ++sym1__) {
          current_statement__ = 53;
          check_less_or_equal(function__, "region[sym1__]",
                              region[(sym1__ - 1)], n_state);
        }
      } 
      current_statement__ = 54;
      validate_non_negative_index("state", "N", N);
      current_statement__ = 55;
      context__.validate_dims("data initialization","state","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      state = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 55;
      state = context__.vals_i("state");
      current_statement__ = 55;
      if (lcm_sym29__) {
        current_statement__ = 55;
        check_greater_or_equal(function__, "state[sym1__]",
                               rvalue(state, "state", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 55;
          check_greater_or_equal(function__, "state[sym1__]",
                                 state[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 55;
      if (lcm_sym29__) {
        current_statement__ = 55;
        check_less_or_equal(function__, "state[sym1__]",
                            rvalue(state, "state", index_uni(1)), n_state);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 55;
          check_less_or_equal(function__, "state[sym1__]",
                              state[(sym1__ - 1)], n_state);
        }
      } 
      current_statement__ = 56;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 57;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 57;
      y = context__.vals_i("y");
      current_statement__ = 57;
      if (lcm_sym29__) {
        current_statement__ = 57;
        check_greater_or_equal(function__, "y[sym1__]",
                               rvalue(y, "y", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 57;
          check_greater_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 57;
      if (lcm_sym29__) {
        current_statement__ = 57;
        check_less_or_equal(function__, "y[sym1__]",
                            rvalue(y, "y", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 57;
          check_less_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 58;
      validate_non_negative_index("v_prev", "n_state", n_state);
      current_statement__ = 59;
      context__.validate_dims("data initialization","v_prev","double",
           std::vector<size_t>{static_cast<size_t>(n_state)});
      v_prev__ = Eigen::Matrix<double, -1, 1>(n_state);
      new (&v_prev) Eigen::Map<Eigen::Matrix<double, -1, 1>>(v_prev__.data(), n_state);
      
      
      {
        std::vector<double> v_prev_flat__;
        current_statement__ = 59;
        v_prev_flat__ = context__.vals_r("v_prev");
        current_statement__ = 59;
        pos__ = 1;
        current_statement__ = 59;
        if (lcm_sym30__) {
          current_statement__ = 59;
          assign(v_prev,
            rvalue(v_prev_flat__, "v_prev_flat__", index_uni(1)),
            "assigning variable v_prev", index_uni(1));
          current_statement__ = 59;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_state; ++sym1__) {
            current_statement__ = 59;
            assign(v_prev, v_prev_flat__[(pos__ - 1)],
              "assigning variable v_prev", index_uni(sym1__));
            current_statement__ = 59;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 60;
      validate_non_negative_index("b_age", "n_age", n_age);
      current_statement__ = 61;
      validate_non_negative_index("b_edu", "n_edu", n_edu);
      current_statement__ = 62;
      validate_non_negative_index("b_region", "n_region", n_region);
      current_statement__ = 63;
      validate_non_negative_index("b_age_edu", "n_age", n_age);
      current_statement__ = 64;
      validate_non_negative_index("b_age_edu", "n_edu", n_edu);
      current_statement__ = 65;
      validate_non_negative_index("b_hat", "n_state", n_state);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + n_age
       + n_edu + n_region + (n_age * n_edu) + n_state;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "dce_fail_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      double lcm_sym12__;
      double lcm_sym11__;
      int lcm_sym10__;
      int lcm_sym9__;
      int lcm_sym8__;
      int lcm_sym7__;
      local_scalar_t__ sigma;
      current_statement__ = 1;
      sigma = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                0, lp__);
      local_scalar_t__ sigma_age;
      current_statement__ = 2;
      sigma_age = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                    0, lp__);
      local_scalar_t__ sigma_edu;
      current_statement__ = 3;
      sigma_edu = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                    0, lp__);
      local_scalar_t__ sigma_state;
      current_statement__ = 4;
      sigma_state = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                      0, lp__);
      local_scalar_t__ sigma_region;
      current_statement__ = 5;
      sigma_region = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                       0, lp__);
      local_scalar_t__ sigma_age_edu;
      current_statement__ = 6;
      sigma_age_edu = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                        0, lp__);
      local_scalar_t__ b_0;
      current_statement__ = 7;
      b_0 = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_female;
      current_statement__ = 8;
      b_female = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_black;
      current_statement__ = 9;
      b_black = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_female_black;
      current_statement__ = 10;
      b_female_black = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_v_prev;
      current_statement__ = 11;
      b_v_prev = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__, -1, 1> b_age;
      current_statement__ = 12;
      b_age = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                n_age);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_edu;
      current_statement__ = 13;
      b_edu = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                n_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_region;
      current_statement__ = 14;
      b_region = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                   n_region);
      Eigen::Matrix<local_scalar_t__, -1, -1> b_age_edu;
      current_statement__ = 15;
      b_age_edu = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                    n_age, n_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_hat;
      current_statement__ = 16;
      b_hat = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                n_state);
      {
        current_statement__ = 17;
        validate_non_negative_index("p", "N", N);
        Eigen::Matrix<local_scalar_t__, -1, 1> p;
        p = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
        stan::math::fill(p, DUMMY_VAR__);
        
        current_statement__ = 19;
        validate_non_negative_index("b_state_hat", "n_state", n_state);
        Eigen::Matrix<local_scalar_t__, -1, 1> b_state_hat;
        b_state_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(n_state);
        stan::math::fill(b_state_hat, DUMMY_VAR__);
        
        current_statement__ = 21;
        lp_accum__.add(normal_lpdf<propto__>(b_0, 0, 100));
        current_statement__ = 22;
        lp_accum__.add(normal_lpdf<propto__>(b_female, 0, 100));
        current_statement__ = 23;
        lp_accum__.add(normal_lpdf<propto__>(b_black, 0, 100));
        current_statement__ = 24;
        lp_accum__.add(normal_lpdf<propto__>(b_female_black, 0, 100));
        current_statement__ = 25;
        lp_accum__.add(normal_lpdf<propto__>(b_age, 0, sigma_age));
        current_statement__ = 26;
        lp_accum__.add(normal_lpdf<propto__>(b_edu, 0, sigma_edu));
        current_statement__ = 27;
        lp_accum__.add(normal_lpdf<propto__>(b_region, 0, sigma_region));
        current_statement__ = 31;
        if (logical_gte(n_age, 1)) {
          lcm_sym9__ = logical_gte(n_edu, 1);
          if (lcm_sym9__) {
            current_statement__ = 28;
            lp_accum__.add(
              normal_lpdf<propto__>(
                rvalue(b_age_edu, "b_age_edu", index_uni(1), index_uni(1)),
                0, sigma_age_edu));
            for (int i = 2; i <= n_edu; ++i) {
              current_statement__ = 28;
              lp_accum__.add(
                normal_lpdf<propto__>(
                  rvalue(b_age_edu, "b_age_edu", index_uni(1), index_uni(i)),
                  0, sigma_age_edu));
            }
          } 
          for (int j = 2; j <= n_age; ++j) {
            current_statement__ = 29;
            if (lcm_sym9__) {
              current_statement__ = 28;
              lp_accum__.add(
                normal_lpdf<propto__>(
                  rvalue(b_age_edu, "b_age_edu", index_uni(j), index_uni(1)),
                  0, sigma_age_edu));
              for (int i = 2; i <= n_edu; ++i) {
                current_statement__ = 28;
                lp_accum__.add(
                  normal_lpdf<propto__>(
                    rvalue(b_age_edu, "b_age_edu",
                      index_uni(j), index_uni(i)), 0, sigma_age_edu));
              }
            } 
          }
        } 
        current_statement__ = 32;
        lp_accum__.add(normal_lpdf<propto__>(b_v_prev, 0, 100));
        current_statement__ = 34;
        if (logical_gte(n_state, 1)) {
          current_statement__ = 33;
          assign(b_state_hat,
            stan::math::fma(b_v_prev, rvalue(v_prev, "v_prev", index_uni(1)),
              rvalue(b_region, "b_region",
                index_uni(rvalue(region, "region", index_uni(1))))),
            "assigning variable b_state_hat", index_uni(1));
          for (int j = 2; j <= n_state; ++j) {
            current_statement__ = 33;
            assign(b_state_hat,
              stan::math::fma(b_v_prev,
                rvalue(v_prev, "v_prev", index_uni(j)),
                rvalue(b_region, "b_region",
                  index_uni(rvalue(region, "region", index_uni(j))))),
              "assigning variable b_state_hat", index_uni(j));
          }
        } 
        current_statement__ = 35;
        lp_accum__.add(normal_lpdf<propto__>(b_hat, b_state_hat, sigma_state));
        current_statement__ = 37;
        if (logical_gte(N, 1)) {
          current_statement__ = 36;
          assign(p,
            stan::math::fmax(0,
              stan::math::fmin(1,
                inv_logit(
                  ((((stan::math::fma(
                        (b_female_black *
                          rvalue(female, "female", index_uni(1))),
                        rvalue(black, "black", index_uni(1)),
                        stan::math::fma(b_black,
                          rvalue(black, "black", index_uni(1)),
                          stan::math::fma(b_female,
                            rvalue(female, "female", index_uni(1)), b_0))) +
                       rvalue(b_age, "b_age",
                         index_uni(rvalue(age, "age", index_uni(1))))) +
                      rvalue(b_edu, "b_edu",
                        index_uni(rvalue(edu, "edu", index_uni(1))))) +
                     rvalue(b_age_edu, "b_age_edu",
                       index_uni(rvalue(age, "age", index_uni(1))),
                         index_uni(rvalue(edu, "edu", index_uni(1))))) +
                    rvalue(b_hat, "b_hat",
                      index_uni(rvalue(state, "state", index_uni(1)))))))),
            "assigning variable p", index_uni(1));
          for (int i = 2; i <= N; ++i) {
            current_statement__ = 36;
            assign(p,
              stan::math::fmax(0,
                stan::math::fmin(1,
                  inv_logit(
                    ((((stan::math::fma(
                          (b_female_black *
                            rvalue(female, "female", index_uni(i))),
                          rvalue(black, "black", index_uni(i)),
                          stan::math::fma(b_black,
                            rvalue(black, "black", index_uni(i)),
                            stan::math::fma(b_female,
                              rvalue(female, "female", index_uni(i)), b_0)))
                         +
                         rvalue(b_age, "b_age",
                           index_uni(rvalue(age, "age", index_uni(i))))) +
                        rvalue(b_edu, "b_edu",
                          index_uni(rvalue(edu, "edu", index_uni(i))))) +
                       rvalue(b_age_edu, "b_age_edu",
                         index_uni(rvalue(age, "age", index_uni(i))),
                           index_uni(rvalue(edu, "edu", index_uni(i))))) +
                      rvalue(b_hat, "b_hat",
                        index_uni(rvalue(state, "state", index_uni(i)))))))),
              "assigning variable p", index_uni(i));
          }
        } 
        current_statement__ = 38;
        lp_accum__.add(bernoulli_lpmf<propto__>(y, p));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "dce_fail_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym6__;
      int lcm_sym5__;
      double sigma;
      current_statement__ = 1;
      sigma = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                0, lp__);
      double sigma_age;
      current_statement__ = 2;
      sigma_age = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                    0, lp__);
      double sigma_edu;
      current_statement__ = 3;
      sigma_edu = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                    0, lp__);
      double sigma_state;
      current_statement__ = 4;
      sigma_state = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                      0, lp__);
      double sigma_region;
      current_statement__ = 5;
      sigma_region = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                       0, lp__);
      double sigma_age_edu;
      current_statement__ = 6;
      sigma_age_edu = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                        0, lp__);
      double b_0;
      current_statement__ = 7;
      b_0 = in__.template read<local_scalar_t__>();
      double b_female;
      current_statement__ = 8;
      b_female = in__.template read<local_scalar_t__>();
      double b_black;
      current_statement__ = 9;
      b_black = in__.template read<local_scalar_t__>();
      double b_female_black;
      current_statement__ = 10;
      b_female_black = in__.template read<local_scalar_t__>();
      double b_v_prev;
      current_statement__ = 11;
      b_v_prev = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, 1> b_age;
      current_statement__ = 12;
      b_age = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                n_age);
      Eigen::Matrix<double, -1, 1> b_edu;
      current_statement__ = 13;
      b_edu = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                n_edu);
      Eigen::Matrix<double, -1, 1> b_region;
      current_statement__ = 14;
      b_region = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                   n_region);
      Eigen::Matrix<double, -1, -1> b_age_edu;
      current_statement__ = 15;
      b_age_edu = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                    n_age, n_edu);
      Eigen::Matrix<double, -1, 1> b_hat;
      current_statement__ = 16;
      b_hat = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                n_state);
      out__.write(sigma);
      out__.write(sigma_age);
      out__.write(sigma_edu);
      out__.write(sigma_state);
      out__.write(sigma_region);
      out__.write(sigma_age_edu);
      out__.write(b_0);
      out__.write(b_female);
      out__.write(b_black);
      out__.write(b_female_black);
      out__.write(b_v_prev);
      out__.write(b_age);
      out__.write(b_edu);
      out__.write(b_region);
      out__.write(b_age_edu);
      out__.write(b_hat);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ sigma;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma);
      local_scalar_t__ sigma_age;
      sigma_age = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_age);
      local_scalar_t__ sigma_edu;
      sigma_edu = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_edu);
      local_scalar_t__ sigma_state;
      sigma_state = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_state);
      local_scalar_t__ sigma_region;
      sigma_region = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_region);
      local_scalar_t__ sigma_age_edu;
      sigma_age_edu = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_age_edu);
      local_scalar_t__ b_0;
      b_0 = in__.read<local_scalar_t__>();
      out__.write(b_0);
      local_scalar_t__ b_female;
      b_female = in__.read<local_scalar_t__>();
      out__.write(b_female);
      local_scalar_t__ b_black;
      b_black = in__.read<local_scalar_t__>();
      out__.write(b_black);
      local_scalar_t__ b_female_black;
      b_female_black = in__.read<local_scalar_t__>();
      out__.write(b_female_black);
      local_scalar_t__ b_v_prev;
      b_v_prev = in__.read<local_scalar_t__>();
      out__.write(b_v_prev);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_age;
      b_age = Eigen::Matrix<local_scalar_t__, -1, 1>(n_age);
      stan::math::fill(b_age, DUMMY_VAR__);
      
      lcm_sym1__ = logical_gte(n_age, 1);
      if (lcm_sym1__) {
        assign(b_age, in__.read<local_scalar_t__>(),
          "assigning variable b_age", index_uni(1));
        for (int sym1__ = 2; sym1__ <= n_age; ++sym1__) {
          assign(b_age, in__.read<local_scalar_t__>(),
            "assigning variable b_age", index_uni(sym1__));
        }
      } 
      out__.write(b_age);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_edu;
      b_edu = Eigen::Matrix<local_scalar_t__, -1, 1>(n_edu);
      stan::math::fill(b_edu, DUMMY_VAR__);
      
      lcm_sym2__ = logical_gte(n_edu, 1);
      if (lcm_sym2__) {
        assign(b_edu, in__.read<local_scalar_t__>(),
          "assigning variable b_edu", index_uni(1));
        for (int sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
          assign(b_edu, in__.read<local_scalar_t__>(),
            "assigning variable b_edu", index_uni(sym1__));
        }
      } 
      out__.write(b_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_region;
      b_region = Eigen::Matrix<local_scalar_t__, -1, 1>(n_region);
      stan::math::fill(b_region, DUMMY_VAR__);
      
      if (logical_gte(n_region, 1)) {
        assign(b_region, in__.read<local_scalar_t__>(),
          "assigning variable b_region", index_uni(1));
        for (int sym1__ = 2; sym1__ <= n_region; ++sym1__) {
          assign(b_region, in__.read<local_scalar_t__>(),
            "assigning variable b_region", index_uni(sym1__));
        }
      } 
      out__.write(b_region);
      Eigen::Matrix<local_scalar_t__, -1, -1> b_age_edu;
      b_age_edu = Eigen::Matrix<local_scalar_t__, -1, -1>(n_age, n_edu);
      stan::math::fill(b_age_edu, DUMMY_VAR__);
      
      if (lcm_sym2__) {
        if (lcm_sym1__) {
          assign(b_age_edu, in__.read<local_scalar_t__>(),
            "assigning variable b_age_edu", index_uni(1), index_uni(1));
          for (int sym2__ = 2; sym2__ <= n_age; ++sym2__) {
            assign(b_age_edu, in__.read<local_scalar_t__>(),
              "assigning variable b_age_edu", index_uni(sym2__), index_uni(1));
          }
        } 
        for (int sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
          if (lcm_sym1__) {
            assign(b_age_edu, in__.read<local_scalar_t__>(),
              "assigning variable b_age_edu", index_uni(1), index_uni(sym1__));
            for (int sym2__ = 2; sym2__ <= n_age; ++sym2__) {
              assign(b_age_edu, in__.read<local_scalar_t__>(),
                "assigning variable b_age_edu", index_uni(sym2__),
                                                  index_uni(sym1__));
            }
          } 
        }
      } 
      out__.write(b_age_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_hat;
      b_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(n_state);
      stan::math::fill(b_hat, DUMMY_VAR__);
      
      if (logical_gte(n_state, 1)) {
        assign(b_hat, in__.read<local_scalar_t__>(),
          "assigning variable b_hat", index_uni(1));
        for (int sym1__ = 2; sym1__ <= n_state; ++sym1__) {
          assign(b_hat, in__.read<local_scalar_t__>(),
            "assigning variable b_hat", index_uni(sym1__));
        }
      } 
      out__.write(b_hat);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"sigma", "sigma_age", "sigma_edu",
      "sigma_state", "sigma_region", "sigma_age_edu", "b_0", "b_female",
      "b_black", "b_female_black", "b_v_prev", "b_age", "b_edu", "b_region",
      "b_age_edu", "b_hat"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(n_age)},
      std::vector<size_t>{static_cast<size_t>(n_edu)},
      std::vector<size_t>{static_cast<size_t>(n_region)},
      std::vector<size_t>{static_cast<size_t>(n_age),
                          static_cast<size_t>(n_edu)},
      std::vector<size_t>{static_cast<size_t>(n_state)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "sigma");
    param_names__.emplace_back(std::string() + "sigma_age");
    param_names__.emplace_back(std::string() + "sigma_edu");
    param_names__.emplace_back(std::string() + "sigma_state");
    param_names__.emplace_back(std::string() + "sigma_region");
    param_names__.emplace_back(std::string() + "sigma_age_edu");
    param_names__.emplace_back(std::string() + "b_0");
    param_names__.emplace_back(std::string() + "b_female");
    param_names__.emplace_back(std::string() + "b_black");
    param_names__.emplace_back(std::string() + "b_female_black");
    param_names__.emplace_back(std::string() + "b_v_prev");
    for (int sym48__ = 1; sym48__ <= n_age; ++sym48__) {
      {
        param_names__.emplace_back(std::string() + "b_age" + '.' + std::to_string(sym48__));
      } 
    }
    for (int sym48__ = 1; sym48__ <= n_edu; ++sym48__) {
      {
        param_names__.emplace_back(std::string() + "b_edu" + '.' + std::to_string(sym48__));
      } 
    }
    for (int sym48__ = 1; sym48__ <= n_region; ++sym48__) {
      {
        param_names__.emplace_back(std::string() + "b_region" + '.' + std::to_string(sym48__));
      } 
    }
    for (int sym48__ = 1; sym48__ <= n_edu; ++sym48__) {
      {
        for (int sym49__ = 1; sym49__ <= n_age; ++sym49__) {
          {
            param_names__.emplace_back(std::string() + "b_age_edu" + '.' + std::to_string(sym49__) + '.' + std::to_string(sym48__));
          } 
        }
      } 
    }
    for (int sym48__ = 1; sym48__ <= n_state; ++sym48__) {
      {
        param_names__.emplace_back(std::string() + "b_hat" + '.' + std::to_string(sym48__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "sigma");
    param_names__.emplace_back(std::string() + "sigma_age");
    param_names__.emplace_back(std::string() + "sigma_edu");
    param_names__.emplace_back(std::string() + "sigma_state");
    param_names__.emplace_back(std::string() + "sigma_region");
    param_names__.emplace_back(std::string() + "sigma_age_edu");
    param_names__.emplace_back(std::string() + "b_0");
    param_names__.emplace_back(std::string() + "b_female");
    param_names__.emplace_back(std::string() + "b_black");
    param_names__.emplace_back(std::string() + "b_female_black");
    param_names__.emplace_back(std::string() + "b_v_prev");
    for (int sym48__ = 1; sym48__ <= n_age; ++sym48__) {
      {
        param_names__.emplace_back(std::string() + "b_age" + '.' + std::to_string(sym48__));
      } 
    }
    for (int sym48__ = 1; sym48__ <= n_edu; ++sym48__) {
      {
        param_names__.emplace_back(std::string() + "b_edu" + '.' + std::to_string(sym48__));
      } 
    }
    for (int sym48__ = 1; sym48__ <= n_region; ++sym48__) {
      {
        param_names__.emplace_back(std::string() + "b_region" + '.' + std::to_string(sym48__));
      } 
    }
    for (int sym48__ = 1; sym48__ <= n_edu; ++sym48__) {
      {
        for (int sym49__ = 1; sym49__ <= n_age; ++sym49__) {
          {
            param_names__.emplace_back(std::string() + "b_age_edu" + '.' + std::to_string(sym49__) + '.' + std::to_string(sym48__));
          } 
        }
      } 
    }
    for (int sym48__ = 1; sym48__ <= n_state; ++sym48__) {
      {
        param_names__.emplace_back(std::string() + "b_hat" + '.' + std::to_string(sym48__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_state\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_region\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_v_prev\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_age\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age) + "},\"block\":\"parameters\"},{\"name\":\"b_edu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"b_region\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_region) + "},\"block\":\"parameters\"},{\"name\":\"b_age_edu\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_age) + ",\"cols\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"b_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_state) + "},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_state\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_region\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_v_prev\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_age\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age) + "},\"block\":\"parameters\"},{\"name\":\"b_edu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"b_region\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_region) + "},\"block\":\"parameters\"},{\"name\":\"b_age_edu\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_age) + ",\"cols\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"b_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_state) + "},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((((((((((((1 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + n_age)
       + n_edu) + n_region) + (n_age * n_edu)) + n_state);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((((((((((((1 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + n_age)
       + n_edu) + n_region) + (n_age * n_edu)) + n_state);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 16> names__{"sigma", "sigma_age",
      "sigma_edu", "sigma_state", "sigma_region", "sigma_age_edu", "b_0",
      "b_female", "b_black", "b_female_black", "b_v_prev", "b_age", "b_edu",
      "b_region", "b_age_edu", "b_hat"};
      const std::array<Eigen::Index, 16> constrain_param_sizes__{1, 1, 
       1, 1, 1, 1, 1, 1, 1, 1, 1, n_age, n_edu, n_region, (n_age * n_edu),
       n_state};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = dce_fail_model_namespace::dce_fail_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return dce_fail_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-experiment.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_experiment_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 9> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-experiment.stan', line 2, column 2 to column 8)",
 " (in 'expr-prop-experiment.stan', line 5, column 2 to column 9)",
 " (in 'expr-prop-experiment.stan', line 6, column 2 to column 9)",
 " (in 'expr-prop-experiment.stan', line 7, column 2 to column 9)",
 " (in 'expr-prop-experiment.stan', line 8, column 2 to column 28)",
 " (in 'expr-prop-experiment.stan', line 10, column 2 to column 23)",
 " (in 'expr-prop-experiment.stan', line 11, column 2 to column 23)",
 " (in 'expr-prop-experiment.stan', line 12, column 2 to column 23)"};



class expr_prop_experiment_model final : public model_base_crtp<expr_prop_experiment_model> {

 private:
  double lcm_sym4__;
  int j;
  double z;
  double x;
  double y;
  double i; 
  
 
 public:
  ~expr_prop_experiment_model() { }
  
  inline std::string model_name() const final { return "expr_prop_experiment_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_experiment_model(stan::io::var_context& context__,
                             unsigned int random_seed__ = 0,
                             std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_experiment_model_namespace::expr_prop_experiment_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      int pos__;
      pos__ = 1;
      current_statement__ = 1;
      context__.validate_dims("data initialization","j","int",
           std::vector<size_t>{});
      j = std::numeric_limits<int>::min();
      
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      current_statement__ = 2;
      z = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      x = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      y = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      i = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      i = normal_rng(5, 1, base_rng__);
      lcm_sym4__ = (i * j);
      z = lcm_sym4__;
      current_statement__ = 6;
      x = normal_rng(lcm_sym4__, 1, base_rng__);
      current_statement__ = 7;
      i = normal_rng(5, 1, base_rng__);
      current_statement__ = 8;
      y = normal_rng(z, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_experiment_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_experiment_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__;
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 0> names__{};
      const std::array<Eigen::Index, 0> constrain_param_sizes__{};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}

using stan_model = expr_prop_experiment_model_namespace::expr_prop_experiment_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_experiment_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-experiment2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_experiment2_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 8> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-experiment2.stan', line 2, column 2 to column 8)",
 " (in 'expr-prop-experiment2.stan', line 5, column 2 to column 13)",
 " (in 'expr-prop-experiment2.stan', line 6, column 2 to column 9)",
 " (in 'expr-prop-experiment2.stan', line 8, column 4 to column 32)",
 " (in 'expr-prop-experiment2.stan', line 10, column 4 to column 25)",
 " (in 'expr-prop-experiment2.stan', line 7, column 2 to line 11, column 3)",
 " (in 'expr-prop-experiment2.stan', line 12, column 2 to column 23)"};



class expr_prop_experiment2_model final : public model_base_crtp<expr_prop_experiment2_model> {

 private:
  double lcm_sym4__;
  int j;
  double z;
  double y; 
  
 
 public:
  ~expr_prop_experiment2_model() { }
  
  inline std::string model_name() const final { return "expr_prop_experiment2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_experiment2_model(stan::io::var_context& context__,
                              unsigned int random_seed__ = 0,
                              std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_experiment2_model_namespace::expr_prop_experiment2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      int pos__;
      pos__ = 1;
      current_statement__ = 1;
      context__.validate_dims("data initialization","j","int",
           std::vector<size_t>{});
      j = std::numeric_limits<int>::min();
      
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      current_statement__ = 2;
      z = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      z = 1;
      current_statement__ = 3;
      y = std::numeric_limits<double>::quiet_NaN();
      
      {
        double x;
        current_statement__ = 4;
        x = normal_rng(123, 1, base_rng__);
        lcm_sym4__ = (x * 2);
        z = lcm_sym4__;
        current_statement__ = 5;
        y = normal_rng(lcm_sym4__, 1, base_rng__);
      }
      current_statement__ = 7;
      y = normal_rng(z, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_experiment2_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_experiment2_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__;
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 0> names__{};
      const std::array<Eigen::Index, 0> constrain_param_sizes__{};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}

using stan_model = expr_prop_experiment2_model_namespace::expr_prop_experiment2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_experiment2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 12> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail.stan', line 7, column 2 to column 16)",
 " (in 'expr-prop-fail.stan', line 8, column 2 to column 25)",
 " (in 'expr-prop-fail.stan', line 9, column 2 to column 31)",
 " (in 'expr-prop-fail.stan', line 13, column 1 to column 22)",
 " (in 'expr-prop-fail.stan', line 14, column 1 to column 19)",
 " (in 'expr-prop-fail.stan', line 15, column 1 to column 20)",
 " (in 'expr-prop-fail.stan', line 17, column 3 to line 19, column 58)",
 " (in 'expr-prop-fail.stan', line 16, column 1 to line 19, column 58)",
 " (in 'expr-prop-fail.stan', line 2, column 1 to column 18)",
 " (in 'expr-prop-fail.stan', line 3, column 8 to column 9)",
 " (in 'expr-prop-fail.stan', line 3, column 1 to column 13)"};



class expr_prop_fail_model final : public model_base_crtp<expr_prop_fail_model> {

 private:
  double lcm_sym12__;
  double lcm_sym11__;
  int lcm_sym10__;
  int lcm_sym9__;
  int N;
  Eigen::Matrix<double, -1, 1> y__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> y{nullptr, 0};
 
 public:
  ~expr_prop_fail_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail_model_namespace::expr_prop_fail_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 9;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 9;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 9;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 10;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 11;
      context__.validate_dims("data initialization","y","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      y__ = Eigen::Matrix<double, -1, 1>(N);
      new (&y) Eigen::Map<Eigen::Matrix<double, -1, 1>>(y__.data(), N);
      
      {
        std::vector<double> y_flat__;
        current_statement__ = 11;
        y_flat__ = context__.vals_r("y");
        current_statement__ = 11;
        pos__ = 1;
        current_statement__ = 11;
        if (logical_gte(N, 1)) {
          current_statement__ = 11;
          assign(y, rvalue(y_flat__, "y_flat__", index_uni(1)),
            "assigning variable y", index_uni(1));
          current_statement__ = 11;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 11;
            assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", index_uni(sym1__));
            current_statement__ = 11;
            pos__ = (pos__ + 1);
          }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 2 + 2 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym8__;
      double lcm_sym7__;
      double lcm_sym6__;
      double lcm_sym5__;
      double lcm_sym4__;
      int lcm_sym3__;
      Eigen::Matrix<local_scalar_t__, -1, 1> mu;
      current_statement__ = 1;
      mu = in__.template read_constrain_ordered<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
             lp__, 2);
      std::vector<local_scalar_t__> sigma;
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<std::vector<local_scalar_t__>, jacobian__>(
                0, lp__, 2);
      local_scalar_t__ theta;
      current_statement__ = 3;
      theta = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 1, lp__);
      {
        current_statement__ = 4;
        lp_accum__.add(normal_lpdf<propto__>(sigma, 0, 2));
        current_statement__ = 5;
        lp_accum__.add(normal_lpdf<propto__>(mu, 0, 2));
        current_statement__ = 6;
        lp_accum__.add(beta_lpdf<propto__>(theta, 5, 5));
        current_statement__ = 8;
        if (logical_gte(N, 1)) {
          current_statement__ = 7;
          lp_accum__.add(
            log_mix(theta,
              normal_lpdf<false>(rvalue(y, "y", index_uni(1)),
                rvalue(mu, "mu", index_uni(1)),
                rvalue(sigma, "sigma", index_uni(1))),
              normal_lpdf<false>(rvalue(y, "y", index_uni(1)),
                rvalue(mu, "mu", index_uni(2)),
                rvalue(sigma, "sigma", index_uni(2)))));
          for (int n = 2; n <= N; ++n) {
            current_statement__ = 7;
            lp_accum__.add(
              log_mix(theta,
                normal_lpdf<false>(rvalue(y, "y", index_uni(n)),
                  rvalue(mu, "mu", index_uni(1)),
                  rvalue(sigma, "sigma", index_uni(1))),
                normal_lpdf<false>(rvalue(y, "y", index_uni(n)),
                  rvalue(mu, "mu", index_uni(2)),
                  rvalue(sigma, "sigma", index_uni(2)))));
          }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      Eigen::Matrix<double, -1, 1> mu;
      current_statement__ = 1;
      mu = in__.template read_constrain_ordered<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
             lp__, 2);
      std::vector<double> sigma;
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<std::vector<local_scalar_t__>, jacobian__>(
                0, lp__, 2);
      double theta;
      current_statement__ = 3;
      theta = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 1, lp__);
      out__.write(mu);
      out__.write(sigma);
      out__.write(theta);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__;
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, 1> mu;
      mu = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(mu, DUMMY_VAR__);
      
      {
        assign(mu, in__.read<local_scalar_t__>(),
          "assigning variable mu", index_uni(1));
        {
          assign(mu, in__.read<local_scalar_t__>(),
            "assigning variable mu", index_uni(2));
        }
      }
      out__.write_free_ordered(mu);
      std::vector<local_scalar_t__> sigma;
      sigma = std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      
      {
        sigma[(1 - 1)] = in__.read<local_scalar_t__>();
        {
          sigma[(2 - 1)] = in__.read<local_scalar_t__>();
        }
      }
      out__.write_free_lb(0, sigma);
      local_scalar_t__ theta;
      theta = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mu", "sigma", "theta"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(2)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(2)}, std::vector<size_t>{
      }};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym13__ = 1; sym13__ <= 2; ++sym13__) {
      {
        param_names__.emplace_back(std::string() + "mu" + '.' + std::to_string(sym13__));
      } 
    }
    for (int sym13__ = 1; sym13__ <= 2; ++sym13__) {
      {
        param_names__.emplace_back(std::string() + "sigma" + '.' + std::to_string(sym13__));
      } 
    }
    param_names__.emplace_back(std::string() + "theta");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym13__ = 1; sym13__ <= 2; ++sym13__) {
      {
        param_names__.emplace_back(std::string() + "mu" + '.' + std::to_string(sym13__));
      } 
    }
    for (int sym13__ = 1; sym13__ <= 2; ++sym13__) {
      {
        param_names__.emplace_back(std::string() + "sigma" + '.' + std::to_string(sym13__));
      } 
    }
    param_names__.emplace_back(std::string() + "theta");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((2 + 2) + 1);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((2 + 2) + 1);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 3> names__{"mu", "sigma", "theta"};
      const std::array<Eigen::Index, 3> constrain_param_sizes__{2, 2, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail_model_namespace::expr_prop_fail_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail2_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 12> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail2.stan', line 7, column 2 to column 10)",
 " (in 'expr-prop-fail2.stan', line 8, column 2 to column 16)",
 " (in 'expr-prop-fail2.stan', line 9, column 2 to column 20)",
 " (in 'expr-prop-fail2.stan', line 12, column 2 to column 26)",
 " (in 'expr-prop-fail2.stan', line 13, column 2 to column 26)",
 " (in 'expr-prop-fail2.stan', line 2, column 2 to column 17)",
 " (in 'expr-prop-fail2.stan', line 3, column 9 to column 10)",
 " (in 'expr-prop-fail2.stan', line 3, column 2 to column 12)",
 " (in 'expr-prop-fail2.stan', line 4, column 22 to column 23)",
 " (in 'expr-prop-fail2.stan', line 4, column 2 to column 25)",
 " (in 'expr-prop-fail2.stan', line 8, column 13 to column 14)"};



class expr_prop_fail2_model final : public model_base_crtp<expr_prop_fail2_model> {

 private:
  double lcm_sym8__;
  double lcm_sym7__;
  int lcm_sym6__;
  int J;
  std::vector<double> y;
  std::vector<double> sigma; 
  
 
 public:
  ~expr_prop_fail2_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail2_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail2_model_namespace::expr_prop_fail2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 6;
      context__.validate_dims("data initialization","J","int",
           std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      
      current_statement__ = 6;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 6;
      check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 7;
      validate_non_negative_index("y", "J", J);
      current_statement__ = 8;
      context__.validate_dims("data initialization","y","double",
           std::vector<size_t>{static_cast<size_t>(J)});
      y = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      y = context__.vals_r("y");
      current_statement__ = 9;
      validate_non_negative_index("sigma", "J", J);
      current_statement__ = 10;
      context__.validate_dims("data initialization","sigma","double",
           std::vector<size_t>{static_cast<size_t>(J)});
      sigma = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 10;
      sigma = context__.vals_r("sigma");
      current_statement__ = 10;
      if (logical_gte(J, 1)) {
        current_statement__ = 10;
        check_greater_or_equal(function__, "sigma[sym1__]",
                               rvalue(sigma, "sigma", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 10;
          check_greater_or_equal(function__, "sigma[sym1__]",
                                 sigma[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 11;
      validate_non_negative_index("theta", "J", J);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + J + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail2_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym5__;
      double lcm_sym4__;
      local_scalar_t__ mu;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      std::vector<local_scalar_t__> theta;
      current_statement__ = 2;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      local_scalar_t__ tau;
      current_statement__ = 3;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      {
        current_statement__ = 4;
        lp_accum__.add(normal_lpdf<propto__>(theta, mu, tau));
        current_statement__ = 5;
        lp_accum__.add(normal_lpdf<propto__>(y, theta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail2_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym3__;
      int lcm_sym2__;
      double mu;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      std::vector<double> theta;
      current_statement__ = 2;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      double tau;
      current_statement__ = 3;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      out__.write(mu);
      out__.write(theta);
      out__.write(tau);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ mu;
      mu = in__.read<local_scalar_t__>();
      out__.write(mu);
      std::vector<local_scalar_t__> theta;
      theta = std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      
      if (logical_gte(J, 1)) {
        theta[(1 - 1)] = in__.read<local_scalar_t__>();
        for (int sym1__ = 2; sym1__ <= J; ++sym1__) {
          theta[(sym1__ - 1)] = in__.read<local_scalar_t__>();
        }
      } 
      out__.write(theta);
      local_scalar_t__ tau;
      tau = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mu", "theta", "tau"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(J)}, std::vector<size_t>{
      }};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    for (int sym9__ = 1; sym9__ <= J; ++sym9__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym9__));
      } 
    }
    param_names__.emplace_back(std::string() + "tau");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    for (int sym9__ = 1; sym9__ <= J; ++sym9__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym9__));
      } 
    }
    param_names__.emplace_back(std::string() + "tau");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((1 + J) + 1);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((1 + J) + 1);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 3> names__{"mu", "theta", "tau"};
      const std::array<Eigen::Index, 3> constrain_param_sizes__{1, J, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail2_model_namespace::expr_prop_fail2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail3.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail3_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 52> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail3.stan', line 19, column 2 to column 18)",
 " (in 'expr-prop-fail3.stan', line 20, column 2 to column 18)",
 " (in 'expr-prop-fail3.stan', line 21, column 2 to column 22)",
 " (in 'expr-prop-fail3.stan', line 22, column 2 to column 20)",
 " (in 'expr-prop-fail3.stan', line 23, column 2 to column 26)",
 " (in 'expr-prop-fail3.stan', line 24, column 2 to column 17)",
 " (in 'expr-prop-fail3.stan', line 25, column 2 to column 34)",
 " (in 'expr-prop-fail3.stan', line 26, column 2 to column 34)",
 " (in 'expr-prop-fail3.stan', line 27, column 2 to column 34)",
 " (in 'expr-prop-fail3.stan', line 28, column 2 to column 34)",
 " (in 'expr-prop-fail3.stan', line 29, column 2 to column 34)",
 " (in 'expr-prop-fail3.stan', line 32, column 2 to column 18)",
 " (in 'expr-prop-fail3.stan', line 35, column 4 to line 38, column 66)",
 " (in 'expr-prop-fail3.stan', line 34, column 2 to line 38, column 66)",
 " (in 'expr-prop-fail3.stan', line 41, column 2 to column 26)",
 " (in 'expr-prop-fail3.stan', line 42, column 2 to column 26)",
 " (in 'expr-prop-fail3.stan', line 43, column 2 to column 26)",
 " (in 'expr-prop-fail3.stan', line 44, column 2 to column 26)",
 " (in 'expr-prop-fail3.stan', line 45, column 2 to column 26)",
 " (in 'expr-prop-fail3.stan', line 46, column 2 to column 24)",
 " (in 'expr-prop-fail3.stan', line 47, column 2 to column 29)",
 " (in 'expr-prop-fail3.stan', line 2, column 2 to column 17)",
 " (in 'expr-prop-fail3.stan', line 3, column 2 to column 21)",
 " (in 'expr-prop-fail3.stan', line 4, column 2 to column 25)",
 " (in 'expr-prop-fail3.stan', line 5, column 2 to column 21)",
 " (in 'expr-prop-fail3.stan', line 6, column 2 to column 29)",
 " (in 'expr-prop-fail3.stan', line 7, column 2 to column 23)",
 " (in 'expr-prop-fail3.stan', line 8, column 31 to column 32)",
 " (in 'expr-prop-fail3.stan', line 8, column 2 to column 34)",
 " (in 'expr-prop-fail3.stan', line 9, column 39 to column 40)",
 " (in 'expr-prop-fail3.stan', line 9, column 2 to column 42)",
 " (in 'expr-prop-fail3.stan', line 10, column 26 to column 27)",
 " (in 'expr-prop-fail3.stan', line 10, column 2 to column 35)",
 " (in 'expr-prop-fail3.stan', line 11, column 31 to column 32)",
 " (in 'expr-prop-fail3.stan', line 11, column 2 to column 34)",
 " (in 'expr-prop-fail3.stan', line 12, column 26 to column 27)",
 " (in 'expr-prop-fail3.stan', line 12, column 2 to column 36)",
 " (in 'expr-prop-fail3.stan', line 13, column 47 to column 48)",
 " (in 'expr-prop-fail3.stan', line 13, column 2 to column 50)",
 " (in 'expr-prop-fail3.stan', line 14, column 35 to column 36)",
 " (in 'expr-prop-fail3.stan', line 14, column 2 to column 38)",
 " (in 'expr-prop-fail3.stan', line 15, column 9 to column 10)",
 " (in 'expr-prop-fail3.stan', line 15, column 2 to column 24)",
 " (in 'expr-prop-fail3.stan', line 16, column 25 to column 26)",
 " (in 'expr-prop-fail3.stan', line 16, column 2 to column 28)",
 " (in 'expr-prop-fail3.stan', line 19, column 9 to column 14)",
 " (in 'expr-prop-fail3.stan', line 20, column 9 to column 14)",
 " (in 'expr-prop-fail3.stan', line 21, column 9 to column 18)",
 " (in 'expr-prop-fail3.stan', line 22, column 9 to column 16)",
 " (in 'expr-prop-fail3.stan', line 23, column 9 to column 22)",
 " (in 'expr-prop-fail3.stan', line 32, column 9 to column 10)"};



class expr_prop_fail3_model final : public model_base_crtp<expr_prop_fail3_model> {

 private:
  int lcm_sym44__;
  int lcm_sym43__;
  double lcm_sym42__;
  double lcm_sym41__;
  int lcm_sym40__;
  int lcm_sym39__;
  int lcm_sym38__;
  int lcm_sym37__;
  double lcm_sym36__;
  double lcm_sym35__;
  double lcm_sym34__;
  double lcm_sym33__;
  int lcm_sym32__;
  int lcm_sym31__;
  double lcm_sym30__;
  double lcm_sym29__;
  double lcm_sym28__;
  double lcm_sym27__;
  int lcm_sym26__;
  int lcm_sym25__;
  int lcm_sym24__;
  int lcm_sym23__;
  int lcm_sym22__;
  int lcm_sym21__;
  int N;
  int n_age;
  int n_age_edu;
  int n_edu;
  int n_region_full;
  int n_state;
  std::vector<int> age;
  std::vector<int> age_edu;
  Eigen::Matrix<double, -1, 1> black__;
  std::vector<int> edu;
  Eigen::Matrix<double, -1, 1> female__;
  std::vector<int> region_full;
  std::vector<int> state;
  Eigen::Matrix<double, -1, 1> v_prev_full__;
  std::vector<int> y; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> black{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> female{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> v_prev_full{nullptr, 0};
 
 public:
  ~expr_prop_fail3_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail3_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail3_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail3_model_namespace::expr_prop_fail3_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 22;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 22;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 22;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 23;
      context__.validate_dims("data initialization","n_age","int",
           std::vector<size_t>{});
      n_age = std::numeric_limits<int>::min();
      
      current_statement__ = 23;
      n_age = context__.vals_i("n_age")[(1 - 1)];
      current_statement__ = 23;
      check_greater_or_equal(function__, "n_age", n_age, 0);
      current_statement__ = 24;
      context__.validate_dims("data initialization","n_age_edu","int",
           std::vector<size_t>{});
      n_age_edu = std::numeric_limits<int>::min();
      
      current_statement__ = 24;
      n_age_edu = context__.vals_i("n_age_edu")[(1 - 1)];
      current_statement__ = 24;
      check_greater_or_equal(function__, "n_age_edu", n_age_edu, 0);
      current_statement__ = 25;
      context__.validate_dims("data initialization","n_edu","int",
           std::vector<size_t>{});
      n_edu = std::numeric_limits<int>::min();
      
      current_statement__ = 25;
      n_edu = context__.vals_i("n_edu")[(1 - 1)];
      current_statement__ = 25;
      check_greater_or_equal(function__, "n_edu", n_edu, 0);
      current_statement__ = 26;
      context__.validate_dims("data initialization","n_region_full","int",
           std::vector<size_t>{});
      n_region_full = std::numeric_limits<int>::min();
      
      current_statement__ = 26;
      n_region_full = context__.vals_i("n_region_full")[(1 - 1)];
      current_statement__ = 26;
      check_greater_or_equal(function__, "n_region_full", n_region_full, 0);
      current_statement__ = 27;
      context__.validate_dims("data initialization","n_state","int",
           std::vector<size_t>{});
      n_state = std::numeric_limits<int>::min();
      
      current_statement__ = 27;
      n_state = context__.vals_i("n_state")[(1 - 1)];
      current_statement__ = 27;
      check_greater_or_equal(function__, "n_state", n_state, 0);
      current_statement__ = 28;
      validate_non_negative_index("age", "N", N);
      current_statement__ = 29;
      context__.validate_dims("data initialization","age","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      age = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 29;
      age = context__.vals_i("age");
      lcm_sym21__ = logical_gte(N, 1);
      if (lcm_sym21__) {
        current_statement__ = 29;
        check_greater_or_equal(function__, "age[sym1__]",
                               rvalue(age, "age", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 29;
          check_greater_or_equal(function__, "age[sym1__]",
                                 age[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 29;
      if (lcm_sym21__) {
        current_statement__ = 29;
        check_less_or_equal(function__, "age[sym1__]",
                            rvalue(age, "age", index_uni(1)), n_age);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 29;
          check_less_or_equal(function__, "age[sym1__]", age[(sym1__ - 1)],
                              n_age);
        }
      } 
      current_statement__ = 30;
      validate_non_negative_index("age_edu", "N", N);
      current_statement__ = 31;
      context__.validate_dims("data initialization","age_edu","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      age_edu = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 31;
      age_edu = context__.vals_i("age_edu");
      current_statement__ = 31;
      if (lcm_sym21__) {
        current_statement__ = 31;
        check_greater_or_equal(function__, "age_edu[sym1__]",
                               rvalue(age_edu, "age_edu", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 31;
          check_greater_or_equal(function__, "age_edu[sym1__]",
                                 age_edu[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 31;
      if (lcm_sym21__) {
        current_statement__ = 31;
        check_less_or_equal(function__, "age_edu[sym1__]",
                            rvalue(age_edu, "age_edu", index_uni(1)),
                            n_age_edu);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 31;
          check_less_or_equal(function__, "age_edu[sym1__]",
                              age_edu[(sym1__ - 1)], n_age_edu);
        }
      } 
      current_statement__ = 32;
      validate_non_negative_index("black", "N", N);
      current_statement__ = 33;
      context__.validate_dims("data initialization","black","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      black__ = Eigen::Matrix<double, -1, 1>(N);
      new (&black) Eigen::Map<Eigen::Matrix<double, -1, 1>>(black__.data(), N);
      
      
      {
        std::vector<double> black_flat__;
        current_statement__ = 33;
        black_flat__ = context__.vals_r("black");
        current_statement__ = 33;
        pos__ = 1;
        current_statement__ = 33;
        if (lcm_sym21__) {
          current_statement__ = 33;
          assign(black, rvalue(black_flat__, "black_flat__", index_uni(1)),
            "assigning variable black", index_uni(1));
          current_statement__ = 33;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 33;
            assign(black, black_flat__[(pos__ - 1)],
              "assigning variable black", index_uni(sym1__));
            current_statement__ = 33;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 33;
      if (lcm_sym21__) {
        current_statement__ = 33;
        check_greater_or_equal(function__, "black[sym1__]",
                               rvalue(black, "black", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 33;
          check_greater_or_equal(function__, "black[sym1__]",
                                 black[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 33;
      if (lcm_sym21__) {
        current_statement__ = 33;
        check_less_or_equal(function__, "black[sym1__]",
                            rvalue(black, "black", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 33;
          check_less_or_equal(function__, "black[sym1__]",
                              black[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 34;
      validate_non_negative_index("edu", "N", N);
      current_statement__ = 35;
      context__.validate_dims("data initialization","edu","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      edu = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 35;
      edu = context__.vals_i("edu");
      current_statement__ = 35;
      if (lcm_sym21__) {
        current_statement__ = 35;
        check_greater_or_equal(function__, "edu[sym1__]",
                               rvalue(edu, "edu", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 35;
          check_greater_or_equal(function__, "edu[sym1__]",
                                 edu[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 35;
      if (lcm_sym21__) {
        current_statement__ = 35;
        check_less_or_equal(function__, "edu[sym1__]",
                            rvalue(edu, "edu", index_uni(1)), n_edu);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 35;
          check_less_or_equal(function__, "edu[sym1__]", edu[(sym1__ - 1)],
                              n_edu);
        }
      } 
      current_statement__ = 36;
      validate_non_negative_index("female", "N", N);
      current_statement__ = 37;
      context__.validate_dims("data initialization","female","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      female__ = Eigen::Matrix<double, -1, 1>(N);
      new (&female) Eigen::Map<Eigen::Matrix<double, -1, 1>>(female__.data(), N);
      
      
      {
        std::vector<double> female_flat__;
        current_statement__ = 37;
        female_flat__ = context__.vals_r("female");
        current_statement__ = 37;
        pos__ = 1;
        current_statement__ = 37;
        if (lcm_sym21__) {
          current_statement__ = 37;
          assign(female,
            rvalue(female_flat__, "female_flat__", index_uni(1)),
            "assigning variable female", index_uni(1));
          current_statement__ = 37;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 37;
            assign(female, female_flat__[(pos__ - 1)],
              "assigning variable female", index_uni(sym1__));
            current_statement__ = 37;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 37;
      if (lcm_sym21__) {
        current_statement__ = 37;
        check_greater_or_equal(function__, "female[sym1__]",
                               rvalue(female, "female", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 37;
          check_greater_or_equal(function__, "female[sym1__]",
                                 female[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 37;
      if (lcm_sym21__) {
        current_statement__ = 37;
        check_less_or_equal(function__, "female[sym1__]",
                            rvalue(female, "female", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 37;
          check_less_or_equal(function__, "female[sym1__]",
                              female[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 38;
      validate_non_negative_index("region_full", "N", N);
      current_statement__ = 39;
      context__.validate_dims("data initialization","region_full","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      region_full = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 39;
      region_full = context__.vals_i("region_full");
      current_statement__ = 39;
      if (lcm_sym21__) {
        current_statement__ = 39;
        check_greater_or_equal(function__, "region_full[sym1__]",
                               rvalue(region_full, "region_full",
                                 index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 39;
          check_greater_or_equal(function__, "region_full[sym1__]",
                                 region_full[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 39;
      if (lcm_sym21__) {
        current_statement__ = 39;
        check_less_or_equal(function__, "region_full[sym1__]",
                            rvalue(region_full, "region_full", index_uni(1)),
                            n_region_full);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 39;
          check_less_or_equal(function__, "region_full[sym1__]",
                              region_full[(sym1__ - 1)], n_region_full);
        }
      } 
      current_statement__ = 40;
      validate_non_negative_index("state", "N", N);
      current_statement__ = 41;
      context__.validate_dims("data initialization","state","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      state = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 41;
      state = context__.vals_i("state");
      current_statement__ = 41;
      if (lcm_sym21__) {
        current_statement__ = 41;
        check_greater_or_equal(function__, "state[sym1__]",
                               rvalue(state, "state", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 41;
          check_greater_or_equal(function__, "state[sym1__]",
                                 state[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 41;
      if (lcm_sym21__) {
        current_statement__ = 41;
        check_less_or_equal(function__, "state[sym1__]",
                            rvalue(state, "state", index_uni(1)), n_state);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 41;
          check_less_or_equal(function__, "state[sym1__]",
                              state[(sym1__ - 1)], n_state);
        }
      } 
      current_statement__ = 42;
      validate_non_negative_index("v_prev_full", "N", N);
      current_statement__ = 43;
      context__.validate_dims("data initialization","v_prev_full","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      v_prev_full__ = Eigen::Matrix<double, -1, 1>(N);
      new (&v_prev_full) Eigen::Map<Eigen::Matrix<double, -1, 1>>(v_prev_full__.data(), N);
      
      
      {
        std::vector<double> v_prev_full_flat__;
        current_statement__ = 43;
        v_prev_full_flat__ = context__.vals_r("v_prev_full");
        current_statement__ = 43;
        pos__ = 1;
        current_statement__ = 43;
        if (lcm_sym21__) {
          current_statement__ = 43;
          assign(v_prev_full,
            rvalue(v_prev_full_flat__, "v_prev_full_flat__", index_uni(1)),
            "assigning variable v_prev_full", index_uni(1));
          current_statement__ = 43;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 43;
            assign(v_prev_full, v_prev_full_flat__[(pos__ - 1)],
              "assigning variable v_prev_full", index_uni(sym1__));
            current_statement__ = 43;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 44;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 45;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 45;
      y = context__.vals_i("y");
      current_statement__ = 45;
      if (lcm_sym21__) {
        current_statement__ = 45;
        check_greater_or_equal(function__, "y[sym1__]",
                               rvalue(y, "y", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 45;
          check_greater_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 45;
      if (lcm_sym21__) {
        current_statement__ = 45;
        check_less_or_equal(function__, "y[sym1__]",
                            rvalue(y, "y", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 45;
          check_less_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 46;
      validate_non_negative_index("a", "n_age", n_age);
      current_statement__ = 47;
      validate_non_negative_index("b", "n_edu", n_edu);
      current_statement__ = 48;
      validate_non_negative_index("c", "n_age_edu", n_age_edu);
      current_statement__ = 49;
      validate_non_negative_index("d", "n_state", n_state);
      current_statement__ = 50;
      validate_non_negative_index("e", "n_region_full", n_region_full);
      current_statement__ = 51;
      validate_non_negative_index("y_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = n_age + n_edu + n_age_edu + n_state + n_region_full + 
      5 + 1 + 1 + 1 + 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail3_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      double lcm_sym12__;
      int lcm_sym11__;
      Eigen::Matrix<local_scalar_t__, -1, 1> a;
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_age);
      Eigen::Matrix<local_scalar_t__, -1, 1> b;
      current_statement__ = 2;
      b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> c;
      current_statement__ = 3;
      c = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
            n_age_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> d;
      current_statement__ = 4;
      d = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_state);
      Eigen::Matrix<local_scalar_t__, -1, 1> e;
      current_statement__ = 5;
      e = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
            n_region_full);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      current_statement__ = 6;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(5);
      local_scalar_t__ sigma_a;
      current_statement__ = 7;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      local_scalar_t__ sigma_b;
      current_statement__ = 8;
      sigma_b = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      local_scalar_t__ sigma_c;
      current_statement__ = 9;
      sigma_c = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      local_scalar_t__ sigma_d;
      current_statement__ = 10;
      sigma_d = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      local_scalar_t__ sigma_e;
      current_statement__ = 11;
      sigma_e = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y_hat, DUMMY_VAR__);
      
      current_statement__ = 14;
      if (logical_gte(N, 1)) {
        current_statement__ = 13;
        assign(y_hat,
          (((((stan::math::fma(rvalue(beta, "beta", index_uni(4)),
                 rvalue(v_prev_full, "v_prev_full", index_uni(1)),
                 stan::math::fma(
                   (rvalue(beta, "beta", index_uni(5)) *
                     rvalue(female, "female", index_uni(1))),
                   rvalue(black, "black", index_uni(1)),
                   stan::math::fma(rvalue(beta, "beta", index_uni(3)),
                     rvalue(female, "female", index_uni(1)),
                     stan::math::fma(rvalue(beta, "beta", index_uni(2)),
                       rvalue(black, "black", index_uni(1)),
                       rvalue(beta, "beta", index_uni(1)))))) +
                rvalue(a, "a", index_uni(rvalue(age, "age", index_uni(1)))))
               + rvalue(b, "b", index_uni(rvalue(edu, "edu", index_uni(1)))))
              +
              rvalue(c, "c",
                index_uni(rvalue(age_edu, "age_edu", index_uni(1))))) +
             rvalue(d, "d", index_uni(rvalue(state, "state", index_uni(1)))))
            +
            rvalue(e, "e",
              index_uni(rvalue(region_full, "region_full", index_uni(1))))),
          "assigning variable y_hat", index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 13;
          assign(y_hat,
            (((((stan::math::fma(rvalue(beta, "beta", index_uni(4)),
                   rvalue(v_prev_full, "v_prev_full", index_uni(i)),
                   stan::math::fma(
                     (rvalue(beta, "beta", index_uni(5)) *
                       rvalue(female, "female", index_uni(i))),
                     rvalue(black, "black", index_uni(i)),
                     stan::math::fma(rvalue(beta, "beta", index_uni(3)),
                       rvalue(female, "female", index_uni(i)),
                       stan::math::fma(rvalue(beta, "beta", index_uni(2)),
                         rvalue(black, "black", index_uni(i)),
                         rvalue(beta, "beta", index_uni(1)))))) +
                  rvalue(a, "a", index_uni(rvalue(age, "age", index_uni(i)))))
                 +
                 rvalue(b, "b", index_uni(rvalue(edu, "edu", index_uni(i)))))
                +
                rvalue(c, "c",
                  index_uni(rvalue(age_edu, "age_edu", index_uni(i))))) +
               rvalue(d, "d",
                 index_uni(rvalue(state, "state", index_uni(i))))) +
              rvalue(e, "e",
                index_uni(rvalue(region_full, "region_full", index_uni(i))))),
            "assigning variable y_hat", index_uni(i));
        }
      } 
      {
        current_statement__ = 15;
        lp_accum__.add(normal_lpdf<propto__>(a, 0, sigma_a));
        current_statement__ = 16;
        lp_accum__.add(normal_lpdf<propto__>(b, 0, sigma_b));
        current_statement__ = 17;
        lp_accum__.add(normal_lpdf<propto__>(c, 0, sigma_c));
        current_statement__ = 18;
        lp_accum__.add(normal_lpdf<propto__>(d, 0, sigma_d));
        current_statement__ = 19;
        lp_accum__.add(normal_lpdf<propto__>(e, 0, sigma_e));
        current_statement__ = 20;
        lp_accum__.add(normal_lpdf<propto__>(beta, 0, 100));
        current_statement__ = 21;
        lp_accum__.add(bernoulli_logit_lpmf<propto__>(y, y_hat));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail3_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym10__;
      double lcm_sym9__;
      int lcm_sym8__;
      int lcm_sym7__;
      int lcm_sym6__;
      Eigen::Matrix<double, -1, 1> a;
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_age);
      Eigen::Matrix<double, -1, 1> b;
      current_statement__ = 2;
      b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_edu);
      Eigen::Matrix<double, -1, 1> c;
      current_statement__ = 3;
      c = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
            n_age_edu);
      Eigen::Matrix<double, -1, 1> d;
      current_statement__ = 4;
      d = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_state);
      Eigen::Matrix<double, -1, 1> e;
      current_statement__ = 5;
      e = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
            n_region_full);
      Eigen::Matrix<double, -1, 1> beta;
      current_statement__ = 6;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(5);
      double sigma_a;
      current_statement__ = 7;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      double sigma_b;
      current_statement__ = 8;
      sigma_b = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      double sigma_c;
      current_statement__ = 9;
      sigma_c = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      double sigma_d;
      current_statement__ = 10;
      sigma_d = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      double sigma_e;
      current_statement__ = 11;
      sigma_e = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y_hat, DUMMY_VAR__);
      
      out__.write(a);
      out__.write(b);
      out__.write(c);
      out__.write(d);
      out__.write(e);
      out__.write(beta);
      out__.write(sigma_a);
      out__.write(sigma_b);
      out__.write(sigma_c);
      out__.write(sigma_d);
      out__.write(sigma_e);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 14;
      if (logical_gte(N, 1)) {
        current_statement__ = 13;
        assign(y_hat,
          (((((stan::math::fma(rvalue(beta, "beta", index_uni(4)),
                 rvalue(v_prev_full, "v_prev_full", index_uni(1)),
                 stan::math::fma(
                   (rvalue(beta, "beta", index_uni(5)) *
                     rvalue(female, "female", index_uni(1))),
                   rvalue(black, "black", index_uni(1)),
                   stan::math::fma(rvalue(beta, "beta", index_uni(3)),
                     rvalue(female, "female", index_uni(1)),
                     stan::math::fma(rvalue(beta, "beta", index_uni(2)),
                       rvalue(black, "black", index_uni(1)),
                       rvalue(beta, "beta", index_uni(1)))))) +
                rvalue(a, "a", index_uni(rvalue(age, "age", index_uni(1)))))
               + rvalue(b, "b", index_uni(rvalue(edu, "edu", index_uni(1)))))
              +
              rvalue(c, "c",
                index_uni(rvalue(age_edu, "age_edu", index_uni(1))))) +
             rvalue(d, "d", index_uni(rvalue(state, "state", index_uni(1)))))
            +
            rvalue(e, "e",
              index_uni(rvalue(region_full, "region_full", index_uni(1))))),
          "assigning variable y_hat", index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 13;
          assign(y_hat,
            (((((stan::math::fma(rvalue(beta, "beta", index_uni(4)),
                   rvalue(v_prev_full, "v_prev_full", index_uni(i)),
                   stan::math::fma(
                     (rvalue(beta, "beta", index_uni(5)) *
                       rvalue(female, "female", index_uni(i))),
                     rvalue(black, "black", index_uni(i)),
                     stan::math::fma(rvalue(beta, "beta", index_uni(3)),
                       rvalue(female, "female", index_uni(i)),
                       stan::math::fma(rvalue(beta, "beta", index_uni(2)),
                         rvalue(black, "black", index_uni(i)),
                         rvalue(beta, "beta", index_uni(1)))))) +
                  rvalue(a, "a", index_uni(rvalue(age, "age", index_uni(i)))))
                 +
                 rvalue(b, "b", index_uni(rvalue(edu, "edu", index_uni(i)))))
                +
                rvalue(c, "c",
                  index_uni(rvalue(age_edu, "age_edu", index_uni(i))))) +
               rvalue(d, "d",
                 index_uni(rvalue(state, "state", index_uni(i))))) +
              rvalue(e, "e",
                index_uni(rvalue(region_full, "region_full", index_uni(i))))),
            "assigning variable y_hat", index_uni(i));
        }
      } 
      if (emit_transformed_parameters__) {
        out__.write(y_hat);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, 1> a;
      a = Eigen::Matrix<local_scalar_t__, -1, 1>(n_age);
      stan::math::fill(a, DUMMY_VAR__);
      
      if (logical_gte(n_age, 1)) {
        assign(a, in__.read<local_scalar_t__>(),
          "assigning variable a", index_uni(1));
        for (int sym1__ = 2; sym1__ <= n_age; ++sym1__) {
          assign(a, in__.read<local_scalar_t__>(),
            "assigning variable a", index_uni(sym1__));
        }
      } 
      out__.write(a);
      Eigen::Matrix<local_scalar_t__, -1, 1> b;
      b = Eigen::Matrix<local_scalar_t__, -1, 1>(n_edu);
      stan::math::fill(b, DUMMY_VAR__);
      
      if (logical_gte(n_edu, 1)) {
        assign(b, in__.read<local_scalar_t__>(),
          "assigning variable b", index_uni(1));
        for (int sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
          assign(b, in__.read<local_scalar_t__>(),
            "assigning variable b", index_uni(sym1__));
        }
      } 
      out__.write(b);
      Eigen::Matrix<local_scalar_t__, -1, 1> c;
      c = Eigen::Matrix<local_scalar_t__, -1, 1>(n_age_edu);
      stan::math::fill(c, DUMMY_VAR__);
      
      if (logical_gte(n_age_edu, 1)) {
        assign(c, in__.read<local_scalar_t__>(),
          "assigning variable c", index_uni(1));
        for (int sym1__ = 2; sym1__ <= n_age_edu; ++sym1__) {
          assign(c, in__.read<local_scalar_t__>(),
            "assigning variable c", index_uni(sym1__));
        }
      } 
      out__.write(c);
      Eigen::Matrix<local_scalar_t__, -1, 1> d;
      d = Eigen::Matrix<local_scalar_t__, -1, 1>(n_state);
      stan::math::fill(d, DUMMY_VAR__);
      
      if (logical_gte(n_state, 1)) {
        assign(d, in__.read<local_scalar_t__>(),
          "assigning variable d", index_uni(1));
        for (int sym1__ = 2; sym1__ <= n_state; ++sym1__) {
          assign(d, in__.read<local_scalar_t__>(),
            "assigning variable d", index_uni(sym1__));
        }
      } 
      out__.write(d);
      Eigen::Matrix<local_scalar_t__, -1, 1> e;
      e = Eigen::Matrix<local_scalar_t__, -1, 1>(n_region_full);
      stan::math::fill(e, DUMMY_VAR__);
      
      if (logical_gte(n_region_full, 1)) {
        assign(e, in__.read<local_scalar_t__>(),
          "assigning variable e", index_uni(1));
        for (int sym1__ = 2; sym1__ <= n_region_full; ++sym1__) {
          assign(e, in__.read<local_scalar_t__>(),
            "assigning variable e", index_uni(sym1__));
        }
      } 
      out__.write(e);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(5);
      stan::math::fill(beta, DUMMY_VAR__);
      
      {
        assign(beta, in__.read<local_scalar_t__>(),
          "assigning variable beta", index_uni(1));
        {
          assign(beta, in__.read<local_scalar_t__>(),
            "assigning variable beta", index_uni(2));
        }
        {
          assign(beta, in__.read<local_scalar_t__>(),
            "assigning variable beta", index_uni(3));
        }
        {
          assign(beta, in__.read<local_scalar_t__>(),
            "assigning variable beta", index_uni(4));
        }
        {
          assign(beta, in__.read<local_scalar_t__>(),
            "assigning variable beta", index_uni(5));
        }
      }
      out__.write(beta);
      local_scalar_t__ sigma_a;
      sigma_a = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_a);
      local_scalar_t__ sigma_b;
      sigma_b = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_b);
      local_scalar_t__ sigma_c;
      sigma_c = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_c);
      local_scalar_t__ sigma_d;
      sigma_d = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_d);
      local_scalar_t__ sigma_e;
      sigma_e = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_e);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"a", "b", "c", "d", "e", "beta",
      "sigma_a", "sigma_b", "sigma_c", "sigma_d", "sigma_e", "y_hat"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(n_age)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(n_edu)},
      std::vector<size_t>{static_cast<size_t>(n_age_edu)},
      std::vector<size_t>{static_cast<size_t>(n_state)},
      std::vector<size_t>{static_cast<size_t>(n_region_full)},
      std::vector<size_t>{static_cast<size_t>(5)}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(N)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym45__ = 1; sym45__ <= n_age; ++sym45__) {
      {
        param_names__.emplace_back(std::string() + "a" + '.' + std::to_string(sym45__));
      } 
    }
    for (int sym45__ = 1; sym45__ <= n_edu; ++sym45__) {
      {
        param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym45__));
      } 
    }
    for (int sym45__ = 1; sym45__ <= n_age_edu; ++sym45__) {
      {
        param_names__.emplace_back(std::string() + "c" + '.' + std::to_string(sym45__));
      } 
    }
    for (int sym45__ = 1; sym45__ <= n_state; ++sym45__) {
      {
        param_names__.emplace_back(std::string() + "d" + '.' + std::to_string(sym45__));
      } 
    }
    for (int sym45__ = 1; sym45__ <= n_region_full; ++sym45__) {
      {
        param_names__.emplace_back(std::string() + "e" + '.' + std::to_string(sym45__));
      } 
    }
    for (int sym45__ = 1; sym45__ <= 5; ++sym45__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym45__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_b");
    param_names__.emplace_back(std::string() + "sigma_c");
    param_names__.emplace_back(std::string() + "sigma_d");
    param_names__.emplace_back(std::string() + "sigma_e");
    if (emit_transformed_parameters__) {
      for (int sym45__ = 1; sym45__ <= N; ++sym45__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym45__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym45__ = 1; sym45__ <= n_age; ++sym45__) {
      {
        param_names__.emplace_back(std::string() + "a" + '.' + std::to_string(sym45__));
      } 
    }
    for (int sym45__ = 1; sym45__ <= n_edu; ++sym45__) {
      {
        param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym45__));
      } 
    }
    for (int sym45__ = 1; sym45__ <= n_age_edu; ++sym45__) {
      {
        param_names__.emplace_back(std::string() + "c" + '.' + std::to_string(sym45__));
      } 
    }
    for (int sym45__ = 1; sym45__ <= n_state; ++sym45__) {
      {
        param_names__.emplace_back(std::string() + "d" + '.' + std::to_string(sym45__));
      } 
    }
    for (int sym45__ = 1; sym45__ <= n_region_full; ++sym45__) {
      {
        param_names__.emplace_back(std::string() + "e" + '.' + std::to_string(sym45__));
      } 
    }
    for (int sym45__ = 1; sym45__ <= 5; ++sym45__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym45__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_b");
    param_names__.emplace_back(std::string() + "sigma_c");
    param_names__.emplace_back(std::string() + "sigma_d");
    param_names__.emplace_back(std::string() + "sigma_e");
    if (emit_transformed_parameters__) {
      for (int sym45__ = 1; sym45__ <= N; ++sym45__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym45__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age) + "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"c\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age_edu) + "},\"block\":\"parameters\"},{\"name\":\"d\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_state) + "},\"block\":\"parameters\"},{\"name\":\"e\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_region_full) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_b\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_c\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_d\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_e\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age) + "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"c\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age_edu) + "},\"block\":\"parameters\"},{\"name\":\"d\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_state) + "},\"block\":\"parameters\"},{\"name\":\"e\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_region_full) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_b\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_c\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_d\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_e\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((((((((n_age + n_edu) + n_age_edu) + n_state) + n_region_full) + 5) + 1)
       + 1) + 1) + 1) + 1);
      const size_t num_transformed = N;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((((((((n_age + n_edu) + n_age_edu) + n_state) + n_region_full) + 5) + 1)
       + 1) + 1) + 1) + 1);
      const size_t num_transformed = N;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 11> names__{"a", "b", "c", "d", "e",
      "beta", "sigma_a", "sigma_b", "sigma_c", "sigma_d", "sigma_e"};
      const std::array<Eigen::Index, 11> constrain_param_sizes__{n_age, 
       n_edu, n_age_edu, n_state, n_region_full, 5, 1, 1, 1, 1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail3_model_namespace::expr_prop_fail3_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail3_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail4.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail4_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 43> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail4.stan', line 12, column 2 to column 24)",
 " (in 'expr-prop-fail4.stan', line 13, column 2 to column 28)",
 " (in 'expr-prop-fail4.stan', line 16, column 2 to column 47)",
 " (in 'expr-prop-fail4.stan', line 17, column 2 to column 16)",
 " (in 'expr-prop-fail4.stan', line 18, column 2 to column 31)",
 " (in 'expr-prop-fail4.stan', line 19, column 2 to column 29)",
 " (in 'expr-prop-fail4.stan', line 20, column 2 to column 24)",
 " (in 'expr-prop-fail4.stan', line 27, column 2 to column 13)",
 " (in 'expr-prop-fail4.stan', line 28, column 2 to column 13)",
 " (in 'expr-prop-fail4.stan', line 29, column 2 to column 26)",
 " (in 'expr-prop-fail4.stan', line 30, column 2 to column 28)",
 " (in 'expr-prop-fail4.stan', line 31, column 2 to column 18)",
 " (in 'expr-prop-fail4.stan', line 32, column 2 to column 22)",
 " (in 'expr-prop-fail4.stan', line 34, column 2 to column 14)",
 " (in 'expr-prop-fail4.stan', line 35, column 2 to column 11)",
 " (in 'expr-prop-fail4.stan', line 37, column 2 to column 27)",
 " (in 'expr-prop-fail4.stan', line 38, column 2 to column 27)",
 " (in 'expr-prop-fail4.stan', line 40, column 4 to column 36)",
 " (in 'expr-prop-fail4.stan', line 39, column 17 to line 41, column 3)",
 " (in 'expr-prop-fail4.stan', line 42, column 2 to column 38)",
 " (in 'expr-prop-fail4.stan', line 47, column 4 to column 28)",
 " (in 'expr-prop-fail4.stan', line 48, column 4 to column 80)",
 " (in 'expr-prop-fail4.stan', line 46, column 17 to line 49, column 3)",
 " (in 'expr-prop-fail4.stan', line 46, column 2 to line 49, column 3)",
 " (in 'expr-prop-fail4.stan', line 23, column 2 to column 53)",
 " (in 'expr-prop-fail4.stan', line 24, column 2 to column 24)",
 " (in 'expr-prop-fail4.stan', line 2, column 2 to column 17)",
 " (in 'expr-prop-fail4.stan', line 3, column 2 to column 23)",
 " (in 'expr-prop-fail4.stan', line 4, column 30 to column 37)",
 " (in 'expr-prop-fail4.stan', line 4, column 2 to column 39)",
 " (in 'expr-prop-fail4.stan', line 5, column 30 to column 37)",
 " (in 'expr-prop-fail4.stan', line 5, column 2 to column 39)",
 " (in 'expr-prop-fail4.stan', line 6, column 18 to column 19)",
 " (in 'expr-prop-fail4.stan', line 6, column 2 to column 23)",
 " (in 'expr-prop-fail4.stan', line 9, column 9 to column 10)",
 " (in 'expr-prop-fail4.stan', line 9, column 2 to column 27)",
 " (in 'expr-prop-fail4.stan', line 13, column 9 to column 14)",
 " (in 'expr-prop-fail4.stan', line 17, column 9 to column 10)",
 " (in 'expr-prop-fail4.stan', line 31, column 9 to column 10)",
 " (in 'expr-prop-fail4.stan', line 32, column 9 to column 10)",
 " (in 'expr-prop-fail4.stan', line 34, column 9 to column 10)",
 " (in 'expr-prop-fail4.stan', line 35, column 8 to column 9)"};



class expr_prop_fail4_model final : public model_base_crtp<expr_prop_fail4_model> {

 private:
  int lcm_sym35__;
  int lcm_sym34__;
  int lcm_sym33__;
  int lcm_sym32__;
  double lcm_sym31__;
  double lcm_sym30__;
  double lcm_sym29__;
  double lcm_sym28__;
  Eigen::Matrix<double, -1, 1> lcm_sym27____;
  int lcm_sym26__;
  int lcm_sym25__;
  int lcm_sym24__;
  int lcm_sym23__;
  int N;
  int N_edges;
  std::vector<int> node1;
  std::vector<int> node2;
  Eigen::Matrix<double, -1, 1> E__;
  Eigen::Matrix<double, -1, 1> log_E__;
  int phi_std_raw_1dim__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> lcm_sym27__{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> E{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> log_E{nullptr, 0};
 
 public:
  ~expr_prop_fail4_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail4_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail4_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail4_model_namespace::expr_prop_fail4_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 27;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 27;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 27;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 28;
      context__.validate_dims("data initialization","N_edges","int",
           std::vector<size_t>{});
      N_edges = std::numeric_limits<int>::min();
      
      current_statement__ = 28;
      N_edges = context__.vals_i("N_edges")[(1 - 1)];
      current_statement__ = 28;
      check_greater_or_equal(function__, "N_edges", N_edges, 0);
      current_statement__ = 29;
      validate_non_negative_index("node1", "N_edges", N_edges);
      current_statement__ = 30;
      context__.validate_dims("data initialization","node1","int",
           std::vector<size_t>{static_cast<size_t>(N_edges)});
      node1 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      
      current_statement__ = 30;
      node1 = context__.vals_i("node1");
      lcm_sym24__ = logical_gte(N_edges, 1);
      if (lcm_sym24__) {
        current_statement__ = 30;
        check_greater_or_equal(function__, "node1[sym1__]",
                               rvalue(node1, "node1", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 30;
          check_greater_or_equal(function__, "node1[sym1__]",
                                 node1[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 30;
      if (lcm_sym24__) {
        current_statement__ = 30;
        check_less_or_equal(function__, "node1[sym1__]",
                            rvalue(node1, "node1", index_uni(1)), N);
        for (int sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 30;
          check_less_or_equal(function__, "node1[sym1__]",
                              node1[(sym1__ - 1)], N);
        }
      } 
      current_statement__ = 31;
      validate_non_negative_index("node2", "N_edges", N_edges);
      current_statement__ = 32;
      context__.validate_dims("data initialization","node2","int",
           std::vector<size_t>{static_cast<size_t>(N_edges)});
      node2 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      
      current_statement__ = 32;
      node2 = context__.vals_i("node2");
      current_statement__ = 32;
      if (lcm_sym24__) {
        current_statement__ = 32;
        check_greater_or_equal(function__, "node2[sym1__]",
                               rvalue(node2, "node2", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 32;
          check_greater_or_equal(function__, "node2[sym1__]",
                                 node2[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 32;
      if (lcm_sym24__) {
        current_statement__ = 32;
        check_less_or_equal(function__, "node2[sym1__]",
                            rvalue(node2, "node2", index_uni(1)), N);
        for (int sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 32;
          check_less_or_equal(function__, "node2[sym1__]",
                              node2[(sym1__ - 1)], N);
        }
      } 
      current_statement__ = 33;
      validate_non_negative_index("E", "N", N);
      current_statement__ = 34;
      context__.validate_dims("data initialization","E","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      E__ = Eigen::Matrix<double, -1, 1>(N);
      new (&E) Eigen::Map<Eigen::Matrix<double, -1, 1>>(E__.data(), N);
      
      {
        std::vector<double> E_flat__;
        current_statement__ = 34;
        E_flat__ = context__.vals_r("E");
        current_statement__ = 34;
        pos__ = 1;
        lcm_sym23__ = logical_gte(N, 1);
        if (lcm_sym23__) {
          current_statement__ = 34;
          assign(E, rvalue(E_flat__, "E_flat__", index_uni(1)),
            "assigning variable E", index_uni(1));
          current_statement__ = 34;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 34;
            assign(E, E_flat__[(pos__ - 1)],
              "assigning variable E", index_uni(sym1__));
            current_statement__ = 34;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 34;
      if (lcm_sym23__) {
        current_statement__ = 34;
        check_greater_or_equal(function__, "E[sym1__]",
                               rvalue(E, "E", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 34;
          check_greater_or_equal(function__, "E[sym1__]", E[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 35;
      validate_non_negative_index("log_E", "N", N);
      current_statement__ = 36;
      log_E__ = Eigen::Matrix<double, -1, 1>(N);
      new (&log_E) Eigen::Map<Eigen::Matrix<double, -1, 1>>(log_E__.data(), N);
      stan::math::fill(log_E, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 36;
      assign(log_E, stan::math::log(E), "assigning variable log_E");
      current_statement__ = 37;
      phi_std_raw_1dim__ = std::numeric_limits<int>::min();
      
      lcm_sym25__ = (N - 1);
      phi_std_raw_1dim__ = lcm_sym25__;
      current_statement__ = 37;
      validate_non_negative_index("phi_std_raw", "N - 1", lcm_sym25__);
      current_statement__ = 38;
      validate_non_negative_index("phi", "N", N);
      current_statement__ = 39;
      validate_non_negative_index("theta", "N", N);
      current_statement__ = 40;
      validate_non_negative_index("theta_std", "N", N);
      current_statement__ = 41;
      validate_non_negative_index("x", "N", N);
      current_statement__ = 42;
      validate_non_negative_index("y", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + phi_std_raw_1dim__;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail4_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      Eigen::Matrix<double, -1, 1> lcm_sym18__;
      double lcm_sym17__;
      int lcm_sym22__;
      local_scalar_t__ tau_phi;
      current_statement__ = 1;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                  0, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_std_raw;
      lcm_sym22__ = (N - 1);
      phi_std_raw = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                      lcm_sym22__);
      local_scalar_t__ sigma_phi;
      lcm_sym21__ = inv_sqrt(tau_phi);
      sigma_phi = lcm_sym21__;
      Eigen::Matrix<local_scalar_t__, -1, 1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(phi, DUMMY_VAR__);
      
      current_statement__ = 5;
      assign(phi, phi_std_raw,
        "assigning variable phi", index_min_max(1, lcm_sym22__));
      current_statement__ = 6;
      assign(phi, -sum(phi_std_raw), "assigning variable phi", index_uni(N));
      current_statement__ = 7;
      assign(phi, multiply(stan::model::deep_copy(phi), lcm_sym21__),
        "assigning variable phi");
      current_statement__ = 3;
      check_greater_or_equal(function__, "sigma_phi", lcm_sym21__, 0);
      {
        current_statement__ = 25;
        lp_accum__.add(
          (-0.5 *
            dot_self(
              subtract(rvalue(phi, "phi", index_multi(node1)),
                rvalue(phi, "phi", index_multi(node2))))));
        current_statement__ = 26;
        lp_accum__.add(gamma_lpdf<propto__>(tau_phi, 1, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail4_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym12__;
      double lcm_sym11__;
      Eigen::Matrix<double, -1, 1> lcm_sym10__;
      Eigen::Matrix<double, -1, 1> lcm_sym9__;
      double lcm_sym14__;
      double lcm_sym13__;
      int lcm_sym8__;
      int lcm_sym7__;
      double lcm_sym6__;
      int lcm_sym15__;
      int lcm_sym4__;
      double tau_phi;
      current_statement__ = 1;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                  0, lp__);
      Eigen::Matrix<double, -1, 1> phi_std_raw;
      lcm_sym15__ = (N - 1);
      phi_std_raw = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                      lcm_sym15__);
      double sigma_phi;
      sigma_phi = std::numeric_limits<double>::quiet_NaN();
      
      Eigen::Matrix<double, -1, 1> phi;
      phi = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(phi, std::numeric_limits<double>::quiet_NaN());
      
      out__.write(tau_phi);
      out__.write(phi_std_raw);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym11__ = inv_sqrt(tau_phi);
      sigma_phi = lcm_sym11__;
      current_statement__ = 5;
      assign(phi, phi_std_raw,
        "assigning variable phi", index_min_max(1, lcm_sym15__));
      current_statement__ = 6;
      assign(phi, -sum(phi_std_raw), "assigning variable phi", index_uni(N));
      current_statement__ = 7;
      assign(phi, multiply(stan::model::deep_copy(phi), lcm_sym11__),
        "assigning variable phi");
      current_statement__ = 3;
      check_greater_or_equal(function__, "sigma_phi", lcm_sym11__, 0);
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym11__);
        out__.write(phi);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double beta0;
      beta0 = std::numeric_limits<double>::quiet_NaN();
      
      double beta1;
      beta1 = std::numeric_limits<double>::quiet_NaN();
      
      double tau_theta;
      tau_theta = std::numeric_limits<double>::quiet_NaN();
      
      double sigma_theta;
      sigma_theta = std::numeric_limits<double>::quiet_NaN();
      
      Eigen::Matrix<double, -1, 1> theta;
      theta = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(theta, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> theta_std;
      theta_std = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(theta_std, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> x;
      x = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(x, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<int> y;
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 16;
      beta0 = normal_rng(0, 1, base_rng__);
      current_statement__ = 17;
      beta1 = normal_rng(0, 1, base_rng__);
      lcm_sym4__ = logical_gte(N, 1);
      if (lcm_sym4__) {
        current_statement__ = 18;
        assign(theta_std, normal_rng(0, 1, base_rng__),
          "assigning variable theta_std", index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 18;
          assign(theta_std, normal_rng(0, 1, base_rng__),
            "assigning variable theta_std", index_uni(i));
        }
      } 
      current_statement__ = 20;
      tau_theta = gamma_rng(3.2761, 1.81, base_rng__);
      lcm_sym12__ = inv_sqrt(tau_theta);
      sigma_theta = lcm_sym12__;
      assign(lcm_sym10__, multiply(theta_std, lcm_sym12__),
        "assigning variable lcm_sym10__");
      assign(theta, lcm_sym10__, "assigning variable theta");
      current_statement__ = 24;
      if (lcm_sym4__) {
        current_statement__ = 21;
        assign(x, normal_rng(0, 1, base_rng__),
          "assigning variable x", index_uni(1));
        current_statement__ = 22;
        assign(y,
          poisson_log_rng(
            ((stan::math::fma(beta1, rvalue(x, "x", index_uni(1)),
                (rvalue(stan::math::log(E), "log(E)", index_uni(1)) + beta0))
               + rvalue(phi, "phi", index_uni(1))) +
              rvalue(lcm_sym10__, "lcm_sym10__", index_uni(1))), base_rng__),
          "assigning variable y", index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 21;
          assign(x, normal_rng(0, 1, base_rng__),
            "assigning variable x", index_uni(i));
          current_statement__ = 22;
          assign(y,
            poisson_log_rng(
              ((stan::math::fma(beta1, rvalue(x, "x", index_uni(i)),
                  (rvalue(stan::math::log(E), "log(E)", index_uni(i)) +
                    beta0)) + rvalue(phi, "phi", index_uni(i))) +
                rvalue(lcm_sym10__, "lcm_sym10__", index_uni(i))),
              base_rng__), "assigning variable y", index_uni(i));
        }
      } 
      current_statement__ = 10;
      check_greater_or_equal(function__, "tau_theta", tau_theta, 0);
      current_statement__ = 11;
      check_greater_or_equal(function__, "sigma_theta", lcm_sym12__, 0);
      out__.write(beta0);
      out__.write(beta1);
      out__.write(tau_theta);
      out__.write(lcm_sym12__);
      out__.write(lcm_sym10__);
      out__.write(theta_std);
      out__.write(x);
      out__.write(y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym3__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ tau_phi;
      tau_phi = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau_phi);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<local_scalar_t__, -1, 1>((N - 1));
      stan::math::fill(phi_std_raw, DUMMY_VAR__);
      
      lcm_sym3__ = (N - 1);
      if (logical_gte(lcm_sym3__, 1)) {
        assign(phi_std_raw, in__.read<local_scalar_t__>(),
          "assigning variable phi_std_raw", index_uni(1));
        for (int sym1__ = 2; sym1__ <= lcm_sym3__; ++sym1__) {
          assign(phi_std_raw, in__.read<local_scalar_t__>(),
            "assigning variable phi_std_raw", index_uni(sym1__));
        }
      } 
      out__.write(phi_std_raw);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"tau_phi", "phi_std_raw", "sigma_phi",
      "phi", "beta0", "beta1", "tau_theta", "sigma_theta", "theta",
      "theta_std", "x", "y"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(phi_std_raw_1dim__)},
      std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym36__ = 1; sym36__ <= phi_std_raw_1dim__; ++sym36__) {
      {
        param_names__.emplace_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym36__));
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym36__ = 1; sym36__ <= N; ++sym36__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym36__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "beta0");
      param_names__.emplace_back(std::string() + "beta1");
      param_names__.emplace_back(std::string() + "tau_theta");
      param_names__.emplace_back(std::string() + "sigma_theta");
      for (int sym36__ = 1; sym36__ <= N; ++sym36__) {
        {
          param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym36__));
        } 
      }
      for (int sym36__ = 1; sym36__ <= N; ++sym36__) {
        {
          param_names__.emplace_back(std::string() + "theta_std" + '.' + std::to_string(sym36__));
        } 
      }
      for (int sym36__ = 1; sym36__ <= N; ++sym36__) {
        {
          param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym36__));
        } 
      }
      for (int sym36__ = 1; sym36__ <= N; ++sym36__) {
        {
          param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym36__));
        } 
      }
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym36__ = 1; sym36__ <= phi_std_raw_1dim__; ++sym36__) {
      {
        param_names__.emplace_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym36__));
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym36__ = 1; sym36__ <= N; ++sym36__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym36__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "beta0");
      param_names__.emplace_back(std::string() + "beta1");
      param_names__.emplace_back(std::string() + "tau_theta");
      param_names__.emplace_back(std::string() + "sigma_theta");
      for (int sym36__ = 1; sym36__ <= N; ++sym36__) {
        {
          param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym36__));
        } 
      }
      for (int sym36__ = 1; sym36__ <= N; ++sym36__) {
        {
          param_names__.emplace_back(std::string() + "theta_std" + '.' + std::to_string(sym36__));
        } 
      }
      for (int sym36__ = 1; sym36__ <= N; ++sym36__) {
        {
          param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym36__));
        } 
      }
      for (int sym36__ = 1; sym36__ <= N; ++sym36__) {
        {
          param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym36__));
        } 
      }
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(phi_std_raw_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"sigma_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(phi_std_raw_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"sigma_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + phi_std_raw_1dim__);
      const size_t num_transformed = (1 + N);
      const size_t num_gen_quantities = 
  (((((((1 + 1) + 1) + 1) + N) + N) + N) + N);
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + phi_std_raw_1dim__);
      const size_t num_transformed = (1 + N);
      const size_t num_gen_quantities = 
  (((((((1 + 1) + 1) + 1) + N) + N) + N) + N);
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"tau_phi", "phi_std_raw"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{1,
       phi_std_raw_1dim__};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail4_model_namespace::expr_prop_fail4_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail4_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail5.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail5_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 70> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail5.stan', line 71, column 2 to column 33)",
 " (in 'expr-prop-fail5.stan', line 72, column 2 to column 31)",
 " (in 'expr-prop-fail5.stan', line 73, column 2 to column 23)",
 " (in 'expr-prop-fail5.stan', line 74, column 2 to column 30)",
 " (in 'expr-prop-fail5.stan', line 80, column 2 to column 51)",
 " (in 'expr-prop-fail5.stan', line 81, column 2 to column 49)",
 " (in 'expr-prop-fail5.stan', line 82, column 2 to column 49)",
 " (in 'expr-prop-fail5.stan', line 83, column 2 to column 10)",
 " (in 'expr-prop-fail5.stan', line 89, column 6 to column 20)",
 " (in 'expr-prop-fail5.stan', line 90, column 6 to column 18)",
 " (in 'expr-prop-fail5.stan', line 88, column 32 to line 91, column 5)",
 " (in 'expr-prop-fail5.stan', line 93, column 6 to column 45)",
 " (in 'expr-prop-fail5.stan', line 94, column 6 to column 23)",
 " (in 'expr-prop-fail5.stan', line 92, column 38 to line 95, column 5)",
 " (in 'expr-prop-fail5.stan', line 92, column 4 to line 95, column 5)",
 " (in 'expr-prop-fail5.stan', line 87, column 20 to line 96, column 3)",
 " (in 'expr-prop-fail5.stan', line 26, column 11 to column 15)",
 " (in 'expr-prop-fail5.stan', line 26, column 17 to column 28)",
 " (in 'expr-prop-fail5.stan', line 26, column 4 to column 34)",
 " (in 'expr-prop-fail5.stan', line 29, column 6 to column 32)",
 " (in 'expr-prop-fail5.stan', line 32, column 8 to column 37)",
 " (in 'expr-prop-fail5.stan', line 33, column 8 to column 32)",
 " (in 'expr-prop-fail5.stan', line 43, column 8 to line 44, column 83)",
 " (in 'expr-prop-fail5.stan', line 30, column 37 to line 45, column 7)",
 " (in 'expr-prop-fail5.stan', line 28, column 22 to line 46, column 5)",
 " (in 'expr-prop-fail5.stan', line 25, column 47 to line 48, column 3)",
 " (in 'expr-prop-fail5.stan', line 124, column 2 to column 23)",
 " (in 'expr-prop-fail5.stan', line 109, column 2 to column 29)",
 " (in 'expr-prop-fail5.stan', line 115, column 8 to column 37)",
 " (in 'expr-prop-fail5.stan', line 116, column 8 to column 41)",
 " (in 'expr-prop-fail5.stan', line 114, column 40 to line 117, column 7)",
 " (in 'expr-prop-fail5.stan', line 118, column 6 to column 37)",
 " (in 'expr-prop-fail5.stan', line 113, column 22 to line 119, column 5)",
 " (in 'expr-prop-fail5.stan', line 112, column 20 to line 120, column 3)",
 " (in 'expr-prop-fail5.stan', line 112, column 2 to line 120, column 3)",
 " (in 'expr-prop-fail5.stan', line 52, column 2 to column 20)",
 " (in 'expr-prop-fail5.stan', line 53, column 2 to column 27)",
 " (in 'expr-prop-fail5.stan', line 54, column 25 to column 29)",
 " (in 'expr-prop-fail5.stan', line 54, column 31 to column 42)",
 " (in 'expr-prop-fail5.stan', line 54, column 2 to column 44)",
 " (in 'expr-prop-fail5.stan', line 58, column 2 to column 38)",
 " (in 'expr-prop-fail5.stan', line 60, column 39 to column 43)",
 " (in 'expr-prop-fail5.stan', line 60, column 2 to column 45)",
 " (in 'expr-prop-fail5.stan', line 61, column 38 to column 42)",
 " (in 'expr-prop-fail5.stan', line 61, column 2 to column 44)",
 " (in 'expr-prop-fail5.stan', line 8, column 8 to column 17)",
 " (in 'expr-prop-fail5.stan', line 7, column 6 to line 8, column 17)",
 " (in 'expr-prop-fail5.stan', line 5, column 31 to line 10, column 3)",
 " (in 'expr-prop-fail5.stan', line 65, column 4 to column 35)",
 " (in 'expr-prop-fail5.stan', line 64, column 2 to line 65, column 35)",
 " (in 'expr-prop-fail5.stan', line 15, column 6 to column 32)",
 " (in 'expr-prop-fail5.stan', line 19, column 8 to column 17)",
 " (in 'expr-prop-fail5.stan', line 18, column 6 to line 19, column 17)",
 " (in 'expr-prop-fail5.stan', line 13, column 37 to line 20, column 5)",
 " (in 'expr-prop-fail5.stan', line 12, column 30 to line 22, column 3)",
 " (in 'expr-prop-fail5.stan', line 67, column 4 to column 33)",
 " (in 'expr-prop-fail5.stan', line 66, column 2 to line 67, column 33)",
 " (in 'expr-prop-fail5.stan', line 73, column 9 to column 13)",
 " (in 'expr-prop-fail5.stan', line 80, column 26 to column 30)",
 " (in 'expr-prop-fail5.stan', line 80, column 32 to column 45)",
 " (in 'expr-prop-fail5.stan', line 81, column 26 to column 30)",
 " (in 'expr-prop-fail5.stan', line 81, column 32 to column 45)",
 " (in 'expr-prop-fail5.stan', line 82, column 26 to column 30)",
 " (in 'expr-prop-fail5.stan', line 82, column 32 to column 43)",
 " (in 'expr-prop-fail5.stan', line 9, column 4 to column 13)",
 " (in 'expr-prop-fail5.stan', line 21, column 4 to column 13)",
 " (in 'expr-prop-fail5.stan', line 30, column 6 to line 45, column 7)",
 " (in 'expr-prop-fail5.stan', line 28, column 4 to line 46, column 5)",
 " (in 'expr-prop-fail5.stan', line 47, column 4 to column 15)"};

int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) ;

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) ;

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p,
                const T3__& phi, std::ostream* pstream__) ;

struct prob_uncaptured_functor__ {
template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
operator()(const int& nind, const int& n_occasions, const T2__& p,
           const T3__& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}
};

int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym29__;
    int lcm_sym28__;
    int lcm_sym27__;
    int lcm_sym26__;
    {
      lcm_sym27__ = size(y_i);
      if (logical_gte(lcm_sym27__, 1)) {
        current_statement__ = 47;
        if (rvalue(y_i, "y_i", index_uni(1))) {
          current_statement__ = 46;
          return 1;
        } 
        for (int k = 2; k <= lcm_sym27__; ++k) {
          current_statement__ = 47;
          if (rvalue(y_i, "y_i", index_uni(k))) {
            current_statement__ = 46;
            return k;
          } 
        }
      } 
      current_statement__ = 65;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym35__;
    int lcm_sym34__;
    int lcm_sym33__;
    int lcm_sym32__;
    int lcm_sym31__;
    int lcm_sym30__;
    {
      lcm_sym33__ = (size(y_i) - 1);
      if (logical_gte(lcm_sym33__, 0)) {
        int k;
        lcm_sym32__ = (size(y_i) - 0);
        current_statement__ = 53;
        if (y_i[(lcm_sym32__ - 1)]) {
          current_statement__ = 52;
          return lcm_sym32__;
        } 
        for (int k_rev = 1; k_rev <= lcm_sym33__; ++k_rev) {
          int k;
          lcm_sym31__ = (size(y_i) - k_rev);
          current_statement__ = 53;
          if (y_i[(lcm_sym31__ - 1)]) {
            current_statement__ = 52;
            return lcm_sym31__;
          } 
        }
      } 
      current_statement__ = 66;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  int current_statement__ = 0; 
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    double lcm_sym45__;
    double lcm_sym44__;
    double lcm_sym43__;
    double lcm_sym42__;
    int lcm_sym41__;
    int lcm_sym40__;
    int lcm_sym39__;
    int lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    {
      current_statement__ = 17;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 18;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      current_statement__ = 68;
      if (logical_gte(nind, 1)) {
        current_statement__ = 20;
        assign(chi, 1.0,
          "assigning variable chi", index_uni(1), index_uni(n_occasions));
        lcm_sym39__ = (n_occasions - 1);
        lcm_sym37__ = logical_gte(lcm_sym39__, 1);
        if (lcm_sym37__) {
          int t_curr;
          int t_next;
          t_next = std::numeric_limits<int>::min();
          
          lcm_sym41__ = (lcm_sym39__ + 1);
          current_statement__ = 23;
          assign(chi,
            stan::math::fma(
              (rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym39__)) *
                (1 -
                  rvalue(p, "p", index_uni(1), index_uni((lcm_sym41__ - 1))))),
              rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym41__)),
              (1 - rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym39__)))),
            "assigning variable chi", index_uni(1), index_uni(lcm_sym39__));
          for (int t = 2; t <= lcm_sym39__; ++t) {
            int t_curr;
            lcm_sym38__ = (n_occasions - t);
            int t_next;
            t_next = std::numeric_limits<int>::min();
            
            lcm_sym40__ = (lcm_sym38__ + 1);
            current_statement__ = 23;
            assign(chi,
              stan::math::fma(
                (rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym38__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(1), index_uni((lcm_sym40__ - 1))))),
                rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym40__)),
                (1 -
                  rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym38__)))),
              "assigning variable chi", index_uni(1), index_uni(lcm_sym38__));
          }
        } 
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 20;
          assign(chi, 1.0,
            "assigning variable chi", index_uni(i), index_uni(n_occasions));
          current_statement__ = 67;
          if (lcm_sym37__) {
            int t_curr;
            int t_next;
            t_next = std::numeric_limits<int>::min();
            
            lcm_sym41__ = (lcm_sym39__ + 1);
            current_statement__ = 23;
            assign(chi,
              stan::math::fma(
                (rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym39__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(i), index_uni((lcm_sym41__ - 1))))),
                rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym41__)),
                (1 -
                  rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym39__)))),
              "assigning variable chi", index_uni(i), index_uni(lcm_sym39__));
            for (int t = 2; t <= lcm_sym39__; ++t) {
              int t_curr;
              lcm_sym38__ = (n_occasions - t);
              int t_next;
              t_next = std::numeric_limits<int>::min();
              
              lcm_sym40__ = (lcm_sym38__ + 1);
              current_statement__ = 23;
              assign(chi,
                stan::math::fma(
                  (rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym38__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(i), index_uni((lcm_sym40__ - 1))))),
                  rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym40__)),
                  (1 -
                    rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym38__)))),
                "assigning variable chi", index_uni(i),
                                            index_uni(lcm_sym38__));
            }
          } 
        }
      } 
      current_statement__ = 69;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
class expr_prop_fail5_model final : public model_base_crtp<expr_prop_fail5_model> {

 private:
  int lcm_sym160__;
  int lcm_sym159__;
  int lcm_sym158__;
  int lcm_sym157__;
  int lcm_sym156__;
  int lcm_sym155__;
  int lcm_sym154__;
  int lcm_sym153__;
  int lcm_sym152__;
  int lcm_sym151__;
  int lcm_sym150__;
  int lcm_sym149__;
  int lcm_sym148__;
  int lcm_sym147__;
  int lcm_sym146__;
  int lcm_sym145__;
  int lcm_sym144__;
  int lcm_sym143__;
  int lcm_sym142__;
  int lcm_sym141__;
  int lcm_sym140__;
  int lcm_sym139__;
  int lcm_sym138__;
  int lcm_sym137__;
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last; 
  
 
 public:
  ~expr_prop_fail5_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail5_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail5_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail5_model_namespace::expr_prop_fail5_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 36;
      context__.validate_dims("data initialization","nind","int",
           std::vector<size_t>{});
      nind = std::numeric_limits<int>::min();
      
      current_statement__ = 36;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 36;
      check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 37;
      context__.validate_dims("data initialization","n_occasions","int",
           std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      
      current_statement__ = 37;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 37;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 2);
      current_statement__ = 38;
      validate_non_negative_index("y", "nind", nind);
      current_statement__ = 39;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 40;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(nind),
            static_cast<size_t>(n_occasions)});
      y = std::vector<std::vector<int>>(nind, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 40;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 40;
        pos__ = 1;
        lcm_sym137__ = logical_gte(n_occasions, 1);
        if (lcm_sym137__) {
          {
            lcm_sym138__ = logical_gte(nind, 1);
            if (lcm_sym138__) {
              current_statement__ = 40;
              assign(y, rvalue(y_flat__, "y_flat__", index_uni(1)),
                "assigning variable y", index_uni(1), index_uni(1));
              current_statement__ = 40;
              pos__ = 2;
              for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                current_statement__ = 40;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(sym2__), index_uni(1));
                current_statement__ = 40;
                pos__ = (pos__ + 1);
              }
            } 
            for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
              current_statement__ = 40;
              if (lcm_sym138__) {
                current_statement__ = 40;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(1), index_uni(sym1__));
                current_statement__ = 40;
                pos__ = (pos__ + 1);
                for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                  current_statement__ = 40;
                  assign(y, y_flat__[(pos__ - 1)],
                    "assigning variable y", index_uni(sym2__),
                                              index_uni(sym1__));
                  current_statement__ = 40;
                  pos__ = (pos__ + 1);
                }
              } 
            }
          }
        } else {
          lcm_sym138__ = logical_gte(nind, 1);
        }
      }
      current_statement__ = 40;
      if (lcm_sym138__) {
        current_statement__ = 40;
        if (lcm_sym137__) {
          current_statement__ = 40;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 rvalue(y, "y", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 40;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 40;
          if (lcm_sym137__) {
            current_statement__ = 40;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 40;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);
            }
          } 
        }
      } 
      current_statement__ = 40;
      if (lcm_sym138__) {
        current_statement__ = 40;
        if (lcm_sym137__) {
          current_statement__ = 40;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              rvalue(y, "y", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 40;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 40;
          if (lcm_sym137__) {
            current_statement__ = 40;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 40;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);
            }
          } 
        }
      } 
      current_statement__ = 41;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      
      lcm_sym139__ = (n_occasions - 1);
      n_occ_minus_1 = lcm_sym139__;
      current_statement__ = 42;
      validate_non_negative_index("first", "nind", nind);
      current_statement__ = 43;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 44;
      validate_non_negative_index("last", "nind", nind);
      current_statement__ = 45;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 50;
      if (lcm_sym138__) {
        int inline_sym17__;
        int inline_sym19__;
        inline_sym19__ = 0;
        for (int inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
          lcm_sym146__ = size(rvalue(y, "y", index_uni(1)));
          for (int inline_sym18__ = 1; inline_sym18__ <= lcm_sym146__;
               ++inline_sym18__) {
            current_statement__ = 47;
            if (rvalue(y, "y", index_uni(1))[(inline_sym18__ - 1)]) {
              inline_sym19__ = 1;
              inline_sym17__ = inline_sym18__;
              break;
            } 
          }
          if (inline_sym19__) {
            break;
          } 
          inline_sym19__ = 1;
          inline_sym17__ = 0;
          break;
        }
        assign(first, inline_sym17__,
          "assigning variable first", index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          int inline_sym17__;
          int inline_sym19__;
          inline_sym19__ = 0;
          for (int inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
            lcm_sym145__ = size(rvalue(y, "y", index_uni(i)));
            for (int inline_sym18__ = 1; inline_sym18__ <= lcm_sym145__;
                 ++inline_sym18__) {
              current_statement__ = 47;
              if (rvalue(y, "y", index_uni(i))[(inline_sym18__ - 1)]) {
                inline_sym19__ = 1;
                inline_sym17__ = inline_sym18__;
                break;
              } 
            }
            if (inline_sym19__) {
              break;
            } 
            inline_sym19__ = 1;
            inline_sym17__ = 0;
            break;
          }
          assign(first, inline_sym17__,
            "assigning variable first", index_uni(i));
        }
      } 
      current_statement__ = 57;
      if (lcm_sym138__) {
        int inline_sym21__;
        int inline_sym24__;
        inline_sym24__ = 0;
        for (int inline_sym25__ = 1; inline_sym25__ <= 1; ++inline_sym25__) {
          lcm_sym146__ = size(rvalue(y, "y", index_uni(1)));
          lcm_sym143__ = (lcm_sym146__ - 1);
          for (int inline_sym23__ = 0; inline_sym23__ <= lcm_sym143__;
               ++inline_sym23__) {
            int inline_sym22__;
            lcm_sym142__ = (lcm_sym146__ - inline_sym23__);
            inline_sym22__ = lcm_sym142__;
            current_statement__ = 53;
            if (rvalue(y, "y", index_uni(1))[(lcm_sym142__ - 1)]) {
              inline_sym24__ = 1;
              inline_sym21__ = lcm_sym142__;
              break;
            } 
          }
          if (inline_sym24__) {
            break;
          } 
          inline_sym24__ = 1;
          inline_sym21__ = 0;
          break;
        }
        assign(last, inline_sym21__, "assigning variable last", index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          int inline_sym21__;
          int inline_sym24__;
          inline_sym24__ = 0;
          for (int inline_sym25__ = 1; inline_sym25__ <= 1; ++inline_sym25__) {
            lcm_sym145__ = size(rvalue(y, "y", index_uni(i)));
            lcm_sym141__ = (lcm_sym145__ - 1);
            for (int inline_sym23__ = 0; inline_sym23__ <= lcm_sym141__;
                 ++inline_sym23__) {
              int inline_sym22__;
              lcm_sym140__ = (lcm_sym145__ - inline_sym23__);
              inline_sym22__ = lcm_sym140__;
              current_statement__ = 53;
              if (rvalue(y, "y", index_uni(i))[(lcm_sym140__ - 1)]) {
                inline_sym24__ = 1;
                inline_sym21__ = lcm_sym140__;
                break;
              } 
            }
            if (inline_sym24__) {
              break;
            } 
            inline_sym24__ = 1;
            inline_sym21__ = 0;
            break;
          }
          assign(last, inline_sym21__,
            "assigning variable last", index_uni(i));
        }
      } 
      current_statement__ = 43;
      if (lcm_sym138__) {
        current_statement__ = 43;
        check_greater_or_equal(function__, "first[sym1__]",
                               rvalue(first, "first", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 43;
          check_greater_or_equal(function__, "first[sym1__]",
                                 first[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 43;
      if (lcm_sym138__) {
        current_statement__ = 43;
        check_less_or_equal(function__, "first[sym1__]",
                            rvalue(first, "first", index_uni(1)), n_occasions);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 43;
          check_less_or_equal(function__, "first[sym1__]",
                              first[(sym1__ - 1)], n_occasions);
        }
      } 
      current_statement__ = 45;
      if (lcm_sym138__) {
        current_statement__ = 45;
        check_greater_or_equal(function__, "last[sym1__]",
                               rvalue(last, "last", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 45;
          check_greater_or_equal(function__, "last[sym1__]",
                                 last[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 45;
      if (lcm_sym138__) {
        current_statement__ = 45;
        check_less_or_equal(function__, "last[sym1__]",
                            rvalue(last, "last", index_uni(1)), n_occasions);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 45;
          check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                              n_occasions);
        }
      } 
      current_statement__ = 58;
      validate_non_negative_index("epsilon", "nind", nind);
      current_statement__ = 59;
      validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 60;
      validate_non_negative_index("phi", "n_occ_minus_1", lcm_sym139__);
      current_statement__ = 61;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 62;
      validate_non_negative_index("p", "n_occ_minus_1", lcm_sym139__);
      current_statement__ = 63;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 64;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + nind + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail5_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym136__;
      double lcm_sym135__;
      double lcm_sym134__;
      double lcm_sym133__;
      double lcm_sym132__;
      double lcm_sym131__;
      double lcm_sym130__;
      double lcm_sym129__;
      int lcm_sym128__;
      int lcm_sym127__;
      double lcm_sym126__;
      double lcm_sym125__;
      double lcm_sym124__;
      double lcm_sym123__;
      int lcm_sym122__;
      int lcm_sym121__;
      double lcm_sym120__;
      local_scalar_t__ lcm_sym119__;
      local_scalar_t__ lcm_sym118__;
      local_scalar_t__ lcm_sym117__;
      double lcm_sym116__;
      double lcm_sym115__;
      double lcm_sym114__;
      double lcm_sym113__;
      double lcm_sym112__;
      double lcm_sym111__;
      double lcm_sym110__;
      double lcm_sym109__;
      double lcm_sym108__;
      double lcm_sym107__;
      double lcm_sym106__;
      double lcm_sym105__;
      int lcm_sym104__;
      int lcm_sym103__;
      int lcm_sym102__;
      int lcm_sym101__;
      int lcm_sym100__;
      int lcm_sym99__;
      int lcm_sym98__;
      int lcm_sym97__;
      int lcm_sym96__;
      int lcm_sym95__;
      int lcm_sym94__;
      int lcm_sym93__;
      int lcm_sym92__;
      int lcm_sym91__;
      int lcm_sym90__;
      int lcm_sym89__;
      int lcm_sym88__;
      int lcm_sym87__;
      int lcm_sym86__;
      int lcm_sym85__;
      int lcm_sym84__;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                   0, 1, lp__);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                 0, 1, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon;
      current_statement__ = 3;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  nind);
      local_scalar_t__ sigma;
      current_statement__ = 4;
      sigma = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 5, lp__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(p, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      local_scalar_t__ mu;
      lcm_sym119__ = logit(mean_phi);
      mu = lcm_sym119__;
      lcm_sym85__ = logical_gte(nind, 1);
      if (lcm_sym85__) {
        lcm_sym122__ = rvalue(first, "first", index_uni(1));
        lcm_sym98__ = (lcm_sym122__ - 1);
        if (logical_gte(lcm_sym98__, 1)) {
          current_statement__ = 9;
          assign(phi, 0, "assigning variable phi", index_uni(1), index_uni(1));
          current_statement__ = 10;
          assign(p, 0, "assigning variable p", index_uni(1), index_uni(1));
          for (int t = 2; t <= lcm_sym98__; ++t) {
            current_statement__ = 9;
            assign(phi, 0,
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 10;
            assign(p, 0, "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        lcm_sym96__ = (n_occasions - 1);
        if (logical_gte(lcm_sym96__, lcm_sym122__)) {
          lcm_sym118__ = inv_logit(
                           (lcm_sym119__ +
                             rvalue(epsilon, "epsilon", index_uni(1))));
          assign(phi, lcm_sym118__,
            "assigning variable phi", index_uni(1), index_uni(lcm_sym122__));
          lcm_sym104__ = (lcm_sym122__ + 1);
          assign(p, mean_p,
            "assigning variable p", index_uni(1), index_uni(lcm_sym122__));
          for (int t = lcm_sym104__; t <= lcm_sym96__; ++t) {
            current_statement__ = 12;
            assign(phi, lcm_sym118__,
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 13;
            assign(p, mean_p,
              "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        for (int i = 2; i <= nind; ++i) {
          lcm_sym121__ = rvalue(first, "first", index_uni(i));
          lcm_sym97__ = (lcm_sym121__ - 1);
          if (logical_gte(lcm_sym97__, 1)) {
            current_statement__ = 9;
            assign(phi, 0,
              "assigning variable phi", index_uni(i), index_uni(1));
            current_statement__ = 10;
            assign(p, 0, "assigning variable p", index_uni(i), index_uni(1));
            for (int t = 2; t <= lcm_sym97__; ++t) {
              current_statement__ = 9;
              assign(phi, 0,
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 10;
              assign(p, 0, "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
          current_statement__ = 15;
          if (logical_gte(lcm_sym96__, lcm_sym121__)) {
            lcm_sym117__ = inv_logit(
                             (lcm_sym119__ +
                               rvalue(epsilon, "epsilon", index_uni(i))));
            assign(phi, lcm_sym117__,
              "assigning variable phi", index_uni(i), index_uni(lcm_sym121__));
            lcm_sym103__ = (lcm_sym121__ + 1);
            assign(p, mean_p,
              "assigning variable p", index_uni(i), index_uni(lcm_sym121__));
            for (int t = lcm_sym103__; t <= lcm_sym96__; ++t) {
              current_statement__ = 12;
              assign(phi, lcm_sym117__,
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 13;
              assign(p, mean_p,
                "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
        }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym9__;
      int inline_sym15__;
      inline_sym15__ = 0;
      for (int inline_sym16__ = 1; inline_sym16__ <= 1; ++inline_sym16__) {
        current_statement__ = 17;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 18;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym10__;
        inline_sym10__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        stan::math::fill(inline_sym10__, DUMMY_VAR__);
        
        for (int inline_sym14__ = 1; inline_sym14__ <= nind; ++inline_sym14__) {
          current_statement__ = 20;
          assign(inline_sym10__, 1.0,
            "assigning variable inline_sym10__", index_uni(inline_sym14__),
                                                   index_uni(n_occasions));
          lcm_sym96__ = (n_occasions - 1);
          if (logical_gte(lcm_sym96__, 1)) {
            int inline_sym11__;
            inline_sym11__ = std::numeric_limits<int>::min();
            
            int inline_sym12__;
            inline_sym12__ = std::numeric_limits<int>::min();
            
            lcm_sym100__ = (lcm_sym96__ + 1);
            current_statement__ = 23;
            assign(inline_sym10__,
              stan::math::fma(
                (rvalue(phi, "phi",
                   index_uni(inline_sym14__), index_uni(lcm_sym96__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(inline_sym14__),
                        index_uni((lcm_sym100__ - 1))))),
                rvalue(inline_sym10__, "inline_sym10__",
                  index_uni(inline_sym14__), index_uni(lcm_sym100__)),
                (1 -
                  rvalue(phi, "phi",
                    index_uni(inline_sym14__), index_uni(lcm_sym96__)))),
              "assigning variable inline_sym10__", index_uni(inline_sym14__),
                                                     index_uni(lcm_sym96__));
            for (int inline_sym13__ = 2; inline_sym13__ <= lcm_sym96__;
                 ++inline_sym13__) {
              int inline_sym11__;
              inline_sym11__ = std::numeric_limits<int>::min();
              
              int inline_sym12__;
              inline_sym12__ = std::numeric_limits<int>::min();
              
              lcm_sym95__ = (n_occasions - inline_sym13__);
              lcm_sym99__ = (lcm_sym95__ + 1);
              current_statement__ = 23;
              assign(inline_sym10__,
                stan::math::fma(
                  (rvalue(phi, "phi",
                     index_uni(inline_sym14__), index_uni(lcm_sym95__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(inline_sym14__),
                          index_uni((lcm_sym99__ - 1))))),
                  rvalue(inline_sym10__, "inline_sym10__",
                    index_uni(inline_sym14__), index_uni(lcm_sym99__)),
                  (1 -
                    rvalue(phi, "phi",
                      index_uni(inline_sym14__), index_uni(lcm_sym95__)))),
                "assigning variable inline_sym10__", index_uni(inline_sym14__),
                                                       index_uni(lcm_sym95__));
            }
          } 
          if (inline_sym15__) {
            break;
          } 
        }
        if (inline_sym15__) {
          break;
        } 
        inline_sym15__ = 1;
        assign(inline_sym9__, inline_sym10__,
          "assigning variable inline_sym9__");
        break;
      }
      assign(chi, inline_sym9__, "assigning variable chi");
      current_statement__ = 5;
      if (lcm_sym85__) {
        lcm_sym96__ = (n_occasions - 1);
        lcm_sym86__ = logical_gte(lcm_sym96__, 1);
        if (lcm_sym86__) {
          current_statement__ = 5;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi, "phi",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym86__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
              current_statement__ = 5;
              check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                     rvalue(phi, "phi",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym85__) {
        lcm_sym96__ = (n_occasions - 1);
        lcm_sym86__ = logical_gte(lcm_sym96__, 1);
        if (lcm_sym86__) {
          current_statement__ = 5;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi, "phi", index_uni(1), index_uni(1)),
                              1);
          for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym86__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
              current_statement__ = 5;
              check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                  rvalue(phi, "phi",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 6;
      if (lcm_sym85__) {
        lcm_sym96__ = (n_occasions - 1);
        lcm_sym86__ = logical_gte(lcm_sym96__, 1);
        if (lcm_sym86__) {
          current_statement__ = 6;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p, "p", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
            current_statement__ = 6;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 6;
          if (lcm_sym86__) {
            current_statement__ = 6;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
              current_statement__ = 6;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(p, "p",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 6;
      if (lcm_sym85__) {
        lcm_sym96__ = (n_occasions - 1);
        lcm_sym86__ = logical_gte(lcm_sym96__, 1);
        if (lcm_sym86__) {
          current_statement__ = 6;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p, "p", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
            current_statement__ = 6;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 6;
          if (lcm_sym86__) {
            current_statement__ = 6;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
              current_statement__ = 6;
              check_less_or_equal(function__, "p[sym1__, sym2__]",
                                  rvalue(p, "p",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 7;
      if (lcm_sym85__) {
        lcm_sym84__ = logical_gte(n_occasions, 1);
        if (lcm_sym84__) {
          current_statement__ = 7;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(inline_sym9__, "inline_sym9__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 7;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym9__, "inline_sym9__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym84__) {
            current_statement__ = 7;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym9__, "inline_sym9__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 7;
              check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                     rvalue(inline_sym9__, "inline_sym9__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 7;
      if (lcm_sym85__) {
        lcm_sym84__ = logical_gte(n_occasions, 1);
        if (lcm_sym84__) {
          current_statement__ = 7;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(inline_sym9__, "inline_sym9__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 7;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym9__, "inline_sym9__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym84__) {
            current_statement__ = 7;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym9__, "inline_sym9__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 7;
              check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                  rvalue(inline_sym9__, "inline_sym9__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      {
        current_statement__ = 28;
        lp_accum__.add(normal_lpdf<propto__>(epsilon, 0, sigma));
        current_statement__ = 35;
        if (lcm_sym85__) {
          lcm_sym122__ = rvalue(first, "first", index_uni(1));
          if (logical_gt(lcm_sym122__, 0)) {
            lcm_sym128__ = rvalue(last, "last", index_uni(1));
            if (logical_gte(lcm_sym128__, (lcm_sym122__ + 1))) {
              current_statement__ = 29;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(phi, "phi",
                    index_uni(1), index_uni(((lcm_sym122__ + 1) - 1)))));
              lcm_sym102__ = ((lcm_sym122__ + 1) + 1);
              lp_accum__.add(
                bernoulli_lpmf<propto__>(
                  rvalue(y, "y", index_uni(1), index_uni((lcm_sym122__ + 1))),
                  rvalue(p, "p",
                    index_uni(1), index_uni(((lcm_sym122__ + 1) - 1)))));
              for (int t = lcm_sym102__; t <= lcm_sym128__; ++t) {
                current_statement__ = 29;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(phi, "phi", index_uni(1), index_uni((t - 1)))));
                current_statement__ = 30;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(
                    rvalue(y, "y", index_uni(1), index_uni(t)),
                    rvalue(p, "p", index_uni(1), index_uni((t - 1)))));
              }
            } 
            current_statement__ = 32;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                rvalue(inline_sym9__, "inline_sym9__",
                  index_uni(1), index_uni(lcm_sym128__))));
          } 
          for (int i = 2; i <= nind; ++i) {
            lcm_sym121__ = rvalue(first, "first", index_uni(i));
            if (logical_gt(lcm_sym121__, 0)) {
              lcm_sym127__ = rvalue(last, "last", index_uni(i));
              if (logical_gte(lcm_sym127__, (lcm_sym121__ + 1))) {
                current_statement__ = 29;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(phi, "phi",
                      index_uni(i), index_uni(((lcm_sym121__ + 1) - 1)))));
                lcm_sym101__ = ((lcm_sym121__ + 1) + 1);
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(
                    rvalue(y, "y",
                      index_uni(i), index_uni((lcm_sym121__ + 1))),
                    rvalue(p, "p",
                      index_uni(i), index_uni(((lcm_sym121__ + 1) - 1)))));
                for (int t = lcm_sym101__; t <= lcm_sym127__; ++t) {
                  current_statement__ = 29;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(1,
                      rvalue(phi, "phi", index_uni(i), index_uni((t - 1)))));
                  current_statement__ = 30;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(
                      rvalue(y, "y", index_uni(i), index_uni(t)),
                      rvalue(p, "p", index_uni(i), index_uni((t - 1)))));
                }
              } 
              current_statement__ = 32;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(inline_sym9__, "inline_sym9__",
                    index_uni(i), index_uni(lcm_sym127__))));
            } 
          }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail5_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym83__;
      double lcm_sym82__;
      double lcm_sym81__;
      double lcm_sym80__;
      double lcm_sym79__;
      double lcm_sym78__;
      double lcm_sym77__;
      double lcm_sym76__;
      double lcm_sym75__;
      double lcm_sym74__;
      double lcm_sym73__;
      double lcm_sym72__;
      int lcm_sym71__;
      int lcm_sym70__;
      double lcm_sym69__;
      double lcm_sym68__;
      local_scalar_t__ lcm_sym67__;
      local_scalar_t__ lcm_sym66__;
      double lcm_sym65__;
      double lcm_sym64__;
      int lcm_sym63__;
      int lcm_sym62__;
      int lcm_sym61__;
      int lcm_sym60__;
      int lcm_sym59__;
      int lcm_sym58__;
      int lcm_sym57__;
      int lcm_sym56__;
      int lcm_sym55__;
      int lcm_sym54__;
      int lcm_sym53__;
      int lcm_sym52__;
      int lcm_sym51__;
      int lcm_sym50__;
      int lcm_sym49__;
      int lcm_sym48__;
      int lcm_sym47__;
      double mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                   0, 1, lp__);
      double mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                 0, 1, lp__);
      Eigen::Matrix<double, -1, 1> epsilon;
      current_statement__ = 3;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  nind);
      double sigma;
      current_statement__ = 4;
      sigma = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 5, lp__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(p, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      double mu;
      mu = std::numeric_limits<double>::quiet_NaN();
      
      out__.write(mean_phi);
      out__.write(mean_p);
      out__.write(epsilon);
      out__.write(sigma);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym68__ = logit(mean_phi);
      mu = lcm_sym68__;
      lcm_sym48__ = logical_gte(nind, 1);
      if (lcm_sym48__) {
        lcm_sym71__ = rvalue(first, "first", index_uni(1));
        lcm_sym57__ = (lcm_sym71__ - 1);
        if (logical_gte(lcm_sym57__, 1)) {
          current_statement__ = 9;
          assign(phi, 0, "assigning variable phi", index_uni(1), index_uni(1));
          current_statement__ = 10;
          assign(p, 0, "assigning variable p", index_uni(1), index_uni(1));
          for (int t = 2; t <= lcm_sym57__; ++t) {
            current_statement__ = 9;
            assign(phi, 0,
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 10;
            assign(p, 0, "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        lcm_sym55__ = (n_occasions - 1);
        if (logical_gte(lcm_sym55__, lcm_sym71__)) {
          lcm_sym67__ = inv_logit(
                          (lcm_sym68__ +
                            rvalue(epsilon, "epsilon", index_uni(1))));
          assign(phi, lcm_sym67__,
            "assigning variable phi", index_uni(1), index_uni(lcm_sym71__));
          lcm_sym63__ = (lcm_sym71__ + 1);
          assign(p, mean_p,
            "assigning variable p", index_uni(1), index_uni(lcm_sym71__));
          for (int t = lcm_sym63__; t <= lcm_sym55__; ++t) {
            current_statement__ = 12;
            assign(phi, lcm_sym67__,
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 13;
            assign(p, mean_p,
              "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        for (int i = 2; i <= nind; ++i) {
          lcm_sym70__ = rvalue(first, "first", index_uni(i));
          lcm_sym56__ = (lcm_sym70__ - 1);
          if (logical_gte(lcm_sym56__, 1)) {
            current_statement__ = 9;
            assign(phi, 0,
              "assigning variable phi", index_uni(i), index_uni(1));
            current_statement__ = 10;
            assign(p, 0, "assigning variable p", index_uni(i), index_uni(1));
            for (int t = 2; t <= lcm_sym56__; ++t) {
              current_statement__ = 9;
              assign(phi, 0,
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 10;
              assign(p, 0, "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
          current_statement__ = 15;
          if (logical_gte(lcm_sym55__, lcm_sym70__)) {
            lcm_sym66__ = inv_logit(
                            (lcm_sym68__ +
                              rvalue(epsilon, "epsilon", index_uni(i))));
            assign(phi, lcm_sym66__,
              "assigning variable phi", index_uni(i), index_uni(lcm_sym70__));
            lcm_sym62__ = (lcm_sym70__ + 1);
            assign(p, mean_p,
              "assigning variable p", index_uni(i), index_uni(lcm_sym70__));
            for (int t = lcm_sym62__; t <= lcm_sym55__; ++t) {
              current_statement__ = 12;
              assign(phi, lcm_sym66__,
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 13;
              assign(p, mean_p,
                "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
        }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym1__;
      int inline_sym7__;
      inline_sym7__ = 0;
      for (int inline_sym8__ = 1; inline_sym8__ <= 1; ++inline_sym8__) {
        current_statement__ = 17;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 18;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym2__;
        inline_sym2__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        stan::math::fill(inline_sym2__, DUMMY_VAR__);
        
        for (int inline_sym6__ = 1; inline_sym6__ <= nind; ++inline_sym6__) {
          current_statement__ = 20;
          assign(inline_sym2__, 1.0,
            "assigning variable inline_sym2__", index_uni(inline_sym6__),
                                                  index_uni(n_occasions));
          lcm_sym55__ = (n_occasions - 1);
          if (logical_gte(lcm_sym55__, 1)) {
            int inline_sym3__;
            inline_sym3__ = std::numeric_limits<int>::min();
            
            int inline_sym4__;
            inline_sym4__ = std::numeric_limits<int>::min();
            
            lcm_sym61__ = (lcm_sym55__ + 1);
            current_statement__ = 23;
            assign(inline_sym2__,
              stan::math::fma(
                (rvalue(phi, "phi",
                   index_uni(inline_sym6__), index_uni(lcm_sym55__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(inline_sym6__), index_uni((lcm_sym61__ - 1))))),
                rvalue(inline_sym2__, "inline_sym2__",
                  index_uni(inline_sym6__), index_uni(lcm_sym61__)),
                (1 -
                  rvalue(phi, "phi",
                    index_uni(inline_sym6__), index_uni(lcm_sym55__)))),
              "assigning variable inline_sym2__", index_uni(inline_sym6__),
                                                    index_uni(lcm_sym55__));
            for (int inline_sym5__ = 2; inline_sym5__ <= lcm_sym55__;
                 ++inline_sym5__) {
              int inline_sym3__;
              inline_sym3__ = std::numeric_limits<int>::min();
              
              int inline_sym4__;
              inline_sym4__ = std::numeric_limits<int>::min();
              
              lcm_sym54__ = (n_occasions - inline_sym5__);
              lcm_sym60__ = (lcm_sym54__ + 1);
              current_statement__ = 23;
              assign(inline_sym2__,
                stan::math::fma(
                  (rvalue(phi, "phi",
                     index_uni(inline_sym6__), index_uni(lcm_sym54__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(inline_sym6__),
                          index_uni((lcm_sym60__ - 1))))),
                  rvalue(inline_sym2__, "inline_sym2__",
                    index_uni(inline_sym6__), index_uni(lcm_sym60__)),
                  (1 -
                    rvalue(phi, "phi",
                      index_uni(inline_sym6__), index_uni(lcm_sym54__)))),
                "assigning variable inline_sym2__", index_uni(inline_sym6__),
                                                      index_uni(lcm_sym54__));
            }
          } 
          if (inline_sym7__) {
            break;
          } 
        }
        if (inline_sym7__) {
          break;
        } 
        inline_sym7__ = 1;
        assign(inline_sym1__, inline_sym2__,
          "assigning variable inline_sym1__");
        break;
      }
      assign(chi, inline_sym1__, "assigning variable chi");
      current_statement__ = 5;
      if (lcm_sym48__) {
        lcm_sym55__ = (n_occasions - 1);
        lcm_sym49__ = logical_gte(lcm_sym55__, 1);
        if (lcm_sym49__) {
          current_statement__ = 5;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi, "phi",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym49__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
              current_statement__ = 5;
              check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                     rvalue(phi, "phi",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym48__) {
        lcm_sym55__ = (n_occasions - 1);
        lcm_sym49__ = logical_gte(lcm_sym55__, 1);
        if (lcm_sym49__) {
          current_statement__ = 5;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi, "phi", index_uni(1), index_uni(1)),
                              1);
          for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym49__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
              current_statement__ = 5;
              check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                  rvalue(phi, "phi",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 6;
      if (lcm_sym48__) {
        lcm_sym55__ = (n_occasions - 1);
        lcm_sym49__ = logical_gte(lcm_sym55__, 1);
        if (lcm_sym49__) {
          current_statement__ = 6;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p, "p", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
            current_statement__ = 6;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 6;
          if (lcm_sym49__) {
            current_statement__ = 6;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
              current_statement__ = 6;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(p, "p",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 6;
      if (lcm_sym48__) {
        lcm_sym55__ = (n_occasions - 1);
        lcm_sym49__ = logical_gte(lcm_sym55__, 1);
        if (lcm_sym49__) {
          current_statement__ = 6;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p, "p", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
            current_statement__ = 6;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 6;
          if (lcm_sym49__) {
            current_statement__ = 6;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
              current_statement__ = 6;
              check_less_or_equal(function__, "p[sym1__, sym2__]",
                                  rvalue(p, "p",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 7;
      if (lcm_sym48__) {
        lcm_sym47__ = logical_gte(n_occasions, 1);
        if (lcm_sym47__) {
          current_statement__ = 7;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(inline_sym1__, "inline_sym1__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 7;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym1__, "inline_sym1__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym47__) {
            current_statement__ = 7;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym1__, "inline_sym1__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 7;
              check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                     rvalue(inline_sym1__, "inline_sym1__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 7;
      if (lcm_sym48__) {
        lcm_sym47__ = logical_gte(n_occasions, 1);
        if (lcm_sym47__) {
          current_statement__ = 7;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(inline_sym1__, "inline_sym1__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 7;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym1__, "inline_sym1__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym47__) {
            current_statement__ = 7;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym1__, "inline_sym1__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 7;
              check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                  rvalue(inline_sym1__, "inline_sym1__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(inline_sym1__);
        out__.write(lcm_sym68__);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double sigma2;
      lcm_sym69__ = square(sigma);
      sigma2 = lcm_sym69__;
      current_statement__ = 27;
      check_greater_or_equal(function__, "sigma2", lcm_sym69__, 0);
      out__.write(lcm_sym69__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym46__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ mean_phi;
      mean_phi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon;
      epsilon = Eigen::Matrix<local_scalar_t__, -1, 1>(nind);
      stan::math::fill(epsilon, DUMMY_VAR__);
      
      if (logical_gte(nind, 1)) {
        assign(epsilon, in__.read<local_scalar_t__>(),
          "assigning variable epsilon", index_uni(1));
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          assign(epsilon, in__.read<local_scalar_t__>(),
            "assigning variable epsilon", index_uni(sym1__));
        }
      } 
      out__.write(epsilon);
      local_scalar_t__ sigma;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 5, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mean_phi", "mean_p", "epsilon",
      "sigma", "phi", "p", "chi", "mu", "sigma2"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(nind)},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occasions)},
      std::vector<size_t>{}, std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym161__ = 1; sym161__ <= nind; ++sym161__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym161__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym161__ = 1; sym161__ <= n_occ_minus_1; ++sym161__) {
        {
          for (int sym162__ = 1; sym162__ <= nind; ++sym162__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym162__) + '.' + std::to_string(sym161__));
            } 
          }
        } 
      }
      for (int sym161__ = 1; sym161__ <= n_occ_minus_1; ++sym161__) {
        {
          for (int sym162__ = 1; sym162__ <= nind; ++sym162__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym162__) + '.' + std::to_string(sym161__));
            } 
          }
        } 
      }
      for (int sym161__ = 1; sym161__ <= n_occasions; ++sym161__) {
        {
          for (int sym162__ = 1; sym162__ <= nind; ++sym162__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym162__) + '.' + std::to_string(sym161__));
            } 
          }
        } 
      }
      param_names__.emplace_back(std::string() + "mu");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym161__ = 1; sym161__ <= nind; ++sym161__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym161__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym161__ = 1; sym161__ <= n_occ_minus_1; ++sym161__) {
        {
          for (int sym162__ = 1; sym162__ <= nind; ++sym162__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym162__) + '.' + std::to_string(sym161__));
            } 
          }
        } 
      }
      for (int sym161__ = 1; sym161__ <= n_occ_minus_1; ++sym161__) {
        {
          for (int sym162__ = 1; sym162__ <= nind; ++sym162__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym162__) + '.' + std::to_string(sym161__));
            } 
          }
        } 
      }
      for (int sym161__ = 1; sym161__ <= n_occasions; ++sym161__) {
        {
          for (int sym162__ = 1; sym162__ <= nind; ++sym162__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym162__) + '.' + std::to_string(sym161__));
            } 
          }
        } 
      }
      param_names__.emplace_back(std::string() + "mu");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nind) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nind) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((1 + 1) + nind) + 1);
      const size_t num_transformed = ((((nind *
                                                                    n_occ_minus_1)
                                                                   +
                                                                   (nind *
                                                                    n_occ_minus_1))
                                                                  +
                                                                  (nind *
                                                                    n_occasions))
                                                                 + 1);
      const size_t num_gen_quantities = 1;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((1 + 1) + nind) + 1);
      const size_t num_transformed = ((((nind *
                                                                    n_occ_minus_1)
                                                                   +
                                                                   (nind *
                                                                    n_occ_minus_1))
                                                                  +
                                                                  (nind *
                                                                    n_occasions))
                                                                 + 1);
      const size_t num_gen_quantities = 1;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 4> names__{"mean_phi", "mean_p",
      "epsilon", "sigma"};
      const std::array<Eigen::Index, 4> constrain_param_sizes__{1, 1, 
       nind, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail5_model_namespace::expr_prop_fail5_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail5_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail6.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail6_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 146> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail6.stan', line 163, column 2 to column 33)",
 " (in 'expr-prop-fail6.stan', line 164, column 2 to column 31)",
 " (in 'expr-prop-fail6.stan', line 165, column 2 to column 28)",
 " (in 'expr-prop-fail6.stan', line 166, column 2 to column 36)",
 " (in 'expr-prop-fail6.stan', line 167, column 2 to column 20)",
 " (in 'expr-prop-fail6.stan', line 168, column 2 to column 30)",
 " (in 'expr-prop-fail6.stan', line 174, column 2 to column 50)",
 " (in 'expr-prop-fail6.stan', line 175, column 2 to column 44)",
 " (in 'expr-prop-fail6.stan', line 176, column 2 to column 25)",
 " (in 'expr-prop-fail6.stan', line 177, column 2 to column 42)",
 " (in 'expr-prop-fail6.stan', line 178, column 2 to column 46)",
 " (in 'expr-prop-fail6.stan', line 183, column 4 to column 48)",
 " (in 'expr-prop-fail6.stan', line 192, column 4 to column 22)",
 " (in 'expr-prop-fail6.stan', line 194, column 4 to column 17)",
 " (in 'expr-prop-fail6.stan', line 196, column 6 to column 35)",
 " (in 'expr-prop-fail6.stan', line 197, column 6 to column 27)",
 " (in 'expr-prop-fail6.stan', line 195, column 35 to line 198, column 5)",
 " (in 'expr-prop-fail6.stan', line 195, column 4 to line 198, column 5)",
 " (in 'expr-prop-fail6.stan', line 199, column 4 to column 26)",
 " (in 'expr-prop-fail6.stan', line 191, column 2 to line 200, column 3)",
 " (in 'expr-prop-fail6.stan', line 49, column 4 to column 24)",
 " (in 'expr-prop-fail6.stan', line 50, column 4 to column 30)",
 " (in 'expr-prop-fail6.stan', line 51, column 11 to column 16)",
 " (in 'expr-prop-fail6.stan', line 51, column 18 to column 29)",
 " (in 'expr-prop-fail6.stan', line 51, column 4 to column 35)",
 " (in 'expr-prop-fail6.stan', line 54, column 6 to column 32)",
 " (in 'expr-prop-fail6.stan', line 56, column 8 to column 37)",
 " (in 'expr-prop-fail6.stan', line 57, column 8 to column 32)",
 " (in 'expr-prop-fail6.stan', line 59, column 8 to line 60, column 65)",
 " (in 'expr-prop-fail6.stan', line 55, column 37 to line 61, column 7)",
 " (in 'expr-prop-fail6.stan', line 53, column 23 to line 62, column 5)",
 " (in 'expr-prop-fail6.stan', line 48, column 47 to line 64, column 3)",
 " (in 'expr-prop-fail6.stan', line 219, column 2 to column 23)",
 " (in 'expr-prop-fail6.stan', line 220, column 2 to column 22)",
 " (in 'expr-prop-fail6.stan', line 221, column 2 to column 30)",
 " (in 'expr-prop-fail6.stan', line 222, column 2 to column 30)",
 " (in 'expr-prop-fail6.stan', line 223, column 2 to column 41)",
 " (in 'expr-prop-fail6.stan', line 229, column 4 to column 14)",
 " (in 'expr-prop-fail6.stan', line 238, column 6 to column 41)",
 " (in 'expr-prop-fail6.stan', line 237, column 11 to line 239, column 5)",
 " (in 'expr-prop-fail6.stan', line 231, column 6 to column 37)",
 " (in 'expr-prop-fail6.stan', line 234, column 8 to line 235, column 46)",
 " (in 'expr-prop-fail6.stan', line 233, column 8 to column 34)",
 " (in 'expr-prop-fail6.stan', line 232, column 31 to line 236, column 7)",
 " (in 'expr-prop-fail6.stan', line 232, column 6 to line 236, column 7)",
 " (in 'expr-prop-fail6.stan', line 230, column 28 to line 237, column 5)",
 " (in 'expr-prop-fail6.stan', line 230, column 4 to line 239, column 5)",
 " (in 'expr-prop-fail6.stan', line 228, column 17 to line 240, column 3)",
 " (in 'expr-prop-fail6.stan', line 228, column 2 to line 240, column 3)",
 " (in 'expr-prop-fail6.stan', line 244, column 16 to column 17)",
 " (in 'expr-prop-fail6.stan', line 244, column 19 to column 30)",
 " (in 'expr-prop-fail6.stan', line 244, column 4 to column 63)",
 " (in 'expr-prop-fail6.stan', line 245, column 13 to column 14)",
 " (in 'expr-prop-fail6.stan', line 245, column 4 to column 16)",
 " (in 'expr-prop-fail6.stan', line 246, column 15 to column 16)",
 " (in 'expr-prop-fail6.stan', line 246, column 4 to column 18)",
 " (in 'expr-prop-fail6.stan', line 249, column 6 to column 36)",
 " (in 'expr-prop-fail6.stan', line 17, column 8 to column 17)",
 " (in 'expr-prop-fail6.stan', line 16, column 6 to line 17, column 17)",
 " (in 'expr-prop-fail6.stan', line 14, column 31 to line 19, column 3)",
 " (in 'expr-prop-fail6.stan', line 252, column 8 to column 26)",
 " (in 'expr-prop-fail6.stan', line 251, column 6 to line 252, column 26)",
 " (in 'expr-prop-fail6.stan', line 248, column 19 to line 253, column 5)",
 " (in 'expr-prop-fail6.stan', line 248, column 4 to line 253, column 5)",
 " (in 'expr-prop-fail6.stan', line 255, column 6 to column 25)",
 " (in 'expr-prop-fail6.stan', line 256, column 6 to column 31)",
 " (in 'expr-prop-fail6.stan', line 254, column 29 to line 257, column 5)",
 " (in 'expr-prop-fail6.stan', line 254, column 4 to line 257, column 5)",
 " (in 'expr-prop-fail6.stan', line 259, column 6 to column 26)",
 " (in 'expr-prop-fail6.stan', line 260, column 6 to column 32)",
 " (in 'expr-prop-fail6.stan', line 258, column 19 to line 261, column 5)",
 " (in 'expr-prop-fail6.stan', line 258, column 4 to line 261, column 5)",
 " (in 'expr-prop-fail6.stan', line 262, column 4 to column 25)",
 " (in 'expr-prop-fail6.stan', line 243, column 2 to line 263, column 3)",
 " (in 'expr-prop-fail6.stan', line 211, column 2 to column 29)",
 " (in 'expr-prop-fail6.stan', line 212, column 2 to column 21)",
 " (in 'expr-prop-fail6.stan', line 82, column 4 to column 27)",
 " (in 'expr-prop-fail6.stan', line 83, column 4 to column 33)",
 " (in 'expr-prop-fail6.stan', line 84, column 11 to column 22)",
 " (in 'expr-prop-fail6.stan', line 84, column 4 to column 39)",
 " (in 'expr-prop-fail6.stan', line 87, column 13 to column 24)",
 " (in 'expr-prop-fail6.stan', line 87, column 6 to column 43)",
 " (in 'expr-prop-fail6.stan', line 124, column 8 to column 33)",
 " (in 'expr-prop-fail6.stan', line 133, column 10 to line 137, column 49)",
 " (in 'expr-prop-fail6.stan', line 139, column 8 to column 54)",
 " (in 'expr-prop-fail6.stan', line 140, column 8 to column 34)",
 " (in 'expr-prop-fail6.stan', line 123, column 13 to line 141, column 7)",
 " (in 'expr-prop-fail6.stan', line 91, column 8 to column 27)",
 " (in 'expr-prop-fail6.stan', line 97, column 17 to column 25)",
 " (in 'expr-prop-fail6.stan', line 97, column 10 to column 30)",
 " (in 'expr-prop-fail6.stan', line 106, column 12 to line 110, column 56)",
 " (in 'expr-prop-fail6.stan', line 111, column 10 to line 113, column 61)",
 " (in 'expr-prop-fail6.stan', line 114, column 10 to column 36)",
 " (in 'expr-prop-fail6.stan', line 96, column 15 to line 115, column 9)",
 " (in 'expr-prop-fail6.stan', line 94, column 27 to line 96, column 9)",
 " (in 'expr-prop-fail6.stan', line 94, column 8 to line 115, column 9)",
 " (in 'expr-prop-fail6.stan', line 118, column 10 to column 39)",
 " (in 'expr-prop-fail6.stan', line 119, column 10 to column 39)",
 " (in 'expr-prop-fail6.stan', line 117, column 42 to line 120, column 9)",
 " (in 'expr-prop-fail6.stan', line 122, column 8 to column 39)",
 " (in 'expr-prop-fail6.stan', line 89, column 20 to line 123, column 7)",
 " (in 'expr-prop-fail6.stan', line 127, column 8 to line 130, column 47)",
 " (in 'expr-prop-fail6.stan', line 95, column 10 to column 41)",
 " (in 'expr-prop-fail6.stan', line 86, column 23 to line 142, column 5)",
 " (in 'expr-prop-fail6.stan', line 147, column 2 to column 17)",
 " (in 'expr-prop-fail6.stan', line 148, column 2 to column 27)",
 " (in 'expr-prop-fail6.stan', line 149, column 25 to column 26)",
 " (in 'expr-prop-fail6.stan', line 149, column 28 to column 39)",
 " (in 'expr-prop-fail6.stan', line 149, column 2 to column 41)",
 " (in 'expr-prop-fail6.stan', line 153, column 39 to column 40)",
 " (in 'expr-prop-fail6.stan', line 153, column 2 to column 42)",
 " (in 'expr-prop-fail6.stan', line 154, column 38 to column 39)",
 " (in 'expr-prop-fail6.stan', line 154, column 2 to column 41)",
 " (in 'expr-prop-fail6.stan', line 157, column 4 to column 35)",
 " (in 'expr-prop-fail6.stan', line 156, column 2 to line 157, column 35)",
 " (in 'expr-prop-fail6.stan', line 30, column 6 to column 32)",
 " (in 'expr-prop-fail6.stan', line 33, column 8 to column 17)",
 " (in 'expr-prop-fail6.stan', line 32, column 6 to line 33, column 17)",
 " (in 'expr-prop-fail6.stan', line 29, column 37 to line 34, column 5)",
 " (in 'expr-prop-fail6.stan', line 28, column 30 to line 36, column 3)",
 " (in 'expr-prop-fail6.stan', line 159, column 4 to column 33)",
 " (in 'expr-prop-fail6.stan', line 158, column 2 to line 159, column 33)",
 " (in 'expr-prop-fail6.stan', line 166, column 18 to column 29)",
 " (in 'expr-prop-fail6.stan', line 167, column 9 to column 10)",
 " (in 'expr-prop-fail6.stan', line 174, column 26 to column 27)",
 " (in 'expr-prop-fail6.stan', line 174, column 29 to column 44)",
 " (in 'expr-prop-fail6.stan', line 175, column 26 to column 27)",
 " (in 'expr-prop-fail6.stan', line 175, column 29 to column 40)",
 " (in 'expr-prop-fail6.stan', line 176, column 10 to column 21)",
 " (in 'expr-prop-fail6.stan', line 177, column 26 to column 37)",
 " (in 'expr-prop-fail6.stan', line 178, column 26 to column 27)",
 " (in 'expr-prop-fail6.stan', line 178, column 29 to column 40)",
 " (in 'expr-prop-fail6.stan', line 221, column 17 to column 28)",
 " (in 'expr-prop-fail6.stan', line 222, column 17 to column 28)",
 " (in 'expr-prop-fail6.stan', line 223, column 25 to column 26)",
 " (in 'expr-prop-fail6.stan', line 223, column 28 to column 39)",
 " (in 'expr-prop-fail6.stan', line 18, column 4 to column 13)",
 " (in 'expr-prop-fail6.stan', line 35, column 4 to column 13)",
 " (in 'expr-prop-fail6.stan', line 55, column 6 to line 61, column 7)",
 " (in 'expr-prop-fail6.stan', line 53, column 4 to line 62, column 5)",
 " (in 'expr-prop-fail6.stan', line 63, column 4 to column 15)",
 " (in 'expr-prop-fail6.stan', line 132, column 8 to line 137, column 49)",
 " (in 'expr-prop-fail6.stan', line 105, column 10 to line 110, column 56)",
 " (in 'expr-prop-fail6.stan', line 86, column 4 to line 142, column 5)",
 " (in 'expr-prop-fail6.stan', line 81, column 42 to line 143, column 3)"};

int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) ;

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) ;

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
stan::value_type_t<T1__>>, -1, -1>
prob_uncaptured(const T0__& p, const T1__& phi, std::ostream* pstream__) ;

struct prob_uncaptured_functor__ {
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
stan::value_type_t<T1__>>, -1, -1>
operator()(const T0__& p, const T1__& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(p, phi, pstream__);
}
};

template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T7__, typename T_lp__, typename T_lp_accum__>
void
js_super_lp(const std::vector<std::vector<int>>& y,
            const std::vector<int>& first, const std::vector<int>& last,
            const T3__& p, const T4__& phi, const T5__& psi, const T6__& nu,
            const T7__& chi, T_lp__& lp__, T_lp_accum__& lp_accum__,
            std::ostream* pstream__) ;

struct js_super_lp_functor__ {
template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T7__, typename T_lp__, typename T_lp_accum__>
void
operator()(const std::vector<std::vector<int>>& y,
           const std::vector<int>& first, const std::vector<int>& last,
           const T3__& p, const T4__& phi, const T5__& psi, const T6__& nu,
           const T7__& chi, T_lp__& lp__, T_lp_accum__& lp_accum__,
           std::ostream* pstream__)  const 
{
return js_super_lp<propto__>(y, first, last, p, phi, psi, nu, chi, lp__,
         lp_accum__, pstream__);
}
};

int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym46__;
    int lcm_sym45__;
    int lcm_sym44__;
    int lcm_sym43__;
    {
      lcm_sym44__ = size(y_i);
      if (logical_gte(lcm_sym44__, 1)) {
        current_statement__ = 59;
        if (rvalue(y_i, "y_i", index_uni(1))) {
          current_statement__ = 58;
          return 1;
        } 
        for (int k = 2; k <= lcm_sym44__; ++k) {
          current_statement__ = 59;
          if (rvalue(y_i, "y_i", index_uni(k))) {
            current_statement__ = 58;
            return k;
          } 
        }
      } 
      current_statement__ = 137;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym52__;
    int lcm_sym51__;
    int lcm_sym50__;
    int lcm_sym49__;
    int lcm_sym48__;
    int lcm_sym47__;
    {
      lcm_sym50__ = (size(y_i) - 1);
      if (logical_gte(lcm_sym50__, 0)) {
        int k;
        lcm_sym49__ = (size(y_i) - 0);
        current_statement__ = 118;
        if (y_i[(lcm_sym49__ - 1)]) {
          current_statement__ = 117;
          return lcm_sym49__;
        } 
        for (int k_rev = 1; k_rev <= lcm_sym50__; ++k_rev) {
          int k;
          lcm_sym48__ = (size(y_i) - k_rev);
          current_statement__ = 118;
          if (y_i[(lcm_sym48__ - 1)]) {
            current_statement__ = 117;
            return lcm_sym48__;
          } 
        }
      } 
      current_statement__ = 138;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
stan::value_type_t<T1__>>, -1, -1>
prob_uncaptured(const T0__& p_arg__, const T1__& phi_arg__,
                std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>>;
  int current_statement__ = 0; 
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym64__;
    double lcm_sym63__;
    double lcm_sym62__;
    double lcm_sym61__;
    double lcm_sym60__;
    int lcm_sym59__;
    int lcm_sym58__;
    int lcm_sym57__;
    int lcm_sym56__;
    int lcm_sym55__;
    int lcm_sym54__;
    int lcm_sym53__;
    {
      int n_ind;
      lcm_sym64__ = rows(p);
      int n_occasions;
      lcm_sym59__ = cols(p);
      n_occasions = lcm_sym59__;
      current_statement__ = 23;
      validate_non_negative_index("chi", "n_ind", lcm_sym64__);
      current_statement__ = 24;
      validate_non_negative_index("chi", "n_occasions", lcm_sym59__);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(lcm_sym64__, lcm_sym59__);
      stan::math::fill(chi, DUMMY_VAR__);
      
      current_statement__ = 140;
      if (logical_gte(lcm_sym64__, 1)) {
        current_statement__ = 26;
        assign(chi, 1.0,
          "assigning variable chi", index_uni(1), index_uni(lcm_sym59__));
        lcm_sym56__ = (lcm_sym59__ - 1);
        lcm_sym53__ = logical_gte(lcm_sym56__, 1);
        if (lcm_sym53__) {
          int t_curr;
          int t_next;
          lcm_sym58__ = (lcm_sym56__ + 1);
          current_statement__ = 29;
          assign(chi,
            stan::math::fma(
              (rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym56__)) *
                (1 - rvalue(p, "p", index_uni(1), index_uni(lcm_sym58__)))),
              rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym58__)),
              (1 - rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym56__)))),
            "assigning variable chi", index_uni(1), index_uni(lcm_sym56__));
          for (int t = 2; t <= lcm_sym56__; ++t) {
            int t_curr;
            lcm_sym55__ = (lcm_sym59__ - t);
            int t_next;
            lcm_sym57__ = (lcm_sym55__ + 1);
            current_statement__ = 29;
            assign(chi,
              stan::math::fma(
                (rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym55__)) *
                  (1 - rvalue(p, "p", index_uni(1), index_uni(lcm_sym57__)))),
                rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym57__)),
                (1 -
                  rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym55__)))),
              "assigning variable chi", index_uni(1), index_uni(lcm_sym55__));
          }
        } 
        for (int i = 2; i <= lcm_sym64__; ++i) {
          current_statement__ = 26;
          assign(chi, 1.0,
            "assigning variable chi", index_uni(i), index_uni(lcm_sym59__));
          current_statement__ = 139;
          if (lcm_sym53__) {
            int t_curr;
            int t_next;
            lcm_sym58__ = (lcm_sym56__ + 1);
            current_statement__ = 29;
            assign(chi,
              stan::math::fma(
                (rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym56__)) *
                  (1 - rvalue(p, "p", index_uni(i), index_uni(lcm_sym58__)))),
                rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym58__)),
                (1 -
                  rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym56__)))),
              "assigning variable chi", index_uni(i), index_uni(lcm_sym56__));
            for (int t = 2; t <= lcm_sym56__; ++t) {
              int t_curr;
              lcm_sym55__ = (lcm_sym59__ - t);
              int t_next;
              lcm_sym57__ = (lcm_sym55__ + 1);
              current_statement__ = 29;
              assign(chi,
                stan::math::fma(
                  (rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym55__)) *
                    (1 -
                      rvalue(p, "p", index_uni(i), index_uni(lcm_sym57__)))),
                  rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym57__)),
                  (1 -
                    rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym55__)))),
                "assigning variable chi", index_uni(i),
                                            index_uni(lcm_sym55__));
            }
          } 
        }
      } 
      current_statement__ = 141;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T7__, typename T_lp__, typename T_lp_accum__>
void
js_super_lp(const std::vector<std::vector<int>>& y,
            const std::vector<int>& first, const std::vector<int>& last,
            const T3__& p_arg__, const T4__& phi_arg__, const T5__& psi,
            const T6__& nu_arg__, const T7__& chi_arg__, T_lp__& lp__,
            T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T3__>,
          stan::value_type_t<T4__>,
          T5__,
          stan::value_type_t<T6__>,
          stan::value_type_t<T7__>>;
  int current_statement__ = 0; 
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  const auto& nu = to_ref(nu_arg__);
  const auto& chi = to_ref(chi_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym115__;
    int lcm_sym114__;
    int lcm_sym113__;
    int lcm_sym112__;
    int lcm_sym111__;
    int lcm_sym110__;
    double lcm_sym109__;
    double lcm_sym108__;
    double lcm_sym107__;
    double lcm_sym106__;
    double lcm_sym105__;
    double lcm_sym104__;
    double lcm_sym103__;
    double lcm_sym102__;
    double lcm_sym101__;
    double lcm_sym100__;
    double lcm_sym99__;
    double lcm_sym98__;
    double lcm_sym97__;
    double lcm_sym96__;
    double lcm_sym95__;
    int lcm_sym94__;
    int lcm_sym93__;
    int lcm_sym92__;
    double lcm_sym91__;
    double lcm_sym90__;
    double lcm_sym89__;
    double lcm_sym88__;
    double lcm_sym87__;
    double lcm_sym86__;
    double lcm_sym85__;
    double lcm_sym84__;
    double lcm_sym83__;
    double lcm_sym82__;
    double lcm_sym81__;
    double lcm_sym80__;
    double lcm_sym79__;
    double lcm_sym78__;
    int lcm_sym77__;
    int lcm_sym76__;
    Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym75__;
    Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym74__;
    Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym73__;
    int lcm_sym72__;
    int lcm_sym71__;
    int lcm_sym70__;
    int lcm_sym69__;
    int lcm_sym68__;
    int lcm_sym67__;
    int lcm_sym66__;
    int lcm_sym65__;
    {
      int n_ind;
      lcm_sym114__ = rvalue(dims(y), "dims(y)", index_uni(1));
      int n_occasions;
      lcm_sym115__ = rvalue(dims(y), "dims(y)", index_uni(2));
      n_occasions = lcm_sym115__;
      current_statement__ = 79;
      validate_non_negative_index("qnu", "n_occasions", lcm_sym115__);
      Eigen::Matrix<double, -1, 1> qnu;
      assign(lcm_sym73__, subtract(1.0, nu), "assigning variable lcm_sym73__");
      current_statement__ = 144;
      if (logical_gte(lcm_sym114__, 1)) {
        current_statement__ = 81;
        validate_non_negative_index("qp", "n_occasions", lcm_sym115__);
        Eigen::Matrix<double, -1, 1> qp;
        assign(lcm_sym75__,
          subtract(1.0, transpose(rvalue(p, "p", index_uni(1)))),
          "assigning variable lcm_sym75__");
        lcm_sym111__ = rvalue(first, "first", index_uni(1));
        if (lcm_sym111__) {
          current_statement__ = 88;
          lp_accum__.add(bernoulli_lpmf<propto__>(1, psi));
          current_statement__ = 96;
          if (logical_eq(lcm_sym111__, 1)) {
            current_statement__ = 103;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                (rvalue(nu, "nu", index_uni(1)) *
                  rvalue(p, "p", index_uni(1), index_uni(1)))));
          } else {
            current_statement__ = 89;
            validate_non_negative_index("lp", "first[i]", lcm_sym111__);
            Eigen::Matrix<local_scalar_t__, -1, 1> lp;
            lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym111__);
            stan::math::fill(lp, DUMMY_VAR__);
            
            lcm_sym77__ = (lcm_sym111__ - 1);
            assign(lp,
              (((bernoulli_lpmf<false>(1, rvalue(nu, "nu", index_uni(1))) +
                  bernoulli_lpmf<false>(1,
                    prod(
                      rvalue(lcm_sym75__, "lcm_sym75__",
                        index_min_max(1, lcm_sym77__))))) +
                 bernoulli_lpmf<false>(1,
                   prod(
                     rvalue(phi, "phi",
                       index_uni(1), index_min_max(1, lcm_sym77__))))) +
                bernoulli_lpmf<false>(1,
                  rvalue(p, "p", index_uni(1), index_uni(lcm_sym111__)))),
              "assigning variable lp", index_uni(1));
            current_statement__ = 143;
            if (logical_gte(lcm_sym77__, 2)) {
              current_statement__ = 91;
              assign(lp,
                ((((bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym73__, "lcm_sym73__",
                          index_min_max(1, 1)))) +
                     bernoulli_lpmf<false>(1, rvalue(nu, "nu", index_uni(2))))
                    +
                    bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym75__, "lcm_sym75__",
                          index_min_max(2, lcm_sym77__))))) +
                   bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(phi, "phi",
                         index_uni(1), index_min_max(2, lcm_sym77__))))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(p, "p", index_uni(1), index_uni(lcm_sym111__)))),
                "assigning variable lp", index_uni(2));
              for (int t = 3; t <= lcm_sym77__; ++t) {
                current_statement__ = 91;
                assign(lp,
                  ((((bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym73__, "lcm_sym73__",
                            index_min_max(1, (t - 1))))) +
                       bernoulli_lpmf<false>(1,
                         rvalue(nu, "nu", index_uni(t)))) +
                      bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym75__, "lcm_sym75__",
                            index_min_max(t, lcm_sym77__))))) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(phi, "phi",
                           index_uni(1), index_min_max(t, lcm_sym77__))))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(p, "p", index_uni(1), index_uni(lcm_sym111__)))),
                  "assigning variable lp", index_uni(t));
              }
            } 
            current_statement__ = 92;
            assign(lp,
              ((bernoulli_lpmf<false>(1,
                  prod(
                    rvalue(lcm_sym73__, "lcm_sym73__",
                      index_min_max(1, lcm_sym77__)))) +
                 bernoulli_lpmf<false>(1, nu[(lcm_sym111__ - 1)])) +
                bernoulli_lpmf<false>(1,
                  rvalue(p, "p", index_uni(1), index_uni(lcm_sym111__)))),
              "assigning variable lp", index_uni(lcm_sym111__));
            current_statement__ = 93;
            lp_accum__.add(log_sum_exp(lp));
          }
          lcm_sym113__ = rvalue(last, "last", index_uni(1));
          if (logical_gte(lcm_sym113__, (lcm_sym111__ + 1))) {
            current_statement__ = 97;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                rvalue(phi, "phi",
                  index_uni(1), index_uni(((lcm_sym111__ + 1) - 1)))));
            lcm_sym94__ = ((lcm_sym111__ + 1) + 1);
            lp_accum__.add(
              bernoulli_lpmf<propto__>(
                rvalue(y, "y", index_uni(1), index_uni((lcm_sym111__ + 1))),
                rvalue(p, "p", index_uni(1), index_uni((lcm_sym111__ + 1)))));
            for (int t = lcm_sym94__; t <= lcm_sym113__; ++t) {
              current_statement__ = 97;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(phi, "phi", index_uni(1), index_uni((t - 1)))));
              current_statement__ = 98;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(
                  rvalue(y, "y", index_uni(1), index_uni(t)),
                  rvalue(p, "p", index_uni(1), index_uni(t))));
            }
          } 
          current_statement__ = 100;
          lp_accum__.add(
            bernoulli_lpmf<propto__>(1,
              rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym113__))));
        } else {
          lcm_sym92__ = (lcm_sym115__ + 1);
          validate_non_negative_index("lp", "n_occasions + 1", lcm_sym92__);
          Eigen::Matrix<local_scalar_t__, -1, 1> lp;
          lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym92__);
          stan::math::fill(lp, DUMMY_VAR__);
          
          current_statement__ = 102;
          assign(lp,
            (((bernoulli_lpmf<false>(1, psi) +
                bernoulli_lpmf<false>(1, rvalue(nu, "nu", index_uni(1)))) +
               bernoulli_lpmf<false>(0,
                 rvalue(p, "p", index_uni(1), index_uni(1)))) +
              bernoulli_lpmf<false>(1,
                rvalue(chi, "chi", index_uni(1), index_uni(1)))),
            "assigning variable lp", index_uni(1));
          current_statement__ = 142;
          if (logical_gte(lcm_sym115__, 2)) {
            current_statement__ = 84;
            assign(lp,
              ((((bernoulli_lpmf<false>(1, psi) +
                   bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(lcm_sym73__, "lcm_sym73__",
                         index_min_max(1, 1))))) +
                  bernoulli_lpmf<false>(1, rvalue(nu, "nu", index_uni(2)))) +
                 bernoulli_lpmf<false>(0,
                   rvalue(p, "p", index_uni(1), index_uni(2)))) +
                bernoulli_lpmf<false>(1,
                  rvalue(chi, "chi", index_uni(1), index_uni(2)))),
              "assigning variable lp", index_uni(2));
            for (int t = 3; t <= lcm_sym115__; ++t) {
              current_statement__ = 84;
              assign(lp,
                ((((bernoulli_lpmf<false>(1, psi) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(lcm_sym73__, "lcm_sym73__",
                           index_min_max(1, (t - 1)))))) +
                    bernoulli_lpmf<false>(1, rvalue(nu, "nu", index_uni(t))))
                   +
                   bernoulli_lpmf<false>(0,
                     rvalue(p, "p", index_uni(1), index_uni(t)))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(chi, "chi", index_uni(1), index_uni(t)))),
                "assigning variable lp", index_uni(t));
            }
          } 
          current_statement__ = 85;
          assign(lp, bernoulli_lpmf<false>(0, psi),
            "assigning variable lp", index_uni(lcm_sym92__));
          current_statement__ = 86;
          lp_accum__.add(log_sum_exp(lp));
        }
        for (int i = 2; i <= lcm_sym114__; ++i) {
          current_statement__ = 81;
          validate_non_negative_index("qp", "n_occasions", lcm_sym115__);
          Eigen::Matrix<double, -1, 1> qp;
          assign(lcm_sym74__,
            subtract(1.0, transpose(rvalue(p, "p", index_uni(i)))),
            "assigning variable lcm_sym74__");
          lcm_sym110__ = rvalue(first, "first", index_uni(i));
          if (lcm_sym110__) {
            current_statement__ = 88;
            lp_accum__.add(bernoulli_lpmf<propto__>(1, psi));
            current_statement__ = 96;
            if (logical_eq(lcm_sym110__, 1)) {
              current_statement__ = 103;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  (rvalue(nu, "nu", index_uni(1)) *
                    rvalue(p, "p", index_uni(i), index_uni(1)))));
            } else {
              current_statement__ = 89;
              validate_non_negative_index("lp", "first[i]", lcm_sym110__);
              Eigen::Matrix<local_scalar_t__, -1, 1> lp;
              lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym110__);
              stan::math::fill(lp, DUMMY_VAR__);
              
              lcm_sym76__ = (lcm_sym110__ - 1);
              assign(lp,
                (((bernoulli_lpmf<false>(1, rvalue(nu, "nu", index_uni(1))) +
                    bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym74__, "lcm_sym74__",
                          index_min_max(1, lcm_sym76__))))) +
                   bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(phi, "phi",
                         index_uni(i), index_min_max(1, lcm_sym76__))))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(p, "p", index_uni(i), index_uni(lcm_sym110__)))),
                "assigning variable lp", index_uni(1));
              current_statement__ = 143;
              if (logical_gte(lcm_sym76__, 2)) {
                current_statement__ = 91;
                assign(lp,
                  ((((bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym73__, "lcm_sym73__",
                            index_min_max(1, 1)))) +
                       bernoulli_lpmf<false>(1,
                         rvalue(nu, "nu", index_uni(2)))) +
                      bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym74__, "lcm_sym74__",
                            index_min_max(2, lcm_sym76__))))) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(phi, "phi",
                           index_uni(i), index_min_max(2, lcm_sym76__))))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(p, "p", index_uni(i), index_uni(lcm_sym110__)))),
                  "assigning variable lp", index_uni(2));
                for (int t = 3; t <= lcm_sym76__; ++t) {
                  current_statement__ = 91;
                  assign(lp,
                    ((((bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym73__, "lcm_sym73__",
                              index_min_max(1, (t - 1))))) +
                         bernoulli_lpmf<false>(1,
                           rvalue(nu, "nu", index_uni(t)))) +
                        bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym74__, "lcm_sym74__",
                              index_min_max(t, lcm_sym76__))))) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(phi, "phi",
                             index_uni(i), index_min_max(t, lcm_sym76__)))))
                      +
                      bernoulli_lpmf<false>(1,
                        rvalue(p, "p", index_uni(i), index_uni(lcm_sym110__)))),
                    "assigning variable lp", index_uni(t));
                }
              } 
              current_statement__ = 92;
              assign(lp,
                ((bernoulli_lpmf<false>(1,
                    prod(
                      rvalue(lcm_sym73__, "lcm_sym73__",
                        index_min_max(1, lcm_sym76__)))) +
                   bernoulli_lpmf<false>(1, nu[(lcm_sym110__ - 1)])) +
                  bernoulli_lpmf<false>(1,
                    rvalue(p, "p", index_uni(i), index_uni(lcm_sym110__)))),
                "assigning variable lp", index_uni(lcm_sym110__));
              current_statement__ = 93;
              lp_accum__.add(log_sum_exp(lp));
            }
            lcm_sym112__ = rvalue(last, "last", index_uni(i));
            if (logical_gte(lcm_sym112__, (lcm_sym110__ + 1))) {
              current_statement__ = 97;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(phi, "phi",
                    index_uni(i), index_uni(((lcm_sym110__ + 1) - 1)))));
              lcm_sym93__ = ((lcm_sym110__ + 1) + 1);
              lp_accum__.add(
                bernoulli_lpmf<propto__>(
                  rvalue(y, "y", index_uni(i), index_uni((lcm_sym110__ + 1))),
                  rvalue(p, "p", index_uni(i), index_uni((lcm_sym110__ + 1)))));
              for (int t = lcm_sym93__; t <= lcm_sym112__; ++t) {
                current_statement__ = 97;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(phi, "phi", index_uni(i), index_uni((t - 1)))));
                current_statement__ = 98;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(
                    rvalue(y, "y", index_uni(i), index_uni(t)),
                    rvalue(p, "p", index_uni(i), index_uni(t))));
              }
            } 
            current_statement__ = 100;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym112__))));
          } else {
            lcm_sym92__ = (lcm_sym115__ + 1);
            validate_non_negative_index("lp", "n_occasions + 1", lcm_sym92__);
            Eigen::Matrix<local_scalar_t__, -1, 1> lp;
            lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym92__);
            stan::math::fill(lp, DUMMY_VAR__);
            
            current_statement__ = 102;
            assign(lp,
              (((bernoulli_lpmf<false>(1, psi) +
                  bernoulli_lpmf<false>(1, rvalue(nu, "nu", index_uni(1)))) +
                 bernoulli_lpmf<false>(0,
                   rvalue(p, "p", index_uni(i), index_uni(1)))) +
                bernoulli_lpmf<false>(1,
                  rvalue(chi, "chi", index_uni(i), index_uni(1)))),
              "assigning variable lp", index_uni(1));
            current_statement__ = 142;
            if (logical_gte(lcm_sym115__, 2)) {
              current_statement__ = 84;
              assign(lp,
                ((((bernoulli_lpmf<false>(1, psi) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(lcm_sym73__, "lcm_sym73__",
                           index_min_max(1, 1))))) +
                    bernoulli_lpmf<false>(1, rvalue(nu, "nu", index_uni(2))))
                   +
                   bernoulli_lpmf<false>(0,
                     rvalue(p, "p", index_uni(i), index_uni(2)))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(chi, "chi", index_uni(i), index_uni(2)))),
                "assigning variable lp", index_uni(2));
              for (int t = 3; t <= lcm_sym115__; ++t) {
                current_statement__ = 84;
                assign(lp,
                  ((((bernoulli_lpmf<false>(1, psi) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(lcm_sym73__, "lcm_sym73__",
                             index_min_max(1, (t - 1)))))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(nu, "nu", index_uni(t)))) +
                     bernoulli_lpmf<false>(0,
                       rvalue(p, "p", index_uni(i), index_uni(t)))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(chi, "chi", index_uni(i), index_uni(t)))),
                  "assigning variable lp", index_uni(t));
              }
            } 
            current_statement__ = 85;
            assign(lp, bernoulli_lpmf<false>(0, psi),
              "assigning variable lp", index_uni(lcm_sym92__));
            current_statement__ = 86;
            lp_accum__.add(log_sum_exp(lp));
          }
        }
      } 
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
class expr_prop_fail6_model final : public model_base_crtp<expr_prop_fail6_model> {

 private:
  int lcm_sym306__;
  int lcm_sym305__;
  int lcm_sym304__;
  int lcm_sym303__;
  int lcm_sym302__;
  int lcm_sym301__;
  int lcm_sym300__;
  int lcm_sym299__;
  int lcm_sym298__;
  int lcm_sym297__;
  int lcm_sym296__;
  int lcm_sym295__;
  int lcm_sym294__;
  int lcm_sym293__;
  int lcm_sym292__;
  int lcm_sym291__;
  int lcm_sym290__;
  int lcm_sym289__;
  int lcm_sym288__;
  int lcm_sym287__;
  int lcm_sym286__;
  int lcm_sym285__;
  int lcm_sym284__;
  int lcm_sym283__;
  int M;
  int n_occasions;
  std::vector<std::vector<int>> y;
  std::vector<int> first;
  std::vector<int> last;
  int phi_2dim__; 
  
 
 public:
  ~expr_prop_fail6_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail6_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail6_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail6_model_namespace::expr_prop_fail6_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 105;
      context__.validate_dims("data initialization","M","int",
           std::vector<size_t>{});
      M = std::numeric_limits<int>::min();
      
      current_statement__ = 105;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 105;
      check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 106;
      context__.validate_dims("data initialization","n_occasions","int",
           std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      
      current_statement__ = 106;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 106;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 0);
      current_statement__ = 107;
      validate_non_negative_index("y", "M", M);
      current_statement__ = 108;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 109;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(M),
            static_cast<size_t>(n_occasions)});
      y = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 109;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 109;
        pos__ = 1;
        lcm_sym284__ = logical_gte(n_occasions, 1);
        if (lcm_sym284__) {
          {
            lcm_sym283__ = logical_gte(M, 1);
            if (lcm_sym283__) {
              current_statement__ = 109;
              assign(y, rvalue(y_flat__, "y_flat__", index_uni(1)),
                "assigning variable y", index_uni(1), index_uni(1));
              current_statement__ = 109;
              pos__ = 2;
              for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
                current_statement__ = 109;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(sym2__), index_uni(1));
                current_statement__ = 109;
                pos__ = (pos__ + 1);
              }
            } 
            for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
              current_statement__ = 109;
              if (lcm_sym283__) {
                current_statement__ = 109;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(1), index_uni(sym1__));
                current_statement__ = 109;
                pos__ = (pos__ + 1);
                for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
                  current_statement__ = 109;
                  assign(y, y_flat__[(pos__ - 1)],
                    "assigning variable y", index_uni(sym2__),
                                              index_uni(sym1__));
                  current_statement__ = 109;
                  pos__ = (pos__ + 1);
                }
              } 
            }
          }
        } else {
          lcm_sym283__ = logical_gte(M, 1);
        }
      }
      current_statement__ = 109;
      if (lcm_sym283__) {
        current_statement__ = 109;
        if (lcm_sym284__) {
          current_statement__ = 109;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 rvalue(y, "y", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 109;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 109;
          if (lcm_sym284__) {
            current_statement__ = 109;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 109;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);
            }
          } 
        }
      } 
      current_statement__ = 109;
      if (lcm_sym283__) {
        current_statement__ = 109;
        if (lcm_sym284__) {
          current_statement__ = 109;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              rvalue(y, "y", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 109;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 109;
          if (lcm_sym284__) {
            current_statement__ = 109;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 109;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);
            }
          } 
        }
      } 
      current_statement__ = 110;
      validate_non_negative_index("first", "M", M);
      current_statement__ = 111;
      first = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 112;
      validate_non_negative_index("last", "M", M);
      current_statement__ = 113;
      last = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 115;
      if (lcm_sym283__) {
        int inline_sym34__;
        int inline_sym36__;
        inline_sym36__ = 0;
        for (int inline_sym37__ = 1; inline_sym37__ <= 1; ++inline_sym37__) {
          lcm_sym292__ = size(rvalue(y, "y", index_uni(1)));
          for (int inline_sym35__ = 1; inline_sym35__ <= lcm_sym292__;
               ++inline_sym35__) {
            current_statement__ = 59;
            if (rvalue(y, "y", index_uni(1))[(inline_sym35__ - 1)]) {
              inline_sym36__ = 1;
              inline_sym34__ = inline_sym35__;
              break;
            } 
          }
          if (inline_sym36__) {
            break;
          } 
          inline_sym36__ = 1;
          inline_sym34__ = 0;
          break;
        }
        assign(first, inline_sym34__,
          "assigning variable first", index_uni(1));
        for (int i = 2; i <= M; ++i) {
          int inline_sym34__;
          int inline_sym36__;
          inline_sym36__ = 0;
          for (int inline_sym37__ = 1; inline_sym37__ <= 1; ++inline_sym37__) {
            lcm_sym291__ = size(rvalue(y, "y", index_uni(i)));
            for (int inline_sym35__ = 1; inline_sym35__ <= lcm_sym291__;
                 ++inline_sym35__) {
              current_statement__ = 59;
              if (rvalue(y, "y", index_uni(i))[(inline_sym35__ - 1)]) {
                inline_sym36__ = 1;
                inline_sym34__ = inline_sym35__;
                break;
              } 
            }
            if (inline_sym36__) {
              break;
            } 
            inline_sym36__ = 1;
            inline_sym34__ = 0;
            break;
          }
          assign(first, inline_sym34__,
            "assigning variable first", index_uni(i));
        }
      } 
      current_statement__ = 122;
      if (lcm_sym283__) {
        int inline_sym38__;
        int inline_sym41__;
        inline_sym41__ = 0;
        for (int inline_sym42__ = 1; inline_sym42__ <= 1; ++inline_sym42__) {
          lcm_sym292__ = size(rvalue(y, "y", index_uni(1)));
          lcm_sym289__ = (lcm_sym292__ - 1);
          for (int inline_sym40__ = 0; inline_sym40__ <= lcm_sym289__;
               ++inline_sym40__) {
            int inline_sym39__;
            lcm_sym288__ = (lcm_sym292__ - inline_sym40__);
            inline_sym39__ = lcm_sym288__;
            current_statement__ = 118;
            if (rvalue(y, "y", index_uni(1))[(lcm_sym288__ - 1)]) {
              inline_sym41__ = 1;
              inline_sym38__ = lcm_sym288__;
              break;
            } 
          }
          if (inline_sym41__) {
            break;
          } 
          inline_sym41__ = 1;
          inline_sym38__ = 0;
          break;
        }
        assign(last, inline_sym38__, "assigning variable last", index_uni(1));
        for (int i = 2; i <= M; ++i) {
          int inline_sym38__;
          int inline_sym41__;
          inline_sym41__ = 0;
          for (int inline_sym42__ = 1; inline_sym42__ <= 1; ++inline_sym42__) {
            lcm_sym291__ = size(rvalue(y, "y", index_uni(i)));
            lcm_sym287__ = (lcm_sym291__ - 1);
            for (int inline_sym40__ = 0; inline_sym40__ <= lcm_sym287__;
                 ++inline_sym40__) {
              int inline_sym39__;
              lcm_sym286__ = (lcm_sym291__ - inline_sym40__);
              inline_sym39__ = lcm_sym286__;
              current_statement__ = 118;
              if (rvalue(y, "y", index_uni(i))[(lcm_sym286__ - 1)]) {
                inline_sym41__ = 1;
                inline_sym38__ = lcm_sym286__;
                break;
              } 
            }
            if (inline_sym41__) {
              break;
            } 
            inline_sym41__ = 1;
            inline_sym38__ = 0;
            break;
          }
          assign(last, inline_sym38__,
            "assigning variable last", index_uni(i));
        }
      } 
      current_statement__ = 111;
      if (lcm_sym283__) {
        current_statement__ = 111;
        check_greater_or_equal(function__, "first[sym1__]",
                               rvalue(first, "first", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 111;
          check_greater_or_equal(function__, "first[sym1__]",
                                 first[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 111;
      if (lcm_sym283__) {
        current_statement__ = 111;
        check_less_or_equal(function__, "first[sym1__]",
                            rvalue(first, "first", index_uni(1)), n_occasions);
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 111;
          check_less_or_equal(function__, "first[sym1__]",
                              first[(sym1__ - 1)], n_occasions);
        }
      } 
      current_statement__ = 113;
      if (lcm_sym283__) {
        current_statement__ = 113;
        check_greater_or_equal(function__, "last[sym1__]",
                               rvalue(last, "last", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 113;
          check_greater_or_equal(function__, "last[sym1__]",
                                 last[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 113;
      if (lcm_sym283__) {
        current_statement__ = 113;
        check_less_or_equal(function__, "last[sym1__]",
                            rvalue(last, "last", index_uni(1)), n_occasions);
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 113;
          check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                              n_occasions);
        }
      } 
      current_statement__ = 123;
      validate_non_negative_index("beta", "n_occasions", n_occasions);
      current_statement__ = 124;
      validate_non_negative_index("epsilon", "M", M);
      current_statement__ = 125;
      validate_non_negative_index("phi", "M", M);
      current_statement__ = 126;
      phi_2dim__ = std::numeric_limits<int>::min();
      
      lcm_sym285__ = (n_occasions - 1);
      phi_2dim__ = lcm_sym285__;
      current_statement__ = 126;
      validate_non_negative_index("phi", "n_occasions - 1", lcm_sym285__);
      current_statement__ = 127;
      validate_non_negative_index("p", "M", M);
      current_statement__ = 128;
      validate_non_negative_index("p", "n_occasions", n_occasions);
      current_statement__ = 129;
      validate_non_negative_index("b", "n_occasions", n_occasions);
      current_statement__ = 130;
      validate_non_negative_index("nu", "n_occasions", n_occasions);
      current_statement__ = 131;
      validate_non_negative_index("chi", "M", M);
      current_statement__ = 132;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      current_statement__ = 133;
      validate_non_negative_index("N", "n_occasions", n_occasions);
      current_statement__ = 134;
      validate_non_negative_index("B", "n_occasions", n_occasions);
      current_statement__ = 135;
      validate_non_negative_index("z", "M", M);
      current_statement__ = 136;
      validate_non_negative_index("z", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + n_occasions + M + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail6_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym282__;
      double lcm_sym281__;
      double lcm_sym280__;
      double lcm_sym279__;
      int lcm_sym278__;
      int lcm_sym277__;
      local_scalar_t__ lcm_sym276__;
      double lcm_sym275__;
      double lcm_sym274__;
      double lcm_sym273__;
      double lcm_sym272__;
      local_scalar_t__ lcm_sym271__;
      double lcm_sym270__;
      int lcm_sym269__;
      int lcm_sym268__;
      double lcm_sym267__;
      double lcm_sym266__;
      double lcm_sym265__;
      double lcm_sym264__;
      int lcm_sym263__;
      int lcm_sym262__;
      int lcm_sym261__;
      Eigen::Matrix<local_scalar_t__, -1, -1> lcm_sym260__;
      double lcm_sym259__;
      double lcm_sym258__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym257__;
      double lcm_sym256__;
      double lcm_sym255__;
      double lcm_sym254__;
      int lcm_sym253__;
      double lcm_sym252__;
      double lcm_sym251__;
      double lcm_sym250__;
      double lcm_sym249__;
      double lcm_sym248__;
      double lcm_sym247__;
      double lcm_sym246__;
      double lcm_sym245__;
      double lcm_sym244__;
      double lcm_sym243__;
      double lcm_sym242__;
      double lcm_sym241__;
      double lcm_sym240__;
      double lcm_sym239__;
      int lcm_sym238__;
      int lcm_sym237__;
      int lcm_sym236__;
      double lcm_sym235__;
      double lcm_sym234__;
      double lcm_sym233__;
      double lcm_sym232__;
      double lcm_sym231__;
      double lcm_sym230__;
      double lcm_sym229__;
      double lcm_sym228__;
      double lcm_sym227__;
      double lcm_sym226__;
      double lcm_sym225__;
      double lcm_sym224__;
      double lcm_sym223__;
      double lcm_sym222__;
      double lcm_sym221__;
      int lcm_sym220__;
      int lcm_sym219__;
      double lcm_sym218__;
      int lcm_sym217__;
      int lcm_sym216__;
      int lcm_sym215__;
      int lcm_sym214__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym213__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym212__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym211__;
      int lcm_sym210__;
      int lcm_sym209__;
      int lcm_sym208__;
      int lcm_sym207__;
      int lcm_sym206__;
      int lcm_sym205__;
      int lcm_sym204__;
      int lcm_sym203__;
      int lcm_sym202__;
      int lcm_sym201__;
      int lcm_sym200__;
      int lcm_sym199__;
      int lcm_sym198__;
      int lcm_sym197__;
      double lcm_sym196__;
      double lcm_sym195__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym194__;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                   0, 1, lp__);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                 0, 1, lp__);
      local_scalar_t__ psi;
      current_statement__ = 3;
      psi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(0,
              1, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      current_statement__ = 4;
      beta = in__.template read_constrain_lb<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
               0, lp__, n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon;
      current_statement__ = 5;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(M);
      local_scalar_t__ sigma;
      current_statement__ = 6;
      sigma = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 5, lp__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, (n_occasions - 1));
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      stan::math::fill(p, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> b;
      b = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(b, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> nu;
      nu = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(nu, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      lcm_sym210__ = (n_occasions - 1);
      assign(lcm_sym260__, rep_matrix(mean_phi, M, lcm_sym210__),
        "assigning variable lcm_sym260__");
      assign(phi, lcm_sym260__, "assigning variable phi");
      lcm_sym200__ = logical_gte(n_occasions, 1);
      if (lcm_sym200__) {
        assign(lcm_sym257__, inv_logit(add(logit(mean_p), epsilon)),
          "assigning variable lcm_sym257__");
        assign(p, lcm_sym257__,
          "assigning variable p", index_omni(), index_uni(1));
        for (int t = 2; t <= n_occasions; ++t) {
          current_statement__ = 12;
          assign(p, lcm_sym257__,
            "assigning variable p", index_omni(), index_uni(t));
        }
      } 
      assign(lcm_sym194__, divide(beta, sum(beta)),
        "assigning variable lcm_sym194__");
      assign(b, lcm_sym194__, "assigning variable b");
      {
        local_scalar_t__ cum_b;
        lcm_sym276__ = rvalue(lcm_sym194__, "lcm_sym194__", index_uni(1));
        current_statement__ = 14;
        assign(nu, lcm_sym276__, "assigning variable nu", index_uni(1));
        current_statement__ = 18;
        if (logical_gte(lcm_sym210__, 2)) {
          current_statement__ = 15;
          assign(nu,
            (rvalue(lcm_sym194__, "lcm_sym194__", index_uni(2)) /
              (1.0 - lcm_sym276__)), "assigning variable nu", index_uni(2));
          current_statement__ = 16;
          cum_b = (lcm_sym276__ +
                    rvalue(lcm_sym194__, "lcm_sym194__", index_uni(2)));
          for (int t = 3; t <= lcm_sym210__; ++t) {
            current_statement__ = 15;
            assign(nu,
              (rvalue(lcm_sym194__, "lcm_sym194__", index_uni(t)) /
                (1.0 - cum_b)), "assigning variable nu", index_uni(t));
            current_statement__ = 16;
            cum_b = (cum_b +
                      rvalue(lcm_sym194__, "lcm_sym194__", index_uni(t)));
          }
        } 
        current_statement__ = 19;
        assign(nu, 1.0, "assigning variable nu", index_uni(n_occasions));
      }
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym15__;
      int inline_sym23__;
      inline_sym23__ = 0;
      for (int inline_sym24__ = 1; inline_sym24__ <= 1; ++inline_sym24__) {
        int inline_sym16__;
        lcm_sym261__ = rows(p);
        int inline_sym17__;
        lcm_sym253__ = cols(p);
        current_statement__ = 23;
        validate_non_negative_index("chi", "n_ind", lcm_sym261__);
        current_statement__ = 24;
        validate_non_negative_index("chi", "n_occasions", lcm_sym253__);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym18__;
        inline_sym18__ = Eigen::Matrix<local_scalar_t__, -1, -1>(lcm_sym261__, lcm_sym253__);
        stan::math::fill(inline_sym18__, DUMMY_VAR__);
        
        for (int inline_sym22__ = 1; inline_sym22__ <= lcm_sym261__;
             ++inline_sym22__) {
          current_statement__ = 26;
          assign(inline_sym18__, 1.0,
            "assigning variable inline_sym18__", index_uni(inline_sym22__),
                                                   index_uni(lcm_sym253__));
          lcm_sym215__ = (lcm_sym253__ - 1);
          if (logical_gte(lcm_sym215__, 1)) {
            int inline_sym19__;
            int inline_sym20__;
            lcm_sym220__ = (lcm_sym215__ + 1);
            current_statement__ = 29;
            assign(inline_sym18__,
              stan::math::fma(
                (rvalue(lcm_sym260__, "lcm_sym260__",
                   index_uni(inline_sym22__), index_uni(lcm_sym215__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(inline_sym22__), index_uni(lcm_sym220__)))),
                rvalue(inline_sym18__, "inline_sym18__",
                  index_uni(inline_sym22__), index_uni(lcm_sym220__)),
                (1 -
                  rvalue(lcm_sym260__, "lcm_sym260__",
                    index_uni(inline_sym22__), index_uni(lcm_sym215__)))),
              "assigning variable inline_sym18__", index_uni(inline_sym22__),
                                                     index_uni(lcm_sym215__));
            for (int inline_sym21__ = 2; inline_sym21__ <= lcm_sym215__;
                 ++inline_sym21__) {
              int inline_sym19__;
              lcm_sym214__ = (lcm_sym253__ - inline_sym21__);
              int inline_sym20__;
              lcm_sym219__ = (lcm_sym214__ + 1);
              current_statement__ = 29;
              assign(inline_sym18__,
                stan::math::fma(
                  (rvalue(lcm_sym260__, "lcm_sym260__",
                     index_uni(inline_sym22__), index_uni(lcm_sym214__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(inline_sym22__), index_uni(lcm_sym219__)))),
                  rvalue(inline_sym18__, "inline_sym18__",
                    index_uni(inline_sym22__), index_uni(lcm_sym219__)),
                  (1 -
                    rvalue(lcm_sym260__, "lcm_sym260__",
                      index_uni(inline_sym22__), index_uni(lcm_sym214__)))),
                "assigning variable inline_sym18__", index_uni(inline_sym22__),
                                                       index_uni(lcm_sym214__));
            }
          } 
          if (inline_sym23__) {
            break;
          } 
        }
        if (inline_sym23__) {
          break;
        } 
        inline_sym23__ = 1;
        assign(inline_sym15__, inline_sym18__,
          "assigning variable inline_sym15__");
        break;
      }
      assign(chi, inline_sym15__, "assigning variable chi");
      lcm_sym199__ = logical_gte(M, 1);
      if (lcm_sym199__) {
        lcm_sym201__ = logical_gte(lcm_sym210__, 1);
        if (lcm_sym201__) {
          current_statement__ = 7;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(lcm_sym260__, "lcm_sym260__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym210__; ++sym2__) {
            current_statement__ = 7;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(lcm_sym260__, "lcm_sym260__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym201__) {
            current_statement__ = 7;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(lcm_sym260__, "lcm_sym260__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym210__; ++sym2__) {
              current_statement__ = 7;
              check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                     rvalue(lcm_sym260__, "lcm_sym260__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 7;
      if (lcm_sym199__) {
        lcm_sym201__ = logical_gte(lcm_sym210__, 1);
        if (lcm_sym201__) {
          current_statement__ = 7;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(lcm_sym260__, "lcm_sym260__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= lcm_sym210__; ++sym2__) {
            current_statement__ = 7;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(lcm_sym260__, "lcm_sym260__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym201__) {
            current_statement__ = 7;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(lcm_sym260__, "lcm_sym260__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym210__; ++sym2__) {
              current_statement__ = 7;
              check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                  rvalue(lcm_sym260__, "lcm_sym260__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 8;
      if (lcm_sym199__) {
        current_statement__ = 8;
        if (lcm_sym200__) {
          current_statement__ = 8;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p, "p", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 8;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 8;
          if (lcm_sym200__) {
            current_statement__ = 8;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 8;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(p, "p",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 8;
      if (lcm_sym199__) {
        current_statement__ = 8;
        if (lcm_sym200__) {
          current_statement__ = 8;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p, "p", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 8;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 8;
          if (lcm_sym200__) {
            current_statement__ = 8;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 8;
              check_less_or_equal(function__, "p[sym1__, sym2__]",
                                  rvalue(p, "p",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 9;
      check_simplex(function__, "b", lcm_sym194__);
      current_statement__ = 10;
      if (lcm_sym200__) {
        current_statement__ = 10;
        check_greater_or_equal(function__, "nu[sym1__]",
                               rvalue(nu, "nu", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 10;
          check_greater_or_equal(function__, "nu[sym1__]", nu[(sym1__ - 1)],
                                 0);
        }
      } 
      current_statement__ = 10;
      if (lcm_sym200__) {
        current_statement__ = 10;
        check_less_or_equal(function__, "nu[sym1__]",
                            rvalue(nu, "nu", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 10;
          check_less_or_equal(function__, "nu[sym1__]", nu[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 11;
      if (lcm_sym199__) {
        current_statement__ = 11;
        if (lcm_sym200__) {
          current_statement__ = 11;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(inline_sym15__, "inline_sym15__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 11;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym15__, "inline_sym15__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 11;
          if (lcm_sym200__) {
            current_statement__ = 11;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym15__, "inline_sym15__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 11;
              check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                     rvalue(inline_sym15__, "inline_sym15__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 11;
      if (lcm_sym199__) {
        current_statement__ = 11;
        if (lcm_sym200__) {
          current_statement__ = 11;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(inline_sym15__, "inline_sym15__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 11;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym15__, "inline_sym15__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 11;
          if (lcm_sym200__) {
            current_statement__ = 11;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym15__, "inline_sym15__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 11;
              check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                  rvalue(inline_sym15__, "inline_sym15__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      {
        current_statement__ = 75;
        lp_accum__.add(normal_lpdf<propto__>(epsilon, 0, sigma));
        current_statement__ = 76;
        lp_accum__.add(gamma_lpdf<propto__>(beta, 1, 1));
        int inline_sym32__;
        inline_sym32__ = std::numeric_limits<int>::min();
        
        {
          int inline_sym25__;
          lcm_sym277__ = rvalue(dims(y), "dims(y)", index_uni(1));
          int inline_sym26__;
          lcm_sym278__ = rvalue(dims(y), "dims(y)", index_uni(2));
          current_statement__ = 79;
          validate_non_negative_index("qnu", "n_occasions", lcm_sym278__);
          Eigen::Matrix<double, -1, 1> inline_sym27__;
          assign(lcm_sym211__, subtract(1.0, nu),
            "assigning variable lcm_sym211__");
          lcm_sym208__ = logical_gte(lcm_sym277__, 1);
          if (lcm_sym208__) {
            current_statement__ = 81;
            validate_non_negative_index("qp", "n_occasions", lcm_sym278__);
            Eigen::Matrix<double, -1, 1> inline_sym28__;
            assign(lcm_sym213__,
              subtract(1.0, transpose(rvalue(p, "p", index_uni(1)))),
              "assigning variable lcm_sym213__");
            lcm_sym263__ = rvalue(first, "first", index_uni(1));
            if (lcm_sym263__) {
              current_statement__ = 88;
              lp_accum__.add(bernoulli_lpmf<propto__>(1, psi));
              current_statement__ = 96;
              if (logical_eq(lcm_sym263__, 1)) {
                lcm_sym271__ = rvalue(nu, "nu", index_uni(1));
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    (lcm_sym271__ *
                      rvalue(p, "p", index_uni(1), index_uni(1)))));
              } else {
                current_statement__ = 89;
                validate_non_negative_index("lp", "first[i]", lcm_sym263__);
                Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym29__;
                inline_sym29__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym263__);
                stan::math::fill(inline_sym29__, DUMMY_VAR__);
                
                lcm_sym271__ = rvalue(nu, "nu", index_uni(1));
                lcm_sym217__ = (lcm_sym263__ - 1);
                assign(inline_sym29__,
                  (((bernoulli_lpmf<false>(1, lcm_sym271__) +
                      bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym213__, "lcm_sym213__",
                            index_min_max(1, lcm_sym217__))))) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(lcm_sym260__, "lcm_sym260__",
                           index_uni(1), index_min_max(1, lcm_sym217__))))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(p, "p", index_uni(1), index_uni(lcm_sym263__)))),
                  "assigning variable inline_sym29__", index_uni(1));
                if (logical_gte(lcm_sym217__, 2)) {
                  current_statement__ = 91;
                  assign(inline_sym29__,
                    ((((bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym211__, "lcm_sym211__",
                              index_min_max(1, 1)))) +
                         bernoulli_lpmf<false>(1,
                           rvalue(nu, "nu", index_uni(2)))) +
                        bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym213__, "lcm_sym213__",
                              index_min_max(2, lcm_sym217__))))) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(lcm_sym260__, "lcm_sym260__",
                             index_uni(1), index_min_max(2, lcm_sym217__)))))
                      +
                      bernoulli_lpmf<false>(1,
                        rvalue(p, "p", index_uni(1), index_uni(lcm_sym263__)))),
                    "assigning variable inline_sym29__", index_uni(2));
                  for (int inline_sym30__ = 3;
                       inline_sym30__ <= lcm_sym217__; ++inline_sym30__) {
                    current_statement__ = 91;
                    assign(inline_sym29__,
                      ((((bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym211__, "lcm_sym211__",
                                index_min_max(1, (inline_sym30__ - 1))))) +
                           bernoulli_lpmf<false>(1, nu[(inline_sym30__ - 1)]))
                          +
                          bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym213__, "lcm_sym213__",
                                index_min_max(inline_sym30__, lcm_sym217__)))))
                         +
                         bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(lcm_sym260__, "lcm_sym260__",
                               index_uni(1),
                                 index_min_max(inline_sym30__, lcm_sym217__)))))
                        +
                        bernoulli_lpmf<false>(1,
                          rvalue(p, "p",
                            index_uni(1), index_uni(lcm_sym263__)))),
                      "assigning variable inline_sym29__", index_uni(inline_sym30__));
                  }
                } 
                current_statement__ = 92;
                assign(inline_sym29__,
                  ((bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym211__, "lcm_sym211__",
                          index_min_max(1, lcm_sym217__)))) +
                     bernoulli_lpmf<false>(1, nu[(lcm_sym263__ - 1)])) +
                    bernoulli_lpmf<false>(1,
                      rvalue(p, "p", index_uni(1), index_uni(lcm_sym263__)))),
                  "assigning variable inline_sym29__", index_uni(lcm_sym263__));
                current_statement__ = 93;
                lp_accum__.add(log_sum_exp(inline_sym29__));
              }
              lcm_sym269__ = rvalue(last, "last", index_uni(1));
              if (logical_gte(lcm_sym269__, (lcm_sym263__ + 1))) {
                current_statement__ = 97;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(lcm_sym260__, "lcm_sym260__",
                      index_uni(1), index_uni(((lcm_sym263__ + 1) - 1)))));
                lcm_sym238__ = ((lcm_sym263__ + 1) + 1);
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(
                    rvalue(y, "y",
                      index_uni(1), index_uni((lcm_sym263__ + 1))),
                    rvalue(p, "p",
                      index_uni(1), index_uni((lcm_sym263__ + 1)))));
                for (int inline_sym30__ = lcm_sym238__;
                     inline_sym30__ <= lcm_sym269__; ++inline_sym30__) {
                  current_statement__ = 97;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(1,
                      rvalue(lcm_sym260__, "lcm_sym260__",
                        index_uni(1), index_uni((inline_sym30__ - 1)))));
                  current_statement__ = 98;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(
                      rvalue(y, "y", index_uni(1), index_uni(inline_sym30__)),
                      rvalue(p, "p", index_uni(1), index_uni(inline_sym30__))));
                }
              } 
              current_statement__ = 100;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(inline_sym15__, "inline_sym15__",
                    index_uni(1), index_uni(lcm_sym269__))));
            } else {
              lcm_sym236__ = (lcm_sym278__ + 1);
              validate_non_negative_index("lp", "n_occasions + 1",
                                          lcm_sym236__);
              Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym29__;
              inline_sym29__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym236__);
              stan::math::fill(inline_sym29__, DUMMY_VAR__);
              
              lcm_sym271__ = rvalue(nu, "nu", index_uni(1));
              assign(inline_sym29__,
                (((bernoulli_lpmf<false>(1, psi) +
                    bernoulli_lpmf<false>(1, lcm_sym271__)) +
                   bernoulli_lpmf<false>(0,
                     rvalue(p, "p", index_uni(1), index_uni(1)))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(inline_sym15__, "inline_sym15__",
                      index_uni(1), index_uni(1)))),
                "assigning variable inline_sym29__", index_uni(1));
              if (logical_gte(lcm_sym278__, 2)) {
                current_statement__ = 84;
                assign(inline_sym29__,
                  ((((bernoulli_lpmf<false>(1, psi) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(lcm_sym211__, "lcm_sym211__",
                             index_min_max(1, 1))))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(nu, "nu", index_uni(2)))) +
                     bernoulli_lpmf<false>(0,
                       rvalue(p, "p", index_uni(1), index_uni(2)))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(inline_sym15__, "inline_sym15__",
                        index_uni(1), index_uni(2)))),
                  "assigning variable inline_sym29__", index_uni(2));
                for (int inline_sym30__ = 3; inline_sym30__ <= lcm_sym278__;
                     ++inline_sym30__) {
                  current_statement__ = 84;
                  assign(inline_sym29__,
                    ((((bernoulli_lpmf<false>(1, psi) +
                         bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(lcm_sym211__, "lcm_sym211__",
                               index_min_max(1, (inline_sym30__ - 1)))))) +
                        bernoulli_lpmf<false>(1, nu[(inline_sym30__ - 1)])) +
                       bernoulli_lpmf<false>(0,
                         rvalue(p, "p",
                           index_uni(1), index_uni(inline_sym30__)))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(inline_sym15__, "inline_sym15__",
                          index_uni(1), index_uni(inline_sym30__)))),
                    "assigning variable inline_sym29__", index_uni(inline_sym30__));
                }
              } 
              current_statement__ = 85;
              assign(inline_sym29__, bernoulli_lpmf<false>(0, psi),
                "assigning variable inline_sym29__", index_uni(lcm_sym236__));
              current_statement__ = 86;
              lp_accum__.add(log_sum_exp(inline_sym29__));
            }
            for (int inline_sym31__ = 2; inline_sym31__ <= lcm_sym277__;
                 ++inline_sym31__) {
              current_statement__ = 81;
              validate_non_negative_index("qp", "n_occasions", lcm_sym278__);
              Eigen::Matrix<double, -1, 1> inline_sym28__;
              assign(lcm_sym212__,
                subtract(1.0,
                  transpose(rvalue(p, "p", index_uni(inline_sym31__)))),
                "assigning variable lcm_sym212__");
              lcm_sym262__ = first[(inline_sym31__ - 1)];
              if (lcm_sym262__) {
                current_statement__ = 88;
                lp_accum__.add(bernoulli_lpmf<propto__>(1, psi));
                current_statement__ = 96;
                if (logical_eq(lcm_sym262__, 1)) {
                  current_statement__ = 103;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(1,
                      (lcm_sym271__ *
                        rvalue(p, "p",
                          index_uni(inline_sym31__), index_uni(1)))));
                } else {
                  current_statement__ = 89;
                  validate_non_negative_index("lp", "first[i]", lcm_sym262__);
                  Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym29__;
                  inline_sym29__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym262__);
                  stan::math::fill(inline_sym29__, DUMMY_VAR__);
                  
                  lcm_sym216__ = (lcm_sym262__ - 1);
                  assign(inline_sym29__,
                    (((bernoulli_lpmf<false>(1, lcm_sym271__) +
                        bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym212__, "lcm_sym212__",
                              index_min_max(1, lcm_sym216__))))) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(lcm_sym260__, "lcm_sym260__",
                             index_uni(inline_sym31__),
                               index_min_max(1, lcm_sym216__))))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(p, "p",
                          index_uni(inline_sym31__), index_uni(lcm_sym262__)))),
                    "assigning variable inline_sym29__", index_uni(1));
                  if (logical_gte(lcm_sym216__, 2)) {
                    current_statement__ = 91;
                    assign(inline_sym29__,
                      ((((bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym211__, "lcm_sym211__",
                                index_min_max(1, 1)))) +
                           bernoulli_lpmf<false>(1,
                             rvalue(nu, "nu", index_uni(2)))) +
                          bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym212__, "lcm_sym212__",
                                index_min_max(2, lcm_sym216__))))) +
                         bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(lcm_sym260__, "lcm_sym260__",
                               index_uni(inline_sym31__),
                                 index_min_max(2, lcm_sym216__))))) +
                        bernoulli_lpmf<false>(1,
                          rvalue(p, "p",
                            index_uni(inline_sym31__),
                              index_uni(lcm_sym262__)))),
                      "assigning variable inline_sym29__", index_uni(2));
                    for (int inline_sym30__ = 3;
                         inline_sym30__ <= lcm_sym216__; ++inline_sym30__) {
                      current_statement__ = 91;
                      assign(inline_sym29__,
                        ((((bernoulli_lpmf<false>(1,
                              prod(
                                rvalue(lcm_sym211__, "lcm_sym211__",
                                  index_min_max(1, (inline_sym30__ - 1))))) +
                             bernoulli_lpmf<false>(1,
                               nu[(inline_sym30__ - 1)])) +
                            bernoulli_lpmf<false>(1,
                              prod(
                                rvalue(lcm_sym212__, "lcm_sym212__",
                                  index_min_max(inline_sym30__, lcm_sym216__)))))
                           +
                           bernoulli_lpmf<false>(1,
                             prod(
                               rvalue(lcm_sym260__, "lcm_sym260__",
                                 index_uni(inline_sym31__),
                                   index_min_max(inline_sym30__, lcm_sym216__)))))
                          +
                          bernoulli_lpmf<false>(1,
                            rvalue(p, "p",
                              index_uni(inline_sym31__),
                                index_uni(lcm_sym262__)))),
                        "assigning variable inline_sym29__", index_uni(inline_sym30__));
                    }
                  } 
                  current_statement__ = 92;
                  assign(inline_sym29__,
                    ((bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym211__, "lcm_sym211__",
                            index_min_max(1, lcm_sym216__)))) +
                       bernoulli_lpmf<false>(1, nu[(lcm_sym262__ - 1)])) +
                      bernoulli_lpmf<false>(1,
                        rvalue(p, "p",
                          index_uni(inline_sym31__), index_uni(lcm_sym262__)))),
                    "assigning variable inline_sym29__", index_uni(lcm_sym262__));
                  current_statement__ = 93;
                  lp_accum__.add(log_sum_exp(inline_sym29__));
                }
                lcm_sym268__ = last[(inline_sym31__ - 1)];
                if (logical_gte(lcm_sym268__, (lcm_sym262__ + 1))) {
                  current_statement__ = 97;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(1,
                      rvalue(lcm_sym260__, "lcm_sym260__",
                        index_uni(inline_sym31__),
                          index_uni(((lcm_sym262__ + 1) - 1)))));
                  lcm_sym237__ = ((lcm_sym262__ + 1) + 1);
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(
                      rvalue(y, "y",
                        index_uni(inline_sym31__),
                          index_uni((lcm_sym262__ + 1))),
                      rvalue(p, "p",
                        index_uni(inline_sym31__),
                          index_uni((lcm_sym262__ + 1)))));
                  for (int inline_sym30__ = lcm_sym237__;
                       inline_sym30__ <= lcm_sym268__; ++inline_sym30__) {
                    current_statement__ = 97;
                    lp_accum__.add(
                      bernoulli_lpmf<propto__>(1,
                        rvalue(lcm_sym260__, "lcm_sym260__",
                          index_uni(inline_sym31__),
                            index_uni((inline_sym30__ - 1)))));
                    current_statement__ = 98;
                    lp_accum__.add(
                      bernoulli_lpmf<propto__>(
                        y[(inline_sym31__ - 1)][(inline_sym30__ - 1)],
                        rvalue(p, "p",
                          index_uni(inline_sym31__),
                            index_uni(inline_sym30__))));
                  }
                } 
                current_statement__ = 100;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(inline_sym15__, "inline_sym15__",
                      index_uni(inline_sym31__), index_uni(lcm_sym268__))));
              } else {
                lcm_sym236__ = (lcm_sym278__ + 1);
                validate_non_negative_index("lp", "n_occasions + 1",
                                            lcm_sym236__);
                Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym29__;
                inline_sym29__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym236__);
                stan::math::fill(inline_sym29__, DUMMY_VAR__);
                
                current_statement__ = 102;
                assign(inline_sym29__,
                  (((bernoulli_lpmf<false>(1, psi) +
                      bernoulli_lpmf<false>(1, lcm_sym271__)) +
                     bernoulli_lpmf<false>(0,
                       rvalue(p, "p",
                         index_uni(inline_sym31__), index_uni(1)))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(inline_sym15__, "inline_sym15__",
                        index_uni(inline_sym31__), index_uni(1)))),
                  "assigning variable inline_sym29__", index_uni(1));
                if (logical_gte(lcm_sym278__, 2)) {
                  current_statement__ = 84;
                  assign(inline_sym29__,
                    ((((bernoulli_lpmf<false>(1, psi) +
                         bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(lcm_sym211__, "lcm_sym211__",
                               index_min_max(1, 1))))) +
                        bernoulli_lpmf<false>(1,
                          rvalue(nu, "nu", index_uni(2)))) +
                       bernoulli_lpmf<false>(0,
                         rvalue(p, "p",
                           index_uni(inline_sym31__), index_uni(2)))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(inline_sym15__, "inline_sym15__",
                          index_uni(inline_sym31__), index_uni(2)))),
                    "assigning variable inline_sym29__", index_uni(2));
                  for (int inline_sym30__ = 3;
                       inline_sym30__ <= lcm_sym278__; ++inline_sym30__) {
                    current_statement__ = 84;
                    assign(inline_sym29__,
                      ((((bernoulli_lpmf<false>(1, psi) +
                           bernoulli_lpmf<false>(1,
                             prod(
                               rvalue(lcm_sym211__, "lcm_sym211__",
                                 index_min_max(1, (inline_sym30__ - 1)))))) +
                          bernoulli_lpmf<false>(1, nu[(inline_sym30__ - 1)]))
                         +
                         bernoulli_lpmf<false>(0,
                           rvalue(p, "p",
                             index_uni(inline_sym31__),
                               index_uni(inline_sym30__)))) +
                        bernoulli_lpmf<false>(1,
                          rvalue(inline_sym15__, "inline_sym15__",
                            index_uni(inline_sym31__),
                              index_uni(inline_sym30__)))),
                      "assigning variable inline_sym29__", index_uni(inline_sym30__));
                  }
                } 
                current_statement__ = 85;
                assign(inline_sym29__, bernoulli_lpmf<false>(0, psi),
                  "assigning variable inline_sym29__", index_uni(lcm_sym236__));
                current_statement__ = 86;
                lp_accum__.add(log_sum_exp(inline_sym29__));
              }
            }
          } 
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail6_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym193__;
      int lcm_sym192__;
      double lcm_sym191__;
      double lcm_sym190__;
      double lcm_sym189__;
      double lcm_sym188__;
      local_scalar_t__ lcm_sym187__;
      int lcm_sym186__;
      int lcm_sym185__;
      int lcm_sym184__;
      int lcm_sym183__;
      int lcm_sym182__;
      int lcm_sym181__;
      int lcm_sym180__;
      double lcm_sym179__;
      double lcm_sym178__;
      double lcm_sym177__;
      double lcm_sym176__;
      double lcm_sym175__;
      double lcm_sym174__;
      double lcm_sym173__;
      double lcm_sym172__;
      double lcm_sym171__;
      double lcm_sym170__;
      int lcm_sym169__;
      int lcm_sym168__;
      int lcm_sym167__;
      int lcm_sym166__;
      int lcm_sym165__;
      int lcm_sym164__;
      int lcm_sym163__;
      int lcm_sym162__;
      int lcm_sym161__;
      int lcm_sym160__;
      int lcm_sym159__;
      double lcm_sym158__;
      int lcm_sym157__;
      int lcm_sym156__;
      int lcm_sym155__;
      Eigen::Matrix<double, -1, -1> lcm_sym154__;
      std::vector<int> lcm_sym153__;
      std::vector<std::vector<int>> lcm_sym152__;
      Eigen::Matrix<double, -1, 1> lcm_sym151__;
      double lcm_sym146__;
      double lcm_sym145__;
      double lcm_sym144__;
      double lcm_sym143__;
      double lcm_sym150__;
      double lcm_sym149__;
      int lcm_sym148__;
      int lcm_sym142__;
      int lcm_sym141__;
      int lcm_sym140__;
      int lcm_sym139__;
      double lcm_sym138__;
      int lcm_sym137__;
      int lcm_sym136__;
      double lcm_sym135__;
      int lcm_sym134__;
      int lcm_sym133__;
      int lcm_sym132__;
      int lcm_sym131__;
      int lcm_sym130__;
      int lcm_sym129__;
      int lcm_sym128__;
      int lcm_sym127__;
      int lcm_sym126__;
      int lcm_sym125__;
      int lcm_sym124__;
      int lcm_sym123__;
      int lcm_sym122__;
      int lcm_sym121__;
      double lcm_sym120__;
      double lcm_sym119__;
      Eigen::Matrix<double, -1, 1> lcm_sym118__;
      double mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                   0, 1, lp__);
      double mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                 0, 1, lp__);
      double psi;
      current_statement__ = 3;
      psi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(0,
              1, lp__);
      Eigen::Matrix<double, -1, 1> beta;
      current_statement__ = 4;
      beta = in__.template read_constrain_lb<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
               0, lp__, n_occasions);
      Eigen::Matrix<double, -1, 1> epsilon;
      current_statement__ = 5;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(M);
      double sigma;
      current_statement__ = 6;
      sigma = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 5, lp__);
      Eigen::Matrix<double, -1, -1> phi;
      phi = Eigen::Matrix<double, -1, -1>(M, (n_occasions - 1));
      stan::math::fill(phi, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(M, n_occasions);
      stan::math::fill(p, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> b;
      b = Eigen::Matrix<double, -1, 1>(n_occasions);
      stan::math::fill(b, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, 1> nu;
      nu = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(nu, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      out__.write(mean_phi);
      out__.write(mean_p);
      out__.write(psi);
      out__.write(beta);
      out__.write(epsilon);
      out__.write(sigma);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym130__ = (n_occasions - 1);
      assign(lcm_sym154__, rep_matrix(mean_phi, M, lcm_sym130__),
        "assigning variable lcm_sym154__");
      assign(phi, lcm_sym154__, "assigning variable phi");
      lcm_sym122__ = logical_gte(n_occasions, 1);
      if (lcm_sym122__) {
        assign(lcm_sym151__, inv_logit(add(logit(mean_p), epsilon)),
          "assigning variable lcm_sym151__");
        assign(p, lcm_sym151__,
          "assigning variable p", index_omni(), index_uni(1));
        for (int t = 2; t <= n_occasions; ++t) {
          current_statement__ = 12;
          assign(p, lcm_sym151__,
            "assigning variable p", index_omni(), index_uni(t));
        }
      } 
      assign(lcm_sym118__, divide(beta, sum(beta)),
        "assigning variable lcm_sym118__");
      assign(b, lcm_sym118__, "assigning variable b");
      {
        local_scalar_t__ cum_b;
        lcm_sym187__ = rvalue(lcm_sym118__, "lcm_sym118__", index_uni(1));
        current_statement__ = 14;
        assign(nu, lcm_sym187__, "assigning variable nu", index_uni(1));
        current_statement__ = 18;
        if (logical_gte(lcm_sym130__, 2)) {
          current_statement__ = 15;
          assign(nu,
            (rvalue(lcm_sym118__, "lcm_sym118__", index_uni(2)) /
              (1.0 - lcm_sym187__)), "assigning variable nu", index_uni(2));
          current_statement__ = 16;
          cum_b = (lcm_sym187__ +
                    rvalue(lcm_sym118__, "lcm_sym118__", index_uni(2)));
          for (int t = 3; t <= lcm_sym130__; ++t) {
            current_statement__ = 15;
            assign(nu,
              (rvalue(lcm_sym118__, "lcm_sym118__", index_uni(t)) /
                (1.0 - cum_b)), "assigning variable nu", index_uni(t));
            current_statement__ = 16;
            cum_b = (cum_b +
                      rvalue(lcm_sym118__, "lcm_sym118__", index_uni(t)));
          }
        } 
        current_statement__ = 19;
        assign(nu, 1.0, "assigning variable nu", index_uni(n_occasions));
      }
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym1__;
      int inline_sym9__;
      inline_sym9__ = 0;
      for (int inline_sym10__ = 1; inline_sym10__ <= 1; ++inline_sym10__) {
        int inline_sym2__;
        lcm_sym155__ = rows(p);
        int inline_sym3__;
        lcm_sym148__ = cols(p);
        current_statement__ = 23;
        validate_non_negative_index("chi", "n_ind", lcm_sym155__);
        current_statement__ = 24;
        validate_non_negative_index("chi", "n_occasions", lcm_sym148__);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym4__;
        inline_sym4__ = Eigen::Matrix<local_scalar_t__, -1, -1>(lcm_sym155__, lcm_sym148__);
        stan::math::fill(inline_sym4__, DUMMY_VAR__);
        
        for (int inline_sym8__ = 1; inline_sym8__ <= lcm_sym155__;
             ++inline_sym8__) {
          current_statement__ = 26;
          assign(inline_sym4__, 1.0,
            "assigning variable inline_sym4__", index_uni(inline_sym8__),
                                                  index_uni(lcm_sym148__));
          lcm_sym132__ = (lcm_sym148__ - 1);
          if (logical_gte(lcm_sym132__, 1)) {
            int inline_sym5__;
            int inline_sym6__;
            lcm_sym137__ = (lcm_sym132__ + 1);
            current_statement__ = 29;
            assign(inline_sym4__,
              stan::math::fma(
                (rvalue(lcm_sym154__, "lcm_sym154__",
                   index_uni(inline_sym8__), index_uni(lcm_sym132__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(inline_sym8__), index_uni(lcm_sym137__)))),
                rvalue(inline_sym4__, "inline_sym4__",
                  index_uni(inline_sym8__), index_uni(lcm_sym137__)),
                (1 -
                  rvalue(lcm_sym154__, "lcm_sym154__",
                    index_uni(inline_sym8__), index_uni(lcm_sym132__)))),
              "assigning variable inline_sym4__", index_uni(inline_sym8__),
                                                    index_uni(lcm_sym132__));
            for (int inline_sym7__ = 2; inline_sym7__ <= lcm_sym132__;
                 ++inline_sym7__) {
              int inline_sym5__;
              lcm_sym131__ = (lcm_sym148__ - inline_sym7__);
              int inline_sym6__;
              lcm_sym136__ = (lcm_sym131__ + 1);
              current_statement__ = 29;
              assign(inline_sym4__,
                stan::math::fma(
                  (rvalue(lcm_sym154__, "lcm_sym154__",
                     index_uni(inline_sym8__), index_uni(lcm_sym131__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(inline_sym8__), index_uni(lcm_sym136__)))),
                  rvalue(inline_sym4__, "inline_sym4__",
                    index_uni(inline_sym8__), index_uni(lcm_sym136__)),
                  (1 -
                    rvalue(lcm_sym154__, "lcm_sym154__",
                      index_uni(inline_sym8__), index_uni(lcm_sym131__)))),
                "assigning variable inline_sym4__", index_uni(inline_sym8__),
                                                      index_uni(lcm_sym131__));
            }
          } 
          if (inline_sym9__) {
            break;
          } 
        }
        if (inline_sym9__) {
          break;
        } 
        inline_sym9__ = 1;
        assign(inline_sym1__, inline_sym4__,
          "assigning variable inline_sym1__");
        break;
      }
      assign(chi, inline_sym1__, "assigning variable chi");
      lcm_sym121__ = logical_gte(M, 1);
      if (lcm_sym121__) {
        lcm_sym124__ = logical_gte(lcm_sym130__, 1);
        if (lcm_sym124__) {
          current_statement__ = 7;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(lcm_sym154__, "lcm_sym154__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym130__; ++sym2__) {
            current_statement__ = 7;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(lcm_sym154__, "lcm_sym154__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym124__) {
            current_statement__ = 7;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(lcm_sym154__, "lcm_sym154__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym130__; ++sym2__) {
              current_statement__ = 7;
              check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                     rvalue(lcm_sym154__, "lcm_sym154__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 7;
      if (lcm_sym121__) {
        lcm_sym124__ = logical_gte(lcm_sym130__, 1);
        if (lcm_sym124__) {
          current_statement__ = 7;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(lcm_sym154__, "lcm_sym154__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= lcm_sym130__; ++sym2__) {
            current_statement__ = 7;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(lcm_sym154__, "lcm_sym154__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym124__) {
            current_statement__ = 7;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(lcm_sym154__, "lcm_sym154__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym130__; ++sym2__) {
              current_statement__ = 7;
              check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                  rvalue(lcm_sym154__, "lcm_sym154__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 8;
      if (lcm_sym121__) {
        current_statement__ = 8;
        if (lcm_sym122__) {
          current_statement__ = 8;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p, "p", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 8;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 8;
          if (lcm_sym122__) {
            current_statement__ = 8;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 8;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(p, "p",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 8;
      if (lcm_sym121__) {
        current_statement__ = 8;
        if (lcm_sym122__) {
          current_statement__ = 8;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p, "p", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 8;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 8;
          if (lcm_sym122__) {
            current_statement__ = 8;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 8;
              check_less_or_equal(function__, "p[sym1__, sym2__]",
                                  rvalue(p, "p",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 9;
      check_simplex(function__, "b", lcm_sym118__);
      current_statement__ = 10;
      if (lcm_sym122__) {
        current_statement__ = 10;
        check_greater_or_equal(function__, "nu[sym1__]",
                               rvalue(nu, "nu", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 10;
          check_greater_or_equal(function__, "nu[sym1__]", nu[(sym1__ - 1)],
                                 0);
        }
      } 
      current_statement__ = 10;
      if (lcm_sym122__) {
        current_statement__ = 10;
        check_less_or_equal(function__, "nu[sym1__]",
                            rvalue(nu, "nu", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 10;
          check_less_or_equal(function__, "nu[sym1__]", nu[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 11;
      if (lcm_sym121__) {
        current_statement__ = 11;
        if (lcm_sym122__) {
          current_statement__ = 11;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(inline_sym1__, "inline_sym1__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 11;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym1__, "inline_sym1__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 11;
          if (lcm_sym122__) {
            current_statement__ = 11;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym1__, "inline_sym1__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 11;
              check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                     rvalue(inline_sym1__, "inline_sym1__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 11;
      if (lcm_sym121__) {
        current_statement__ = 11;
        if (lcm_sym122__) {
          current_statement__ = 11;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(inline_sym1__, "inline_sym1__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 11;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym1__, "inline_sym1__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 11;
          if (lcm_sym122__) {
            current_statement__ = 11;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym1__, "inline_sym1__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 11;
              check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                  rvalue(inline_sym1__, "inline_sym1__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym154__);
        out__.write(p);
        out__.write(lcm_sym118__);
        out__.write(nu);
        out__.write(inline_sym1__);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double sigma2;
      sigma2 = std::numeric_limits<double>::quiet_NaN();
      
      int Nsuper;
      Nsuper = std::numeric_limits<int>::min();
      
      std::vector<int> N;
      N = std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      
      std::vector<int> B;
      B = std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      
      std::vector<std::vector<int>> z;
      z = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      lcm_sym158__ = square(sigma);
      sigma2 = lcm_sym158__;
      current_statement__ = 49;
      if (lcm_sym121__) {
        int q;
        current_statement__ = 47;
        if (bernoulli_rng(psi, base_rng__)) {
          current_statement__ = 41;
          assign(z,
            bernoulli_rng(rvalue(nu, "nu", index_uni(1)), base_rng__),
            "assigning variable z", index_uni(1), index_uni(1));
          current_statement__ = 45;
          if (logical_gte(n_occasions, 2)) {
            lcm_sym186__ = rvalue(z, "z", index_uni(1), index_uni(1));
            lcm_sym142__ = (1 * (1 - lcm_sym186__));
            q = lcm_sym142__;
            current_statement__ = 42;
            assign(z,
              bernoulli_rng(
                stan::math::fma(lcm_sym186__,
                  rvalue(lcm_sym154__, "lcm_sym154__",
                    index_uni(1), index_uni(1)),
                  (lcm_sym142__ * rvalue(nu, "nu", index_uni(2)))),
                base_rng__),
              "assigning variable z", index_uni(1), index_uni(2));
            for (int t = 3; t <= n_occasions; ++t) {
              current_statement__ = 43;
              q = (q *
                    (1 - rvalue(z, "z", index_uni(1), index_uni((t - 1)))));
              current_statement__ = 42;
              assign(z,
                bernoulli_rng(
                  stan::math::fma(
                    rvalue(z, "z", index_uni(1), index_uni((t - 1))),
                    rvalue(lcm_sym154__, "lcm_sym154__",
                      index_uni(1), index_uni((t - 1))),
                    (q * rvalue(nu, "nu", index_uni(t)))), base_rng__),
                "assigning variable z", index_uni(1), index_uni(t));
            }
          } 
        } else {
          current_statement__ = 39;
          assign(z, rep_array(0, n_occasions),
            "assigning variable z", index_uni(1), index_omni());
        }
        for (int i = 2; i <= M; ++i) {
          int q;
          current_statement__ = 47;
          if (bernoulli_rng(psi, base_rng__)) {
            current_statement__ = 41;
            assign(z,
              bernoulli_rng(rvalue(nu, "nu", index_uni(1)), base_rng__),
              "assigning variable z", index_uni(i), index_uni(1));
            current_statement__ = 45;
            if (logical_gte(n_occasions, 2)) {
              lcm_sym141__ = (1 *
                               (1 -
                                 rvalue(z, "z", index_uni(i), index_uni(1))));
              q = lcm_sym141__;
              current_statement__ = 42;
              assign(z,
                bernoulli_rng(
                  stan::math::fma(rvalue(z, "z", index_uni(i), index_uni(1)),
                    rvalue(lcm_sym154__, "lcm_sym154__",
                      index_uni(i), index_uni(1)),
                    (lcm_sym141__ * rvalue(nu, "nu", index_uni(2)))),
                  base_rng__),
                "assigning variable z", index_uni(i), index_uni(2));
              for (int t = 3; t <= n_occasions; ++t) {
                current_statement__ = 43;
                q = (q *
                      (1 - rvalue(z, "z", index_uni(i), index_uni((t - 1)))));
                current_statement__ = 42;
                assign(z,
                  bernoulli_rng(
                    stan::math::fma(
                      rvalue(z, "z", index_uni(i), index_uni((t - 1))),
                      rvalue(lcm_sym154__, "lcm_sym154__",
                        index_uni(i), index_uni((t - 1))),
                      (q * rvalue(nu, "nu", index_uni(t)))), base_rng__),
                  "assigning variable z", index_uni(i), index_uni(t));
              }
            } 
          } else {
            current_statement__ = 39;
            assign(z, rep_array(0, n_occasions),
              "assigning variable z", index_uni(i), index_omni());
          }
        }
      } 
      {
        current_statement__ = 50;
        validate_non_negative_index("recruit", "M", M);
        current_statement__ = 51;
        validate_non_negative_index("recruit", "n_occasions", n_occasions);
        std::vector<std::vector<int>> recruit;
        current_statement__ = 52;
        assign(recruit, rep_array(0, M, n_occasions),
          "assigning variable recruit");
        current_statement__ = 53;
        validate_non_negative_index("Nind", "M", M);
        std::vector<int> Nind;
        Nind = std::vector<int>(M, std::numeric_limits<int>::min());
        
        current_statement__ = 55;
        validate_non_negative_index("Nalive", "M", M);
        std::vector<int> Nalive;
        Nalive = std::vector<int>(M, std::numeric_limits<int>::min());
        
        current_statement__ = 64;
        if (lcm_sym121__) {
          int f;
          f = std::numeric_limits<int>::min();
          
          int inline_sym11__;
          int inline_sym13__;
          inline_sym13__ = 0;
          for (int inline_sym14__ = 1; inline_sym14__ <= 1; ++inline_sym14__) {
            lcm_sym157__ = size(rvalue(z, "z", index_uni(1)));
            for (int inline_sym12__ = 1; inline_sym12__ <= lcm_sym157__;
                 ++inline_sym12__) {
              current_statement__ = 59;
              if (rvalue(z, "z", index_uni(1), index_uni(inline_sym12__))) {
                inline_sym13__ = 1;
                inline_sym11__ = inline_sym12__;
                break;
              } 
            }
            if (inline_sym13__) {
              break;
            } 
            inline_sym13__ = 1;
            inline_sym11__ = 0;
            break;
          }
          current_statement__ = 62;
          if (logical_gt(inline_sym11__, 0)) {
            current_statement__ = 61;
            assign(recruit, 1,
              "assigning variable recruit", index_uni(1),
                                              index_uni(inline_sym11__));
          } 
          for (int i = 2; i <= M; ++i) {
            int f;
            f = std::numeric_limits<int>::min();
            
            int inline_sym11__;
            int inline_sym13__;
            inline_sym13__ = 0;
            for (int inline_sym14__ = 1; inline_sym14__ <= 1;
                 ++inline_sym14__) {
              lcm_sym156__ = size(rvalue(z, "z", index_uni(i)));
              for (int inline_sym12__ = 1; inline_sym12__ <= lcm_sym156__;
                   ++inline_sym12__) {
                current_statement__ = 59;
                if (rvalue(z, "z", index_uni(i), index_uni(inline_sym12__))) {
                  inline_sym13__ = 1;
                  inline_sym11__ = inline_sym12__;
                  break;
                } 
              }
              if (inline_sym13__) {
                break;
              } 
              inline_sym13__ = 1;
              inline_sym11__ = 0;
              break;
            }
            current_statement__ = 62;
            if (logical_gt(inline_sym11__, 0)) {
              current_statement__ = 61;
              assign(recruit, 1,
                "assigning variable recruit", index_uni(i),
                                                index_uni(inline_sym11__));
            } 
          }
        } 
        current_statement__ = 68;
        if (lcm_sym122__) {
          current_statement__ = 65;
          assign(N, sum(rvalue(z, "z", index_omni(), index_uni(1))),
            "assigning variable N", index_uni(1));
          current_statement__ = 66;
          assign(B,
            sum(rvalue(recruit, "recruit", index_omni(), index_uni(1))),
            "assigning variable B", index_uni(1));
          for (int t = 2; t <= n_occasions; ++t) {
            current_statement__ = 65;
            assign(N, sum(rvalue(z, "z", index_omni(), index_uni(t))),
              "assigning variable N", index_uni(t));
            current_statement__ = 66;
            assign(B,
              sum(rvalue(recruit, "recruit", index_omni(), index_uni(t))),
              "assigning variable B", index_uni(t));
          }
        } 
        current_statement__ = 72;
        if (lcm_sym121__) {
          current_statement__ = 69;
          assign(Nind, sum(rvalue(z, "z", index_uni(1))),
            "assigning variable Nind", index_uni(1));
          current_statement__ = 70;
          assign(Nalive, logical_gt(rvalue(Nind, "Nind", index_uni(1)), 0),
            "assigning variable Nalive", index_uni(1));
          for (int i = 2; i <= M; ++i) {
            current_statement__ = 69;
            assign(Nind, sum(rvalue(z, "z", index_uni(i))),
              "assigning variable Nind", index_uni(i));
            current_statement__ = 70;
            assign(Nalive, logical_gt(rvalue(Nind, "Nind", index_uni(i)), 0),
              "assigning variable Nalive", index_uni(i));
          }
        } 
        current_statement__ = 73;
        Nsuper = sum(Nalive);
      }
      current_statement__ = 33;
      check_greater_or_equal(function__, "sigma2", lcm_sym158__, 0);
      current_statement__ = 34;
      check_greater_or_equal(function__, "Nsuper", Nsuper, 0);
      current_statement__ = 35;
      if (lcm_sym122__) {
        current_statement__ = 35;
        check_greater_or_equal(function__, "N[sym1__]",
                               rvalue(N, "N", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 35;
          check_greater_or_equal(function__, "N[sym1__]", N[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 36;
      if (lcm_sym122__) {
        current_statement__ = 36;
        check_greater_or_equal(function__, "B[sym1__]",
                               rvalue(B, "B", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 36;
          check_greater_or_equal(function__, "B[sym1__]", B[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 37;
      if (lcm_sym121__) {
        current_statement__ = 37;
        if (lcm_sym122__) {
          current_statement__ = 37;
          check_greater_or_equal(function__, "z[sym1__, sym2__]",
                                 rvalue(z, "z", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 37;
            check_greater_or_equal(function__, "z[sym1__, sym2__]",
                                   rvalue(z, "z",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 37;
          if (lcm_sym122__) {
            current_statement__ = 37;
            check_greater_or_equal(function__, "z[sym1__, sym2__]",
                                   rvalue(z, "z",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 37;
              check_greater_or_equal(function__, "z[sym1__, sym2__]",
                                     z[(sym1__ - 1)][(sym2__ - 1)], 0);
            }
          } 
        }
      } 
      current_statement__ = 37;
      if (lcm_sym121__) {
        current_statement__ = 37;
        if (lcm_sym122__) {
          current_statement__ = 37;
          check_less_or_equal(function__, "z[sym1__, sym2__]",
                              rvalue(z, "z", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 37;
            check_less_or_equal(function__, "z[sym1__, sym2__]",
                                rvalue(z, "z",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 37;
          if (lcm_sym122__) {
            current_statement__ = 37;
            check_less_or_equal(function__, "z[sym1__, sym2__]",
                                rvalue(z, "z",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 37;
              check_less_or_equal(function__, "z[sym1__, sym2__]",
                                  z[(sym1__ - 1)][(sym2__ - 1)], 1);
            }
          } 
        }
      } 
      out__.write(lcm_sym158__);
      out__.write(Nsuper);
      out__.write(N);
      out__.write(B);
      if (lcm_sym122__) {
        if (lcm_sym121__) {
          out__.write(rvalue(z, "z", index_uni(1), index_uni(1)));
          for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
            out__.write(rvalue(z, "z", index_uni(sym2__), index_uni(1)));
          }
        } 
        for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym121__) {
            out__.write(rvalue(z, "z", index_uni(1), index_uni(sym1__)));
            for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
              out__.write(z[(sym2__ - 1)][(sym1__ - 1)]);
            }
          } 
        }
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym117__;
      int lcm_sym116__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ mean_phi;
      mean_phi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      local_scalar_t__ psi;
      psi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, psi);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(beta, DUMMY_VAR__);
      
      if (logical_gte(n_occasions, 1)) {
        assign(beta, in__.read<local_scalar_t__>(),
          "assigning variable beta", index_uni(1));
        for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          assign(beta, in__.read<local_scalar_t__>(),
            "assigning variable beta", index_uni(sym1__));
        }
      } 
      out__.write_free_lb(0, beta);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon;
      epsilon = Eigen::Matrix<local_scalar_t__, -1, 1>(M);
      stan::math::fill(epsilon, DUMMY_VAR__);
      
      if (logical_gte(M, 1)) {
        assign(epsilon, in__.read<local_scalar_t__>(),
          "assigning variable epsilon", index_uni(1));
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          assign(epsilon, in__.read<local_scalar_t__>(),
            "assigning variable epsilon", index_uni(sym1__));
        }
      } 
      out__.write(epsilon);
      local_scalar_t__ sigma;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 5, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mean_phi", "mean_p", "psi", "beta",
      "epsilon", "sigma", "phi", "p", "b", "nu", "chi", "sigma2", "Nsuper",
      "N", "B", "z"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(M)}, std::vector<size_t>{
      },
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(phi_2dim__)},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(n_occasions)},
      std::vector<size_t>{}, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(n_occasions)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    param_names__.emplace_back(std::string() + "psi");
    for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym307__));
      } 
    }
    for (int sym307__ = 1; sym307__ <= M; ++sym307__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym307__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym307__ = 1; sym307__ <= phi_2dim__; ++sym307__) {
        {
          for (int sym308__ = 1; sym308__ <= M; ++sym308__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym308__) + '.' + std::to_string(sym307__));
            } 
          }
        } 
      }
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          for (int sym308__ = 1; sym308__ <= M; ++sym308__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym308__) + '.' + std::to_string(sym307__));
            } 
          }
        } 
      }
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym307__));
        } 
      }
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          param_names__.emplace_back(std::string() + "nu" + '.' + std::to_string(sym307__));
        } 
      }
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          for (int sym308__ = 1; sym308__ <= M; ++sym308__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym308__) + '.' + std::to_string(sym307__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          param_names__.emplace_back(std::string() + "N" + '.' + std::to_string(sym307__));
        } 
      }
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          param_names__.emplace_back(std::string() + "B" + '.' + std::to_string(sym307__));
        } 
      }
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          for (int sym308__ = 1; sym308__ <= M; ++sym308__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym308__) + '.' + std::to_string(sym307__));
            } 
          }
        } 
      }
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    param_names__.emplace_back(std::string() + "psi");
    for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym307__));
      } 
    }
    for (int sym307__ = 1; sym307__ <= M; ++sym307__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym307__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym307__ = 1; sym307__ <= phi_2dim__; ++sym307__) {
        {
          for (int sym308__ = 1; sym308__ <= M; ++sym308__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym308__) + '.' + std::to_string(sym307__));
            } 
          }
        } 
      }
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          for (int sym308__ = 1; sym308__ <= M; ++sym308__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym308__) + '.' + std::to_string(sym307__));
            } 
          }
        } 
      }
      for (int sym307__ = 1; sym307__ <= (n_occasions - 1); ++sym307__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym307__));
        } 
      }
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          param_names__.emplace_back(std::string() + "nu" + '.' + std::to_string(sym307__));
        } 
      }
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          for (int sym308__ = 1; sym308__ <= M; ++sym308__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym308__) + '.' + std::to_string(sym307__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          param_names__.emplace_back(std::string() + "N" + '.' + std::to_string(sym307__));
        } 
      }
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          param_names__.emplace_back(std::string() + "B" + '.' + std::to_string(sym307__));
        } 
      }
      for (int sym307__ = 1; sym307__ <= n_occasions; ++sym307__) {
        {
          for (int sym308__ = 1; sym308__ <= M; ++sym308__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym308__) + '.' + std::to_string(sym307__));
            } 
          }
        } 
      }
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(phi_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"nu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(phi_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((n_occasions - 1)) + "},\"block\":\"transformed_parameters\"},{\"name\":\"nu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((1 + 1) + 1) + n_occasions) + M) + 1);
      const size_t num_transformed = 
  (((((M * phi_2dim__) + (M * n_occasions)) + n_occasions) + n_occasions) +
    (M * n_occasions));
      const size_t num_gen_quantities = ((((1 + 1) +
                                                                    n_occasions)
                                                                   +
                                                                   n_occasions)
                                                                  +
                                                                  (M *
                                                                    n_occasions));
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((1 + 1) + 1) + n_occasions) + M) + 1);
      const size_t num_transformed = 
  (((((M * phi_2dim__) + (M * n_occasions)) + n_occasions) + n_occasions) +
    (M * n_occasions));
      const size_t num_gen_quantities = ((((1 + 1) +
                                                                    n_occasions)
                                                                   +
                                                                   n_occasions)
                                                                  +
                                                                  (M *
                                                                    n_occasions));
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 6> names__{"mean_phi", "mean_p", "psi"
      , "beta", "epsilon", "sigma"};
      const std::array<Eigen::Index, 6> constrain_param_sizes__{1, 1, 
       1, n_occasions, M, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail6_model_namespace::expr_prop_fail6_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail6_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail7.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail7_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 37> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail7.stan', line 20, column 2 to column 16)",
 " (in 'expr-prop-fail7.stan', line 21, column 2 to column 24)",
 " (in 'expr-prop-fail7.stan', line 40, column 2 to column 24)",
 " (in 'expr-prop-fail7.stan', line 42, column 11 to column 12)",
 " (in 'expr-prop-fail7.stan', line 42, column 4 to column 30)",
 " (in 'expr-prop-fail7.stan', line 44, column 6 to column 51)",
 " (in 'expr-prop-fail7.stan', line 45, column 4 to column 45)",
 " (in 'expr-prop-fail7.stan', line 43, column 4 to line 44, column 51)",
 " (in 'expr-prop-fail7.stan', line 41, column 17 to line 46, column 3)",
 " (in 'expr-prop-fail7.stan', line 25, column 2 to column 24)",
 " (in 'expr-prop-fail7.stan', line 28, column 6 to column 39)",
 " (in 'expr-prop-fail7.stan', line 27, column 4 to line 28, column 39)",
 " (in 'expr-prop-fail7.stan', line 32, column 11 to column 12)",
 " (in 'expr-prop-fail7.stan', line 32, column 4 to column 30)",
 " (in 'expr-prop-fail7.stan', line 34, column 6 to column 51)",
 " (in 'expr-prop-fail7.stan', line 33, column 4 to line 34, column 51)",
 " (in 'expr-prop-fail7.stan', line 35, column 4 to column 33)",
 " (in 'expr-prop-fail7.stan', line 31, column 17 to line 36, column 3)",
 " (in 'expr-prop-fail7.stan', line 31, column 2 to line 36, column 3)",
 " (in 'expr-prop-fail7.stan', line 12, column 2 to column 17)",
 " (in 'expr-prop-fail7.stan', line 13, column 2 to column 17)",
 " (in 'expr-prop-fail7.stan', line 14, column 2 to column 17)",
 " (in 'expr-prop-fail7.stan', line 15, column 25 to column 26)",
 " (in 'expr-prop-fail7.stan', line 15, column 27 to column 28)",
 " (in 'expr-prop-fail7.stan', line 15, column 2 to column 30)",
 " (in 'expr-prop-fail7.stan', line 16, column 18 to column 19)",
 " (in 'expr-prop-fail7.stan', line 16, column 2 to column 27)",
 " (in 'expr-prop-fail7.stan', line 17, column 26 to column 27)",
 " (in 'expr-prop-fail7.stan', line 17, column 18 to column 19)",
 " (in 'expr-prop-fail7.stan', line 17, column 2 to column 29)",
 " (in 'expr-prop-fail7.stan', line 20, column 10 to column 11)",
 " (in 'expr-prop-fail7.stan', line 21, column 19 to column 20)",
 " (in 'expr-prop-fail7.stan', line 21, column 21 to column 22)",
 " (in 'expr-prop-fail7.stan', line 21, column 10 to column 11)",
 " (in 'expr-prop-fail7.stan', line 40, column 21 to column 22)",
 " (in 'expr-prop-fail7.stan', line 40, column 9 to column 10)"};



class expr_prop_fail7_model final : public model_base_crtp<expr_prop_fail7_model> {

 private:
  int lcm_sym59__;
  int lcm_sym58__;
  int lcm_sym57__;
  int lcm_sym56__;
  int lcm_sym55__;
  int lcm_sym54__;
  double lcm_sym53__;
  double lcm_sym52__;
  double lcm_sym51__;
  double lcm_sym50__;
  double lcm_sym49__;
  double lcm_sym48__;
  double lcm_sym47__;
  double lcm_sym46__;
  double lcm_sym45__;
  double lcm_sym44__;
  int lcm_sym43__;
  int lcm_sym42__;
  int lcm_sym41__;
  int lcm_sym40__;
  int K;
  int I;
  int J;
  std::vector<std::vector<int>> y;
  Eigen::Matrix<double, -1, 1> alpha__;
  std::vector<Eigen::Matrix<double, -1, 1>> beta; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> alpha{nullptr, 0};
 
 public:
  ~expr_prop_fail7_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail7_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail7_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail7_model_namespace::expr_prop_fail7_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 20;
      context__.validate_dims("data initialization","K","int",
           std::vector<size_t>{});
      K = std::numeric_limits<int>::min();
      
      current_statement__ = 20;
      K = context__.vals_i("K")[(1 - 1)];
      current_statement__ = 20;
      check_greater_or_equal(function__, "K", K, 2);
      current_statement__ = 21;
      context__.validate_dims("data initialization","I","int",
           std::vector<size_t>{});
      I = std::numeric_limits<int>::min();
      
      current_statement__ = 21;
      I = context__.vals_i("I")[(1 - 1)];
      current_statement__ = 21;
      check_greater_or_equal(function__, "I", I, 1);
      current_statement__ = 22;
      context__.validate_dims("data initialization","J","int",
           std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      
      current_statement__ = 22;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 22;
      check_greater_or_equal(function__, "J", J, 1);
      current_statement__ = 23;
      validate_non_negative_index("y", "I", I);
      current_statement__ = 24;
      validate_non_negative_index("y", "J", J);
      current_statement__ = 25;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(I),
            static_cast<size_t>(J)});
      y = std::vector<std::vector<int>>(I, std::vector<int>(J, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 25;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 25;
        pos__ = 1;
        lcm_sym41__ = logical_gte(J, 1);
        if (lcm_sym41__) {
          {
            lcm_sym40__ = logical_gte(I, 1);
            if (lcm_sym40__) {
              current_statement__ = 25;
              assign(y, rvalue(y_flat__, "y_flat__", index_uni(1)),
                "assigning variable y", index_uni(1), index_uni(1));
              current_statement__ = 25;
              pos__ = 2;
              for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
                current_statement__ = 25;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(sym2__), index_uni(1));
                current_statement__ = 25;
                pos__ = (pos__ + 1);
              }
            } 
            for (int sym1__ = 2; sym1__ <= J; ++sym1__) {
              current_statement__ = 25;
              if (lcm_sym40__) {
                current_statement__ = 25;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(1), index_uni(sym1__));
                current_statement__ = 25;
                pos__ = (pos__ + 1);
                for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
                  current_statement__ = 25;
                  assign(y, y_flat__[(pos__ - 1)],
                    "assigning variable y", index_uni(sym2__),
                                              index_uni(sym1__));
                  current_statement__ = 25;
                  pos__ = (pos__ + 1);
                }
              } 
            }
          }
        } else {
          lcm_sym40__ = logical_gte(I, 1);
        }
      }
      current_statement__ = 25;
      if (lcm_sym40__) {
        current_statement__ = 25;
        if (lcm_sym41__) {
          current_statement__ = 25;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 rvalue(y, "y", index_uni(1), index_uni(1)),
                                 1);
          for (int sym2__ = 2; sym2__ <= J; ++sym2__) {
            current_statement__ = 25;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= I; ++sym1__) {
          current_statement__ = 25;
          if (lcm_sym41__) {
            current_statement__ = 25;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= J; ++sym2__) {
              current_statement__ = 25;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 1);
            }
          } 
        }
      } 
      current_statement__ = 25;
      if (lcm_sym40__) {
        current_statement__ = 25;
        if (lcm_sym41__) {
          current_statement__ = 25;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              rvalue(y, "y", index_uni(1), index_uni(1)), K);
          for (int sym2__ = 2; sym2__ <= J; ++sym2__) {
            current_statement__ = 25;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(1), index_uni(sym2__)), K);
          }
        } 
        for (int sym1__ = 2; sym1__ <= I; ++sym1__) {
          current_statement__ = 25;
          if (lcm_sym41__) {
            current_statement__ = 25;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(sym1__), index_uni(1)), K);
            for (int sym2__ = 2; sym2__ <= J; ++sym2__) {
              current_statement__ = 25;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], K);
            }
          } 
        }
      } 
      current_statement__ = 26;
      validate_non_negative_index("alpha", "K", K);
      current_statement__ = 27;
      context__.validate_dims("data initialization","alpha","double",
           std::vector<size_t>{static_cast<size_t>(K)});
      alpha__ = Eigen::Matrix<double, -1, 1>(K);
      new (&alpha) Eigen::Map<Eigen::Matrix<double, -1, 1>>(alpha__.data(), K);
      
      
      {
        std::vector<double> alpha_flat__;
        current_statement__ = 27;
        alpha_flat__ = context__.vals_r("alpha");
        current_statement__ = 27;
        pos__ = 1;
        lcm_sym42__ = logical_gte(K, 1);
        if (lcm_sym42__) {
          current_statement__ = 27;
          assign(alpha, rvalue(alpha_flat__, "alpha_flat__", index_uni(1)),
            "assigning variable alpha", index_uni(1));
          current_statement__ = 27;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
            current_statement__ = 27;
            assign(alpha, alpha_flat__[(pos__ - 1)],
              "assigning variable alpha", index_uni(sym1__));
            current_statement__ = 27;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 27;
      if (lcm_sym42__) {
        current_statement__ = 27;
        check_greater_or_equal(function__, "alpha[sym1__]",
                               rvalue(alpha, "alpha", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
          current_statement__ = 27;
          check_greater_or_equal(function__, "alpha[sym1__]",
                                 alpha[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 28;
      validate_non_negative_index("beta", "K", K);
      current_statement__ = 29;
      validate_non_negative_index("beta", "K", K);
      current_statement__ = 30;
      context__.validate_dims("data initialization","beta","double",
           std::vector<size_t>{static_cast<size_t>(K),
            static_cast<size_t>(K)});
      beta = std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(K));
      
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 30;
        beta_flat__ = context__.vals_r("beta");
        current_statement__ = 30;
        pos__ = 1;
        current_statement__ = 30;
        if (lcm_sym42__) {
          current_statement__ = 30;
          if (lcm_sym42__) {
            current_statement__ = 30;
            assign(beta, rvalue(beta_flat__, "beta_flat__", index_uni(1)),
              "assigning variable beta", index_uni(1), index_uni(1));
            current_statement__ = 30;
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
              current_statement__ = 30;
              assign(beta, beta_flat__[(pos__ - 1)],
                "assigning variable beta", index_uni(sym2__), index_uni(1));
              current_statement__ = 30;
              pos__ = (pos__ + 1);
            }
          } 
          for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
            current_statement__ = 30;
            if (lcm_sym42__) {
              current_statement__ = 30;
              assign(beta, beta_flat__[(pos__ - 1)],
                "assigning variable beta", index_uni(1), index_uni(sym1__));
              current_statement__ = 30;
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
                current_statement__ = 30;
                assign(beta, beta_flat__[(pos__ - 1)],
                  "assigning variable beta", index_uni(sym2__),
                                               index_uni(sym1__));
                current_statement__ = 30;
                pos__ = (pos__ + 1);
              }
            } 
          }
        } 
      }
      current_statement__ = 30;
      if (lcm_sym42__) {
        current_statement__ = 30;
        if (lcm_sym42__) {
          current_statement__ = 30;
          check_greater_or_equal(function__, "beta[sym1__, sym2__]",
                                 rvalue(beta, "beta",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
            current_statement__ = 30;
            check_greater_or_equal(function__, "beta[sym1__, sym2__]",
                                   rvalue(beta, "beta",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
          current_statement__ = 30;
          if (lcm_sym42__) {
            current_statement__ = 30;
            check_greater_or_equal(function__, "beta[sym1__, sym2__]",
                                   rvalue(beta, "beta",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
              current_statement__ = 30;
              check_greater_or_equal(function__, "beta[sym1__, sym2__]",
                                     beta[(sym1__ - 1)][(sym2__ - 1)], 0);
            }
          } 
        }
      } 
      current_statement__ = 31;
      validate_positive_index("pi", "K", K);
      current_statement__ = 32;
      validate_non_negative_index("theta", "J", J);
      current_statement__ = 33;
      validate_non_negative_index("theta", "K", K);
      current_statement__ = 34;
      validate_positive_index("theta", "K", K);
      current_statement__ = 35;
      validate_non_negative_index("log_Pr_z", "I", I);
      current_statement__ = 36;
      validate_non_negative_index("log_Pr_z", "K", K);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (K - 1) + (J * K * (K - 1));
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail7_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym39__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym38__;
      double lcm_sym37__;
      double lcm_sym36__;
      double lcm_sym35__;
      double lcm_sym34__;
      double lcm_sym33__;
      Eigen::Matrix<double, -1, 1> lcm_sym32__;
      Eigen::Matrix<double, -1, 1> lcm_sym31__;
      Eigen::Matrix<double, -1, 1> lcm_sym30__;
      Eigen::Matrix<double, -1, 1> lcm_sym29__;
      int lcm_sym28__;
      int lcm_sym27__;
      int lcm_sym26__;
      Eigen::Matrix<local_scalar_t__, -1, 1> pi;
      current_statement__ = 1;
      pi = in__.template read_constrain_simplex<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
             lp__, K);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> theta;
      current_statement__ = 2;
      theta = in__.template read_constrain_simplex<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>, jacobian__>(
                lp__, J, K, K);
      {
        current_statement__ = 10;
        lp_accum__.add(dirichlet_lpdf<propto__>(pi, alpha));
        lcm_sym27__ = logical_gte(J, 1);
        if (lcm_sym27__) {
          lcm_sym28__ = logical_gte(K, 1);
          if (lcm_sym28__) {
            current_statement__ = 11;
            lp_accum__.add(
              dirichlet_lpdf<propto__>(
                rvalue(theta, "theta", index_uni(1), index_uni(1)),
                rvalue(beta, "beta", index_uni(1))));
            for (int k = 2; k <= K; ++k) {
              current_statement__ = 11;
              lp_accum__.add(
                dirichlet_lpdf<propto__>(
                  rvalue(theta, "theta", index_uni(1), index_uni(k)),
                  rvalue(beta, "beta", index_uni(k))));
            }
          } 
          for (int j = 2; j <= J; ++j) {
            current_statement__ = 12;
            if (lcm_sym28__) {
              current_statement__ = 11;
              lp_accum__.add(
                dirichlet_lpdf<propto__>(
                  rvalue(theta, "theta", index_uni(j), index_uni(1)),
                  rvalue(beta, "beta", index_uni(1))));
              for (int k = 2; k <= K; ++k) {
                current_statement__ = 11;
                lp_accum__.add(
                  dirichlet_lpdf<propto__>(
                    rvalue(theta, "theta", index_uni(j), index_uni(k)),
                    rvalue(beta, "beta", index_uni(k))));
              }
            } 
          }
        } 
        current_statement__ = 19;
        if (logical_gte(I, 1)) {
          current_statement__ = 13;
          validate_non_negative_index("log_q", "K", K);
          Eigen::Matrix<local_scalar_t__, -1, 1> log_q;
          assign(lcm_sym38__, stan::math::log(pi),
            "assigning variable lcm_sym38__");
          assign(log_q, lcm_sym38__, "assigning variable log_q");
          current_statement__ = 16;
          if (lcm_sym27__) {
            current_statement__ = 15;
            assign(log_q,
              add(lcm_sym38__,
                to_vector(
                  stan::math::log(
                    rvalue(theta, "theta",
                      index_uni(1), index_omni(),
                        index_uni(rvalue(y, "y", index_uni(1), index_uni(1))))))),
              "assigning variable log_q");
            for (int j = 2; j <= J; ++j) {
              current_statement__ = 15;
              assign(log_q,
                add(stan::model::deep_copy(log_q),
                  to_vector(
                    stan::math::log(
                      rvalue(theta, "theta",
                        index_uni(j), index_omni(),
                          index_uni(rvalue(y, "y",
                                      index_uni(1), index_uni(j))))))),
                "assigning variable log_q");
            }
          } 
          current_statement__ = 17;
          lp_accum__.add(log_sum_exp(log_q));
          for (int i = 2; i <= I; ++i) {
            current_statement__ = 13;
            validate_non_negative_index("log_q", "K", K);
            Eigen::Matrix<local_scalar_t__, -1, 1> log_q;
            current_statement__ = 14;
            assign(log_q, lcm_sym38__, "assigning variable log_q");
            current_statement__ = 16;
            if (lcm_sym27__) {
              current_statement__ = 15;
              assign(log_q,
                add(lcm_sym38__,
                  to_vector(
                    stan::math::log(
                      rvalue(theta, "theta",
                        index_uni(1), index_omni(),
                          index_uni(rvalue(y, "y",
                                      index_uni(i), index_uni(1))))))),
                "assigning variable log_q");
              for (int j = 2; j <= J; ++j) {
                current_statement__ = 15;
                assign(log_q,
                  add(stan::model::deep_copy(log_q),
                    to_vector(
                      stan::math::log(
                        rvalue(theta, "theta",
                          index_uni(j), index_omni(),
                            index_uni(rvalue(y, "y",
                                        index_uni(i), index_uni(j))))))),
                  "assigning variable log_q");
              }
            } 
            current_statement__ = 17;
            lp_accum__.add(log_sum_exp(log_q));
          }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail7_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym25__;
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      Eigen::Matrix<double, -1, 1> lcm_sym13__;
      Eigen::Matrix<double, -1, 1> lcm_sym12__;
      Eigen::Matrix<double, -1, 1> lcm_sym11__;
      Eigen::Matrix<double, -1, 1> lcm_sym10__;
      Eigen::Matrix<double, -1, 1> lcm_sym9__;
      int lcm_sym8__;
      int lcm_sym7__;
      Eigen::Matrix<double, -1, 1> lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      Eigen::Matrix<double, -1, 1> pi;
      current_statement__ = 1;
      pi = in__.template read_constrain_simplex<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
             lp__, K);
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> theta;
      current_statement__ = 2;
      theta = in__.template read_constrain_simplex<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>, jacobian__>(
                lp__, J, K, K);
      out__.write(pi);
      lcm_sym5__ = logical_gte(K, 1);
      if (lcm_sym5__) {
        if (lcm_sym5__) {
          lcm_sym4__ = logical_gte(J, 1);
          if (lcm_sym4__) {
            out__.write(
              rvalue(theta, "theta",
                index_uni(1), index_uni(1), index_uni(1)));
            for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
              out__.write(
                rvalue(theta, "theta",
                  index_uni(sym3__), index_uni(1), index_uni(1)));
            }
          } 
          for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
            if (lcm_sym4__) {
              out__.write(
                rvalue(theta, "theta",
                  index_uni(1), index_uni(sym2__), index_uni(1)));
              for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                out__.write(
                  rvalue(theta, "theta",
                    index_uni(sym3__), index_uni(sym2__), index_uni(1)));
              }
            } 
          }
        } 
        for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
          if (lcm_sym5__) {
            lcm_sym4__ = logical_gte(J, 1);
            if (lcm_sym4__) {
              out__.write(
                rvalue(theta, "theta",
                  index_uni(1), index_uni(1), index_uni(sym1__)));
              for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                out__.write(
                  rvalue(theta, "theta",
                    index_uni(sym3__), index_uni(1), index_uni(sym1__)));
              }
            } 
            for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
              if (lcm_sym4__) {
                out__.write(
                  rvalue(theta, "theta",
                    index_uni(1), index_uni(sym2__), index_uni(sym1__)));
                for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                  out__.write(
                    theta[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
                }
              } 
            }
          } 
        }
      } 
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      std::vector<Eigen::Matrix<double, -1, 1>> log_Pr_z;
      log_Pr_z = std::vector<Eigen::Matrix<double, -1, 1>>(I, Eigen::Matrix<double, -1, 1>(K));
      stan::math::fill(log_Pr_z, std::numeric_limits<double>::quiet_NaN());
      
      lcm_sym3__ = logical_gte(I, 1);
      if (lcm_sym3__) {
        current_statement__ = 4;
        validate_non_negative_index("log_q", "K", K);
        Eigen::Matrix<double, -1, 1> log_q;
        assign(lcm_sym13__, stan::math::log(pi),
          "assigning variable lcm_sym13__");
        assign(log_q, lcm_sym13__, "assigning variable log_q");
        lcm_sym4__ = logical_gte(J, 1);
        if (lcm_sym4__) {
          current_statement__ = 6;
          assign(log_q,
            add(lcm_sym13__,
              to_vector(
                stan::math::log(
                  rvalue(theta, "theta",
                    index_uni(1), index_omni(),
                      index_uni(rvalue(y, "y", index_uni(1), index_uni(1))))))),
            "assigning variable log_q");
          for (int j = 2; j <= J; ++j) {
            current_statement__ = 6;
            assign(log_q,
              add(stan::model::deep_copy(log_q),
                to_vector(
                  stan::math::log(
                    rvalue(theta, "theta",
                      index_uni(j), index_omni(),
                        index_uni(rvalue(y, "y", index_uni(1), index_uni(j))))))),
              "assigning variable log_q");
          }
        } 
        current_statement__ = 7;
        assign(log_Pr_z, subtract(log_q, log_sum_exp(log_q)),
          "assigning variable log_Pr_z", index_uni(1));
        for (int i = 2; i <= I; ++i) {
          current_statement__ = 4;
          validate_non_negative_index("log_q", "K", K);
          Eigen::Matrix<double, -1, 1> log_q;
          current_statement__ = 5;
          assign(log_q, lcm_sym13__, "assigning variable log_q");
          current_statement__ = 8;
          if (lcm_sym4__) {
            current_statement__ = 6;
            assign(log_q,
              add(lcm_sym13__,
                to_vector(
                  stan::math::log(
                    rvalue(theta, "theta",
                      index_uni(1), index_omni(),
                        index_uni(rvalue(y, "y", index_uni(i), index_uni(1))))))),
              "assigning variable log_q");
            for (int j = 2; j <= J; ++j) {
              current_statement__ = 6;
              assign(log_q,
                add(stan::model::deep_copy(log_q),
                  to_vector(
                    stan::math::log(
                      rvalue(theta, "theta",
                        index_uni(j), index_omni(),
                          index_uni(rvalue(y, "y",
                                      index_uni(i), index_uni(j))))))),
                "assigning variable log_q");
            }
          } 
          current_statement__ = 7;
          assign(log_Pr_z, subtract(log_q, log_sum_exp(log_q)),
            "assigning variable log_Pr_z", index_uni(i));
        }
      } 
      if (lcm_sym5__) {
        if (lcm_sym3__) {
          out__.write(
            rvalue(log_Pr_z, "log_Pr_z", index_uni(1), index_uni(1)));
          for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
            out__.write(
              rvalue(log_Pr_z, "log_Pr_z", index_uni(sym2__), index_uni(1)));
          }
        } 
        for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
          if (lcm_sym3__) {
            out__.write(
              rvalue(log_Pr_z, "log_Pr_z", index_uni(1), index_uni(sym1__)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(log_Pr_z[(sym2__ - 1)][(sym1__ - 1)]);
            }
          } 
        }
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, 1> pi;
      pi = Eigen::Matrix<local_scalar_t__, -1, 1>(K);
      stan::math::fill(pi, DUMMY_VAR__);
      
      lcm_sym2__ = logical_gte(K, 1);
      if (lcm_sym2__) {
        assign(pi, in__.read<local_scalar_t__>(),
          "assigning variable pi", index_uni(1));
        for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
          assign(pi, in__.read<local_scalar_t__>(),
            "assigning variable pi", index_uni(sym1__));
        }
      } 
      out__.write_free_simplex(pi);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> theta;
      theta = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(J, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(K)));
      stan::math::fill(theta, DUMMY_VAR__);
      
      if (lcm_sym2__) {
        if (lcm_sym2__) {
          lcm_sym1__ = logical_gte(J, 1);
          if (lcm_sym1__) {
            assign(theta, in__.read<local_scalar_t__>(),
              "assigning variable theta", index_uni(1), index_uni(1),
                                            index_uni(1));
            for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
              assign(theta, in__.read<local_scalar_t__>(),
                "assigning variable theta", index_uni(sym3__), index_uni(1),
                                              index_uni(1));
            }
          } 
          for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
            if (lcm_sym1__) {
              assign(theta, in__.read<local_scalar_t__>(),
                "assigning variable theta", index_uni(1), index_uni(sym2__),
                                              index_uni(1));
              for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                assign(theta, in__.read<local_scalar_t__>(),
                  "assigning variable theta", index_uni(sym3__),
                                                index_uni(sym2__),
                                                index_uni(1));
              }
            } 
          }
        } 
        for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
          if (lcm_sym2__) {
            lcm_sym1__ = logical_gte(J, 1);
            if (lcm_sym1__) {
              assign(theta, in__.read<local_scalar_t__>(),
                "assigning variable theta", index_uni(1), index_uni(1),
                                              index_uni(sym1__));
              for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                assign(theta, in__.read<local_scalar_t__>(),
                  "assigning variable theta", index_uni(sym3__),
                                                index_uni(1),
                                                index_uni(sym1__));
              }
            } 
            for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
              if (lcm_sym1__) {
                assign(theta, in__.read<local_scalar_t__>(),
                  "assigning variable theta", index_uni(1),
                                                index_uni(sym2__),
                                                index_uni(sym1__));
                for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                  assign(theta, in__.read<local_scalar_t__>(),
                    "assigning variable theta", index_uni(sym3__),
                                                  index_uni(sym2__),
                                                  index_uni(sym1__));
                }
              } 
            }
          } 
        }
      } 
      out__.write_free_simplex(theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"pi", "theta", "log_Pr_z"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(K)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(J), static_cast<size_t>(K),
                          static_cast<size_t>(K)},
      std::vector<size_t>{static_cast<size_t>(I), static_cast<size_t>(K)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym60__ = 1; sym60__ <= K; ++sym60__) {
      {
        param_names__.emplace_back(std::string() + "pi" + '.' + std::to_string(sym60__));
      } 
    }
    for (int sym60__ = 1; sym60__ <= K; ++sym60__) {
      {
        for (int sym61__ = 1; sym61__ <= K; ++sym61__) {
          {
            for (int sym62__ = 1; sym62__ <= J; ++sym62__) {
              {
                param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym62__) + '.' + std::to_string(sym61__) + '.' + std::to_string(sym60__));
              } 
            }
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      for (int sym60__ = 1; sym60__ <= K; ++sym60__) {
        {
          for (int sym61__ = 1; sym61__ <= I; ++sym61__) {
            {
              param_names__.emplace_back(std::string() + "log_Pr_z" + '.' + std::to_string(sym61__) + '.' + std::to_string(sym60__));
            } 
          }
        } 
      }
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym60__ = 1; sym60__ <= (K - 1); ++sym60__) {
      {
        param_names__.emplace_back(std::string() + "pi" + '.' + std::to_string(sym60__));
      } 
    }
    for (int sym60__ = 1; sym60__ <= (K - 1); ++sym60__) {
      {
        for (int sym61__ = 1; sym61__ <= K; ++sym61__) {
          {
            for (int sym62__ = 1; sym62__ <= J; ++sym62__) {
              {
                param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym62__) + '.' + std::to_string(sym61__) + '.' + std::to_string(sym60__));
              } 
            }
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      for (int sym60__ = 1; sym60__ <= K; ++sym60__) {
        {
          for (int sym61__ = 1; sym61__ <= I; ++sym61__) {
            {
              param_names__.emplace_back(std::string() + "log_Pr_z" + '.' + std::to_string(sym61__) + '.' + std::to_string(sym60__));
            } 
          }
        } 
      }
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"pi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}}},\"block\":\"parameters\"},{\"name\":\"log_Pr_z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(I) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"pi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((K - 1)) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string((K - 1)) + "}}},\"block\":\"parameters\"},{\"name\":\"log_Pr_z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(I) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (K + ((J * K) * K));
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 
  (I * K);
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (K + ((J * K) * K));
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 
  (I * K);
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"pi", "theta"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{K,
       (J * K * K)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail7_model_namespace::expr_prop_fail7_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail7_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail8.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail8_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 25> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail8.stan', line 11, column 2 to column 13)",
 " (in 'expr-prop-fail8.stan', line 12, column 2 to column 13)",
 " (in 'expr-prop-fail8.stan', line 14, column 2 to column 26)",
 " (in 'expr-prop-fail8.stan', line 15, column 2 to column 24)",
 " (in 'expr-prop-fail8.stan', line 17, column 2 to column 22)",
 " (in 'expr-prop-fail8.stan', line 18, column 2 to column 24)",
 " (in 'expr-prop-fail8.stan', line 21, column 2 to column 47)",
 " (in 'expr-prop-fail8.stan', line 22, column 2 to column 16)",
 " (in 'expr-prop-fail8.stan', line 23, column 2 to column 25)",
 " (in 'expr-prop-fail8.stan', line 24, column 2 to column 24)",
 " (in 'expr-prop-fail8.stan', line 27, column 2 to column 33)",
 " (in 'expr-prop-fail8.stan', line 2, column 2 to column 17)",
 " (in 'expr-prop-fail8.stan', line 3, column 2 to column 23)",
 " (in 'expr-prop-fail8.stan', line 4, column 30 to column 37)",
 " (in 'expr-prop-fail8.stan', line 4, column 2 to column 39)",
 " (in 'expr-prop-fail8.stan', line 5, column 30 to column 37)",
 " (in 'expr-prop-fail8.stan', line 5, column 2 to column 39)",
 " (in 'expr-prop-fail8.stan', line 7, column 17 to column 18)",
 " (in 'expr-prop-fail8.stan', line 7, column 2 to column 20)",
 " (in 'expr-prop-fail8.stan', line 8, column 9 to column 10)",
 " (in 'expr-prop-fail8.stan', line 8, column 2 to column 14)",
 " (in 'expr-prop-fail8.stan', line 17, column 9 to column 10)",
 " (in 'expr-prop-fail8.stan', line 18, column 9 to column 10)",
 " (in 'expr-prop-fail8.stan', line 22, column 9 to column 10)"};



class expr_prop_fail8_model final : public model_base_crtp<expr_prop_fail8_model> {

 private:
  int lcm_sym19__;
  int lcm_sym18__;
  double lcm_sym17__;
  double lcm_sym16__;
  int lcm_sym15__;
  int lcm_sym14__;
  int lcm_sym13__;
  int lcm_sym12__;
  int lcm_sym11__;
  int lcm_sym10__;
  int lcm_sym9__;
  int N;
  int N_edges;
  std::vector<int> node1;
  std::vector<int> node2;
  std::vector<int> y;
  Eigen::Matrix<double, -1, 1> x__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> x{nullptr, 0};
 
 public:
  ~expr_prop_fail8_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail8_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail8_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail8_model_namespace::expr_prop_fail8_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 12;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 12;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 12;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 13;
      context__.validate_dims("data initialization","N_edges","int",
           std::vector<size_t>{});
      N_edges = std::numeric_limits<int>::min();
      
      current_statement__ = 13;
      N_edges = context__.vals_i("N_edges")[(1 - 1)];
      current_statement__ = 13;
      check_greater_or_equal(function__, "N_edges", N_edges, 0);
      current_statement__ = 14;
      validate_non_negative_index("node1", "N_edges", N_edges);
      current_statement__ = 15;
      context__.validate_dims("data initialization","node1","int",
           std::vector<size_t>{static_cast<size_t>(N_edges)});
      node1 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      
      current_statement__ = 15;
      node1 = context__.vals_i("node1");
      lcm_sym10__ = logical_gte(N_edges, 1);
      if (lcm_sym10__) {
        current_statement__ = 15;
        check_greater_or_equal(function__, "node1[sym1__]",
                               rvalue(node1, "node1", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 15;
          check_greater_or_equal(function__, "node1[sym1__]",
                                 node1[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 15;
      if (lcm_sym10__) {
        current_statement__ = 15;
        check_less_or_equal(function__, "node1[sym1__]",
                            rvalue(node1, "node1", index_uni(1)), N);
        for (int sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 15;
          check_less_or_equal(function__, "node1[sym1__]",
                              node1[(sym1__ - 1)], N);
        }
      } 
      current_statement__ = 16;
      validate_non_negative_index("node2", "N_edges", N_edges);
      current_statement__ = 17;
      context__.validate_dims("data initialization","node2","int",
           std::vector<size_t>{static_cast<size_t>(N_edges)});
      node2 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      
      current_statement__ = 17;
      node2 = context__.vals_i("node2");
      current_statement__ = 17;
      if (lcm_sym10__) {
        current_statement__ = 17;
        check_greater_or_equal(function__, "node2[sym1__]",
                               rvalue(node2, "node2", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 17;
          check_greater_or_equal(function__, "node2[sym1__]",
                                 node2[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 17;
      if (lcm_sym10__) {
        current_statement__ = 17;
        check_less_or_equal(function__, "node2[sym1__]",
                            rvalue(node2, "node2", index_uni(1)), N);
        for (int sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 17;
          check_less_or_equal(function__, "node2[sym1__]",
                              node2[(sym1__ - 1)], N);
        }
      } 
      current_statement__ = 18;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 19;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 19;
      y = context__.vals_i("y");
      lcm_sym9__ = logical_gte(N, 1);
      if (lcm_sym9__) {
        current_statement__ = 19;
        check_greater_or_equal(function__, "y[sym1__]",
                               rvalue(y, "y", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 19;
          check_greater_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 20;
      validate_non_negative_index("x", "N", N);
      current_statement__ = 21;
      context__.validate_dims("data initialization","x","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      x__ = Eigen::Matrix<double, -1, 1>(N);
      new (&x) Eigen::Map<Eigen::Matrix<double, -1, 1>>(x__.data(), N);
      
      {
        std::vector<double> x_flat__;
        current_statement__ = 21;
        x_flat__ = context__.vals_r("x");
        current_statement__ = 21;
        pos__ = 1;
        current_statement__ = 21;
        if (lcm_sym9__) {
          current_statement__ = 21;
          assign(x, rvalue(x_flat__, "x_flat__", index_uni(1)),
            "assigning variable x", index_uni(1));
          current_statement__ = 21;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 21;
            assign(x, x_flat__[(pos__ - 1)],
              "assigning variable x", index_uni(sym1__));
            current_statement__ = 21;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 22;
      validate_non_negative_index("theta_std", "N", N);
      current_statement__ = 23;
      validate_non_negative_index("phi_std_raw", "N", N);
      current_statement__ = 24;
      validate_non_negative_index("phi", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + N + N;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail8_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ lcm_sym8__;
      double lcm_sym7__;
      Eigen::Matrix<double, -1, 1> lcm_sym6__;
      local_scalar_t__ beta0;
      current_statement__ = 1;
      beta0 = in__.template read<local_scalar_t__>();
      local_scalar_t__ beta1;
      current_statement__ = 2;
      beta1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ tau_theta;
      current_statement__ = 3;
      tau_theta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                    0, lp__);
      local_scalar_t__ tau_phi;
      current_statement__ = 4;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                  0, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> theta_std;
      current_statement__ = 5;
      theta_std = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                    N);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_std_raw;
      current_statement__ = 6;
      phi_std_raw = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                      N);
      local_scalar_t__ sigma_phi;
      lcm_sym8__ = inv_sqrt(tau_phi);
      sigma_phi = lcm_sym8__;
      Eigen::Matrix<local_scalar_t__, -1, 1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(phi, DUMMY_VAR__);
      
      current_statement__ = 9;
      assign(phi, phi_std_raw, "assigning variable phi", index_min_max(1, N));
      current_statement__ = 10;
      assign(phi, multiply(stan::model::deep_copy(phi), lcm_sym8__),
        "assigning variable phi");
      current_statement__ = 7;
      check_greater_or_equal(function__, "sigma_phi", lcm_sym8__, 0);
      {
        current_statement__ = 11;
        lp_accum__.add(dot_self(rvalue(phi, "phi", index_multi(node1))));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail8_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym5__;
      Eigen::Matrix<double, -1, 1> lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      double beta0;
      current_statement__ = 1;
      beta0 = in__.template read<local_scalar_t__>();
      double beta1;
      current_statement__ = 2;
      beta1 = in__.template read<local_scalar_t__>();
      double tau_theta;
      current_statement__ = 3;
      tau_theta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                    0, lp__);
      double tau_phi;
      current_statement__ = 4;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                  0, lp__);
      Eigen::Matrix<double, -1, 1> theta_std;
      current_statement__ = 5;
      theta_std = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                    N);
      Eigen::Matrix<double, -1, 1> phi_std_raw;
      current_statement__ = 6;
      phi_std_raw = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                      N);
      double sigma_phi;
      sigma_phi = std::numeric_limits<double>::quiet_NaN();
      
      Eigen::Matrix<double, -1, 1> phi;
      phi = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(phi, std::numeric_limits<double>::quiet_NaN());
      
      out__.write(beta0);
      out__.write(beta1);
      out__.write(tau_theta);
      out__.write(tau_phi);
      out__.write(theta_std);
      out__.write(phi_std_raw);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym5__ = inv_sqrt(tau_phi);
      sigma_phi = lcm_sym5__;
      current_statement__ = 9;
      assign(phi, phi_std_raw, "assigning variable phi", index_min_max(1, N));
      current_statement__ = 10;
      assign(phi, multiply(stan::model::deep_copy(phi), lcm_sym5__),
        "assigning variable phi");
      current_statement__ = 7;
      check_greater_or_equal(function__, "sigma_phi", lcm_sym5__, 0);
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym5__);
        out__.write(phi);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ beta0;
      beta0 = in__.read<local_scalar_t__>();
      out__.write(beta0);
      local_scalar_t__ beta1;
      beta1 = in__.read<local_scalar_t__>();
      out__.write(beta1);
      local_scalar_t__ tau_theta;
      tau_theta = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau_theta);
      local_scalar_t__ tau_phi;
      tau_phi = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau_phi);
      Eigen::Matrix<local_scalar_t__, -1, 1> theta_std;
      theta_std = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(theta_std, DUMMY_VAR__);
      
      lcm_sym1__ = logical_gte(N, 1);
      if (lcm_sym1__) {
        assign(theta_std, in__.read<local_scalar_t__>(),
          "assigning variable theta_std", index_uni(1));
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          assign(theta_std, in__.read<local_scalar_t__>(),
            "assigning variable theta_std", index_uni(sym1__));
        }
      } 
      out__.write(theta_std);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(phi_std_raw, DUMMY_VAR__);
      
      if (lcm_sym1__) {
        assign(phi_std_raw, in__.read<local_scalar_t__>(),
          "assigning variable phi_std_raw", index_uni(1));
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          assign(phi_std_raw, in__.read<local_scalar_t__>(),
            "assigning variable phi_std_raw", index_uni(sym1__));
        }
      } 
      out__.write(phi_std_raw);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"beta0", "beta1", "tau_theta",
      "tau_phi", "theta_std", "phi_std_raw", "sigma_phi", "phi"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)}, std::vector<size_t>{
      }, std::vector<size_t>{static_cast<size_t>(N)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta0");
    param_names__.emplace_back(std::string() + "beta1");
    param_names__.emplace_back(std::string() + "tau_theta");
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym20__ = 1; sym20__ <= N; ++sym20__) {
      {
        param_names__.emplace_back(std::string() + "theta_std" + '.' + std::to_string(sym20__));
      } 
    }
    for (int sym20__ = 1; sym20__ <= N; ++sym20__) {
      {
        param_names__.emplace_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym20__));
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym20__ = 1; sym20__ <= N; ++sym20__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym20__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta0");
    param_names__.emplace_back(std::string() + "beta1");
    param_names__.emplace_back(std::string() + "tau_theta");
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym20__ = 1; sym20__ <= N; ++sym20__) {
      {
        param_names__.emplace_back(std::string() + "theta_std" + '.' + std::to_string(sym20__));
      } 
    }
    for (int sym20__ = 1; sym20__ <= N; ++sym20__) {
      {
        param_names__.emplace_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym20__));
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym20__ = 1; sym20__ <= N; ++sym20__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym20__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((1 + 1) + 1) + 1) + N) + N);
      const size_t num_transformed = 
  (1 + N);
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((1 + 1) + 1) + 1) + N) + N);
      const size_t num_transformed = 
  (1 + N);
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 6> names__{"beta0", "beta1",
      "tau_theta", "tau_phi", "theta_std", "phi_std_raw"};
      const std::array<Eigen::Index, 6> constrain_param_sizes__{1, 1, 
       1, 1, N, N};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail8_model_namespace::expr_prop_fail8_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail8_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp fails-test.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace fails_test_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 68> locations_array__ = 
{" (found before start of program)",
 " (in 'fails-test.stan', line 71, column 2 to column 31)",
 " (in 'fails-test.stan', line 72, column 2 to column 40)",
 " (in 'fails-test.stan', line 76, column 2 to column 51)",
 " (in 'fails-test.stan', line 77, column 2 to column 49)",
 " (in 'fails-test.stan', line 78, column 2 to column 49)",
 " (in 'fails-test.stan', line 83, column 6 to column 20)",
 " (in 'fails-test.stan', line 84, column 6 to column 18)",
 " (in 'fails-test.stan', line 82, column 32 to line 85, column 5)",
 " (in 'fails-test.stan', line 87, column 6 to column 32)",
 " (in 'fails-test.stan', line 88, column 6 to column 23)",
 " (in 'fails-test.stan', line 86, column 38 to line 89, column 5)",
 " (in 'fails-test.stan', line 86, column 4 to line 89, column 5)",
 " (in 'fails-test.stan', line 81, column 20 to line 90, column 3)",
 " (in 'fails-test.stan', line 26, column 11 to column 15)",
 " (in 'fails-test.stan', line 26, column 17 to column 28)",
 " (in 'fails-test.stan', line 26, column 4 to column 34)",
 " (in 'fails-test.stan', line 29, column 6 to column 32)",
 " (in 'fails-test.stan', line 32, column 8 to column 37)",
 " (in 'fails-test.stan', line 33, column 8 to column 32)",
 " (in 'fails-test.stan', line 41, column 8 to line 42, column 83)",
 " (in 'fails-test.stan', line 30, column 37 to line 43, column 7)",
 " (in 'fails-test.stan', line 28, column 22 to line 44, column 5)",
 " (in 'fails-test.stan', line 25, column 47 to line 46, column 3)",
 " (in 'fails-test.stan', line 105, column 8 to column 37)",
 " (in 'fails-test.stan', line 106, column 8 to column 41)",
 " (in 'fails-test.stan', line 104, column 40 to line 107, column 7)",
 " (in 'fails-test.stan', line 108, column 6 to column 37)",
 " (in 'fails-test.stan', line 103, column 22 to line 109, column 5)",
 " (in 'fails-test.stan', line 102, column 20 to line 110, column 3)",
 " (in 'fails-test.stan', line 102, column 2 to line 110, column 3)",
 " (in 'fails-test.stan', line 50, column 2 to column 20)",
 " (in 'fails-test.stan', line 51, column 2 to column 27)",
 " (in 'fails-test.stan', line 52, column 25 to column 29)",
 " (in 'fails-test.stan', line 52, column 31 to column 42)",
 " (in 'fails-test.stan', line 52, column 2 to column 44)",
 " (in 'fails-test.stan', line 53, column 2 to column 23)",
 " (in 'fails-test.stan', line 54, column 31 to column 35)",
 " (in 'fails-test.stan', line 54, column 2 to column 54)",
 " (in 'fails-test.stan', line 58, column 2 to column 38)",
 " (in 'fails-test.stan', line 60, column 39 to column 43)",
 " (in 'fails-test.stan', line 60, column 2 to column 45)",
 " (in 'fails-test.stan', line 61, column 38 to column 42)",
 " (in 'fails-test.stan', line 61, column 2 to column 44)",
 " (in 'fails-test.stan', line 8, column 8 to column 17)",
 " (in 'fails-test.stan', line 7, column 6 to line 8, column 17)",
 " (in 'fails-test.stan', line 5, column 31 to line 10, column 3)",
 " (in 'fails-test.stan', line 65, column 4 to column 35)",
 " (in 'fails-test.stan', line 64, column 2 to line 65, column 35)",
 " (in 'fails-test.stan', line 15, column 6 to column 32)",
 " (in 'fails-test.stan', line 19, column 8 to column 17)",
 " (in 'fails-test.stan', line 18, column 6 to line 19, column 17)",
 " (in 'fails-test.stan', line 13, column 37 to line 20, column 5)",
 " (in 'fails-test.stan', line 12, column 30 to line 22, column 3)",
 " (in 'fails-test.stan', line 67, column 4 to column 33)",
 " (in 'fails-test.stan', line 66, column 2 to line 67, column 33)",
 " (in 'fails-test.stan', line 72, column 26 to column 33)",
 " (in 'fails-test.stan', line 76, column 26 to column 30)",
 " (in 'fails-test.stan', line 76, column 32 to column 45)",
 " (in 'fails-test.stan', line 77, column 26 to column 30)",
 " (in 'fails-test.stan', line 77, column 32 to column 45)",
 " (in 'fails-test.stan', line 78, column 26 to column 30)",
 " (in 'fails-test.stan', line 78, column 32 to column 43)",
 " (in 'fails-test.stan', line 9, column 4 to column 13)",
 " (in 'fails-test.stan', line 21, column 4 to column 13)",
 " (in 'fails-test.stan', line 30, column 6 to line 43, column 7)",
 " (in 'fails-test.stan', line 28, column 4 to line 44, column 5)",
 " (in 'fails-test.stan', line 45, column 4 to column 15)"};

int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) ;

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) ;

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p,
                const T3__& phi, std::ostream* pstream__) ;

struct prob_uncaptured_functor__ {
template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
operator()(const int& nind, const int& n_occasions, const T2__& p,
           const T3__& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}
};

int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym29__;
    int lcm_sym28__;
    int lcm_sym27__;
    int lcm_sym26__;
    {
      lcm_sym27__ = size(y_i);
      if (logical_gte(lcm_sym27__, 1)) {
        current_statement__ = 45;
        if (rvalue(y_i, "y_i", index_uni(1))) {
          current_statement__ = 44;
          return 1;
        } 
        for (int k = 2; k <= lcm_sym27__; ++k) {
          current_statement__ = 45;
          if (rvalue(y_i, "y_i", index_uni(k))) {
            current_statement__ = 44;
            return k;
          } 
        }
      } 
      current_statement__ = 63;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym35__;
    int lcm_sym34__;
    int lcm_sym33__;
    int lcm_sym32__;
    int lcm_sym31__;
    int lcm_sym30__;
    {
      lcm_sym33__ = (size(y_i) - 1);
      if (logical_gte(lcm_sym33__, 0)) {
        int k;
        lcm_sym32__ = (size(y_i) - 0);
        current_statement__ = 51;
        if (y_i[(lcm_sym32__ - 1)]) {
          current_statement__ = 50;
          return lcm_sym32__;
        } 
        for (int k_rev = 1; k_rev <= lcm_sym33__; ++k_rev) {
          int k;
          lcm_sym31__ = (size(y_i) - k_rev);
          current_statement__ = 51;
          if (y_i[(lcm_sym31__ - 1)]) {
            current_statement__ = 50;
            return lcm_sym31__;
          } 
        }
      } 
      current_statement__ = 64;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  int current_statement__ = 0; 
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    double lcm_sym45__;
    double lcm_sym44__;
    double lcm_sym43__;
    double lcm_sym42__;
    int lcm_sym41__;
    int lcm_sym40__;
    int lcm_sym39__;
    int lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    {
      current_statement__ = 14;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 15;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      current_statement__ = 66;
      if (logical_gte(nind, 1)) {
        current_statement__ = 17;
        assign(chi, 1.0,
          "assigning variable chi", index_uni(1), index_uni(n_occasions));
        lcm_sym39__ = (n_occasions - 1);
        lcm_sym37__ = logical_gte(lcm_sym39__, 1);
        if (lcm_sym37__) {
          int t_curr;
          int t_next;
          lcm_sym41__ = (lcm_sym39__ + 1);
          current_statement__ = 20;
          assign(chi,
            stan::math::fma(
              (rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym39__)) *
                (1 -
                  rvalue(p, "p", index_uni(1), index_uni((lcm_sym41__ - 1))))),
              rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym41__)),
              (1 - rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym39__)))),
            "assigning variable chi", index_uni(1), index_uni(lcm_sym39__));
          for (int t = 2; t <= lcm_sym39__; ++t) {
            int t_curr;
            lcm_sym38__ = (n_occasions - t);
            int t_next;
            lcm_sym40__ = (lcm_sym38__ + 1);
            current_statement__ = 20;
            assign(chi,
              stan::math::fma(
                (rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym38__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(1), index_uni((lcm_sym40__ - 1))))),
                rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym40__)),
                (1 -
                  rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym38__)))),
              "assigning variable chi", index_uni(1), index_uni(lcm_sym38__));
          }
        } 
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 17;
          assign(chi, 1.0,
            "assigning variable chi", index_uni(i), index_uni(n_occasions));
          current_statement__ = 65;
          if (lcm_sym37__) {
            int t_curr;
            int t_next;
            lcm_sym41__ = (lcm_sym39__ + 1);
            current_statement__ = 20;
            assign(chi,
              stan::math::fma(
                (rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym39__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(i), index_uni((lcm_sym41__ - 1))))),
                rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym41__)),
                (1 -
                  rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym39__)))),
              "assigning variable chi", index_uni(i), index_uni(lcm_sym39__));
            for (int t = 2; t <= lcm_sym39__; ++t) {
              int t_curr;
              lcm_sym38__ = (n_occasions - t);
              int t_next;
              lcm_sym40__ = (lcm_sym38__ + 1);
              current_statement__ = 20;
              assign(chi,
                stan::math::fma(
                  (rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym38__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(i), index_uni((lcm_sym40__ - 1))))),
                  rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym40__)),
                  (1 -
                    rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym38__)))),
                "assigning variable chi", index_uni(i),
                                            index_uni(lcm_sym38__));
            }
          } 
        }
      } 
      current_statement__ = 67;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
class fails_test_model final : public model_base_crtp<fails_test_model> {

 private:
  int lcm_sym167__;
  int lcm_sym166__;
  int lcm_sym165__;
  int lcm_sym164__;
  int lcm_sym163__;
  int lcm_sym162__;
  int lcm_sym161__;
  int lcm_sym160__;
  int lcm_sym159__;
  int lcm_sym158__;
  int lcm_sym157__;
  int lcm_sym156__;
  int lcm_sym155__;
  int lcm_sym154__;
  int lcm_sym153__;
  int lcm_sym152__;
  int lcm_sym151__;
  int lcm_sym150__;
  int lcm_sym149__;
  int lcm_sym148__;
  int lcm_sym147__;
  int lcm_sym146__;
  int lcm_sym145__;
  int lcm_sym144__;
  int lcm_sym143__;
  int lcm_sym142__;
  int lcm_sym141__;
  int lcm_sym140__;
  int lcm_sym139__;
  int lcm_sym138__;
  int lcm_sym137__;
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int max_age;
  std::vector<std::vector<int>> x;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last; 
  
 
 public:
  ~fails_test_model() { }
  
  inline std::string model_name() const final { return "fails_test_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  fails_test_model(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "fails_test_model_namespace::fails_test_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 31;
      context__.validate_dims("data initialization","nind","int",
           std::vector<size_t>{});
      nind = std::numeric_limits<int>::min();
      
      current_statement__ = 31;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 31;
      check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 32;
      context__.validate_dims("data initialization","n_occasions","int",
           std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      
      current_statement__ = 32;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 32;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 2);
      current_statement__ = 33;
      validate_non_negative_index("y", "nind", nind);
      current_statement__ = 34;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 35;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(nind),
            static_cast<size_t>(n_occasions)});
      y = std::vector<std::vector<int>>(nind, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 35;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 35;
        pos__ = 1;
        lcm_sym137__ = logical_gte(n_occasions, 1);
        if (lcm_sym137__) {
          {
            lcm_sym138__ = logical_gte(nind, 1);
            if (lcm_sym138__) {
              current_statement__ = 35;
              assign(y, rvalue(y_flat__, "y_flat__", index_uni(1)),
                "assigning variable y", index_uni(1), index_uni(1));
              current_statement__ = 35;
              pos__ = 2;
              for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                current_statement__ = 35;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(sym2__), index_uni(1));
                current_statement__ = 35;
                pos__ = (pos__ + 1);
              }
            } 
            for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
              current_statement__ = 35;
              if (lcm_sym138__) {
                current_statement__ = 35;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(1), index_uni(sym1__));
                current_statement__ = 35;
                pos__ = (pos__ + 1);
                for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                  current_statement__ = 35;
                  assign(y, y_flat__[(pos__ - 1)],
                    "assigning variable y", index_uni(sym2__),
                                              index_uni(sym1__));
                  current_statement__ = 35;
                  pos__ = (pos__ + 1);
                }
              } 
            }
          }
        } else {
          lcm_sym138__ = logical_gte(nind, 1);
        }
      }
      current_statement__ = 35;
      if (lcm_sym138__) {
        current_statement__ = 35;
        if (lcm_sym137__) {
          current_statement__ = 35;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 rvalue(y, "y", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 35;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 35;
          if (lcm_sym137__) {
            current_statement__ = 35;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 35;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);
            }
          } 
        }
      } 
      current_statement__ = 35;
      if (lcm_sym138__) {
        current_statement__ = 35;
        if (lcm_sym137__) {
          current_statement__ = 35;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              rvalue(y, "y", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 35;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 35;
          if (lcm_sym137__) {
            current_statement__ = 35;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 35;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);
            }
          } 
        }
      } 
      current_statement__ = 36;
      context__.validate_dims("data initialization","max_age","int",
           std::vector<size_t>{});
      max_age = std::numeric_limits<int>::min();
      
      current_statement__ = 36;
      max_age = context__.vals_i("max_age")[(1 - 1)];
      current_statement__ = 36;
      check_greater_or_equal(function__, "max_age", max_age, 1);
      current_statement__ = 37;
      validate_non_negative_index("x", "nind", nind);
      lcm_sym140__ = (n_occasions - 1);
      validate_non_negative_index("x", "n_occasions - 1", lcm_sym140__);
      current_statement__ = 38;
      context__.validate_dims("data initialization","x","int",
           std::vector<size_t>{static_cast<size_t>(nind),
            static_cast<size_t>(lcm_sym140__)});
      x = std::vector<std::vector<int>>(nind, std::vector<int>(lcm_sym140__, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> x_flat__;
        current_statement__ = 38;
        x_flat__ = context__.vals_i("x");
        current_statement__ = 38;
        pos__ = 1;
        lcm_sym139__ = logical_gte(lcm_sym140__, 1);
        if (lcm_sym139__) {
          current_statement__ = 38;
          if (lcm_sym138__) {
            current_statement__ = 38;
            assign(x, rvalue(x_flat__, "x_flat__", index_uni(1)),
              "assigning variable x", index_uni(1), index_uni(1));
            current_statement__ = 38;
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
              current_statement__ = 38;
              assign(x, x_flat__[(pos__ - 1)],
                "assigning variable x", index_uni(sym2__), index_uni(1));
              current_statement__ = 38;
              pos__ = (pos__ + 1);
            }
          } 
          for (int sym1__ = 2; sym1__ <= lcm_sym140__; ++sym1__) {
            current_statement__ = 38;
            if (lcm_sym138__) {
              current_statement__ = 38;
              assign(x, x_flat__[(pos__ - 1)],
                "assigning variable x", index_uni(1), index_uni(sym1__));
              current_statement__ = 38;
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                current_statement__ = 38;
                assign(x, x_flat__[(pos__ - 1)],
                  "assigning variable x", index_uni(sym2__),
                                            index_uni(sym1__));
                current_statement__ = 38;
                pos__ = (pos__ + 1);
              }
            } 
          }
        } 
      }
      current_statement__ = 38;
      if (lcm_sym138__) {
        current_statement__ = 38;
        if (lcm_sym139__) {
          current_statement__ = 38;
          check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                 rvalue(x, "x", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym140__; ++sym2__) {
            current_statement__ = 38;
            check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                   rvalue(x, "x",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 38;
          if (lcm_sym139__) {
            current_statement__ = 38;
            check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                   rvalue(x, "x",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym140__; ++sym2__) {
              current_statement__ = 38;
              check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                     x[(sym1__ - 1)][(sym2__ - 1)], 0);
            }
          } 
        }
      } 
      current_statement__ = 38;
      if (lcm_sym138__) {
        current_statement__ = 38;
        if (lcm_sym139__) {
          current_statement__ = 38;
          check_less_or_equal(function__, "x[sym1__, sym2__]",
                              rvalue(x, "x", index_uni(1), index_uni(1)),
                              max_age);
          for (int sym2__ = 2; sym2__ <= lcm_sym140__; ++sym2__) {
            current_statement__ = 38;
            check_less_or_equal(function__, "x[sym1__, sym2__]",
                                rvalue(x, "x",
                                  index_uni(1), index_uni(sym2__)), max_age);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 38;
          if (lcm_sym139__) {
            current_statement__ = 38;
            check_less_or_equal(function__, "x[sym1__, sym2__]",
                                rvalue(x, "x",
                                  index_uni(sym1__), index_uni(1)), max_age);
            for (int sym2__ = 2; sym2__ <= lcm_sym140__; ++sym2__) {
              current_statement__ = 38;
              check_less_or_equal(function__, "x[sym1__, sym2__]",
                                  x[(sym1__ - 1)][(sym2__ - 1)], max_age);
            }
          } 
        }
      } 
      current_statement__ = 39;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      
      current_statement__ = 39;
      n_occ_minus_1 = lcm_sym140__;
      current_statement__ = 40;
      validate_non_negative_index("first", "nind", nind);
      current_statement__ = 41;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 42;
      validate_non_negative_index("last", "nind", nind);
      current_statement__ = 43;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 48;
      if (lcm_sym138__) {
        int inline_sym17__;
        int inline_sym19__;
        inline_sym19__ = 0;
        for (int inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
          lcm_sym147__ = size(rvalue(y, "y", index_uni(1)));
          for (int inline_sym18__ = 1; inline_sym18__ <= lcm_sym147__;
               ++inline_sym18__) {
            current_statement__ = 45;
            if (rvalue(y, "y", index_uni(1))[(inline_sym18__ - 1)]) {
              inline_sym19__ = 1;
              inline_sym17__ = inline_sym18__;
              break;
            } 
          }
          if (inline_sym19__) {
            break;
          } 
          inline_sym19__ = 1;
          inline_sym17__ = 0;
          break;
        }
        assign(first, inline_sym17__,
          "assigning variable first", index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          int inline_sym17__;
          int inline_sym19__;
          inline_sym19__ = 0;
          for (int inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
            lcm_sym146__ = size(rvalue(y, "y", index_uni(i)));
            for (int inline_sym18__ = 1; inline_sym18__ <= lcm_sym146__;
                 ++inline_sym18__) {
              current_statement__ = 45;
              if (rvalue(y, "y", index_uni(i))[(inline_sym18__ - 1)]) {
                inline_sym19__ = 1;
                inline_sym17__ = inline_sym18__;
                break;
              } 
            }
            if (inline_sym19__) {
              break;
            } 
            inline_sym19__ = 1;
            inline_sym17__ = 0;
            break;
          }
          assign(first, inline_sym17__,
            "assigning variable first", index_uni(i));
        }
      } 
      current_statement__ = 55;
      if (lcm_sym138__) {
        int inline_sym21__;
        int inline_sym24__;
        inline_sym24__ = 0;
        for (int inline_sym25__ = 1; inline_sym25__ <= 1; ++inline_sym25__) {
          lcm_sym147__ = size(rvalue(y, "y", index_uni(1)));
          lcm_sym144__ = (lcm_sym147__ - 1);
          for (int inline_sym23__ = 0; inline_sym23__ <= lcm_sym144__;
               ++inline_sym23__) {
            int inline_sym22__;
            lcm_sym143__ = (lcm_sym147__ - inline_sym23__);
            inline_sym22__ = lcm_sym143__;
            current_statement__ = 51;
            if (rvalue(y, "y", index_uni(1))[(lcm_sym143__ - 1)]) {
              inline_sym24__ = 1;
              inline_sym21__ = lcm_sym143__;
              break;
            } 
          }
          if (inline_sym24__) {
            break;
          } 
          inline_sym24__ = 1;
          inline_sym21__ = 0;
          break;
        }
        assign(last, inline_sym21__, "assigning variable last", index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          int inline_sym21__;
          int inline_sym24__;
          inline_sym24__ = 0;
          for (int inline_sym25__ = 1; inline_sym25__ <= 1; ++inline_sym25__) {
            lcm_sym146__ = size(rvalue(y, "y", index_uni(i)));
            lcm_sym142__ = (lcm_sym146__ - 1);
            for (int inline_sym23__ = 0; inline_sym23__ <= lcm_sym142__;
                 ++inline_sym23__) {
              int inline_sym22__;
              lcm_sym141__ = (lcm_sym146__ - inline_sym23__);
              inline_sym22__ = lcm_sym141__;
              current_statement__ = 51;
              if (rvalue(y, "y", index_uni(i))[(lcm_sym141__ - 1)]) {
                inline_sym24__ = 1;
                inline_sym21__ = lcm_sym141__;
                break;
              } 
            }
            if (inline_sym24__) {
              break;
            } 
            inline_sym24__ = 1;
            inline_sym21__ = 0;
            break;
          }
          assign(last, inline_sym21__,
            "assigning variable last", index_uni(i));
        }
      } 
      current_statement__ = 41;
      if (lcm_sym138__) {
        current_statement__ = 41;
        check_greater_or_equal(function__, "first[sym1__]",
                               rvalue(first, "first", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 41;
          check_greater_or_equal(function__, "first[sym1__]",
                                 first[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 41;
      if (lcm_sym138__) {
        current_statement__ = 41;
        check_less_or_equal(function__, "first[sym1__]",
                            rvalue(first, "first", index_uni(1)), n_occasions);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 41;
          check_less_or_equal(function__, "first[sym1__]",
                              first[(sym1__ - 1)], n_occasions);
        }
      } 
      current_statement__ = 43;
      if (lcm_sym138__) {
        current_statement__ = 43;
        check_greater_or_equal(function__, "last[sym1__]",
                               rvalue(last, "last", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 43;
          check_greater_or_equal(function__, "last[sym1__]",
                                 last[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 43;
      if (lcm_sym138__) {
        current_statement__ = 43;
        check_less_or_equal(function__, "last[sym1__]",
                            rvalue(last, "last", index_uni(1)), n_occasions);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 43;
          check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                              n_occasions);
        }
      } 
      current_statement__ = 56;
      validate_non_negative_index("beta", "max_age", max_age);
      current_statement__ = 57;
      validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 58;
      validate_non_negative_index("phi", "n_occ_minus_1", lcm_sym140__);
      current_statement__ = 59;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 60;
      validate_non_negative_index("p", "n_occ_minus_1", lcm_sym140__);
      current_statement__ = 61;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 62;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + max_age;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "fails_test_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym136__;
      double lcm_sym135__;
      double lcm_sym134__;
      double lcm_sym133__;
      double lcm_sym132__;
      double lcm_sym131__;
      double lcm_sym130__;
      double lcm_sym129__;
      int lcm_sym128__;
      int lcm_sym127__;
      double lcm_sym126__;
      double lcm_sym125__;
      double lcm_sym124__;
      double lcm_sym123__;
      int lcm_sym122__;
      int lcm_sym121__;
      double lcm_sym120__;
      double lcm_sym119__;
      double lcm_sym118__;
      double lcm_sym117__;
      double lcm_sym116__;
      double lcm_sym115__;
      double lcm_sym114__;
      double lcm_sym113__;
      double lcm_sym112__;
      double lcm_sym111__;
      double lcm_sym110__;
      double lcm_sym109__;
      double lcm_sym108__;
      double lcm_sym107__;
      double lcm_sym106__;
      double lcm_sym105__;
      int lcm_sym104__;
      int lcm_sym103__;
      int lcm_sym102__;
      int lcm_sym101__;
      int lcm_sym100__;
      int lcm_sym99__;
      int lcm_sym98__;
      int lcm_sym97__;
      int lcm_sym96__;
      int lcm_sym95__;
      int lcm_sym94__;
      int lcm_sym93__;
      int lcm_sym92__;
      int lcm_sym91__;
      int lcm_sym90__;
      int lcm_sym89__;
      int lcm_sym88__;
      int lcm_sym87__;
      int lcm_sym86__;
      int lcm_sym85__;
      int lcm_sym84__;
      local_scalar_t__ mean_p;
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                 0, 1, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
               0, 1, lp__, max_age);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(p, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      lcm_sym85__ = logical_gte(nind, 1);
      if (lcm_sym85__) {
        lcm_sym122__ = rvalue(first, "first", index_uni(1));
        lcm_sym98__ = (lcm_sym122__ - 1);
        if (logical_gte(lcm_sym98__, 1)) {
          current_statement__ = 6;
          assign(phi, 0, "assigning variable phi", index_uni(1), index_uni(1));
          current_statement__ = 7;
          assign(p, 0, "assigning variable p", index_uni(1), index_uni(1));
          for (int t = 2; t <= lcm_sym98__; ++t) {
            current_statement__ = 6;
            assign(phi, 0,
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 7;
            assign(p, 0, "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        lcm_sym96__ = (n_occasions - 1);
        if (logical_gte(lcm_sym96__, lcm_sym122__)) {
          current_statement__ = 9;
          assign(phi,
            rvalue(beta, "beta",
              index_uni(rvalue(x, "x", index_uni(1), index_uni(lcm_sym122__)))),
            "assigning variable phi", index_uni(1), index_uni(lcm_sym122__));
          lcm_sym104__ = (lcm_sym122__ + 1);
          assign(p, mean_p,
            "assigning variable p", index_uni(1), index_uni(lcm_sym122__));
          for (int t = lcm_sym104__; t <= lcm_sym96__; ++t) {
            current_statement__ = 9;
            assign(phi,
              rvalue(beta, "beta",
                index_uni(rvalue(x, "x", index_uni(1), index_uni(t)))),
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 10;
            assign(p, mean_p,
              "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        for (int i = 2; i <= nind; ++i) {
          lcm_sym121__ = rvalue(first, "first", index_uni(i));
          lcm_sym97__ = (lcm_sym121__ - 1);
          if (logical_gte(lcm_sym97__, 1)) {
            current_statement__ = 6;
            assign(phi, 0,
              "assigning variable phi", index_uni(i), index_uni(1));
            current_statement__ = 7;
            assign(p, 0, "assigning variable p", index_uni(i), index_uni(1));
            for (int t = 2; t <= lcm_sym97__; ++t) {
              current_statement__ = 6;
              assign(phi, 0,
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 7;
              assign(p, 0, "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
          current_statement__ = 12;
          if (logical_gte(lcm_sym96__, lcm_sym121__)) {
            current_statement__ = 9;
            assign(phi,
              rvalue(beta, "beta",
                index_uni(rvalue(x, "x",
                            index_uni(i), index_uni(lcm_sym121__)))),
              "assigning variable phi", index_uni(i), index_uni(lcm_sym121__));
            lcm_sym103__ = (lcm_sym121__ + 1);
            assign(p, mean_p,
              "assigning variable p", index_uni(i), index_uni(lcm_sym121__));
            for (int t = lcm_sym103__; t <= lcm_sym96__; ++t) {
              current_statement__ = 9;
              assign(phi,
                rvalue(beta, "beta",
                  index_uni(rvalue(x, "x", index_uni(i), index_uni(t)))),
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 10;
              assign(p, mean_p,
                "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
        }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym9__;
      int inline_sym15__;
      inline_sym15__ = 0;
      for (int inline_sym16__ = 1; inline_sym16__ <= 1; ++inline_sym16__) {
        current_statement__ = 14;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym10__;
        inline_sym10__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        stan::math::fill(inline_sym10__, DUMMY_VAR__);
        
        for (int inline_sym14__ = 1; inline_sym14__ <= nind; ++inline_sym14__) {
          current_statement__ = 17;
          assign(inline_sym10__, 1.0,
            "assigning variable inline_sym10__", index_uni(inline_sym14__),
                                                   index_uni(n_occasions));
          lcm_sym96__ = (n_occasions - 1);
          if (logical_gte(lcm_sym96__, 1)) {
            int inline_sym11__;
            int inline_sym12__;
            lcm_sym100__ = (lcm_sym96__ + 1);
            current_statement__ = 20;
            assign(inline_sym10__,
              stan::math::fma(
                (rvalue(phi, "phi",
                   index_uni(inline_sym14__), index_uni(lcm_sym96__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(inline_sym14__),
                        index_uni((lcm_sym100__ - 1))))),
                rvalue(inline_sym10__, "inline_sym10__",
                  index_uni(inline_sym14__), index_uni(lcm_sym100__)),
                (1 -
                  rvalue(phi, "phi",
                    index_uni(inline_sym14__), index_uni(lcm_sym96__)))),
              "assigning variable inline_sym10__", index_uni(inline_sym14__),
                                                     index_uni(lcm_sym96__));
            for (int inline_sym13__ = 2; inline_sym13__ <= lcm_sym96__;
                 ++inline_sym13__) {
              int inline_sym11__;
              lcm_sym95__ = (n_occasions - inline_sym13__);
              int inline_sym12__;
              lcm_sym99__ = (lcm_sym95__ + 1);
              current_statement__ = 20;
              assign(inline_sym10__,
                stan::math::fma(
                  (rvalue(phi, "phi",
                     index_uni(inline_sym14__), index_uni(lcm_sym95__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(inline_sym14__),
                          index_uni((lcm_sym99__ - 1))))),
                  rvalue(inline_sym10__, "inline_sym10__",
                    index_uni(inline_sym14__), index_uni(lcm_sym99__)),
                  (1 -
                    rvalue(phi, "phi",
                      index_uni(inline_sym14__), index_uni(lcm_sym95__)))),
                "assigning variable inline_sym10__", index_uni(inline_sym14__),
                                                       index_uni(lcm_sym95__));
            }
          } 
          if (inline_sym15__) {
            break;
          } 
        }
        if (inline_sym15__) {
          break;
        } 
        inline_sym15__ = 1;
        assign(inline_sym9__, inline_sym10__,
          "assigning variable inline_sym9__");
        break;
      }
      assign(chi, inline_sym9__, "assigning variable chi");
      current_statement__ = 3;
      if (lcm_sym85__) {
        lcm_sym96__ = (n_occasions - 1);
        lcm_sym86__ = logical_gte(lcm_sym96__, 1);
        if (lcm_sym86__) {
          current_statement__ = 3;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi, "phi",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
            current_statement__ = 3;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym86__) {
            current_statement__ = 3;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
              current_statement__ = 3;
              check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                     rvalue(phi, "phi",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 3;
      if (lcm_sym85__) {
        lcm_sym96__ = (n_occasions - 1);
        lcm_sym86__ = logical_gte(lcm_sym96__, 1);
        if (lcm_sym86__) {
          current_statement__ = 3;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi, "phi", index_uni(1), index_uni(1)),
                              1);
          for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
            current_statement__ = 3;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym86__) {
            current_statement__ = 3;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
              current_statement__ = 3;
              check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                  rvalue(phi, "phi",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 4;
      if (lcm_sym85__) {
        lcm_sym96__ = (n_occasions - 1);
        lcm_sym86__ = logical_gte(lcm_sym96__, 1);
        if (lcm_sym86__) {
          current_statement__ = 4;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p, "p", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
            current_statement__ = 4;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym86__) {
            current_statement__ = 4;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
              current_statement__ = 4;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(p, "p",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 4;
      if (lcm_sym85__) {
        lcm_sym96__ = (n_occasions - 1);
        lcm_sym86__ = logical_gte(lcm_sym96__, 1);
        if (lcm_sym86__) {
          current_statement__ = 4;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p, "p", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
            current_statement__ = 4;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym86__) {
            current_statement__ = 4;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym96__; ++sym2__) {
              current_statement__ = 4;
              check_less_or_equal(function__, "p[sym1__, sym2__]",
                                  rvalue(p, "p",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym85__) {
        lcm_sym84__ = logical_gte(n_occasions, 1);
        if (lcm_sym84__) {
          current_statement__ = 5;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(inline_sym9__, "inline_sym9__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym9__, "inline_sym9__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym84__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym9__, "inline_sym9__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                     rvalue(inline_sym9__, "inline_sym9__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym85__) {
        lcm_sym84__ = logical_gte(n_occasions, 1);
        if (lcm_sym84__) {
          current_statement__ = 5;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(inline_sym9__, "inline_sym9__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym9__, "inline_sym9__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym84__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym9__, "inline_sym9__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                  rvalue(inline_sym9__, "inline_sym9__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      {
        current_statement__ = 30;
        if (lcm_sym85__) {
          lcm_sym122__ = rvalue(first, "first", index_uni(1));
          if (logical_gt(lcm_sym122__, 0)) {
            lcm_sym128__ = rvalue(last, "last", index_uni(1));
            if (logical_gte(lcm_sym128__, (lcm_sym122__ + 1))) {
              current_statement__ = 24;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(phi, "phi",
                    index_uni(1), index_uni(((lcm_sym122__ + 1) - 1)))));
              lcm_sym102__ = ((lcm_sym122__ + 1) + 1);
              lp_accum__.add(
                bernoulli_lpmf<propto__>(
                  rvalue(y, "y", index_uni(1), index_uni((lcm_sym122__ + 1))),
                  rvalue(p, "p",
                    index_uni(1), index_uni(((lcm_sym122__ + 1) - 1)))));
              for (int t = lcm_sym102__; t <= lcm_sym128__; ++t) {
                current_statement__ = 24;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(phi, "phi", index_uni(1), index_uni((t - 1)))));
                current_statement__ = 25;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(
                    rvalue(y, "y", index_uni(1), index_uni(t)),
                    rvalue(p, "p", index_uni(1), index_uni((t - 1)))));
              }
            } 
            current_statement__ = 27;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                rvalue(inline_sym9__, "inline_sym9__",
                  index_uni(1), index_uni(lcm_sym128__))));
          } 
          for (int i = 2; i <= nind; ++i) {
            lcm_sym121__ = rvalue(first, "first", index_uni(i));
            if (logical_gt(lcm_sym121__, 0)) {
              lcm_sym127__ = rvalue(last, "last", index_uni(i));
              if (logical_gte(lcm_sym127__, (lcm_sym121__ + 1))) {
                current_statement__ = 24;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(phi, "phi",
                      index_uni(i), index_uni(((lcm_sym121__ + 1) - 1)))));
                lcm_sym101__ = ((lcm_sym121__ + 1) + 1);
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(
                    rvalue(y, "y",
                      index_uni(i), index_uni((lcm_sym121__ + 1))),
                    rvalue(p, "p",
                      index_uni(i), index_uni(((lcm_sym121__ + 1) - 1)))));
                for (int t = lcm_sym101__; t <= lcm_sym127__; ++t) {
                  current_statement__ = 24;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(1,
                      rvalue(phi, "phi", index_uni(i), index_uni((t - 1)))));
                  current_statement__ = 25;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(
                      rvalue(y, "y", index_uni(i), index_uni(t)),
                      rvalue(p, "p", index_uni(i), index_uni((t - 1)))));
                }
              } 
              current_statement__ = 27;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(inline_sym9__, "inline_sym9__",
                    index_uni(i), index_uni(lcm_sym127__))));
            } 
          }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "fails_test_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym83__;
      double lcm_sym82__;
      double lcm_sym81__;
      double lcm_sym80__;
      double lcm_sym79__;
      double lcm_sym78__;
      double lcm_sym77__;
      double lcm_sym76__;
      double lcm_sym75__;
      double lcm_sym74__;
      double lcm_sym73__;
      double lcm_sym72__;
      int lcm_sym71__;
      int lcm_sym70__;
      double lcm_sym69__;
      double lcm_sym68__;
      double lcm_sym67__;
      double lcm_sym66__;
      double lcm_sym65__;
      double lcm_sym64__;
      int lcm_sym63__;
      int lcm_sym62__;
      int lcm_sym61__;
      int lcm_sym60__;
      int lcm_sym59__;
      int lcm_sym58__;
      int lcm_sym57__;
      int lcm_sym56__;
      int lcm_sym55__;
      int lcm_sym54__;
      int lcm_sym53__;
      int lcm_sym52__;
      int lcm_sym51__;
      int lcm_sym50__;
      int lcm_sym49__;
      int lcm_sym48__;
      int lcm_sym47__;
      double mean_p;
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                 0, 1, lp__);
      Eigen::Matrix<double, -1, 1> beta;
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
               0, 1, lp__, max_age);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(p, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      out__.write(mean_p);
      out__.write(beta);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym48__ = logical_gte(nind, 1);
      if (lcm_sym48__) {
        lcm_sym71__ = rvalue(first, "first", index_uni(1));
        lcm_sym57__ = (lcm_sym71__ - 1);
        if (logical_gte(lcm_sym57__, 1)) {
          current_statement__ = 6;
          assign(phi, 0, "assigning variable phi", index_uni(1), index_uni(1));
          current_statement__ = 7;
          assign(p, 0, "assigning variable p", index_uni(1), index_uni(1));
          for (int t = 2; t <= lcm_sym57__; ++t) {
            current_statement__ = 6;
            assign(phi, 0,
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 7;
            assign(p, 0, "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        lcm_sym55__ = (n_occasions - 1);
        if (logical_gte(lcm_sym55__, lcm_sym71__)) {
          current_statement__ = 9;
          assign(phi,
            rvalue(beta, "beta",
              index_uni(rvalue(x, "x", index_uni(1), index_uni(lcm_sym71__)))),
            "assigning variable phi", index_uni(1), index_uni(lcm_sym71__));
          lcm_sym63__ = (lcm_sym71__ + 1);
          assign(p, mean_p,
            "assigning variable p", index_uni(1), index_uni(lcm_sym71__));
          for (int t = lcm_sym63__; t <= lcm_sym55__; ++t) {
            current_statement__ = 9;
            assign(phi,
              rvalue(beta, "beta",
                index_uni(rvalue(x, "x", index_uni(1), index_uni(t)))),
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 10;
            assign(p, mean_p,
              "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        for (int i = 2; i <= nind; ++i) {
          lcm_sym70__ = rvalue(first, "first", index_uni(i));
          lcm_sym56__ = (lcm_sym70__ - 1);
          if (logical_gte(lcm_sym56__, 1)) {
            current_statement__ = 6;
            assign(phi, 0,
              "assigning variable phi", index_uni(i), index_uni(1));
            current_statement__ = 7;
            assign(p, 0, "assigning variable p", index_uni(i), index_uni(1));
            for (int t = 2; t <= lcm_sym56__; ++t) {
              current_statement__ = 6;
              assign(phi, 0,
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 7;
              assign(p, 0, "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
          current_statement__ = 12;
          if (logical_gte(lcm_sym55__, lcm_sym70__)) {
            current_statement__ = 9;
            assign(phi,
              rvalue(beta, "beta",
                index_uni(rvalue(x, "x",
                            index_uni(i), index_uni(lcm_sym70__)))),
              "assigning variable phi", index_uni(i), index_uni(lcm_sym70__));
            lcm_sym62__ = (lcm_sym70__ + 1);
            assign(p, mean_p,
              "assigning variable p", index_uni(i), index_uni(lcm_sym70__));
            for (int t = lcm_sym62__; t <= lcm_sym55__; ++t) {
              current_statement__ = 9;
              assign(phi,
                rvalue(beta, "beta",
                  index_uni(rvalue(x, "x", index_uni(i), index_uni(t)))),
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 10;
              assign(p, mean_p,
                "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
        }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym1__;
      int inline_sym7__;
      inline_sym7__ = 0;
      for (int inline_sym8__ = 1; inline_sym8__ <= 1; ++inline_sym8__) {
        current_statement__ = 14;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym2__;
        inline_sym2__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        stan::math::fill(inline_sym2__, DUMMY_VAR__);
        
        for (int inline_sym6__ = 1; inline_sym6__ <= nind; ++inline_sym6__) {
          current_statement__ = 17;
          assign(inline_sym2__, 1.0,
            "assigning variable inline_sym2__", index_uni(inline_sym6__),
                                                  index_uni(n_occasions));
          lcm_sym55__ = (n_occasions - 1);
          if (logical_gte(lcm_sym55__, 1)) {
            int inline_sym3__;
            int inline_sym4__;
            lcm_sym61__ = (lcm_sym55__ + 1);
            current_statement__ = 20;
            assign(inline_sym2__,
              stan::math::fma(
                (rvalue(phi, "phi",
                   index_uni(inline_sym6__), index_uni(lcm_sym55__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(inline_sym6__), index_uni((lcm_sym61__ - 1))))),
                rvalue(inline_sym2__, "inline_sym2__",
                  index_uni(inline_sym6__), index_uni(lcm_sym61__)),
                (1 -
                  rvalue(phi, "phi",
                    index_uni(inline_sym6__), index_uni(lcm_sym55__)))),
              "assigning variable inline_sym2__", index_uni(inline_sym6__),
                                                    index_uni(lcm_sym55__));
            for (int inline_sym5__ = 2; inline_sym5__ <= lcm_sym55__;
                 ++inline_sym5__) {
              int inline_sym3__;
              lcm_sym54__ = (n_occasions - inline_sym5__);
              int inline_sym4__;
              lcm_sym60__ = (lcm_sym54__ + 1);
              current_statement__ = 20;
              assign(inline_sym2__,
                stan::math::fma(
                  (rvalue(phi, "phi",
                     index_uni(inline_sym6__), index_uni(lcm_sym54__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(inline_sym6__),
                          index_uni((lcm_sym60__ - 1))))),
                  rvalue(inline_sym2__, "inline_sym2__",
                    index_uni(inline_sym6__), index_uni(lcm_sym60__)),
                  (1 -
                    rvalue(phi, "phi",
                      index_uni(inline_sym6__), index_uni(lcm_sym54__)))),
                "assigning variable inline_sym2__", index_uni(inline_sym6__),
                                                      index_uni(lcm_sym54__));
            }
          } 
          if (inline_sym7__) {
            break;
          } 
        }
        if (inline_sym7__) {
          break;
        } 
        inline_sym7__ = 1;
        assign(inline_sym1__, inline_sym2__,
          "assigning variable inline_sym1__");
        break;
      }
      assign(chi, inline_sym1__, "assigning variable chi");
      current_statement__ = 3;
      if (lcm_sym48__) {
        lcm_sym55__ = (n_occasions - 1);
        lcm_sym49__ = logical_gte(lcm_sym55__, 1);
        if (lcm_sym49__) {
          current_statement__ = 3;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi, "phi",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
            current_statement__ = 3;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym49__) {
            current_statement__ = 3;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
              current_statement__ = 3;
              check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                     rvalue(phi, "phi",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 3;
      if (lcm_sym48__) {
        lcm_sym55__ = (n_occasions - 1);
        lcm_sym49__ = logical_gte(lcm_sym55__, 1);
        if (lcm_sym49__) {
          current_statement__ = 3;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi, "phi", index_uni(1), index_uni(1)),
                              1);
          for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
            current_statement__ = 3;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym49__) {
            current_statement__ = 3;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
              current_statement__ = 3;
              check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                  rvalue(phi, "phi",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 4;
      if (lcm_sym48__) {
        lcm_sym55__ = (n_occasions - 1);
        lcm_sym49__ = logical_gte(lcm_sym55__, 1);
        if (lcm_sym49__) {
          current_statement__ = 4;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p, "p", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
            current_statement__ = 4;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym49__) {
            current_statement__ = 4;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
              current_statement__ = 4;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(p, "p",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 4;
      if (lcm_sym48__) {
        lcm_sym55__ = (n_occasions - 1);
        lcm_sym49__ = logical_gte(lcm_sym55__, 1);
        if (lcm_sym49__) {
          current_statement__ = 4;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p, "p", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
            current_statement__ = 4;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym49__) {
            current_statement__ = 4;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym55__; ++sym2__) {
              current_statement__ = 4;
              check_less_or_equal(function__, "p[sym1__, sym2__]",
                                  rvalue(p, "p",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym48__) {
        lcm_sym47__ = logical_gte(n_occasions, 1);
        if (lcm_sym47__) {
          current_statement__ = 5;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(inline_sym1__, "inline_sym1__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym1__, "inline_sym1__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym47__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym1__, "inline_sym1__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                     rvalue(inline_sym1__, "inline_sym1__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym48__) {
        lcm_sym47__ = logical_gte(n_occasions, 1);
        if (lcm_sym47__) {
          current_statement__ = 5;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(inline_sym1__, "inline_sym1__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym1__, "inline_sym1__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym47__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym1__, "inline_sym1__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                  rvalue(inline_sym1__, "inline_sym1__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(inline_sym1__);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym46__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ mean_p;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(max_age);
      stan::math::fill(beta, DUMMY_VAR__);
      
      if (logical_gte(max_age, 1)) {
        assign(beta, in__.read<local_scalar_t__>(),
          "assigning variable beta", index_uni(1));
        for (int sym1__ = 2; sym1__ <= max_age; ++sym1__) {
          assign(beta, in__.read<local_scalar_t__>(),
            "assigning variable beta", index_uni(sym1__));
        }
      } 
      out__.write_free_lub(0, 1, beta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mean_p", "beta", "phi", "p", "chi"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(max_age)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occasions)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym168__ = 1; sym168__ <= max_age; ++sym168__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym168__));
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym168__ = 1; sym168__ <= n_occ_minus_1; ++sym168__) {
        {
          for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym169__) + '.' + std::to_string(sym168__));
            } 
          }
        } 
      }
      for (int sym168__ = 1; sym168__ <= n_occ_minus_1; ++sym168__) {
        {
          for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym169__) + '.' + std::to_string(sym168__));
            } 
          }
        } 
      }
      for (int sym168__ = 1; sym168__ <= n_occasions; ++sym168__) {
        {
          for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym169__) + '.' + std::to_string(sym168__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym168__ = 1; sym168__ <= max_age; ++sym168__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym168__));
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym168__ = 1; sym168__ <= n_occ_minus_1; ++sym168__) {
        {
          for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym169__) + '.' + std::to_string(sym168__));
            } 
          }
        } 
      }
      for (int sym168__ = 1; sym168__ <= n_occ_minus_1; ++sym168__) {
        {
          for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym169__) + '.' + std::to_string(sym168__));
            } 
          }
        } 
      }
      for (int sym168__ = 1; sym168__ <= n_occasions; ++sym168__) {
        {
          for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym169__) + '.' + std::to_string(sym168__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(max_age) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(max_age) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + max_age);
      const size_t num_transformed = (((nind *
                                                          n_occ_minus_1) +
                                                         (nind *
                                                           n_occ_minus_1)) +
                                                        (nind * n_occasions));
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + max_age);
      const size_t num_transformed = (((nind *
                                                          n_occ_minus_1) +
                                                         (nind *
                                                           n_occ_minus_1)) +
                                                        (nind * n_occasions));
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"mean_p", "beta"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{1, max_age};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = fails_test_model_namespace::fails_test_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return fails_test_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp inlining-fail2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace inlining_fail2_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 144> locations_array__ = 
{" (found before start of program)",
 " (in 'inlining-fail2.stan', line 177, column 2 to column 33)",
 " (in 'inlining-fail2.stan', line 178, column 2 to column 31)",
 " (in 'inlining-fail2.stan', line 179, column 2 to column 45)",
 " (in 'inlining-fail2.stan', line 180, column 2 to column 32)",
 " (in 'inlining-fail2.stan', line 181, column 2 to column 30)",
 " (in 'inlining-fail2.stan', line 187, column 2 to column 50)",
 " (in 'inlining-fail2.stan', line 188, column 2 to column 44)",
 " (in 'inlining-fail2.stan', line 189, column 2 to column 46)",
 " (in 'inlining-fail2.stan', line 194, column 6 to column 58)",
 " (in 'inlining-fail2.stan', line 193, column 4 to line 194, column 58)",
 " (in 'inlining-fail2.stan', line 49, column 4 to column 24)",
 " (in 'inlining-fail2.stan', line 50, column 4 to column 30)",
 " (in 'inlining-fail2.stan', line 51, column 11 to column 16)",
 " (in 'inlining-fail2.stan', line 51, column 18 to column 29)",
 " (in 'inlining-fail2.stan', line 51, column 4 to column 35)",
 " (in 'inlining-fail2.stan', line 54, column 6 to column 32)",
 " (in 'inlining-fail2.stan', line 56, column 8 to column 37)",
 " (in 'inlining-fail2.stan', line 57, column 8 to column 32)",
 " (in 'inlining-fail2.stan', line 59, column 8 to line 60, column 65)",
 " (in 'inlining-fail2.stan', line 55, column 37 to line 61, column 7)",
 " (in 'inlining-fail2.stan', line 53, column 23 to line 62, column 5)",
 " (in 'inlining-fail2.stan', line 48, column 47 to line 64, column 3)",
 " (in 'inlining-fail2.stan', line 213, column 2 to column 14)",
 " (in 'inlining-fail2.stan', line 214, column 2 to column 11)",
 " (in 'inlining-fail2.stan', line 215, column 2 to column 24)",
 " (in 'inlining-fail2.stan', line 216, column 2 to column 13)",
 " (in 'inlining-fail2.stan', line 217, column 2 to column 21)",
 " (in 'inlining-fail2.stan', line 218, column 2 to column 21)",
 " (in 'inlining-fail2.stan', line 219, column 2 to column 24)",
 " (in 'inlining-fail2.stan', line 223, column 4 to column 14)",
 " (in 'inlining-fail2.stan', line 224, column 4 to column 13)",
 " (in 'inlining-fail2.stan', line 231, column 6 to column 35)",
 " (in 'inlining-fail2.stan', line 228, column 6 to column 32)",
 " (in 'inlining-fail2.stan', line 227, column 29 to line 232, column 5)",
 " (in 'inlining-fail2.stan', line 226, column 4 to column 38)",
 " (in 'inlining-fail2.stan', line 227, column 4 to line 232, column 5)",
 " (in 'inlining-fail2.stan', line 222, column 17 to line 233, column 3)",
 " (in 'inlining-fail2.stan', line 222, column 2 to line 233, column 3)",
 " (in 'inlining-fail2.stan', line 237, column 11 to column 22)",
 " (in 'inlining-fail2.stan', line 237, column 4 to column 49)",
 " (in 'inlining-fail2.stan', line 148, column 4 to column 24)",
 " (in 'inlining-fail2.stan', line 149, column 11 to column 12)",
 " (in 'inlining-fail2.stan', line 149, column 4 to column 24)",
 " (in 'inlining-fail2.stan', line 150, column 4 to column 31)",
 " (in 'inlining-fail2.stan', line 153, column 6 to column 55)",
 " (in 'inlining-fail2.stan', line 154, column 6 to column 64)",
 " (in 'inlining-fail2.stan', line 152, column 19 to line 155, column 5)",
 " (in 'inlining-fail2.stan', line 147, column 33 to line 157, column 3)",
 " (in 'inlining-fail2.stan', line 238, column 16 to column 17)",
 " (in 'inlining-fail2.stan', line 238, column 19 to column 30)",
 " (in 'inlining-fail2.stan', line 238, column 4 to column 63)",
 " (in 'inlining-fail2.stan', line 239, column 13 to column 14)",
 " (in 'inlining-fail2.stan', line 239, column 4 to column 16)",
 " (in 'inlining-fail2.stan', line 240, column 15 to column 16)",
 " (in 'inlining-fail2.stan', line 240, column 4 to column 18)",
 " (in 'inlining-fail2.stan', line 247, column 6 to column 36)",
 " (in 'inlining-fail2.stan', line 17, column 8 to column 17)",
 " (in 'inlining-fail2.stan', line 16, column 6 to line 17, column 17)",
 " (in 'inlining-fail2.stan', line 14, column 31 to line 19, column 3)",
 " (in 'inlining-fail2.stan', line 250, column 8 to column 26)",
 " (in 'inlining-fail2.stan', line 249, column 6 to line 250, column 26)",
 " (in 'inlining-fail2.stan', line 246, column 19 to line 251, column 5)",
 " (in 'inlining-fail2.stan', line 246, column 4 to line 251, column 5)",
 " (in 'inlining-fail2.stan', line 253, column 6 to column 25)",
 " (in 'inlining-fail2.stan', line 254, column 6 to column 31)",
 " (in 'inlining-fail2.stan', line 252, column 29 to line 255, column 5)",
 " (in 'inlining-fail2.stan', line 252, column 4 to line 255, column 5)",
 " (in 'inlining-fail2.stan', line 257, column 6 to column 26)",
 " (in 'inlining-fail2.stan', line 258, column 6 to column 31)",
 " (in 'inlining-fail2.stan', line 256, column 19 to line 259, column 5)",
 " (in 'inlining-fail2.stan', line 256, column 4 to line 259, column 5)",
 " (in 'inlining-fail2.stan', line 260, column 4 to column 25)",
 " (in 'inlining-fail2.stan', line 236, column 2 to line 261, column 3)",
 " (in 'inlining-fail2.stan', line 206, column 2 to column 29)",
 " (in 'inlining-fail2.stan', line 80, column 4 to column 27)",
 " (in 'inlining-fail2.stan', line 81, column 4 to column 33)",
 " (in 'inlining-fail2.stan', line 82, column 11 to column 22)",
 " (in 'inlining-fail2.stan', line 82, column 4 to column 45)",
 " (in 'inlining-fail2.stan', line 85, column 13 to column 24)",
 " (in 'inlining-fail2.stan', line 85, column 6 to column 43)",
 " (in 'inlining-fail2.stan', line 119, column 8 to column 33)",
 " (in 'inlining-fail2.stan', line 122, column 8 to line 124, column 47)",
 " (in 'inlining-fail2.stan', line 127, column 10 to line 130, column 49)",
 " (in 'inlining-fail2.stan', line 132, column 8 to column 63)",
 " (in 'inlining-fail2.stan', line 133, column 8 to column 34)",
 " (in 'inlining-fail2.stan', line 118, column 13 to line 134, column 7)",
 " (in 'inlining-fail2.stan', line 92, column 17 to column 25)",
 " (in 'inlining-fail2.stan', line 92, column 10 to column 30)",
 " (in 'inlining-fail2.stan', line 101, column 12 to line 105, column 56)",
 " (in 'inlining-fail2.stan', line 106, column 10 to line 108, column 61)",
 " (in 'inlining-fail2.stan', line 109, column 10 to column 36)",
 " (in 'inlining-fail2.stan', line 91, column 15 to line 110, column 9)",
 " (in 'inlining-fail2.stan', line 90, column 10 to column 44)",
 " (in 'inlining-fail2.stan', line 89, column 27 to line 91, column 9)",
 " (in 'inlining-fail2.stan', line 89, column 8 to line 110, column 9)",
 " (in 'inlining-fail2.stan', line 113, column 10 to column 39)",
 " (in 'inlining-fail2.stan', line 114, column 10 to column 39)",
 " (in 'inlining-fail2.stan', line 112, column 42 to line 115, column 9)",
 " (in 'inlining-fail2.stan', line 117, column 8 to column 39)",
 " (in 'inlining-fail2.stan', line 87, column 20 to line 118, column 7)",
 " (in 'inlining-fail2.stan', line 84, column 23 to line 135, column 5)",
 " (in 'inlining-fail2.stan', line 161, column 2 to column 17)",
 " (in 'inlining-fail2.stan', line 162, column 2 to column 27)",
 " (in 'inlining-fail2.stan', line 163, column 25 to column 26)",
 " (in 'inlining-fail2.stan', line 163, column 28 to column 39)",
 " (in 'inlining-fail2.stan', line 163, column 2 to column 41)",
 " (in 'inlining-fail2.stan', line 167, column 39 to column 40)",
 " (in 'inlining-fail2.stan', line 167, column 2 to column 42)",
 " (in 'inlining-fail2.stan', line 168, column 38 to column 39)",
 " (in 'inlining-fail2.stan', line 168, column 2 to column 41)",
 " (in 'inlining-fail2.stan', line 171, column 4 to column 35)",
 " (in 'inlining-fail2.stan', line 170, column 2 to line 171, column 35)",
 " (in 'inlining-fail2.stan', line 30, column 6 to column 32)",
 " (in 'inlining-fail2.stan', line 33, column 8 to column 17)",
 " (in 'inlining-fail2.stan', line 32, column 6 to line 33, column 17)",
 " (in 'inlining-fail2.stan', line 29, column 37 to line 34, column 5)",
 " (in 'inlining-fail2.stan', line 28, column 30 to line 36, column 3)",
 " (in 'inlining-fail2.stan', line 173, column 4 to column 33)",
 " (in 'inlining-fail2.stan', line 172, column 2 to line 173, column 33)",
 " (in 'inlining-fail2.stan', line 179, column 26 to column 37)",
 " (in 'inlining-fail2.stan', line 180, column 9 to column 22)",
 " (in 'inlining-fail2.stan', line 187, column 26 to column 27)",
 " (in 'inlining-fail2.stan', line 187, column 29 to column 44)",
 " (in 'inlining-fail2.stan', line 188, column 26 to column 27)",
 " (in 'inlining-fail2.stan', line 188, column 29 to column 40)",
 " (in 'inlining-fail2.stan', line 189, column 26 to column 27)",
 " (in 'inlining-fail2.stan', line 189, column 29 to column 40)",
 " (in 'inlining-fail2.stan', line 215, column 9 to column 20)",
 " (in 'inlining-fail2.stan', line 217, column 8 to column 19)",
 " (in 'inlining-fail2.stan', line 218, column 8 to column 19)",
 " (in 'inlining-fail2.stan', line 219, column 8 to column 9)",
 " (in 'inlining-fail2.stan', line 219, column 11 to column 22)",
 " (in 'inlining-fail2.stan', line 18, column 4 to column 13)",
 " (in 'inlining-fail2.stan', line 35, column 4 to column 13)",
 " (in 'inlining-fail2.stan', line 55, column 6 to line 61, column 7)",
 " (in 'inlining-fail2.stan', line 53, column 4 to line 62, column 5)",
 " (in 'inlining-fail2.stan', line 63, column 4 to column 15)",
 " (in 'inlining-fail2.stan', line 126, column 8 to line 130, column 49)",
 " (in 'inlining-fail2.stan', line 100, column 10 to line 105, column 56)",
 " (in 'inlining-fail2.stan', line 84, column 4 to line 135, column 5)",
 " (in 'inlining-fail2.stan', line 79, column 34 to line 136, column 3)",
 " (in 'inlining-fail2.stan', line 152, column 4 to line 155, column 5)",
 " (in 'inlining-fail2.stan', line 156, column 4 to column 26)"};

int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) ;

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) ;

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
stan::value_type_t<T1__>>, -1, -1>
prob_uncaptured(const T0__& p, const T1__& phi, std::ostream* pstream__) ;

struct prob_uncaptured_functor__ {
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
stan::value_type_t<T1__>>, -1, -1>
operator()(const T0__& p, const T1__& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(p, phi, pstream__);
}
};

template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T_lp__, typename T_lp_accum__>
void
jolly_seber_lp(const std::vector<std::vector<int>>& y,
               const std::vector<int>& first, const std::vector<int>& last,
               const T3__& p, const T4__& phi, const T5__& gamma,
               const T6__& chi, T_lp__& lp__, T_lp_accum__& lp_accum__,
               std::ostream* pstream__) ;

struct jolly_seber_lp_functor__ {
template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T_lp__, typename T_lp_accum__>
void
operator()(const std::vector<std::vector<int>>& y,
           const std::vector<int>& first, const std::vector<int>& last,
           const T3__& p, const T4__& phi, const T5__& gamma,
           const T6__& chi, T_lp__& lp__, T_lp_accum__& lp_accum__,
           std::ostream* pstream__)  const 
{
return jolly_seber_lp<propto__>(y, first, last, p, phi, gamma, chi, lp__,
         lp_accum__, pstream__);
}
};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
seq_cprob(const T0__& gamma, std::ostream* pstream__) ;

struct seq_cprob_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
operator()(const T0__& gamma, std::ostream* pstream__)  const 
{
return seq_cprob(gamma, pstream__);
}
};

int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym53__;
    int lcm_sym52__;
    int lcm_sym51__;
    int lcm_sym50__;
    {
      lcm_sym51__ = size(y_i);
      if (logical_gte(lcm_sym51__, 1)) {
        current_statement__ = 58;
        if (rvalue(y_i, "y_i", index_uni(1))) {
          current_statement__ = 57;
          return 1;
        } 
        for (int k = 2; k <= lcm_sym51__; ++k) {
          current_statement__ = 58;
          if (rvalue(y_i, "y_i", index_uni(k))) {
            current_statement__ = 57;
            return k;
          } 
        }
      } 
      current_statement__ = 133;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym59__;
    int lcm_sym58__;
    int lcm_sym57__;
    int lcm_sym56__;
    int lcm_sym55__;
    int lcm_sym54__;
    {
      lcm_sym57__ = (size(y_i) - 1);
      if (logical_gte(lcm_sym57__, 0)) {
        int k;
        lcm_sym56__ = (size(y_i) - 0);
        current_statement__ = 115;
        if (y_i[(lcm_sym56__ - 1)]) {
          current_statement__ = 114;
          return lcm_sym56__;
        } 
        for (int k_rev = 1; k_rev <= lcm_sym57__; ++k_rev) {
          int k;
          lcm_sym55__ = (size(y_i) - k_rev);
          current_statement__ = 115;
          if (y_i[(lcm_sym55__ - 1)]) {
            current_statement__ = 114;
            return lcm_sym55__;
          } 
        }
      } 
      current_statement__ = 134;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
stan::value_type_t<T1__>>, -1, -1>
prob_uncaptured(const T0__& p_arg__, const T1__& phi_arg__,
                std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>>;
  int current_statement__ = 0; 
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym71__;
    double lcm_sym70__;
    double lcm_sym69__;
    double lcm_sym68__;
    double lcm_sym67__;
    int lcm_sym66__;
    int lcm_sym65__;
    int lcm_sym64__;
    int lcm_sym63__;
    int lcm_sym62__;
    int lcm_sym61__;
    int lcm_sym60__;
    {
      int n_ind;
      lcm_sym71__ = rows(p);
      int n_occasions;
      lcm_sym66__ = cols(p);
      n_occasions = lcm_sym66__;
      current_statement__ = 13;
      validate_non_negative_index("chi", "n_ind", lcm_sym71__);
      current_statement__ = 14;
      validate_non_negative_index("chi", "n_occasions", lcm_sym66__);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(lcm_sym71__, lcm_sym66__);
      stan::math::fill(chi, DUMMY_VAR__);
      
      current_statement__ = 136;
      if (logical_gte(lcm_sym71__, 1)) {
        current_statement__ = 16;
        assign(chi, 1.0,
          "assigning variable chi", index_uni(1), index_uni(lcm_sym66__));
        lcm_sym63__ = (lcm_sym66__ - 1);
        lcm_sym60__ = logical_gte(lcm_sym63__, 1);
        if (lcm_sym60__) {
          int t_curr;
          int t_next;
          lcm_sym65__ = (lcm_sym63__ + 1);
          current_statement__ = 19;
          assign(chi,
            stan::math::fma(
              (rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym63__)) *
                (1 - rvalue(p, "p", index_uni(1), index_uni(lcm_sym65__)))),
              rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym65__)),
              (1 - rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym63__)))),
            "assigning variable chi", index_uni(1), index_uni(lcm_sym63__));
          for (int t = 2; t <= lcm_sym63__; ++t) {
            int t_curr;
            lcm_sym62__ = (lcm_sym66__ - t);
            int t_next;
            lcm_sym64__ = (lcm_sym62__ + 1);
            current_statement__ = 19;
            assign(chi,
              stan::math::fma(
                (rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym62__)) *
                  (1 - rvalue(p, "p", index_uni(1), index_uni(lcm_sym64__)))),
                rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym64__)),
                (1 -
                  rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym62__)))),
              "assigning variable chi", index_uni(1), index_uni(lcm_sym62__));
          }
        } 
        for (int i = 2; i <= lcm_sym71__; ++i) {
          current_statement__ = 16;
          assign(chi, 1.0,
            "assigning variable chi", index_uni(i), index_uni(lcm_sym66__));
          current_statement__ = 135;
          if (lcm_sym60__) {
            int t_curr;
            int t_next;
            lcm_sym65__ = (lcm_sym63__ + 1);
            current_statement__ = 19;
            assign(chi,
              stan::math::fma(
                (rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym63__)) *
                  (1 - rvalue(p, "p", index_uni(i), index_uni(lcm_sym65__)))),
                rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym65__)),
                (1 -
                  rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym63__)))),
              "assigning variable chi", index_uni(i), index_uni(lcm_sym63__));
            for (int t = 2; t <= lcm_sym63__; ++t) {
              int t_curr;
              lcm_sym62__ = (lcm_sym66__ - t);
              int t_next;
              lcm_sym64__ = (lcm_sym62__ + 1);
              current_statement__ = 19;
              assign(chi,
                stan::math::fma(
                  (rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym62__)) *
                    (1 -
                      rvalue(p, "p", index_uni(i), index_uni(lcm_sym64__)))),
                  rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym64__)),
                  (1 -
                    rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym62__)))),
                "assigning variable chi", index_uni(i),
                                            index_uni(lcm_sym62__));
            }
          } 
        }
      } 
      current_statement__ = 137;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T_lp__, typename T_lp_accum__>
void
jolly_seber_lp(const std::vector<std::vector<int>>& y,
               const std::vector<int>& first, const std::vector<int>& last,
               const T3__& p_arg__, const T4__& phi_arg__,
               const T5__& gamma_arg__, const T6__& chi_arg__, T_lp__& lp__,
               T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T3__>,
          stan::value_type_t<T4__>,
          stan::value_type_t<T5__>,
          stan::value_type_t<T6__>>;
  int current_statement__ = 0; 
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  const auto& gamma = to_ref(gamma_arg__);
  const auto& chi = to_ref(chi_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym121__;
    int lcm_sym120__;
    int lcm_sym119__;
    int lcm_sym118__;
    int lcm_sym117__;
    int lcm_sym116__;
    double lcm_sym115__;
    double lcm_sym114__;
    double lcm_sym113__;
    double lcm_sym112__;
    double lcm_sym111__;
    double lcm_sym110__;
    double lcm_sym109__;
    double lcm_sym108__;
    double lcm_sym107__;
    double lcm_sym106__;
    double lcm_sym105__;
    double lcm_sym104__;
    double lcm_sym103__;
    double lcm_sym102__;
    int lcm_sym101__;
    int lcm_sym100__;
    int lcm_sym99__;
    double lcm_sym98__;
    double lcm_sym97__;
    double lcm_sym96__;
    double lcm_sym95__;
    double lcm_sym94__;
    double lcm_sym93__;
    double lcm_sym92__;
    double lcm_sym91__;
    double lcm_sym90__;
    double lcm_sym89__;
    double lcm_sym88__;
    double lcm_sym87__;
    double lcm_sym86__;
    double lcm_sym85__;
    int lcm_sym84__;
    int lcm_sym83__;
    Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym82__;
    Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym81__;
    Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym80__;
    int lcm_sym79__;
    int lcm_sym78__;
    int lcm_sym77__;
    int lcm_sym76__;
    int lcm_sym75__;
    int lcm_sym74__;
    int lcm_sym73__;
    int lcm_sym72__;
    {
      int n_ind;
      lcm_sym120__ = rvalue(dims(y), "dims(y)", index_uni(1));
      int n_occasions;
      lcm_sym121__ = rvalue(dims(y), "dims(y)", index_uni(2));
      n_occasions = lcm_sym121__;
      current_statement__ = 77;
      validate_non_negative_index("qgamma", "n_occasions", lcm_sym121__);
      Eigen::Matrix<double, -1, 1> qgamma;
      assign(lcm_sym80__, subtract(1.0, gamma),
        "assigning variable lcm_sym80__");
      current_statement__ = 140;
      if (logical_gte(lcm_sym120__, 1)) {
        current_statement__ = 79;
        validate_non_negative_index("qp", "n_occasions", lcm_sym121__);
        Eigen::Matrix<double, -1, 1> qp;
        assign(lcm_sym82__,
          subtract(1.0, transpose(rvalue(p, "p", index_uni(1)))),
          "assigning variable lcm_sym82__");
        lcm_sym117__ = rvalue(first, "first", index_uni(1));
        if (lcm_sym117__) {
          current_statement__ = 95;
          if (logical_eq(lcm_sym117__, 1)) {
            current_statement__ = 93;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                (rvalue(gamma, "gamma", index_uni(1)) *
                  rvalue(p, "p", index_uni(1), index_uni(1)))));
          } else {
            current_statement__ = 87;
            validate_non_negative_index("lp", "first[i]", lcm_sym117__);
            Eigen::Matrix<local_scalar_t__, -1, 1> lp;
            lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym117__);
            stan::math::fill(lp, DUMMY_VAR__);
            
            lcm_sym84__ = (lcm_sym117__ - 1);
            assign(lp,
              (((bernoulli_lpmf<false>(1,
                   rvalue(gamma, "gamma", index_uni(1))) +
                  bernoulli_lpmf<false>(1,
                    prod(
                      rvalue(lcm_sym82__, "lcm_sym82__",
                        index_min_max(1, lcm_sym84__))))) +
                 bernoulli_lpmf<false>(1,
                   prod(
                     rvalue(phi, "phi",
                       index_uni(1), index_min_max(1, lcm_sym84__))))) +
                bernoulli_lpmf<false>(1,
                  rvalue(p, "p", index_uni(1), index_uni(lcm_sym117__)))),
              "assigning variable lp", index_uni(1));
            current_statement__ = 139;
            if (logical_gte(lcm_sym84__, 2)) {
              current_statement__ = 89;
              assign(lp,
                ((((bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym80__, "lcm_sym80__",
                          index_min_max(1, 1)))) +
                     bernoulli_lpmf<false>(1,
                       rvalue(gamma, "gamma", index_uni(2)))) +
                    bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym82__, "lcm_sym82__",
                          index_min_max(2, lcm_sym84__))))) +
                   bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(phi, "phi",
                         index_uni(1), index_min_max(2, lcm_sym84__))))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(p, "p", index_uni(1), index_uni(lcm_sym117__)))),
                "assigning variable lp", index_uni(2));
              for (int t = 3; t <= lcm_sym84__; ++t) {
                current_statement__ = 89;
                assign(lp,
                  ((((bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym80__, "lcm_sym80__",
                            index_min_max(1, (t - 1))))) +
                       bernoulli_lpmf<false>(1,
                         rvalue(gamma, "gamma", index_uni(t)))) +
                      bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym82__, "lcm_sym82__",
                            index_min_max(t, lcm_sym84__))))) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(phi, "phi",
                           index_uni(1), index_min_max(t, lcm_sym84__))))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(p, "p", index_uni(1), index_uni(lcm_sym117__)))),
                  "assigning variable lp", index_uni(t));
              }
            } 
            current_statement__ = 90;
            assign(lp,
              ((bernoulli_lpmf<false>(1,
                  prod(
                    rvalue(lcm_sym80__, "lcm_sym80__",
                      index_min_max(1, lcm_sym84__)))) +
                 bernoulli_lpmf<false>(1, gamma[(lcm_sym117__ - 1)])) +
                bernoulli_lpmf<false>(1,
                  rvalue(p, "p", index_uni(1), index_uni(lcm_sym117__)))),
              "assigning variable lp", index_uni(lcm_sym117__));
            current_statement__ = 91;
            lp_accum__.add(log_sum_exp(lp));
          }
          lcm_sym119__ = rvalue(last, "last", index_uni(1));
          if (logical_gte(lcm_sym119__, (lcm_sym117__ + 1))) {
            current_statement__ = 96;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                rvalue(phi, "phi",
                  index_uni(1), index_uni(((lcm_sym117__ + 1) - 1)))));
            lcm_sym101__ = ((lcm_sym117__ + 1) + 1);
            lp_accum__.add(
              bernoulli_lpmf<propto__>(
                rvalue(y, "y", index_uni(1), index_uni((lcm_sym117__ + 1))),
                rvalue(p, "p", index_uni(1), index_uni((lcm_sym117__ + 1)))));
            for (int t = lcm_sym101__; t <= lcm_sym119__; ++t) {
              current_statement__ = 96;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(phi, "phi", index_uni(1), index_uni((t - 1)))));
              current_statement__ = 97;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(
                  rvalue(y, "y", index_uni(1), index_uni(t)),
                  rvalue(p, "p", index_uni(1), index_uni(t))));
            }
          } 
          current_statement__ = 99;
          lp_accum__.add(
            bernoulli_lpmf<propto__>(1,
              rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym119__))));
        } else {
          lcm_sym99__ = (lcm_sym121__ + 1);
          validate_non_negative_index("lp", "n_occasions + 1", lcm_sym99__);
          Eigen::Matrix<local_scalar_t__, -1, 1> lp;
          lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym99__);
          stan::math::fill(lp, DUMMY_VAR__);
          
          current_statement__ = 82;
          assign(lp,
            ((bernoulli_lpmf<false>(1, rvalue(gamma, "gamma", index_uni(1)))
               +
               bernoulli_lpmf<false>(0,
                 rvalue(p, "p", index_uni(1), index_uni(1)))) +
              bernoulli_lpmf<false>(1,
                rvalue(chi, "chi", index_uni(1), index_uni(1)))),
            "assigning variable lp", index_uni(1));
          current_statement__ = 138;
          if (logical_gte(lcm_sym121__, 2)) {
            current_statement__ = 83;
            assign(lp,
              (((bernoulli_lpmf<false>(1,
                   prod(
                     rvalue(lcm_sym80__, "lcm_sym80__", index_min_max(1, 1))))
                  +
                  bernoulli_lpmf<false>(1,
                    rvalue(gamma, "gamma", index_uni(2)))) +
                 bernoulli_lpmf<false>(0,
                   rvalue(p, "p", index_uni(1), index_uni(2)))) +
                bernoulli_lpmf<false>(1,
                  rvalue(chi, "chi", index_uni(1), index_uni(2)))),
              "assigning variable lp", index_uni(2));
            for (int t = 3; t <= lcm_sym121__; ++t) {
              current_statement__ = 83;
              assign(lp,
                (((bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(lcm_sym80__, "lcm_sym80__",
                         index_min_max(1, (t - 1))))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(gamma, "gamma", index_uni(t)))) +
                   bernoulli_lpmf<false>(0,
                     rvalue(p, "p", index_uni(1), index_uni(t)))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(chi, "chi", index_uni(1), index_uni(t)))),
                "assigning variable lp", index_uni(t));
            }
          } 
          current_statement__ = 84;
          assign(lp, bernoulli_lpmf<false>(1, prod(lcm_sym80__)),
            "assigning variable lp", index_uni(lcm_sym99__));
          current_statement__ = 85;
          lp_accum__.add(log_sum_exp(lp));
        }
        for (int i = 2; i <= lcm_sym120__; ++i) {
          current_statement__ = 79;
          validate_non_negative_index("qp", "n_occasions", lcm_sym121__);
          Eigen::Matrix<double, -1, 1> qp;
          assign(lcm_sym81__,
            subtract(1.0, transpose(rvalue(p, "p", index_uni(i)))),
            "assigning variable lcm_sym81__");
          lcm_sym116__ = rvalue(first, "first", index_uni(i));
          if (lcm_sym116__) {
            current_statement__ = 95;
            if (logical_eq(lcm_sym116__, 1)) {
              current_statement__ = 93;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  (rvalue(gamma, "gamma", index_uni(1)) *
                    rvalue(p, "p", index_uni(i), index_uni(1)))));
            } else {
              current_statement__ = 87;
              validate_non_negative_index("lp", "first[i]", lcm_sym116__);
              Eigen::Matrix<local_scalar_t__, -1, 1> lp;
              lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym116__);
              stan::math::fill(lp, DUMMY_VAR__);
              
              lcm_sym83__ = (lcm_sym116__ - 1);
              assign(lp,
                (((bernoulli_lpmf<false>(1,
                     rvalue(gamma, "gamma", index_uni(1))) +
                    bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym81__, "lcm_sym81__",
                          index_min_max(1, lcm_sym83__))))) +
                   bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(phi, "phi",
                         index_uni(i), index_min_max(1, lcm_sym83__))))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(p, "p", index_uni(i), index_uni(lcm_sym116__)))),
                "assigning variable lp", index_uni(1));
              current_statement__ = 139;
              if (logical_gte(lcm_sym83__, 2)) {
                current_statement__ = 89;
                assign(lp,
                  ((((bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym80__, "lcm_sym80__",
                            index_min_max(1, 1)))) +
                       bernoulli_lpmf<false>(1,
                         rvalue(gamma, "gamma", index_uni(2)))) +
                      bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym81__, "lcm_sym81__",
                            index_min_max(2, lcm_sym83__))))) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(phi, "phi",
                           index_uni(i), index_min_max(2, lcm_sym83__))))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(p, "p", index_uni(i), index_uni(lcm_sym116__)))),
                  "assigning variable lp", index_uni(2));
                for (int t = 3; t <= lcm_sym83__; ++t) {
                  current_statement__ = 89;
                  assign(lp,
                    ((((bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym80__, "lcm_sym80__",
                              index_min_max(1, (t - 1))))) +
                         bernoulli_lpmf<false>(1,
                           rvalue(gamma, "gamma", index_uni(t)))) +
                        bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym81__, "lcm_sym81__",
                              index_min_max(t, lcm_sym83__))))) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(phi, "phi",
                             index_uni(i), index_min_max(t, lcm_sym83__)))))
                      +
                      bernoulli_lpmf<false>(1,
                        rvalue(p, "p", index_uni(i), index_uni(lcm_sym116__)))),
                    "assigning variable lp", index_uni(t));
                }
              } 
              current_statement__ = 90;
              assign(lp,
                ((bernoulli_lpmf<false>(1,
                    prod(
                      rvalue(lcm_sym80__, "lcm_sym80__",
                        index_min_max(1, lcm_sym83__)))) +
                   bernoulli_lpmf<false>(1, gamma[(lcm_sym116__ - 1)])) +
                  bernoulli_lpmf<false>(1,
                    rvalue(p, "p", index_uni(i), index_uni(lcm_sym116__)))),
                "assigning variable lp", index_uni(lcm_sym116__));
              current_statement__ = 91;
              lp_accum__.add(log_sum_exp(lp));
            }
            lcm_sym118__ = rvalue(last, "last", index_uni(i));
            if (logical_gte(lcm_sym118__, (lcm_sym116__ + 1))) {
              current_statement__ = 96;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(phi, "phi",
                    index_uni(i), index_uni(((lcm_sym116__ + 1) - 1)))));
              lcm_sym100__ = ((lcm_sym116__ + 1) + 1);
              lp_accum__.add(
                bernoulli_lpmf<propto__>(
                  rvalue(y, "y", index_uni(i), index_uni((lcm_sym116__ + 1))),
                  rvalue(p, "p", index_uni(i), index_uni((lcm_sym116__ + 1)))));
              for (int t = lcm_sym100__; t <= lcm_sym118__; ++t) {
                current_statement__ = 96;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(phi, "phi", index_uni(i), index_uni((t - 1)))));
                current_statement__ = 97;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(
                    rvalue(y, "y", index_uni(i), index_uni(t)),
                    rvalue(p, "p", index_uni(i), index_uni(t))));
              }
            } 
            current_statement__ = 99;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym118__))));
          } else {
            lcm_sym99__ = (lcm_sym121__ + 1);
            validate_non_negative_index("lp", "n_occasions + 1", lcm_sym99__);
            Eigen::Matrix<local_scalar_t__, -1, 1> lp;
            lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym99__);
            stan::math::fill(lp, DUMMY_VAR__);
            
            current_statement__ = 82;
            assign(lp,
              ((bernoulli_lpmf<false>(1,
                  rvalue(gamma, "gamma", index_uni(1))) +
                 bernoulli_lpmf<false>(0,
                   rvalue(p, "p", index_uni(i), index_uni(1)))) +
                bernoulli_lpmf<false>(1,
                  rvalue(chi, "chi", index_uni(i), index_uni(1)))),
              "assigning variable lp", index_uni(1));
            current_statement__ = 138;
            if (logical_gte(lcm_sym121__, 2)) {
              current_statement__ = 83;
              assign(lp,
                (((bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(lcm_sym80__, "lcm_sym80__",
                         index_min_max(1, 1)))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(gamma, "gamma", index_uni(2)))) +
                   bernoulli_lpmf<false>(0,
                     rvalue(p, "p", index_uni(i), index_uni(2)))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(chi, "chi", index_uni(i), index_uni(2)))),
                "assigning variable lp", index_uni(2));
              for (int t = 3; t <= lcm_sym121__; ++t) {
                current_statement__ = 83;
                assign(lp,
                  (((bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(lcm_sym80__, "lcm_sym80__",
                           index_min_max(1, (t - 1))))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(gamma, "gamma", index_uni(t)))) +
                     bernoulli_lpmf<false>(0,
                       rvalue(p, "p", index_uni(i), index_uni(t)))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(chi, "chi", index_uni(i), index_uni(t)))),
                  "assigning variable lp", index_uni(t));
              }
            } 
            current_statement__ = 84;
            assign(lp, bernoulli_lpmf<false>(1, prod(lcm_sym80__)),
              "assigning variable lp", index_uni(lcm_sym99__));
            current_statement__ = 85;
            lp_accum__.add(log_sum_exp(lp));
          }
        }
      } 
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
seq_cprob(const T0__& gamma_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  int current_statement__ = 0; 
  const auto& gamma = to_ref(gamma_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym128__;
    Eigen::Matrix<double, -1, 1> lcm_sym127__;
    double lcm_sym126__;
    double lcm_sym125__;
    double lcm_sym124__;
    double lcm_sym123__;
    int lcm_sym122__;
    {
      int N;
      lcm_sym128__ = rows(gamma);
      N = lcm_sym128__;
      current_statement__ = 42;
      validate_non_negative_index("log_cprob", "N", lcm_sym128__);
      Eigen::Matrix<local_scalar_t__, -1, 1> log_cprob;
      log_cprob = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym128__);
      stan::math::fill(log_cprob, DUMMY_VAR__);
      
      local_scalar_t__ log_residual_prob;
      current_statement__ = 142;
      if (logical_gte(lcm_sym128__, 1)) {
        current_statement__ = 45;
        assign(log_cprob,
          (stan::math::log(rvalue(gamma, "gamma", index_uni(1))) + 0),
          "assigning variable log_cprob", index_uni(1));
        current_statement__ = 46;
        log_residual_prob = (0 + log1m(rvalue(gamma, "gamma", index_uni(1))));
        for (int n = 2; n <= lcm_sym128__; ++n) {
          current_statement__ = 45;
          assign(log_cprob,
            (stan::math::log(rvalue(gamma, "gamma", index_uni(n))) +
              log_residual_prob),
            "assigning variable log_cprob", index_uni(n));
          current_statement__ = 46;
          log_residual_prob = (log_residual_prob +
                                log1m(rvalue(gamma, "gamma", index_uni(n))));
        }
      } 
      current_statement__ = 143;
      return stan::math::exp(log_cprob);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
class inlining_fail2_model final : public model_base_crtp<inlining_fail2_model> {

 private:
  int lcm_sym310__;
  int lcm_sym309__;
  int lcm_sym308__;
  int lcm_sym307__;
  int lcm_sym306__;
  int lcm_sym305__;
  int lcm_sym304__;
  int lcm_sym303__;
  int lcm_sym302__;
  int lcm_sym301__;
  int lcm_sym300__;
  int lcm_sym299__;
  int lcm_sym298__;
  int lcm_sym297__;
  int lcm_sym296__;
  int lcm_sym295__;
  int lcm_sym294__;
  int lcm_sym293__;
  int lcm_sym292__;
  int lcm_sym291__;
  int lcm_sym290__;
  int lcm_sym289__;
  int lcm_sym288__;
  int lcm_sym287__;
  int M;
  int n_occasions;
  std::vector<std::vector<int>> y;
  std::vector<int> first;
  std::vector<int> last;
  int epsilon_1dim__;
  int phi_2dim__; 
  
 
 public:
  ~inlining_fail2_model() { }
  
  inline std::string model_name() const final { return "inlining_fail2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  inlining_fail2_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "inlining_fail2_model_namespace::inlining_fail2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 102;
      context__.validate_dims("data initialization","M","int",
           std::vector<size_t>{});
      M = std::numeric_limits<int>::min();
      
      current_statement__ = 102;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 102;
      check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 103;
      context__.validate_dims("data initialization","n_occasions","int",
           std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      
      current_statement__ = 103;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 103;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 0);
      current_statement__ = 104;
      validate_non_negative_index("y", "M", M);
      current_statement__ = 105;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 106;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(M),
            static_cast<size_t>(n_occasions)});
      y = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 106;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 106;
        pos__ = 1;
        lcm_sym288__ = logical_gte(n_occasions, 1);
        if (lcm_sym288__) {
          {
            lcm_sym287__ = logical_gte(M, 1);
            if (lcm_sym287__) {
              current_statement__ = 106;
              assign(y, rvalue(y_flat__, "y_flat__", index_uni(1)),
                "assigning variable y", index_uni(1), index_uni(1));
              current_statement__ = 106;
              pos__ = 2;
              for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
                current_statement__ = 106;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(sym2__), index_uni(1));
                current_statement__ = 106;
                pos__ = (pos__ + 1);
              }
            } 
            for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
              current_statement__ = 106;
              if (lcm_sym287__) {
                current_statement__ = 106;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(1), index_uni(sym1__));
                current_statement__ = 106;
                pos__ = (pos__ + 1);
                for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
                  current_statement__ = 106;
                  assign(y, y_flat__[(pos__ - 1)],
                    "assigning variable y", index_uni(sym2__),
                                              index_uni(sym1__));
                  current_statement__ = 106;
                  pos__ = (pos__ + 1);
                }
              } 
            }
          }
        } else {
          lcm_sym287__ = logical_gte(M, 1);
        }
      }
      current_statement__ = 106;
      if (lcm_sym287__) {
        current_statement__ = 106;
        if (lcm_sym288__) {
          current_statement__ = 106;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 rvalue(y, "y", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 106;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 106;
          if (lcm_sym288__) {
            current_statement__ = 106;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 106;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);
            }
          } 
        }
      } 
      current_statement__ = 106;
      if (lcm_sym287__) {
        current_statement__ = 106;
        if (lcm_sym288__) {
          current_statement__ = 106;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              rvalue(y, "y", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 106;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 106;
          if (lcm_sym288__) {
            current_statement__ = 106;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 106;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);
            }
          } 
        }
      } 
      current_statement__ = 107;
      validate_non_negative_index("first", "M", M);
      current_statement__ = 108;
      first = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 109;
      validate_non_negative_index("last", "M", M);
      current_statement__ = 110;
      last = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 112;
      if (lcm_sym287__) {
        int inline_sym41__;
        int inline_sym43__;
        inline_sym43__ = 0;
        for (int inline_sym44__ = 1; inline_sym44__ <= 1; ++inline_sym44__) {
          lcm_sym296__ = size(rvalue(y, "y", index_uni(1)));
          for (int inline_sym42__ = 1; inline_sym42__ <= lcm_sym296__;
               ++inline_sym42__) {
            current_statement__ = 58;
            if (rvalue(y, "y", index_uni(1))[(inline_sym42__ - 1)]) {
              inline_sym43__ = 1;
              inline_sym41__ = inline_sym42__;
              break;
            } 
          }
          if (inline_sym43__) {
            break;
          } 
          inline_sym43__ = 1;
          inline_sym41__ = 0;
          break;
        }
        assign(first, inline_sym41__,
          "assigning variable first", index_uni(1));
        for (int i = 2; i <= M; ++i) {
          int inline_sym41__;
          int inline_sym43__;
          inline_sym43__ = 0;
          for (int inline_sym44__ = 1; inline_sym44__ <= 1; ++inline_sym44__) {
            lcm_sym295__ = size(rvalue(y, "y", index_uni(i)));
            for (int inline_sym42__ = 1; inline_sym42__ <= lcm_sym295__;
                 ++inline_sym42__) {
              current_statement__ = 58;
              if (rvalue(y, "y", index_uni(i))[(inline_sym42__ - 1)]) {
                inline_sym43__ = 1;
                inline_sym41__ = inline_sym42__;
                break;
              } 
            }
            if (inline_sym43__) {
              break;
            } 
            inline_sym43__ = 1;
            inline_sym41__ = 0;
            break;
          }
          assign(first, inline_sym41__,
            "assigning variable first", index_uni(i));
        }
      } 
      current_statement__ = 119;
      if (lcm_sym287__) {
        int inline_sym45__;
        int inline_sym48__;
        inline_sym48__ = 0;
        for (int inline_sym49__ = 1; inline_sym49__ <= 1; ++inline_sym49__) {
          lcm_sym296__ = size(rvalue(y, "y", index_uni(1)));
          lcm_sym293__ = (lcm_sym296__ - 1);
          for (int inline_sym47__ = 0; inline_sym47__ <= lcm_sym293__;
               ++inline_sym47__) {
            int inline_sym46__;
            lcm_sym292__ = (lcm_sym296__ - inline_sym47__);
            inline_sym46__ = lcm_sym292__;
            current_statement__ = 115;
            if (rvalue(y, "y", index_uni(1))[(lcm_sym292__ - 1)]) {
              inline_sym48__ = 1;
              inline_sym45__ = lcm_sym292__;
              break;
            } 
          }
          if (inline_sym48__) {
            break;
          } 
          inline_sym48__ = 1;
          inline_sym45__ = 0;
          break;
        }
        assign(last, inline_sym45__, "assigning variable last", index_uni(1));
        for (int i = 2; i <= M; ++i) {
          int inline_sym45__;
          int inline_sym48__;
          inline_sym48__ = 0;
          for (int inline_sym49__ = 1; inline_sym49__ <= 1; ++inline_sym49__) {
            lcm_sym295__ = size(rvalue(y, "y", index_uni(i)));
            lcm_sym291__ = (lcm_sym295__ - 1);
            for (int inline_sym47__ = 0; inline_sym47__ <= lcm_sym291__;
                 ++inline_sym47__) {
              int inline_sym46__;
              lcm_sym290__ = (lcm_sym295__ - inline_sym47__);
              inline_sym46__ = lcm_sym290__;
              current_statement__ = 115;
              if (rvalue(y, "y", index_uni(i))[(lcm_sym290__ - 1)]) {
                inline_sym48__ = 1;
                inline_sym45__ = lcm_sym290__;
                break;
              } 
            }
            if (inline_sym48__) {
              break;
            } 
            inline_sym48__ = 1;
            inline_sym45__ = 0;
            break;
          }
          assign(last, inline_sym45__,
            "assigning variable last", index_uni(i));
        }
      } 
      current_statement__ = 108;
      if (lcm_sym287__) {
        current_statement__ = 108;
        check_greater_or_equal(function__, "first[sym1__]",
                               rvalue(first, "first", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 108;
          check_greater_or_equal(function__, "first[sym1__]",
                                 first[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 108;
      if (lcm_sym287__) {
        current_statement__ = 108;
        check_less_or_equal(function__, "first[sym1__]",
                            rvalue(first, "first", index_uni(1)), n_occasions);
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 108;
          check_less_or_equal(function__, "first[sym1__]",
                              first[(sym1__ - 1)], n_occasions);
        }
      } 
      current_statement__ = 110;
      if (lcm_sym287__) {
        current_statement__ = 110;
        check_greater_or_equal(function__, "last[sym1__]",
                               rvalue(last, "last", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 110;
          check_greater_or_equal(function__, "last[sym1__]",
                                 last[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 110;
      if (lcm_sym287__) {
        current_statement__ = 110;
        check_less_or_equal(function__, "last[sym1__]",
                            rvalue(last, "last", index_uni(1)), n_occasions);
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 110;
          check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                              n_occasions);
        }
      } 
      current_statement__ = 120;
      validate_non_negative_index("gamma", "n_occasions", n_occasions);
      current_statement__ = 121;
      epsilon_1dim__ = std::numeric_limits<int>::min();
      
      lcm_sym289__ = (n_occasions - 1);
      epsilon_1dim__ = lcm_sym289__;
      current_statement__ = 121;
      validate_non_negative_index("epsilon", "n_occasions - 1", lcm_sym289__);
      current_statement__ = 122;
      validate_non_negative_index("phi", "M", M);
      current_statement__ = 123;
      phi_2dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 123;
      phi_2dim__ = lcm_sym289__;
      current_statement__ = 123;
      validate_non_negative_index("phi", "n_occasions - 1", lcm_sym289__);
      current_statement__ = 124;
      validate_non_negative_index("p", "M", M);
      current_statement__ = 125;
      validate_non_negative_index("p", "n_occasions", n_occasions);
      current_statement__ = 126;
      validate_non_negative_index("chi", "M", M);
      current_statement__ = 127;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      current_statement__ = 128;
      validate_non_negative_index("b", "n_occasions", n_occasions);
      current_statement__ = 129;
      validate_non_negative_index("N", "n_occasions", n_occasions);
      current_statement__ = 130;
      validate_non_negative_index("B", "n_occasions", n_occasions);
      current_statement__ = 131;
      validate_non_negative_index("z", "M", M);
      current_statement__ = 132;
      validate_non_negative_index("z", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + n_occasions + epsilon_1dim__ + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "inlining_fail2_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym286__;
      double lcm_sym285__;
      double lcm_sym284__;
      double lcm_sym283__;
      int lcm_sym282__;
      int lcm_sym281__;
      double lcm_sym280__;
      double lcm_sym279__;
      double lcm_sym278__;
      double lcm_sym277__;
      int lcm_sym276__;
      int lcm_sym275__;
      double lcm_sym274__;
      double lcm_sym273__;
      double lcm_sym272__;
      double lcm_sym271__;
      int lcm_sym270__;
      int lcm_sym269__;
      int lcm_sym267__;
      Eigen::Matrix<local_scalar_t__, -1, -1> lcm_sym266__;
      double lcm_sym265__;
      double lcm_sym264__;
      local_scalar_t__ lcm_sym263__;
      local_scalar_t__ lcm_sym262__;
      double lcm_sym261__;
      double lcm_sym260__;
      int lcm_sym259__;
      double lcm_sym258__;
      double lcm_sym257__;
      double lcm_sym256__;
      double lcm_sym255__;
      double lcm_sym254__;
      double lcm_sym253__;
      double lcm_sym252__;
      double lcm_sym251__;
      double lcm_sym250__;
      double lcm_sym249__;
      double lcm_sym248__;
      double lcm_sym247__;
      double lcm_sym246__;
      int lcm_sym245__;
      int lcm_sym244__;
      int lcm_sym243__;
      double lcm_sym242__;
      double lcm_sym241__;
      double lcm_sym240__;
      double lcm_sym239__;
      double lcm_sym238__;
      double lcm_sym237__;
      double lcm_sym236__;
      double lcm_sym235__;
      double lcm_sym234__;
      double lcm_sym233__;
      double lcm_sym232__;
      double lcm_sym231__;
      double lcm_sym230__;
      double lcm_sym229__;
      int lcm_sym228__;
      int lcm_sym227__;
      int lcm_sym226__;
      int lcm_sym225__;
      int lcm_sym224__;
      int lcm_sym223__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym222__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym221__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym220__;
      int lcm_sym268__;
      int lcm_sym218__;
      int lcm_sym217__;
      int lcm_sym216__;
      int lcm_sym215__;
      int lcm_sym214__;
      int lcm_sym213__;
      int lcm_sym212__;
      int lcm_sym211__;
      int lcm_sym210__;
      int lcm_sym209__;
      int lcm_sym208__;
      int lcm_sym207__;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                   0, 1, lp__);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                 0, 1, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> gamma;
      current_statement__ = 3;
      gamma = in__.template read_constrain_lub<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                0, 1, lp__, n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon;
      lcm_sym268__ = (n_occasions - 1);
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  lcm_sym268__);
      local_scalar_t__ sigma;
      current_statement__ = 5;
      sigma = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 5, lp__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, lcm_sym268__);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      stan::math::fill(p, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      lcm_sym211__ = logical_gte(lcm_sym268__, 1);
      if (lcm_sym211__) {
        {
          lcm_sym209__ = logical_gte(M, 1);
          if (lcm_sym209__) {
            lcm_sym263__ = inv_logit(
                             (logit(mean_phi) +
                               rvalue(epsilon, "epsilon", index_uni(1))));
            assign(phi, lcm_sym263__,
              "assigning variable phi", index_uni(1), index_uni(1));
            for (int i = 2; i <= M; ++i) {
              current_statement__ = 9;
              assign(phi, lcm_sym263__,
                "assigning variable phi", index_uni(i), index_uni(1));
            }
          } 
          for (int t = 2; t <= lcm_sym268__; ++t) {
            current_statement__ = 10;
            if (lcm_sym209__) {
              lcm_sym262__ = inv_logit(
                               (logit(mean_phi) +
                                 rvalue(epsilon, "epsilon", index_uni(t))));
              assign(phi, lcm_sym262__,
                "assigning variable phi", index_uni(1), index_uni(t));
              for (int i = 2; i <= M; ++i) {
                current_statement__ = 9;
                assign(phi, lcm_sym262__,
                  "assigning variable phi", index_uni(i), index_uni(t));
              }
            } 
          }
        }
      } else {
        lcm_sym209__ = logical_gte(M, 1);
      }
      assign(lcm_sym266__, rep_matrix(mean_p, M, n_occasions),
        "assigning variable lcm_sym266__");
      assign(p, lcm_sym266__, "assigning variable p");
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym22__;
      int inline_sym30__;
      inline_sym30__ = 0;
      for (int inline_sym31__ = 1; inline_sym31__ <= 1; ++inline_sym31__) {
        int inline_sym23__;
        lcm_sym267__ = rows(lcm_sym266__);
        int inline_sym24__;
        lcm_sym259__ = cols(lcm_sym266__);
        current_statement__ = 13;
        validate_non_negative_index("chi", "n_ind", lcm_sym267__);
        current_statement__ = 14;
        validate_non_negative_index("chi", "n_occasions", lcm_sym259__);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym25__;
        inline_sym25__ = Eigen::Matrix<local_scalar_t__, -1, -1>(lcm_sym267__, lcm_sym259__);
        stan::math::fill(inline_sym25__, DUMMY_VAR__);
        
        for (int inline_sym29__ = 1; inline_sym29__ <= lcm_sym267__;
             ++inline_sym29__) {
          current_statement__ = 16;
          assign(inline_sym25__, 1.0,
            "assigning variable inline_sym25__", index_uni(inline_sym29__),
                                                   index_uni(lcm_sym259__));
          lcm_sym224__ = (lcm_sym259__ - 1);
          if (logical_gte(lcm_sym224__, 1)) {
            int inline_sym26__;
            int inline_sym27__;
            lcm_sym228__ = (lcm_sym224__ + 1);
            current_statement__ = 19;
            assign(inline_sym25__,
              stan::math::fma(
                (rvalue(phi, "phi",
                   index_uni(inline_sym29__), index_uni(lcm_sym224__)) *
                  (1 -
                    rvalue(lcm_sym266__, "lcm_sym266__",
                      index_uni(inline_sym29__), index_uni(lcm_sym228__)))),
                rvalue(inline_sym25__, "inline_sym25__",
                  index_uni(inline_sym29__), index_uni(lcm_sym228__)),
                (1 -
                  rvalue(phi, "phi",
                    index_uni(inline_sym29__), index_uni(lcm_sym224__)))),
              "assigning variable inline_sym25__", index_uni(inline_sym29__),
                                                     index_uni(lcm_sym224__));
            for (int inline_sym28__ = 2; inline_sym28__ <= lcm_sym224__;
                 ++inline_sym28__) {
              int inline_sym26__;
              lcm_sym223__ = (lcm_sym259__ - inline_sym28__);
              int inline_sym27__;
              lcm_sym227__ = (lcm_sym223__ + 1);
              current_statement__ = 19;
              assign(inline_sym25__,
                stan::math::fma(
                  (rvalue(phi, "phi",
                     index_uni(inline_sym29__), index_uni(lcm_sym223__)) *
                    (1 -
                      rvalue(lcm_sym266__, "lcm_sym266__",
                        index_uni(inline_sym29__), index_uni(lcm_sym227__)))),
                  rvalue(inline_sym25__, "inline_sym25__",
                    index_uni(inline_sym29__), index_uni(lcm_sym227__)),
                  (1 -
                    rvalue(phi, "phi",
                      index_uni(inline_sym29__), index_uni(lcm_sym223__)))),
                "assigning variable inline_sym25__", index_uni(inline_sym29__),
                                                       index_uni(lcm_sym223__));
            }
          } 
          if (inline_sym30__) {
            break;
          } 
        }
        if (inline_sym30__) {
          break;
        } 
        inline_sym30__ = 1;
        assign(inline_sym22__, inline_sym25__,
          "assigning variable inline_sym22__");
        break;
      }
      assign(chi, inline_sym22__, "assigning variable chi");
      current_statement__ = 6;
      if (lcm_sym209__) {
        current_statement__ = 6;
        if (lcm_sym211__) {
          current_statement__ = 6;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi, "phi",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym268__; ++sym2__) {
            current_statement__ = 6;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 6;
          if (lcm_sym211__) {
            current_statement__ = 6;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym268__; ++sym2__) {
              current_statement__ = 6;
              check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                     rvalue(phi, "phi",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 6;
      if (lcm_sym209__) {
        current_statement__ = 6;
        if (lcm_sym211__) {
          current_statement__ = 6;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi, "phi", index_uni(1), index_uni(1)),
                              1);
          for (int sym2__ = 2; sym2__ <= lcm_sym268__; ++sym2__) {
            current_statement__ = 6;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 6;
          if (lcm_sym211__) {
            current_statement__ = 6;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym268__; ++sym2__) {
              current_statement__ = 6;
              check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                  rvalue(phi, "phi",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 7;
      if (lcm_sym209__) {
        lcm_sym210__ = logical_gte(n_occasions, 1);
        if (lcm_sym210__) {
          current_statement__ = 7;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(lcm_sym266__, "lcm_sym266__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 7;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(lcm_sym266__, "lcm_sym266__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym210__) {
            current_statement__ = 7;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(lcm_sym266__, "lcm_sym266__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 7;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(lcm_sym266__, "lcm_sym266__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 7;
      if (lcm_sym209__) {
        lcm_sym210__ = logical_gte(n_occasions, 1);
        if (lcm_sym210__) {
          current_statement__ = 7;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(lcm_sym266__, "lcm_sym266__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 7;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(lcm_sym266__, "lcm_sym266__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym210__) {
            current_statement__ = 7;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(lcm_sym266__, "lcm_sym266__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 7;
              check_less_or_equal(function__, "p[sym1__, sym2__]",
                                  rvalue(lcm_sym266__, "lcm_sym266__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 8;
      if (lcm_sym209__) {
        lcm_sym210__ = logical_gte(n_occasions, 1);
        if (lcm_sym210__) {
          current_statement__ = 8;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(inline_sym22__, "inline_sym22__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 8;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym22__, "inline_sym22__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 8;
          if (lcm_sym210__) {
            current_statement__ = 8;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym22__, "inline_sym22__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 8;
              check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                     rvalue(inline_sym22__, "inline_sym22__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 8;
      if (lcm_sym209__) {
        lcm_sym210__ = logical_gte(n_occasions, 1);
        if (lcm_sym210__) {
          current_statement__ = 8;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(inline_sym22__, "inline_sym22__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 8;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym22__, "inline_sym22__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 8;
          if (lcm_sym210__) {
            current_statement__ = 8;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym22__, "inline_sym22__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 8;
              check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                  rvalue(inline_sym22__, "inline_sym22__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      {
        current_statement__ = 74;
        lp_accum__.add(normal_lpdf<propto__>(epsilon, 0, sigma));
        int inline_sym39__;
        inline_sym39__ = std::numeric_limits<int>::min();
        
        {
          int inline_sym32__;
          lcm_sym281__ = rvalue(dims(y), "dims(y)", index_uni(1));
          int inline_sym33__;
          lcm_sym282__ = rvalue(dims(y), "dims(y)", index_uni(2));
          current_statement__ = 77;
          validate_non_negative_index("qgamma", "n_occasions", lcm_sym282__);
          Eigen::Matrix<double, -1, 1> inline_sym34__;
          assign(lcm_sym220__, subtract(1.0, gamma),
            "assigning variable lcm_sym220__");
          lcm_sym217__ = logical_gte(lcm_sym281__, 1);
          if (lcm_sym217__) {
            current_statement__ = 79;
            validate_non_negative_index("qp", "n_occasions", lcm_sym282__);
            Eigen::Matrix<double, -1, 1> inline_sym35__;
            assign(lcm_sym222__,
              subtract(1.0,
                transpose(rvalue(lcm_sym266__, "lcm_sym266__", index_uni(1)))),
              "assigning variable lcm_sym222__");
            lcm_sym270__ = rvalue(first, "first", index_uni(1));
            if (lcm_sym270__) {
              current_statement__ = 95;
              if (logical_eq(lcm_sym270__, 1)) {
                current_statement__ = 93;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    (rvalue(gamma, "gamma", index_uni(1)) *
                      rvalue(lcm_sym266__, "lcm_sym266__",
                        index_uni(1), index_uni(1)))));
              } else {
                current_statement__ = 87;
                validate_non_negative_index("lp", "first[i]", lcm_sym270__);
                Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym36__;
                inline_sym36__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym270__);
                stan::math::fill(inline_sym36__, DUMMY_VAR__);
                
                lcm_sym226__ = (lcm_sym270__ - 1);
                assign(inline_sym36__,
                  (((bernoulli_lpmf<false>(1,
                       rvalue(gamma, "gamma", index_uni(1))) +
                      bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym222__, "lcm_sym222__",
                            index_min_max(1, lcm_sym226__))))) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(phi, "phi",
                           index_uni(1), index_min_max(1, lcm_sym226__))))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(lcm_sym266__, "lcm_sym266__",
                        index_uni(1), index_uni(lcm_sym270__)))),
                  "assigning variable inline_sym36__", index_uni(1));
                if (logical_gte(lcm_sym226__, 2)) {
                  current_statement__ = 89;
                  assign(inline_sym36__,
                    ((((bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym220__, "lcm_sym220__",
                              index_min_max(1, 1)))) +
                         bernoulli_lpmf<false>(1,
                           rvalue(gamma, "gamma", index_uni(2)))) +
                        bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym222__, "lcm_sym222__",
                              index_min_max(2, lcm_sym226__))))) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(phi, "phi",
                             index_uni(1), index_min_max(2, lcm_sym226__)))))
                      +
                      bernoulli_lpmf<false>(1,
                        rvalue(lcm_sym266__, "lcm_sym266__",
                          index_uni(1), index_uni(lcm_sym270__)))),
                    "assigning variable inline_sym36__", index_uni(2));
                  for (int inline_sym37__ = 3;
                       inline_sym37__ <= lcm_sym226__; ++inline_sym37__) {
                    current_statement__ = 89;
                    assign(inline_sym36__,
                      ((((bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym220__, "lcm_sym220__",
                                index_min_max(1, (inline_sym37__ - 1))))) +
                           bernoulli_lpmf<false>(1,
                             gamma[(inline_sym37__ - 1)])) +
                          bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym222__, "lcm_sym222__",
                                index_min_max(inline_sym37__, lcm_sym226__)))))
                         +
                         bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(phi, "phi",
                               index_uni(1),
                                 index_min_max(inline_sym37__, lcm_sym226__)))))
                        +
                        bernoulli_lpmf<false>(1,
                          rvalue(lcm_sym266__, "lcm_sym266__",
                            index_uni(1), index_uni(lcm_sym270__)))),
                      "assigning variable inline_sym36__", index_uni(inline_sym37__));
                  }
                } 
                current_statement__ = 90;
                assign(inline_sym36__,
                  ((bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym220__, "lcm_sym220__",
                          index_min_max(1, lcm_sym226__)))) +
                     bernoulli_lpmf<false>(1, gamma[(lcm_sym270__ - 1)])) +
                    bernoulli_lpmf<false>(1,
                      rvalue(lcm_sym266__, "lcm_sym266__",
                        index_uni(1), index_uni(lcm_sym270__)))),
                  "assigning variable inline_sym36__", index_uni(lcm_sym270__));
                current_statement__ = 91;
                lp_accum__.add(log_sum_exp(inline_sym36__));
              }
              lcm_sym276__ = rvalue(last, "last", index_uni(1));
              if (logical_gte(lcm_sym276__, (lcm_sym270__ + 1))) {
                current_statement__ = 96;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(phi, "phi",
                      index_uni(1), index_uni(((lcm_sym270__ + 1) - 1)))));
                lcm_sym245__ = ((lcm_sym270__ + 1) + 1);
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(
                    rvalue(y, "y",
                      index_uni(1), index_uni((lcm_sym270__ + 1))),
                    rvalue(lcm_sym266__, "lcm_sym266__",
                      index_uni(1), index_uni((lcm_sym270__ + 1)))));
                for (int inline_sym37__ = lcm_sym245__;
                     inline_sym37__ <= lcm_sym276__; ++inline_sym37__) {
                  current_statement__ = 96;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(1,
                      rvalue(phi, "phi",
                        index_uni(1), index_uni((inline_sym37__ - 1)))));
                  current_statement__ = 97;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(
                      rvalue(y, "y", index_uni(1), index_uni(inline_sym37__)),
                      rvalue(lcm_sym266__, "lcm_sym266__",
                        index_uni(1), index_uni(inline_sym37__))));
                }
              } 
              current_statement__ = 99;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(inline_sym22__, "inline_sym22__",
                    index_uni(1), index_uni(lcm_sym276__))));
            } else {
              lcm_sym243__ = (lcm_sym282__ + 1);
              validate_non_negative_index("lp", "n_occasions + 1",
                                          lcm_sym243__);
              Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym36__;
              inline_sym36__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym243__);
              stan::math::fill(inline_sym36__, DUMMY_VAR__);
              
              current_statement__ = 82;
              assign(inline_sym36__,
                ((bernoulli_lpmf<false>(1,
                    rvalue(gamma, "gamma", index_uni(1))) +
                   bernoulli_lpmf<false>(0,
                     rvalue(lcm_sym266__, "lcm_sym266__",
                       index_uni(1), index_uni(1)))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(inline_sym22__, "inline_sym22__",
                      index_uni(1), index_uni(1)))),
                "assigning variable inline_sym36__", index_uni(1));
              if (logical_gte(lcm_sym282__, 2)) {
                current_statement__ = 83;
                assign(inline_sym36__,
                  (((bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(lcm_sym220__, "lcm_sym220__",
                           index_min_max(1, 1)))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(gamma, "gamma", index_uni(2)))) +
                     bernoulli_lpmf<false>(0,
                       rvalue(lcm_sym266__, "lcm_sym266__",
                         index_uni(1), index_uni(2)))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(inline_sym22__, "inline_sym22__",
                        index_uni(1), index_uni(2)))),
                  "assigning variable inline_sym36__", index_uni(2));
                for (int inline_sym37__ = 3; inline_sym37__ <= lcm_sym282__;
                     ++inline_sym37__) {
                  current_statement__ = 83;
                  assign(inline_sym36__,
                    (((bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(lcm_sym220__, "lcm_sym220__",
                             index_min_max(1, (inline_sym37__ - 1))))) +
                        bernoulli_lpmf<false>(1, gamma[(inline_sym37__ - 1)]))
                       +
                       bernoulli_lpmf<false>(0,
                         rvalue(lcm_sym266__, "lcm_sym266__",
                           index_uni(1), index_uni(inline_sym37__)))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(inline_sym22__, "inline_sym22__",
                          index_uni(1), index_uni(inline_sym37__)))),
                    "assigning variable inline_sym36__", index_uni(inline_sym37__));
                }
              } 
              current_statement__ = 84;
              assign(inline_sym36__,
                bernoulli_lpmf<false>(1, prod(lcm_sym220__)),
                "assigning variable inline_sym36__", index_uni(lcm_sym243__));
              current_statement__ = 85;
              lp_accum__.add(log_sum_exp(inline_sym36__));
            }
            for (int inline_sym38__ = 2; inline_sym38__ <= lcm_sym281__;
                 ++inline_sym38__) {
              current_statement__ = 79;
              validate_non_negative_index("qp", "n_occasions", lcm_sym282__);
              Eigen::Matrix<double, -1, 1> inline_sym35__;
              assign(lcm_sym221__,
                subtract(1.0,
                  transpose(
                    rvalue(lcm_sym266__, "lcm_sym266__",
                      index_uni(inline_sym38__)))),
                "assigning variable lcm_sym221__");
              lcm_sym269__ = first[(inline_sym38__ - 1)];
              if (lcm_sym269__) {
                current_statement__ = 95;
                if (logical_eq(lcm_sym269__, 1)) {
                  current_statement__ = 93;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(1,
                      (rvalue(gamma, "gamma", index_uni(1)) *
                        rvalue(lcm_sym266__, "lcm_sym266__",
                          index_uni(inline_sym38__), index_uni(1)))));
                } else {
                  current_statement__ = 87;
                  validate_non_negative_index("lp", "first[i]", lcm_sym269__);
                  Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym36__;
                  inline_sym36__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym269__);
                  stan::math::fill(inline_sym36__, DUMMY_VAR__);
                  
                  lcm_sym225__ = (lcm_sym269__ - 1);
                  assign(inline_sym36__,
                    (((bernoulli_lpmf<false>(1,
                         rvalue(gamma, "gamma", index_uni(1))) +
                        bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym221__, "lcm_sym221__",
                              index_min_max(1, lcm_sym225__))))) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(phi, "phi",
                             index_uni(inline_sym38__),
                               index_min_max(1, lcm_sym225__))))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(lcm_sym266__, "lcm_sym266__",
                          index_uni(inline_sym38__), index_uni(lcm_sym269__)))),
                    "assigning variable inline_sym36__", index_uni(1));
                  if (logical_gte(lcm_sym225__, 2)) {
                    current_statement__ = 89;
                    assign(inline_sym36__,
                      ((((bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym220__, "lcm_sym220__",
                                index_min_max(1, 1)))) +
                           bernoulli_lpmf<false>(1,
                             rvalue(gamma, "gamma", index_uni(2)))) +
                          bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym221__, "lcm_sym221__",
                                index_min_max(2, lcm_sym225__))))) +
                         bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(phi, "phi",
                               index_uni(inline_sym38__),
                                 index_min_max(2, lcm_sym225__))))) +
                        bernoulli_lpmf<false>(1,
                          rvalue(lcm_sym266__, "lcm_sym266__",
                            index_uni(inline_sym38__),
                              index_uni(lcm_sym269__)))),
                      "assigning variable inline_sym36__", index_uni(2));
                    for (int inline_sym37__ = 3;
                         inline_sym37__ <= lcm_sym225__; ++inline_sym37__) {
                      current_statement__ = 89;
                      assign(inline_sym36__,
                        ((((bernoulli_lpmf<false>(1,
                              prod(
                                rvalue(lcm_sym220__, "lcm_sym220__",
                                  index_min_max(1, (inline_sym37__ - 1))))) +
                             bernoulli_lpmf<false>(1,
                               gamma[(inline_sym37__ - 1)])) +
                            bernoulli_lpmf<false>(1,
                              prod(
                                rvalue(lcm_sym221__, "lcm_sym221__",
                                  index_min_max(inline_sym37__, lcm_sym225__)))))
                           +
                           bernoulli_lpmf<false>(1,
                             prod(
                               rvalue(phi, "phi",
                                 index_uni(inline_sym38__),
                                   index_min_max(inline_sym37__, lcm_sym225__)))))
                          +
                          bernoulli_lpmf<false>(1,
                            rvalue(lcm_sym266__, "lcm_sym266__",
                              index_uni(inline_sym38__),
                                index_uni(lcm_sym269__)))),
                        "assigning variable inline_sym36__", index_uni(inline_sym37__));
                    }
                  } 
                  current_statement__ = 90;
                  assign(inline_sym36__,
                    ((bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym220__, "lcm_sym220__",
                            index_min_max(1, lcm_sym225__)))) +
                       bernoulli_lpmf<false>(1, gamma[(lcm_sym269__ - 1)])) +
                      bernoulli_lpmf<false>(1,
                        rvalue(lcm_sym266__, "lcm_sym266__",
                          index_uni(inline_sym38__), index_uni(lcm_sym269__)))),
                    "assigning variable inline_sym36__", index_uni(lcm_sym269__));
                  current_statement__ = 91;
                  lp_accum__.add(log_sum_exp(inline_sym36__));
                }
                lcm_sym275__ = last[(inline_sym38__ - 1)];
                if (logical_gte(lcm_sym275__, (lcm_sym269__ + 1))) {
                  current_statement__ = 96;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(1,
                      rvalue(phi, "phi",
                        index_uni(inline_sym38__),
                          index_uni(((lcm_sym269__ + 1) - 1)))));
                  lcm_sym244__ = ((lcm_sym269__ + 1) + 1);
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(
                      rvalue(y, "y",
                        index_uni(inline_sym38__),
                          index_uni((lcm_sym269__ + 1))),
                      rvalue(lcm_sym266__, "lcm_sym266__",
                        index_uni(inline_sym38__),
                          index_uni((lcm_sym269__ + 1)))));
                  for (int inline_sym37__ = lcm_sym244__;
                       inline_sym37__ <= lcm_sym275__; ++inline_sym37__) {
                    current_statement__ = 96;
                    lp_accum__.add(
                      bernoulli_lpmf<propto__>(1,
                        rvalue(phi, "phi",
                          index_uni(inline_sym38__),
                            index_uni((inline_sym37__ - 1)))));
                    current_statement__ = 97;
                    lp_accum__.add(
                      bernoulli_lpmf<propto__>(
                        y[(inline_sym38__ - 1)][(inline_sym37__ - 1)],
                        rvalue(lcm_sym266__, "lcm_sym266__",
                          index_uni(inline_sym38__),
                            index_uni(inline_sym37__))));
                  }
                } 
                current_statement__ = 99;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(inline_sym22__, "inline_sym22__",
                      index_uni(inline_sym38__), index_uni(lcm_sym275__))));
              } else {
                lcm_sym243__ = (lcm_sym282__ + 1);
                validate_non_negative_index("lp", "n_occasions + 1",
                                            lcm_sym243__);
                Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym36__;
                inline_sym36__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym243__);
                stan::math::fill(inline_sym36__, DUMMY_VAR__);
                
                current_statement__ = 82;
                assign(inline_sym36__,
                  ((bernoulli_lpmf<false>(1,
                      rvalue(gamma, "gamma", index_uni(1))) +
                     bernoulli_lpmf<false>(0,
                       rvalue(lcm_sym266__, "lcm_sym266__",
                         index_uni(inline_sym38__), index_uni(1)))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(inline_sym22__, "inline_sym22__",
                        index_uni(inline_sym38__), index_uni(1)))),
                  "assigning variable inline_sym36__", index_uni(1));
                if (logical_gte(lcm_sym282__, 2)) {
                  current_statement__ = 83;
                  assign(inline_sym36__,
                    (((bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(lcm_sym220__, "lcm_sym220__",
                             index_min_max(1, 1)))) +
                        bernoulli_lpmf<false>(1,
                          rvalue(gamma, "gamma", index_uni(2)))) +
                       bernoulli_lpmf<false>(0,
                         rvalue(lcm_sym266__, "lcm_sym266__",
                           index_uni(inline_sym38__), index_uni(2)))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(inline_sym22__, "inline_sym22__",
                          index_uni(inline_sym38__), index_uni(2)))),
                    "assigning variable inline_sym36__", index_uni(2));
                  for (int inline_sym37__ = 3;
                       inline_sym37__ <= lcm_sym282__; ++inline_sym37__) {
                    current_statement__ = 83;
                    assign(inline_sym36__,
                      (((bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(lcm_sym220__, "lcm_sym220__",
                               index_min_max(1, (inline_sym37__ - 1))))) +
                          bernoulli_lpmf<false>(1,
                            gamma[(inline_sym37__ - 1)])) +
                         bernoulli_lpmf<false>(0,
                           rvalue(lcm_sym266__, "lcm_sym266__",
                             index_uni(inline_sym38__),
                               index_uni(inline_sym37__)))) +
                        bernoulli_lpmf<false>(1,
                          rvalue(inline_sym22__, "inline_sym22__",
                            index_uni(inline_sym38__),
                              index_uni(inline_sym37__)))),
                      "assigning variable inline_sym36__", index_uni(inline_sym37__));
                  }
                } 
                current_statement__ = 84;
                assign(inline_sym36__,
                  bernoulli_lpmf<false>(1, prod(lcm_sym220__)),
                  "assigning variable inline_sym36__", index_uni(lcm_sym243__));
                current_statement__ = 85;
                lp_accum__.add(log_sum_exp(inline_sym36__));
              }
            }
          } 
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "inlining_fail2_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym206__;
      int lcm_sym205__;
      double lcm_sym204__;
      double lcm_sym203__;
      double lcm_sym202__;
      double lcm_sym201__;
      int lcm_sym200__;
      int lcm_sym199__;
      int lcm_sym198__;
      int lcm_sym197__;
      double lcm_sym196__;
      double lcm_sym195__;
      double lcm_sym194__;
      double lcm_sym193__;
      double lcm_sym192__;
      double lcm_sym191__;
      double lcm_sym190__;
      double lcm_sym189__;
      double lcm_sym162__;
      int lcm_sym187__;
      int lcm_sym186__;
      int lcm_sym185__;
      int lcm_sym184__;
      int lcm_sym183__;
      int lcm_sym182__;
      local_scalar_t__ lcm_sym181__;
      int lcm_sym180__;
      double lcm_sym179__;
      int lcm_sym178__;
      int lcm_sym177__;
      int lcm_sym176__;
      int lcm_sym175__;
      Eigen::Matrix<double, -1, -1> lcm_sym174__;
      std::vector<std::vector<int>> lcm_sym173__;
      local_scalar_t__ lcm_sym172__;
      local_scalar_t__ lcm_sym171__;
      double lcm_sym170__;
      double lcm_sym169__;
      double lcm_sym168__;
      double lcm_sym167__;
      double lcm_sym166__;
      double lcm_sym165__;
      Eigen::Matrix<double, -1, 1> lcm_sym164__;
      int lcm_sym163__;
      int lcm_sym157__;
      int lcm_sym156__;
      int lcm_sym155__;
      int lcm_sym154__;
      double lcm_sym153__;
      double lcm_sym152__;
      int lcm_sym151__;
      int lcm_sym150__;
      double lcm_sym149__;
      double lcm_sym148__;
      int lcm_sym147__;
      int lcm_sym146__;
      int lcm_sym145__;
      int lcm_sym144__;
      int lcm_sym143__;
      int lcm_sym142__;
      int lcm_sym188__;
      int lcm_sym140__;
      int lcm_sym139__;
      int lcm_sym138__;
      int lcm_sym137__;
      int lcm_sym136__;
      int lcm_sym135__;
      int lcm_sym134__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym133__;
      double mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                   0, 1, lp__);
      double mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                 0, 1, lp__);
      Eigen::Matrix<double, -1, 1> gamma;
      current_statement__ = 3;
      gamma = in__.template read_constrain_lub<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                0, 1, lp__, n_occasions);
      Eigen::Matrix<double, -1, 1> epsilon;
      lcm_sym188__ = (n_occasions - 1);
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  lcm_sym188__);
      double sigma;
      current_statement__ = 5;
      sigma = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 5, lp__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, lcm_sym188__);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(M, n_occasions);
      stan::math::fill(p, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      out__.write(mean_phi);
      out__.write(mean_p);
      out__.write(gamma);
      out__.write(epsilon);
      out__.write(sigma);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym137__ = logical_gte(lcm_sym188__, 1);
      if (lcm_sym137__) {
        {
          lcm_sym134__ = logical_gte(M, 1);
          if (lcm_sym134__) {
            lcm_sym172__ = inv_logit(
                             (logit(mean_phi) +
                               rvalue(epsilon, "epsilon", index_uni(1))));
            assign(phi, lcm_sym172__,
              "assigning variable phi", index_uni(1), index_uni(1));
            for (int i = 2; i <= M; ++i) {
              current_statement__ = 9;
              assign(phi, lcm_sym172__,
                "assigning variable phi", index_uni(i), index_uni(1));
            }
          } 
          for (int t = 2; t <= lcm_sym188__; ++t) {
            current_statement__ = 10;
            if (lcm_sym134__) {
              lcm_sym171__ = inv_logit(
                               (logit(mean_phi) +
                                 rvalue(epsilon, "epsilon", index_uni(t))));
              assign(phi, lcm_sym171__,
                "assigning variable phi", index_uni(1), index_uni(t));
              for (int i = 2; i <= M; ++i) {
                current_statement__ = 9;
                assign(phi, lcm_sym171__,
                  "assigning variable phi", index_uni(i), index_uni(t));
              }
            } 
          }
        }
      } else {
        lcm_sym134__ = logical_gte(M, 1);
      }
      assign(lcm_sym174__, rep_matrix(mean_p, M, n_occasions),
        "assigning variable lcm_sym174__");
      assign(p, lcm_sym174__, "assigning variable p");
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym1__;
      int inline_sym9__;
      inline_sym9__ = 0;
      for (int inline_sym10__ = 1; inline_sym10__ <= 1; ++inline_sym10__) {
        int inline_sym2__;
        lcm_sym176__ = rows(lcm_sym174__);
        int inline_sym3__;
        lcm_sym163__ = cols(lcm_sym174__);
        current_statement__ = 13;
        validate_non_negative_index("chi", "n_ind", lcm_sym176__);
        current_statement__ = 14;
        validate_non_negative_index("chi", "n_occasions", lcm_sym163__);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym4__;
        inline_sym4__ = Eigen::Matrix<local_scalar_t__, -1, -1>(lcm_sym176__, lcm_sym163__);
        stan::math::fill(inline_sym4__, DUMMY_VAR__);
        
        for (int inline_sym8__ = 1; inline_sym8__ <= lcm_sym176__;
             ++inline_sym8__) {
          current_statement__ = 16;
          assign(inline_sym4__, 1.0,
            "assigning variable inline_sym4__", index_uni(inline_sym8__),
                                                  index_uni(lcm_sym163__));
          lcm_sym145__ = (lcm_sym163__ - 1);
          if (logical_gte(lcm_sym145__, 1)) {
            int inline_sym5__;
            int inline_sym6__;
            lcm_sym151__ = (lcm_sym145__ + 1);
            current_statement__ = 19;
            assign(inline_sym4__,
              stan::math::fma(
                (rvalue(phi, "phi",
                   index_uni(inline_sym8__), index_uni(lcm_sym145__)) *
                  (1 -
                    rvalue(lcm_sym174__, "lcm_sym174__",
                      index_uni(inline_sym8__), index_uni(lcm_sym151__)))),
                rvalue(inline_sym4__, "inline_sym4__",
                  index_uni(inline_sym8__), index_uni(lcm_sym151__)),
                (1 -
                  rvalue(phi, "phi",
                    index_uni(inline_sym8__), index_uni(lcm_sym145__)))),
              "assigning variable inline_sym4__", index_uni(inline_sym8__),
                                                    index_uni(lcm_sym145__));
            for (int inline_sym7__ = 2; inline_sym7__ <= lcm_sym145__;
                 ++inline_sym7__) {
              int inline_sym5__;
              lcm_sym144__ = (lcm_sym163__ - inline_sym7__);
              int inline_sym6__;
              lcm_sym150__ = (lcm_sym144__ + 1);
              current_statement__ = 19;
              assign(inline_sym4__,
                stan::math::fma(
                  (rvalue(phi, "phi",
                     index_uni(inline_sym8__), index_uni(lcm_sym144__)) *
                    (1 -
                      rvalue(lcm_sym174__, "lcm_sym174__",
                        index_uni(inline_sym8__), index_uni(lcm_sym150__)))),
                  rvalue(inline_sym4__, "inline_sym4__",
                    index_uni(inline_sym8__), index_uni(lcm_sym150__)),
                  (1 -
                    rvalue(phi, "phi",
                      index_uni(inline_sym8__), index_uni(lcm_sym144__)))),
                "assigning variable inline_sym4__", index_uni(inline_sym8__),
                                                      index_uni(lcm_sym144__));
            }
          } 
          if (inline_sym9__) {
            break;
          } 
        }
        if (inline_sym9__) {
          break;
        } 
        inline_sym9__ = 1;
        assign(inline_sym1__, inline_sym4__,
          "assigning variable inline_sym1__");
        break;
      }
      assign(chi, inline_sym1__, "assigning variable chi");
      current_statement__ = 6;
      if (lcm_sym134__) {
        current_statement__ = 6;
        if (lcm_sym137__) {
          current_statement__ = 6;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi, "phi",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym188__; ++sym2__) {
            current_statement__ = 6;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 6;
          if (lcm_sym137__) {
            current_statement__ = 6;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym188__; ++sym2__) {
              current_statement__ = 6;
              check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                     rvalue(phi, "phi",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 6;
      if (lcm_sym134__) {
        current_statement__ = 6;
        if (lcm_sym137__) {
          current_statement__ = 6;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi, "phi", index_uni(1), index_uni(1)),
                              1);
          for (int sym2__ = 2; sym2__ <= lcm_sym188__; ++sym2__) {
            current_statement__ = 6;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 6;
          if (lcm_sym137__) {
            current_statement__ = 6;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym188__; ++sym2__) {
              current_statement__ = 6;
              check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                  rvalue(phi, "phi",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 7;
      if (lcm_sym134__) {
        {
          lcm_sym135__ = logical_gte(n_occasions, 1);
          if (lcm_sym135__) {
            current_statement__ = 7;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(lcm_sym174__, "lcm_sym174__",
                                     index_uni(1), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 7;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(lcm_sym174__, "lcm_sym174__",
                                       index_uni(1), index_uni(sym2__)), 0);
            }
          } 
          for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
            current_statement__ = 7;
            if (lcm_sym135__) {
              current_statement__ = 7;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(lcm_sym174__, "lcm_sym174__",
                                       index_uni(sym1__), index_uni(1)), 0);
              for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
                current_statement__ = 7;
                check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                       rvalue(lcm_sym174__, "lcm_sym174__",
                                         index_uni(sym1__), index_uni(sym2__)),
                                       0);
              }
            } 
          }
        }
      } else {
        lcm_sym135__ = logical_gte(n_occasions, 1);
      }
      current_statement__ = 7;
      if (lcm_sym134__) {
        current_statement__ = 7;
        if (lcm_sym135__) {
          current_statement__ = 7;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(lcm_sym174__, "lcm_sym174__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 7;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(lcm_sym174__, "lcm_sym174__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym135__) {
            current_statement__ = 7;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(lcm_sym174__, "lcm_sym174__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 7;
              check_less_or_equal(function__, "p[sym1__, sym2__]",
                                  rvalue(lcm_sym174__, "lcm_sym174__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 8;
      if (lcm_sym134__) {
        current_statement__ = 8;
        if (lcm_sym135__) {
          current_statement__ = 8;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(inline_sym1__, "inline_sym1__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 8;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym1__, "inline_sym1__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 8;
          if (lcm_sym135__) {
            current_statement__ = 8;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym1__, "inline_sym1__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 8;
              check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                     rvalue(inline_sym1__, "inline_sym1__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 8;
      if (lcm_sym134__) {
        current_statement__ = 8;
        if (lcm_sym135__) {
          current_statement__ = 8;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(inline_sym1__, "inline_sym1__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 8;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym1__, "inline_sym1__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 8;
          if (lcm_sym135__) {
            current_statement__ = 8;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym1__, "inline_sym1__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 8;
              check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                  rvalue(inline_sym1__, "inline_sym1__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(lcm_sym174__);
        out__.write(inline_sym1__);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double sigma2;
      sigma2 = std::numeric_limits<double>::quiet_NaN();
      
      local_scalar_t__ psi;
      psi = DUMMY_VAR__;
      
      Eigen::Matrix<local_scalar_t__, -1, 1> b;
      b = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(b, DUMMY_VAR__);
      
      int Nsuper;
      Nsuper = std::numeric_limits<int>::min();
      
      std::vector<int> N;
      N = std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      
      std::vector<int> B;
      B = std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      
      std::vector<std::vector<int>> z;
      z = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      current_statement__ = 38;
      if (lcm_sym134__) {
        int q;
        double mu2;
        mu2 = std::numeric_limits<double>::quiet_NaN();
        
        lcm_sym162__ = rvalue(gamma, "gamma", index_uni(1));
        assign(z, bernoulli_rng(lcm_sym162__, base_rng__),
          "assigning variable z", index_uni(1), index_uni(1));
        lcm_sym136__ = logical_gte(n_occasions, 2);
        if (lcm_sym136__) {
          lcm_sym200__ = rvalue(z, "z", index_uni(1), index_uni(1));
          lcm_sym157__ = (1 * (1 - lcm_sym200__));
          q = lcm_sym157__;
          lcm_sym196__ = rvalue(phi, "phi", index_uni(1), index_uni(1));
          lcm_sym169__ = stan::math::fma(lcm_sym196__, lcm_sym200__,
                           (rvalue(gamma, "gamma", index_uni(2)) *
                             lcm_sym157__));
          current_statement__ = 32;
          assign(z, bernoulli_rng(lcm_sym169__, base_rng__),
            "assigning variable z", index_uni(1), index_uni(2));
          for (int t = 3; t <= n_occasions; ++t) {
            current_statement__ = 33;
            q = (q * (1 - rvalue(z, "z", index_uni(1), index_uni((t - 1)))));
            lcm_sym170__ = stan::math::fma(
                             rvalue(phi, "phi",
                               index_uni(1), index_uni((t - 1))),
                             rvalue(z, "z", index_uni(1), index_uni((t - 1))),
                             (rvalue(gamma, "gamma", index_uni(t)) * q));
            current_statement__ = 32;
            assign(z, bernoulli_rng(lcm_sym170__, base_rng__),
              "assigning variable z", index_uni(1), index_uni(t));
          }
        } 
        for (int i = 2; i <= M; ++i) {
          int q;
          double mu2;
          mu2 = std::numeric_limits<double>::quiet_NaN();
          
          current_statement__ = 35;
          assign(z, bernoulli_rng(lcm_sym162__, base_rng__),
            "assigning variable z", index_uni(i), index_uni(1));
          current_statement__ = 36;
          if (lcm_sym136__) {
            lcm_sym156__ = (1 *
                             (1 - rvalue(z, "z", index_uni(i), index_uni(1))));
            q = lcm_sym156__;
            lcm_sym167__ = stan::math::fma(
                             rvalue(phi, "phi", index_uni(i), index_uni(1)),
                             rvalue(z, "z", index_uni(i), index_uni(1)),
                             (rvalue(gamma, "gamma", index_uni(2)) *
                               lcm_sym156__));
            current_statement__ = 32;
            assign(z, bernoulli_rng(lcm_sym167__, base_rng__),
              "assigning variable z", index_uni(i), index_uni(2));
            for (int t = 3; t <= n_occasions; ++t) {
              current_statement__ = 33;
              q = (q *
                    (1 - rvalue(z, "z", index_uni(i), index_uni((t - 1)))));
              lcm_sym168__ = stan::math::fma(
                               rvalue(phi, "phi",
                                 index_uni(i), index_uni((t - 1))),
                               rvalue(z, "z",
                                 index_uni(i), index_uni((t - 1))),
                               (rvalue(gamma, "gamma", index_uni(t)) * q));
              current_statement__ = 32;
              assign(z, bernoulli_rng(lcm_sym168__, base_rng__),
                "assigning variable z", index_uni(i), index_uni(t));
            }
          } 
        }
      } 
      {
        current_statement__ = 39;
        validate_non_negative_index("cprob", "n_occasions", n_occasions);
        Eigen::Matrix<double, -1, 1> cprob;
        cprob = Eigen::Matrix<double, -1, 1>(n_occasions);
        stan::math::fill(cprob, std::numeric_limits<double>::quiet_NaN());
        
        Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym11__;
        int inline_sym16__;
        inline_sym16__ = 0;
        for (int inline_sym17__ = 1; inline_sym17__ <= 1; ++inline_sym17__) {
          int inline_sym12__;
          lcm_sym175__ = rows(gamma);
          current_statement__ = 42;
          validate_non_negative_index("log_cprob", "N", lcm_sym175__);
          Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym13__;
          inline_sym13__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym175__);
          stan::math::fill(inline_sym13__, DUMMY_VAR__);
          
          local_scalar_t__ inline_sym14__;
          if (logical_gte(lcm_sym175__, 1)) {
            current_statement__ = 45;
            assign(inline_sym13__,
              (stan::math::log(rvalue(gamma, "gamma", index_uni(1))) + 0),
              "assigning variable inline_sym13__", index_uni(1));
            current_statement__ = 46;
            inline_sym14__ = (0 +
                               log1m(rvalue(gamma, "gamma", index_uni(1))));
            for (int inline_sym15__ = 2; inline_sym15__ <= lcm_sym175__;
                 ++inline_sym15__) {
              current_statement__ = 45;
              assign(inline_sym13__,
                (stan::math::log(gamma[(inline_sym15__ - 1)]) +
                  inline_sym14__),
                "assigning variable inline_sym13__", index_uni(inline_sym15__));
              current_statement__ = 46;
              inline_sym14__ = (inline_sym14__ +
                                 log1m(gamma[(inline_sym15__ - 1)]));
            }
          } 
          if (inline_sym16__) {
            break;
          } 
          inline_sym16__ = 1;
          assign(inline_sym11__, stan::math::exp(inline_sym13__),
            "assigning variable inline_sym11__");
          break;
        }
        current_statement__ = 49;
        validate_non_negative_index("recruit", "M", M);
        current_statement__ = 50;
        validate_non_negative_index("recruit", "n_occasions", n_occasions);
        std::vector<std::vector<int>> recruit;
        current_statement__ = 51;
        assign(recruit, rep_array(0, M, n_occasions),
          "assigning variable recruit");
        current_statement__ = 52;
        validate_non_negative_index("Nind", "M", M);
        std::vector<int> Nind;
        Nind = std::vector<int>(M, std::numeric_limits<int>::min());
        
        current_statement__ = 54;
        validate_non_negative_index("Nalive", "M", M);
        std::vector<int> Nalive;
        Nalive = std::vector<int>(M, std::numeric_limits<int>::min());
        
        lcm_sym179__ = square(sigma);
        sigma2 = lcm_sym179__;
        lcm_sym181__ = sum(inline_sym11__);
        psi = lcm_sym181__;
        assign(lcm_sym133__, divide(inline_sym11__, lcm_sym181__),
          "assigning variable lcm_sym133__");
        assign(b, lcm_sym133__, "assigning variable b");
        current_statement__ = 63;
        if (lcm_sym134__) {
          int f;
          f = std::numeric_limits<int>::min();
          
          int inline_sym18__;
          int inline_sym20__;
          inline_sym20__ = 0;
          for (int inline_sym21__ = 1; inline_sym21__ <= 1; ++inline_sym21__) {
            lcm_sym178__ = size(rvalue(z, "z", index_uni(1)));
            for (int inline_sym19__ = 1; inline_sym19__ <= lcm_sym178__;
                 ++inline_sym19__) {
              current_statement__ = 58;
              if (rvalue(z, "z", index_uni(1), index_uni(inline_sym19__))) {
                inline_sym20__ = 1;
                inline_sym18__ = inline_sym19__;
                break;
              } 
            }
            if (inline_sym20__) {
              break;
            } 
            inline_sym20__ = 1;
            inline_sym18__ = 0;
            break;
          }
          current_statement__ = 61;
          if (logical_gt(inline_sym18__, 0)) {
            current_statement__ = 60;
            assign(recruit, 1,
              "assigning variable recruit", index_uni(1),
                                              index_uni(inline_sym18__));
          } 
          for (int i = 2; i <= M; ++i) {
            int f;
            f = std::numeric_limits<int>::min();
            
            int inline_sym18__;
            int inline_sym20__;
            inline_sym20__ = 0;
            for (int inline_sym21__ = 1; inline_sym21__ <= 1;
                 ++inline_sym21__) {
              lcm_sym177__ = size(rvalue(z, "z", index_uni(i)));
              for (int inline_sym19__ = 1; inline_sym19__ <= lcm_sym177__;
                   ++inline_sym19__) {
                current_statement__ = 58;
                if (rvalue(z, "z", index_uni(i), index_uni(inline_sym19__))) {
                  inline_sym20__ = 1;
                  inline_sym18__ = inline_sym19__;
                  break;
                } 
              }
              if (inline_sym20__) {
                break;
              } 
              inline_sym20__ = 1;
              inline_sym18__ = 0;
              break;
            }
            current_statement__ = 61;
            if (logical_gt(inline_sym18__, 0)) {
              current_statement__ = 60;
              assign(recruit, 1,
                "assigning variable recruit", index_uni(i),
                                                index_uni(inline_sym18__));
            } 
          }
        } 
        current_statement__ = 67;
        if (lcm_sym135__) {
          current_statement__ = 64;
          assign(N, sum(rvalue(z, "z", index_omni(), index_uni(1))),
            "assigning variable N", index_uni(1));
          current_statement__ = 65;
          assign(B,
            sum(rvalue(recruit, "recruit", index_omni(), index_uni(1))),
            "assigning variable B", index_uni(1));
          for (int t = 2; t <= n_occasions; ++t) {
            current_statement__ = 64;
            assign(N, sum(rvalue(z, "z", index_omni(), index_uni(t))),
              "assigning variable N", index_uni(t));
            current_statement__ = 65;
            assign(B,
              sum(rvalue(recruit, "recruit", index_omni(), index_uni(t))),
              "assigning variable B", index_uni(t));
          }
        } 
        current_statement__ = 71;
        if (lcm_sym134__) {
          current_statement__ = 68;
          assign(Nind, sum(rvalue(z, "z", index_uni(1))),
            "assigning variable Nind", index_uni(1));
          current_statement__ = 69;
          assign(Nalive,
            (1 - logical_negation(rvalue(Nind, "Nind", index_uni(1)))),
            "assigning variable Nalive", index_uni(1));
          for (int i = 2; i <= M; ++i) {
            current_statement__ = 68;
            assign(Nind, sum(rvalue(z, "z", index_uni(i))),
              "assigning variable Nind", index_uni(i));
            current_statement__ = 69;
            assign(Nalive,
              (1 - logical_negation(rvalue(Nind, "Nind", index_uni(i)))),
              "assigning variable Nalive", index_uni(i));
          }
        } 
        current_statement__ = 72;
        Nsuper = sum(Nalive);
      }
      out__.write(lcm_sym179__);
      out__.write(lcm_sym181__);
      out__.write(lcm_sym133__);
      out__.write(Nsuper);
      out__.write(N);
      out__.write(B);
      if (lcm_sym135__) {
        if (lcm_sym134__) {
          out__.write(rvalue(z, "z", index_uni(1), index_uni(1)));
          for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
            out__.write(rvalue(z, "z", index_uni(sym2__), index_uni(1)));
          }
        } 
        for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym134__) {
            out__.write(rvalue(z, "z", index_uni(1), index_uni(sym1__)));
            for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
              out__.write(z[(sym2__ - 1)][(sym1__ - 1)]);
            }
          } 
        }
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym132__;
      int lcm_sym130__;
      int lcm_sym129__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ mean_phi;
      mean_phi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__, -1, 1> gamma;
      gamma = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(gamma, DUMMY_VAR__);
      
      if (logical_gte(n_occasions, 1)) {
        assign(gamma, in__.read<local_scalar_t__>(),
          "assigning variable gamma", index_uni(1));
        for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          assign(gamma, in__.read<local_scalar_t__>(),
            "assigning variable gamma", index_uni(sym1__));
        }
      } 
      out__.write_free_lub(0, 1, gamma);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon;
      epsilon = Eigen::Matrix<local_scalar_t__, -1, 1>((n_occasions - 1));
      stan::math::fill(epsilon, DUMMY_VAR__);
      
      lcm_sym132__ = (n_occasions - 1);
      if (logical_gte(lcm_sym132__, 1)) {
        assign(epsilon, in__.read<local_scalar_t__>(),
          "assigning variable epsilon", index_uni(1));
        for (int sym1__ = 2; sym1__ <= lcm_sym132__; ++sym1__) {
          assign(epsilon, in__.read<local_scalar_t__>(),
            "assigning variable epsilon", index_uni(sym1__));
        }
      } 
      out__.write(epsilon);
      local_scalar_t__ sigma;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 5, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mean_phi", "mean_p", "gamma",
      "epsilon", "sigma", "phi", "p", "chi", "sigma2", "psi", "b", "Nsuper",
      "N", "B", "z"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(epsilon_1dim__)},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(phi_2dim__)},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(n_occasions)},
      std::vector<size_t>{}, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(n_occasions)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
      {
        param_names__.emplace_back(std::string() + "gamma" + '.' + std::to_string(sym311__));
      } 
    }
    for (int sym311__ = 1; sym311__ <= epsilon_1dim__; ++sym311__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym311__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym311__ = 1; sym311__ <= phi_2dim__; ++sym311__) {
        {
          for (int sym312__ = 1; sym312__ <= M; ++sym312__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym312__) + '.' + std::to_string(sym311__));
            } 
          }
        } 
      }
      for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
        {
          for (int sym312__ = 1; sym312__ <= M; ++sym312__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym312__) + '.' + std::to_string(sym311__));
            } 
          }
        } 
      }
      for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
        {
          for (int sym312__ = 1; sym312__ <= M; ++sym312__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym312__) + '.' + std::to_string(sym311__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "psi");
      for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym311__));
        } 
      }
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
        {
          param_names__.emplace_back(std::string() + "N" + '.' + std::to_string(sym311__));
        } 
      }
      for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
        {
          param_names__.emplace_back(std::string() + "B" + '.' + std::to_string(sym311__));
        } 
      }
      for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
        {
          for (int sym312__ = 1; sym312__ <= M; ++sym312__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym312__) + '.' + std::to_string(sym311__));
            } 
          }
        } 
      }
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
      {
        param_names__.emplace_back(std::string() + "gamma" + '.' + std::to_string(sym311__));
      } 
    }
    for (int sym311__ = 1; sym311__ <= epsilon_1dim__; ++sym311__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym311__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym311__ = 1; sym311__ <= phi_2dim__; ++sym311__) {
        {
          for (int sym312__ = 1; sym312__ <= M; ++sym312__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym312__) + '.' + std::to_string(sym311__));
            } 
          }
        } 
      }
      for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
        {
          for (int sym312__ = 1; sym312__ <= M; ++sym312__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym312__) + '.' + std::to_string(sym311__));
            } 
          }
        } 
      }
      for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
        {
          for (int sym312__ = 1; sym312__ <= M; ++sym312__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym312__) + '.' + std::to_string(sym311__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "psi");
      for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym311__));
        } 
      }
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
        {
          param_names__.emplace_back(std::string() + "N" + '.' + std::to_string(sym311__));
        } 
      }
      for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
        {
          param_names__.emplace_back(std::string() + "B" + '.' + std::to_string(sym311__));
        } 
      }
      for (int sym311__ = 1; sym311__ <= n_occasions; ++sym311__) {
        {
          for (int sym312__ = 1; sym312__ <= M; ++sym312__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym312__) + '.' + std::to_string(sym311__));
            } 
          }
        } 
      }
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(epsilon_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(phi_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(epsilon_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(phi_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((1 + 1) + n_occasions) + epsilon_1dim__) + 1);
      const size_t num_transformed = 
  (((M * phi_2dim__) + (M * n_occasions)) + (M * n_occasions));
      const size_t num_gen_quantities = 
  ((((((1 + 1) + n_occasions) + 1) + n_occasions) + n_occasions) +
    (M * n_occasions));
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((1 + 1) + n_occasions) + epsilon_1dim__) + 1);
      const size_t num_transformed = 
  (((M * phi_2dim__) + (M * n_occasions)) + (M * n_occasions));
      const size_t num_gen_quantities = 
  ((((((1 + 1) + n_occasions) + 1) + n_occasions) + n_occasions) +
    (M * n_occasions));
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 5> names__{"mean_phi", "mean_p",
      "gamma", "epsilon", "sigma"};
      const std::array<Eigen::Index, 5> constrain_param_sizes__{1, 1,
       n_occasions, epsilon_1dim__, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = inlining_fail2_model_namespace::inlining_fail2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return inlining_fail2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp lcm-experiment.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_experiment_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 7> locations_array__ = 
{" (found before start of program)",
 " (in 'lcm-experiment.stan', line 2, column 2 to column 8)",
 " (in 'lcm-experiment.stan', line 5, column 2 to column 13)",
 " (in 'lcm-experiment.stan', line 6, column 2 to column 9)",
 " (in 'lcm-experiment.stan', line 8, column 4 to column 27)",
 " (in 'lcm-experiment.stan', line 7, column 2 to line 10, column 3)",
 " (in 'lcm-experiment.stan', line 11, column 2 to column 38)"};



class lcm_experiment_model final : public model_base_crtp<lcm_experiment_model> {

 private:
  double lcm_sym3__;
  int j;
  double z;
  double x;
  double i; 
  
 
 public:
  ~lcm_experiment_model() { }
  
  inline std::string model_name() const final { return "lcm_experiment_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  lcm_experiment_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_experiment_model_namespace::lcm_experiment_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      int pos__;
      pos__ = 1;
      current_statement__ = 1;
      context__.validate_dims("data initialization","j","int",
           std::vector<size_t>{});
      j = std::numeric_limits<int>::min();
      
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      current_statement__ = 2;
      z = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      z = 1;
      current_statement__ = 3;
      x = std::numeric_limits<double>::quiet_NaN();
      
      {
        current_statement__ = 4;
        x = normal_rng(123, 1, base_rng__);
        lcm_sym3__ = stan::math::fma(stan::math::sqrt(j), 2, 1);
        z = normal_rng(lcm_sym3__, 1, base_rng__);
      }
      current_statement__ = 6;
      i = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      i = normal_rng(lcm_sym3__, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_experiment_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_experiment_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__;
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 0> names__{};
      const std::array<Eigen::Index, 0> constrain_param_sizes__{};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = lcm_experiment_model_namespace::lcm_experiment_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lcm_experiment_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp lcm-experiment2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_experiment2_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 8> locations_array__ = 
{" (found before start of program)",
 " (in 'lcm-experiment2.stan', line 2, column 2 to column 9)",
 " (in 'lcm-experiment2.stan', line 5, column 2 to column 18)",
 " (in 'lcm-experiment2.stan', line 7, column 4 to column 11)",
 " (in 'lcm-experiment2.stan', line 6, column 2 to line 8, column 3)",
 " (in 'lcm-experiment2.stan', line 10, column 4 to column 11)",
 " (in 'lcm-experiment2.stan', line 9, column 2 to line 10, column 11)",
 " (in 'lcm-experiment2.stan', line 11, column 2 to column 14)"};



class lcm_experiment2_model final : public model_base_crtp<lcm_experiment2_model> {

 private:
   
  
 
 public:
  ~lcm_experiment2_model() { }
  
  inline std::string model_name() const final { return "lcm_experiment2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  lcm_experiment2_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_experiment2_model_namespace::lcm_experiment2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_experiment2_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      local_scalar_t__ x;
      current_statement__ = 1;
      x = in__.template read<local_scalar_t__>();
      {
        local_scalar_t__ y;
        lcm_sym5__ = stan::math::log(x);
        {
          current_statement__ = 3;
          y = (lcm_sym5__ + 1);
        }
        {
          current_statement__ = 5;
          y = (y + 1);
        }
        current_statement__ = 7;
        lp_accum__.add(y);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_experiment2_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      double x;
      current_statement__ = 1;
      x = in__.template read<local_scalar_t__>();
      out__.write(x);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__;
      pos__ = 1;
      local_scalar_t__ x;
      x = in__.read<local_scalar_t__>();
      out__.write(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"x"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 1;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 1;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 1> names__{"x"};
      const std::array<Eigen::Index, 1> constrain_param_sizes__{1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = lcm_experiment2_model_namespace::lcm_experiment2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lcm_experiment2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp lcm-fails.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_fails_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 7> locations_array__ = 
{" (found before start of program)",
 " (in 'lcm-fails.stan', line 6, column 2 to column 16)",
 " (in 'lcm-fails.stan', line 9, column 2 to column 22)",
 " (in 'lcm-fails.stan', line 2, column 2 to column 17)",
 " (in 'lcm-fails.stan', line 3, column 9 to column 10)",
 " (in 'lcm-fails.stan', line 3, column 2 to column 12)",
 " (in 'lcm-fails.stan', line 6, column 13 to column 14)"};



class lcm_fails_model final : public model_base_crtp<lcm_fails_model> {

 private:
  int J;
  std::vector<double> y; 
  
 
 public:
  ~lcm_fails_model() { }
  
  inline std::string model_name() const final { return "lcm_fails_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  lcm_fails_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_fails_model_namespace::lcm_fails_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 3;
      context__.validate_dims("data initialization","J","int",
           std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      
      current_statement__ = 3;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 3;
      check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 4;
      validate_non_negative_index("y", "J", J);
      current_statement__ = 5;
      context__.validate_dims("data initialization","y","double",
           std::vector<size_t>{static_cast<size_t>(J)});
      y = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      y = context__.vals_r("y");
      current_statement__ = 6;
      validate_non_negative_index("theta", "J", J);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = J;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_fails_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym4__;
      std::vector<local_scalar_t__> theta;
      current_statement__ = 1;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      {
        current_statement__ = 2;
        lp_accum__.add(normal_lpdf<propto__>(y, theta, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_fails_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym3__;
      int lcm_sym2__;
      std::vector<double> theta;
      current_statement__ = 1;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      out__.write(theta);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      std::vector<local_scalar_t__> theta;
      theta = std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      
      if (logical_gte(J, 1)) {
        theta[(1 - 1)] = in__.read<local_scalar_t__>();
        for (int sym1__ = 2; sym1__ <= J; ++sym1__) {
          theta[(sym1__ - 1)] = in__.read<local_scalar_t__>();
        }
      } 
      out__.write(theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"theta"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(J)
                                                                   }};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym5__ = 1; sym5__ <= J; ++sym5__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym5__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym5__ = 1; sym5__ <= J; ++sym5__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym5__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = J;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = J;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 1> names__{"theta"};
      const std::array<Eigen::Index, 1> constrain_param_sizes__{J};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = lcm_fails_model_namespace::lcm_fails_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lcm_fails_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp lcm-fails2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_fails2_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 64> locations_array__ = 
{" (found before start of program)",
 " (in 'lcm-fails2.stan', line 69, column 2 to column 33)",
 " (in 'lcm-fails2.stan', line 70, column 2 to column 31)",
 " (in 'lcm-fails2.stan', line 74, column 2 to column 51)",
 " (in 'lcm-fails2.stan', line 75, column 2 to column 49)",
 " (in 'lcm-fails2.stan', line 76, column 2 to column 49)",
 " (in 'lcm-fails2.stan', line 81, column 6 to column 20)",
 " (in 'lcm-fails2.stan', line 82, column 6 to column 18)",
 " (in 'lcm-fails2.stan', line 80, column 32 to line 83, column 5)",
 " (in 'lcm-fails2.stan', line 85, column 6 to column 27)",
 " (in 'lcm-fails2.stan', line 86, column 6 to column 23)",
 " (in 'lcm-fails2.stan', line 84, column 38 to line 87, column 5)",
 " (in 'lcm-fails2.stan', line 84, column 4 to line 87, column 5)",
 " (in 'lcm-fails2.stan', line 79, column 20 to line 88, column 3)",
 " (in 'lcm-fails2.stan', line 26, column 11 to column 15)",
 " (in 'lcm-fails2.stan', line 26, column 17 to column 28)",
 " (in 'lcm-fails2.stan', line 26, column 4 to column 34)",
 " (in 'lcm-fails2.stan', line 29, column 6 to column 32)",
 " (in 'lcm-fails2.stan', line 32, column 8 to column 37)",
 " (in 'lcm-fails2.stan', line 33, column 8 to column 32)",
 " (in 'lcm-fails2.stan', line 41, column 8 to line 42, column 83)",
 " (in 'lcm-fails2.stan', line 30, column 37 to line 43, column 7)",
 " (in 'lcm-fails2.stan', line 28, column 22 to line 44, column 5)",
 " (in 'lcm-fails2.stan', line 25, column 47 to line 46, column 3)",
 " (in 'lcm-fails2.stan', line 103, column 8 to column 37)",
 " (in 'lcm-fails2.stan', line 104, column 8 to column 41)",
 " (in 'lcm-fails2.stan', line 102, column 40 to line 105, column 7)",
 " (in 'lcm-fails2.stan', line 106, column 6 to column 37)",
 " (in 'lcm-fails2.stan', line 101, column 22 to line 107, column 5)",
 " (in 'lcm-fails2.stan', line 100, column 20 to line 108, column 3)",
 " (in 'lcm-fails2.stan', line 100, column 2 to line 108, column 3)",
 " (in 'lcm-fails2.stan', line 50, column 2 to column 20)",
 " (in 'lcm-fails2.stan', line 51, column 2 to column 27)",
 " (in 'lcm-fails2.stan', line 52, column 25 to column 29)",
 " (in 'lcm-fails2.stan', line 52, column 31 to column 42)",
 " (in 'lcm-fails2.stan', line 52, column 2 to column 44)",
 " (in 'lcm-fails2.stan', line 56, column 2 to column 38)",
 " (in 'lcm-fails2.stan', line 58, column 39 to column 43)",
 " (in 'lcm-fails2.stan', line 58, column 2 to column 45)",
 " (in 'lcm-fails2.stan', line 59, column 38 to column 42)",
 " (in 'lcm-fails2.stan', line 59, column 2 to column 44)",
 " (in 'lcm-fails2.stan', line 8, column 8 to column 17)",
 " (in 'lcm-fails2.stan', line 7, column 6 to line 8, column 17)",
 " (in 'lcm-fails2.stan', line 5, column 31 to line 10, column 3)",
 " (in 'lcm-fails2.stan', line 63, column 4 to column 35)",
 " (in 'lcm-fails2.stan', line 62, column 2 to line 63, column 35)",
 " (in 'lcm-fails2.stan', line 15, column 6 to column 32)",
 " (in 'lcm-fails2.stan', line 19, column 8 to column 17)",
 " (in 'lcm-fails2.stan', line 18, column 6 to line 19, column 17)",
 " (in 'lcm-fails2.stan', line 13, column 37 to line 20, column 5)",
 " (in 'lcm-fails2.stan', line 12, column 30 to line 22, column 3)",
 " (in 'lcm-fails2.stan', line 65, column 4 to column 33)",
 " (in 'lcm-fails2.stan', line 64, column 2 to line 65, column 33)",
 " (in 'lcm-fails2.stan', line 74, column 26 to column 30)",
 " (in 'lcm-fails2.stan', line 74, column 32 to column 45)",
 " (in 'lcm-fails2.stan', line 75, column 26 to column 30)",
 " (in 'lcm-fails2.stan', line 75, column 32 to column 45)",
 " (in 'lcm-fails2.stan', line 76, column 26 to column 30)",
 " (in 'lcm-fails2.stan', line 76, column 32 to column 43)",
 " (in 'lcm-fails2.stan', line 9, column 4 to column 13)",
 " (in 'lcm-fails2.stan', line 21, column 4 to column 13)",
 " (in 'lcm-fails2.stan', line 30, column 6 to line 43, column 7)",
 " (in 'lcm-fails2.stan', line 28, column 4 to line 44, column 5)",
 " (in 'lcm-fails2.stan', line 45, column 4 to column 15)"};

int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) ;

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) ;

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p,
                const T3__& phi, std::ostream* pstream__) ;

struct prob_uncaptured_functor__ {
template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
operator()(const int& nind, const int& n_occasions, const T2__& p,
           const T3__& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}
};

int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym29__;
    int lcm_sym28__;
    int lcm_sym27__;
    int lcm_sym26__;
    {
      lcm_sym27__ = size(y_i);
      if (logical_gte(lcm_sym27__, 1)) {
        current_statement__ = 42;
        if (rvalue(y_i, "y_i", index_uni(1))) {
          current_statement__ = 41;
          return 1;
        } 
        for (int k = 2; k <= lcm_sym27__; ++k) {
          current_statement__ = 42;
          if (rvalue(y_i, "y_i", index_uni(k))) {
            current_statement__ = 41;
            return k;
          } 
        }
      } 
      current_statement__ = 59;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym35__;
    int lcm_sym34__;
    int lcm_sym33__;
    int lcm_sym32__;
    int lcm_sym31__;
    int lcm_sym30__;
    {
      lcm_sym33__ = (size(y_i) - 1);
      if (logical_gte(lcm_sym33__, 0)) {
        int k;
        lcm_sym32__ = (size(y_i) - 0);
        current_statement__ = 48;
        if (y_i[(lcm_sym32__ - 1)]) {
          current_statement__ = 47;
          return lcm_sym32__;
        } 
        for (int k_rev = 1; k_rev <= lcm_sym33__; ++k_rev) {
          int k;
          lcm_sym31__ = (size(y_i) - k_rev);
          current_statement__ = 48;
          if (y_i[(lcm_sym31__ - 1)]) {
            current_statement__ = 47;
            return lcm_sym31__;
          } 
        }
      } 
      current_statement__ = 60;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  int current_statement__ = 0; 
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    double lcm_sym45__;
    double lcm_sym44__;
    double lcm_sym43__;
    double lcm_sym42__;
    int lcm_sym41__;
    int lcm_sym40__;
    int lcm_sym39__;
    int lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    {
      current_statement__ = 14;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 15;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      current_statement__ = 62;
      if (logical_gte(nind, 1)) {
        current_statement__ = 17;
        assign(chi, 1.0,
          "assigning variable chi", index_uni(1), index_uni(n_occasions));
        lcm_sym39__ = (n_occasions - 1);
        lcm_sym37__ = logical_gte(lcm_sym39__, 1);
        if (lcm_sym37__) {
          int t_curr;
          int t_next;
          lcm_sym41__ = (lcm_sym39__ + 1);
          current_statement__ = 20;
          assign(chi,
            stan::math::fma(
              (rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym39__)) *
                (1 -
                  rvalue(p, "p", index_uni(1), index_uni((lcm_sym41__ - 1))))),
              rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym41__)),
              (1 - rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym39__)))),
            "assigning variable chi", index_uni(1), index_uni(lcm_sym39__));
          for (int t = 2; t <= lcm_sym39__; ++t) {
            int t_curr;
            lcm_sym38__ = (n_occasions - t);
            int t_next;
            lcm_sym40__ = (lcm_sym38__ + 1);
            current_statement__ = 20;
            assign(chi,
              stan::math::fma(
                (rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym38__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(1), index_uni((lcm_sym40__ - 1))))),
                rvalue(chi, "chi", index_uni(1), index_uni(lcm_sym40__)),
                (1 -
                  rvalue(phi, "phi", index_uni(1), index_uni(lcm_sym38__)))),
              "assigning variable chi", index_uni(1), index_uni(lcm_sym38__));
          }
        } 
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 17;
          assign(chi, 1.0,
            "assigning variable chi", index_uni(i), index_uni(n_occasions));
          current_statement__ = 61;
          if (lcm_sym37__) {
            int t_curr;
            int t_next;
            lcm_sym41__ = (lcm_sym39__ + 1);
            current_statement__ = 20;
            assign(chi,
              stan::math::fma(
                (rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym39__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(i), index_uni((lcm_sym41__ - 1))))),
                rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym41__)),
                (1 -
                  rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym39__)))),
              "assigning variable chi", index_uni(i), index_uni(lcm_sym39__));
            for (int t = 2; t <= lcm_sym39__; ++t) {
              int t_curr;
              lcm_sym38__ = (n_occasions - t);
              int t_next;
              lcm_sym40__ = (lcm_sym38__ + 1);
              current_statement__ = 20;
              assign(chi,
                stan::math::fma(
                  (rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym38__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(i), index_uni((lcm_sym40__ - 1))))),
                  rvalue(chi, "chi", index_uni(i), index_uni(lcm_sym40__)),
                  (1 -
                    rvalue(phi, "phi", index_uni(i), index_uni(lcm_sym38__)))),
                "assigning variable chi", index_uni(i),
                                            index_uni(lcm_sym38__));
            }
          } 
        }
      } 
      current_statement__ = 63;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
class lcm_fails2_model final : public model_base_crtp<lcm_fails2_model> {

 private:
  int lcm_sym151__;
  int lcm_sym150__;
  int lcm_sym149__;
  int lcm_sym148__;
  int lcm_sym147__;
  int lcm_sym146__;
  int lcm_sym145__;
  int lcm_sym144__;
  int lcm_sym143__;
  int lcm_sym142__;
  int lcm_sym141__;
  int lcm_sym140__;
  int lcm_sym139__;
  int lcm_sym138__;
  int lcm_sym137__;
  int lcm_sym136__;
  int lcm_sym135__;
  int lcm_sym134__;
  int lcm_sym133__;
  int lcm_sym132__;
  int lcm_sym131__;
  int lcm_sym130__;
  int lcm_sym129__;
  int lcm_sym128__;
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last; 
  
 
 public:
  ~lcm_fails2_model() { }
  
  inline std::string model_name() const final { return "lcm_fails2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  lcm_fails2_model(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_fails2_model_namespace::lcm_fails2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 31;
      context__.validate_dims("data initialization","nind","int",
           std::vector<size_t>{});
      nind = std::numeric_limits<int>::min();
      
      current_statement__ = 31;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 31;
      check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 32;
      context__.validate_dims("data initialization","n_occasions","int",
           std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      
      current_statement__ = 32;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 32;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 2);
      current_statement__ = 33;
      validate_non_negative_index("y", "nind", nind);
      current_statement__ = 34;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 35;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(nind),
            static_cast<size_t>(n_occasions)});
      y = std::vector<std::vector<int>>(nind, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 35;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 35;
        pos__ = 1;
        lcm_sym128__ = logical_gte(n_occasions, 1);
        if (lcm_sym128__) {
          {
            lcm_sym129__ = logical_gte(nind, 1);
            if (lcm_sym129__) {
              current_statement__ = 35;
              assign(y, rvalue(y_flat__, "y_flat__", index_uni(1)),
                "assigning variable y", index_uni(1), index_uni(1));
              current_statement__ = 35;
              pos__ = 2;
              for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                current_statement__ = 35;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(sym2__), index_uni(1));
                current_statement__ = 35;
                pos__ = (pos__ + 1);
              }
            } 
            for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
              current_statement__ = 35;
              if (lcm_sym129__) {
                current_statement__ = 35;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(1), index_uni(sym1__));
                current_statement__ = 35;
                pos__ = (pos__ + 1);
                for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                  current_statement__ = 35;
                  assign(y, y_flat__[(pos__ - 1)],
                    "assigning variable y", index_uni(sym2__),
                                              index_uni(sym1__));
                  current_statement__ = 35;
                  pos__ = (pos__ + 1);
                }
              } 
            }
          }
        } else {
          lcm_sym129__ = logical_gte(nind, 1);
        }
      }
      current_statement__ = 35;
      if (lcm_sym129__) {
        current_statement__ = 35;
        if (lcm_sym128__) {
          current_statement__ = 35;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 rvalue(y, "y", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 35;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 35;
          if (lcm_sym128__) {
            current_statement__ = 35;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 35;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);
            }
          } 
        }
      } 
      current_statement__ = 35;
      if (lcm_sym129__) {
        current_statement__ = 35;
        if (lcm_sym128__) {
          current_statement__ = 35;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              rvalue(y, "y", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 35;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 35;
          if (lcm_sym128__) {
            current_statement__ = 35;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 35;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);
            }
          } 
        }
      } 
      current_statement__ = 36;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      
      lcm_sym130__ = (n_occasions - 1);
      n_occ_minus_1 = lcm_sym130__;
      current_statement__ = 37;
      validate_non_negative_index("first", "nind", nind);
      current_statement__ = 38;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 39;
      validate_non_negative_index("last", "nind", nind);
      current_statement__ = 40;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 45;
      if (lcm_sym129__) {
        int inline_sym17__;
        int inline_sym19__;
        inline_sym19__ = 0;
        for (int inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
          lcm_sym137__ = size(rvalue(y, "y", index_uni(1)));
          for (int inline_sym18__ = 1; inline_sym18__ <= lcm_sym137__;
               ++inline_sym18__) {
            current_statement__ = 42;
            if (rvalue(y, "y", index_uni(1))[(inline_sym18__ - 1)]) {
              inline_sym19__ = 1;
              inline_sym17__ = inline_sym18__;
              break;
            } 
          }
          if (inline_sym19__) {
            break;
          } 
          inline_sym19__ = 1;
          inline_sym17__ = 0;
          break;
        }
        assign(first, inline_sym17__,
          "assigning variable first", index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          int inline_sym17__;
          int inline_sym19__;
          inline_sym19__ = 0;
          for (int inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
            lcm_sym136__ = size(rvalue(y, "y", index_uni(i)));
            for (int inline_sym18__ = 1; inline_sym18__ <= lcm_sym136__;
                 ++inline_sym18__) {
              current_statement__ = 42;
              if (rvalue(y, "y", index_uni(i))[(inline_sym18__ - 1)]) {
                inline_sym19__ = 1;
                inline_sym17__ = inline_sym18__;
                break;
              } 
            }
            if (inline_sym19__) {
              break;
            } 
            inline_sym19__ = 1;
            inline_sym17__ = 0;
            break;
          }
          assign(first, inline_sym17__,
            "assigning variable first", index_uni(i));
        }
      } 
      current_statement__ = 52;
      if (lcm_sym129__) {
        int inline_sym21__;
        int inline_sym24__;
        inline_sym24__ = 0;
        for (int inline_sym25__ = 1; inline_sym25__ <= 1; ++inline_sym25__) {
          lcm_sym137__ = size(rvalue(y, "y", index_uni(1)));
          lcm_sym134__ = (lcm_sym137__ - 1);
          for (int inline_sym23__ = 0; inline_sym23__ <= lcm_sym134__;
               ++inline_sym23__) {
            int inline_sym22__;
            lcm_sym133__ = (lcm_sym137__ - inline_sym23__);
            inline_sym22__ = lcm_sym133__;
            current_statement__ = 48;
            if (rvalue(y, "y", index_uni(1))[(lcm_sym133__ - 1)]) {
              inline_sym24__ = 1;
              inline_sym21__ = lcm_sym133__;
              break;
            } 
          }
          if (inline_sym24__) {
            break;
          } 
          inline_sym24__ = 1;
          inline_sym21__ = 0;
          break;
        }
        assign(last, inline_sym21__, "assigning variable last", index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          int inline_sym21__;
          int inline_sym24__;
          inline_sym24__ = 0;
          for (int inline_sym25__ = 1; inline_sym25__ <= 1; ++inline_sym25__) {
            lcm_sym136__ = size(rvalue(y, "y", index_uni(i)));
            lcm_sym132__ = (lcm_sym136__ - 1);
            for (int inline_sym23__ = 0; inline_sym23__ <= lcm_sym132__;
                 ++inline_sym23__) {
              int inline_sym22__;
              lcm_sym131__ = (lcm_sym136__ - inline_sym23__);
              inline_sym22__ = lcm_sym131__;
              current_statement__ = 48;
              if (rvalue(y, "y", index_uni(i))[(lcm_sym131__ - 1)]) {
                inline_sym24__ = 1;
                inline_sym21__ = lcm_sym131__;
                break;
              } 
            }
            if (inline_sym24__) {
              break;
            } 
            inline_sym24__ = 1;
            inline_sym21__ = 0;
            break;
          }
          assign(last, inline_sym21__,
            "assigning variable last", index_uni(i));
        }
      } 
      current_statement__ = 38;
      if (lcm_sym129__) {
        current_statement__ = 38;
        check_greater_or_equal(function__, "first[sym1__]",
                               rvalue(first, "first", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 38;
          check_greater_or_equal(function__, "first[sym1__]",
                                 first[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 38;
      if (lcm_sym129__) {
        current_statement__ = 38;
        check_less_or_equal(function__, "first[sym1__]",
                            rvalue(first, "first", index_uni(1)), n_occasions);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 38;
          check_less_or_equal(function__, "first[sym1__]",
                              first[(sym1__ - 1)], n_occasions);
        }
      } 
      current_statement__ = 40;
      if (lcm_sym129__) {
        current_statement__ = 40;
        check_greater_or_equal(function__, "last[sym1__]",
                               rvalue(last, "last", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 40;
          check_greater_or_equal(function__, "last[sym1__]",
                                 last[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 40;
      if (lcm_sym129__) {
        current_statement__ = 40;
        check_less_or_equal(function__, "last[sym1__]",
                            rvalue(last, "last", index_uni(1)), n_occasions);
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 40;
          check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                              n_occasions);
        }
      } 
      current_statement__ = 53;
      validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 54;
      validate_non_negative_index("phi", "n_occ_minus_1", lcm_sym130__);
      current_statement__ = 55;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 56;
      validate_non_negative_index("p", "n_occ_minus_1", lcm_sym130__);
      current_statement__ = 57;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 58;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_fails2_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym127__;
      double lcm_sym126__;
      double lcm_sym125__;
      double lcm_sym124__;
      double lcm_sym123__;
      double lcm_sym122__;
      double lcm_sym121__;
      double lcm_sym120__;
      int lcm_sym119__;
      int lcm_sym118__;
      double lcm_sym117__;
      double lcm_sym116__;
      double lcm_sym115__;
      double lcm_sym114__;
      int lcm_sym113__;
      int lcm_sym112__;
      double lcm_sym111__;
      double lcm_sym110__;
      double lcm_sym109__;
      double lcm_sym108__;
      double lcm_sym107__;
      double lcm_sym106__;
      double lcm_sym105__;
      double lcm_sym104__;
      double lcm_sym103__;
      double lcm_sym102__;
      double lcm_sym101__;
      double lcm_sym100__;
      int lcm_sym99__;
      int lcm_sym98__;
      int lcm_sym97__;
      int lcm_sym96__;
      int lcm_sym95__;
      int lcm_sym94__;
      int lcm_sym93__;
      int lcm_sym92__;
      int lcm_sym91__;
      int lcm_sym90__;
      int lcm_sym89__;
      int lcm_sym88__;
      int lcm_sym87__;
      int lcm_sym86__;
      int lcm_sym85__;
      int lcm_sym84__;
      int lcm_sym83__;
      int lcm_sym82__;
      int lcm_sym81__;
      int lcm_sym80__;
      int lcm_sym79__;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                   0, 1, lp__);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                 0, 1, lp__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(p, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      lcm_sym80__ = logical_gte(nind, 1);
      if (lcm_sym80__) {
        lcm_sym113__ = rvalue(first, "first", index_uni(1));
        lcm_sym93__ = (lcm_sym113__ - 1);
        if (logical_gte(lcm_sym93__, 1)) {
          current_statement__ = 6;
          assign(phi, 0, "assigning variable phi", index_uni(1), index_uni(1));
          current_statement__ = 7;
          assign(p, 0, "assigning variable p", index_uni(1), index_uni(1));
          for (int t = 2; t <= lcm_sym93__; ++t) {
            current_statement__ = 6;
            assign(phi, 0,
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 7;
            assign(p, 0, "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        lcm_sym91__ = (n_occasions - 1);
        if (logical_gte(lcm_sym91__, lcm_sym113__)) {
          current_statement__ = 9;
          assign(phi, mean_phi,
            "assigning variable phi", index_uni(1), index_uni(lcm_sym113__));
          lcm_sym99__ = (lcm_sym113__ + 1);
          assign(p, mean_p,
            "assigning variable p", index_uni(1), index_uni(lcm_sym113__));
          for (int t = lcm_sym99__; t <= lcm_sym91__; ++t) {
            current_statement__ = 9;
            assign(phi, mean_phi,
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 10;
            assign(p, mean_p,
              "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        for (int i = 2; i <= nind; ++i) {
          lcm_sym112__ = rvalue(first, "first", index_uni(i));
          lcm_sym92__ = (lcm_sym112__ - 1);
          if (logical_gte(lcm_sym92__, 1)) {
            current_statement__ = 6;
            assign(phi, 0,
              "assigning variable phi", index_uni(i), index_uni(1));
            current_statement__ = 7;
            assign(p, 0, "assigning variable p", index_uni(i), index_uni(1));
            for (int t = 2; t <= lcm_sym92__; ++t) {
              current_statement__ = 6;
              assign(phi, 0,
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 7;
              assign(p, 0, "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
          current_statement__ = 12;
          if (logical_gte(lcm_sym91__, lcm_sym112__)) {
            current_statement__ = 9;
            assign(phi, mean_phi,
              "assigning variable phi", index_uni(i), index_uni(lcm_sym112__));
            lcm_sym98__ = (lcm_sym112__ + 1);
            assign(p, mean_p,
              "assigning variable p", index_uni(i), index_uni(lcm_sym112__));
            for (int t = lcm_sym98__; t <= lcm_sym91__; ++t) {
              current_statement__ = 9;
              assign(phi, mean_phi,
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 10;
              assign(p, mean_p,
                "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
        }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym9__;
      int inline_sym15__;
      inline_sym15__ = 0;
      for (int inline_sym16__ = 1; inline_sym16__ <= 1; ++inline_sym16__) {
        current_statement__ = 14;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym10__;
        inline_sym10__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        stan::math::fill(inline_sym10__, DUMMY_VAR__);
        
        for (int inline_sym14__ = 1; inline_sym14__ <= nind; ++inline_sym14__) {
          current_statement__ = 17;
          assign(inline_sym10__, 1.0,
            "assigning variable inline_sym10__", index_uni(inline_sym14__),
                                                   index_uni(n_occasions));
          lcm_sym91__ = (n_occasions - 1);
          if (logical_gte(lcm_sym91__, 1)) {
            int inline_sym11__;
            int inline_sym12__;
            lcm_sym95__ = (lcm_sym91__ + 1);
            current_statement__ = 20;
            assign(inline_sym10__,
              stan::math::fma(
                (rvalue(phi, "phi",
                   index_uni(inline_sym14__), index_uni(lcm_sym91__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(inline_sym14__), index_uni((lcm_sym95__ - 1))))),
                rvalue(inline_sym10__, "inline_sym10__",
                  index_uni(inline_sym14__), index_uni(lcm_sym95__)),
                (1 -
                  rvalue(phi, "phi",
                    index_uni(inline_sym14__), index_uni(lcm_sym91__)))),
              "assigning variable inline_sym10__", index_uni(inline_sym14__),
                                                     index_uni(lcm_sym91__));
            for (int inline_sym13__ = 2; inline_sym13__ <= lcm_sym91__;
                 ++inline_sym13__) {
              int inline_sym11__;
              lcm_sym90__ = (n_occasions - inline_sym13__);
              int inline_sym12__;
              lcm_sym94__ = (lcm_sym90__ + 1);
              current_statement__ = 20;
              assign(inline_sym10__,
                stan::math::fma(
                  (rvalue(phi, "phi",
                     index_uni(inline_sym14__), index_uni(lcm_sym90__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(inline_sym14__),
                          index_uni((lcm_sym94__ - 1))))),
                  rvalue(inline_sym10__, "inline_sym10__",
                    index_uni(inline_sym14__), index_uni(lcm_sym94__)),
                  (1 -
                    rvalue(phi, "phi",
                      index_uni(inline_sym14__), index_uni(lcm_sym90__)))),
                "assigning variable inline_sym10__", index_uni(inline_sym14__),
                                                       index_uni(lcm_sym90__));
            }
          } 
          if (inline_sym15__) {
            break;
          } 
        }
        if (inline_sym15__) {
          break;
        } 
        inline_sym15__ = 1;
        assign(inline_sym9__, inline_sym10__,
          "assigning variable inline_sym9__");
        break;
      }
      assign(chi, inline_sym9__, "assigning variable chi");
      current_statement__ = 3;
      if (lcm_sym80__) {
        lcm_sym91__ = (n_occasions - 1);
        lcm_sym81__ = logical_gte(lcm_sym91__, 1);
        if (lcm_sym81__) {
          current_statement__ = 3;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi, "phi",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym91__; ++sym2__) {
            current_statement__ = 3;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym81__) {
            current_statement__ = 3;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym91__; ++sym2__) {
              current_statement__ = 3;
              check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                     rvalue(phi, "phi",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 3;
      if (lcm_sym80__) {
        lcm_sym91__ = (n_occasions - 1);
        lcm_sym81__ = logical_gte(lcm_sym91__, 1);
        if (lcm_sym81__) {
          current_statement__ = 3;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi, "phi", index_uni(1), index_uni(1)),
                              1);
          for (int sym2__ = 2; sym2__ <= lcm_sym91__; ++sym2__) {
            current_statement__ = 3;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym81__) {
            current_statement__ = 3;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym91__; ++sym2__) {
              current_statement__ = 3;
              check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                  rvalue(phi, "phi",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 4;
      if (lcm_sym80__) {
        lcm_sym91__ = (n_occasions - 1);
        lcm_sym81__ = logical_gte(lcm_sym91__, 1);
        if (lcm_sym81__) {
          current_statement__ = 4;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p, "p", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym91__; ++sym2__) {
            current_statement__ = 4;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym81__) {
            current_statement__ = 4;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym91__; ++sym2__) {
              current_statement__ = 4;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(p, "p",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 4;
      if (lcm_sym80__) {
        lcm_sym91__ = (n_occasions - 1);
        lcm_sym81__ = logical_gte(lcm_sym91__, 1);
        if (lcm_sym81__) {
          current_statement__ = 4;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p, "p", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= lcm_sym91__; ++sym2__) {
            current_statement__ = 4;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym81__) {
            current_statement__ = 4;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym91__; ++sym2__) {
              current_statement__ = 4;
              check_less_or_equal(function__, "p[sym1__, sym2__]",
                                  rvalue(p, "p",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym80__) {
        lcm_sym79__ = logical_gte(n_occasions, 1);
        if (lcm_sym79__) {
          current_statement__ = 5;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(inline_sym9__, "inline_sym9__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym9__, "inline_sym9__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym79__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym9__, "inline_sym9__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                     rvalue(inline_sym9__, "inline_sym9__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym80__) {
        lcm_sym79__ = logical_gte(n_occasions, 1);
        if (lcm_sym79__) {
          current_statement__ = 5;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(inline_sym9__, "inline_sym9__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym9__, "inline_sym9__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym79__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym9__, "inline_sym9__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                  rvalue(inline_sym9__, "inline_sym9__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      {
        current_statement__ = 30;
        if (lcm_sym80__) {
          lcm_sym113__ = rvalue(first, "first", index_uni(1));
          if (logical_gt(lcm_sym113__, 0)) {
            lcm_sym119__ = rvalue(last, "last", index_uni(1));
            if (logical_gte(lcm_sym119__, (lcm_sym113__ + 1))) {
              current_statement__ = 24;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(phi, "phi",
                    index_uni(1), index_uni(((lcm_sym113__ + 1) - 1)))));
              lcm_sym97__ = ((lcm_sym113__ + 1) + 1);
              lp_accum__.add(
                bernoulli_lpmf<propto__>(
                  rvalue(y, "y", index_uni(1), index_uni((lcm_sym113__ + 1))),
                  rvalue(p, "p",
                    index_uni(1), index_uni(((lcm_sym113__ + 1) - 1)))));
              for (int t = lcm_sym97__; t <= lcm_sym119__; ++t) {
                current_statement__ = 24;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(phi, "phi", index_uni(1), index_uni((t - 1)))));
                current_statement__ = 25;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(
                    rvalue(y, "y", index_uni(1), index_uni(t)),
                    rvalue(p, "p", index_uni(1), index_uni((t - 1)))));
              }
            } 
            current_statement__ = 27;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                rvalue(inline_sym9__, "inline_sym9__",
                  index_uni(1), index_uni(lcm_sym119__))));
          } 
          for (int i = 2; i <= nind; ++i) {
            lcm_sym112__ = rvalue(first, "first", index_uni(i));
            if (logical_gt(lcm_sym112__, 0)) {
              lcm_sym118__ = rvalue(last, "last", index_uni(i));
              if (logical_gte(lcm_sym118__, (lcm_sym112__ + 1))) {
                current_statement__ = 24;
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(1,
                    rvalue(phi, "phi",
                      index_uni(i), index_uni(((lcm_sym112__ + 1) - 1)))));
                lcm_sym96__ = ((lcm_sym112__ + 1) + 1);
                lp_accum__.add(
                  bernoulli_lpmf<propto__>(
                    rvalue(y, "y",
                      index_uni(i), index_uni((lcm_sym112__ + 1))),
                    rvalue(p, "p",
                      index_uni(i), index_uni(((lcm_sym112__ + 1) - 1)))));
                for (int t = lcm_sym96__; t <= lcm_sym118__; ++t) {
                  current_statement__ = 24;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(1,
                      rvalue(phi, "phi", index_uni(i), index_uni((t - 1)))));
                  current_statement__ = 25;
                  lp_accum__.add(
                    bernoulli_lpmf<propto__>(
                      rvalue(y, "y", index_uni(i), index_uni(t)),
                      rvalue(p, "p", index_uni(i), index_uni((t - 1)))));
                }
              } 
              current_statement__ = 27;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(inline_sym9__, "inline_sym9__",
                    index_uni(i), index_uni(lcm_sym118__))));
            } 
          }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_fails2_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym78__;
      double lcm_sym77__;
      double lcm_sym76__;
      double lcm_sym75__;
      double lcm_sym74__;
      double lcm_sym73__;
      double lcm_sym72__;
      double lcm_sym71__;
      double lcm_sym70__;
      double lcm_sym69__;
      double lcm_sym68__;
      double lcm_sym67__;
      int lcm_sym66__;
      int lcm_sym65__;
      double lcm_sym64__;
      double lcm_sym63__;
      int lcm_sym62__;
      int lcm_sym61__;
      int lcm_sym60__;
      int lcm_sym59__;
      int lcm_sym58__;
      int lcm_sym57__;
      int lcm_sym56__;
      int lcm_sym55__;
      int lcm_sym54__;
      int lcm_sym53__;
      int lcm_sym52__;
      int lcm_sym51__;
      int lcm_sym50__;
      int lcm_sym49__;
      int lcm_sym48__;
      int lcm_sym47__;
      int lcm_sym46__;
      double mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                   0, 1, lp__);
      double mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                 0, 1, lp__);
      Eigen::Matrix<double, -1, -1> phi;
      phi = Eigen::Matrix<double, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(phi, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(nind, (n_occasions - 1));
      stan::math::fill(p, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      out__.write(mean_phi);
      out__.write(mean_p);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym47__ = logical_gte(nind, 1);
      if (lcm_sym47__) {
        lcm_sym66__ = rvalue(first, "first", index_uni(1));
        lcm_sym56__ = (lcm_sym66__ - 1);
        if (logical_gte(lcm_sym56__, 1)) {
          current_statement__ = 6;
          assign(phi, 0, "assigning variable phi", index_uni(1), index_uni(1));
          current_statement__ = 7;
          assign(p, 0, "assigning variable p", index_uni(1), index_uni(1));
          for (int t = 2; t <= lcm_sym56__; ++t) {
            current_statement__ = 6;
            assign(phi, 0,
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 7;
            assign(p, 0, "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        lcm_sym54__ = (n_occasions - 1);
        if (logical_gte(lcm_sym54__, lcm_sym66__)) {
          current_statement__ = 9;
          assign(phi, mean_phi,
            "assigning variable phi", index_uni(1), index_uni(lcm_sym66__));
          lcm_sym62__ = (lcm_sym66__ + 1);
          assign(p, mean_p,
            "assigning variable p", index_uni(1), index_uni(lcm_sym66__));
          for (int t = lcm_sym62__; t <= lcm_sym54__; ++t) {
            current_statement__ = 9;
            assign(phi, mean_phi,
              "assigning variable phi", index_uni(1), index_uni(t));
            current_statement__ = 10;
            assign(p, mean_p,
              "assigning variable p", index_uni(1), index_uni(t));
          }
        } 
        for (int i = 2; i <= nind; ++i) {
          lcm_sym65__ = rvalue(first, "first", index_uni(i));
          lcm_sym55__ = (lcm_sym65__ - 1);
          if (logical_gte(lcm_sym55__, 1)) {
            current_statement__ = 6;
            assign(phi, 0,
              "assigning variable phi", index_uni(i), index_uni(1));
            current_statement__ = 7;
            assign(p, 0, "assigning variable p", index_uni(i), index_uni(1));
            for (int t = 2; t <= lcm_sym55__; ++t) {
              current_statement__ = 6;
              assign(phi, 0,
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 7;
              assign(p, 0, "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
          current_statement__ = 12;
          if (logical_gte(lcm_sym54__, lcm_sym65__)) {
            current_statement__ = 9;
            assign(phi, mean_phi,
              "assigning variable phi", index_uni(i), index_uni(lcm_sym65__));
            lcm_sym61__ = (lcm_sym65__ + 1);
            assign(p, mean_p,
              "assigning variable p", index_uni(i), index_uni(lcm_sym65__));
            for (int t = lcm_sym61__; t <= lcm_sym54__; ++t) {
              current_statement__ = 9;
              assign(phi, mean_phi,
                "assigning variable phi", index_uni(i), index_uni(t));
              current_statement__ = 10;
              assign(p, mean_p,
                "assigning variable p", index_uni(i), index_uni(t));
            }
          } 
        }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym1__;
      int inline_sym7__;
      inline_sym7__ = 0;
      for (int inline_sym8__ = 1; inline_sym8__ <= 1; ++inline_sym8__) {
        current_statement__ = 14;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym2__;
        inline_sym2__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        stan::math::fill(inline_sym2__, DUMMY_VAR__);
        
        for (int inline_sym6__ = 1; inline_sym6__ <= nind; ++inline_sym6__) {
          current_statement__ = 17;
          assign(inline_sym2__, 1.0,
            "assigning variable inline_sym2__", index_uni(inline_sym6__),
                                                  index_uni(n_occasions));
          lcm_sym54__ = (n_occasions - 1);
          if (logical_gte(lcm_sym54__, 1)) {
            int inline_sym3__;
            int inline_sym4__;
            lcm_sym60__ = (lcm_sym54__ + 1);
            current_statement__ = 20;
            assign(inline_sym2__,
              stan::math::fma(
                (rvalue(phi, "phi",
                   index_uni(inline_sym6__), index_uni(lcm_sym54__)) *
                  (1 -
                    rvalue(p, "p",
                      index_uni(inline_sym6__), index_uni((lcm_sym60__ - 1))))),
                rvalue(inline_sym2__, "inline_sym2__",
                  index_uni(inline_sym6__), index_uni(lcm_sym60__)),
                (1 -
                  rvalue(phi, "phi",
                    index_uni(inline_sym6__), index_uni(lcm_sym54__)))),
              "assigning variable inline_sym2__", index_uni(inline_sym6__),
                                                    index_uni(lcm_sym54__));
            for (int inline_sym5__ = 2; inline_sym5__ <= lcm_sym54__;
                 ++inline_sym5__) {
              int inline_sym3__;
              lcm_sym53__ = (n_occasions - inline_sym5__);
              int inline_sym4__;
              lcm_sym59__ = (lcm_sym53__ + 1);
              current_statement__ = 20;
              assign(inline_sym2__,
                stan::math::fma(
                  (rvalue(phi, "phi",
                     index_uni(inline_sym6__), index_uni(lcm_sym53__)) *
                    (1 -
                      rvalue(p, "p",
                        index_uni(inline_sym6__),
                          index_uni((lcm_sym59__ - 1))))),
                  rvalue(inline_sym2__, "inline_sym2__",
                    index_uni(inline_sym6__), index_uni(lcm_sym59__)),
                  (1 -
                    rvalue(phi, "phi",
                      index_uni(inline_sym6__), index_uni(lcm_sym53__)))),
                "assigning variable inline_sym2__", index_uni(inline_sym6__),
                                                      index_uni(lcm_sym53__));
            }
          } 
          if (inline_sym7__) {
            break;
          } 
        }
        if (inline_sym7__) {
          break;
        } 
        inline_sym7__ = 1;
        assign(inline_sym1__, inline_sym2__,
          "assigning variable inline_sym1__");
        break;
      }
      assign(chi, inline_sym1__, "assigning variable chi");
      current_statement__ = 3;
      if (lcm_sym47__) {
        lcm_sym54__ = (n_occasions - 1);
        lcm_sym48__ = logical_gte(lcm_sym54__, 1);
        if (lcm_sym48__) {
          current_statement__ = 3;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi, "phi",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym54__; ++sym2__) {
            current_statement__ = 3;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym48__) {
            current_statement__ = 3;
            check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                   rvalue(phi, "phi",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym54__; ++sym2__) {
              current_statement__ = 3;
              check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                     rvalue(phi, "phi",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 3;
      if (lcm_sym47__) {
        lcm_sym54__ = (n_occasions - 1);
        lcm_sym48__ = logical_gte(lcm_sym54__, 1);
        if (lcm_sym48__) {
          current_statement__ = 3;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi, "phi", index_uni(1), index_uni(1)),
                              1);
          for (int sym2__ = 2; sym2__ <= lcm_sym54__; ++sym2__) {
            current_statement__ = 3;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym48__) {
            current_statement__ = 3;
            check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                rvalue(phi, "phi",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym54__; ++sym2__) {
              current_statement__ = 3;
              check_less_or_equal(function__, "phi[sym1__, sym2__]",
                                  rvalue(phi, "phi",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 4;
      if (lcm_sym47__) {
        lcm_sym54__ = (n_occasions - 1);
        lcm_sym48__ = logical_gte(lcm_sym54__, 1);
        if (lcm_sym48__) {
          current_statement__ = 4;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p, "p", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= lcm_sym54__; ++sym2__) {
            current_statement__ = 4;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym48__) {
            current_statement__ = 4;
            check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                   rvalue(p, "p",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= lcm_sym54__; ++sym2__) {
              current_statement__ = 4;
              check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                     rvalue(p, "p",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 4;
      if (lcm_sym47__) {
        lcm_sym54__ = (n_occasions - 1);
        lcm_sym48__ = logical_gte(lcm_sym54__, 1);
        if (lcm_sym48__) {
          current_statement__ = 4;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p, "p", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= lcm_sym54__; ++sym2__) {
            current_statement__ = 4;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym48__) {
            current_statement__ = 4;
            check_less_or_equal(function__, "p[sym1__, sym2__]",
                                rvalue(p, "p",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= lcm_sym54__; ++sym2__) {
              current_statement__ = 4;
              check_less_or_equal(function__, "p[sym1__, sym2__]",
                                  rvalue(p, "p",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym47__) {
        lcm_sym46__ = logical_gte(n_occasions, 1);
        if (lcm_sym46__) {
          current_statement__ = 5;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(inline_sym1__, "inline_sym1__",
                                   index_uni(1), index_uni(1)), 0);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym1__, "inline_sym1__",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym46__) {
            current_statement__ = 5;
            check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                   rvalue(inline_sym1__, "inline_sym1__",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                     rvalue(inline_sym1__, "inline_sym1__",
                                       index_uni(sym1__), index_uni(sym2__)),
                                     0);
            }
          } 
        }
      } 
      current_statement__ = 5;
      if (lcm_sym47__) {
        lcm_sym46__ = logical_gte(n_occasions, 1);
        if (lcm_sym46__) {
          current_statement__ = 5;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(inline_sym1__, "inline_sym1__",
                                index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym1__, "inline_sym1__",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym46__) {
            current_statement__ = 5;
            check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                rvalue(inline_sym1__, "inline_sym1__",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              check_less_or_equal(function__, "chi[sym1__, sym2__]",
                                  rvalue(inline_sym1__, "inline_sym1__",
                                    index_uni(sym1__), index_uni(sym2__)), 1);
            }
          } 
        }
      } 
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(inline_sym1__);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__;
      pos__ = 1;
      local_scalar_t__ mean_phi;
      mean_phi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mean_phi", "mean_p", "phi", "p",
      "chi"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occasions)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    if (emit_transformed_parameters__) {
      for (int sym152__ = 1; sym152__ <= n_occ_minus_1; ++sym152__) {
        {
          for (int sym153__ = 1; sym153__ <= nind; ++sym153__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym153__) + '.' + std::to_string(sym152__));
            } 
          }
        } 
      }
      for (int sym152__ = 1; sym152__ <= n_occ_minus_1; ++sym152__) {
        {
          for (int sym153__ = 1; sym153__ <= nind; ++sym153__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym153__) + '.' + std::to_string(sym152__));
            } 
          }
        } 
      }
      for (int sym152__ = 1; sym152__ <= n_occasions; ++sym152__) {
        {
          for (int sym153__ = 1; sym153__ <= nind; ++sym153__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym153__) + '.' + std::to_string(sym152__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    if (emit_transformed_parameters__) {
      for (int sym152__ = 1; sym152__ <= n_occ_minus_1; ++sym152__) {
        {
          for (int sym153__ = 1; sym153__ <= nind; ++sym153__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym153__) + '.' + std::to_string(sym152__));
            } 
          }
        } 
      }
      for (int sym152__ = 1; sym152__ <= n_occ_minus_1; ++sym152__) {
        {
          for (int sym153__ = 1; sym153__ <= nind; ++sym153__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym153__) + '.' + std::to_string(sym152__));
            } 
          }
        } 
      }
      for (int sym152__ = 1; sym152__ <= n_occasions; ++sym152__) {
        {
          for (int sym153__ = 1; sym153__ <= nind; ++sym153__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym153__) + '.' + std::to_string(sym152__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + 1);
      const size_t num_transformed = (((nind * n_occ_minus_1) +
                                                   (nind * n_occ_minus_1)) +
                                                  (nind * n_occasions));
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + 1);
      const size_t num_transformed = (((nind * n_occ_minus_1) +
                                                   (nind * n_occ_minus_1)) +
                                                  (nind * n_occasions));
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"mean_phi", "mean_p"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = lcm_fails2_model_namespace::lcm_fails2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lcm_fails2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp lupdf-inlining.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lupdf_inlining_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 13> locations_array__ = 
{" (found before start of program)",
 " (in 'lupdf-inlining.stan', line 16, column 4 to column 12)",
 " (in 'lupdf-inlining.stan', line 19, column 4 to column 32)",
 " (in 'lupdf-inlining.stan', line 2, column 35 to line 4, column 5)",
 " (in 'lupdf-inlining.stan', line 26, column 4 to column 30)",
 " (in 'lupdf-inlining.stan', line 8, column 26 to line 10, column 5)",
 " (in 'lupdf-inlining.stan', line 27, column 4 to column 31)",
 " (in 'lupdf-inlining.stan', line 5, column 34 to line 7, column 5)",
 " (in 'lupdf-inlining.stan', line 22, column 4 to column 29)",
 " (in 'lupdf-inlining.stan', line 13, column 4 to column 10)",
 " (in 'lupdf-inlining.stan', line 3, column 8 to column 36)",
 " (in 'lupdf-inlining.stan', line 6, column 8 to column 35)",
 " (in 'lupdf-inlining.stan', line 9, column 8 to column 32)"};

template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
foo_lpdf(const T0__& x, const T1__& mu, std::ostream* pstream__) ;

struct foo_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
operator()(const T0__& x, const T1__& mu, std::ostream* pstream__)  const 
{
return foo_lpdf<propto__>(x, mu, pstream__);
}
};

template <bool propto__, typename T1__>
stan::promote_args_t<T1__>
bar_lpmf(const int& n, const T1__& mu, std::ostream* pstream__) ;

struct bar_lpmf_functor__ {
template <bool propto__, typename T1__>
stan::promote_args_t<T1__>
operator()(const int& n, const T1__& mu, std::ostream* pstream__)  const 
{
return bar_lpmf<propto__>(n, mu, pstream__);
}
};

template <bool propto__, typename T0__>
stan::promote_args_t<T0__>
baz_lpdf(const T0__& x, std::ostream* pstream__) ;

struct baz_lpdf_functor__ {
template <bool propto__, typename T0__>
stan::promote_args_t<T0__>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return baz_lpdf<propto__>(x, pstream__);
}
};

template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
foo_lpdf(const T0__& x, const T1__& mu, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    double lcm_sym37__;
    {
      current_statement__ = 10;
      return normal_lpdf<propto__>(x, mu, 1);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <bool propto__, typename T1__>
stan::promote_args_t<T1__>
bar_lpmf(const int& n, const T1__& mu, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    double lcm_sym38__;
    {
      current_statement__ = 11;
      return poisson_lpmf<propto__>(n, mu);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <bool propto__, typename T0__>
stan::promote_args_t<T0__>
baz_lpdf(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    double lcm_sym39__;
    {
      current_statement__ = 12;
      return foo_lpdf<propto__>(x, 0.5, pstream__);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
class lupdf_inlining_model final : public model_base_crtp<lupdf_inlining_model> {

 private:
  int n; 
  
 
 public:
  ~lupdf_inlining_model() { }
  
  inline std::string model_name() const final { return "lupdf_inlining_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  lupdf_inlining_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "lupdf_inlining_model_namespace::lupdf_inlining_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 9;
      context__.validate_dims("data initialization","n","int",
           std::vector<size_t>{});
      n = std::numeric_limits<int>::min();
      
      current_statement__ = 9;
      n = context__.vals_i("n")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lupdf_inlining_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym47__;
      double lcm_sym46__;
      double lcm_sym45__;
      local_scalar_t__ mu;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      local_scalar_t__ tp;
      local_scalar_t__ inline_sym25__;
      int inline_sym26__;
      inline_sym26__ = std::numeric_limits<int>::min();
      
      for (int inline_sym27__ = 1; inline_sym27__ <= 1; ++inline_sym27__) {
        inline_sym25__ = normal_lpdf<false>(mu, 1.0, 1);
        break;
      }
      tp = inline_sym25__;
      {
        local_scalar_t__ inline_sym28__;
        int inline_sym32__;
        inline_sym32__ = 0;
        for (int inline_sym33__ = 1; inline_sym33__ <= 1; ++inline_sym33__) {
          local_scalar_t__ inline_sym29__;
          int inline_sym30__;
          inline_sym30__ = std::numeric_limits<int>::min();
          
          for (int inline_sym31__ = 1; inline_sym31__ <= 1; ++inline_sym31__) {
            inline_sym29__ = normal_lpdf<propto__>(mu, 0.5, 1);
            break;
          }
          if (inline_sym32__) {
            break;
          } 
          inline_sym32__ = 1;
          inline_sym28__ = inline_sym29__;
          break;
        }
        lp_accum__.add(inline_sym28__);
        local_scalar_t__ inline_sym34__;
        int inline_sym35__;
        inline_sym35__ = std::numeric_limits<int>::min();
        
        for (int inline_sym36__ = 1; inline_sym36__ <= 1; ++inline_sym36__) {
          inline_sym34__ = poisson_lpmf<propto__>(n, mu);
          break;
        }
        lp_accum__.add(inline_sym34__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lupdf_inlining_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym44__;
      double lcm_sym43__;
      double lcm_sym42__;
      int lcm_sym41__;
      int lcm_sym40__;
      double mu;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      double tp;
      tp = std::numeric_limits<double>::quiet_NaN();
      
      out__.write(mu);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      double inline_sym13__;
      int inline_sym14__;
      inline_sym14__ = std::numeric_limits<int>::min();
      
      for (int inline_sym15__ = 1; inline_sym15__ <= 1; ++inline_sym15__) {
        inline_sym13__ = normal_lpdf<false>(mu, 1.0, 1);
        break;
      }
      tp = inline_sym13__;
      if (emit_transformed_parameters__) {
        out__.write(inline_sym13__);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double lbaz;
      double inline_sym16__;
      int inline_sym20__;
      inline_sym20__ = 0;
      for (int inline_sym21__ = 1; inline_sym21__ <= 1; ++inline_sym21__) {
        double inline_sym17__;
        int inline_sym18__;
        inline_sym18__ = std::numeric_limits<int>::min();
        
        for (int inline_sym19__ = 1; inline_sym19__ <= 1; ++inline_sym19__) {
          inline_sym17__ = normal_lpdf<false>(mu, 0.5, 1);
          break;
        }
        if (inline_sym20__) {
          break;
        } 
        inline_sym20__ = 1;
        inline_sym16__ = inline_sym17__;
        break;
      }
      lbaz = inline_sym16__;
      double lbar;
      double inline_sym22__;
      int inline_sym23__;
      inline_sym23__ = std::numeric_limits<int>::min();
      
      for (int inline_sym24__ = 1; inline_sym24__ <= 1; ++inline_sym24__) {
        inline_sym22__ = poisson_lpmf<false>(n, mu);
        break;
      }
      lbar = inline_sym22__;
      out__.write(inline_sym16__);
      out__.write(inline_sym22__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__;
      pos__ = 1;
      local_scalar_t__ mu;
      mu = in__.read<local_scalar_t__>();
      out__.write(mu);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mu", "tp", "lbaz", "lbar"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "lbaz");
      param_names__.emplace_back(std::string() + "lbar");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "lbaz");
      param_names__.emplace_back(std::string() + "lbar");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tp\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"lbaz\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"lbar\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tp\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"lbaz\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"lbar\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 1;
      const size_t num_transformed = 1;
      const size_t num_gen_quantities = 
  (1 + 1);
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 1;
      const size_t num_transformed = 1;
      const size_t num_gen_quantities = 
  (1 + 1);
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 1> names__{"mu"};
      const std::array<Eigen::Index, 1> constrain_param_sizes__{1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = lupdf_inlining_model_namespace::lupdf_inlining_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lupdf_inlining_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp off-dce.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace off_dce_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 52> locations_array__ = 
{" (found before start of program)",
 " (in 'off-dce.stan', line 23, column 2 to column 17)",
 " (in 'off-dce.stan', line 24, column 2 to column 16)",
 " (in 'off-dce.stan', line 25, column 2 to column 15)",
 " (in 'off-dce.stan', line 26, column 2 to column 14)",
 " (in 'off-dce.stan', line 30, column 2 to column 22)",
 " (in 'off-dce.stan', line 31, column 2 to column 23)",
 " (in 'off-dce.stan', line 58, column 2 to column 13)",
 " (in 'off-dce.stan', line 59, column 2 to column 18)",
 " (in 'off-dce.stan', line 60, column 2 to column 11)",
 " (in 'off-dce.stan', line 70, column 6 to column 21)",
 " (in 'off-dce.stan', line 71, column 6 to column 15)",
 " (in 'off-dce.stan', line 69, column 11 to line 72, column 5)",
 " (in 'off-dce.stan', line 64, column 6 to column 41)",
 " (in 'off-dce.stan', line 65, column 13 to column 14)",
 " (in 'off-dce.stan', line 65, column 6 to column 44)",
 " (in 'off-dce.stan', line 66, column 6 to column 26)",
 " (in 'off-dce.stan', line 67, column 6 to column 55)",
 " (in 'off-dce.stan', line 68, column 6 to column 39)",
 " (in 'off-dce.stan', line 63, column 23 to line 69, column 5)",
 " (in 'off-dce.stan', line 63, column 4 to line 72, column 5)",
 " (in 'off-dce.stan', line 62, column 17 to line 73, column 3)",
 " (in 'off-dce.stan', line 62, column 2 to line 73, column 3)",
 " (in 'off-dce.stan', line 49, column 6 to line 52, column 68)",
 " (in 'off-dce.stan', line 47, column 11 to line 53, column 5)",
 " (in 'off-dce.stan', line 45, column 6 to column 40)",
 " (in 'off-dce.stan', line 46, column 6 to column 41)",
 " (in 'off-dce.stan', line 44, column 18 to line 47, column 5)",
 " (in 'off-dce.stan', line 44, column 4 to line 53, column 5)",
 " (in 'off-dce.stan', line 43, column 17 to line 54, column 3)",
 " (in 'off-dce.stan', line 43, column 2 to line 54, column 3)",
 " (in 'off-dce.stan', line 4, column 2 to column 17)",
 " (in 'off-dce.stan', line 5, column 2 to column 17)",
 " (in 'off-dce.stan', line 6, column 25 to column 26)",
 " (in 'off-dce.stan', line 6, column 28 to column 29)",
 " (in 'off-dce.stan', line 6, column 2 to column 31)",
 " (in 'off-dce.stan', line 7, column 9 to column 10)",
 " (in 'off-dce.stan', line 7, column 2 to column 14)",
 " (in 'off-dce.stan', line 11, column 29 to column 30)",
 " (in 'off-dce.stan', line 11, column 2 to column 32)",
 " (in 'off-dce.stan', line 12, column 2 to column 31)",
 " (in 'off-dce.stan', line 14, column 2 to column 14)",
 " (in 'off-dce.stan', line 16, column 4 to column 25)",
 " (in 'off-dce.stan', line 18, column 6 to column 28)",
 " (in 'off-dce.stan', line 17, column 4 to line 18, column 28)",
 " (in 'off-dce.stan', line 15, column 17 to line 19, column 3)",
 " (in 'off-dce.stan', line 15, column 2 to line 19, column 3)",
 " (in 'off-dce.stan', line 30, column 9 to column 10)",
 " (in 'off-dce.stan', line 31, column 9 to column 10)",
 " (in 'off-dce.stan', line 31, column 12 to column 13)",
 " (in 'off-dce.stan', line 59, column 15 to column 16)",
 " (in 'off-dce.stan', line 60, column 8 to column 9)"};



class off_dce_model final : public model_base_crtp<off_dce_model> {

 private:
  int lcm_sym46__;
  int lcm_sym45__;
  int lcm_sym44__;
  int lcm_sym43__;
  int lcm_sym42__;
  int lcm_sym41__;
  int lcm_sym40__;
  int lcm_sym39__;
  int lcm_sym38__;
  double lcm_sym37__;
  double lcm_sym36__;
  int lcm_sym35__;
  int lcm_sym34__;
  int lcm_sym33__;
  int lcm_sym32__;
  int lcm_sym31__;
  int lcm_sym30__;
  int R;
  int T;
  std::vector<std::vector<int>> y;
  Eigen::Matrix<double, -1, 1> X__;
  std::vector<int> sum_y;
  int occ_obs; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> X{nullptr, 0};
 
 public:
  ~off_dce_model() { }
  
  inline std::string model_name() const final { return "off_dce_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  off_dce_model(stan::io::var_context& context__,
                unsigned int random_seed__ = 0,
                std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "off_dce_model_namespace::off_dce_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 31;
      context__.validate_dims("data initialization","R","int",
           std::vector<size_t>{});
      R = std::numeric_limits<int>::min();
      
      current_statement__ = 31;
      R = context__.vals_i("R")[(1 - 1)];
      current_statement__ = 31;
      check_greater_or_equal(function__, "R", R, 1);
      current_statement__ = 32;
      context__.validate_dims("data initialization","T","int",
           std::vector<size_t>{});
      T = std::numeric_limits<int>::min();
      
      current_statement__ = 32;
      T = context__.vals_i("T")[(1 - 1)];
      current_statement__ = 32;
      check_greater_or_equal(function__, "T", T, 1);
      current_statement__ = 33;
      validate_non_negative_index("y", "R", R);
      current_statement__ = 34;
      validate_non_negative_index("y", "T", T);
      current_statement__ = 35;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(R),
            static_cast<size_t>(T)});
      y = std::vector<std::vector<int>>(R, std::vector<int>(T, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 35;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 35;
        pos__ = 1;
        lcm_sym31__ = logical_gte(T, 1);
        if (lcm_sym31__) {
          {
            lcm_sym30__ = logical_gte(R, 1);
            if (lcm_sym30__) {
              current_statement__ = 35;
              assign(y, rvalue(y_flat__, "y_flat__", index_uni(1)),
                "assigning variable y", index_uni(1), index_uni(1));
              current_statement__ = 35;
              pos__ = 2;
              for (int sym2__ = 2; sym2__ <= R; ++sym2__) {
                current_statement__ = 35;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(sym2__), index_uni(1));
                current_statement__ = 35;
                pos__ = (pos__ + 1);
              }
            } 
            for (int sym1__ = 2; sym1__ <= T; ++sym1__) {
              current_statement__ = 35;
              if (lcm_sym30__) {
                current_statement__ = 35;
                assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", index_uni(1), index_uni(sym1__));
                current_statement__ = 35;
                pos__ = (pos__ + 1);
                for (int sym2__ = 2; sym2__ <= R; ++sym2__) {
                  current_statement__ = 35;
                  assign(y, y_flat__[(pos__ - 1)],
                    "assigning variable y", index_uni(sym2__),
                                              index_uni(sym1__));
                  current_statement__ = 35;
                  pos__ = (pos__ + 1);
                }
              } 
            }
          }
        } else {
          lcm_sym30__ = logical_gte(R, 1);
        }
      }
      current_statement__ = 35;
      if (lcm_sym30__) {
        current_statement__ = 35;
        if (lcm_sym31__) {
          current_statement__ = 35;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 rvalue(y, "y", index_uni(1), index_uni(1)),
                                 0);
          for (int sym2__ = 2; sym2__ <= T; ++sym2__) {
            current_statement__ = 35;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(1), index_uni(sym2__)), 0);
          }
        } 
        for (int sym1__ = 2; sym1__ <= R; ++sym1__) {
          current_statement__ = 35;
          if (lcm_sym31__) {
            current_statement__ = 35;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   rvalue(y, "y",
                                     index_uni(sym1__), index_uni(1)), 0);
            for (int sym2__ = 2; sym2__ <= T; ++sym2__) {
              current_statement__ = 35;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);
            }
          } 
        }
      } 
      current_statement__ = 35;
      if (lcm_sym30__) {
        current_statement__ = 35;
        if (lcm_sym31__) {
          current_statement__ = 35;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              rvalue(y, "y", index_uni(1), index_uni(1)), 1);
          for (int sym2__ = 2; sym2__ <= T; ++sym2__) {
            current_statement__ = 35;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(1), index_uni(sym2__)), 1);
          }
        } 
        for (int sym1__ = 2; sym1__ <= R; ++sym1__) {
          current_statement__ = 35;
          if (lcm_sym31__) {
            current_statement__ = 35;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                rvalue(y, "y",
                                  index_uni(sym1__), index_uni(1)), 1);
            for (int sym2__ = 2; sym2__ <= T; ++sym2__) {
              current_statement__ = 35;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);
            }
          } 
        }
      } 
      current_statement__ = 36;
      validate_non_negative_index("X", "R", R);
      current_statement__ = 37;
      context__.validate_dims("data initialization","X","double",
           std::vector<size_t>{static_cast<size_t>(R)});
      X__ = Eigen::Matrix<double, -1, 1>(R);
      new (&X) Eigen::Map<Eigen::Matrix<double, -1, 1>>(X__.data(), R);
      
      {
        std::vector<double> X_flat__;
        current_statement__ = 37;
        X_flat__ = context__.vals_r("X");
        current_statement__ = 37;
        pos__ = 1;
        current_statement__ = 37;
        if (lcm_sym30__) {
          current_statement__ = 37;
          assign(X, rvalue(X_flat__, "X_flat__", index_uni(1)),
            "assigning variable X", index_uni(1));
          current_statement__ = 37;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= R; ++sym1__) {
            current_statement__ = 37;
            assign(X, X_flat__[(pos__ - 1)],
              "assigning variable X", index_uni(sym1__));
            current_statement__ = 37;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 38;
      validate_non_negative_index("sum_y", "R", R);
      current_statement__ = 39;
      sum_y = std::vector<int>(R, std::numeric_limits<int>::min());
      
      current_statement__ = 40;
      occ_obs = std::numeric_limits<int>::min();
      
      current_statement__ = 41;
      occ_obs = 0;
      current_statement__ = 46;
      if (lcm_sym30__) {
        current_statement__ = 42;
        assign(sum_y, sum(rvalue(y, "y", index_uni(1))),
          "assigning variable sum_y", index_uni(1));
        current_statement__ = 44;
        if (rvalue(sum_y, "sum_y", index_uni(1))) {
          current_statement__ = 43;
          occ_obs = 1;
        } 
        for (int i = 2; i <= R; ++i) {
          current_statement__ = 42;
          assign(sum_y, sum(rvalue(y, "y", index_uni(i))),
            "assigning variable sum_y", index_uni(i));
          current_statement__ = 44;
          if (rvalue(sum_y, "sum_y", index_uni(i))) {
            current_statement__ = 43;
            occ_obs = (occ_obs + 1);
          } 
        }
      } 
      current_statement__ = 39;
      if (lcm_sym30__) {
        current_statement__ = 39;
        check_greater_or_equal(function__, "sum_y[sym1__]",
                               rvalue(sum_y, "sum_y", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= R; ++sym1__) {
          current_statement__ = 39;
          check_greater_or_equal(function__, "sum_y[sym1__]",
                                 sum_y[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 39;
      if (lcm_sym30__) {
        current_statement__ = 39;
        check_less_or_equal(function__, "sum_y[sym1__]",
                            rvalue(sum_y, "sum_y", index_uni(1)), T);
        for (int sym1__ = 2; sym1__ <= R; ++sym1__) {
          current_statement__ = 39;
          check_less_or_equal(function__, "sum_y[sym1__]",
                              sum_y[(sym1__ - 1)], T);
        }
      } 
      current_statement__ = 40;
      check_greater_or_equal(function__, "occ_obs", occ_obs, 0);
      current_statement__ = 40;
      check_less_or_equal(function__, "occ_obs", occ_obs, R);
      current_statement__ = 47;
      validate_non_negative_index("logit_psi", "R", R);
      current_statement__ = 48;
      validate_non_negative_index("logit_p", "R", R);
      current_statement__ = 49;
      validate_non_negative_index("logit_p", "T", T);
      current_statement__ = 50;
      validate_non_negative_index("psi_con", "R", R);
      current_statement__ = 51;
      validate_non_negative_index("z", "R", R);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "off_dce_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym29__;
      int lcm_sym28__;
      Eigen::Matrix<local_scalar_t__, -1, -1> lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      int lcm_sym19__;
      local_scalar_t__ alpha_occ;
      current_statement__ = 1;
      alpha_occ = in__.template read<local_scalar_t__>();
      local_scalar_t__ beta_occ;
      current_statement__ = 2;
      beta_occ = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha_p;
      current_statement__ = 3;
      alpha_p = in__.template read<local_scalar_t__>();
      local_scalar_t__ beta_p;
      current_statement__ = 4;
      beta_p = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__, -1, 1> logit_psi;
      logit_psi = Eigen::Matrix<local_scalar_t__, -1, 1>(R);
      stan::math::fill(logit_psi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> logit_p;
      logit_p = Eigen::Matrix<local_scalar_t__, -1, -1>(R, T);
      stan::math::fill(logit_p, DUMMY_VAR__);
      
      assign(lcm_sym24__, stan::math::fma(beta_occ, X, alpha_occ),
        "assigning variable lcm_sym24__");
      assign(logit_psi, lcm_sym24__, "assigning variable logit_psi");
      assign(lcm_sym27__, rep_matrix(stan::math::fma(beta_p, X, alpha_p), T),
        "assigning variable lcm_sym27__");
      assign(logit_p, lcm_sym27__, "assigning variable logit_p");
      {
        current_statement__ = 30;
        if (logical_gte(R, 1)) {
          current_statement__ = 28;
          if (rvalue(sum_y, "sum_y", index_uni(1))) {
            current_statement__ = 25;
            lp_accum__.add(
              bernoulli_logit_lpmf<propto__>(1,
                rvalue(lcm_sym24__, "lcm_sym24__", index_uni(1))));
            current_statement__ = 26;
            lp_accum__.add(
              bernoulli_logit_lpmf<propto__>(rvalue(y, "y", index_uni(1)),
                rvalue(lcm_sym27__, "lcm_sym27__", index_uni(1))));
          } else {
            current_statement__ = 23;
            lp_accum__.add(
              log_sum_exp(
                (bernoulli_logit_lpmf<false>(1,
                   rvalue(lcm_sym24__, "lcm_sym24__", index_uni(1))) +
                  bernoulli_logit_lpmf<false>(0,
                    rvalue(lcm_sym27__, "lcm_sym27__", index_uni(1)))),
                bernoulli_logit_lpmf<false>(0,
                  rvalue(lcm_sym24__, "lcm_sym24__", index_uni(1)))));
          }
          for (int i = 2; i <= R; ++i) {
            current_statement__ = 28;
            if (rvalue(sum_y, "sum_y", index_uni(i))) {
              current_statement__ = 25;
              lp_accum__.add(
                bernoulli_logit_lpmf<propto__>(1,
                  rvalue(lcm_sym24__, "lcm_sym24__", index_uni(i))));
              current_statement__ = 26;
              lp_accum__.add(
                bernoulli_logit_lpmf<propto__>(rvalue(y, "y", index_uni(i)),
                  rvalue(lcm_sym27__, "lcm_sym27__", index_uni(i))));
            } else {
              current_statement__ = 23;
              lp_accum__.add(
                log_sum_exp(
                  (bernoulli_logit_lpmf<false>(1,
                     rvalue(lcm_sym24__, "lcm_sym24__", index_uni(i))) +
                    bernoulli_logit_lpmf<false>(0,
                      rvalue(lcm_sym27__, "lcm_sym27__", index_uni(i)))),
                  bernoulli_logit_lpmf<false>(0,
                    rvalue(lcm_sym24__, "lcm_sym24__", index_uni(i)))));
            }
          }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "off_dce_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym11__;
      double lcm_sym10__;
      int lcm_sym18__;
      Eigen::Matrix<double, -1, -1> lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      Eigen::Matrix<double, -1, 1> lcm_sym12__;
      Eigen::Matrix<double, -1, 1> lcm_sym9__;
      Eigen::Matrix<double, -1, 1> lcm_sym8__;
      int lcm_sym7__;
      int lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      double lcm_sym2__;
      double lcm_sym1__;
      double alpha_occ;
      current_statement__ = 1;
      alpha_occ = in__.template read<local_scalar_t__>();
      double beta_occ;
      current_statement__ = 2;
      beta_occ = in__.template read<local_scalar_t__>();
      double alpha_p;
      current_statement__ = 3;
      alpha_p = in__.template read<local_scalar_t__>();
      double beta_p;
      current_statement__ = 4;
      beta_p = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, 1> logit_psi;
      logit_psi = Eigen::Matrix<double, -1, 1>(R);
      stan::math::fill(logit_psi, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> logit_p;
      logit_p = Eigen::Matrix<double, -1, -1>(R, T);
      stan::math::fill(logit_p, std::numeric_limits<double>::quiet_NaN());
      
      out__.write(alpha_occ);
      out__.write(beta_occ);
      out__.write(alpha_p);
      out__.write(beta_p);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      assign(lcm_sym12__, stan::math::fma(beta_occ, X, alpha_occ),
        "assigning variable lcm_sym12__");
      assign(logit_psi, lcm_sym12__, "assigning variable logit_psi");
      assign(lcm_sym17__, rep_matrix(stan::math::fma(beta_p, X, alpha_p), T),
        "assigning variable lcm_sym17__");
      assign(logit_p, lcm_sym17__, "assigning variable logit_p");
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym12__);
        out__.write(lcm_sym17__);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      int occ_fs;
      occ_fs = std::numeric_limits<int>::min();
      
      std::vector<double> psi_con;
      psi_con = std::vector<double>(R, std::numeric_limits<double>::quiet_NaN());
      
      
      std::vector<int> z;
      z = std::vector<int>(R, std::numeric_limits<int>::min());
      
      current_statement__ = 22;
      if (logical_gte(R, 1)) {
        current_statement__ = 20;
        if (logical_eq(rvalue(sum_y, "sum_y", index_uni(1)), 0)) {
          double psi;
          lcm_sym14__ = inv_logit(
                          rvalue(lcm_sym12__, "lcm_sym12__", index_uni(1)));
          current_statement__ = 14;
          validate_non_negative_index("q", "T", T);
          Eigen::Matrix<double, -1, 1> q;
          assign(lcm_sym9__,
            transpose(
              inv_logit(
                minus(rvalue(lcm_sym17__, "lcm_sym17__", index_uni(1))))),
            "assigning variable lcm_sym9__");
          double qT;
          lcm_sym16__ = prod(lcm_sym9__);
          current_statement__ = 17;
          assign(psi_con,
            ((lcm_sym14__ * lcm_sym16__) /
              stan::math::fma(lcm_sym14__, lcm_sym16__, (1 - lcm_sym14__))),
            "assigning variable psi_con", index_uni(1));
          current_statement__ = 18;
          assign(z,
            bernoulli_rng(rvalue(psi_con, "psi_con", index_uni(1)),
              base_rng__), "assigning variable z", index_uni(1));
        } else {
          current_statement__ = 10;
          assign(psi_con, 1, "assigning variable psi_con", index_uni(1));
          current_statement__ = 11;
          assign(z, 1, "assigning variable z", index_uni(1));
        }
        for (int i = 2; i <= R; ++i) {
          current_statement__ = 20;
          if (logical_eq(rvalue(sum_y, "sum_y", index_uni(i)), 0)) {
            double psi;
            lcm_sym13__ = inv_logit(
                            rvalue(lcm_sym12__, "lcm_sym12__", index_uni(i)));
            current_statement__ = 14;
            validate_non_negative_index("q", "T", T);
            Eigen::Matrix<double, -1, 1> q;
            assign(lcm_sym8__,
              transpose(
                inv_logit(
                  minus(rvalue(lcm_sym17__, "lcm_sym17__", index_uni(i))))),
              "assigning variable lcm_sym8__");
            double qT;
            lcm_sym15__ = prod(lcm_sym8__);
            current_statement__ = 17;
            assign(psi_con,
              ((lcm_sym13__ * lcm_sym15__) /
                stan::math::fma(lcm_sym13__, lcm_sym15__, (1 - lcm_sym13__))),
              "assigning variable psi_con", index_uni(i));
            current_statement__ = 18;
            assign(z,
              bernoulli_rng(rvalue(psi_con, "psi_con", index_uni(i)),
                base_rng__), "assigning variable z", index_uni(i));
          } else {
            current_statement__ = 10;
            assign(psi_con, 1, "assigning variable psi_con", index_uni(i));
            current_statement__ = 11;
            assign(z, 1, "assigning variable z", index_uni(i));
          }
        }
      } 
      lcm_sym18__ = sum(z);
      occ_fs = lcm_sym18__;
      out__.write(lcm_sym18__);
      out__.write(psi_con);
      out__.write(z);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__;
      pos__ = 1;
      local_scalar_t__ alpha_occ;
      alpha_occ = in__.read<local_scalar_t__>();
      out__.write(alpha_occ);
      local_scalar_t__ beta_occ;
      beta_occ = in__.read<local_scalar_t__>();
      out__.write(beta_occ);
      local_scalar_t__ alpha_p;
      alpha_p = in__.read<local_scalar_t__>();
      out__.write(alpha_p);
      local_scalar_t__ beta_p;
      beta_p = in__.read<local_scalar_t__>();
      out__.write(beta_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"alpha_occ", "beta_occ", "alpha_p",
      "beta_p", "logit_psi", "logit_p", "occ_fs", "psi_con", "z"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{static_cast<size_t>(R)},
      std::vector<size_t>{static_cast<size_t>(R), static_cast<size_t>(T)},
      std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(R)},
      std::vector<size_t>{static_cast<size_t>(R)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha_occ");
    param_names__.emplace_back(std::string() + "beta_occ");
    param_names__.emplace_back(std::string() + "alpha_p");
    param_names__.emplace_back(std::string() + "beta_p");
    if (emit_transformed_parameters__) {
      for (int sym47__ = 1; sym47__ <= R; ++sym47__) {
        {
          param_names__.emplace_back(std::string() + "logit_psi" + '.' + std::to_string(sym47__));
        } 
      }
      for (int sym47__ = 1; sym47__ <= T; ++sym47__) {
        {
          for (int sym48__ = 1; sym48__ <= R; ++sym48__) {
            {
              param_names__.emplace_back(std::string() + "logit_p" + '.' + std::to_string(sym48__) + '.' + std::to_string(sym47__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "occ_fs");
      for (int sym47__ = 1; sym47__ <= R; ++sym47__) {
        {
          param_names__.emplace_back(std::string() + "psi_con" + '.' + std::to_string(sym47__));
        } 
      }
      for (int sym47__ = 1; sym47__ <= R; ++sym47__) {
        {
          param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym47__));
        } 
      }
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha_occ");
    param_names__.emplace_back(std::string() + "beta_occ");
    param_names__.emplace_back(std::string() + "alpha_p");
    param_names__.emplace_back(std::string() + "beta_p");
    if (emit_transformed_parameters__) {
      for (int sym47__ = 1; sym47__ <= R; ++sym47__) {
        {
          param_names__.emplace_back(std::string() + "logit_psi" + '.' + std::to_string(sym47__));
        } 
      }
      for (int sym47__ = 1; sym47__ <= T; ++sym47__) {
        {
          for (int sym48__ = 1; sym48__ <= R; ++sym48__) {
            {
              param_names__.emplace_back(std::string() + "logit_p" + '.' + std::to_string(sym48__) + '.' + std::to_string(sym47__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "occ_fs");
      for (int sym47__ = 1; sym47__ <= R; ++sym47__) {
        {
          param_names__.emplace_back(std::string() + "psi_con" + '.' + std::to_string(sym47__));
        } 
      }
      for (int sym47__ = 1; sym47__ <= R; ++sym47__) {
        {
          param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym47__));
        } 
      }
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"logit_psi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(R) + "},\"block\":\"transformed_parameters\"},{\"name\":\"logit_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(R) + ",\"cols\":" + std::to_string(T) + "},\"block\":\"transformed_parameters\"},{\"name\":\"occ_fs\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"psi_con\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(R) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(R) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"logit_psi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(R) + "},\"block\":\"transformed_parameters\"},{\"name\":\"logit_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(R) + ",\"cols\":" + std::to_string(T) + "},\"block\":\"transformed_parameters\"},{\"name\":\"occ_fs\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"psi_con\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(R) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(R) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((1 + 1) + 1) + 1);
      const size_t num_transformed = (R + (R * T));
      const size_t num_gen_quantities = 
  ((1 + R) + R);
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((1 + 1) + 1) + 1);
      const size_t num_transformed = (R + (R * T));
      const size_t num_gen_quantities = 
  ((1 + R) + R);
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 4> names__{"alpha_occ", "beta_occ",
      "alpha_p", "beta_p"};
      const std::array<Eigen::Index, 4> constrain_param_sizes__{1, 1, 1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = off_dce_model_namespace::off_dce_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return off_dce_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp off-small.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace off_small_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 35> locations_array__ = 
{" (found before start of program)",
 " (in 'off-small.stan', line 10, column 2 to column 12)",
 " (in 'off-small.stan', line 11, column 2 to column 17)",
 " (in 'off-small.stan', line 12, column 2 to column 17)",
 " (in 'off-small.stan', line 13, column 2 to column 13)",
 " (in 'off-small.stan', line 14, column 2 to column 13)",
 " (in 'off-small.stan', line 15, column 2 to column 35)",
 " (in 'off-small.stan', line 16, column 2 to column 35)",
 " (in 'off-small.stan', line 17, column 2 to column 34)",
 " (in 'off-small.stan', line 20, column 2 to column 15)",
 " (in 'off-small.stan', line 21, column 2 to column 15)",
 " (in 'off-small.stan', line 22, column 2 to column 18)",
 " (in 'off-small.stan', line 28, column 4 to line 29, column 42)",
 " (in 'off-small.stan', line 27, column 2 to line 29, column 42)",
 " (in 'off-small.stan', line 32, column 2 to column 23)",
 " (in 'off-small.stan', line 33, column 2 to column 23)",
 " (in 'off-small.stan', line 34, column 2 to column 23)",
 " (in 'off-small.stan', line 35, column 2 to column 23)",
 " (in 'off-small.stan', line 37, column 2 to column 23)",
 " (in 'off-small.stan', line 39, column 2 to column 29)",
 " (in 'off-small.stan', line 2, column 2 to column 17)",
 " (in 'off-small.stan', line 3, column 2 to column 17)",
 " (in 'off-small.stan', line 4, column 30 to column 31)",
 " (in 'off-small.stan', line 4, column 2 to column 33)",
 " (in 'off-small.stan', line 5, column 9 to column 10)",
 " (in 'off-small.stan', line 5, column 2 to column 17)",
 " (in 'off-small.stan', line 6, column 9 to column 10)",
 " (in 'off-small.stan', line 6, column 2 to column 22)",
 " (in 'off-small.stan', line 7, column 9 to column 10)",
 " (in 'off-small.stan', line 7, column 2 to column 14)",
 " (in 'off-small.stan', line 11, column 9 to column 10)",
 " (in 'off-small.stan', line 12, column 9 to column 10)",
 " (in 'off-small.stan', line 20, column 9 to column 10)",
 " (in 'off-small.stan', line 21, column 9 to column 10)",
 " (in 'off-small.stan', line 22, column 9 to column 10)"};



class off_small_model final : public model_base_crtp<off_small_model> {

 private:
  double lcm_sym29__;
  double lcm_sym28__;
  double lcm_sym27__;
  double lcm_sym26__;
  double lcm_sym25__;
  double lcm_sym24__;
  int lcm_sym23__;
  int lcm_sym22__;
  int lcm_sym21__;
  int lcm_sym20__;
  int J;
  int N;
  std::vector<int> person;
  Eigen::Matrix<double, -1, 1> time__;
  Eigen::Matrix<double, -1, 1> treatment__;
  Eigen::Matrix<double, -1, 1> y__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> time{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> treatment{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> y{nullptr, 0};
 
 public:
  ~off_small_model() { }
  
  inline std::string model_name() const final { return "off_small_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  off_small_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "off_small_model_namespace::off_small_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 20;
      context__.validate_dims("data initialization","J","int",
           std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      
      current_statement__ = 20;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 20;
      check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 21;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 21;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 21;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 22;
      validate_non_negative_index("person", "N", N);
      current_statement__ = 23;
      context__.validate_dims("data initialization","person","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      person = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 23;
      person = context__.vals_i("person");
      lcm_sym20__ = logical_gte(N, 1);
      if (lcm_sym20__) {
        current_statement__ = 23;
        check_greater_or_equal(function__, "person[sym1__]",
                               rvalue(person, "person", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 23;
          check_greater_or_equal(function__, "person[sym1__]",
                                 person[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 23;
      if (lcm_sym20__) {
        current_statement__ = 23;
        check_less_or_equal(function__, "person[sym1__]",
                            rvalue(person, "person", index_uni(1)), J);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 23;
          check_less_or_equal(function__, "person[sym1__]",
                              person[(sym1__ - 1)], J);
        }
      } 
      current_statement__ = 24;
      validate_non_negative_index("time", "N", N);
      current_statement__ = 25;
      context__.validate_dims("data initialization","time","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      time__ = Eigen::Matrix<double, -1, 1>(N);
      new (&time) Eigen::Map<Eigen::Matrix<double, -1, 1>>(time__.data(), N);
      
      {
        std::vector<double> time_flat__;
        current_statement__ = 25;
        time_flat__ = context__.vals_r("time");
        current_statement__ = 25;
        pos__ = 1;
        current_statement__ = 25;
        if (lcm_sym20__) {
          current_statement__ = 25;
          assign(time, rvalue(time_flat__, "time_flat__", index_uni(1)),
            "assigning variable time", index_uni(1));
          current_statement__ = 25;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 25;
            assign(time, time_flat__[(pos__ - 1)],
              "assigning variable time", index_uni(sym1__));
            current_statement__ = 25;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 26;
      validate_non_negative_index("treatment", "N", N);
      current_statement__ = 27;
      context__.validate_dims("data initialization","treatment","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      treatment__ = Eigen::Matrix<double, -1, 1>(N);
      new (&treatment) Eigen::Map<Eigen::Matrix<double, -1, 1>>(treatment__.data(), N);
      
      
      {
        std::vector<double> treatment_flat__;
        current_statement__ = 27;
        treatment_flat__ = context__.vals_r("treatment");
        current_statement__ = 27;
        pos__ = 1;
        current_statement__ = 27;
        if (lcm_sym20__) {
          current_statement__ = 27;
          assign(treatment,
            rvalue(treatment_flat__, "treatment_flat__", index_uni(1)),
            "assigning variable treatment", index_uni(1));
          current_statement__ = 27;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 27;
            assign(treatment, treatment_flat__[(pos__ - 1)],
              "assigning variable treatment", index_uni(sym1__));
            current_statement__ = 27;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 28;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 29;
      context__.validate_dims("data initialization","y","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      y__ = Eigen::Matrix<double, -1, 1>(N);
      new (&y) Eigen::Map<Eigen::Matrix<double, -1, 1>>(y__.data(), N);
      
      {
        std::vector<double> y_flat__;
        current_statement__ = 29;
        y_flat__ = context__.vals_r("y");
        current_statement__ = 29;
        pos__ = 1;
        current_statement__ = 29;
        if (lcm_sym20__) {
          current_statement__ = 29;
          assign(y, rvalue(y_flat__, "y_flat__", index_uni(1)),
            "assigning variable y", index_uni(1));
          current_statement__ = 29;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 29;
            assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", index_uni(sym1__));
            current_statement__ = 29;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 30;
      validate_non_negative_index("eta1", "J", J);
      current_statement__ = 31;
      validate_non_negative_index("eta2", "J", J);
      current_statement__ = 32;
      validate_non_negative_index("a1", "J", J);
      current_statement__ = 33;
      validate_non_negative_index("a2", "J", J);
      current_statement__ = 34;
      validate_non_negative_index("y_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + J + J + 1 + 1 + 1 + 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "off_small_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      double lcm_sym12__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym11__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym10__;
      int lcm_sym9__;
      local_scalar_t__ beta;
      current_statement__ = 1;
      beta = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__, -1, 1> eta1;
      current_statement__ = 2;
      eta1 = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(J);
      Eigen::Matrix<local_scalar_t__, -1, 1> eta2;
      current_statement__ = 3;
      eta2 = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(J);
      local_scalar_t__ mu_a1;
      current_statement__ = 4;
      mu_a1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ mu_a2;
      current_statement__ = 5;
      mu_a2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma_a1;
      current_statement__ = 6;
      sigma_a1 = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                   0, 100, lp__);
      local_scalar_t__ sigma_a2;
      current_statement__ = 7;
      sigma_a2 = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                   0, 100, lp__);
      local_scalar_t__ sigma_y;
      current_statement__ = 8;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> a1;
      a1 = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      stan::math::fill(a1, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> a2;
      a2 = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      stan::math::fill(a2, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y_hat, DUMMY_VAR__);
      
      assign(lcm_sym10__,
        stan::math::fma(10, mu_a1, multiply(sigma_a1, eta1)),
        "assigning variable lcm_sym10__");
      assign(a1, lcm_sym10__, "assigning variable a1");
      assign(lcm_sym11__,
        stan::math::fma(0.1, mu_a2, multiply(sigma_a2, eta2)),
        "assigning variable lcm_sym11__");
      assign(a2, lcm_sym11__, "assigning variable a2");
      current_statement__ = 13;
      if (logical_gte(N, 1)) {
        current_statement__ = 12;
        assign(y_hat,
          stan::math::fma(
            rvalue(lcm_sym11__, "lcm_sym11__",
              index_uni(rvalue(person, "person", index_uni(1)))),
            rvalue(time, "time", index_uni(1)),
            stan::math::fma((beta * rvalue(time, "time", index_uni(1))),
              rvalue(treatment, "treatment", index_uni(1)),
              rvalue(lcm_sym10__, "lcm_sym10__",
                index_uni(rvalue(person, "person", index_uni(1)))))),
          "assigning variable y_hat", index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 12;
          assign(y_hat,
            stan::math::fma(
              rvalue(lcm_sym11__, "lcm_sym11__",
                index_uni(rvalue(person, "person", index_uni(i)))),
              rvalue(time, "time", index_uni(i)),
              stan::math::fma((beta * rvalue(time, "time", index_uni(i))),
                rvalue(treatment, "treatment", index_uni(i)),
                rvalue(lcm_sym10__, "lcm_sym10__",
                  index_uni(rvalue(person, "person", index_uni(i)))))),
            "assigning variable y_hat", index_uni(i));
        }
      } 
      {
        current_statement__ = 14;
        lp_accum__.add(normal_lpdf<propto__>(mu_a1, 0, 1));
        current_statement__ = 15;
        lp_accum__.add(normal_lpdf<propto__>(eta1, 0, 1));
        current_statement__ = 16;
        lp_accum__.add(normal_lpdf<propto__>(mu_a2, 0, 1));
        current_statement__ = 17;
        lp_accum__.add(normal_lpdf<propto__>(eta2, 0, 1));
        current_statement__ = 18;
        lp_accum__.add(normal_lpdf<propto__>(beta, 0, 1));
        current_statement__ = 19;
        lp_accum__.add(normal_lpdf<propto__>(y, y_hat, sigma_y));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "off_small_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym8__;
      double lcm_sym7__;
      Eigen::Matrix<double, -1, 1> lcm_sym6__;
      Eigen::Matrix<double, -1, 1> lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      double beta;
      current_statement__ = 1;
      beta = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, 1> eta1;
      current_statement__ = 2;
      eta1 = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(J);
      Eigen::Matrix<double, -1, 1> eta2;
      current_statement__ = 3;
      eta2 = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(J);
      double mu_a1;
      current_statement__ = 4;
      mu_a1 = in__.template read<local_scalar_t__>();
      double mu_a2;
      current_statement__ = 5;
      mu_a2 = in__.template read<local_scalar_t__>();
      double sigma_a1;
      current_statement__ = 6;
      sigma_a1 = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                   0, 100, lp__);
      double sigma_a2;
      current_statement__ = 7;
      sigma_a2 = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                   0, 100, lp__);
      double sigma_y;
      current_statement__ = 8;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      Eigen::Matrix<double, -1, 1> a1;
      a1 = Eigen::Matrix<double, -1, 1>(J);
      stan::math::fill(a1, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> a2;
      a2 = Eigen::Matrix<double, -1, 1>(J);
      stan::math::fill(a2, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y_hat, DUMMY_VAR__);
      
      out__.write(beta);
      out__.write(eta1);
      out__.write(eta2);
      out__.write(mu_a1);
      out__.write(mu_a2);
      out__.write(sigma_a1);
      out__.write(sigma_a2);
      out__.write(sigma_y);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      assign(lcm_sym5__,
        stan::math::fma(10, mu_a1, multiply(sigma_a1, eta1)),
        "assigning variable lcm_sym5__");
      assign(a1, lcm_sym5__, "assigning variable a1");
      assign(lcm_sym6__,
        stan::math::fma(0.1, mu_a2, multiply(sigma_a2, eta2)),
        "assigning variable lcm_sym6__");
      assign(a2, lcm_sym6__, "assigning variable a2");
      current_statement__ = 13;
      if (logical_gte(N, 1)) {
        current_statement__ = 12;
        assign(y_hat,
          stan::math::fma(
            rvalue(lcm_sym6__, "lcm_sym6__",
              index_uni(rvalue(person, "person", index_uni(1)))),
            rvalue(time, "time", index_uni(1)),
            stan::math::fma((beta * rvalue(time, "time", index_uni(1))),
              rvalue(treatment, "treatment", index_uni(1)),
              rvalue(lcm_sym5__, "lcm_sym5__",
                index_uni(rvalue(person, "person", index_uni(1)))))),
          "assigning variable y_hat", index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 12;
          assign(y_hat,
            stan::math::fma(
              rvalue(lcm_sym6__, "lcm_sym6__",
                index_uni(rvalue(person, "person", index_uni(i)))),
              rvalue(time, "time", index_uni(i)),
              stan::math::fma((beta * rvalue(time, "time", index_uni(i))),
                rvalue(treatment, "treatment", index_uni(i)),
                rvalue(lcm_sym5__, "lcm_sym5__",
                  index_uni(rvalue(person, "person", index_uni(i)))))),
            "assigning variable y_hat", index_uni(i));
        }
      } 
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym5__);
        out__.write(lcm_sym6__);
        out__.write(y_hat);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ beta;
      beta = in__.read<local_scalar_t__>();
      out__.write(beta);
      Eigen::Matrix<local_scalar_t__, -1, 1> eta1;
      eta1 = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      stan::math::fill(eta1, DUMMY_VAR__);
      
      lcm_sym1__ = logical_gte(J, 1);
      if (lcm_sym1__) {
        assign(eta1, in__.read<local_scalar_t__>(),
          "assigning variable eta1", index_uni(1));
        for (int sym1__ = 2; sym1__ <= J; ++sym1__) {
          assign(eta1, in__.read<local_scalar_t__>(),
            "assigning variable eta1", index_uni(sym1__));
        }
      } 
      out__.write(eta1);
      Eigen::Matrix<local_scalar_t__, -1, 1> eta2;
      eta2 = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      stan::math::fill(eta2, DUMMY_VAR__);
      
      if (lcm_sym1__) {
        assign(eta2, in__.read<local_scalar_t__>(),
          "assigning variable eta2", index_uni(1));
        for (int sym1__ = 2; sym1__ <= J; ++sym1__) {
          assign(eta2, in__.read<local_scalar_t__>(),
            "assigning variable eta2", index_uni(sym1__));
        }
      } 
      out__.write(eta2);
      local_scalar_t__ mu_a1;
      mu_a1 = in__.read<local_scalar_t__>();
      out__.write(mu_a1);
      local_scalar_t__ mu_a2;
      mu_a2 = in__.read<local_scalar_t__>();
      out__.write(mu_a2);
      local_scalar_t__ sigma_a1;
      sigma_a1 = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_a1);
      local_scalar_t__ sigma_a2;
      sigma_a2 = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_a2);
      local_scalar_t__ sigma_y;
      sigma_y = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"beta", "eta1", "eta2", "mu_a1",
      "mu_a2", "sigma_a1", "sigma_a2", "sigma_y", "a1", "a2", "y_hat"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(J)},
      std::vector<size_t>{static_cast<size_t>(J)}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(J)},
      std::vector<size_t>{static_cast<size_t>(J)},
      std::vector<size_t>{static_cast<size_t>(N)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta");
    for (int sym30__ = 1; sym30__ <= J; ++sym30__) {
      {
        param_names__.emplace_back(std::string() + "eta1" + '.' + std::to_string(sym30__));
      } 
    }
    for (int sym30__ = 1; sym30__ <= J; ++sym30__) {
      {
        param_names__.emplace_back(std::string() + "eta2" + '.' + std::to_string(sym30__));
      } 
    }
    param_names__.emplace_back(std::string() + "mu_a1");
    param_names__.emplace_back(std::string() + "mu_a2");
    param_names__.emplace_back(std::string() + "sigma_a1");
    param_names__.emplace_back(std::string() + "sigma_a2");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym30__ = 1; sym30__ <= J; ++sym30__) {
        {
          param_names__.emplace_back(std::string() + "a1" + '.' + std::to_string(sym30__));
        } 
      }
      for (int sym30__ = 1; sym30__ <= J; ++sym30__) {
        {
          param_names__.emplace_back(std::string() + "a2" + '.' + std::to_string(sym30__));
        } 
      }
      for (int sym30__ = 1; sym30__ <= N; ++sym30__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym30__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta");
    for (int sym30__ = 1; sym30__ <= J; ++sym30__) {
      {
        param_names__.emplace_back(std::string() + "eta1" + '.' + std::to_string(sym30__));
      } 
    }
    for (int sym30__ = 1; sym30__ <= J; ++sym30__) {
      {
        param_names__.emplace_back(std::string() + "eta2" + '.' + std::to_string(sym30__));
      } 
    }
    param_names__.emplace_back(std::string() + "mu_a1");
    param_names__.emplace_back(std::string() + "mu_a2");
    param_names__.emplace_back(std::string() + "sigma_a1");
    param_names__.emplace_back(std::string() + "sigma_a2");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym30__ = 1; sym30__ <= J; ++sym30__) {
        {
          param_names__.emplace_back(std::string() + "a1" + '.' + std::to_string(sym30__));
        } 
      }
      for (int sym30__ = 1; sym30__ <= J; ++sym30__) {
        {
          param_names__.emplace_back(std::string() + "a2" + '.' + std::to_string(sym30__));
        } 
      }
      for (int sym30__ = 1; sym30__ <= N; ++sym30__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym30__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eta1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"eta2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"mu_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eta1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"eta2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"mu_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((((1 + J) + J) + 1) + 1) + 1) + 1) + 1);
      const size_t num_transformed = 
  ((J + J) + N);
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((((1 + J) + J) + 1) + 1) + 1) + 1) + 1);
      const size_t num_transformed = 
  ((J + J) + N);
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 8> names__{"beta", "eta1", "eta2",
      "mu_a1", "mu_a2", "sigma_a1", "sigma_a2", "sigma_y"};
      const std::array<Eigen::Index, 8> constrain_param_sizes__{1, J, 
       J, 1, 1, 1, 1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = off_small_model_namespace::off_small_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return off_small_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp optimizations.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace optimizations_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 93> locations_array__ = 
{" (found before start of program)",
 " (in 'optimizations.stan', line 20, column 4 to column 15)",
 " (in 'optimizations.stan', line 21, column 4 to column 13)",
 " (in 'optimizations.stan', line 22, column 4 to column 26)",
 " (in 'optimizations.stan', line 23, column 4 to column 23)",
 " (in 'optimizations.stan', line 24, column 4 to column 24)",
 " (in 'optimizations.stan', line 27, column 4 to column 11)",
 " (in 'optimizations.stan', line 5, column 8 to column 20)",
 " (in 'optimizations.stan', line 2, column 33 to line 6, column 5)",
 " (in 'optimizations.stan', line 9, column 8 to line 10, column 26)",
 " (in 'optimizations.stan', line 8, column 20 to line 12, column 5)",
 " (in 'optimizations.stan', line 30, column 17 to column 28)",
 " (in 'optimizations.stan', line 31, column 33 to line 34, column 5)",
 " (in 'optimizations.stan', line 36, column 8 to column 21)",
 " (in 'optimizations.stan', line 35, column 4 to line 37, column 5)",
 " (in 'optimizations.stan', line 41, column 16 to column 29)",
 " (in 'optimizations.stan', line 40, column 12 to line 41, column 29)",
 " (in 'optimizations.stan', line 39, column 8 to line 41, column 29)",
 " (in 'optimizations.stan', line 38, column 4 to line 41, column 29)",
 " (in 'optimizations.stan', line 44, column 10 to column 16)",
 " (in 'optimizations.stan', line 43, column 8 to line 44, column 16)",
 " (in 'optimizations.stan', line 45, column 8 to column 20)",
 " (in 'optimizations.stan', line 42, column 21 to line 46, column 5)",
 " (in 'optimizations.stan', line 42, column 4 to line 46, column 5)",
 " (in 'optimizations.stan', line 49, column 10 to column 19)",
 " (in 'optimizations.stan', line 48, column 8 to line 49, column 19)",
 " (in 'optimizations.stan', line 50, column 8 to column 20)",
 " (in 'optimizations.stan', line 47, column 21 to line 51, column 5)",
 " (in 'optimizations.stan', line 47, column 4 to line 51, column 5)",
 " (in 'optimizations.stan', line 54, column 10 to column 19)",
 " (in 'optimizations.stan', line 53, column 8 to line 54, column 19)",
 " (in 'optimizations.stan', line 55, column 8 to column 20)",
 " (in 'optimizations.stan', line 52, column 21 to line 56, column 5)",
 " (in 'optimizations.stan', line 52, column 4 to line 56, column 5)",
 " (in 'optimizations.stan', line 57, column 4 to column 10)",
 " (in 'optimizations.stan', line 58, column 4 to column 16)",
 " (in 'optimizations.stan', line 60, column 6 to column 12)",
 " (in 'optimizations.stan', line 59, column 4 to line 60, column 12)",
 " (in 'optimizations.stan', line 61, column 4 to column 16)",
 " (in 'optimizations.stan', line 64, column 4 to column 16)",
 " (in 'optimizations.stan', line 65, column 4 to column 16)",
 " (in 'optimizations.stan', line 66, column 4 to column 16)",
 " (in 'optimizations.stan', line 68, column 6 to column 19)",
 " (in 'optimizations.stan', line 69, column 4 to column 16)",
 " (in 'optimizations.stan', line 70, column 4 to column 11)",
 " (in 'optimizations.stan', line 71, column 4 to column 10)",
 " (in 'optimizations.stan', line 72, column 4 to column 16)",
 " (in 'optimizations.stan', line 74, column 6 to column 12)",
 " (in 'optimizations.stan', line 73, column 4 to line 74, column 12)",
 " (in 'optimizations.stan', line 75, column 4 to column 16)",
 " (in 'optimizations.stan', line 78, column 4 to column 16)",
 " (in 'optimizations.stan', line 80, column 8 to column 19)",
 " (in 'optimizations.stan', line 82, column 8 to column 20)",
 " (in 'optimizations.stan', line 79, column 4 to line 83, column 5)",
 " (in 'optimizations.stan', line 85, column 8 to column 20)",
 " (in 'optimizations.stan', line 87, column 8 to column 20)",
 " (in 'optimizations.stan', line 84, column 4 to line 88, column 5)",
 " (in 'optimizations.stan', line 90, column 11 to column 23)",
 " (in 'optimizations.stan', line 90, column 4 to column 23)",
 " (in 'optimizations.stan', line 15, column 8 to column 20)",
 " (in 'optimizations.stan', line 14, column 18 to line 17, column 5)",
 " (in 'optimizations.stan', line 97, column 20 to column 26)",
 " (in 'optimizations.stan', line 98, column 22 to column 28)",
 " (in 'optimizations.stan', line 100, column 6 to column 15)",
 " (in 'optimizations.stan', line 99, column 4 to line 100, column 15)",
 " (in 'optimizations.stan', line 102, column 6 to column 12)",
 " (in 'optimizations.stan', line 101, column 4 to line 102, column 12)",
 " (in 'optimizations.stan', line 106, column 6 to column 15)",
 " (in 'optimizations.stan', line 108, column 6 to column 12)",
 " (in 'optimizations.stan', line 112, column 8 to column 20)",
 " (in 'optimizations.stan', line 115, column 8 to column 21)",
 " (in 'optimizations.stan', line 111, column 4 to line 116, column 5)",
 " (in 'optimizations.stan', line 119, column 12 to column 24)",
 " (in 'optimizations.stan', line 118, column 8 to line 121, column 9)",
 " (in 'optimizations.stan', line 117, column 4 to line 127, column 5)",
 " (in 'optimizations.stan', line 128, column 4 to column 14)",
 " (in 'optimizations.stan', line 132, column 6 to column 21)",
 " (in 'optimizations.stan', line 129, column 4 to line 132, column 21)",
 " (in 'optimizations.stan', line 134, column 4 to column 15)",
 " (in 'optimizations.stan', line 137, column 8 to column 23)",
 " (in 'optimizations.stan', line 138, column 8 to column 24)",
 " (in 'optimizations.stan', line 135, column 4 to line 139, column 5)",
 " (in 'optimizations.stan', line 140, column 4 to column 25)",
 " (in 'optimizations.stan', line 143, column 4 to column 26)",
 " (in 'optimizations.stan', line 144, column 4 to column 22)",
 " (in 'optimizations.stan', line 146, column 6 to column 28)",
 " (in 'optimizations.stan', line 145, column 4 to line 146, column 28)",
 " (in 'optimizations.stan', line 147, column 4 to column 23)",
 " (in 'optimizations.stan', line 4, column 10 to column 17)",
 " (in 'optimizations.stan', line 3, column 8 to line 4, column 17)",
 " (in 'optimizations.stan', line 10, column 12 to column 26)",
 " (in 'optimizations.stan', line 11, column 8 to column 21)",
 " (in 'optimizations.stan', line 16, column 8 to column 18)"};

template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
nrfun_lp(const T0__& x, const int& y, T_lp__& lp__, T_lp_accum__& lp_accum__,
         std::ostream* pstream__) ;

struct nrfun_lp_functor__ {
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
operator()(const T0__& x, const int& y, T_lp__& lp__,
           T_lp_accum__& lp_accum__, std::ostream* pstream__)  const 
{
return nrfun_lp<propto__>(x, y, lp__, lp_accum__, pstream__);
}
};

int
rfun(const int& y, std::ostream* pstream__) ;

struct rfun_functor__ {
int
operator()(const int& y, std::ostream* pstream__)  const 
{
return rfun(y, pstream__);
}
};

template <bool propto__, typename T_lp__, typename T_lp_accum__>
int
rfun_lp(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__) ;

struct rfun_lp_functor__ {
template <bool propto__, typename T_lp__, typename T_lp_accum__>
int
operator()(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__)  const 
{
return rfun_lp<propto__>(lp__, lp_accum__, pstream__);
}
};

template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
nrfun_lp(const T0__& x, const int& y, T_lp__& lp__, T_lp_accum__& lp_accum__,
         std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym35__;
    {
      current_statement__ = 89;
      if (logical_gt(x, 342)) {
        current_statement__ = 88;
        return ;
      } 
      current_statement__ = 7;
      lp_accum__.add(y);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
int
rfun(const int& y, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    {
      current_statement__ = 9;
      if (logical_gt(y, 2)) {
        current_statement__ = 90;
        return (y + 24);
      } 
      current_statement__ = 91;
      return (y + 2);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
template <bool propto__, typename T_lp__, typename T_lp_accum__>
int
rfun_lp(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    {
      current_statement__ = 59;
      lp_accum__.add(2);
      current_statement__ = 92;
      return 24;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}
class optimizations_model final : public model_base_crtp<optimizations_model> {

 private:
   
  
 
 public:
  ~optimizations_model() { }
  
  inline std::string model_name() const final { return "optimizations_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  optimizations_model(stan::io::var_context& context__,
                      unsigned int random_seed__ = 0,
                      std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "optimizations_model_namespace::optimizations_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + (3 * 2) + 2 + 3;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "optimizations_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym54__;
      int lcm_sym53__;
      int lcm_sym52__;
      int lcm_sym51__;
      int lcm_sym50__;
      int lcm_sym49__;
      int lcm_sym48__;
      int lcm_sym47__;
      int lcm_sym46__;
      int lcm_sym45__;
      int lcm_sym44__;
      int lcm_sym43__;
      int lcm_sym42__;
      int lcm_sym41__;
      local_scalar_t__ theta;
      current_statement__ = 1;
      theta = in__.template read<local_scalar_t__>();
      local_scalar_t__ phi;
      current_statement__ = 2;
      phi = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__, -1, -1> x_matrix;
      current_statement__ = 3;
      x_matrix = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                   3, 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> x_vector;
      current_statement__ = 4;
      x_vector = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                   2);
      Eigen::Matrix<local_scalar_t__, -1, -1> x_cov;
      current_statement__ = 5;
      x_cov = in__.template read_constrain_cov_matrix<Eigen::Matrix<local_scalar_t__, -1, -1>, jacobian__>(
                lp__, 2);
      {
        double x;
        x = std::numeric_limits<double>::quiet_NaN();
        
        int inline_sym1__;
        inline_sym1__ = std::numeric_limits<int>::min();
        
        for (int inline_sym2__ = 1; inline_sym2__ <= 1; ++inline_sym2__) {
          current_statement__ = 7;
          lp_accum__.add(3);
        }
        int inline_sym3__;
        int inline_sym4__;
        inline_sym4__ = std::numeric_limits<int>::min();
        
        for (int inline_sym5__ = 1; inline_sym5__ <= 1; ++inline_sym5__) {
          {
            inline_sym3__ = 27;
            break;
          }
          inline_sym3__ = 5;
          break;
        }
        if (pstream__) {
          stan_print(pstream__, inline_sym3__);
          stan_print(pstream__, "\n");
        }
        int inline_sym6__;
        int inline_sym7__;
        inline_sym7__ = std::numeric_limits<int>::min();
        
        for (int inline_sym8__ = 1; inline_sym8__ <= 1; ++inline_sym8__) {
          {
            inline_sym6__ = 28;
            break;
          }
          inline_sym6__ = 6;
          break;
        }
        if (inline_sym6__) {
          current_statement__ = 11;
          if (pstream__) {
            stan_print(pstream__, "a");
            stan_print(pstream__, "\n");
          }
        } 
        int inline_sym9__;
        int inline_sym12__;
        int inline_sym10__;
        inline_sym10__ = std::numeric_limits<int>::min();
        
        for (int inline_sym11__ = 1; inline_sym11__ <= 1; ++inline_sym11__) {
          {
            inline_sym9__ = 31;
            break;
          }
          inline_sym9__ = 9;
          break;
        }
        int inline_sym13__;
        inline_sym13__ = std::numeric_limits<int>::min();
        
        for (int inline_sym14__ = 1; inline_sym14__ <= 1; ++inline_sym14__) {
          {
            inline_sym12__ = 29;
            break;
          }
          inline_sym12__ = 7;
          break;
        }
        if (logical_gte(inline_sym12__, inline_sym9__)) {
          {
            int inline_sym15__;
            int inline_sym16__;
            inline_sym16__ = std::numeric_limits<int>::min();
            
            for (int inline_sym17__ = 1; inline_sym17__ <= 1;
                 ++inline_sym17__) {
              {
                inline_sym15__ = 32;
                break;
              }
              inline_sym15__ = 10;
              break;
            }
            lp_accum__.add(inline_sym15__);
            int inline_sym18__;
            inline_sym18__ = std::numeric_limits<int>::min();
            
            for (int inline_sym19__ = 1; inline_sym19__ <= 1;
                 ++inline_sym19__) {
              current_statement__ = 7;
              lp_accum__.add(3);
            }
          }
          int inline_sym13__;
          inline_sym13__ = std::numeric_limits<int>::min();
          
          lcm_sym50__ = (inline_sym9__ + 1);
          for (int inline_sym14__ = 1; inline_sym14__ <= 1; ++inline_sym14__) {
            {
              inline_sym12__ = 29;
              lcm_sym50__ = (inline_sym9__ + 1);
              break;
            }
            inline_sym12__ = 7;
            lcm_sym50__ = (inline_sym9__ + 1);
            break;
          }
          for (int i = lcm_sym50__; i <= inline_sym12__; ++i) {
            {
              int inline_sym15__;
              int inline_sym16__;
              inline_sym16__ = std::numeric_limits<int>::min();
              
              for (int inline_sym17__ = 1; inline_sym17__ <= 1;
                   ++inline_sym17__) {
                {
                  inline_sym15__ = 32;
                  break;
                }
                inline_sym15__ = 10;
                break;
              }
              lp_accum__.add(inline_sym15__);
              int inline_sym18__;
              inline_sym18__ = std::numeric_limits<int>::min();
              
              for (int inline_sym19__ = 1; inline_sym19__ <= 1;
                   ++inline_sym19__) {
                current_statement__ = 7;
                lp_accum__.add(3);
              }
            }
            int inline_sym13__;
            inline_sym13__ = std::numeric_limits<int>::min();
            
            for (int inline_sym14__ = 1; inline_sym14__ <= 1;
                 ++inline_sym14__) {
              {
                inline_sym12__ = 29;
                break;
              }
              inline_sym12__ = 7;
              break;
            }
          }
        } 
        {
          current_statement__ = 13;
          lp_accum__.add(53);
          {
            current_statement__ = 13;
            lp_accum__.add(53);
          }
          {
            current_statement__ = 13;
            lp_accum__.add(53);
          }
          {
            current_statement__ = 13;
            lp_accum__.add(53);
          }
          {
            current_statement__ = 13;
            lp_accum__.add(53);
          }
        }
        {
          {
            {
              current_statement__ = 15;
              lp_accum__.add(53);
              {
                current_statement__ = 15;
                lp_accum__.add(53);
              }
            }
            {
              lcm_sym53__ = (2 * 2);
              if (logical_gte(lcm_sym53__, 2)) {
                lcm_sym51__ = (2 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym51__; k <= lcm_sym53__; ++k) {
                  current_statement__ = 15;
                  lp_accum__.add(53);
                }
              } 
            }
            {
              lcm_sym53__ = (3 * 2);
              if (logical_gte(lcm_sym53__, 3)) {
                lcm_sym51__ = (3 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym51__; k <= lcm_sym53__; ++k) {
                  current_statement__ = 15;
                  lp_accum__.add(53);
                }
              } 
            }
          }
          {
            lcm_sym48__ = (2 + 2);
            if (logical_gte(lcm_sym48__, 2)) {
              lcm_sym52__ = (2 * 2);
              if (logical_gte(lcm_sym52__, 2)) {
                {
                  lcm_sym49__ = (2 + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym49__; k <= lcm_sym52__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);
                  }
                }
              } else {
                lcm_sym49__ = (2 + 1);
              }
              for (int j = lcm_sym49__; j <= lcm_sym48__; ++j) {
                lcm_sym53__ = (j * 2);
                if (logical_gte(lcm_sym53__, j)) {
                  lcm_sym51__ = (j + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym51__; k <= lcm_sym53__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);
                  }
                } 
              }
            } 
          }
          {
            lcm_sym48__ = (3 + 2);
            if (logical_gte(lcm_sym48__, 3)) {
              lcm_sym52__ = (3 * 2);
              if (logical_gte(lcm_sym52__, 3)) {
                {
                  lcm_sym49__ = (3 + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym49__; k <= lcm_sym52__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);
                  }
                }
              } else {
                lcm_sym49__ = (3 + 1);
              }
              for (int j = lcm_sym49__; j <= lcm_sym48__; ++j) {
                lcm_sym53__ = (j * 2);
                if (logical_gte(lcm_sym53__, j)) {
                  lcm_sym51__ = (j + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym51__; k <= lcm_sym53__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);
                  }
                } 
              }
            } 
          }
          {
            lcm_sym48__ = (4 + 2);
            if (logical_gte(lcm_sym48__, 4)) {
              lcm_sym52__ = (4 * 2);
              if (logical_gte(lcm_sym52__, 4)) {
                {
                  lcm_sym49__ = (4 + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym49__; k <= lcm_sym52__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);
                  }
                }
              } else {
                lcm_sym49__ = (4 + 1);
              }
              for (int j = lcm_sym49__; j <= lcm_sym48__; ++j) {
                lcm_sym53__ = (j * 2);
                if (logical_gte(lcm_sym53__, j)) {
                  lcm_sym51__ = (j + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym51__; k <= lcm_sym53__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);
                  }
                } 
              }
            } 
          }
          {
            lcm_sym48__ = (5 + 2);
            if (logical_gte(lcm_sym48__, 5)) {
              lcm_sym52__ = (5 * 2);
              if (logical_gte(lcm_sym52__, 5)) {
                {
                  lcm_sym49__ = (5 + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym49__; k <= lcm_sym52__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);
                  }
                }
              } else {
                lcm_sym49__ = (5 + 1);
              }
              for (int j = lcm_sym49__; j <= lcm_sym48__; ++j) {
                lcm_sym53__ = (j * 2);
                if (logical_gte(lcm_sym53__, j)) {
                  lcm_sym51__ = (j + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym51__; k <= lcm_sym53__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);
                  }
                } 
              }
            } 
          }
        }
        current_statement__ = 23;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 20;
          if (logical_gt(i, 4)) {
            break;
          } 
          current_statement__ = 21;
          lp_accum__.add(2);
        }
        current_statement__ = 28;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 25;
          if (logical_gt(i, 4)) {
            continue;
          } 
          current_statement__ = 26;
          lp_accum__.add(2);
        }
        current_statement__ = 33;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 30;
          if (logical_gt(i, 4)) {
            continue;
          } 
          current_statement__ = 31;
          lp_accum__.add(2);
        }
        current_statement__ = 34;
        x = 3;
        current_statement__ = 35;
        lp_accum__.add(3);
        current_statement__ = 37;
        if (logical_gt(theta, 2)) {
          current_statement__ = 36;
          x = 2;
        } 
        current_statement__ = 38;
        lp_accum__.add(x);
        current_statement__ = 39;
        lp_accum__.add(247);
        current_statement__ = 40;
        x = 576;
        current_statement__ = 41;
        lp_accum__.add(576);
        lcm_sym47__ = logical_gt(theta, 46);
        if (lcm_sym47__) {
          current_statement__ = 42;
          x = 5880;
        } 
        current_statement__ = 43;
        lp_accum__.add(x);
        double z;
        current_statement__ = 45;
        z = x;
        current_statement__ = 46;
        lp_accum__.add(x);
        current_statement__ = 48;
        if (lcm_sym47__) {
          current_statement__ = 47;
          z = x;
        } 
        current_statement__ = 49;
        lp_accum__.add(z);
        current_statement__ = 50;
        lp_accum__.add(2);
        {
          double y;
          y = std::numeric_limits<double>::quiet_NaN();
          
          current_statement__ = 52;
          lp_accum__.add(24);
        }
        {
          double y;
          y = std::numeric_limits<double>::quiet_NaN();
          
          current_statement__ = 55;
          lp_accum__.add(245);
        }
        {
          current_statement__ = 57;
          lp_accum__.add(2);
        }
        int inline_sym20__;
        int inline_sym21__;
        inline_sym21__ = std::numeric_limits<int>::min();
        
        for (int inline_sym22__ = 1; inline_sym22__ <= 1; ++inline_sym22__) {
          current_statement__ = 59;
          lp_accum__.add(2);
          break;
        }
        current_statement__ = 61;
        while (576) {
          break;
        }
        int inline_sym23__;
        int inline_sym24__;
        inline_sym24__ = std::numeric_limits<int>::min();
        
        for (int inline_sym25__ = 1; inline_sym25__ <= 1; ++inline_sym25__) {
          current_statement__ = 59;
          lp_accum__.add(2);
          inline_sym23__ = 24;
          break;
        }
        while (inline_sym23__) {
          {
            break;
          }
          int inline_sym24__;
          inline_sym24__ = std::numeric_limits<int>::min();
          
          for (int inline_sym25__ = 1; inline_sym25__ <= 1; ++inline_sym25__) {
            current_statement__ = 59;
            lp_accum__.add(2);
            inline_sym23__ = 24;
            break;
          }
        }
        current_statement__ = 64;
        for (int i = 31; i <= 225; ++i) { continue;}
        current_statement__ = 66;
        for (int i = 31; i <= 225; ++i) { break;}
        int inline_sym26__;
        int inline_sym27__;
        inline_sym27__ = std::numeric_limits<int>::min();
        
        for (int inline_sym28__ = 1; inline_sym28__ <= 1; ++inline_sym28__) {
          current_statement__ = 59;
          lp_accum__.add(2);
          inline_sym26__ = 24;
          break;
        }
        for (int i = inline_sym26__; i <= 225; ++i) { continue;}
        int inline_sym29__;
        int inline_sym30__;
        inline_sym30__ = std::numeric_limits<int>::min();
        
        for (int inline_sym31__ = 1; inline_sym31__ <= 1; ++inline_sym31__) {
          current_statement__ = 59;
          lp_accum__.add(2);
          inline_sym29__ = 24;
          break;
        }
        for (int i = inline_sym29__; i <= 225; ++i) { break;}
        int inline_sym32__;
        int inline_sym33__;
        inline_sym33__ = std::numeric_limits<int>::min();
        
        for (int inline_sym34__ = 1; inline_sym34__ <= 1; ++inline_sym34__) {
          current_statement__ = 59;
          lp_accum__.add(2);
          break;
        }
        {
          current_statement__ = 69;
          lp_accum__.add(1);
          current_statement__ = 70;
          lp_accum__.add(24);
        }
        {
          {
            current_statement__ = 72;
            lp_accum__.add(1);
          }
        }
        double temp;
        temp = std::numeric_limits<double>::quiet_NaN();
        
        {
          current_statement__ = 76;
          if (pstream__) {
            stan_print(pstream__, "hello");
            stan_print(pstream__, "\n");
          }
        }
        double temp2;
        temp2 = std::numeric_limits<double>::quiet_NaN();
        
        {
          current_statement__ = 79;
          lp_accum__.add(4);
          current_statement__ = 80;
          lp_accum__.add(6);
          {
            current_statement__ = 79;
            lp_accum__.add(4);
            current_statement__ = 80;
            lp_accum__.add(6);
          }
        }
        double dataonlyvar;
        current_statement__ = 82;
        dataonlyvar = 3;
        current_statement__ = 83;
        lp_accum__.add(dataonlyvar);
        local_scalar_t__ paramvar;
        {
          current_statement__ = 85;
          paramvar = (theta * 34);
        }
        current_statement__ = 87;
        lp_accum__.add(paramvar);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "optimizations_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym40__;
      int lcm_sym39__;
      double theta;
      current_statement__ = 1;
      theta = in__.template read<local_scalar_t__>();
      double phi;
      current_statement__ = 2;
      phi = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, -1> x_matrix;
      current_statement__ = 3;
      x_matrix = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                   3, 2);
      Eigen::Matrix<double, -1, 1> x_vector;
      current_statement__ = 4;
      x_vector = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                   2);
      Eigen::Matrix<double, -1, -1> x_cov;
      current_statement__ = 5;
      x_cov = in__.template read_constrain_cov_matrix<Eigen::Matrix<local_scalar_t__, -1, -1>, jacobian__>(
                lp__, 2);
      out__.write(theta);
      out__.write(phi);
      out__.write(x_matrix);
      out__.write(x_vector);
      out__.write(x_cov);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__;
      pos__ = 1;
      local_scalar_t__ theta;
      theta = in__.read<local_scalar_t__>();
      out__.write(theta);
      local_scalar_t__ phi;
      phi = in__.read<local_scalar_t__>();
      out__.write(phi);
      Eigen::Matrix<local_scalar_t__, -1, -1> x_matrix;
      x_matrix = Eigen::Matrix<local_scalar_t__, -1, -1>(3, 2);
      stan::math::fill(x_matrix, DUMMY_VAR__);
      
      {
        {
          assign(x_matrix, in__.read<local_scalar_t__>(),
            "assigning variable x_matrix", index_uni(1), index_uni(1));
          {
            assign(x_matrix, in__.read<local_scalar_t__>(),
              "assigning variable x_matrix", index_uni(2), index_uni(1));
          }
          {
            assign(x_matrix, in__.read<local_scalar_t__>(),
              "assigning variable x_matrix", index_uni(3), index_uni(1));
          }
        }
        {
          {
            assign(x_matrix, in__.read<local_scalar_t__>(),
              "assigning variable x_matrix", index_uni(1), index_uni(2));
            {
              assign(x_matrix, in__.read<local_scalar_t__>(),
                "assigning variable x_matrix", index_uni(2), index_uni(2));
            }
            {
              assign(x_matrix, in__.read<local_scalar_t__>(),
                "assigning variable x_matrix", index_uni(3), index_uni(2));
            }
          }
        }
      }
      out__.write(x_matrix);
      Eigen::Matrix<local_scalar_t__, -1, 1> x_vector;
      x_vector = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(x_vector, DUMMY_VAR__);
      
      {
        assign(x_vector, in__.read<local_scalar_t__>(),
          "assigning variable x_vector", index_uni(1));
        {
          assign(x_vector, in__.read<local_scalar_t__>(),
            "assigning variable x_vector", index_uni(2));
        }
      }
      out__.write(x_vector);
      Eigen::Matrix<local_scalar_t__, -1, -1> x_cov;
      x_cov = Eigen::Matrix<local_scalar_t__, -1, -1>(2, 2);
      stan::math::fill(x_cov, DUMMY_VAR__);
      
      {
        {
          assign(x_cov, in__.read<local_scalar_t__>(),
            "assigning variable x_cov", index_uni(1), index_uni(1));
          {
            assign(x_cov, in__.read<local_scalar_t__>(),
              "assigning variable x_cov", index_uni(2), index_uni(1));
          }
        }
        {
          {
            assign(x_cov, in__.read<local_scalar_t__>(),
              "assigning variable x_cov", index_uni(1), index_uni(2));
            {
              assign(x_cov, in__.read<local_scalar_t__>(),
                "assigning variable x_cov", index_uni(2), index_uni(2));
            }
          }
        }
      }
      out__.write_free_cov_matrix(x_cov);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"theta", "phi", "x_matrix",
      "x_vector", "x_cov"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(3), static_cast<size_t>(2)},
      std::vector<size_t>{static_cast<size_t>(2)},
      std::vector<size_t>{static_cast<size_t>(2), static_cast<size_t>(2)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "theta");
    param_names__.emplace_back(std::string() + "phi");
    for (int sym55__ = 1; sym55__ <= 2; ++sym55__) {
      {
        for (int sym56__ = 1; sym56__ <= 3; ++sym56__) {
          {
            param_names__.emplace_back(std::string() + "x_matrix" + '.' + std::to_string(sym56__) + '.' + std::to_string(sym55__));
          } 
        }
      } 
    }
    for (int sym55__ = 1; sym55__ <= 2; ++sym55__) {
      {
        param_names__.emplace_back(std::string() + "x_vector" + '.' + std::to_string(sym55__));
      } 
    }
    for (int sym55__ = 1; sym55__ <= 2; ++sym55__) {
      {
        for (int sym56__ = 1; sym56__ <= 2; ++sym56__) {
          {
            param_names__.emplace_back(std::string() + "x_cov" + '.' + std::to_string(sym56__) + '.' + std::to_string(sym55__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "theta");
    param_names__.emplace_back(std::string() + "phi");
    for (int sym55__ = 1; sym55__ <= 2; ++sym55__) {
      {
        for (int sym56__ = 1; sym56__ <= 3; ++sym56__) {
          {
            param_names__.emplace_back(std::string() + "x_matrix" + '.' + std::to_string(sym56__) + '.' + std::to_string(sym55__));
          } 
        }
      } 
    }
    for (int sym55__ = 1; sym55__ <= 2; ++sym55__) {
      {
        param_names__.emplace_back(std::string() + "x_vector" + '.' + std::to_string(sym55__));
      } 
    }
    for (int sym55__ = 1; sym55__ <= 3; ++sym55__) {
      {
        param_names__.emplace_back(std::string() + "x_cov" + '.' + std::to_string(sym55__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_matrix\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"x_vector\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"x_cov\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(2) + "},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_matrix\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"x_vector\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"x_cov\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((1 + 1) + (3 * 2)) + 2) + (2 * 2));
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((1 + 1) + (3 * 2)) + 2) + (2 * 2));
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 5> names__{"theta", "phi", "x_matrix",
      "x_vector", "x_cov"};
      const std::array<Eigen::Index, 5> constrain_param_sizes__{1, 1, 
       (3 * 2), 2, (2 * 2)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = optimizations_model_namespace::optimizations_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return optimizations_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp partial-eval.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace partial_eval_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 25> locations_array__ = 
{" (found before start of program)",
 " (in 'partial-eval.stan', line 10, column 2 to column 19)",
 " (in 'partial-eval.stan', line 11, column 2 to column 17)",
 " (in 'partial-eval.stan', line 12, column 2 to column 12)",
 " (in 'partial-eval.stan', line 13, column 2 to column 34)",
 " (in 'partial-eval.stan', line 14, column 2 to column 34)",
 " (in 'partial-eval.stan', line 17, column 2 to column 18)",
 " (in 'partial-eval.stan', line 20, column 4 to line 21, column 42)",
 " (in 'partial-eval.stan', line 19, column 2 to line 21, column 42)",
 " (in 'partial-eval.stan', line 24, column 2 to column 22)",
 " (in 'partial-eval.stan', line 25, column 2 to column 34)",
 " (in 'partial-eval.stan', line 26, column 2 to column 24)",
 " (in 'partial-eval.stan', line 27, column 2 to column 29)",
 " (in 'partial-eval.stan', line 2, column 2 to column 17)",
 " (in 'partial-eval.stan', line 3, column 2 to column 22)",
 " (in 'partial-eval.stan', line 4, column 33 to column 34)",
 " (in 'partial-eval.stan', line 4, column 2 to column 36)",
 " (in 'partial-eval.stan', line 5, column 9 to column 10)",
 " (in 'partial-eval.stan', line 5, column 2 to column 21)",
 " (in 'partial-eval.stan', line 6, column 26 to column 27)",
 " (in 'partial-eval.stan', line 6, column 2 to column 39)",
 " (in 'partial-eval.stan', line 7, column 9 to column 10)",
 " (in 'partial-eval.stan', line 7, column 2 to column 14)",
 " (in 'partial-eval.stan', line 10, column 9 to column 15)",
 " (in 'partial-eval.stan', line 17, column 9 to column 10)"};



class partial_eval_model final : public model_base_crtp<partial_eval_model> {

 private:
  double lcm_sym25__;
  double lcm_sym24__;
  double lcm_sym23__;
  double lcm_sym22__;
  double lcm_sym21__;
  double lcm_sym20__;
  double lcm_sym19__;
  double lcm_sym18__;
  int lcm_sym17__;
  int lcm_sym16__;
  int lcm_sym15__;
  int lcm_sym14__;
  int N;
  int n_pair;
  std::vector<int> pair;
  Eigen::Matrix<double, -1, 1> pre_test__;
  Eigen::Matrix<double, -1, 1> treatment__;
  Eigen::Matrix<double, -1, 1> y__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> pre_test{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> treatment{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> y{nullptr, 0};
 
 public:
  ~partial_eval_model() { }
  
  inline std::string model_name() const final { return "partial_eval_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  partial_eval_model(stan::io::var_context& context__,
                     unsigned int random_seed__ = 0,
                     std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "partial_eval_model_namespace::partial_eval_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 13;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 13;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 13;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 14;
      context__.validate_dims("data initialization","n_pair","int",
           std::vector<size_t>{});
      n_pair = std::numeric_limits<int>::min();
      
      current_statement__ = 14;
      n_pair = context__.vals_i("n_pair")[(1 - 1)];
      current_statement__ = 14;
      check_greater_or_equal(function__, "n_pair", n_pair, 0);
      current_statement__ = 15;
      validate_non_negative_index("pair", "N", N);
      current_statement__ = 16;
      context__.validate_dims("data initialization","pair","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      pair = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 16;
      pair = context__.vals_i("pair");
      lcm_sym14__ = logical_gte(N, 1);
      if (lcm_sym14__) {
        current_statement__ = 16;
        check_greater_or_equal(function__, "pair[sym1__]",
                               rvalue(pair, "pair", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 16;
          check_greater_or_equal(function__, "pair[sym1__]",
                                 pair[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 16;
      if (lcm_sym14__) {
        current_statement__ = 16;
        check_less_or_equal(function__, "pair[sym1__]",
                            rvalue(pair, "pair", index_uni(1)), n_pair);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 16;
          check_less_or_equal(function__, "pair[sym1__]", pair[(sym1__ - 1)],
                              n_pair);
        }
      } 
      current_statement__ = 17;
      validate_non_negative_index("pre_test", "N", N);
      current_statement__ = 18;
      context__.validate_dims("data initialization","pre_test","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      pre_test__ = Eigen::Matrix<double, -1, 1>(N);
      new (&pre_test) Eigen::Map<Eigen::Matrix<double, -1, 1>>(pre_test__.data(), N);
      
      
      {
        std::vector<double> pre_test_flat__;
        current_statement__ = 18;
        pre_test_flat__ = context__.vals_r("pre_test");
        current_statement__ = 18;
        pos__ = 1;
        current_statement__ = 18;
        if (lcm_sym14__) {
          current_statement__ = 18;
          assign(pre_test,
            rvalue(pre_test_flat__, "pre_test_flat__", index_uni(1)),
            "assigning variable pre_test", index_uni(1));
          current_statement__ = 18;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 18;
            assign(pre_test, pre_test_flat__[(pos__ - 1)],
              "assigning variable pre_test", index_uni(sym1__));
            current_statement__ = 18;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 19;
      validate_non_negative_index("treatment", "N", N);
      current_statement__ = 20;
      context__.validate_dims("data initialization","treatment","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      treatment__ = Eigen::Matrix<double, -1, 1>(N);
      new (&treatment) Eigen::Map<Eigen::Matrix<double, -1, 1>>(treatment__.data(), N);
      
      
      {
        std::vector<double> treatment_flat__;
        current_statement__ = 20;
        treatment_flat__ = context__.vals_r("treatment");
        current_statement__ = 20;
        pos__ = 1;
        current_statement__ = 20;
        if (lcm_sym14__) {
          current_statement__ = 20;
          assign(treatment,
            rvalue(treatment_flat__, "treatment_flat__", index_uni(1)),
            "assigning variable treatment", index_uni(1));
          current_statement__ = 20;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 20;
            assign(treatment, treatment_flat__[(pos__ - 1)],
              "assigning variable treatment", index_uni(sym1__));
            current_statement__ = 20;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 20;
      if (lcm_sym14__) {
        current_statement__ = 20;
        check_greater_or_equal(function__, "treatment[sym1__]",
                               rvalue(treatment, "treatment", index_uni(1)),
                               0);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 20;
          check_greater_or_equal(function__, "treatment[sym1__]",
                                 treatment[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 20;
      if (lcm_sym14__) {
        current_statement__ = 20;
        check_less_or_equal(function__, "treatment[sym1__]",
                            rvalue(treatment, "treatment", index_uni(1)), 1);
        for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 20;
          check_less_or_equal(function__, "treatment[sym1__]",
                              treatment[(sym1__ - 1)], 1);
        }
      } 
      current_statement__ = 21;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 22;
      context__.validate_dims("data initialization","y","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      y__ = Eigen::Matrix<double, -1, 1>(N);
      new (&y) Eigen::Map<Eigen::Matrix<double, -1, 1>>(y__.data(), N);
      
      {
        std::vector<double> y_flat__;
        current_statement__ = 22;
        y_flat__ = context__.vals_r("y");
        current_statement__ = 22;
        pos__ = 1;
        current_statement__ = 22;
        if (lcm_sym14__) {
          current_statement__ = 22;
          assign(y, rvalue(y_flat__, "y_flat__", index_uni(1)),
            "assigning variable y", index_uni(1));
          current_statement__ = 22;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 22;
            assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", index_uni(sym1__));
            current_statement__ = 22;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 23;
      validate_non_negative_index("a", "n_pair", n_pair);
      current_statement__ = 24;
      validate_non_negative_index("y_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = n_pair + 2 + 1 + 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "partial_eval_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym13__;
      double lcm_sym12__;
      double lcm_sym11__;
      double lcm_sym10__;
      double lcm_sym9__;
      double lcm_sym8__;
      int lcm_sym7__;
      Eigen::Matrix<local_scalar_t__, -1, 1> a;
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_pair);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      current_statement__ = 2;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(2);
      local_scalar_t__ mu_a;
      current_statement__ = 3;
      mu_a = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma_a;
      current_statement__ = 4;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      local_scalar_t__ sigma_y;
      current_statement__ = 5;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y_hat, DUMMY_VAR__);
      
      current_statement__ = 8;
      if (logical_gte(N, 1)) {
        current_statement__ = 7;
        assign(y_hat,
          stan::math::fma(rvalue(beta, "beta", index_uni(2)),
            rvalue(pre_test, "pre_test", index_uni(1)),
            stan::math::fma(rvalue(beta, "beta", index_uni(1)),
              rvalue(treatment, "treatment", index_uni(1)),
              rvalue(a, "a", index_uni(rvalue(pair, "pair", index_uni(1)))))),
          "assigning variable y_hat", index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 7;
          assign(y_hat,
            stan::math::fma(rvalue(beta, "beta", index_uni(2)),
              rvalue(pre_test, "pre_test", index_uni(i)),
              stan::math::fma(rvalue(beta, "beta", index_uni(1)),
                rvalue(treatment, "treatment", index_uni(i)),
                rvalue(a, "a", index_uni(rvalue(pair, "pair", index_uni(i)))))),
            "assigning variable y_hat", index_uni(i));
        }
      } 
      {
        current_statement__ = 9;
        lp_accum__.add(normal_lpdf<propto__>(mu_a, 0, 1));
        current_statement__ = 10;
        lp_accum__.add(normal_lpdf<propto__>(a, (100 * mu_a), sigma_a));
        current_statement__ = 11;
        lp_accum__.add(normal_lpdf<propto__>(beta, 0, 100));
        current_statement__ = 12;
        lp_accum__.add(normal_lpdf<propto__>(y, y_hat, sigma_y));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "partial_eval_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym6__;
      double lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      Eigen::Matrix<double, -1, 1> a;
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_pair);
      Eigen::Matrix<double, -1, 1> beta;
      current_statement__ = 2;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(2);
      double mu_a;
      current_statement__ = 3;
      mu_a = in__.template read<local_scalar_t__>();
      double sigma_a;
      current_statement__ = 4;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      double sigma_y;
      current_statement__ = 5;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                  0, 100, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y_hat, DUMMY_VAR__);
      
      out__.write(a);
      out__.write(beta);
      out__.write(mu_a);
      out__.write(sigma_a);
      out__.write(sigma_y);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 8;
      if (logical_gte(N, 1)) {
        current_statement__ = 7;
        assign(y_hat,
          stan::math::fma(rvalue(beta, "beta", index_uni(2)),
            rvalue(pre_test, "pre_test", index_uni(1)),
            stan::math::fma(rvalue(beta, "beta", index_uni(1)),
              rvalue(treatment, "treatment", index_uni(1)),
              rvalue(a, "a", index_uni(rvalue(pair, "pair", index_uni(1)))))),
          "assigning variable y_hat", index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 7;
          assign(y_hat,
            stan::math::fma(rvalue(beta, "beta", index_uni(2)),
              rvalue(pre_test, "pre_test", index_uni(i)),
              stan::math::fma(rvalue(beta, "beta", index_uni(1)),
                rvalue(treatment, "treatment", index_uni(i)),
                rvalue(a, "a", index_uni(rvalue(pair, "pair", index_uni(i)))))),
            "assigning variable y_hat", index_uni(i));
        }
      } 
      if (emit_transformed_parameters__) {
        out__.write(y_hat);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, 1> a;
      a = Eigen::Matrix<local_scalar_t__, -1, 1>(n_pair);
      stan::math::fill(a, DUMMY_VAR__);
      
      if (logical_gte(n_pair, 1)) {
        assign(a, in__.read<local_scalar_t__>(),
          "assigning variable a", index_uni(1));
        for (int sym1__ = 2; sym1__ <= n_pair; ++sym1__) {
          assign(a, in__.read<local_scalar_t__>(),
            "assigning variable a", index_uni(sym1__));
        }
      } 
      out__.write(a);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(beta, DUMMY_VAR__);
      
      {
        assign(beta, in__.read<local_scalar_t__>(),
          "assigning variable beta", index_uni(1));
        {
          assign(beta, in__.read<local_scalar_t__>(),
            "assigning variable beta", index_uni(2));
        }
      }
      out__.write(beta);
      local_scalar_t__ mu_a;
      mu_a = in__.read<local_scalar_t__>();
      out__.write(mu_a);
      local_scalar_t__ sigma_a;
      sigma_a = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_a);
      local_scalar_t__ sigma_y;
      sigma_y = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"a", "beta", "mu_a", "sigma_a",
      "sigma_y", "y_hat"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(n_pair)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(2)}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(N)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym26__ = 1; sym26__ <= n_pair; ++sym26__) {
      {
        param_names__.emplace_back(std::string() + "a" + '.' + std::to_string(sym26__));
      } 
    }
    for (int sym26__ = 1; sym26__ <= 2; ++sym26__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym26__));
      } 
    }
    param_names__.emplace_back(std::string() + "mu_a");
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym26__ = 1; sym26__ <= N; ++sym26__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym26__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym26__ = 1; sym26__ <= n_pair; ++sym26__) {
      {
        param_names__.emplace_back(std::string() + "a" + '.' + std::to_string(sym26__));
      } 
    }
    for (int sym26__ = 1; sym26__ <= 2; ++sym26__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym26__));
      } 
    }
    param_names__.emplace_back(std::string() + "mu_a");
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym26__ = 1; sym26__ <= N; ++sym26__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym26__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_pair) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"mu_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_pair) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"mu_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((n_pair + 2) + 1) + 1) + 1);
      const size_t num_transformed = N;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((n_pair + 2) + 1) + 1) + 1);
      const size_t num_transformed = N;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 5> names__{"a", "beta", "mu_a",
      "sigma_a", "sigma_y"};
      const std::array<Eigen::Index, 5> constrain_param_sizes__{n_pair, 
       2, 1, 1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = partial_eval_model_namespace::partial_eval_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return partial_eval_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp stalled1-failure.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace stalled1_failure_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 33> locations_array__ = 
{" (found before start of program)",
 " (in 'stalled1-failure.stan', line 30, column 4 to column 16)",
 " (in 'stalled1-failure.stan', line 31, column 4 to column 16)",
 " (in 'stalled1-failure.stan', line 32, column 4 to column 16)",
 " (in 'stalled1-failure.stan', line 33, column 4 to column 17)",
 " (in 'stalled1-failure.stan', line 34, column 4 to column 22)",
 " (in 'stalled1-failure.stan', line 35, column 4 to column 19)",
 " (in 'stalled1-failure.stan', line 39, column 4 to column 15)",
 " (in 'stalled1-failure.stan', line 44, column 3 to column 31)",
 " (in 'stalled1-failure.stan', line 45, column 3 to column 31)",
 " (in 'stalled1-failure.stan', line 46, column 3 to column 31)",
 " (in 'stalled1-failure.stan', line 47, column 3 to column 32)",
 " (in 'stalled1-failure.stan', line 48, column 3 to column 31)",
 " (in 'stalled1-failure.stan', line 50, column 6 to column 32)",
 " (in 'stalled1-failure.stan', line 51, column 6 to column 103)",
 " (in 'stalled1-failure.stan', line 49, column 18 to line 52, column 4)",
 " (in 'stalled1-failure.stan', line 49, column 3 to line 52, column 4)",
 " (in 'stalled1-failure.stan', line 15, column 4 to column 19)",
 " (in 'stalled1-failure.stan', line 16, column 19 to column 20)",
 " (in 'stalled1-failure.stan', line 16, column 4 to column 22)",
 " (in 'stalled1-failure.stan', line 17, column 19 to column 20)",
 " (in 'stalled1-failure.stan', line 17, column 4 to column 22)",
 " (in 'stalled1-failure.stan', line 18, column 11 to column 12)",
 " (in 'stalled1-failure.stan', line 18, column 4 to column 17)",
 " (in 'stalled1-failure.stan', line 19, column 11 to column 12)",
 " (in 'stalled1-failure.stan', line 19, column 4 to column 17)",
 " (in 'stalled1-failure.stan', line 23, column 4 to column 10)",
 " (in 'stalled1-failure.stan', line 24, column 11 to column 12)",
 " (in 'stalled1-failure.stan', line 24, column 4 to column 19)",
 " (in 'stalled1-failure.stan', line 25, column 4 to column 11)",
 " (in 'stalled1-failure.stan', line 26, column 4 to column 21)",
 " (in 'stalled1-failure.stan', line 35, column 16 to column 17)",
 " (in 'stalled1-failure.stan', line 35, column 11 to column 12)"};



class stalled1_failure_model final : public model_base_crtp<stalled1_failure_model> {

 private:
  double lcm_sym31__;
  double lcm_sym30__;
  double lcm_sym29__;
  double lcm_sym28__;
  int lcm_sym27__;
  int lcm_sym26__;
  int lcm_sym25__;
  int lcm_sym24__;
  int lcm_sym23__;
  int lcm_sym22__;
  Eigen::Matrix<double, -1, 1> lcm_sym21____;
  int I;
  std::vector<int> n;
  std::vector<int> N;
  Eigen::Matrix<double, -1, 1> x1__;
  Eigen::Matrix<double, -1, 1> x2__;
  int K;
  Eigen::Matrix<double, -1, 1> x1x2__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> lcm_sym21__{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> x1{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> x2{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> x1x2{nullptr, 0};
 
 public:
  ~stalled1_failure_model() { }
  
  inline std::string model_name() const final { return "stalled1_failure_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  stalled1_failure_model(stan::io::var_context& context__,
                         unsigned int random_seed__ = 0,
                         std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "stalled1_failure_model_namespace::stalled1_failure_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      
      
      
      
      
      
      
      
      
      
      
      int pos__;
      pos__ = 1;
      current_statement__ = 17;
      context__.validate_dims("data initialization","I","int",
           std::vector<size_t>{});
      I = std::numeric_limits<int>::min();
      
      current_statement__ = 17;
      I = context__.vals_i("I")[(1 - 1)];
      current_statement__ = 17;
      check_greater_or_equal(function__, "I", I, 0);
      current_statement__ = 18;
      validate_non_negative_index("n", "I", I);
      current_statement__ = 19;
      context__.validate_dims("data initialization","n","int",
           std::vector<size_t>{static_cast<size_t>(I)});
      n = std::vector<int>(I, std::numeric_limits<int>::min());
      
      current_statement__ = 19;
      n = context__.vals_i("n");
      lcm_sym22__ = logical_gte(I, 1);
      if (lcm_sym22__) {
        current_statement__ = 19;
        check_greater_or_equal(function__, "n[sym1__]",
                               rvalue(n, "n", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= I; ++sym1__) {
          current_statement__ = 19;
          check_greater_or_equal(function__, "n[sym1__]", n[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 20;
      validate_non_negative_index("N", "I", I);
      current_statement__ = 21;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{static_cast<size_t>(I)});
      N = std::vector<int>(I, std::numeric_limits<int>::min());
      
      current_statement__ = 21;
      N = context__.vals_i("N");
      current_statement__ = 21;
      if (lcm_sym22__) {
        current_statement__ = 21;
        check_greater_or_equal(function__, "N[sym1__]",
                               rvalue(N, "N", index_uni(1)), 0);
        for (int sym1__ = 2; sym1__ <= I; ++sym1__) {
          current_statement__ = 21;
          check_greater_or_equal(function__, "N[sym1__]", N[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 22;
      validate_non_negative_index("x1", "I", I);
      current_statement__ = 23;
      context__.validate_dims("data initialization","x1","double",
           std::vector<size_t>{static_cast<size_t>(I)});
      x1__ = Eigen::Matrix<double, -1, 1>(I);
      new (&x1) Eigen::Map<Eigen::Matrix<double, -1, 1>>(x1__.data(), I);
      
      {
        std::vector<double> x1_flat__;
        current_statement__ = 23;
        x1_flat__ = context__.vals_r("x1");
        current_statement__ = 23;
        pos__ = 1;
        current_statement__ = 23;
        if (lcm_sym22__) {
          current_statement__ = 23;
          assign(x1, rvalue(x1_flat__, "x1_flat__", index_uni(1)),
            "assigning variable x1", index_uni(1));
          current_statement__ = 23;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= I; ++sym1__) {
            current_statement__ = 23;
            assign(x1, x1_flat__[(pos__ - 1)],
              "assigning variable x1", index_uni(sym1__));
            current_statement__ = 23;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 24;
      validate_non_negative_index("x2", "I", I);
      current_statement__ = 25;
      context__.validate_dims("data initialization","x2","double",
           std::vector<size_t>{static_cast<size_t>(I)});
      x2__ = Eigen::Matrix<double, -1, 1>(I);
      new (&x2) Eigen::Map<Eigen::Matrix<double, -1, 1>>(x2__.data(), I);
      
      {
        std::vector<double> x2_flat__;
        current_statement__ = 25;
        x2_flat__ = context__.vals_r("x2");
        current_statement__ = 25;
        pos__ = 1;
        current_statement__ = 25;
        if (lcm_sym22__) {
          current_statement__ = 25;
          assign(x2, rvalue(x2_flat__, "x2_flat__", index_uni(1)),
            "assigning variable x2", index_uni(1));
          current_statement__ = 25;
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= I; ++sym1__) {
            current_statement__ = 25;
            assign(x2, x2_flat__[(pos__ - 1)],
              "assigning variable x2", index_uni(sym1__));
            current_statement__ = 25;
            pos__ = (pos__ + 1);
          }
        } 
      }
      current_statement__ = 26;
      K = std::numeric_limits<int>::min();
      
      current_statement__ = 27;
      validate_non_negative_index("x1x2", "I", I);
      current_statement__ = 28;
      x1x2__ = Eigen::Matrix<double, -1, 1>(I);
      new (&x1x2) Eigen::Map<Eigen::Matrix<double, -1, 1>>(x1x2__.data(), I);
      stan::math::fill(x1x2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 29;
      K = 8;
      current_statement__ = 30;
      assign(x1x2, elt_multiply(x1, x2), "assigning variable x1x2");
      current_statement__ = 31;
      validate_non_negative_index("b", "I", I);
      current_statement__ = 32;
      validate_non_negative_index("b", "K", 8);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + 1 + (I * K);
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "stalled1_failure_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      double lcm_sym12__;
      int lcm_sym11__;
      local_scalar_t__ lcm_sym10__;
      local_scalar_t__ alpha0;
      current_statement__ = 1;
      alpha0 = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha1;
      current_statement__ = 2;
      alpha1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha2;
      current_statement__ = 3;
      alpha2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha12;
      current_statement__ = 4;
      alpha12 = in__.template read<local_scalar_t__>();
      local_scalar_t__ tau;
      current_statement__ = 5;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> b;
      current_statement__ = 6;
      b = in__.template read<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(
            I, 8);
      local_scalar_t__ sigma;
      lcm_sym10__ = (1 / stan::math::sqrt(tau));
      sigma = lcm_sym10__;
      {
        current_statement__ = 8;
        lp_accum__.add(normal_lpdf<propto__>(alpha0, 0.0, 1.0E3));
        current_statement__ = 9;
        lp_accum__.add(normal_lpdf<propto__>(alpha1, 0.0, 1.0E3));
        current_statement__ = 10;
        lp_accum__.add(normal_lpdf<propto__>(alpha2, 0.0, 1.0E3));
        current_statement__ = 11;
        lp_accum__.add(normal_lpdf<propto__>(alpha12, 0.0, 1.0E3));
        current_statement__ = 12;
        lp_accum__.add(gamma_lpdf<propto__>(tau, 1.0E-3, 1.0E-3));
        current_statement__ = 16;
        if (logical_gte(I, 1)) {
          current_statement__ = 13;
          lp_accum__.add(
            normal_lpdf<propto__>(rvalue(b, "b", index_uni(1)), 0.0,
              lcm_sym10__));
          current_statement__ = 14;
          lp_accum__.add(
            binomial_logit_lpmf<propto__>(rvalue(n, "n", index_uni(1)),
              rvalue(N, "N", index_uni(1)),
              add(
                stan::math::fma(alpha12,
                  rvalue(elt_multiply(x1, x2), "(x1 .* x2)", index_uni(1)),
                  stan::math::fma(alpha2, rvalue(x2, "x2", index_uni(1)),
                    stan::math::fma(alpha1, rvalue(x1, "x1", index_uni(1)),
                      alpha0))), rvalue(b, "b", index_uni(1)))));
          for (int i = 2; i <= I; ++i) {
            current_statement__ = 13;
            lp_accum__.add(
              normal_lpdf<propto__>(rvalue(b, "b", index_uni(i)), 0.0,
                lcm_sym10__));
            current_statement__ = 14;
            lp_accum__.add(
              binomial_logit_lpmf<propto__>(rvalue(n, "n", index_uni(i)),
                rvalue(N, "N", index_uni(i)),
                add(
                  stan::math::fma(alpha12,
                    rvalue(elt_multiply(x1, x2), "(x1 .* x2)", index_uni(i)),
                    stan::math::fma(alpha2, rvalue(x2, "x2", index_uni(i)),
                      stan::math::fma(alpha1, rvalue(x1, "x1", index_uni(i)),
                        alpha0))), rvalue(b, "b", index_uni(i)))));
          }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "stalled1_failure_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double lcm_sym9__;
      double lcm_sym8__;
      double lcm_sym7__;
      double lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      double lcm_sym2__;
      double alpha0;
      current_statement__ = 1;
      alpha0 = in__.template read<local_scalar_t__>();
      double alpha1;
      current_statement__ = 2;
      alpha1 = in__.template read<local_scalar_t__>();
      double alpha2;
      current_statement__ = 3;
      alpha2 = in__.template read<local_scalar_t__>();
      double alpha12;
      current_statement__ = 4;
      alpha12 = in__.template read<local_scalar_t__>();
      double tau;
      current_statement__ = 5;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      std::vector<Eigen::Matrix<double, -1, 1>> b;
      current_statement__ = 6;
      b = in__.template read<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(
            I, 8);
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      out__.write(alpha0);
      out__.write(alpha1);
      out__.write(alpha2);
      out__.write(alpha12);
      out__.write(tau);
      {
        lcm_sym3__ = logical_gte(I, 1);
        if (lcm_sym3__) {
          out__.write(rvalue(b, "b", index_uni(1), index_uni(1)));
          for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
            out__.write(rvalue(b, "b", index_uni(sym2__), index_uni(1)));
          }
        } 
        {
          if (lcm_sym3__) {
            out__.write(rvalue(b, "b", index_uni(1), index_uni(2)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(rvalue(b, "b", index_uni(sym2__), index_uni(2)));
            }
          } 
        }
        {
          if (lcm_sym3__) {
            out__.write(rvalue(b, "b", index_uni(1), index_uni(3)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(rvalue(b, "b", index_uni(sym2__), index_uni(3)));
            }
          } 
        }
        {
          if (lcm_sym3__) {
            out__.write(rvalue(b, "b", index_uni(1), index_uni(4)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(rvalue(b, "b", index_uni(sym2__), index_uni(4)));
            }
          } 
        }
        {
          if (lcm_sym3__) {
            out__.write(rvalue(b, "b", index_uni(1), index_uni(5)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(rvalue(b, "b", index_uni(sym2__), index_uni(5)));
            }
          } 
        }
        {
          if (lcm_sym3__) {
            out__.write(rvalue(b, "b", index_uni(1), index_uni(6)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(rvalue(b, "b", index_uni(sym2__), index_uni(6)));
            }
          } 
        }
        {
          if (lcm_sym3__) {
            out__.write(rvalue(b, "b", index_uni(1), index_uni(7)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(rvalue(b, "b", index_uni(sym2__), index_uni(7)));
            }
          } 
        }
        {
          if (lcm_sym3__) {
            out__.write(rvalue(b, "b", index_uni(1), index_uni(8)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(rvalue(b, "b", index_uni(sym2__), index_uni(8)));
            }
          } 
        }
      }
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym2__ = (1 / stan::math::sqrt(tau));
      sigma = lcm_sym2__;
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym2__);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ alpha0;
      alpha0 = in__.read<local_scalar_t__>();
      out__.write(alpha0);
      local_scalar_t__ alpha1;
      alpha1 = in__.read<local_scalar_t__>();
      out__.write(alpha1);
      local_scalar_t__ alpha2;
      alpha2 = in__.read<local_scalar_t__>();
      out__.write(alpha2);
      local_scalar_t__ alpha12;
      alpha12 = in__.read<local_scalar_t__>();
      out__.write(alpha12);
      local_scalar_t__ tau;
      tau = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> b;
      b = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(I, Eigen::Matrix<local_scalar_t__, -1, 1>(8));
      stan::math::fill(b, DUMMY_VAR__);
      
      {
        lcm_sym1__ = logical_gte(I, 1);
        if (lcm_sym1__) {
          assign(b, in__.read<local_scalar_t__>(),
            "assigning variable b", index_uni(1), index_uni(1));
          for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
            assign(b, in__.read<local_scalar_t__>(),
              "assigning variable b", index_uni(sym2__), index_uni(1));
          }
        } 
        {
          if (lcm_sym1__) {
            assign(b, in__.read<local_scalar_t__>(),
              "assigning variable b", index_uni(1), index_uni(2));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              assign(b, in__.read<local_scalar_t__>(),
                "assigning variable b", index_uni(sym2__), index_uni(2));
            }
          } 
        }
        {
          if (lcm_sym1__) {
            assign(b, in__.read<local_scalar_t__>(),
              "assigning variable b", index_uni(1), index_uni(3));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              assign(b, in__.read<local_scalar_t__>(),
                "assigning variable b", index_uni(sym2__), index_uni(3));
            }
          } 
        }
        {
          if (lcm_sym1__) {
            assign(b, in__.read<local_scalar_t__>(),
              "assigning variable b", index_uni(1), index_uni(4));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              assign(b, in__.read<local_scalar_t__>(),
                "assigning variable b", index_uni(sym2__), index_uni(4));
            }
          } 
        }
        {
          if (lcm_sym1__) {
            assign(b, in__.read<local_scalar_t__>(),
              "assigning variable b", index_uni(1), index_uni(5));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              assign(b, in__.read<local_scalar_t__>(),
                "assigning variable b", index_uni(sym2__), index_uni(5));
            }
          } 
        }
        {
          if (lcm_sym1__) {
            assign(b, in__.read<local_scalar_t__>(),
              "assigning variable b", index_uni(1), index_uni(6));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              assign(b, in__.read<local_scalar_t__>(),
                "assigning variable b", index_uni(sym2__), index_uni(6));
            }
          } 
        }
        {
          if (lcm_sym1__) {
            assign(b, in__.read<local_scalar_t__>(),
              "assigning variable b", index_uni(1), index_uni(7));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              assign(b, in__.read<local_scalar_t__>(),
                "assigning variable b", index_uni(sym2__), index_uni(7));
            }
          } 
        }
        {
          if (lcm_sym1__) {
            assign(b, in__.read<local_scalar_t__>(),
              "assigning variable b", index_uni(1), index_uni(8));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              assign(b, in__.read<local_scalar_t__>(),
                "assigning variable b", index_uni(sym2__), index_uni(8));
            }
          } 
        }
      }
      out__.write(b);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"alpha0", "alpha1", "alpha2",
      "alpha12", "tau", "b", "sigma"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(I), static_cast<size_t>(K)},
      std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha0");
    param_names__.emplace_back(std::string() + "alpha1");
    param_names__.emplace_back(std::string() + "alpha2");
    param_names__.emplace_back(std::string() + "alpha12");
    param_names__.emplace_back(std::string() + "tau");
    for (int sym32__ = 1; sym32__ <= K; ++sym32__) {
      {
        for (int sym33__ = 1; sym33__ <= I; ++sym33__) {
          {
            param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym33__) + '.' + std::to_string(sym32__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha0");
    param_names__.emplace_back(std::string() + "alpha1");
    param_names__.emplace_back(std::string() + "alpha2");
    param_names__.emplace_back(std::string() + "alpha12");
    param_names__.emplace_back(std::string() + "tau");
    for (int sym32__ = 1; sym32__ <= K; ++sym32__) {
      {
        for (int sym33__ = 1; sym33__ <= I; ++sym33__) {
          {
            param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym33__) + '.' + std::to_string(sym32__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha12\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(I) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha12\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(I) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((1 + 1) + 1) + 1) + 1) + (I * K));
      const size_t num_transformed = 1;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((1 + 1) + 1) + 1) + 1) + (I * K));
      const size_t num_transformed = 1;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 6> names__{"alpha0", "alpha1",
      "alpha2", "alpha12", "tau", "b"};
      const std::array<Eigen::Index, 6> constrain_param_sizes__{1, 1, 
       1, 1, 1, (I * K)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = stalled1_failure_model_namespace::stalled1_failure_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return stalled1_failure_model_namespace::profiles__;
}

#endif



Warning in 'stalled1-failure.stan', line 1, column 0: Comments beginning with # are deprecated. Please use // in place of # for line comments.
Warning in 'stalled1-failure.stan', line 2, column 0: Comments beginning with # are deprecated. Please use // in place of # for line comments.
Warning in 'stalled1-failure.stan', line 4, column 0: Comments beginning with # are deprecated. Please use // in place of # for line comments.
Warning in 'stalled1-failure.stan', line 5, column 0: Comments beginning with # are deprecated. Please use // in place of # for line comments.
Warning in 'stalled1-failure.stan', line 6, column 0: Comments beginning with # are deprecated. Please use // in place of # for line comments.
Warning in 'stalled1-failure.stan', line 7, column 0: Comments beginning with # are deprecated. Please use // in place of # for line comments.
Warning in 'stalled1-failure.stan', line 8, column 0: Comments beginning with # are deprecated. Please use // in place of # for line comments.
Warning in 'stalled1-failure.stan', line 9, column 0: Comments beginning with # are deprecated. Please use // in place of # for line comments.
Warning in 'stalled1-failure.stan', line 10, column 0: Comments beginning with # are deprecated. Please use // in place of # for line comments.
Warning in 'stalled1-failure.stan', line 11, column 0: Comments beginning with # are deprecated. Please use // in place of # for line comments.
Warning in 'stalled1-failure.stan', line 25, column 6: assignment operator <- is deprecated in the Stan language; use = instead.
Warning in 'stalled1-failure.stan', line 26, column 9: assignment operator <- is deprecated in the Stan language; use = instead.
Warning in 'stalled1-failure.stan', line 40, column 10: assignment operator <- is deprecated in the Stan language; use = instead.
  $ ../../../../../install/default/bin/stanc --O --print-cpp unroll-limit.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace unroll_limit_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 14> locations_array__ = 
{" (found before start of program)",
 " (in 'unroll-limit.stan', line 2, column 2 to column 8)",
 " (in 'unroll-limit.stan', line 4, column 4 to column 15)",
 " (in 'unroll-limit.stan', line 3, column 19 to line 5, column 3)",
 " (in 'unroll-limit.stan', line 3, column 2 to line 5, column 3)",
 " (in 'unroll-limit.stan', line 7, column 4 to column 15)",
 " (in 'unroll-limit.stan', line 6, column 2 to line 8, column 3)",
 " (in 'unroll-limit.stan', line 10, column 4 to column 15)",
 " (in 'unroll-limit.stan', line 9, column 2 to line 11, column 3)",
 " (in 'unroll-limit.stan', line 13, column 4 to column 15)",
 " (in 'unroll-limit.stan', line 12, column 2 to line 14, column 3)",
 " (in 'unroll-limit.stan', line 16, column 4 to column 15)",
 " (in 'unroll-limit.stan', line 15, column 20 to line 17, column 3)",
 " (in 'unroll-limit.stan', line 15, column 2 to line 17, column 3)"};



class unroll_limit_model final : public model_base_crtp<unroll_limit_model> {

 private:
   
  
 
 public:
  ~unroll_limit_model() { }
  
  inline std::string model_name() const final { return "unroll_limit_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  unroll_limit_model(stan::io::var_context& context__,
                     unsigned int random_seed__ = 0,
                     std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    static constexpr bool propto__ = true;
    (void) propto__;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "unroll_limit_model_namespace::unroll_limit_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "unroll_limit_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "unroll_limit_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      int lcm_sym12__;
      int lcm_sym11__;
      int lcm_sym10__;
      int lcm_sym9__;
      int lcm_sym8__;
      int lcm_sym7__;
      int lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      int x;
      {
        current_statement__ = 2;
        x = (x + 2);
        for (int i = 2; i <= 100; ++i) {
          current_statement__ = 2;
          x = (x + (1 + i));
        }
      }
      {
        current_statement__ = 5;
        x = (x + 3);
        {
          current_statement__ = 5;
          x = (x + (2 + 2));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 3));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 4));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 5));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 6));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 7));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 8));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 9));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 10));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 11));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 12));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 13));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 14));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 15));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 16));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 17));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 18));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 19));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 20));
        }
      }
      {
        current_statement__ = 7;
        x = (x + 53);
        {
          current_statement__ = 7;
          x = (x + (3 + 51));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 52));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 53));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 54));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 55));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 56));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 57));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 58));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 59));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 60));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 61));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 62));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 63));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 64));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 65));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 66));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 67));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 68));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 69));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 70));
        }
      }
      {
        current_statement__ = 9;
        x = (x + -6);
        {
          current_statement__ = 9;
          x = (x + (4 + -9));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -8));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -7));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -6));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -5));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -4));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -3));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -2));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -1));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 0));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 1));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 2));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 3));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 4));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 5));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 6));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 7));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 8));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 9));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 10));
        }
      }
      {
        current_statement__ = 11;
        x = (x + -5);
        for (int i = -9; i <= 40; ++i) {
          current_statement__ = 11;
          x = (x + (5 + i));
        }
      }
      out__.write(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__;
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"x"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "x");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "x");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 1;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 1;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 0> names__{};
      const std::array<Eigen::Index, 0> constrain_param_sizes__{};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = unroll_limit_model_namespace::unroll_limit_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return unroll_limit_model_namespace::profiles__;
}

#endif



