  $ ../../../../../install/default/bin/stanc --O --print-cpp ad-level-deep-dependence.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace ad_level_deep_dependence_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 11> locations_array__ =
  {" (found before start of program)",
  " (in 'ad-level-deep-dependence.stan', line 10, column 4 to column 23)",
  " (in 'ad-level-deep-dependence.stan', line 14, column 4 to column 31)",
  " (in 'ad-level-deep-dependence.stan', line 15, column 4 to column 38)",
  " (in 'ad-level-deep-dependence.stan', line 16, column 4 to column 38)",
  " (in 'ad-level-deep-dependence.stan', line 17, column 4 to column 38)",
  " (in 'ad-level-deep-dependence.stan', line 18, column 4 to column 38)",
  " (in 'ad-level-deep-dependence.stan', line 19, column 4 to column 38)",
  " (in 'ad-level-deep-dependence.stan', line 20, column 4 to column 38)",
  " (in 'ad-level-deep-dependence.stan', line 21, column 4 to column 16)",
  " (in 'ad-level-deep-dependence.stan', line 7, column 4 to column 23)"};
class ad_level_deep_dependence_model final : public model_base_crtp<ad_level_deep_dependence_model> {
 private:
  double lcm_sym26__;
  double lcm_sym25__;
  int lcm_sym24__;
  Eigen::Matrix<double,-1,-1> X_d_data__;
  Eigen::Map<Eigen::Matrix<double,-1,-1>> X_d{nullptr, 0, 0};
 public:
  ~ad_level_deep_dependence_model() {}
  ad_level_deep_dependence_model(stan::io::var_context& context__,
                                 unsigned int random_seed__ = 0,
                                 std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "ad_level_deep_dependence_model_namespace::ad_level_deep_dependence_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 10;
      context__.validate_dims("data initialization", "X_d", "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      X_d_data__ = Eigen::Matrix<double,-1,-1>::Constant(10, 10,
                     std::numeric_limits<double>::quiet_NaN());
      new (&X_d) Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_d_data__.data(),
        10, 10);
      {
        std::vector<double> X_d_flat__;
        current_statement__ = 10;
        X_d_flat__ = context__.vals_r("X_d");
        pos__ = 1;
        {
          {
            stan::model::assign(X_d,
              stan::model::rvalue(X_d_flat__, "X_d_flat__",
                stan::model::index_uni(1)), "assigning variable X_d",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(2),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(3),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(4),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(5),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(6),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(7),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(8),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(9),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(10),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
              "assigning variable X_d", stan::model::index_uni(1),
              stan::model::index_uni(2));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(2),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(3),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(4),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(5),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(6),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(7),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(8),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(9),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(10),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
              "assigning variable X_d", stan::model::index_uni(1),
              stan::model::index_uni(3));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(2),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(3),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(4),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(5),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(6),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(7),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(8),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(9),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(10),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
              "assigning variable X_d", stan::model::index_uni(1),
              stan::model::index_uni(4));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(2),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(3),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(4),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(5),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(6),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(7),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(8),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(9),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(10),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
              "assigning variable X_d", stan::model::index_uni(1),
              stan::model::index_uni(5));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(2),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(3),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(4),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(5),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(6),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(7),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(8),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(9),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(10),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
              "assigning variable X_d", stan::model::index_uni(1),
              stan::model::index_uni(6));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(2),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(3),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(4),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(5),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(6),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(7),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(8),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(9),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(10),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
              "assigning variable X_d", stan::model::index_uni(1),
              stan::model::index_uni(7));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(2),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(3),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(4),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(5),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(6),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(7),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(8),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(9),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(10),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
              "assigning variable X_d", stan::model::index_uni(1),
              stan::model::index_uni(8));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(2),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(3),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(4),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(5),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(6),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(7),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(8),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(9),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(10),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
              "assigning variable X_d", stan::model::index_uni(1),
              stan::model::index_uni(9));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(2),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(3),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(4),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(5),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(6),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(7),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(8),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(9),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(10),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
              "assigning variable X_d", stan::model::index_uni(1),
              stan::model::index_uni(10));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(2),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(3),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(4),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(5),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(6),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(7),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(8),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(9),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
                "assigning variable X_d", stan::model::index_uni(10),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (10 * 10);
  }
  inline std::string model_name() const final {
    return "ad_level_deep_dependence_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "ad_level_deep_dependence_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> lcm_sym23__;
      Eigen::Matrix<double,-1,-1> lcm_sym22__;
      Eigen::Matrix<double,-1,-1> lcm_sym21__;
      Eigen::Matrix<double,-1,-1> lcm_sym20__;
      Eigen::Matrix<double,-1,-1> lcm_sym19__;
      Eigen::Matrix<double,-1,-1> lcm_sym18__;
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p;
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp1;
      current_statement__ = 2;
      stan::model::assign(X_tp1, X_d, "assigning variable X_tp1");
      Eigen::Matrix<double,-1,-1> X_tp2 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      stan::model::assign(lcm_sym18__, stan::math::exp(X_d),
        "assigning variable lcm_sym18__");
      stan::model::assign(X_tp2, lcm_sym18__, "assigning variable X_tp2");
      Eigen::Matrix<double,-1,-1> X_tp3 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      stan::model::assign(lcm_sym19__, stan::math::exp(lcm_sym18__),
        "assigning variable lcm_sym19__");
      stan::model::assign(X_tp3, lcm_sym19__, "assigning variable X_tp3");
      Eigen::Matrix<double,-1,-1> X_tp4 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      stan::model::assign(lcm_sym20__, stan::math::exp(lcm_sym19__),
        "assigning variable lcm_sym20__");
      stan::model::assign(X_tp4, lcm_sym20__, "assigning variable X_tp4");
      Eigen::Matrix<double,-1,-1> X_tp5 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      stan::model::assign(lcm_sym21__, stan::math::exp(lcm_sym20__),
        "assigning variable lcm_sym21__");
      stan::model::assign(X_tp5, lcm_sym21__, "assigning variable X_tp5");
      Eigen::Matrix<double,-1,-1> X_tp6 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      stan::model::assign(lcm_sym22__, stan::math::exp(lcm_sym21__),
        "assigning variable lcm_sym22__");
      stan::model::assign(X_tp6, lcm_sym22__, "assigning variable X_tp6");
      Eigen::Matrix<double,-1,-1> X_tp7;
      current_statement__ = 8;
      stan::model::assign(X_tp7, stan::math::exp(lcm_sym22__),
        "assigning variable X_tp7");
      current_statement__ = 9;
      stan::model::assign(X_tp1, X_p, "assigning variable X_tp1");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "ad_level_deep_dependence_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> lcm_sym17__;
      Eigen::Matrix<double,-1,-1> lcm_sym16__;
      Eigen::Matrix<double,-1,-1> lcm_sym15__;
      Eigen::Matrix<double,-1,-1> lcm_sym14__;
      Eigen::Matrix<double,-1,-1> lcm_sym13__;
      Eigen::Matrix<double,-1,-1> lcm_sym12__;
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> X_p;
      current_statement__ = 1;
      X_p = in__.template read<
              stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(10, 10);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> X_tp1;
      current_statement__ = 2;
      stan::model::assign(X_tp1, X_d, "assigning variable X_tp1");
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> X_tp2 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      stan::model::assign(lcm_sym12__, stan::math::exp(X_d),
        "assigning variable lcm_sym12__");
      stan::model::assign(X_tp2, lcm_sym12__, "assigning variable X_tp2");
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> X_tp3 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      stan::model::assign(lcm_sym13__, stan::math::exp(lcm_sym12__),
        "assigning variable lcm_sym13__");
      stan::model::assign(X_tp3, lcm_sym13__, "assigning variable X_tp3");
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> X_tp4 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      stan::model::assign(lcm_sym14__, stan::math::exp(lcm_sym13__),
        "assigning variable lcm_sym14__");
      stan::model::assign(X_tp4, lcm_sym14__, "assigning variable X_tp4");
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> X_tp5 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      stan::model::assign(lcm_sym15__, stan::math::exp(lcm_sym14__),
        "assigning variable lcm_sym15__");
      stan::model::assign(X_tp5, lcm_sym15__, "assigning variable X_tp5");
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> X_tp6 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      stan::model::assign(lcm_sym16__, stan::math::exp(lcm_sym15__),
        "assigning variable lcm_sym16__");
      stan::model::assign(X_tp6, lcm_sym16__, "assigning variable X_tp6");
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> X_tp7;
      current_statement__ = 8;
      stan::model::assign(X_tp7, stan::math::exp(lcm_sym16__),
        "assigning variable X_tp7");
      current_statement__ = 9;
      stan::model::assign(X_tp1, X_p, "assigning variable X_tp1");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "ad_level_deep_dependence_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> lcm_sym11__;
      Eigen::Matrix<double,-1,-1> lcm_sym10__;
      Eigen::Matrix<double,-1,-1> lcm_sym9__;
      Eigen::Matrix<double,-1,-1> lcm_sym8__;
      Eigen::Matrix<double,-1,-1> lcm_sym7__;
      Eigen::Matrix<double,-1,-1> lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      Eigen::Matrix<double,-1,-1> X_p;
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<double,-1,-1> X_tp1 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp2 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp3 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp4 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp5 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp6 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp7 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(X_p);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 2;
      stan::model::assign(X_tp1, X_d, "assigning variable X_tp1");
      stan::model::assign(lcm_sym6__, stan::math::exp(X_d),
        "assigning variable lcm_sym6__");
      stan::model::assign(X_tp2, lcm_sym6__, "assigning variable X_tp2");
      stan::model::assign(lcm_sym7__, stan::math::exp(lcm_sym6__),
        "assigning variable lcm_sym7__");
      stan::model::assign(X_tp3, lcm_sym7__, "assigning variable X_tp3");
      stan::model::assign(lcm_sym8__, stan::math::exp(lcm_sym7__),
        "assigning variable lcm_sym8__");
      stan::model::assign(X_tp4, lcm_sym8__, "assigning variable X_tp4");
      stan::model::assign(lcm_sym9__, stan::math::exp(lcm_sym8__),
        "assigning variable lcm_sym9__");
      stan::model::assign(X_tp5, lcm_sym9__, "assigning variable X_tp5");
      stan::model::assign(lcm_sym10__, stan::math::exp(lcm_sym9__),
        "assigning variable lcm_sym10__");
      stan::model::assign(X_tp6, lcm_sym10__, "assigning variable X_tp6");
      stan::model::assign(lcm_sym11__, stan::math::exp(lcm_sym10__),
        "assigning variable lcm_sym11__");
      stan::model::assign(X_tp7, lcm_sym11__, "assigning variable X_tp7");
      current_statement__ = 9;
      stan::model::assign(X_tp1, X_p, "assigning variable X_tp1");
      if (emit_transformed_parameters__) {
        out__.write(X_p);
        out__.write(lcm_sym6__);
        out__.write(lcm_sym7__);
        out__.write(lcm_sym8__);
        out__.write(lcm_sym9__);
        out__.write(lcm_sym10__);
        out__.write(lcm_sym11__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p;
      current_statement__ = 1;
      stan::model::assign(X_p,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10),
        "assigning variable X_p");
      out__.write(X_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "X_p", "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      double lcm_sym3__;
      double lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      {
        std::vector<double> X_p_flat__;
        current_statement__ = 1;
        X_p_flat__ = context__.vals_r("X_p");
        pos__ = 1;
        {
          {
            stan::model::assign(X_p,
              stan::model::rvalue(X_p_flat__, "X_p_flat__",
                stan::model::index_uni(1)), "assigning variable X_p",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(2));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(3));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(4));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(5));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(6));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(7));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(8));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(9));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(10));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(X_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"X_p"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"X_tp1", "X_tp2", "X_tp3", "X_tp4", "X_tp5", "X_tp6", "X_tp7"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    10),
                                                 static_cast<size_t>(10)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
      for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
        param_names__.emplace_back(std::string() + "X_p" + '.' +
          std::to_string(sym28__) + '.' + std::to_string(sym27__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp1" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp2" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp3" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp4" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp5" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp6" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp7" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
      for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
        param_names__.emplace_back(std::string() + "X_p" + '.' +
          std::to_string(sym28__) + '.' + std::to_string(sym27__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp1" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp2" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp3" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp4" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp5" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp6" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
      for (int sym27__ = 1; sym27__ <= 10; ++sym27__) {
        for (int sym28__ = 1; sym28__ <= 10; ++sym28__) {
          param_names__.emplace_back(std::string() + "X_tp7" + '.' +
            std::to_string(sym28__) + '.' + std::to_string(sym27__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"X_tp1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp3\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp4\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp5\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp6\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp7\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"X_tp1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp3\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp4\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp5\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp6\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp7\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (10 * 10);
    const size_t num_transformed = emit_transformed_parameters * ((((((((10 *
      10) + (10 * 10)) + (10 * 10)) + (10 * 10)) + (10 * 10)) + (10 * 10)) +
      (10 * 10)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (10 * 10);
    const size_t num_transformed = emit_transformed_parameters * ((((((((10 *
      10) + (10 * 10)) + (10 * 10)) + (10 * 10)) + (10 * 10)) + (10 * 10)) +
      (10 * 10)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = ad_level_deep_dependence_model_namespace::ad_level_deep_dependence_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return ad_level_deep_dependence_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp ad-level-failing.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace ad_level_failing_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 35> locations_array__ =
  {" (found before start of program)",
  " (in 'ad-level-failing.stan', line 37, column 2 to column 21)",
  " (in 'ad-level-failing.stan', line 38, column 2 to column 22)",
  " (in 'ad-level-failing.stan', line 39, column 2 to column 19)",
  " (in 'ad-level-failing.stan', line 40, column 2 to column 22)",
  " (in 'ad-level-failing.stan', line 43, column 2 to column 32)",
  " (in 'ad-level-failing.stan', line 45, column 4 to column 58)",
  " (in 'ad-level-failing.stan', line 44, column 2 to line 47, column 3)",
  " (in 'ad-level-failing.stan', line 50, column 2 to column 24)",
  " (in 'ad-level-failing.stan', line 51, column 2 to column 23)",
  " (in 'ad-level-failing.stan', line 52, column 2 to column 21)",
  " (in 'ad-level-failing.stan', line 53, column 2 to column 23)",
  " (in 'ad-level-failing.stan', line 55, column 2 to column 41)",
  " (in 'ad-level-failing.stan', line 57, column 4 to column 49)",
  " (in 'ad-level-failing.stan', line 56, column 2 to line 57, column 49)",
  " (in 'ad-level-failing.stan', line 59, column 2 to column 53)",
  " (in 'ad-level-failing.stan', line 23, column 2 to column 19)",
  " (in 'ad-level-failing.stan', line 24, column 8 to column 11)",
  " (in 'ad-level-failing.stan', line 24, column 2 to column 20)",
  " (in 'ad-level-failing.stan', line 25, column 2 to column 19)",
  " (in 'ad-level-failing.stan', line 26, column 8 to column 11)",
  " (in 'ad-level-failing.stan', line 26, column 2 to column 26)",
  " (in 'ad-level-failing.stan', line 27, column 8 to column 11)",
  " (in 'ad-level-failing.stan', line 27, column 2 to column 24)",
  " (in 'ad-level-failing.stan', line 30, column 2 to column 14)",
  " (in 'ad-level-failing.stan', line 31, column 2 to column 32)",
  " (in 'ad-level-failing.stan', line 33, column 2 to column 20)",
  " (in 'ad-level-failing.stan', line 34, column 2 to column 19)",
  " (in 'ad-level-failing.stan', line 43, column 8 to column 11)",
  " (in 'ad-level-failing.stan', line 12, column 4 to column 23)",
  " (in 'ad-level-failing.stan', line 14, column 4 to column 58)",
  " (in 'ad-level-failing.stan', line 16, column 4 to column 30)",
  " (in 'ad-level-failing.stan', line 17, column 4 to column 48)",
  " (in 'ad-level-failing.stan', line 19, column 4 to column 16)",
  " (in 'ad-level-failing.stan', line 11, column 61 to line 20, column 3)"};
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_stan_scalar<T1__>,
                              stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>>* = nullptr>
std::vector<stan::promote_args_t<T0__, T1__, T2__, T3__>>
simple_SIR(const T0__& t, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__);
struct simple_SIR_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_all_t<stan::is_stan_scalar<T0__>,
                                stan::is_stan_scalar<T1__>,
                                stan::is_stan_scalar<T2__>,
                                stan::is_stan_scalar<T3__>>* = nullptr>
  std::vector<stan::promote_args_t<T0__, T1__, T2__, T3__>>
  operator()(const T0__& t, const std::vector<T1__>& y,
             const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
             const std::vector<int>& x_i, std::ostream* pstream__) const {
    return simple_SIR(t, y, theta, x_r, x_i, pstream__);
  }
};
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_stan_scalar<T1__>,
                              stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>>*>
std::vector<stan::promote_args_t<T0__, T1__, T2__, T3__>>
simple_SIR(const T0__& t, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ lcm_sym4__;
    double lcm_sym3__;
    double lcm_sym2__;
    double lcm_sym1__;
    {
      std::vector<local_scalar_t__> dydt =
        std::vector<local_scalar_t__>(4, DUMMY_VAR__);
      current_statement__ = 30;
      stan::model::assign(dydt,
        (((-(stan::model::rvalue(theta, "theta", stan::model::index_uni(1)))
        * stan::model::rvalue(y, "y", stan::model::index_uni(4))) /
        (stan::model::rvalue(y, "y", stan::model::index_uni(4)) +
        stan::model::rvalue(theta, "theta", stan::model::index_uni(2)))) *
        stan::model::rvalue(y, "y", stan::model::index_uni(1))),
        "assigning variable dydt", stan::model::index_uni(1));
      lcm_sym4__ = (stan::model::rvalue(theta, "theta",
                      stan::model::index_uni(3))
        * stan::model::rvalue(y, "y", stan::model::index_uni(2)));
      stan::model::assign(dydt,
        ((((stan::model::rvalue(theta, "theta", stan::model::index_uni(1)) *
        stan::model::rvalue(y, "y", stan::model::index_uni(4))) /
        (stan::model::rvalue(y, "y", stan::model::index_uni(4)) +
        stan::model::rvalue(theta, "theta", stan::model::index_uni(2)))) *
        stan::model::rvalue(y, "y", stan::model::index_uni(1))) -
        lcm_sym4__), "assigning variable dydt", stan::model::index_uni(2));
      current_statement__ = 31;
      stan::model::assign(dydt, lcm_sym4__, "assigning variable dydt",
        stan::model::index_uni(3));
      current_statement__ = 32;
      stan::model::assign(dydt,
        ((stan::model::rvalue(theta, "theta", stan::model::index_uni(4)) *
        stan::model::rvalue(y, "y", stan::model::index_uni(2))) -
        (stan::model::rvalue(theta, "theta", stan::model::index_uni(5)) *
        stan::model::rvalue(y, "y", stan::model::index_uni(4)))),
        "assigning variable dydt", stan::model::index_uni(4));
      current_statement__ = 33;
      return dydt;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class ad_level_failing_model final : public model_base_crtp<ad_level_failing_model> {
 private:
  double lcm_sym37__;
  double lcm_sym36__;
  int N_t;
  std::vector<double> t;
  std::vector<double> y0;
  std::vector<int> stoi_hat;
  std::vector<double> B_hat;
  double t0;
  double kappa;
  std::vector<double> x_r;
  std::vector<int> x_i;
 public:
  ~ad_level_failing_model() {}
  ad_level_failing_model(stan::io::var_context& context__, unsigned int
                         random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "ad_level_failing_model_namespace::ad_level_failing_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 16;
      context__.validate_dims("data initialization", "N_t", "int",
        std::vector<size_t>{});
      N_t = std::numeric_limits<int>::min();
      current_statement__ = 16;
      N_t = context__.vals_i("N_t")[(1 - 1)];
      current_statement__ = 16;
      stan::math::check_greater_or_equal(function__, "N_t", N_t, 0);
      current_statement__ = 17;
      stan::math::validate_non_negative_index("t", "N_t", N_t);
      current_statement__ = 18;
      context__.validate_dims("data initialization", "t", "double",
        std::vector<size_t>{static_cast<size_t>(N_t)});
      t = std::vector<double>(N_t, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 18;
      t = context__.vals_r("t");
      current_statement__ = 19;
      context__.validate_dims("data initialization", "y0", "double",
        std::vector<size_t>{static_cast<size_t>(4)});
      y0 = std::vector<double>(4, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 19;
      y0 = context__.vals_r("y0");
      current_statement__ = 20;
      stan::math::validate_non_negative_index("stoi_hat", "N_t", N_t);
      current_statement__ = 21;
      context__.validate_dims("data initialization", "stoi_hat", "int",
        std::vector<size_t>{static_cast<size_t>(N_t)});
      stoi_hat = std::vector<int>(N_t, std::numeric_limits<int>::min());
      current_statement__ = 21;
      stoi_hat = context__.vals_i("stoi_hat");
      current_statement__ = 22;
      stan::math::validate_non_negative_index("B_hat", "N_t", N_t);
      current_statement__ = 23;
      context__.validate_dims("data initialization", "B_hat", "double",
        std::vector<size_t>{static_cast<size_t>(N_t)});
      B_hat = std::vector<double>(N_t,
                std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 23;
      B_hat = context__.vals_r("B_hat");
      current_statement__ = 24;
      t0 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 24;
      t0 = 0;
      current_statement__ = 25;
      kappa = std::numeric_limits<double>::quiet_NaN();
      lcm_sym37__ = 1000000;
      kappa = 1000000;
      current_statement__ = 26;
      x_r = std::vector<double>(0, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 27;
      x_i = std::vector<int>(0, std::numeric_limits<int>::min());
      current_statement__ = 25;
      stan::math::check_greater_or_equal(function__, "kappa", 1000000, 0);
      current_statement__ = 28;
      stan::math::validate_non_negative_index("y", "N_t", N_t);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1;
  }
  inline std::string model_name() const final {
    return "ad_level_failing_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "ad_level_failing_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<local_scalar_t__> lcm_sym35__;
      double lcm_sym34__;
      double lcm_sym33__;
      double lcm_sym32__;
      double lcm_sym31__;
      std::vector<std::vector<local_scalar_t__>> lcm_sym30__;
      double lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      int lcm_sym25__;
      local_scalar_t__ beta;
      current_statement__ = 1;
      beta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      local_scalar_t__ gamma;
      current_statement__ = 2;
      gamma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      local_scalar_t__ xi;
      current_statement__ = 3;
      xi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
             lp__);
      local_scalar_t__ delta;
      current_statement__ = 4;
      delta = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      std::vector<std::vector<local_scalar_t__>> y =
        std::vector<std::vector<local_scalar_t__>>(N_t,
          std::vector<local_scalar_t__>(4, DUMMY_VAR__));
      {
        std::vector<double> theta =
          std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
        stan::model::assign(lcm_sym35__,
          std::vector<local_scalar_t__>{beta, 1000000, gamma, xi, delta},
          "assigning variable lcm_sym35__");
        stan::model::assign(lcm_sym30__,
          stan::math::integrate_ode_rk45(simple_SIR_functor__(), y0, 0, t,
            lcm_sym35__, x_r, x_i, pstream__),
          "assigning variable lcm_sym30__");
        stan::model::assign(y, lcm_sym30__, "assigning variable y");
      }
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "y", lcm_sym30__, 0);
      {
        current_statement__ = 8;
        lp_accum__.add(stan::math::cauchy_lpdf<propto__>(beta, 0, 2.5));
        current_statement__ = 9;
        lp_accum__.add(stan::math::cauchy_lpdf<propto__>(gamma, 0, 1));
        current_statement__ = 10;
        lp_accum__.add(stan::math::cauchy_lpdf<propto__>(xi, 0, 25));
        current_statement__ = 11;
        lp_accum__.add(stan::math::cauchy_lpdf<propto__>(delta, 0, 1));
        current_statement__ = 12;
        lp_accum__.add(stan::math::poisson_lpmf<propto__>(
                         stan::model::rvalue(stoi_hat, "stoi_hat",
                           stan::model::index_uni(1)),
                         (stan::model::rvalue(y0, "y0",
                            stan::model::index_uni(1)) -
                         stan::model::rvalue(lcm_sym30__, "lcm_sym30__",
                           stan::model::index_uni(1),
                           stan::model::index_uni(1)))));
        current_statement__ = 14;
        if (stan::math::logical_gte(N_t, 2)) {
          current_statement__ = 13;
          lp_accum__.add(stan::math::poisson_lpmf<propto__>(
                           stan::model::rvalue(stoi_hat, "stoi_hat",
                             stan::model::index_uni(2)),
                           (stan::model::rvalue(lcm_sym30__, "lcm_sym30__",
                              stan::model::index_uni(1),
                              stan::model::index_uni(1)) -
                           stan::model::rvalue(lcm_sym30__, "lcm_sym30__",
                             stan::model::index_uni(2),
                             stan::model::index_uni(1)))));
          for (int n = 3; n <= N_t; ++n) {
            current_statement__ = 13;
            lp_accum__.add(stan::math::poisson_lpmf<propto__>(
                             stan::model::rvalue(stoi_hat, "stoi_hat",
                               stan::model::index_uni(n)),
                             (stan::model::rvalue(lcm_sym30__, "lcm_sym30__",
                                stan::model::index_uni((n - 1)),
                                stan::model::index_uni(1)) -
                             stan::model::rvalue(lcm_sym30__, "lcm_sym30__",
                               stan::model::index_uni(n),
                               stan::model::index_uni(1)))));
          }
        }
        current_statement__ = 15;
        lp_accum__.add(stan::math::lognormal_lpdf<propto__>(B_hat,
                         stan::math::log(
                           stan::math::col(
                             stan::math::to_matrix(lcm_sym30__), 4)), 0.15));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "ad_level_failing_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<local_scalar_t__> lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      std::vector<std::vector<local_scalar_t__>> lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      int lcm_sym14__;
      local_scalar_t__ beta;
      current_statement__ = 1;
      beta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      local_scalar_t__ gamma;
      current_statement__ = 2;
      gamma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      local_scalar_t__ xi;
      current_statement__ = 3;
      xi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
             lp__);
      local_scalar_t__ delta;
      current_statement__ = 4;
      delta = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      std::vector<std::vector<local_scalar_t__>> y =
        std::vector<std::vector<local_scalar_t__>>(N_t,
          std::vector<local_scalar_t__>(4, DUMMY_VAR__));
      {
        std::vector<double> theta =
          std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
        stan::model::assign(lcm_sym24__,
          std::vector<local_scalar_t__>{beta, 1000000, gamma, xi, delta},
          "assigning variable lcm_sym24__");
        stan::model::assign(lcm_sym19__,
          stan::math::integrate_ode_rk45(simple_SIR_functor__(), y0, 0, t,
            lcm_sym24__, x_r, x_i, pstream__),
          "assigning variable lcm_sym19__");
        stan::model::assign(y, lcm_sym19__, "assigning variable y");
      }
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "y", lcm_sym19__, 0);
      {
        current_statement__ = 8;
        lp_accum__.add(stan::math::cauchy_lpdf<propto__>(beta, 0, 2.5));
        current_statement__ = 9;
        lp_accum__.add(stan::math::cauchy_lpdf<propto__>(gamma, 0, 1));
        current_statement__ = 10;
        lp_accum__.add(stan::math::cauchy_lpdf<propto__>(xi, 0, 25));
        current_statement__ = 11;
        lp_accum__.add(stan::math::cauchy_lpdf<propto__>(delta, 0, 1));
        current_statement__ = 12;
        lp_accum__.add(stan::math::poisson_lpmf<propto__>(
                         stan::model::rvalue(stoi_hat, "stoi_hat",
                           stan::model::index_uni(1)),
                         (stan::model::rvalue(y0, "y0",
                            stan::model::index_uni(1)) -
                         stan::model::rvalue(lcm_sym19__, "lcm_sym19__",
                           stan::model::index_uni(1),
                           stan::model::index_uni(1)))));
        current_statement__ = 14;
        if (stan::math::logical_gte(N_t, 2)) {
          current_statement__ = 13;
          lp_accum__.add(stan::math::poisson_lpmf<propto__>(
                           stan::model::rvalue(stoi_hat, "stoi_hat",
                             stan::model::index_uni(2)),
                           (stan::model::rvalue(lcm_sym19__, "lcm_sym19__",
                              stan::model::index_uni(1),
                              stan::model::index_uni(1)) -
                           stan::model::rvalue(lcm_sym19__, "lcm_sym19__",
                             stan::model::index_uni(2),
                             stan::model::index_uni(1)))));
          for (int n = 3; n <= N_t; ++n) {
            current_statement__ = 13;
            lp_accum__.add(stan::math::poisson_lpmf<propto__>(
                             stan::model::rvalue(stoi_hat, "stoi_hat",
                               stan::model::index_uni(n)),
                             (stan::model::rvalue(lcm_sym19__, "lcm_sym19__",
                                stan::model::index_uni((n - 1)),
                                stan::model::index_uni(1)) -
                             stan::model::rvalue(lcm_sym19__, "lcm_sym19__",
                               stan::model::index_uni(n),
                               stan::model::index_uni(1)))));
          }
        }
        current_statement__ = 15;
        lp_accum__.add(stan::math::lognormal_lpdf<propto__>(B_hat,
                         stan::math::log(
                           stan::math::col(
                             stan::math::to_matrix(lcm_sym19__), 4)), 0.15));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "ad_level_failing_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym13__;
      double lcm_sym12__;
      double lcm_sym11__;
      double lcm_sym10__;
      std::vector<double> lcm_sym9__;
      std::vector<std::vector<double>> lcm_sym8__;
      int lcm_sym7__;
      int lcm_sym6__;
      int lcm_sym5__;
      double beta;
      current_statement__ = 1;
      beta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      double gamma;
      current_statement__ = 2;
      gamma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      double xi;
      current_statement__ = 3;
      xi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
             lp__);
      double delta;
      current_statement__ = 4;
      delta = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      std::vector<std::vector<double>> y =
        std::vector<std::vector<double>>(N_t,
          std::vector<double>(4, std::numeric_limits<double>::quiet_NaN()));
      out__.write(beta);
      out__.write(gamma);
      out__.write(xi);
      out__.write(delta);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      {
        std::vector<double> theta =
          std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
        stan::model::assign(lcm_sym9__,
          std::vector<double>{beta, 1000000, gamma, xi, delta},
          "assigning variable lcm_sym9__");
        stan::model::assign(lcm_sym8__,
          stan::math::integrate_ode_rk45(simple_SIR_functor__(), y0, 0, t,
            lcm_sym9__, x_r, x_i, pstream__), "assigning variable lcm_sym8__");
        stan::model::assign(y, lcm_sym8__, "assigning variable y");
      }
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "y", lcm_sym8__, 0);
      if (emit_transformed_parameters__) {
        lcm_sym5__ = stan::math::logical_gte(N_t, 1);
        if (lcm_sym5__) {
          out__.write(stan::model::rvalue(lcm_sym8__, "lcm_sym8__",
                        stan::model::index_uni(1), stan::model::index_uni(1)));
          for (int sym2__ = 2; sym2__ <= N_t; ++sym2__) {
            out__.write(stan::model::rvalue(lcm_sym8__, "lcm_sym8__",
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(1)));
          }
        }
        {
          if (lcm_sym5__) {
            out__.write(stan::model::rvalue(lcm_sym8__, "lcm_sym8__",
                          stan::model::index_uni(1),
                          stan::model::index_uni(2)));
            for (int sym2__ = 2; sym2__ <= N_t; ++sym2__) {
              out__.write(stan::model::rvalue(lcm_sym8__, "lcm_sym8__",
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(2)));
            }
          }
        }
        {
          if (lcm_sym5__) {
            out__.write(stan::model::rvalue(lcm_sym8__, "lcm_sym8__",
                          stan::model::index_uni(1),
                          stan::model::index_uni(3)));
            for (int sym2__ = 2; sym2__ <= N_t; ++sym2__) {
              out__.write(stan::model::rvalue(lcm_sym8__, "lcm_sym8__",
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(3)));
            }
          }
        }
        {
          if (lcm_sym5__) {
            out__.write(stan::model::rvalue(lcm_sym8__, "lcm_sym8__",
                          stan::model::index_uni(1),
                          stan::model::index_uni(4)));
            for (int sym2__ = 2; sym2__ <= N_t; ++sym2__) {
              out__.write(stan::model::rvalue(lcm_sym8__, "lcm_sym8__",
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(4)));
            }
          }
        }
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ beta;
      current_statement__ = 1;
      beta = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, beta);
      local_scalar_t__ gamma;
      current_statement__ = 2;
      gamma = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, gamma);
      local_scalar_t__ xi;
      current_statement__ = 3;
      xi = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, xi);
      local_scalar_t__ delta;
      current_statement__ = 4;
      delta = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, delta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "beta", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "gamma", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "xi", "double",
        std::vector<size_t>{});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "delta", "double",
        std::vector<size_t>{});
      local_scalar_t__ beta;
      current_statement__ = 1;
      beta = context__.vals_r("beta")[(1 - 1)];
      out__.write_free_lb(0, beta);
      local_scalar_t__ gamma;
      current_statement__ = 2;
      gamma = context__.vals_r("gamma")[(1 - 1)];
      out__.write_free_lb(0, gamma);
      local_scalar_t__ xi;
      current_statement__ = 3;
      xi = context__.vals_r("xi")[(1 - 1)];
      out__.write_free_lb(0, xi);
      local_scalar_t__ delta;
      current_statement__ = 4;
      delta = context__.vals_r("delta")[(1 - 1)];
      out__.write_free_lb(0, delta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"beta", "gamma", "xi", "delta"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"y"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(N_t),
               static_cast<size_t>(4)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "beta");
    param_names__.emplace_back(std::string() + "gamma");
    param_names__.emplace_back(std::string() + "xi");
    param_names__.emplace_back(std::string() + "delta");
    if (emit_transformed_parameters__) {
      for (int sym38__ = 1; sym38__ <= 4; ++sym38__) {
        for (int sym39__ = 1; sym39__ <= N_t; ++sym39__) {
          param_names__.emplace_back(std::string() + "y" + '.' +
            std::to_string(sym39__) + '.' + std::to_string(sym38__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "beta");
    param_names__.emplace_back(std::string() + "gamma");
    param_names__.emplace_back(std::string() + "xi");
    param_names__.emplace_back(std::string() + "delta");
    if (emit_transformed_parameters__) {
      for (int sym38__ = 1; sym38__ <= 4; ++sym38__) {
        for (int sym39__ = 1; sym39__ <= N_t; ++sym39__) {
          param_names__.emplace_back(std::string() + "y" + '.' +
            std::to_string(sym39__) + '.' + std::to_string(sym38__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"xi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N_t) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"xi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N_t) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((1 + 1) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * ((N_t * 4));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((1 + 1) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * ((N_t * 4));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = ad_level_failing_model_namespace::ad_level_failing_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return ad_level_failing_model_namespace::profiles__;
}
#endif
Warning in 'ad-level-failing.stan', line 46, column 8: integrate_ode_rk45 is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../../install/default/bin/stanc --O --print-cpp ad-levels-deep.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace ad_levels_deep_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 6> locations_array__ =
  {" (found before start of program)",
  " (in 'ad-levels-deep.stan', line 6, column 4 to column 23)",
  " (in 'ad-levels-deep.stan', line 10, column 4 to column 39)",
  " (in 'ad-levels-deep.stan', line 11, column 4 to column 38)",
  " (in 'ad-levels-deep.stan', line 12, column 4 to column 16)",
  " (in 'ad-levels-deep.stan', line 2, column 4 to column 26)"};
class ad_levels_deep_model final : public model_base_crtp<ad_levels_deep_model> {
 private:
  double lcm_sym14__;
  double lcm_sym13__;
  int lcm_sym12__;
  Eigen::Matrix<double,-1,-1> X_data_data__;
  Eigen::Map<Eigen::Matrix<double,-1,-1>> X_data{nullptr, 0, 0};
 public:
  ~ad_levels_deep_model() {}
  ad_levels_deep_model(stan::io::var_context& context__, unsigned int
                       random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "ad_levels_deep_model_namespace::ad_levels_deep_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 5;
      context__.validate_dims("data initialization", "X_data", "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      X_data_data__ = Eigen::Matrix<double,-1,-1>::Constant(10, 10,
                        std::numeric_limits<double>::quiet_NaN());
      new (&X_data)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_data_data__.data(), 10, 10);
      {
        std::vector<double> X_data_flat__;
        current_statement__ = 5;
        X_data_flat__ = context__.vals_r("X_data");
        pos__ = 1;
        {
          {
            stan::model::assign(X_data,
              stan::model::rvalue(X_data_flat__, "X_data_flat__",
                stan::model::index_uni(1)), "assigning variable X_data",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(2),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(3),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(4),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(5),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(6),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(7),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(8),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(9),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(10),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
              "assigning variable X_data", stan::model::index_uni(1),
              stan::model::index_uni(2));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(2),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(3),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(4),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(5),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(6),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(7),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(8),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(9),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(10),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
              "assigning variable X_data", stan::model::index_uni(1),
              stan::model::index_uni(3));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(2),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(3),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(4),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(5),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(6),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(7),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(8),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(9),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(10),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
              "assigning variable X_data", stan::model::index_uni(1),
              stan::model::index_uni(4));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(2),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(3),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(4),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(5),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(6),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(7),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(8),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(9),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(10),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
              "assigning variable X_data", stan::model::index_uni(1),
              stan::model::index_uni(5));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(2),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(3),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(4),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(5),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(6),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(7),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(8),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(9),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(10),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
              "assigning variable X_data", stan::model::index_uni(1),
              stan::model::index_uni(6));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(2),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(3),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(4),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(5),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(6),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(7),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(8),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(9),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(10),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
              "assigning variable X_data", stan::model::index_uni(1),
              stan::model::index_uni(7));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(2),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(3),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(4),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(5),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(6),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(7),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(8),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(9),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(10),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
              "assigning variable X_data", stan::model::index_uni(1),
              stan::model::index_uni(8));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(2),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(3),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(4),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(5),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(6),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(7),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(8),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(9),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(10),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
              "assigning variable X_data", stan::model::index_uni(1),
              stan::model::index_uni(9));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(2),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(3),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(4),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(5),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(6),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(7),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(8),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(9),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(10),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
              "assigning variable X_data", stan::model::index_uni(1),
              stan::model::index_uni(10));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(2),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(3),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(4),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(5),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(6),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(7),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(8),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(9),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
                "assigning variable X_data", stan::model::index_uni(10),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (10 * 10);
  }
  inline std::string model_name() const final {
    return "ad_levels_deep_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "ad_levels_deep_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> lcm_sym11__;
      Eigen::Matrix<double,-1,-1> lcm_sym10__;
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p;
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      stan::model::assign(lcm_sym10__, stan::math::exp(X_data),
        "assigning variable lcm_sym10__");
      stan::model::assign(X_tp1, lcm_sym10__, "assigning variable X_tp1");
      Eigen::Matrix<double,-1,-1> X_tp2;
      current_statement__ = 3;
      stan::model::assign(X_tp2, stan::math::exp(lcm_sym10__),
        "assigning variable X_tp2");
      current_statement__ = 4;
      stan::model::assign(X_tp1, X_p, "assigning variable X_tp1");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "ad_levels_deep_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> lcm_sym9__;
      Eigen::Matrix<double,-1,-1> lcm_sym8__;
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> X_p;
      current_statement__ = 1;
      X_p = in__.template read<
              stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(10, 10);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> X_tp1 =
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(10,
                                                             10,
                                                             std::numeric_limits<double>::quiet_NaN(
                                                               )));
      stan::model::assign(lcm_sym8__, stan::math::exp(X_data),
        "assigning variable lcm_sym8__");
      stan::model::assign(X_tp1, lcm_sym8__, "assigning variable X_tp1");
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> X_tp2;
      current_statement__ = 3;
      stan::model::assign(X_tp2, stan::math::exp(lcm_sym8__),
        "assigning variable X_tp2");
      current_statement__ = 4;
      stan::model::assign(X_tp1, X_p, "assigning variable X_tp1");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "ad_levels_deep_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> lcm_sym7__;
      Eigen::Matrix<double,-1,-1> lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      Eigen::Matrix<double,-1,-1> X_p;
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<double,-1,-1> X_tp1 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp2 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(X_p);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      stan::model::assign(lcm_sym6__, stan::math::exp(X_data),
        "assigning variable lcm_sym6__");
      stan::model::assign(X_tp1, lcm_sym6__, "assigning variable X_tp1");
      stan::model::assign(lcm_sym7__, stan::math::exp(lcm_sym6__),
        "assigning variable lcm_sym7__");
      stan::model::assign(X_tp2, lcm_sym7__, "assigning variable X_tp2");
      current_statement__ = 4;
      stan::model::assign(X_tp1, X_p, "assigning variable X_tp1");
      if (emit_transformed_parameters__) {
        out__.write(X_p);
        out__.write(lcm_sym7__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p;
      current_statement__ = 1;
      stan::model::assign(X_p,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10),
        "assigning variable X_p");
      out__.write(X_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "X_p", "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      double lcm_sym3__;
      double lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      {
        std::vector<double> X_p_flat__;
        current_statement__ = 1;
        X_p_flat__ = context__.vals_r("X_p");
        pos__ = 1;
        {
          {
            stan::model::assign(X_p,
              stan::model::rvalue(X_p_flat__, "X_p_flat__",
                stan::model::index_uni(1)), "assigning variable X_p",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(2));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(3));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(4));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(5));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(6));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(7));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(8));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(9));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(1),
              stan::model::index_uni(10));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(2),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(3),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(4),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(5),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(6),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(7),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(8),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(9),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
                "assigning variable X_p", stan::model::index_uni(10),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(X_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"X_p"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"X_tp1", "X_tp2"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    10),
                                                 static_cast<size_t>(10)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym15__ = 1; sym15__ <= 10; ++sym15__) {
      for (int sym16__ = 1; sym16__ <= 10; ++sym16__) {
        param_names__.emplace_back(std::string() + "X_p" + '.' +
          std::to_string(sym16__) + '.' + std::to_string(sym15__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym15__ = 1; sym15__ <= 10; ++sym15__) {
        for (int sym16__ = 1; sym16__ <= 10; ++sym16__) {
          param_names__.emplace_back(std::string() + "X_tp1" + '.' +
            std::to_string(sym16__) + '.' + std::to_string(sym15__));
        }
      }
      for (int sym15__ = 1; sym15__ <= 10; ++sym15__) {
        for (int sym16__ = 1; sym16__ <= 10; ++sym16__) {
          param_names__.emplace_back(std::string() + "X_tp2" + '.' +
            std::to_string(sym16__) + '.' + std::to_string(sym15__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym15__ = 1; sym15__ <= 10; ++sym15__) {
      for (int sym16__ = 1; sym16__ <= 10; ++sym16__) {
        param_names__.emplace_back(std::string() + "X_p" + '.' +
          std::to_string(sym16__) + '.' + std::to_string(sym15__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym15__ = 1; sym15__ <= 10; ++sym15__) {
        for (int sym16__ = 1; sym16__ <= 10; ++sym16__) {
          param_names__.emplace_back(std::string() + "X_tp1" + '.' +
            std::to_string(sym16__) + '.' + std::to_string(sym15__));
        }
      }
      for (int sym15__ = 1; sym15__ <= 10; ++sym15__) {
        for (int sym16__ = 1; sym16__ <= 10; ++sym16__) {
          param_names__.emplace_back(std::string() + "X_tp2" + '.' +
            std::to_string(sym16__) + '.' + std::to_string(sym15__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"X_tp1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"X_tp1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (10 * 10);
    const size_t num_transformed = emit_transformed_parameters * (((10 * 10)
      + (10 * 10)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (10 * 10);
    const size_t num_transformed = emit_transformed_parameters * (((10 * 10)
      + (10 * 10)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = ad_levels_deep_model_namespace::ad_levels_deep_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return ad_levels_deep_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp copy-prop-profile.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace copy_prop_profile_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 16> locations_array__ =
  {" (found before start of program)",
  " (in 'copy-prop-profile.stan', line 5, column 2 to column 16)",
  " (in 'copy-prop-profile.stan', line 9, column 13 to column 14)",
  " (in 'copy-prop-profile.stan', line 9, column 2 to column 20)",
  " (in 'copy-prop-profile.stan', line 12, column 15 to column 16)",
  " (in 'copy-prop-profile.stan', line 12, column 4 to column 45)",
  " (in 'copy-prop-profile.stan', line 11, column 2 to line 14, column 3)",
  " (in 'copy-prop-profile.stan', line 18, column 13 to column 14)",
  " (in 'copy-prop-profile.stan', line 18, column 2 to column 21)",
  " (in 'copy-prop-profile.stan', line 20, column 15 to column 16)",
  " (in 'copy-prop-profile.stan', line 20, column 4 to column 45)",
  " (in 'copy-prop-profile.stan', line 19, column 2 to line 22, column 3)",
  " (in 'copy-prop-profile.stan', line 24, column 2 to column 22)",
  " (in 'copy-prop-profile.stan', line 2, column 2 to column 17)",
  " (in 'copy-prop-profile.stan', line 5, column 9 to column 10)",
  " (in 'copy-prop-profile.stan', line 5, column 11 to column 12)"};
class copy_prop_profile_model final : public model_base_crtp<copy_prop_profile_model> {
 private:
  int N;
 public:
  ~copy_prop_profile_model() {}
  copy_prop_profile_model(stan::io::var_context& context__, unsigned int
                          random_seed__ = 0, std::ostream*
                          pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "copy_prop_profile_model_namespace::copy_prop_profile_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 13;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 13;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 13;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 14;
      stan::math::validate_non_negative_index("X", "N", N);
      current_statement__ = 15;
      stan::math::validate_non_negative_index("X", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (N * N);
  }
  inline std::string model_name() const final {
    return "copy_prop_profile_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "copy_prop_profile_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ lcm_sym10__;
      Eigen::Matrix<local_scalar_t__,1,-1> lcm_sym9__;
      Eigen::Matrix<local_scalar_t__,-1,-1> X;
      current_statement__ = 1;
      X = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N);
      {
        current_statement__ = 2;
        stan::math::validate_non_negative_index("vec", "N", N);
        Eigen::Matrix<double,1,-1> vec =
          Eigen::Matrix<double,1,-1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 6;
        {
          stan::math::profile<local_scalar_t__> profile__("test",
            const_cast<stan::math::profile_map&>(profiles__));
          current_statement__ = 4;
          stan::math::validate_non_negative_index("vec2", "N", N);
          Eigen::Matrix<double,1,-1> vec2 =
            Eigen::Matrix<double,1,-1>::Constant(N,
              std::numeric_limits<double>::quiet_NaN());
          stan::model::assign(lcm_sym9__, stan::math::columns_dot_self(X),
            "assigning variable lcm_sym9__");
        }
        lcm_sym10__ = stan::math::sum(lcm_sym9__);
        lp_accum__.add(lcm_sym10__);
        current_statement__ = 7;
        stan::math::validate_non_negative_index("vec3", "N", N);
        Eigen::Matrix<double,1,-1> vec3 =
          Eigen::Matrix<double,1,-1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN());
        {
          current_statement__ = 9;
          stan::math::validate_non_negative_index("vec4", "N", N);
          Eigen::Matrix<double,1,-1> vec4 =
            Eigen::Matrix<double,1,-1>::Constant(N,
              std::numeric_limits<double>::quiet_NaN());
        }
        current_statement__ = 12;
        lp_accum__.add(lcm_sym10__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "copy_prop_profile_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ lcm_sym8__;
      Eigen::Matrix<local_scalar_t__,1,-1> lcm_sym7__;
      Eigen::Matrix<local_scalar_t__,-1,-1> X;
      current_statement__ = 1;
      X = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N);
      {
        current_statement__ = 2;
        stan::math::validate_non_negative_index("vec", "N", N);
        stan::math::var_value<Eigen::Matrix<double,1,-1>> vec =
          Eigen::Matrix<double,1,-1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 6;
        {
          stan::math::profile<local_scalar_t__> profile__("test",
            const_cast<stan::math::profile_map&>(profiles__));
          current_statement__ = 4;
          stan::math::validate_non_negative_index("vec2", "N", N);
          stan::math::var_value<Eigen::Matrix<double,1,-1>> vec2 =
            Eigen::Matrix<double,1,-1>::Constant(N,
              std::numeric_limits<double>::quiet_NaN());
          stan::model::assign(lcm_sym7__, stan::math::columns_dot_self(X),
            "assigning variable lcm_sym7__");
        }
        lcm_sym8__ = stan::math::sum(lcm_sym7__);
        lp_accum__.add(lcm_sym8__);
        current_statement__ = 7;
        stan::math::validate_non_negative_index("vec3", "N", N);
        stan::math::var_value<Eigen::Matrix<double,1,-1>> vec3 =
          Eigen::Matrix<double,1,-1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN());
        {
          current_statement__ = 9;
          stan::math::validate_non_negative_index("vec4", "N", N);
          stan::math::var_value<Eigen::Matrix<double,1,-1>> vec4 =
            Eigen::Matrix<double,1,-1>::Constant(N,
              std::numeric_limits<double>::quiet_NaN());
        }
        current_statement__ = 12;
        lp_accum__.add(lcm_sym8__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "copy_prop_profile_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym6__;
      int lcm_sym5__;
      Eigen::Matrix<double,-1,-1> X;
      current_statement__ = 1;
      X = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N);
      out__.write(X);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> X;
      current_statement__ = 1;
      stan::model::assign(X,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N),
        "assigning variable X");
      out__.write(X);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "X", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      double lcm_sym4__;
      double lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__ = std::numeric_limits<int>::min();
      Eigen::Matrix<local_scalar_t__,-1,-1> X =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      {
        std::vector<double> X_flat__;
        current_statement__ = 1;
        X_flat__ = context__.vals_r("X");
        pos__ = 1;
        lcm_sym1__ = stan::math::logical_gte(N, 1);
        if (lcm_sym1__) {
          if (lcm_sym1__) {
            stan::model::assign(X,
              stan::model::rvalue(X_flat__, "X_flat__",
                stan::model::index_uni(1)), "assigning variable X",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= N; ++sym2__) {
              stan::model::assign(X, X_flat__[(pos__ - 1)],
                "assigning variable X", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            if (lcm_sym1__) {
              stan::model::assign(X, X_flat__[(pos__ - 1)],
                "assigning variable X", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= N; ++sym2__) {
                stan::model::assign(X, X_flat__[(pos__ - 1)],
                  "assigning variable X", stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      out__.write(X);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"X"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(N),
                                                 static_cast<size_t>(N)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym11__ = 1; sym11__ <= N; ++sym11__) {
      for (int sym12__ = 1; sym12__ <= N; ++sym12__) {
        param_names__.emplace_back(std::string() + "X" + '.' +
          std::to_string(sym12__) + '.' + std::to_string(sym11__));
      }
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym11__ = 1; sym11__ <= N; ++sym11__) {
      for (int sym12__ = 1; sym12__ <= N; ++sym12__) {
        param_names__.emplace_back(std::string() + "X" + '.' +
          std::to_string(sym12__) + '.' + std::to_string(sym11__));
      }
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"X\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"X\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (N * N);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (N * N);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = copy_prop_profile_model_namespace::copy_prop_profile_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return copy_prop_profile_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp copy_fail.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace copy_fail_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 68> locations_array__ =
  {" (found before start of program)",
  " (in 'copy_fail.stan', line 68, column 2 to column 32)",
  " (in 'copy_fail.stan', line 69, column 2 to column 41)",
  " (in 'copy_fail.stan', line 72, column 2 to column 52)",
  " (in 'copy_fail.stan', line 73, column 2 to column 50)",
  " (in 'copy_fail.stan', line 74, column 2 to column 50)",
  " (in 'copy_fail.stan', line 80, column 6 to column 18)",
  " (in 'copy_fail.stan', line 79, column 6 to column 20)",
  " (in 'copy_fail.stan', line 78, column 34 to line 81, column 5)",
  " (in 'copy_fail.stan', line 83, column 6 to column 32)",
  " (in 'copy_fail.stan', line 84, column 6 to column 23)",
  " (in 'copy_fail.stan', line 82, column 40 to line 85, column 5)",
  " (in 'copy_fail.stan', line 82, column 4 to line 85, column 5)",
  " (in 'copy_fail.stan', line 77, column 22 to line 86, column 3)",
  " (in 'copy_fail.stan', line 25, column 11 to column 15)",
  " (in 'copy_fail.stan', line 25, column 17 to column 28)",
  " (in 'copy_fail.stan', line 25, column 4 to column 34)",
  " (in 'copy_fail.stan', line 28, column 6 to column 32)",
  " (in 'copy_fail.stan', line 31, column 8 to column 37)",
  " (in 'copy_fail.stan', line 32, column 8 to column 32)",
  " (in 'copy_fail.stan', line 40, column 8 to line 42, column 44)",
  " (in 'copy_fail.stan', line 29, column 39 to line 43, column 7)",
  " (in 'copy_fail.stan', line 29, column 6 to line 43, column 7)",
  " (in 'copy_fail.stan', line 27, column 24 to line 44, column 5)",
  " (in 'copy_fail.stan', line 27, column 4 to line 44, column 5)",
  " (in 'copy_fail.stan', line 45, column 4 to column 15)",
  " (in 'copy_fail.stan', line 100, column 8 to column 37)",
  " (in 'copy_fail.stan', line 101, column 8 to column 41)",
  " (in 'copy_fail.stan', line 99, column 42 to line 102, column 7)",
  " (in 'copy_fail.stan', line 103, column 6 to column 37)",
  " (in 'copy_fail.stan', line 98, column 22 to line 104, column 5)",
  " (in 'copy_fail.stan', line 97, column 22 to line 105, column 3)",
  " (in 'copy_fail.stan', line 97, column 2 to line 105, column 3)",
  " (in 'copy_fail.stan', line 49, column 2 to column 20)",
  " (in 'copy_fail.stan', line 50, column 2 to column 27)",
  " (in 'copy_fail.stan', line 51, column 8 to column 12)",
  " (in 'copy_fail.stan', line 51, column 14 to column 25)",
  " (in 'copy_fail.stan', line 51, column 2 to column 51)",
  " (in 'copy_fail.stan', line 52, column 2 to column 23)",
  " (in 'copy_fail.stan', line 53, column 8 to column 12)",
  " (in 'copy_fail.stan', line 53, column 2 to column 61)",
  " (in 'copy_fail.stan', line 56, column 2 to column 38)",
  " (in 'copy_fail.stan', line 58, column 8 to column 12)",
  " (in 'copy_fail.stan', line 58, column 2 to column 52)",
  " (in 'copy_fail.stan', line 59, column 8 to column 12)",
  " (in 'copy_fail.stan', line 59, column 2 to column 51)",
  " (in 'copy_fail.stan', line 63, column 4 to column 35)",
  " (in 'copy_fail.stan', line 62, column 2 to line 63, column 35)",
  " (in 'copy_fail.stan', line 65, column 4 to column 33)",
  " (in 'copy_fail.stan', line 64, column 2 to line 65, column 33)",
  " (in 'copy_fail.stan', line 69, column 27 to column 34)",
  " (in 'copy_fail.stan', line 72, column 27 to column 31)",
  " (in 'copy_fail.stan', line 72, column 33 to column 46)",
  " (in 'copy_fail.stan', line 73, column 27 to column 31)",
  " (in 'copy_fail.stan', line 73, column 33 to column 46)",
  " (in 'copy_fail.stan', line 74, column 27 to column 31)",
  " (in 'copy_fail.stan', line 74, column 33 to column 44)",
  " (in 'copy_fail.stan', line 8, column 8 to column 17)",
  " (in 'copy_fail.stan', line 7, column 6 to line 8, column 17)",
  " (in 'copy_fail.stan', line 9, column 4 to column 13)",
  " (in 'copy_fail.stan', line 5, column 37 to line 10, column 3)",
  " (in 'copy_fail.stan', line 15, column 6 to column 32)",
  " (in 'copy_fail.stan', line 19, column 8 to column 17)",
  " (in 'copy_fail.stan', line 18, column 6 to line 19, column 17)",
  " (in 'copy_fail.stan', line 13, column 39 to line 20, column 5)",
  " (in 'copy_fail.stan', line 21, column 4 to column 13)",
  " (in 'copy_fail.stan', line 12, column 36 to line 22, column 3)",
  " (in 'copy_fail.stan', line 24, column 74 to line 46, column 3)"};
int first_capture(const std::vector<int>& y_i, std::ostream* pstream__);
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__);
template <typename T2__, typename T3__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T2__>,
                stan::base_type_t<T3__>>,-1,-1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__);
int first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym25__;
    int lcm_sym24__;
    int lcm_sym23__;
    int lcm_sym22__;
    {
      lcm_sym23__ = stan::math::size(y_i);
      if (stan::math::logical_gte(lcm_sym23__, 1)) {
        current_statement__ = 58;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(1))) {
          current_statement__ = 57;
          return 1;
        }
        for (int k = 2; k <= lcm_sym23__; ++k) {
          current_statement__ = 58;
          if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
            current_statement__ = 57;
            return k;
          }
        }
      }
      current_statement__ = 59;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym31__;
    int lcm_sym30__;
    int lcm_sym29__;
    int lcm_sym28__;
    int lcm_sym27__;
    int lcm_sym26__;
    {
      lcm_sym29__ = (stan::math::size(y_i) - 1);
      if (stan::math::logical_gte(lcm_sym29__, 0)) {
        int k = std::numeric_limits<int>::min();
        lcm_sym28__ = (stan::math::size(y_i) - 0);
        current_statement__ = 63;
        if (y_i[(lcm_sym28__ - 1)]) {
          current_statement__ = 62;
          return lcm_sym28__;
        }
        for (int k_rev = 1; k_rev <= lcm_sym29__; ++k_rev) {
          int k = std::numeric_limits<int>::min();
          lcm_sym27__ = (stan::math::size(y_i) - k_rev);
          current_statement__ = 63;
          if (y_i[(lcm_sym27__ - 1)]) {
            current_statement__ = 62;
            return lcm_sym27__;
          }
        }
      }
      current_statement__ = 65;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T2__, typename T3__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T2__>,
                stan::base_type_t<T3__>>,-1,-1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T2__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  const auto& p = stan::math::to_ref(p_arg__);
  const auto& phi = stan::math::to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym41__;
    double lcm_sym40__;
    double lcm_sym39__;
    double lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    int lcm_sym35__;
    int lcm_sym34__;
    int lcm_sym33__;
    int lcm_sym32__;
    {
      current_statement__ = 14;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 15;
      stan::math::validate_non_negative_index("chi", "n_occasions",
        n_occasions);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
          DUMMY_VAR__);
      current_statement__ = 24;
      if (stan::math::logical_gte(nind, 1)) {
        current_statement__ = 17;
        stan::model::assign(chi, 1.0, "assigning variable chi",
          stan::model::index_uni(1), stan::model::index_uni(n_occasions));
        lcm_sym35__ = (n_occasions - 1);
        lcm_sym33__ = stan::math::logical_gte(lcm_sym35__, 1);
        if (lcm_sym33__) {
          int t_curr = std::numeric_limits<int>::min();
          int t_next = std::numeric_limits<int>::min();
          lcm_sym37__ = (lcm_sym35__ + 1);
          current_statement__ = 20;
          stan::model::assign(chi,
            stan::math::fma(
              (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                 stan::model::index_uni(lcm_sym35__)) * (1 -
              stan::model::rvalue(p, "p", stan::model::index_uni(1),
                stan::model::index_uni((lcm_sym37__ - 1))))),
              stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym37__)), (1 -
              stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym35__)))),
            "assigning variable chi", stan::model::index_uni(1),
            stan::model::index_uni(lcm_sym35__));
          for (int t = 2; t <= lcm_sym35__; ++t) {
            int t_curr = std::numeric_limits<int>::min();
            lcm_sym34__ = (n_occasions - t);
            int t_next = std::numeric_limits<int>::min();
            lcm_sym36__ = (lcm_sym34__ + 1);
            current_statement__ = 20;
            stan::model::assign(chi,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym34__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym36__ - 1))))),
                stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym36__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym34__)))),
              "assigning variable chi", stan::model::index_uni(1),
              stan::model::index_uni(lcm_sym34__));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 17;
          stan::model::assign(chi, 1.0, "assigning variable chi",
            stan::model::index_uni(i), stan::model::index_uni(n_occasions));
          current_statement__ = 22;
          if (lcm_sym33__) {
            int t_curr = std::numeric_limits<int>::min();
            int t_next = std::numeric_limits<int>::min();
            lcm_sym37__ = (lcm_sym35__ + 1);
            current_statement__ = 20;
            stan::model::assign(chi,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                   stan::model::index_uni(lcm_sym35__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(i),
                  stan::model::index_uni((lcm_sym37__ - 1))))),
                stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym37__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym35__)))),
              "assigning variable chi", stan::model::index_uni(i),
              stan::model::index_uni(lcm_sym35__));
            for (int t = 2; t <= lcm_sym35__; ++t) {
              int t_curr = std::numeric_limits<int>::min();
              lcm_sym34__ = (n_occasions - t);
              int t_next = std::numeric_limits<int>::min();
              lcm_sym36__ = (lcm_sym34__ + 1);
              current_statement__ = 20;
              stan::model::assign(chi,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                     stan::model::index_uni(lcm_sym34__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(i),
                    stan::model::index_uni((lcm_sym36__ - 1))))),
                  stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym36__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym34__)))),
                "assigning variable chi", stan::model::index_uni(i),
                stan::model::index_uni(lcm_sym34__));
            }
          }
        }
      }
      current_statement__ = 25;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class copy_fail_model final : public model_base_crtp<copy_fail_model> {
 private:
  int lcm_sym171__;
  int lcm_sym170__;
  int lcm_sym169__;
  int lcm_sym168__;
  int lcm_sym167__;
  int lcm_sym166__;
  int lcm_sym165__;
  int lcm_sym164__;
  int lcm_sym163__;
  int lcm_sym162__;
  int lcm_sym161__;
  int lcm_sym160__;
  int lcm_sym159__;
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int max_age;
  std::vector<std::vector<int>> x;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last;
 public:
  ~copy_fail_model() {}
  copy_fail_model(stan::io::var_context& context__, unsigned int
                  random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "copy_fail_model_namespace::copy_fail_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 33;
      context__.validate_dims("data initialization", "nind", "int",
        std::vector<size_t>{});
      nind = std::numeric_limits<int>::min();
      current_statement__ = 33;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 33;
      stan::math::check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 34;
      context__.validate_dims("data initialization", "n_occasions", "int",
        std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      current_statement__ = 34;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 34;
      stan::math::check_greater_or_equal(function__, "n_occasions",
        n_occasions, 2);
      current_statement__ = 35;
      stan::math::validate_non_negative_index("y", "nind", nind);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 37;
      context__.validate_dims("data initialization", "y", "int",
        std::vector<size_t>{static_cast<size_t>(nind),
          static_cast<size_t>(n_occasions)});
      y = std::vector<std::vector<int>>(nind,
            std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      {
        std::vector<int> y_flat__;
        current_statement__ = 37;
        y_flat__ = context__.vals_i("y");
        pos__ = 1;
        if (stan::math::logical_gte(n_occasions, 1)) {
          lcm_sym160__ = stan::math::logical_gte(nind, 1);
          if (lcm_sym160__) {
            stan::model::assign(y,
              stan::model::rvalue(y_flat__, "y_flat__",
                stan::model::index_uni(1)), "assigning variable y",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
            if (lcm_sym160__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                stan::model::assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        } else {
          lcm_sym160__ = stan::math::logical_gte(nind, 1);
        }
      }
      current_statement__ = 37;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 37;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 38;
      context__.validate_dims("data initialization", "max_age", "int",
        std::vector<size_t>{});
      max_age = std::numeric_limits<int>::min();
      current_statement__ = 38;
      max_age = context__.vals_i("max_age")[(1 - 1)];
      current_statement__ = 38;
      stan::math::check_greater_or_equal(function__, "max_age", max_age, 1);
      current_statement__ = 39;
      stan::math::validate_non_negative_index("x", "nind", nind);
      lcm_sym162__ = (n_occasions - 1);
      stan::math::validate_non_negative_index("x", "n_occasions - 1",
        lcm_sym162__);
      current_statement__ = 40;
      context__.validate_dims("data initialization", "x", "int",
        std::vector<size_t>{static_cast<size_t>(nind),
          static_cast<size_t>(lcm_sym162__)});
      x = std::vector<std::vector<int>>(nind,
            std::vector<int>(lcm_sym162__, std::numeric_limits<int>::min()));
      {
        std::vector<int> x_flat__;
        current_statement__ = 40;
        x_flat__ = context__.vals_i("x");
        pos__ = 1;
        if (stan::math::logical_gte(lcm_sym162__, 1)) {
          if (lcm_sym160__) {
            stan::model::assign(x,
              stan::model::rvalue(x_flat__, "x_flat__",
                stan::model::index_uni(1)), "assigning variable x",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
              stan::model::assign(x, x_flat__[(pos__ - 1)],
                "assigning variable x", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= lcm_sym162__; ++sym1__) {
            if (lcm_sym160__) {
              stan::model::assign(x, x_flat__[(pos__ - 1)],
                "assigning variable x", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                stan::model::assign(x, x_flat__[(pos__ - 1)],
                  "assigning variable x", stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 40;
      stan::math::check_greater_or_equal(function__, "x", x, 0);
      current_statement__ = 40;
      stan::math::check_less_or_equal(function__, "x", x, max_age);
      current_statement__ = 41;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      current_statement__ = 41;
      n_occ_minus_1 = lcm_sym162__;
      current_statement__ = 42;
      stan::math::validate_non_negative_index("first", "nind", nind);
      current_statement__ = 43;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      current_statement__ = 44;
      stan::math::validate_non_negative_index("last", "nind", nind);
      current_statement__ = 45;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      current_statement__ = 47;
      if (lcm_sym160__) {
        current_statement__ = 46;
        stan::model::assign(first,
          first_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(1)), pstream__),
          "assigning variable first", stan::model::index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 46;
          stan::model::assign(first,
            first_capture(
              stan::model::rvalue(y, "y", stan::model::index_uni(i)),
              pstream__), "assigning variable first",
            stan::model::index_uni(i));
        }
      }
      current_statement__ = 49;
      if (lcm_sym160__) {
        current_statement__ = 48;
        stan::model::assign(last,
          last_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(1)), pstream__),
          "assigning variable last", stan::model::index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 48;
          stan::model::assign(last,
            last_capture(
              stan::model::rvalue(y, "y", stan::model::index_uni(i)),
              pstream__), "assigning variable last",
            stan::model::index_uni(i));
        }
      }
      current_statement__ = 43;
      stan::math::check_greater_or_equal(function__, "first", first, 0);
      current_statement__ = 43;
      stan::math::check_less_or_equal(function__, "first", first, n_occasions);
      current_statement__ = 45;
      stan::math::check_greater_or_equal(function__, "last", last, 0);
      current_statement__ = 45;
      stan::math::check_less_or_equal(function__, "last", last, n_occasions);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("beta", "max_age", max_age);
      current_statement__ = 51;
      stan::math::validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 52;
      stan::math::validate_non_negative_index("phi", "n_occ_minus_1",
        lcm_sym162__);
      current_statement__ = 53;
      stan::math::validate_non_negative_index("p", "nind", nind);
      current_statement__ = 54;
      stan::math::validate_non_negative_index("p", "n_occ_minus_1",
        lcm_sym162__);
      current_statement__ = 55;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 56;
      stan::math::validate_non_negative_index("chi", "n_occasions",
        n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + max_age;
  }
  inline std::string model_name() const final {
    return "copy_fail_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "copy_fail_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym158__;
      int lcm_sym157__;
      int lcm_sym156__;
      int lcm_sym155__;
      int lcm_sym154__;
      double lcm_sym153__;
      double lcm_sym152__;
      double lcm_sym151__;
      double lcm_sym150__;
      double lcm_sym149__;
      double lcm_sym148__;
      double lcm_sym147__;
      double lcm_sym146__;
      double lcm_sym145__;
      double lcm_sym144__;
      double lcm_sym143__;
      double lcm_sym142__;
      double lcm_sym141__;
      double lcm_sym140__;
      double lcm_sym139__;
      double lcm_sym138__;
      double lcm_sym137__;
      double lcm_sym136__;
      int lcm_sym135__;
      int lcm_sym134__;
      int lcm_sym133__;
      int lcm_sym132__;
      int lcm_sym131__;
      int lcm_sym130__;
      int lcm_sym129__;
      int lcm_sym128__;
      int lcm_sym127__;
      int lcm_sym126__;
      int lcm_sym125__;
      int lcm_sym124__;
      int lcm_sym123__;
      int lcm_sym122__;
      int lcm_sym121__;
      int lcm_sym120__;
      int lcm_sym119__;
      int lcm_sym118__;
      int lcm_sym117__;
      int lcm_sym116__;
      local_scalar_t__ mean_p;
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, 1, lp__,
               max_age);
      Eigen::Matrix<local_scalar_t__,-1,-1> phi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
          DUMMY_VAR__);
      lcm_sym116__ = stan::math::logical_gte(nind, 1);
      if (lcm_sym116__) {
        lcm_sym155__ = stan::model::rvalue(first, "first",
                         stan::model::index_uni(1));
        lcm_sym129__ = (lcm_sym155__ - 1);
        if (stan::math::logical_gte(lcm_sym129__, 1)) {
          stan::model::assign(phi, 0, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          current_statement__ = 6;
          stan::model::assign(p, 0, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int t = 2; t <= lcm_sym129__; ++t) {
            current_statement__ = 7;
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        lcm_sym127__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym127__, lcm_sym155__)) {
          current_statement__ = 9;
          stan::model::assign(phi,
            stan::model::rvalue(beta, "beta",
              stan::model::index_uni(
                stan::model::rvalue(x, "x", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym155__)))),
            "assigning variable phi", stan::model::index_uni(1),
            stan::model::index_uni(lcm_sym155__));
          lcm_sym135__ = (lcm_sym155__ + 1);
          stan::model::assign(p, mean_p, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym155__));
          for (int t = lcm_sym135__; t <= lcm_sym127__; ++t) {
            current_statement__ = 9;
            stan::model::assign(phi,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni(
                  stan::model::rvalue(x, "x", stan::model::index_uni(1),
                    stan::model::index_uni(t)))), "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 10;
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          lcm_sym154__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(i));
          lcm_sym128__ = (lcm_sym154__ - 1);
          if (stan::math::logical_gte(lcm_sym128__, 1)) {
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(1));
            for (int t = 2; t <= lcm_sym128__; ++t) {
              current_statement__ = 7;
              stan::model::assign(phi, 0, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 6;
              stan::model::assign(p, 0, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
          current_statement__ = 12;
          if (stan::math::logical_gte(lcm_sym127__, lcm_sym154__)) {
            current_statement__ = 9;
            stan::model::assign(phi,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni(
                  stan::model::rvalue(x, "x", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym154__)))),
              "assigning variable phi", stan::model::index_uni(i),
              stan::model::index_uni(lcm_sym154__));
            lcm_sym134__ = (lcm_sym154__ + 1);
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym154__));
            for (int t = lcm_sym134__; t <= lcm_sym127__; ++t) {
              current_statement__ = 9;
              stan::model::assign(phi,
                stan::model::rvalue(beta, "beta",
                  stan::model::index_uni(
                    stan::model::rvalue(x, "x", stan::model::index_uni(i),
                      stan::model::index_uni(t)))), "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 10;
              stan::model::assign(p, mean_p, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
        }
      }
      Eigen::Matrix<local_scalar_t__,-1,-1>
        inline_prob_uncaptured_return_sym15__;
      {
        current_statement__ = 14;
        stan::math::validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          n_occasions);
        Eigen::Matrix<local_scalar_t__,-1,-1>
          inline_prob_uncaptured_chi_sym16__ =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
            DUMMY_VAR__);
        current_statement__ = 24;
        if (lcm_sym116__) {
          current_statement__ = 17;
          stan::model::assign(inline_prob_uncaptured_chi_sym16__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym16__",
            stan::model::index_uni(1), stan::model::index_uni(n_occasions));
          lcm_sym127__ = (n_occasions - 1);
          lcm_sym117__ = stan::math::logical_gte(lcm_sym127__, 1);
          if (lcm_sym117__) {
            int inline_prob_uncaptured_t_curr_sym17__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym18__ =
              std::numeric_limits<int>::min();
            lcm_sym131__ = (lcm_sym127__ + 1);
            current_statement__ = 20;
            stan::model::assign(inline_prob_uncaptured_chi_sym16__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym127__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym131__ - 1))))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                  "inline_prob_uncaptured_chi_sym16__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym131__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym127__)))),
              "assigning variable inline_prob_uncaptured_chi_sym16__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym127__));
            for (int inline_prob_uncaptured_t_sym19__ = 2; inline_prob_uncaptured_t_sym19__
                 <= lcm_sym127__; ++inline_prob_uncaptured_t_sym19__) {
              int inline_prob_uncaptured_t_curr_sym17__ =
                std::numeric_limits<int>::min();
              lcm_sym126__ = (n_occasions -
                inline_prob_uncaptured_t_sym19__);
              int inline_prob_uncaptured_t_next_sym18__ =
                std::numeric_limits<int>::min();
              lcm_sym130__ = (lcm_sym126__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym16__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym126__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni((lcm_sym130__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                    "inline_prob_uncaptured_chi_sym16__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym130__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym126__)))),
                "assigning variable inline_prob_uncaptured_chi_sym16__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym126__));
            }
          }
          for (int inline_prob_uncaptured_i_sym20__ = 2; inline_prob_uncaptured_i_sym20__
               <= nind; ++inline_prob_uncaptured_i_sym20__) {
            current_statement__ = 17;
            stan::model::assign(inline_prob_uncaptured_chi_sym16__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym16__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
              stan::model::index_uni(n_occasions));
            current_statement__ = 22;
            if (lcm_sym117__) {
              int inline_prob_uncaptured_t_curr_sym17__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym18__ =
                std::numeric_limits<int>::min();
              lcm_sym131__ = (lcm_sym127__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym16__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                     stan::model::index_uni(lcm_sym127__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                    stan::model::index_uni((lcm_sym131__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                    "inline_prob_uncaptured_chi_sym16__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                    stan::model::index_uni(lcm_sym131__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                    stan::model::index_uni(lcm_sym127__)))),
                "assigning variable inline_prob_uncaptured_chi_sym16__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                stan::model::index_uni(lcm_sym127__));
              for (int inline_prob_uncaptured_t_sym19__ = 2; inline_prob_uncaptured_t_sym19__
                   <= lcm_sym127__; ++inline_prob_uncaptured_t_sym19__) {
                int inline_prob_uncaptured_t_curr_sym17__ =
                  std::numeric_limits<int>::min();
                lcm_sym126__ = (n_occasions -
                  inline_prob_uncaptured_t_sym19__);
                int inline_prob_uncaptured_t_next_sym18__ =
                  std::numeric_limits<int>::min();
                lcm_sym130__ = (lcm_sym126__ + 1);
                current_statement__ = 20;
                stan::model::assign(inline_prob_uncaptured_chi_sym16__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(
                         inline_prob_uncaptured_i_sym20__),
                       stan::model::index_uni(lcm_sym126__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                      stan::model::index_uni((lcm_sym130__ - 1))))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                      "inline_prob_uncaptured_chi_sym16__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                      stan::model::index_uni(lcm_sym130__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                      stan::model::index_uni(lcm_sym126__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym16__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                  stan::model::index_uni(lcm_sym126__));
              }
            }
          }
        }
        current_statement__ = 25;
        stan::model::assign(inline_prob_uncaptured_return_sym15__,
          inline_prob_uncaptured_chi_sym16__,
          "assigning variable inline_prob_uncaptured_return_sym15__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym15__,
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym15__, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym15__, 1);
      {
        current_statement__ = 32;
        if (lcm_sym116__) {
          lcm_sym155__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(1));
          if (stan::math::logical_gt(lcm_sym155__, 0)) {
            lcm_sym157__ = stan::model::rvalue(last, "last",
                             stan::model::index_uni(1));
            lcm_sym135__ = (lcm_sym155__ + 1);
            if (stan::math::logical_gte(lcm_sym157__, lcm_sym135__)) {
              current_statement__ = 26;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym135__ - 1)))));
              lcm_sym133__ = (lcm_sym135__ + 1);
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(lcm_sym135__)),
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym135__ - 1)))));
              for (int t = lcm_sym133__; t <= lcm_sym157__; ++t) {
                current_statement__ = 26;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
                current_statement__ = 27;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni(t)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
              }
            }
            current_statement__ = 29;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             stan::model::rvalue(
                               inline_prob_uncaptured_return_sym15__,
                               "inline_prob_uncaptured_return_sym15__",
                               stan::model::index_uni(1),
                               stan::model::index_uni(lcm_sym157__))));
          }
          for (int i = 2; i <= nind; ++i) {
            lcm_sym154__ = stan::model::rvalue(first, "first",
                             stan::model::index_uni(i));
            if (stan::math::logical_gt(lcm_sym154__, 0)) {
              lcm_sym156__ = stan::model::rvalue(last, "last",
                               stan::model::index_uni(i));
              lcm_sym134__ = (lcm_sym154__ + 1);
              if (stan::math::logical_gte(lcm_sym156__, lcm_sym134__)) {
                current_statement__ = 26;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym134__ - 1)))));
                lcm_sym132__ = (lcm_sym134__ + 1);
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(lcm_sym134__)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym134__ - 1)))));
                for (int t = lcm_sym132__; t <= lcm_sym156__; ++t) {
                  current_statement__ = 26;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(phi, "phi",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                  current_statement__ = 27;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni(t)),
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                }
              }
              current_statement__ = 29;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(
                                 inline_prob_uncaptured_return_sym15__,
                                 "inline_prob_uncaptured_return_sym15__",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(lcm_sym156__))));
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "copy_fail_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym115__;
      int lcm_sym114__;
      int lcm_sym113__;
      int lcm_sym112__;
      int lcm_sym111__;
      double lcm_sym110__;
      double lcm_sym109__;
      double lcm_sym108__;
      double lcm_sym107__;
      double lcm_sym106__;
      double lcm_sym105__;
      double lcm_sym104__;
      double lcm_sym103__;
      double lcm_sym102__;
      double lcm_sym101__;
      double lcm_sym100__;
      double lcm_sym99__;
      double lcm_sym98__;
      double lcm_sym97__;
      double lcm_sym96__;
      double lcm_sym95__;
      double lcm_sym94__;
      double lcm_sym93__;
      int lcm_sym92__;
      int lcm_sym91__;
      int lcm_sym90__;
      int lcm_sym89__;
      int lcm_sym88__;
      int lcm_sym87__;
      int lcm_sym86__;
      int lcm_sym85__;
      int lcm_sym84__;
      int lcm_sym83__;
      int lcm_sym82__;
      int lcm_sym81__;
      int lcm_sym80__;
      int lcm_sym79__;
      int lcm_sym78__;
      int lcm_sym77__;
      int lcm_sym76__;
      int lcm_sym75__;
      int lcm_sym74__;
      int lcm_sym73__;
      local_scalar_t__ mean_p;
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, 1, lp__,
               max_age);
      Eigen::Matrix<local_scalar_t__,-1,-1> phi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
          DUMMY_VAR__);
      lcm_sym73__ = stan::math::logical_gte(nind, 1);
      if (lcm_sym73__) {
        lcm_sym112__ = stan::model::rvalue(first, "first",
                         stan::model::index_uni(1));
        lcm_sym86__ = (lcm_sym112__ - 1);
        if (stan::math::logical_gte(lcm_sym86__, 1)) {
          stan::model::assign(phi, 0, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          current_statement__ = 6;
          stan::model::assign(p, 0, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int t = 2; t <= lcm_sym86__; ++t) {
            current_statement__ = 7;
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        lcm_sym84__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym84__, lcm_sym112__)) {
          current_statement__ = 9;
          stan::model::assign(phi,
            stan::model::rvalue(beta, "beta",
              stan::model::index_uni(
                stan::model::rvalue(x, "x", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym112__)))),
            "assigning variable phi", stan::model::index_uni(1),
            stan::model::index_uni(lcm_sym112__));
          lcm_sym92__ = (lcm_sym112__ + 1);
          stan::model::assign(p, mean_p, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym112__));
          for (int t = lcm_sym92__; t <= lcm_sym84__; ++t) {
            current_statement__ = 9;
            stan::model::assign(phi,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni(
                  stan::model::rvalue(x, "x", stan::model::index_uni(1),
                    stan::model::index_uni(t)))), "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 10;
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          lcm_sym111__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(i));
          lcm_sym85__ = (lcm_sym111__ - 1);
          if (stan::math::logical_gte(lcm_sym85__, 1)) {
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(1));
            for (int t = 2; t <= lcm_sym85__; ++t) {
              current_statement__ = 7;
              stan::model::assign(phi, 0, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 6;
              stan::model::assign(p, 0, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
          current_statement__ = 12;
          if (stan::math::logical_gte(lcm_sym84__, lcm_sym111__)) {
            current_statement__ = 9;
            stan::model::assign(phi,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni(
                  stan::model::rvalue(x, "x", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym111__)))),
              "assigning variable phi", stan::model::index_uni(i),
              stan::model::index_uni(lcm_sym111__));
            lcm_sym91__ = (lcm_sym111__ + 1);
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym111__));
            for (int t = lcm_sym91__; t <= lcm_sym84__; ++t) {
              current_statement__ = 9;
              stan::model::assign(phi,
                stan::model::rvalue(beta, "beta",
                  stan::model::index_uni(
                    stan::model::rvalue(x, "x", stan::model::index_uni(i),
                      stan::model::index_uni(t)))), "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 10;
              stan::model::assign(p, mean_p, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
        }
      }
      Eigen::Matrix<local_scalar_t__,-1,-1>
        inline_prob_uncaptured_return_sym8__;
      {
        current_statement__ = 14;
        stan::math::validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          n_occasions);
        Eigen::Matrix<local_scalar_t__,-1,-1>
          inline_prob_uncaptured_chi_sym9__ =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
            DUMMY_VAR__);
        current_statement__ = 24;
        if (lcm_sym73__) {
          current_statement__ = 17;
          stan::model::assign(inline_prob_uncaptured_chi_sym9__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym9__",
            stan::model::index_uni(1), stan::model::index_uni(n_occasions));
          lcm_sym84__ = (n_occasions - 1);
          lcm_sym74__ = stan::math::logical_gte(lcm_sym84__, 1);
          if (lcm_sym74__) {
            int inline_prob_uncaptured_t_curr_sym10__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym11__ =
              std::numeric_limits<int>::min();
            lcm_sym88__ = (lcm_sym84__ + 1);
            current_statement__ = 20;
            stan::model::assign(inline_prob_uncaptured_chi_sym9__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym84__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym88__ - 1))))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                  "inline_prob_uncaptured_chi_sym9__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym88__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym84__)))),
              "assigning variable inline_prob_uncaptured_chi_sym9__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym84__));
            for (int inline_prob_uncaptured_t_sym12__ = 2; inline_prob_uncaptured_t_sym12__
                 <= lcm_sym84__; ++inline_prob_uncaptured_t_sym12__) {
              int inline_prob_uncaptured_t_curr_sym10__ =
                std::numeric_limits<int>::min();
              lcm_sym83__ = (n_occasions - inline_prob_uncaptured_t_sym12__);
              int inline_prob_uncaptured_t_next_sym11__ =
                std::numeric_limits<int>::min();
              lcm_sym87__ = (lcm_sym83__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym9__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym83__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni((lcm_sym87__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                    "inline_prob_uncaptured_chi_sym9__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym87__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym83__)))),
                "assigning variable inline_prob_uncaptured_chi_sym9__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym83__));
            }
          }
          for (int inline_prob_uncaptured_i_sym13__ = 2; inline_prob_uncaptured_i_sym13__
               <= nind; ++inline_prob_uncaptured_i_sym13__) {
            current_statement__ = 17;
            stan::model::assign(inline_prob_uncaptured_chi_sym9__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym9__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
              stan::model::index_uni(n_occasions));
            current_statement__ = 22;
            if (lcm_sym74__) {
              int inline_prob_uncaptured_t_curr_sym10__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym11__ =
                std::numeric_limits<int>::min();
              lcm_sym88__ = (lcm_sym84__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym9__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                     stan::model::index_uni(lcm_sym84__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                    stan::model::index_uni((lcm_sym88__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                    "inline_prob_uncaptured_chi_sym9__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                    stan::model::index_uni(lcm_sym88__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                    stan::model::index_uni(lcm_sym84__)))),
                "assigning variable inline_prob_uncaptured_chi_sym9__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                stan::model::index_uni(lcm_sym84__));
              for (int inline_prob_uncaptured_t_sym12__ = 2; inline_prob_uncaptured_t_sym12__
                   <= lcm_sym84__; ++inline_prob_uncaptured_t_sym12__) {
                int inline_prob_uncaptured_t_curr_sym10__ =
                  std::numeric_limits<int>::min();
                lcm_sym83__ = (n_occasions -
                  inline_prob_uncaptured_t_sym12__);
                int inline_prob_uncaptured_t_next_sym11__ =
                  std::numeric_limits<int>::min();
                lcm_sym87__ = (lcm_sym83__ + 1);
                current_statement__ = 20;
                stan::model::assign(inline_prob_uncaptured_chi_sym9__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(
                         inline_prob_uncaptured_i_sym13__),
                       stan::model::index_uni(lcm_sym83__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                      stan::model::index_uni((lcm_sym87__ - 1))))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                      "inline_prob_uncaptured_chi_sym9__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                      stan::model::index_uni(lcm_sym87__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                      stan::model::index_uni(lcm_sym83__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym9__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                  stan::model::index_uni(lcm_sym83__));
              }
            }
          }
        }
        current_statement__ = 25;
        stan::model::assign(inline_prob_uncaptured_return_sym8__,
          inline_prob_uncaptured_chi_sym9__,
          "assigning variable inline_prob_uncaptured_return_sym8__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym8__,
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym8__, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym8__, 1);
      {
        current_statement__ = 32;
        if (lcm_sym73__) {
          lcm_sym112__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(1));
          if (stan::math::logical_gt(lcm_sym112__, 0)) {
            lcm_sym114__ = stan::model::rvalue(last, "last",
                             stan::model::index_uni(1));
            lcm_sym92__ = (lcm_sym112__ + 1);
            if (stan::math::logical_gte(lcm_sym114__, lcm_sym92__)) {
              current_statement__ = 26;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym92__ - 1)))));
              lcm_sym90__ = (lcm_sym92__ + 1);
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(lcm_sym92__)),
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym92__ - 1)))));
              for (int t = lcm_sym90__; t <= lcm_sym114__; ++t) {
                current_statement__ = 26;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
                current_statement__ = 27;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni(t)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
              }
            }
            current_statement__ = 29;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             stan::model::rvalue(
                               inline_prob_uncaptured_return_sym8__,
                               "inline_prob_uncaptured_return_sym8__",
                               stan::model::index_uni(1),
                               stan::model::index_uni(lcm_sym114__))));
          }
          for (int i = 2; i <= nind; ++i) {
            lcm_sym111__ = stan::model::rvalue(first, "first",
                             stan::model::index_uni(i));
            if (stan::math::logical_gt(lcm_sym111__, 0)) {
              lcm_sym113__ = stan::model::rvalue(last, "last",
                               stan::model::index_uni(i));
              lcm_sym91__ = (lcm_sym111__ + 1);
              if (stan::math::logical_gte(lcm_sym113__, lcm_sym91__)) {
                current_statement__ = 26;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym91__ - 1)))));
                lcm_sym89__ = (lcm_sym91__ + 1);
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(lcm_sym91__)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym91__ - 1)))));
                for (int t = lcm_sym89__; t <= lcm_sym113__; ++t) {
                  current_statement__ = 26;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(phi, "phi",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                  current_statement__ = 27;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni(t)),
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                }
              }
              current_statement__ = 29;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(
                                 inline_prob_uncaptured_return_sym8__,
                                 "inline_prob_uncaptured_return_sym8__",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(lcm_sym113__))));
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "copy_fail_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym72__;
      int lcm_sym71__;
      int lcm_sym70__;
      double lcm_sym69__;
      double lcm_sym68__;
      double lcm_sym67__;
      double lcm_sym66__;
      double lcm_sym65__;
      double lcm_sym64__;
      double lcm_sym63__;
      double lcm_sym62__;
      int lcm_sym61__;
      int lcm_sym60__;
      int lcm_sym59__;
      int lcm_sym58__;
      int lcm_sym57__;
      int lcm_sym56__;
      int lcm_sym55__;
      int lcm_sym54__;
      int lcm_sym53__;
      int lcm_sym52__;
      int lcm_sym51__;
      int lcm_sym50__;
      int lcm_sym49__;
      int lcm_sym48__;
      int lcm_sym47__;
      int lcm_sym46__;
      double mean_p;
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<double,-1,1> beta;
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, 1, lp__,
               max_age);
      Eigen::Matrix<double,-1,-1> phi =
        Eigen::Matrix<double,-1,-1>::Constant(nind, (n_occasions - 1),
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> p =
        Eigen::Matrix<double,-1,-1>::Constant(nind, (n_occasions - 1),
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> chi =
        Eigen::Matrix<double,-1,-1>::Constant(nind, n_occasions,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(mean_p);
      out__.write(beta);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      lcm_sym46__ = stan::math::logical_gte(nind, 1);
      if (lcm_sym46__) {
        lcm_sym71__ = stan::model::rvalue(first, "first",
                        stan::model::index_uni(1));
        lcm_sym55__ = (lcm_sym71__ - 1);
        if (stan::math::logical_gte(lcm_sym55__, 1)) {
          stan::model::assign(phi, 0, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          current_statement__ = 6;
          stan::model::assign(p, 0, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int t = 2; t <= lcm_sym55__; ++t) {
            current_statement__ = 7;
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        lcm_sym53__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym53__, lcm_sym71__)) {
          current_statement__ = 9;
          stan::model::assign(phi,
            stan::model::rvalue(beta, "beta",
              stan::model::index_uni(
                stan::model::rvalue(x, "x", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym71__)))),
            "assigning variable phi", stan::model::index_uni(1),
            stan::model::index_uni(lcm_sym71__));
          lcm_sym61__ = (lcm_sym71__ + 1);
          stan::model::assign(p, mean_p, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym71__));
          for (int t = lcm_sym61__; t <= lcm_sym53__; ++t) {
            current_statement__ = 9;
            stan::model::assign(phi,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni(
                  stan::model::rvalue(x, "x", stan::model::index_uni(1),
                    stan::model::index_uni(t)))), "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 10;
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          lcm_sym70__ = stan::model::rvalue(first, "first",
                          stan::model::index_uni(i));
          lcm_sym54__ = (lcm_sym70__ - 1);
          if (stan::math::logical_gte(lcm_sym54__, 1)) {
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(1));
            for (int t = 2; t <= lcm_sym54__; ++t) {
              current_statement__ = 7;
              stan::model::assign(phi, 0, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 6;
              stan::model::assign(p, 0, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
          current_statement__ = 12;
          if (stan::math::logical_gte(lcm_sym53__, lcm_sym70__)) {
            current_statement__ = 9;
            stan::model::assign(phi,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni(
                  stan::model::rvalue(x, "x", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym70__)))),
              "assigning variable phi", stan::model::index_uni(i),
              stan::model::index_uni(lcm_sym70__));
            lcm_sym60__ = (lcm_sym70__ + 1);
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym70__));
            for (int t = lcm_sym60__; t <= lcm_sym53__; ++t) {
              current_statement__ = 9;
              stan::model::assign(phi,
                stan::model::rvalue(beta, "beta",
                  stan::model::index_uni(
                    stan::model::rvalue(x, "x", stan::model::index_uni(i),
                      stan::model::index_uni(t)))), "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 10;
              stan::model::assign(p, mean_p, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
        }
      }
      Eigen::Matrix<double,-1,-1> inline_prob_uncaptured_return_sym1__;
      {
        current_statement__ = 14;
        stan::math::validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          n_occasions);
        Eigen::Matrix<double,-1,-1> inline_prob_uncaptured_chi_sym2__ =
          Eigen::Matrix<double,-1,-1>::Constant(nind, n_occasions,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 24;
        if (lcm_sym46__) {
          current_statement__ = 17;
          stan::model::assign(inline_prob_uncaptured_chi_sym2__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym2__",
            stan::model::index_uni(1), stan::model::index_uni(n_occasions));
          lcm_sym53__ = (n_occasions - 1);
          lcm_sym47__ = stan::math::logical_gte(lcm_sym53__, 1);
          if (lcm_sym47__) {
            int inline_prob_uncaptured_t_curr_sym3__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym4__ =
              std::numeric_limits<int>::min();
            lcm_sym59__ = (lcm_sym53__ + 1);
            current_statement__ = 20;
            stan::model::assign(inline_prob_uncaptured_chi_sym2__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym53__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym59__ - 1))))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                  "inline_prob_uncaptured_chi_sym2__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym59__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym53__)))),
              "assigning variable inline_prob_uncaptured_chi_sym2__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym53__));
            for (int inline_prob_uncaptured_t_sym5__ = 2; inline_prob_uncaptured_t_sym5__
                 <= lcm_sym53__; ++inline_prob_uncaptured_t_sym5__) {
              int inline_prob_uncaptured_t_curr_sym3__ =
                std::numeric_limits<int>::min();
              lcm_sym52__ = (n_occasions - inline_prob_uncaptured_t_sym5__);
              int inline_prob_uncaptured_t_next_sym4__ =
                std::numeric_limits<int>::min();
              lcm_sym58__ = (lcm_sym52__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym2__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym52__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni((lcm_sym58__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                    "inline_prob_uncaptured_chi_sym2__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym58__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym52__)))),
                "assigning variable inline_prob_uncaptured_chi_sym2__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym52__));
            }
          }
          for (int inline_prob_uncaptured_i_sym6__ = 2; inline_prob_uncaptured_i_sym6__
               <= nind; ++inline_prob_uncaptured_i_sym6__) {
            current_statement__ = 17;
            stan::model::assign(inline_prob_uncaptured_chi_sym2__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym2__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
              stan::model::index_uni(n_occasions));
            current_statement__ = 22;
            if (lcm_sym47__) {
              int inline_prob_uncaptured_t_curr_sym3__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym4__ =
                std::numeric_limits<int>::min();
              lcm_sym59__ = (lcm_sym53__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym2__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                     stan::model::index_uni(lcm_sym53__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                    stan::model::index_uni((lcm_sym59__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                    "inline_prob_uncaptured_chi_sym2__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                    stan::model::index_uni(lcm_sym59__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                    stan::model::index_uni(lcm_sym53__)))),
                "assigning variable inline_prob_uncaptured_chi_sym2__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                stan::model::index_uni(lcm_sym53__));
              for (int inline_prob_uncaptured_t_sym5__ = 2; inline_prob_uncaptured_t_sym5__
                   <= lcm_sym53__; ++inline_prob_uncaptured_t_sym5__) {
                int inline_prob_uncaptured_t_curr_sym3__ =
                  std::numeric_limits<int>::min();
                lcm_sym52__ = (n_occasions -
                  inline_prob_uncaptured_t_sym5__);
                int inline_prob_uncaptured_t_next_sym4__ =
                  std::numeric_limits<int>::min();
                lcm_sym58__ = (lcm_sym52__ + 1);
                current_statement__ = 20;
                stan::model::assign(inline_prob_uncaptured_chi_sym2__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                       stan::model::index_uni(lcm_sym52__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                      stan::model::index_uni((lcm_sym58__ - 1))))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                      "inline_prob_uncaptured_chi_sym2__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                      stan::model::index_uni(lcm_sym58__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                      stan::model::index_uni(lcm_sym52__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym2__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                  stan::model::index_uni(lcm_sym52__));
              }
            }
          }
        }
        current_statement__ = 25;
        stan::model::assign(inline_prob_uncaptured_return_sym1__,
          inline_prob_uncaptured_chi_sym2__,
          "assigning variable inline_prob_uncaptured_return_sym1__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym1__,
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym1__, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym1__, 1);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(inline_prob_uncaptured_return_sym1__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ mean_p;
      current_statement__ = 1;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 2;
      stan::model::assign(beta,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(max_age),
        "assigning variable beta");
      out__.write_free_lub(0, 1, beta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mean_p", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "beta", "double",
        std::vector<size_t>{static_cast<size_t>(max_age)});
      double lcm_sym45__;
      double lcm_sym44__;
      int lcm_sym43__;
      int lcm_sym42__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ mean_p;
      current_statement__ = 1;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(max_age, DUMMY_VAR__);
      {
        std::vector<double> beta_flat__;
        current_statement__ = 2;
        beta_flat__ = context__.vals_r("beta");
        pos__ = 1;
        if (stan::math::logical_gte(max_age, 1)) {
          stan::model::assign(beta,
            stan::model::rvalue(beta_flat__, "beta_flat__",
              stan::model::index_uni(1)), "assigning variable beta",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= max_age; ++sym1__) {
            stan::model::assign(beta, beta_flat__[(pos__ - 1)],
              "assigning variable beta", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_lub(0, 1, beta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mean_p", "beta"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"phi", "p", "chi"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(max_age)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(nind),
               static_cast<size_t>(n_occ_minus_1)},
             std::vector<size_t>{static_cast<size_t>(nind),
               static_cast<size_t>(n_occ_minus_1)},
             std::vector<size_t>{static_cast<size_t>(nind),
               static_cast<size_t>(n_occasions)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym172__ = 1; sym172__ <= max_age; ++sym172__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym172__));
    }
    if (emit_transformed_parameters__) {
      for (int sym172__ = 1; sym172__ <= n_occ_minus_1; ++sym172__) {
        for (int sym173__ = 1; sym173__ <= nind; ++sym173__) {
          param_names__.emplace_back(std::string() + "phi" + '.' +
            std::to_string(sym173__) + '.' + std::to_string(sym172__));
        }
      }
      for (int sym172__ = 1; sym172__ <= n_occ_minus_1; ++sym172__) {
        for (int sym173__ = 1; sym173__ <= nind; ++sym173__) {
          param_names__.emplace_back(std::string() + "p" + '.' +
            std::to_string(sym173__) + '.' + std::to_string(sym172__));
        }
      }
      for (int sym172__ = 1; sym172__ <= n_occasions; ++sym172__) {
        for (int sym173__ = 1; sym173__ <= nind; ++sym173__) {
          param_names__.emplace_back(std::string() + "chi" + '.' +
            std::to_string(sym173__) + '.' + std::to_string(sym172__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym172__ = 1; sym172__ <= max_age; ++sym172__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym172__));
    }
    if (emit_transformed_parameters__) {
      for (int sym172__ = 1; sym172__ <= n_occ_minus_1; ++sym172__) {
        for (int sym173__ = 1; sym173__ <= nind; ++sym173__) {
          param_names__.emplace_back(std::string() + "phi" + '.' +
            std::to_string(sym173__) + '.' + std::to_string(sym172__));
        }
      }
      for (int sym172__ = 1; sym172__ <= n_occ_minus_1; ++sym172__) {
        for (int sym173__ = 1; sym173__ <= nind; ++sym173__) {
          param_names__.emplace_back(std::string() + "p" + '.' +
            std::to_string(sym173__) + '.' + std::to_string(sym172__));
        }
      }
      for (int sym172__ = 1; sym172__ <= n_occasions; ++sym172__) {
        for (int sym173__ = 1; sym173__ <= nind; ++sym173__) {
          param_names__.emplace_back(std::string() + "chi" + '.' +
            std::to_string(sym173__) + '.' + std::to_string(sym172__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(max_age) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(max_age) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + max_age);
    const size_t num_transformed = emit_transformed_parameters * ((((nind *
      n_occ_minus_1) + (nind * n_occ_minus_1)) + (nind * n_occasions)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + max_age);
    const size_t num_transformed = emit_transformed_parameters * ((((nind *
      n_occ_minus_1) + (nind * n_occ_minus_1)) + (nind * n_occasions)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = copy_fail_model_namespace::copy_fail_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return copy_fail_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp dce-fail.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace dce_fail_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 66> locations_array__ =
  {" (found before start of program)",
  " (in 'dce-fail.stan', line 18, column 2 to column 22)",
  " (in 'dce-fail.stan', line 19, column 2 to column 26)",
  " (in 'dce-fail.stan', line 20, column 2 to column 26)",
  " (in 'dce-fail.stan', line 21, column 2 to column 28)",
  " (in 'dce-fail.stan', line 22, column 2 to column 29)",
  " (in 'dce-fail.stan', line 23, column 2 to column 30)",
  " (in 'dce-fail.stan', line 25, column 2 to column 11)",
  " (in 'dce-fail.stan', line 26, column 2 to column 16)",
  " (in 'dce-fail.stan', line 27, column 2 to column 15)",
  " (in 'dce-fail.stan', line 28, column 2 to column 22)",
  " (in 'dce-fail.stan', line 30, column 2 to column 16)",
  " (in 'dce-fail.stan', line 32, column 2 to column 22)",
  " (in 'dce-fail.stan', line 33, column 2 to column 22)",
  " (in 'dce-fail.stan', line 34, column 2 to column 28)",
  " (in 'dce-fail.stan', line 35, column 2 to column 32)",
  " (in 'dce-fail.stan', line 37, column 2 to column 24)",
  " (in 'dce-fail.stan', line 40, column 9 to column 10)",
  " (in 'dce-fail.stan', line 40, column 2 to column 14)",
  " (in 'dce-fail.stan', line 41, column 9 to column 16)",
  " (in 'dce-fail.stan', line 41, column 2 to column 30)",
  " (in 'dce-fail.stan', line 43, column 2 to column 23)",
  " (in 'dce-fail.stan', line 44, column 2 to column 28)",
  " (in 'dce-fail.stan', line 45, column 2 to column 27)",
  " (in 'dce-fail.stan', line 46, column 2 to column 34)",
  " (in 'dce-fail.stan', line 48, column 2 to column 31)",
  " (in 'dce-fail.stan', line 49, column 2 to column 31)",
  " (in 'dce-fail.stan', line 50, column 2 to column 37)",
  " (in 'dce-fail.stan', line 54, column 6 to column 48)",
  " (in 'dce-fail.stan', line 53, column 4 to line 54, column 48)",
  " (in 'dce-fail.stan', line 52, column 21 to line 55, column 3)",
  " (in 'dce-fail.stan', line 52, column 2 to line 55, column 3)",
  " (in 'dce-fail.stan', line 57, column 2 to column 28)",
  " (in 'dce-fail.stan', line 60, column 4 to column 64)",
  " (in 'dce-fail.stan', line 59, column 2 to line 60, column 64)",
  " (in 'dce-fail.stan', line 62, column 2 to column 43)",
  " (in 'dce-fail.stan', line 65, column 4 to line 68, column 25)",
  " (in 'dce-fail.stan', line 64, column 2 to line 68, column 25)",
  " (in 'dce-fail.stan', line 70, column 2 to column 19)",
  " (in 'dce-fail.stan', line 2, column 2 to column 17)",
  " (in 'dce-fail.stan', line 3, column 2 to column 21)",
  " (in 'dce-fail.stan', line 4, column 2 to column 21)",
  " (in 'dce-fail.stan', line 5, column 2 to column 24)",
  " (in 'dce-fail.stan', line 6, column 2 to column 23)",
  " (in 'dce-fail.stan', line 8, column 8 to column 9)",
  " (in 'dce-fail.stan', line 8, column 2 to column 40)",
  " (in 'dce-fail.stan', line 9, column 8 to column 9)",
  " (in 'dce-fail.stan', line 9, column 2 to column 39)",
  " (in 'dce-fail.stan', line 10, column 8 to column 9)",
  " (in 'dce-fail.stan', line 10, column 2 to column 41)",
  " (in 'dce-fail.stan', line 11, column 8 to column 9)",
  " (in 'dce-fail.stan', line 11, column 2 to column 41)",
  " (in 'dce-fail.stan', line 12, column 8 to column 15)",
  " (in 'dce-fail.stan', line 12, column 2 to column 52)",
  " (in 'dce-fail.stan', line 13, column 8 to column 9)",
  " (in 'dce-fail.stan', line 13, column 2 to column 45)",
  " (in 'dce-fail.stan', line 14, column 8 to column 9)",
  " (in 'dce-fail.stan', line 14, column 2 to column 35)",
  " (in 'dce-fail.stan', line 15, column 9 to column 16)",
  " (in 'dce-fail.stan', line 15, column 2 to column 25)",
  " (in 'dce-fail.stan', line 32, column 9 to column 14)",
  " (in 'dce-fail.stan', line 33, column 9 to column 14)",
  " (in 'dce-fail.stan', line 34, column 9 to column 17)",
  " (in 'dce-fail.stan', line 35, column 9 to column 14)",
  " (in 'dce-fail.stan', line 35, column 15 to column 20)",
  " (in 'dce-fail.stan', line 37, column 9 to column 16)"};
class dce_fail_model final : public model_base_crtp<dce_fail_model> {
 private:
  double lcm_sym65__;
  double lcm_sym64__;
  int lcm_sym63__;
  int lcm_sym62__;
  int N;
  int n_age;
  int n_edu;
  int n_region;
  int n_state;
  std::vector<int> female;
  std::vector<int> black;
  std::vector<int> age;
  std::vector<int> edu;
  std::vector<int> region;
  std::vector<int> state;
  std::vector<int> y;
  Eigen::Matrix<double,-1,1> v_prev_data__;
  Eigen::Map<Eigen::Matrix<double,-1,1>> v_prev{nullptr, 0};
 public:
  ~dce_fail_model() {}
  dce_fail_model(stan::io::var_context& context__, unsigned int
                 random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "dce_fail_model_namespace::dce_fail_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 39;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 39;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 39;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 40;
      context__.validate_dims("data initialization", "n_age", "int",
        std::vector<size_t>{});
      n_age = std::numeric_limits<int>::min();
      current_statement__ = 40;
      n_age = context__.vals_i("n_age")[(1 - 1)];
      current_statement__ = 40;
      stan::math::check_greater_or_equal(function__, "n_age", n_age, 0);
      current_statement__ = 41;
      context__.validate_dims("data initialization", "n_edu", "int",
        std::vector<size_t>{});
      n_edu = std::numeric_limits<int>::min();
      current_statement__ = 41;
      n_edu = context__.vals_i("n_edu")[(1 - 1)];
      current_statement__ = 41;
      stan::math::check_greater_or_equal(function__, "n_edu", n_edu, 0);
      current_statement__ = 42;
      context__.validate_dims("data initialization", "n_region", "int",
        std::vector<size_t>{});
      n_region = std::numeric_limits<int>::min();
      current_statement__ = 42;
      n_region = context__.vals_i("n_region")[(1 - 1)];
      current_statement__ = 42;
      stan::math::check_greater_or_equal(function__, "n_region", n_region, 0);
      current_statement__ = 43;
      context__.validate_dims("data initialization", "n_state", "int",
        std::vector<size_t>{});
      n_state = std::numeric_limits<int>::min();
      current_statement__ = 43;
      n_state = context__.vals_i("n_state")[(1 - 1)];
      current_statement__ = 43;
      stan::math::check_greater_or_equal(function__, "n_state", n_state, 0);
      current_statement__ = 44;
      stan::math::validate_non_negative_index("female", "N", N);
      current_statement__ = 45;
      context__.validate_dims("data initialization", "female", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      female = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 45;
      female = context__.vals_i("female");
      current_statement__ = 45;
      stan::math::check_greater_or_equal(function__, "female", female, 0);
      current_statement__ = 45;
      stan::math::check_less_or_equal(function__, "female", female, 1);
      current_statement__ = 46;
      stan::math::validate_non_negative_index("black", "N", N);
      current_statement__ = 47;
      context__.validate_dims("data initialization", "black", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      black = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 47;
      black = context__.vals_i("black");
      current_statement__ = 47;
      stan::math::check_greater_or_equal(function__, "black", black, 0);
      current_statement__ = 47;
      stan::math::check_less_or_equal(function__, "black", black, 1);
      current_statement__ = 48;
      stan::math::validate_non_negative_index("age", "N", N);
      current_statement__ = 49;
      context__.validate_dims("data initialization", "age", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      age = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 49;
      age = context__.vals_i("age");
      current_statement__ = 49;
      stan::math::check_greater_or_equal(function__, "age", age, 0);
      current_statement__ = 49;
      stan::math::check_less_or_equal(function__, "age", age, n_age);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("edu", "N", N);
      current_statement__ = 51;
      context__.validate_dims("data initialization", "edu", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      edu = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 51;
      edu = context__.vals_i("edu");
      current_statement__ = 51;
      stan::math::check_greater_or_equal(function__, "edu", edu, 0);
      current_statement__ = 51;
      stan::math::check_less_or_equal(function__, "edu", edu, n_edu);
      current_statement__ = 52;
      stan::math::validate_non_negative_index("region", "n_state", n_state);
      current_statement__ = 53;
      context__.validate_dims("data initialization", "region", "int",
        std::vector<size_t>{static_cast<size_t>(n_state)});
      region = std::vector<int>(n_state, std::numeric_limits<int>::min());
      current_statement__ = 53;
      region = context__.vals_i("region");
      current_statement__ = 53;
      stan::math::check_greater_or_equal(function__, "region", region, 0);
      current_statement__ = 53;
      stan::math::check_less_or_equal(function__, "region", region, n_state);
      current_statement__ = 54;
      stan::math::validate_non_negative_index("state", "N", N);
      current_statement__ = 55;
      context__.validate_dims("data initialization", "state", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      state = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 55;
      state = context__.vals_i("state");
      current_statement__ = 55;
      stan::math::check_greater_or_equal(function__, "state", state, 0);
      current_statement__ = 55;
      stan::math::check_less_or_equal(function__, "state", state, n_state);
      current_statement__ = 56;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 57;
      context__.validate_dims("data initialization", "y", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 57;
      y = context__.vals_i("y");
      current_statement__ = 57;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 57;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 58;
      stan::math::validate_non_negative_index("v_prev", "n_state", n_state);
      current_statement__ = 59;
      context__.validate_dims("data initialization", "v_prev", "double",
        std::vector<size_t>{static_cast<size_t>(n_state)});
      v_prev_data__ = Eigen::Matrix<double,-1,1>::Constant(n_state,
                        std::numeric_limits<double>::quiet_NaN());
      new (&v_prev)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(v_prev_data__.data(), n_state);
      {
        std::vector<double> v_prev_flat__;
        current_statement__ = 59;
        v_prev_flat__ = context__.vals_r("v_prev");
        pos__ = 1;
        if (stan::math::logical_gte(n_state, 1)) {
          stan::model::assign(v_prev,
            stan::model::rvalue(v_prev_flat__, "v_prev_flat__",
              stan::model::index_uni(1)), "assigning variable v_prev",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_state; ++sym1__) {
            stan::model::assign(v_prev, v_prev_flat__[(pos__ - 1)],
              "assigning variable v_prev", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 60;
      stan::math::validate_non_negative_index("b_age", "n_age", n_age);
      current_statement__ = 61;
      stan::math::validate_non_negative_index("b_edu", "n_edu", n_edu);
      current_statement__ = 62;
      stan::math::validate_non_negative_index("b_region", "n_region",
        n_region);
      current_statement__ = 63;
      stan::math::validate_non_negative_index("b_age_edu", "n_age", n_age);
      current_statement__ = 64;
      stan::math::validate_non_negative_index("b_age_edu", "n_edu", n_edu);
      current_statement__ = 65;
      stan::math::validate_non_negative_index("b_hat", "n_state", n_state);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + n_age +
      n_edu + n_region + (n_age * n_edu) + n_state;
  }
  inline std::string model_name() const final {
    return "dce_fail_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "dce_fail_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym61__;
      double lcm_sym60__;
      double lcm_sym59__;
      double lcm_sym58__;
      double lcm_sym57__;
      double lcm_sym56__;
      double lcm_sym55__;
      double lcm_sym54__;
      double lcm_sym53__;
      double lcm_sym52__;
      double lcm_sym51__;
      double lcm_sym50__;
      double lcm_sym49__;
      double lcm_sym48__;
      double lcm_sym47__;
      double lcm_sym46__;
      double lcm_sym45__;
      double lcm_sym44__;
      int lcm_sym43__;
      int lcm_sym42__;
      int lcm_sym41__;
      int lcm_sym40__;
      local_scalar_t__ sigma;
      current_statement__ = 1;
      sigma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      local_scalar_t__ sigma_age;
      current_statement__ = 2;
      sigma_age = in__.template read_constrain_lb<local_scalar_t__,
                    jacobian__>(0, lp__);
      local_scalar_t__ sigma_edu;
      current_statement__ = 3;
      sigma_edu = in__.template read_constrain_lb<local_scalar_t__,
                    jacobian__>(0, lp__);
      local_scalar_t__ sigma_state;
      current_statement__ = 4;
      sigma_state = in__.template read_constrain_lb<local_scalar_t__,
                      jacobian__>(0, lp__);
      local_scalar_t__ sigma_region;
      current_statement__ = 5;
      sigma_region = in__.template read_constrain_lb<local_scalar_t__,
                       jacobian__>(0, lp__);
      local_scalar_t__ sigma_age_edu;
      current_statement__ = 6;
      sigma_age_edu = in__.template read_constrain_lb<local_scalar_t__,
                        jacobian__>(0, lp__);
      local_scalar_t__ b_0;
      current_statement__ = 7;
      b_0 = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_female;
      current_statement__ = 8;
      b_female = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_black;
      current_statement__ = 9;
      b_black = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_female_black;
      current_statement__ = 10;
      b_female_black = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_v_prev;
      current_statement__ = 11;
      b_v_prev = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> b_age;
      current_statement__ = 12;
      b_age = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_age);
      Eigen::Matrix<local_scalar_t__,-1,1> b_edu;
      current_statement__ = 13;
      b_edu = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_edu);
      Eigen::Matrix<local_scalar_t__,-1,1> b_region;
      current_statement__ = 14;
      b_region = in__.template read<
                   Eigen::Matrix<local_scalar_t__,-1,1>>(n_region);
      Eigen::Matrix<local_scalar_t__,-1,-1> b_age_edu;
      current_statement__ = 15;
      b_age_edu = in__.template read<
                    Eigen::Matrix<local_scalar_t__,-1,-1>>(n_age, n_edu);
      Eigen::Matrix<local_scalar_t__,-1,1> b_hat;
      current_statement__ = 16;
      b_hat = in__.template read<
                Eigen::Matrix<local_scalar_t__,-1,1>>(n_state);
      {
        current_statement__ = 17;
        stan::math::validate_non_negative_index("p", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> p =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 19;
        stan::math::validate_non_negative_index("b_state_hat", "n_state",
          n_state);
        Eigen::Matrix<local_scalar_t__,-1,1> b_state_hat =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_state,
            DUMMY_VAR__);
        current_statement__ = 21;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_0, 0, 100));
        current_statement__ = 22;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_female, 0, 100));
        current_statement__ = 23;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_black, 0, 100));
        current_statement__ = 24;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_female_black, 0,
                         100));
        current_statement__ = 25;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_age, 0, sigma_age));
        current_statement__ = 26;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_edu, 0, sigma_edu));
        current_statement__ = 27;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_region, 0,
                         sigma_region));
        current_statement__ = 31;
        if (stan::math::logical_gte(n_age, 1)) {
          lcm_sym42__ = stan::math::logical_gte(n_edu, 1);
          if (lcm_sym42__) {
            current_statement__ = 28;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(
                             stan::model::rvalue(b_age_edu, "b_age_edu",
                               stan::model::index_uni(1),
                               stan::model::index_uni(1)), 0, sigma_age_edu));
            for (int i = 2; i <= n_edu; ++i) {
              current_statement__ = 28;
              lp_accum__.add(stan::math::normal_lpdf<propto__>(
                               stan::model::rvalue(b_age_edu, "b_age_edu",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(i)), 0, sigma_age_edu));
            }
          }
          for (int j = 2; j <= n_age; ++j) {
            current_statement__ = 29;
            if (lcm_sym42__) {
              current_statement__ = 28;
              lp_accum__.add(stan::math::normal_lpdf<propto__>(
                               stan::model::rvalue(b_age_edu, "b_age_edu",
                                 stan::model::index_uni(j),
                                 stan::model::index_uni(1)), 0, sigma_age_edu));
              for (int i = 2; i <= n_edu; ++i) {
                current_statement__ = 28;
                lp_accum__.add(stan::math::normal_lpdf<propto__>(
                                 stan::model::rvalue(b_age_edu, "b_age_edu",
                                   stan::model::index_uni(j),
                                   stan::model::index_uni(i)), 0,
                                 sigma_age_edu));
              }
            }
          }
        }
        current_statement__ = 32;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_v_prev, 0, 100));
        current_statement__ = 34;
        if (stan::math::logical_gte(n_state, 1)) {
          current_statement__ = 33;
          stan::model::assign(b_state_hat,
            stan::math::fma(b_v_prev,
              stan::model::rvalue(v_prev, "v_prev", stan::model::index_uni(1)),
              stan::model::rvalue(b_region, "b_region",
                stan::model::index_uni(
                  stan::model::rvalue(region, "region",
                    stan::model::index_uni(1))))),
            "assigning variable b_state_hat", stan::model::index_uni(1));
          for (int j = 2; j <= n_state; ++j) {
            current_statement__ = 33;
            stan::model::assign(b_state_hat,
              stan::math::fma(b_v_prev,
                stan::model::rvalue(v_prev, "v_prev",
                  stan::model::index_uni(j)),
                stan::model::rvalue(b_region, "b_region",
                  stan::model::index_uni(
                    stan::model::rvalue(region, "region",
                      stan::model::index_uni(j))))),
              "assigning variable b_state_hat", stan::model::index_uni(j));
          }
        }
        current_statement__ = 35;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_hat, b_state_hat,
                         sigma_state));
        current_statement__ = 37;
        if (stan::math::logical_gte(N, 1)) {
          current_statement__ = 36;
          stan::model::assign(p,
            stan::math::fmax(0,
              stan::math::fmin(1,
                stan::math::inv_logit(
                  ((((stan::math::fma((b_female_black *
                        stan::model::rvalue(female, "female",
                          stan::model::index_uni(1))),
                        stan::model::rvalue(black, "black",
                          stan::model::index_uni(1)),
                        stan::math::fma(b_black,
                          stan::model::rvalue(black, "black",
                            stan::model::index_uni(1)),
                          stan::math::fma(b_female,
                            stan::model::rvalue(female, "female",
                              stan::model::index_uni(1)), b_0))) +
                  stan::model::rvalue(b_age, "b_age",
                    stan::model::index_uni(
                      stan::model::rvalue(age, "age",
                        stan::model::index_uni(1))))) +
                  stan::model::rvalue(b_edu, "b_edu",
                    stan::model::index_uni(
                      stan::model::rvalue(edu, "edu",
                        stan::model::index_uni(1))))) +
                  stan::model::rvalue(b_age_edu, "b_age_edu",
                    stan::model::index_uni(
                      stan::model::rvalue(age, "age",
                        stan::model::index_uni(1))),
                    stan::model::index_uni(
                      stan::model::rvalue(edu, "edu",
                        stan::model::index_uni(1))))) +
                  stan::model::rvalue(b_hat, "b_hat",
                    stan::model::index_uni(
                      stan::model::rvalue(state, "state",
                        stan::model::index_uni(1)))))))),
            "assigning variable p", stan::model::index_uni(1));
          for (int i = 2; i <= N; ++i) {
            current_statement__ = 36;
            stan::model::assign(p,
              stan::math::fmax(0,
                stan::math::fmin(1,
                  stan::math::inv_logit(
                    ((((stan::math::fma((b_female_black *
                          stan::model::rvalue(female, "female",
                            stan::model::index_uni(i))),
                          stan::model::rvalue(black, "black",
                            stan::model::index_uni(i)),
                          stan::math::fma(b_black,
                            stan::model::rvalue(black, "black",
                              stan::model::index_uni(i)),
                            stan::math::fma(b_female,
                              stan::model::rvalue(female, "female",
                                stan::model::index_uni(i)), b_0))) +
                    stan::model::rvalue(b_age, "b_age",
                      stan::model::index_uni(
                        stan::model::rvalue(age, "age",
                          stan::model::index_uni(i))))) +
                    stan::model::rvalue(b_edu, "b_edu",
                      stan::model::index_uni(
                        stan::model::rvalue(edu, "edu",
                          stan::model::index_uni(i))))) +
                    stan::model::rvalue(b_age_edu, "b_age_edu",
                      stan::model::index_uni(
                        stan::model::rvalue(age, "age",
                          stan::model::index_uni(i))),
                      stan::model::index_uni(
                        stan::model::rvalue(edu, "edu",
                          stan::model::index_uni(i))))) +
                    stan::model::rvalue(b_hat, "b_hat",
                      stan::model::index_uni(
                        stan::model::rvalue(state, "state",
                          stan::model::index_uni(i)))))))),
              "assigning variable p", stan::model::index_uni(i));
          }
        }
        current_statement__ = 38;
        lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(y, p));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "dce_fail_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym39__;
      double lcm_sym38__;
      double lcm_sym37__;
      double lcm_sym36__;
      double lcm_sym35__;
      double lcm_sym34__;
      double lcm_sym33__;
      double lcm_sym32__;
      double lcm_sym31__;
      double lcm_sym30__;
      double lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      int lcm_sym21__;
      int lcm_sym20__;
      int lcm_sym19__;
      int lcm_sym18__;
      local_scalar_t__ sigma;
      current_statement__ = 1;
      sigma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      local_scalar_t__ sigma_age;
      current_statement__ = 2;
      sigma_age = in__.template read_constrain_lb<local_scalar_t__,
                    jacobian__>(0, lp__);
      local_scalar_t__ sigma_edu;
      current_statement__ = 3;
      sigma_edu = in__.template read_constrain_lb<local_scalar_t__,
                    jacobian__>(0, lp__);
      local_scalar_t__ sigma_state;
      current_statement__ = 4;
      sigma_state = in__.template read_constrain_lb<local_scalar_t__,
                      jacobian__>(0, lp__);
      local_scalar_t__ sigma_region;
      current_statement__ = 5;
      sigma_region = in__.template read_constrain_lb<local_scalar_t__,
                       jacobian__>(0, lp__);
      local_scalar_t__ sigma_age_edu;
      current_statement__ = 6;
      sigma_age_edu = in__.template read_constrain_lb<local_scalar_t__,
                        jacobian__>(0, lp__);
      local_scalar_t__ b_0;
      current_statement__ = 7;
      b_0 = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_female;
      current_statement__ = 8;
      b_female = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_black;
      current_statement__ = 9;
      b_black = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_female_black;
      current_statement__ = 10;
      b_female_black = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_v_prev;
      current_statement__ = 11;
      b_v_prev = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> b_age;
      current_statement__ = 12;
      b_age = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_age);
      Eigen::Matrix<local_scalar_t__,-1,1> b_edu;
      current_statement__ = 13;
      b_edu = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_edu);
      Eigen::Matrix<local_scalar_t__,-1,1> b_region;
      current_statement__ = 14;
      b_region = in__.template read<
                   Eigen::Matrix<local_scalar_t__,-1,1>>(n_region);
      Eigen::Matrix<local_scalar_t__,-1,-1> b_age_edu;
      current_statement__ = 15;
      b_age_edu = in__.template read<
                    Eigen::Matrix<local_scalar_t__,-1,-1>>(n_age, n_edu);
      Eigen::Matrix<local_scalar_t__,-1,1> b_hat;
      current_statement__ = 16;
      b_hat = in__.template read<
                Eigen::Matrix<local_scalar_t__,-1,1>>(n_state);
      {
        current_statement__ = 17;
        stan::math::validate_non_negative_index("p", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> p =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 19;
        stan::math::validate_non_negative_index("b_state_hat", "n_state",
          n_state);
        Eigen::Matrix<local_scalar_t__,-1,1> b_state_hat =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_state,
            DUMMY_VAR__);
        current_statement__ = 21;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_0, 0, 100));
        current_statement__ = 22;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_female, 0, 100));
        current_statement__ = 23;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_black, 0, 100));
        current_statement__ = 24;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_female_black, 0,
                         100));
        current_statement__ = 25;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_age, 0, sigma_age));
        current_statement__ = 26;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_edu, 0, sigma_edu));
        current_statement__ = 27;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_region, 0,
                         sigma_region));
        current_statement__ = 31;
        if (stan::math::logical_gte(n_age, 1)) {
          lcm_sym20__ = stan::math::logical_gte(n_edu, 1);
          if (lcm_sym20__) {
            current_statement__ = 28;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(
                             stan::model::rvalue(b_age_edu, "b_age_edu",
                               stan::model::index_uni(1),
                               stan::model::index_uni(1)), 0, sigma_age_edu));
            for (int i = 2; i <= n_edu; ++i) {
              current_statement__ = 28;
              lp_accum__.add(stan::math::normal_lpdf<propto__>(
                               stan::model::rvalue(b_age_edu, "b_age_edu",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(i)), 0, sigma_age_edu));
            }
          }
          for (int j = 2; j <= n_age; ++j) {
            current_statement__ = 29;
            if (lcm_sym20__) {
              current_statement__ = 28;
              lp_accum__.add(stan::math::normal_lpdf<propto__>(
                               stan::model::rvalue(b_age_edu, "b_age_edu",
                                 stan::model::index_uni(j),
                                 stan::model::index_uni(1)), 0, sigma_age_edu));
              for (int i = 2; i <= n_edu; ++i) {
                current_statement__ = 28;
                lp_accum__.add(stan::math::normal_lpdf<propto__>(
                                 stan::model::rvalue(b_age_edu, "b_age_edu",
                                   stan::model::index_uni(j),
                                   stan::model::index_uni(i)), 0,
                                 sigma_age_edu));
              }
            }
          }
        }
        current_statement__ = 32;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_v_prev, 0, 100));
        current_statement__ = 34;
        if (stan::math::logical_gte(n_state, 1)) {
          current_statement__ = 33;
          stan::model::assign(b_state_hat,
            stan::math::fma(b_v_prev,
              stan::model::rvalue(v_prev, "v_prev", stan::model::index_uni(1)),
              stan::model::rvalue(b_region, "b_region",
                stan::model::index_uni(
                  stan::model::rvalue(region, "region",
                    stan::model::index_uni(1))))),
            "assigning variable b_state_hat", stan::model::index_uni(1));
          for (int j = 2; j <= n_state; ++j) {
            current_statement__ = 33;
            stan::model::assign(b_state_hat,
              stan::math::fma(b_v_prev,
                stan::model::rvalue(v_prev, "v_prev",
                  stan::model::index_uni(j)),
                stan::model::rvalue(b_region, "b_region",
                  stan::model::index_uni(
                    stan::model::rvalue(region, "region",
                      stan::model::index_uni(j))))),
              "assigning variable b_state_hat", stan::model::index_uni(j));
          }
        }
        current_statement__ = 35;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_hat, b_state_hat,
                         sigma_state));
        current_statement__ = 37;
        if (stan::math::logical_gte(N, 1)) {
          current_statement__ = 36;
          stan::model::assign(p,
            stan::math::fmax(0,
              stan::math::fmin(1,
                stan::math::inv_logit(
                  ((((stan::math::fma((b_female_black *
                        stan::model::rvalue(female, "female",
                          stan::model::index_uni(1))),
                        stan::model::rvalue(black, "black",
                          stan::model::index_uni(1)),
                        stan::math::fma(b_black,
                          stan::model::rvalue(black, "black",
                            stan::model::index_uni(1)),
                          stan::math::fma(b_female,
                            stan::model::rvalue(female, "female",
                              stan::model::index_uni(1)), b_0))) +
                  stan::model::rvalue(b_age, "b_age",
                    stan::model::index_uni(
                      stan::model::rvalue(age, "age",
                        stan::model::index_uni(1))))) +
                  stan::model::rvalue(b_edu, "b_edu",
                    stan::model::index_uni(
                      stan::model::rvalue(edu, "edu",
                        stan::model::index_uni(1))))) +
                  stan::model::rvalue(b_age_edu, "b_age_edu",
                    stan::model::index_uni(
                      stan::model::rvalue(age, "age",
                        stan::model::index_uni(1))),
                    stan::model::index_uni(
                      stan::model::rvalue(edu, "edu",
                        stan::model::index_uni(1))))) +
                  stan::model::rvalue(b_hat, "b_hat",
                    stan::model::index_uni(
                      stan::model::rvalue(state, "state",
                        stan::model::index_uni(1)))))))),
            "assigning variable p", stan::model::index_uni(1));
          for (int i = 2; i <= N; ++i) {
            current_statement__ = 36;
            stan::model::assign(p,
              stan::math::fmax(0,
                stan::math::fmin(1,
                  stan::math::inv_logit(
                    ((((stan::math::fma((b_female_black *
                          stan::model::rvalue(female, "female",
                            stan::model::index_uni(i))),
                          stan::model::rvalue(black, "black",
                            stan::model::index_uni(i)),
                          stan::math::fma(b_black,
                            stan::model::rvalue(black, "black",
                              stan::model::index_uni(i)),
                            stan::math::fma(b_female,
                              stan::model::rvalue(female, "female",
                                stan::model::index_uni(i)), b_0))) +
                    stan::model::rvalue(b_age, "b_age",
                      stan::model::index_uni(
                        stan::model::rvalue(age, "age",
                          stan::model::index_uni(i))))) +
                    stan::model::rvalue(b_edu, "b_edu",
                      stan::model::index_uni(
                        stan::model::rvalue(edu, "edu",
                          stan::model::index_uni(i))))) +
                    stan::model::rvalue(b_age_edu, "b_age_edu",
                      stan::model::index_uni(
                        stan::model::rvalue(age, "age",
                          stan::model::index_uni(i))),
                      stan::model::index_uni(
                        stan::model::rvalue(edu, "edu",
                          stan::model::index_uni(i))))) +
                    stan::model::rvalue(b_hat, "b_hat",
                      stan::model::index_uni(
                        stan::model::rvalue(state, "state",
                          stan::model::index_uni(i)))))))),
              "assigning variable p", stan::model::index_uni(i));
          }
        }
        current_statement__ = 38;
        lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(y, p));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "dce_fail_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym17__;
      int lcm_sym16__;
      double sigma;
      current_statement__ = 1;
      sigma = in__.template read_constrain_lb<local_scalar_t__,
                jacobian__>(0, lp__);
      double sigma_age;
      current_statement__ = 2;
      sigma_age = in__.template read_constrain_lb<local_scalar_t__,
                    jacobian__>(0, lp__);
      double sigma_edu;
      current_statement__ = 3;
      sigma_edu = in__.template read_constrain_lb<local_scalar_t__,
                    jacobian__>(0, lp__);
      double sigma_state;
      current_statement__ = 4;
      sigma_state = in__.template read_constrain_lb<local_scalar_t__,
                      jacobian__>(0, lp__);
      double sigma_region;
      current_statement__ = 5;
      sigma_region = in__.template read_constrain_lb<local_scalar_t__,
                       jacobian__>(0, lp__);
      double sigma_age_edu;
      current_statement__ = 6;
      sigma_age_edu = in__.template read_constrain_lb<local_scalar_t__,
                        jacobian__>(0, lp__);
      double b_0;
      current_statement__ = 7;
      b_0 = in__.template read<local_scalar_t__>();
      double b_female;
      current_statement__ = 8;
      b_female = in__.template read<local_scalar_t__>();
      double b_black;
      current_statement__ = 9;
      b_black = in__.template read<local_scalar_t__>();
      double b_female_black;
      current_statement__ = 10;
      b_female_black = in__.template read<local_scalar_t__>();
      double b_v_prev;
      current_statement__ = 11;
      b_v_prev = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,1> b_age;
      current_statement__ = 12;
      b_age = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_age);
      Eigen::Matrix<double,-1,1> b_edu;
      current_statement__ = 13;
      b_edu = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_edu);
      Eigen::Matrix<double,-1,1> b_region;
      current_statement__ = 14;
      b_region = in__.template read<
                   Eigen::Matrix<local_scalar_t__,-1,1>>(n_region);
      Eigen::Matrix<double,-1,-1> b_age_edu;
      current_statement__ = 15;
      b_age_edu = in__.template read<
                    Eigen::Matrix<local_scalar_t__,-1,-1>>(n_age, n_edu);
      Eigen::Matrix<double,-1,1> b_hat;
      current_statement__ = 16;
      b_hat = in__.template read<
                Eigen::Matrix<local_scalar_t__,-1,1>>(n_state);
      out__.write(sigma);
      out__.write(sigma_age);
      out__.write(sigma_edu);
      out__.write(sigma_state);
      out__.write(sigma_region);
      out__.write(sigma_age_edu);
      out__.write(b_0);
      out__.write(b_female);
      out__.write(b_black);
      out__.write(b_female_black);
      out__.write(b_v_prev);
      out__.write(b_age);
      out__.write(b_edu);
      out__.write(b_region);
      out__.write(b_age_edu);
      out__.write(b_hat);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ sigma;
      current_statement__ = 1;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma);
      local_scalar_t__ sigma_age;
      current_statement__ = 2;
      sigma_age = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_age);
      local_scalar_t__ sigma_edu;
      current_statement__ = 3;
      sigma_edu = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_edu);
      local_scalar_t__ sigma_state;
      current_statement__ = 4;
      sigma_state = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_state);
      local_scalar_t__ sigma_region;
      current_statement__ = 5;
      sigma_region = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_region);
      local_scalar_t__ sigma_age_edu;
      current_statement__ = 6;
      sigma_age_edu = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_age_edu);
      local_scalar_t__ b_0;
      current_statement__ = 7;
      b_0 = in__.read<local_scalar_t__>();
      out__.write(b_0);
      local_scalar_t__ b_female;
      current_statement__ = 8;
      b_female = in__.read<local_scalar_t__>();
      out__.write(b_female);
      local_scalar_t__ b_black;
      current_statement__ = 9;
      b_black = in__.read<local_scalar_t__>();
      out__.write(b_black);
      local_scalar_t__ b_female_black;
      current_statement__ = 10;
      b_female_black = in__.read<local_scalar_t__>();
      out__.write(b_female_black);
      local_scalar_t__ b_v_prev;
      current_statement__ = 11;
      b_v_prev = in__.read<local_scalar_t__>();
      out__.write(b_v_prev);
      Eigen::Matrix<local_scalar_t__,-1,1> b_age;
      current_statement__ = 12;
      stan::model::assign(b_age,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_age),
        "assigning variable b_age");
      out__.write(b_age);
      Eigen::Matrix<local_scalar_t__,-1,1> b_edu;
      current_statement__ = 13;
      stan::model::assign(b_edu,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_edu),
        "assigning variable b_edu");
      out__.write(b_edu);
      Eigen::Matrix<local_scalar_t__,-1,1> b_region;
      current_statement__ = 14;
      stan::model::assign(b_region,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_region),
        "assigning variable b_region");
      out__.write(b_region);
      Eigen::Matrix<local_scalar_t__,-1,-1> b_age_edu;
      current_statement__ = 15;
      stan::model::assign(b_age_edu,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(n_age, n_edu),
        "assigning variable b_age_edu");
      out__.write(b_age_edu);
      Eigen::Matrix<local_scalar_t__,-1,1> b_hat;
      current_statement__ = 16;
      stan::model::assign(b_hat,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_state),
        "assigning variable b_hat");
      out__.write(b_hat);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "sigma", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "sigma_age",
        "double", std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "sigma_edu",
        "double", std::vector<size_t>{});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "sigma_state",
        "double", std::vector<size_t>{});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "sigma_region",
        "double", std::vector<size_t>{});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "sigma_age_edu",
        "double", std::vector<size_t>{});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "b_0", "double",
        std::vector<size_t>{});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization", "b_female",
        "double", std::vector<size_t>{});
      current_statement__ = 9;
      context__.validate_dims("parameter initialization", "b_black",
        "double", std::vector<size_t>{});
      current_statement__ = 10;
      context__.validate_dims("parameter initialization", "b_female_black",
        "double", std::vector<size_t>{});
      current_statement__ = 11;
      context__.validate_dims("parameter initialization", "b_v_prev",
        "double", std::vector<size_t>{});
      current_statement__ = 12;
      context__.validate_dims("parameter initialization", "b_age", "double",
        std::vector<size_t>{static_cast<size_t>(n_age)});
      current_statement__ = 13;
      context__.validate_dims("parameter initialization", "b_edu", "double",
        std::vector<size_t>{static_cast<size_t>(n_edu)});
      current_statement__ = 14;
      context__.validate_dims("parameter initialization", "b_region",
        "double", std::vector<size_t>{static_cast<size_t>(n_region)});
      current_statement__ = 15;
      context__.validate_dims("parameter initialization", "b_age_edu",
        "double",
        std::vector<size_t>{static_cast<size_t>(n_age),
          static_cast<size_t>(n_edu)});
      current_statement__ = 16;
      context__.validate_dims("parameter initialization", "b_hat", "double",
        std::vector<size_t>{static_cast<size_t>(n_state)});
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      double lcm_sym12__;
      double lcm_sym11__;
      double lcm_sym10__;
      double lcm_sym9__;
      double lcm_sym8__;
      double lcm_sym7__;
      double lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ sigma;
      current_statement__ = 1;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      out__.write_free_lb(0, sigma);
      local_scalar_t__ sigma_age;
      current_statement__ = 2;
      sigma_age = context__.vals_r("sigma_age")[(1 - 1)];
      out__.write_free_lb(0, sigma_age);
      local_scalar_t__ sigma_edu;
      current_statement__ = 3;
      sigma_edu = context__.vals_r("sigma_edu")[(1 - 1)];
      out__.write_free_lb(0, sigma_edu);
      local_scalar_t__ sigma_state;
      current_statement__ = 4;
      sigma_state = context__.vals_r("sigma_state")[(1 - 1)];
      out__.write_free_lb(0, sigma_state);
      local_scalar_t__ sigma_region;
      current_statement__ = 5;
      sigma_region = context__.vals_r("sigma_region")[(1 - 1)];
      out__.write_free_lb(0, sigma_region);
      local_scalar_t__ sigma_age_edu;
      current_statement__ = 6;
      sigma_age_edu = context__.vals_r("sigma_age_edu")[(1 - 1)];
      out__.write_free_lb(0, sigma_age_edu);
      local_scalar_t__ b_0;
      current_statement__ = 7;
      b_0 = context__.vals_r("b_0")[(1 - 1)];
      out__.write(b_0);
      local_scalar_t__ b_female;
      current_statement__ = 8;
      b_female = context__.vals_r("b_female")[(1 - 1)];
      out__.write(b_female);
      local_scalar_t__ b_black;
      current_statement__ = 9;
      b_black = context__.vals_r("b_black")[(1 - 1)];
      out__.write(b_black);
      local_scalar_t__ b_female_black;
      current_statement__ = 10;
      b_female_black = context__.vals_r("b_female_black")[(1 - 1)];
      out__.write(b_female_black);
      local_scalar_t__ b_v_prev;
      current_statement__ = 11;
      b_v_prev = context__.vals_r("b_v_prev")[(1 - 1)];
      out__.write(b_v_prev);
      Eigen::Matrix<local_scalar_t__,-1,1> b_age =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_age, DUMMY_VAR__);
      {
        std::vector<double> b_age_flat__;
        current_statement__ = 12;
        b_age_flat__ = context__.vals_r("b_age");
        pos__ = 1;
        lcm_sym1__ = stan::math::logical_gte(n_age, 1);
        if (lcm_sym1__) {
          stan::model::assign(b_age,
            stan::model::rvalue(b_age_flat__, "b_age_flat__",
              stan::model::index_uni(1)), "assigning variable b_age",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_age; ++sym1__) {
            stan::model::assign(b_age, b_age_flat__[(pos__ - 1)],
              "assigning variable b_age", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(b_age);
      Eigen::Matrix<local_scalar_t__,-1,1> b_edu =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_edu, DUMMY_VAR__);
      {
        std::vector<double> b_edu_flat__;
        current_statement__ = 13;
        b_edu_flat__ = context__.vals_r("b_edu");
        pos__ = 1;
        lcm_sym2__ = stan::math::logical_gte(n_edu, 1);
        if (lcm_sym2__) {
          stan::model::assign(b_edu,
            stan::model::rvalue(b_edu_flat__, "b_edu_flat__",
              stan::model::index_uni(1)), "assigning variable b_edu",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
            stan::model::assign(b_edu, b_edu_flat__[(pos__ - 1)],
              "assigning variable b_edu", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(b_edu);
      Eigen::Matrix<local_scalar_t__,-1,1> b_region =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_region, DUMMY_VAR__);
      {
        std::vector<double> b_region_flat__;
        current_statement__ = 14;
        b_region_flat__ = context__.vals_r("b_region");
        pos__ = 1;
        if (stan::math::logical_gte(n_region, 1)) {
          stan::model::assign(b_region,
            stan::model::rvalue(b_region_flat__, "b_region_flat__",
              stan::model::index_uni(1)), "assigning variable b_region",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_region; ++sym1__) {
            stan::model::assign(b_region, b_region_flat__[(pos__ - 1)],
              "assigning variable b_region", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(b_region);
      Eigen::Matrix<local_scalar_t__,-1,-1> b_age_edu =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n_age, n_edu,
          DUMMY_VAR__);
      {
        std::vector<double> b_age_edu_flat__;
        current_statement__ = 15;
        b_age_edu_flat__ = context__.vals_r("b_age_edu");
        pos__ = 1;
        if (lcm_sym2__) {
          if (lcm_sym1__) {
            stan::model::assign(b_age_edu,
              stan::model::rvalue(b_age_edu_flat__, "b_age_edu_flat__",
                stan::model::index_uni(1)), "assigning variable b_age_edu",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= n_age; ++sym2__) {
              stan::model::assign(b_age_edu, b_age_edu_flat__[(pos__ - 1)],
                "assigning variable b_age_edu",
                stan::model::index_uni(sym2__), stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
            if (lcm_sym1__) {
              stan::model::assign(b_age_edu, b_age_edu_flat__[(pos__ - 1)],
                "assigning variable b_age_edu", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= n_age; ++sym2__) {
                stan::model::assign(b_age_edu, b_age_edu_flat__[(pos__ - 1)],
                  "assigning variable b_age_edu",
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      out__.write(b_age_edu);
      Eigen::Matrix<local_scalar_t__,-1,1> b_hat =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_state, DUMMY_VAR__);
      {
        std::vector<double> b_hat_flat__;
        current_statement__ = 16;
        b_hat_flat__ = context__.vals_r("b_hat");
        pos__ = 1;
        if (stan::math::logical_gte(n_state, 1)) {
          stan::model::assign(b_hat,
            stan::model::rvalue(b_hat_flat__, "b_hat_flat__",
              stan::model::index_uni(1)), "assigning variable b_hat",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_state; ++sym1__) {
            stan::model::assign(b_hat, b_hat_flat__[(pos__ - 1)],
              "assigning variable b_hat", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(b_hat);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"sigma", "sigma_age", "sigma_edu",
                "sigma_state", "sigma_region", "sigma_age_edu", "b_0",
                "b_female", "b_black", "b_female_black", "b_v_prev", "b_age",
                "b_edu", "b_region", "b_age_edu", "b_hat"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(n_age)},
                std::vector<size_t>{static_cast<size_t>(n_edu)},
                std::vector<size_t>{static_cast<size_t>(n_region)},
                std::vector<size_t>{static_cast<size_t>(n_age),
                  static_cast<size_t>(n_edu)},
                std::vector<size_t>{static_cast<size_t>(n_state)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "sigma");
    param_names__.emplace_back(std::string() + "sigma_age");
    param_names__.emplace_back(std::string() + "sigma_edu");
    param_names__.emplace_back(std::string() + "sigma_state");
    param_names__.emplace_back(std::string() + "sigma_region");
    param_names__.emplace_back(std::string() + "sigma_age_edu");
    param_names__.emplace_back(std::string() + "b_0");
    param_names__.emplace_back(std::string() + "b_female");
    param_names__.emplace_back(std::string() + "b_black");
    param_names__.emplace_back(std::string() + "b_female_black");
    param_names__.emplace_back(std::string() + "b_v_prev");
    for (int sym66__ = 1; sym66__ <= n_age; ++sym66__) {
      param_names__.emplace_back(std::string() + "b_age" + '.' +
        std::to_string(sym66__));
    }
    for (int sym66__ = 1; sym66__ <= n_edu; ++sym66__) {
      param_names__.emplace_back(std::string() + "b_edu" + '.' +
        std::to_string(sym66__));
    }
    for (int sym66__ = 1; sym66__ <= n_region; ++sym66__) {
      param_names__.emplace_back(std::string() + "b_region" + '.' +
        std::to_string(sym66__));
    }
    for (int sym66__ = 1; sym66__ <= n_edu; ++sym66__) {
      for (int sym67__ = 1; sym67__ <= n_age; ++sym67__) {
        param_names__.emplace_back(std::string() + "b_age_edu" + '.' +
          std::to_string(sym67__) + '.' + std::to_string(sym66__));
      }
    }
    for (int sym66__ = 1; sym66__ <= n_state; ++sym66__) {
      param_names__.emplace_back(std::string() + "b_hat" + '.' +
        std::to_string(sym66__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "sigma");
    param_names__.emplace_back(std::string() + "sigma_age");
    param_names__.emplace_back(std::string() + "sigma_edu");
    param_names__.emplace_back(std::string() + "sigma_state");
    param_names__.emplace_back(std::string() + "sigma_region");
    param_names__.emplace_back(std::string() + "sigma_age_edu");
    param_names__.emplace_back(std::string() + "b_0");
    param_names__.emplace_back(std::string() + "b_female");
    param_names__.emplace_back(std::string() + "b_black");
    param_names__.emplace_back(std::string() + "b_female_black");
    param_names__.emplace_back(std::string() + "b_v_prev");
    for (int sym66__ = 1; sym66__ <= n_age; ++sym66__) {
      param_names__.emplace_back(std::string() + "b_age" + '.' +
        std::to_string(sym66__));
    }
    for (int sym66__ = 1; sym66__ <= n_edu; ++sym66__) {
      param_names__.emplace_back(std::string() + "b_edu" + '.' +
        std::to_string(sym66__));
    }
    for (int sym66__ = 1; sym66__ <= n_region; ++sym66__) {
      param_names__.emplace_back(std::string() + "b_region" + '.' +
        std::to_string(sym66__));
    }
    for (int sym66__ = 1; sym66__ <= n_edu; ++sym66__) {
      for (int sym67__ = 1; sym67__ <= n_age; ++sym67__) {
        param_names__.emplace_back(std::string() + "b_age_edu" + '.' +
          std::to_string(sym67__) + '.' + std::to_string(sym66__));
      }
    }
    for (int sym66__ = 1; sym66__ <= n_state; ++sym66__) {
      param_names__.emplace_back(std::string() + "b_hat" + '.' +
        std::to_string(sym66__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_state\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_region\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_v_prev\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_age\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age) + "},\"block\":\"parameters\"},{\"name\":\"b_edu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"b_region\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_region) + "},\"block\":\"parameters\"},{\"name\":\"b_age_edu\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_age) + ",\"cols\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"b_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_state) + "},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_state\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_region\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_v_prev\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_age\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age) + "},\"block\":\"parameters\"},{\"name\":\"b_edu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"b_region\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_region) + "},\"block\":\"parameters\"},{\"name\":\"b_age_edu\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_age) + ",\"cols\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"b_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_state) + "},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((((((((((1 + 1) + 1) + 1) + 1) + 1) +
      1) + 1) + 1) + 1) + 1) + n_age) + n_edu) + n_region) + (n_age * n_edu))
      + n_state);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((((((((((1 + 1) + 1) + 1) + 1) + 1) +
      1) + 1) + 1) + 1) + 1) + n_age) + n_edu) + n_region) + (n_age * n_edu))
      + n_state);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = dce_fail_model_namespace::dce_fail_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return dce_fail_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-experiment.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_experiment_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 9> locations_array__ =
  {" (found before start of program)",
  " (in 'expr-prop-experiment.stan', line 2, column 2 to column 8)",
  " (in 'expr-prop-experiment.stan', line 5, column 2 to column 9)",
  " (in 'expr-prop-experiment.stan', line 6, column 2 to column 9)",
  " (in 'expr-prop-experiment.stan', line 7, column 2 to column 9)",
  " (in 'expr-prop-experiment.stan', line 8, column 2 to column 28)",
  " (in 'expr-prop-experiment.stan', line 10, column 2 to column 23)",
  " (in 'expr-prop-experiment.stan', line 11, column 2 to column 23)",
  " (in 'expr-prop-experiment.stan', line 12, column 2 to column 23)"};
class expr_prop_experiment_model final : public model_base_crtp<expr_prop_experiment_model> {
 private:
  double lcm_sym4__;
  int j;
  double z;
  double x;
  double y;
  double i;
 public:
  ~expr_prop_experiment_model() {}
  expr_prop_experiment_model(stan::io::var_context& context__, unsigned int
                             random_seed__ = 0, std::ostream*
                             pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "expr_prop_experiment_model_namespace::expr_prop_experiment_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("data initialization", "j", "int",
        std::vector<size_t>{});
      j = std::numeric_limits<int>::min();
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      current_statement__ = 2;
      z = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      x = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      y = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      i = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      i = stan::math::normal_rng(5, 1, base_rng__);
      lcm_sym4__ = (i * j);
      z = lcm_sym4__;
      current_statement__ = 6;
      x = stan::math::normal_rng(lcm_sym4__, 1, base_rng__);
      current_statement__ = 7;
      i = stan::math::normal_rng(5, 1, base_rng__);
      current_statement__ = 8;
      y = stan::math::normal_rng(z, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "expr_prop_experiment_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_experiment_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_experiment_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "expr_prop_experiment_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = expr_prop_experiment_model_namespace::expr_prop_experiment_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_experiment_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-experiment2.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_experiment2_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 8> locations_array__ =
  {" (found before start of program)",
  " (in 'expr-prop-experiment2.stan', line 2, column 2 to column 8)",
  " (in 'expr-prop-experiment2.stan', line 5, column 2 to column 13)",
  " (in 'expr-prop-experiment2.stan', line 6, column 2 to column 9)",
  " (in 'expr-prop-experiment2.stan', line 8, column 4 to column 32)",
  " (in 'expr-prop-experiment2.stan', line 10, column 4 to column 25)",
  " (in 'expr-prop-experiment2.stan', line 7, column 2 to line 11, column 3)",
  " (in 'expr-prop-experiment2.stan', line 12, column 2 to column 23)"};
class expr_prop_experiment2_model final : public model_base_crtp<expr_prop_experiment2_model> {
 private:
  double lcm_sym5__;
  double lcm_sym4__;
  int j;
  double z;
  double y;
 public:
  ~expr_prop_experiment2_model() {}
  expr_prop_experiment2_model(stan::io::var_context& context__, unsigned int
                              random_seed__ = 0, std::ostream*
                              pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "expr_prop_experiment2_model_namespace::expr_prop_experiment2_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("data initialization", "j", "int",
        std::vector<size_t>{});
      j = std::numeric_limits<int>::min();
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      current_statement__ = 2;
      z = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      z = 1;
      current_statement__ = 3;
      y = std::numeric_limits<double>::quiet_NaN();
      {
        double x;
        current_statement__ = 4;
        x = stan::math::normal_rng(123, 1, base_rng__);
        lcm_sym4__ = (x * 2);
        z = lcm_sym4__;
        current_statement__ = 5;
        y = stan::math::normal_rng(lcm_sym4__, 1, base_rng__);
      }
      current_statement__ = 7;
      y = stan::math::normal_rng(z, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "expr_prop_experiment2_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_experiment2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_experiment2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "expr_prop_experiment2_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = expr_prop_experiment2_model_namespace::expr_prop_experiment2_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_experiment2_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 12> locations_array__ =
  {" (found before start of program)",
  " (in 'expr-prop-fail.stan', line 6, column 2 to column 16)",
  " (in 'expr-prop-fail.stan', line 7, column 2 to column 31)",
  " (in 'expr-prop-fail.stan', line 8, column 2 to column 31)",
  " (in 'expr-prop-fail.stan', line 11, column 2 to column 23)",
  " (in 'expr-prop-fail.stan', line 12, column 2 to column 20)",
  " (in 'expr-prop-fail.stan', line 13, column 2 to column 21)",
  " (in 'expr-prop-fail.stan', line 15, column 4 to line 16, column 59)",
  " (in 'expr-prop-fail.stan', line 14, column 2 to line 16, column 59)",
  " (in 'expr-prop-fail.stan', line 2, column 2 to column 17)",
  " (in 'expr-prop-fail.stan', line 3, column 9 to column 10)",
  " (in 'expr-prop-fail.stan', line 3, column 2 to column 14)"};
class expr_prop_fail_model final : public model_base_crtp<expr_prop_fail_model> {
 private:
  double lcm_sym21__;
  double lcm_sym20__;
  int lcm_sym19__;
  int lcm_sym18__;
  int N;
  Eigen::Matrix<double,-1,1> y_data__;
  Eigen::Map<Eigen::Matrix<double,-1,1>> y{nullptr, 0};
 public:
  ~expr_prop_fail_model() {}
  expr_prop_fail_model(stan::io::var_context& context__, unsigned int
                       random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "expr_prop_fail_model_namespace::expr_prop_fail_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 9;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 9;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 9;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 10;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 11;
      context__.validate_dims("data initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      y_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                   std::numeric_limits<double>::quiet_NaN());
      new (&y) Eigen::Map<Eigen::Matrix<double,-1,1>>(y_data__.data(), N);
      {
        std::vector<double> y_flat__;
        current_statement__ = 11;
        y_flat__ = context__.vals_r("y");
        pos__ = 1;
        if (stan::math::logical_gte(N, 1)) {
          stan::model::assign(y,
            stan::model::rvalue(y_flat__, "y_flat__",
              stan::model::index_uni(1)), "assigning variable y",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 2 + 2 + 1;
  }
  inline std::string model_name() const final {
    return "expr_prop_fail_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      int lcm_sym12__;
      Eigen::Matrix<local_scalar_t__,-1,1> mu;
      current_statement__ = 1;
      mu = in__.template read_constrain_ordered<
             Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lp__, 2);
      std::vector<local_scalar_t__> sigma =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<std::vector<local_scalar_t__>,
                jacobian__>(0, lp__, 2);
      local_scalar_t__ theta;
      current_statement__ = 3;
      theta = in__.template read_constrain_lub<local_scalar_t__,
                jacobian__>(0, 1, lp__);
      {
        current_statement__ = 4;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(sigma, 0, 2));
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu, 0, 2));
        current_statement__ = 6;
        lp_accum__.add(stan::math::beta_lpdf<propto__>(theta, 5, 5));
        current_statement__ = 8;
        if (stan::math::logical_gte(N, 1)) {
          current_statement__ = 7;
          lp_accum__.add(stan::math::log_mix(theta,
                           stan::math::normal_lpdf<false>(
                             stan::model::rvalue(y, "y",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(mu, "mu",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(sigma, "sigma",
                               stan::model::index_uni(1))),
                           stan::math::normal_lpdf<false>(
                             stan::model::rvalue(y, "y",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(mu, "mu",
                               stan::model::index_uni(2)),
                             stan::model::rvalue(sigma, "sigma",
                               stan::model::index_uni(2)))));
          for (int n = 2; n <= N; ++n) {
            current_statement__ = 7;
            lp_accum__.add(stan::math::log_mix(theta,
                             stan::math::normal_lpdf<false>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(n)),
                               stan::model::rvalue(mu, "mu",
                                 stan::model::index_uni(1)),
                               stan::model::rvalue(sigma, "sigma",
                                 stan::model::index_uni(1))),
                             stan::math::normal_lpdf<false>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(n)),
                               stan::model::rvalue(mu, "mu",
                                 stan::model::index_uni(2)),
                               stan::model::rvalue(sigma, "sigma",
                                 stan::model::index_uni(2)))));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym11__;
      double lcm_sym10__;
      double lcm_sym9__;
      double lcm_sym8__;
      double lcm_sym7__;
      int lcm_sym6__;
      Eigen::Matrix<local_scalar_t__,-1,1> mu;
      current_statement__ = 1;
      mu = in__.template read_constrain_ordered<
             Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lp__, 2);
      std::vector<local_scalar_t__> sigma =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<std::vector<local_scalar_t__>,
                jacobian__>(0, lp__, 2);
      local_scalar_t__ theta;
      current_statement__ = 3;
      theta = in__.template read_constrain_lub<local_scalar_t__,
                jacobian__>(0, 1, lp__);
      {
        current_statement__ = 4;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(sigma, 0, 2));
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu, 0, 2));
        current_statement__ = 6;
        lp_accum__.add(stan::math::beta_lpdf<propto__>(theta, 5, 5));
        current_statement__ = 8;
        if (stan::math::logical_gte(N, 1)) {
          current_statement__ = 7;
          lp_accum__.add(stan::math::log_mix(theta,
                           stan::math::normal_lpdf<false>(
                             stan::model::rvalue(y, "y",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(mu, "mu",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(sigma, "sigma",
                               stan::model::index_uni(1))),
                           stan::math::normal_lpdf<false>(
                             stan::model::rvalue(y, "y",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(mu, "mu",
                               stan::model::index_uni(2)),
                             stan::model::rvalue(sigma, "sigma",
                               stan::model::index_uni(2)))));
          for (int n = 2; n <= N; ++n) {
            current_statement__ = 7;
            lp_accum__.add(stan::math::log_mix(theta,
                             stan::math::normal_lpdf<false>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(n)),
                               stan::model::rvalue(mu, "mu",
                                 stan::model::index_uni(1)),
                               stan::model::rvalue(sigma, "sigma",
                                 stan::model::index_uni(1))),
                             stan::math::normal_lpdf<false>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(n)),
                               stan::model::rvalue(mu, "mu",
                                 stan::model::index_uni(2)),
                               stan::model::rvalue(sigma, "sigma",
                                 stan::model::index_uni(2)))));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "expr_prop_fail_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym5__;
      int lcm_sym4__;
      Eigen::Matrix<double,-1,1> mu;
      current_statement__ = 1;
      mu = in__.template read_constrain_ordered<
             Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lp__, 2);
      std::vector<double> sigma =
        std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<std::vector<local_scalar_t__>,
                jacobian__>(0, lp__, 2);
      double theta;
      current_statement__ = 3;
      theta = in__.template read_constrain_lub<local_scalar_t__,
                jacobian__>(0, 1, lp__);
      out__.write(mu);
      out__.write(sigma);
      out__.write(theta);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> mu;
      current_statement__ = 1;
      stan::model::assign(mu,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(2),
        "assigning variable mu");
      out__.write_free_ordered(mu);
      std::vector<local_scalar_t__> sigma;
      current_statement__ = 2;
      stan::model::assign(sigma, in__.read<std::vector<local_scalar_t__>>(2),
        "assigning variable sigma");
      out__.write_free_lb(0, sigma);
      local_scalar_t__ theta;
      current_statement__ = 3;
      theta = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mu", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "sigma", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "theta", "double",
        std::vector<size_t>{});
      double lcm_sym3__;
      double lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> mu =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      {
        std::vector<double> mu_flat__;
        current_statement__ = 1;
        mu_flat__ = context__.vals_r("mu");
        pos__ = 1;
        {
          stan::model::assign(mu,
            stan::model::rvalue(mu_flat__, "mu_flat__",
              stan::model::index_uni(1)), "assigning variable mu",
            stan::model::index_uni(1));
          pos__ = 2;
          {
            stan::model::assign(mu, mu_flat__[(pos__ - 1)],
              "assigning variable mu", stan::model::index_uni(2));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_ordered(mu);
      std::vector<local_scalar_t__> sigma =
        std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 2;
      sigma = context__.vals_r("sigma");
      out__.write_free_lb(0, sigma);
      local_scalar_t__ theta;
      current_statement__ = 3;
      theta = context__.vals_r("theta")[(1 - 1)];
      out__.write_free_lub(0, 1, theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mu", "sigma", "theta"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(2)},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym22__ = 1; sym22__ <= 2; ++sym22__) {
      param_names__.emplace_back(std::string() + "mu" + '.' +
        std::to_string(sym22__));
    }
    for (int sym22__ = 1; sym22__ <= 2; ++sym22__) {
      param_names__.emplace_back(std::string() + "sigma" + '.' +
        std::to_string(sym22__));
    }
    param_names__.emplace_back(std::string() + "theta");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym22__ = 1; sym22__ <= 2; ++sym22__) {
      param_names__.emplace_back(std::string() + "mu" + '.' +
        std::to_string(sym22__));
    }
    for (int sym22__ = 1; sym22__ <= 2; ++sym22__) {
      param_names__.emplace_back(std::string() + "sigma" + '.' +
        std::to_string(sym22__));
    }
    param_names__.emplace_back(std::string() + "theta");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((2 + 2) + 1);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((2 + 2) + 1);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = expr_prop_fail_model_namespace::expr_prop_fail_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail2.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail2_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 12> locations_array__ =
  {" (found before start of program)",
  " (in 'expr-prop-fail2.stan', line 7, column 2 to column 10)",
  " (in 'expr-prop-fail2.stan', line 8, column 2 to column 22)",
  " (in 'expr-prop-fail2.stan', line 9, column 2 to column 20)",
  " (in 'expr-prop-fail2.stan', line 12, column 2 to column 26)",
  " (in 'expr-prop-fail2.stan', line 13, column 2 to column 27)",
  " (in 'expr-prop-fail2.stan', line 2, column 2 to column 17)",
  " (in 'expr-prop-fail2.stan', line 3, column 8 to column 9)",
  " (in 'expr-prop-fail2.stan', line 3, column 2 to column 18)",
  " (in 'expr-prop-fail2.stan', line 4, column 8 to column 9)",
  " (in 'expr-prop-fail2.stan', line 4, column 2 to column 31)",
  " (in 'expr-prop-fail2.stan', line 8, column 8 to column 9)"};
class expr_prop_fail2_model final : public model_base_crtp<expr_prop_fail2_model> {
 private:
  int J;
  std::vector<double> y;
  std::vector<double> sigma;
 public:
  ~expr_prop_fail2_model() {}
  expr_prop_fail2_model(stan::io::var_context& context__, unsigned int
                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "expr_prop_fail2_model_namespace::expr_prop_fail2_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 6;
      context__.validate_dims("data initialization", "J", "int",
        std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      current_statement__ = 6;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 6;
      stan::math::check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 7;
      stan::math::validate_non_negative_index("y", "J", J);
      current_statement__ = 8;
      context__.validate_dims("data initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(J)});
      y = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 8;
      y = context__.vals_r("y");
      current_statement__ = 9;
      stan::math::validate_non_negative_index("sigma", "J", J);
      current_statement__ = 10;
      context__.validate_dims("data initialization", "sigma", "double",
        std::vector<size_t>{static_cast<size_t>(J)});
      sigma = std::vector<double>(J,
                std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 10;
      sigma = context__.vals_r("sigma");
      current_statement__ = 10;
      stan::math::check_greater_or_equal(function__, "sigma", sigma, 0);
      current_statement__ = 11;
      stan::math::validate_non_negative_index("theta", "J", J);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + J + 1;
  }
  inline std::string model_name() const final {
    return "expr_prop_fail2_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym6__;
      double lcm_sym5__;
      local_scalar_t__ mu;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      std::vector<local_scalar_t__> theta =
        std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      current_statement__ = 2;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      local_scalar_t__ tau;
      current_statement__ = 3;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      {
        current_statement__ = 4;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(theta, mu, tau));
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, theta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym4__;
      double lcm_sym3__;
      local_scalar_t__ mu;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      std::vector<local_scalar_t__> theta =
        std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      current_statement__ = 2;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      local_scalar_t__ tau;
      current_statement__ = 3;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      {
        current_statement__ = 4;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(theta, mu, tau));
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, theta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "expr_prop_fail2_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      double mu;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      std::vector<double> theta =
        std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      double tau;
      current_statement__ = 3;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      out__.write(mu);
      out__.write(theta);
      out__.write(tau);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ mu;
      current_statement__ = 1;
      mu = in__.read<local_scalar_t__>();
      out__.write(mu);
      std::vector<local_scalar_t__> theta;
      current_statement__ = 2;
      stan::model::assign(theta, in__.read<std::vector<local_scalar_t__>>(J),
        "assigning variable theta");
      out__.write(theta);
      local_scalar_t__ tau;
      current_statement__ = 3;
      tau = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mu", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "theta", "double",
        std::vector<size_t>{static_cast<size_t>(J)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "tau", "double",
        std::vector<size_t>{});
      local_scalar_t__ mu;
      current_statement__ = 1;
      mu = context__.vals_r("mu")[(1 - 1)];
      out__.write(mu);
      std::vector<local_scalar_t__> theta =
        std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      current_statement__ = 2;
      theta = context__.vals_r("theta");
      out__.write(theta);
      local_scalar_t__ tau;
      current_statement__ = 3;
      tau = context__.vals_r("tau")[(1 - 1)];
      out__.write_free_lb(0, tau);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mu", "theta", "tau"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(J)},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mu");
    for (int sym7__ = 1; sym7__ <= J; ++sym7__) {
      param_names__.emplace_back(std::string() + "theta" + '.' +
        std::to_string(sym7__));
    }
    param_names__.emplace_back(std::string() + "tau");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mu");
    for (int sym7__ = 1; sym7__ <= J; ++sym7__) {
      param_names__.emplace_back(std::string() + "theta" + '.' +
        std::to_string(sym7__));
    }
    param_names__.emplace_back(std::string() + "tau");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((1 + J) + 1);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((1 + J) + 1);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = expr_prop_fail2_model_namespace::expr_prop_fail2_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail2_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail3.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail3_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 52> locations_array__ =
  {" (found before start of program)",
  " (in 'expr-prop-fail3.stan', line 19, column 2 to column 18)",
  " (in 'expr-prop-fail3.stan', line 20, column 2 to column 18)",
  " (in 'expr-prop-fail3.stan', line 21, column 2 to column 22)",
  " (in 'expr-prop-fail3.stan', line 22, column 2 to column 20)",
  " (in 'expr-prop-fail3.stan', line 23, column 2 to column 26)",
  " (in 'expr-prop-fail3.stan', line 24, column 2 to column 17)",
  " (in 'expr-prop-fail3.stan', line 25, column 2 to column 35)",
  " (in 'expr-prop-fail3.stan', line 26, column 2 to column 35)",
  " (in 'expr-prop-fail3.stan', line 27, column 2 to column 35)",
  " (in 'expr-prop-fail3.stan', line 28, column 2 to column 35)",
  " (in 'expr-prop-fail3.stan', line 29, column 2 to column 35)",
  " (in 'expr-prop-fail3.stan', line 32, column 2 to column 18)",
  " (in 'expr-prop-fail3.stan', line 35, column 4 to line 38, column 35)",
  " (in 'expr-prop-fail3.stan', line 34, column 2 to line 38, column 35)",
  " (in 'expr-prop-fail3.stan', line 41, column 2 to column 25)",
  " (in 'expr-prop-fail3.stan', line 42, column 2 to column 25)",
  " (in 'expr-prop-fail3.stan', line 43, column 2 to column 25)",
  " (in 'expr-prop-fail3.stan', line 44, column 2 to column 25)",
  " (in 'expr-prop-fail3.stan', line 45, column 2 to column 25)",
  " (in 'expr-prop-fail3.stan', line 46, column 2 to column 24)",
  " (in 'expr-prop-fail3.stan', line 47, column 2 to column 29)",
  " (in 'expr-prop-fail3.stan', line 2, column 2 to column 17)",
  " (in 'expr-prop-fail3.stan', line 3, column 2 to column 21)",
  " (in 'expr-prop-fail3.stan', line 4, column 2 to column 25)",
  " (in 'expr-prop-fail3.stan', line 5, column 2 to column 21)",
  " (in 'expr-prop-fail3.stan', line 6, column 2 to column 29)",
  " (in 'expr-prop-fail3.stan', line 7, column 2 to column 23)",
  " (in 'expr-prop-fail3.stan', line 8, column 8 to column 9)",
  " (in 'expr-prop-fail3.stan', line 8, column 2 to column 41)",
  " (in 'expr-prop-fail3.stan', line 9, column 8 to column 9)",
  " (in 'expr-prop-fail3.stan', line 9, column 2 to column 49)",
  " (in 'expr-prop-fail3.stan', line 10, column 27 to column 28)",
  " (in 'expr-prop-fail3.stan', line 10, column 2 to column 36)",
  " (in 'expr-prop-fail3.stan', line 11, column 8 to column 9)",
  " (in 'expr-prop-fail3.stan', line 11, column 2 to column 41)",
  " (in 'expr-prop-fail3.stan', line 12, column 27 to column 28)",
  " (in 'expr-prop-fail3.stan', line 12, column 2 to column 37)",
  " (in 'expr-prop-fail3.stan', line 13, column 8 to column 9)",
  " (in 'expr-prop-fail3.stan', line 13, column 2 to column 57)",
  " (in 'expr-prop-fail3.stan', line 14, column 8 to column 9)",
  " (in 'expr-prop-fail3.stan', line 14, column 2 to column 45)",
  " (in 'expr-prop-fail3.stan', line 15, column 9 to column 10)",
  " (in 'expr-prop-fail3.stan', line 15, column 2 to column 24)",
  " (in 'expr-prop-fail3.stan', line 16, column 8 to column 9)",
  " (in 'expr-prop-fail3.stan', line 16, column 2 to column 35)",
  " (in 'expr-prop-fail3.stan', line 19, column 9 to column 14)",
  " (in 'expr-prop-fail3.stan', line 20, column 9 to column 14)",
  " (in 'expr-prop-fail3.stan', line 21, column 9 to column 18)",
  " (in 'expr-prop-fail3.stan', line 22, column 9 to column 16)",
  " (in 'expr-prop-fail3.stan', line 23, column 9 to column 22)",
  " (in 'expr-prop-fail3.stan', line 32, column 9 to column 10)"};
class expr_prop_fail3_model final : public model_base_crtp<expr_prop_fail3_model> {
 private:
  double lcm_sym51__;
  double lcm_sym50__;
  double lcm_sym49__;
  double lcm_sym48__;
  double lcm_sym47__;
  double lcm_sym46__;
  int lcm_sym45__;
  int lcm_sym44__;
  int N;
  int n_age;
  int n_age_edu;
  int n_edu;
  int n_region_full;
  int n_state;
  std::vector<int> age;
  std::vector<int> age_edu;
  Eigen::Matrix<double,-1,1> black_data__;
  std::vector<int> edu;
  Eigen::Matrix<double,-1,1> female_data__;
  std::vector<int> region_full;
  std::vector<int> state;
  Eigen::Matrix<double,-1,1> v_prev_full_data__;
  std::vector<int> y;
  Eigen::Map<Eigen::Matrix<double,-1,1>> black{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> female{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> v_prev_full{nullptr, 0};
 public:
  ~expr_prop_fail3_model() {}
  expr_prop_fail3_model(stan::io::var_context& context__, unsigned int
                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "expr_prop_fail3_model_namespace::expr_prop_fail3_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 22;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 22;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 22;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 23;
      context__.validate_dims("data initialization", "n_age", "int",
        std::vector<size_t>{});
      n_age = std::numeric_limits<int>::min();
      current_statement__ = 23;
      n_age = context__.vals_i("n_age")[(1 - 1)];
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "n_age", n_age, 0);
      current_statement__ = 24;
      context__.validate_dims("data initialization", "n_age_edu", "int",
        std::vector<size_t>{});
      n_age_edu = std::numeric_limits<int>::min();
      current_statement__ = 24;
      n_age_edu = context__.vals_i("n_age_edu")[(1 - 1)];
      current_statement__ = 24;
      stan::math::check_greater_or_equal(function__, "n_age_edu", n_age_edu,
        0);
      current_statement__ = 25;
      context__.validate_dims("data initialization", "n_edu", "int",
        std::vector<size_t>{});
      n_edu = std::numeric_limits<int>::min();
      current_statement__ = 25;
      n_edu = context__.vals_i("n_edu")[(1 - 1)];
      current_statement__ = 25;
      stan::math::check_greater_or_equal(function__, "n_edu", n_edu, 0);
      current_statement__ = 26;
      context__.validate_dims("data initialization", "n_region_full", "int",
        std::vector<size_t>{});
      n_region_full = std::numeric_limits<int>::min();
      current_statement__ = 26;
      n_region_full = context__.vals_i("n_region_full")[(1 - 1)];
      current_statement__ = 26;
      stan::math::check_greater_or_equal(function__, "n_region_full",
        n_region_full, 0);
      current_statement__ = 27;
      context__.validate_dims("data initialization", "n_state", "int",
        std::vector<size_t>{});
      n_state = std::numeric_limits<int>::min();
      current_statement__ = 27;
      n_state = context__.vals_i("n_state")[(1 - 1)];
      current_statement__ = 27;
      stan::math::check_greater_or_equal(function__, "n_state", n_state, 0);
      current_statement__ = 28;
      stan::math::validate_non_negative_index("age", "N", N);
      current_statement__ = 29;
      context__.validate_dims("data initialization", "age", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      age = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 29;
      age = context__.vals_i("age");
      current_statement__ = 29;
      stan::math::check_greater_or_equal(function__, "age", age, 0);
      current_statement__ = 29;
      stan::math::check_less_or_equal(function__, "age", age, n_age);
      current_statement__ = 30;
      stan::math::validate_non_negative_index("age_edu", "N", N);
      current_statement__ = 31;
      context__.validate_dims("data initialization", "age_edu", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      age_edu = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 31;
      age_edu = context__.vals_i("age_edu");
      current_statement__ = 31;
      stan::math::check_greater_or_equal(function__, "age_edu", age_edu, 0);
      current_statement__ = 31;
      stan::math::check_less_or_equal(function__, "age_edu", age_edu,
        n_age_edu);
      current_statement__ = 32;
      stan::math::validate_non_negative_index("black", "N", N);
      current_statement__ = 33;
      context__.validate_dims("data initialization", "black", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      black_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                       std::numeric_limits<double>::quiet_NaN());
      new (&black)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(black_data__.data(), N);
      {
        std::vector<double> black_flat__;
        current_statement__ = 33;
        black_flat__ = context__.vals_r("black");
        pos__ = 1;
        lcm_sym44__ = stan::math::logical_gte(N, 1);
        if (lcm_sym44__) {
          stan::model::assign(black,
            stan::model::rvalue(black_flat__, "black_flat__",
              stan::model::index_uni(1)), "assigning variable black",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(black, black_flat__[(pos__ - 1)],
              "assigning variable black", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 33;
      stan::math::check_greater_or_equal(function__, "black", black, 0);
      current_statement__ = 33;
      stan::math::check_less_or_equal(function__, "black", black, 1);
      current_statement__ = 34;
      stan::math::validate_non_negative_index("edu", "N", N);
      current_statement__ = 35;
      context__.validate_dims("data initialization", "edu", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      edu = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 35;
      edu = context__.vals_i("edu");
      current_statement__ = 35;
      stan::math::check_greater_or_equal(function__, "edu", edu, 0);
      current_statement__ = 35;
      stan::math::check_less_or_equal(function__, "edu", edu, n_edu);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("female", "N", N);
      current_statement__ = 37;
      context__.validate_dims("data initialization", "female", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      female_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                        std::numeric_limits<double>::quiet_NaN());
      new (&female)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(female_data__.data(), N);
      {
        std::vector<double> female_flat__;
        current_statement__ = 37;
        female_flat__ = context__.vals_r("female");
        pos__ = 1;
        if (lcm_sym44__) {
          stan::model::assign(female,
            stan::model::rvalue(female_flat__, "female_flat__",
              stan::model::index_uni(1)), "assigning variable female",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(female, female_flat__[(pos__ - 1)],
              "assigning variable female", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 37;
      stan::math::check_greater_or_equal(function__, "female", female, 0);
      current_statement__ = 37;
      stan::math::check_less_or_equal(function__, "female", female, 1);
      current_statement__ = 38;
      stan::math::validate_non_negative_index("region_full", "N", N);
      current_statement__ = 39;
      context__.validate_dims("data initialization", "region_full", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      region_full = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 39;
      region_full = context__.vals_i("region_full");
      current_statement__ = 39;
      stan::math::check_greater_or_equal(function__, "region_full",
        region_full, 0);
      current_statement__ = 39;
      stan::math::check_less_or_equal(function__, "region_full", region_full,
        n_region_full);
      current_statement__ = 40;
      stan::math::validate_non_negative_index("state", "N", N);
      current_statement__ = 41;
      context__.validate_dims("data initialization", "state", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      state = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 41;
      state = context__.vals_i("state");
      current_statement__ = 41;
      stan::math::check_greater_or_equal(function__, "state", state, 0);
      current_statement__ = 41;
      stan::math::check_less_or_equal(function__, "state", state, n_state);
      current_statement__ = 42;
      stan::math::validate_non_negative_index("v_prev_full", "N", N);
      current_statement__ = 43;
      context__.validate_dims("data initialization", "v_prev_full", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      v_prev_full_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                             std::numeric_limits<double>::quiet_NaN());
      new (&v_prev_full)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(v_prev_full_data__.data(), N);
      {
        std::vector<double> v_prev_full_flat__;
        current_statement__ = 43;
        v_prev_full_flat__ = context__.vals_r("v_prev_full");
        pos__ = 1;
        if (lcm_sym44__) {
          stan::model::assign(v_prev_full,
            stan::model::rvalue(v_prev_full_flat__, "v_prev_full_flat__",
              stan::model::index_uni(1)), "assigning variable v_prev_full",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(v_prev_full, v_prev_full_flat__[(pos__ - 1)],
              "assigning variable v_prev_full",
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 44;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 45;
      context__.validate_dims("data initialization", "y", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 45;
      y = context__.vals_i("y");
      current_statement__ = 45;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 45;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 46;
      stan::math::validate_non_negative_index("a", "n_age", n_age);
      current_statement__ = 47;
      stan::math::validate_non_negative_index("b", "n_edu", n_edu);
      current_statement__ = 48;
      stan::math::validate_non_negative_index("c", "n_age_edu", n_age_edu);
      current_statement__ = 49;
      stan::math::validate_non_negative_index("d", "n_state", n_state);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("e", "n_region_full",
        n_region_full);
      current_statement__ = 51;
      stan::math::validate_non_negative_index("y_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = n_age + n_edu + n_age_edu + n_state + n_region_full + 5
      + 1 + 1 + 1 + 1 + 1;
  }
  inline std::string model_name() const final {
    return "expr_prop_fail3_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail3_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym43__;
      double lcm_sym42__;
      double lcm_sym41__;
      double lcm_sym40__;
      double lcm_sym39__;
      double lcm_sym38__;
      double lcm_sym37__;
      double lcm_sym36__;
      double lcm_sym35__;
      int lcm_sym34__;
      Eigen::Matrix<local_scalar_t__,-1,1> a;
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_age);
      Eigen::Matrix<local_scalar_t__,-1,1> b;
      current_statement__ = 2;
      b = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_edu);
      Eigen::Matrix<local_scalar_t__,-1,1> c;
      current_statement__ = 3;
      c = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_age_edu);
      Eigen::Matrix<local_scalar_t__,-1,1> d;
      current_statement__ = 4;
      d = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_state);
      Eigen::Matrix<local_scalar_t__,-1,1> e;
      current_statement__ = 5;
      e = in__.template read<
            Eigen::Matrix<local_scalar_t__,-1,1>>(n_region_full);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 6;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(5);
      local_scalar_t__ sigma_a;
      current_statement__ = 7;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_b;
      current_statement__ = 8;
      sigma_b = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_c;
      current_statement__ = 9;
      sigma_c = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_d;
      current_statement__ = 10;
      sigma_d = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_e;
      current_statement__ = 11;
      sigma_e = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> y_hat =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 14;
      if (stan::math::logical_gte(N, 1)) {
        current_statement__ = 13;
        stan::model::assign(y_hat,
          (((((stan::math::fma(
                 stan::model::rvalue(beta, "beta", stan::model::index_uni(4)),
                 stan::model::rvalue(v_prev_full, "v_prev_full",
                   stan::model::index_uni(1)),
                 stan::math::fma(
                   (stan::model::rvalue(beta, "beta",
                      stan::model::index_uni(5)) *
                   stan::model::rvalue(female, "female",
                     stan::model::index_uni(1))),
                   stan::model::rvalue(black, "black",
                     stan::model::index_uni(1)),
                   stan::math::fma(
                     stan::model::rvalue(beta, "beta",
                       stan::model::index_uni(3)),
                     stan::model::rvalue(female, "female",
                       stan::model::index_uni(1)),
                     stan::math::fma(
                       stan::model::rvalue(beta, "beta",
                         stan::model::index_uni(2)),
                       stan::model::rvalue(black, "black",
                         stan::model::index_uni(1)),
                       stan::model::rvalue(beta, "beta",
                         stan::model::index_uni(1)))))) +
          stan::model::rvalue(a, "a",
            stan::model::index_uni(
              stan::model::rvalue(age, "age", stan::model::index_uni(1))))) +
          stan::model::rvalue(b, "b",
            stan::model::index_uni(
              stan::model::rvalue(edu, "edu", stan::model::index_uni(1))))) +
          stan::model::rvalue(c, "c",
            stan::model::index_uni(
              stan::model::rvalue(age_edu, "age_edu",
                stan::model::index_uni(1))))) +
          stan::model::rvalue(d, "d",
            stan::model::index_uni(
              stan::model::rvalue(state, "state", stan::model::index_uni(1)))))
          +
          stan::model::rvalue(e, "e",
            stan::model::index_uni(
              stan::model::rvalue(region_full, "region_full",
                stan::model::index_uni(1))))), "assigning variable y_hat",
          stan::model::index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 13;
          stan::model::assign(y_hat,
            (((((stan::math::fma(
                   stan::model::rvalue(beta, "beta",
                     stan::model::index_uni(4)),
                   stan::model::rvalue(v_prev_full, "v_prev_full",
                     stan::model::index_uni(i)),
                   stan::math::fma(
                     (stan::model::rvalue(beta, "beta",
                        stan::model::index_uni(5)) *
                     stan::model::rvalue(female, "female",
                       stan::model::index_uni(i))),
                     stan::model::rvalue(black, "black",
                       stan::model::index_uni(i)),
                     stan::math::fma(
                       stan::model::rvalue(beta, "beta",
                         stan::model::index_uni(3)),
                       stan::model::rvalue(female, "female",
                         stan::model::index_uni(i)),
                       stan::math::fma(
                         stan::model::rvalue(beta, "beta",
                           stan::model::index_uni(2)),
                         stan::model::rvalue(black, "black",
                           stan::model::index_uni(i)),
                         stan::model::rvalue(beta, "beta",
                           stan::model::index_uni(1)))))) +
            stan::model::rvalue(a, "a",
              stan::model::index_uni(
                stan::model::rvalue(age, "age", stan::model::index_uni(i)))))
            +
            stan::model::rvalue(b, "b",
              stan::model::index_uni(
                stan::model::rvalue(edu, "edu", stan::model::index_uni(i)))))
            +
            stan::model::rvalue(c, "c",
              stan::model::index_uni(
                stan::model::rvalue(age_edu, "age_edu",
                  stan::model::index_uni(i))))) +
            stan::model::rvalue(d, "d",
              stan::model::index_uni(
                stan::model::rvalue(state, "state", stan::model::index_uni(i)))))
            +
            stan::model::rvalue(e, "e",
              stan::model::index_uni(
                stan::model::rvalue(region_full, "region_full",
                  stan::model::index_uni(i))))), "assigning variable y_hat",
            stan::model::index_uni(i));
        }
      }
      {
        current_statement__ = 15;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(a, 0, sigma_a));
        current_statement__ = 16;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b, 0, sigma_b));
        current_statement__ = 17;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(c, 0, sigma_c));
        current_statement__ = 18;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(d, 0, sigma_d));
        current_statement__ = 19;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(e, 0, sigma_e));
        current_statement__ = 20;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(beta, 0, 100));
        current_statement__ = 21;
        lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(y, y_hat));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail3_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym33__;
      double lcm_sym32__;
      double lcm_sym31__;
      double lcm_sym30__;
      double lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      int lcm_sym24__;
      Eigen::Matrix<local_scalar_t__,-1,1> a;
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_age);
      Eigen::Matrix<local_scalar_t__,-1,1> b;
      current_statement__ = 2;
      b = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_edu);
      Eigen::Matrix<local_scalar_t__,-1,1> c;
      current_statement__ = 3;
      c = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_age_edu);
      Eigen::Matrix<local_scalar_t__,-1,1> d;
      current_statement__ = 4;
      d = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_state);
      Eigen::Matrix<local_scalar_t__,-1,1> e;
      current_statement__ = 5;
      e = in__.template read<
            Eigen::Matrix<local_scalar_t__,-1,1>>(n_region_full);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 6;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(5);
      local_scalar_t__ sigma_a;
      current_statement__ = 7;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_b;
      current_statement__ = 8;
      sigma_b = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_c;
      current_statement__ = 9;
      sigma_c = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_d;
      current_statement__ = 10;
      sigma_d = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_e;
      current_statement__ = 11;
      sigma_e = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> y_hat =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 14;
      if (stan::math::logical_gte(N, 1)) {
        current_statement__ = 13;
        stan::model::assign(y_hat,
          (((((stan::math::fma(
                 stan::model::rvalue(beta, "beta", stan::model::index_uni(4)),
                 stan::model::rvalue(v_prev_full, "v_prev_full",
                   stan::model::index_uni(1)),
                 stan::math::fma(
                   (stan::model::rvalue(beta, "beta",
                      stan::model::index_uni(5)) *
                   stan::model::rvalue(female, "female",
                     stan::model::index_uni(1))),
                   stan::model::rvalue(black, "black",
                     stan::model::index_uni(1)),
                   stan::math::fma(
                     stan::model::rvalue(beta, "beta",
                       stan::model::index_uni(3)),
                     stan::model::rvalue(female, "female",
                       stan::model::index_uni(1)),
                     stan::math::fma(
                       stan::model::rvalue(beta, "beta",
                         stan::model::index_uni(2)),
                       stan::model::rvalue(black, "black",
                         stan::model::index_uni(1)),
                       stan::model::rvalue(beta, "beta",
                         stan::model::index_uni(1)))))) +
          stan::model::rvalue(a, "a",
            stan::model::index_uni(
              stan::model::rvalue(age, "age", stan::model::index_uni(1))))) +
          stan::model::rvalue(b, "b",
            stan::model::index_uni(
              stan::model::rvalue(edu, "edu", stan::model::index_uni(1))))) +
          stan::model::rvalue(c, "c",
            stan::model::index_uni(
              stan::model::rvalue(age_edu, "age_edu",
                stan::model::index_uni(1))))) +
          stan::model::rvalue(d, "d",
            stan::model::index_uni(
              stan::model::rvalue(state, "state", stan::model::index_uni(1)))))
          +
          stan::model::rvalue(e, "e",
            stan::model::index_uni(
              stan::model::rvalue(region_full, "region_full",
                stan::model::index_uni(1))))), "assigning variable y_hat",
          stan::model::index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 13;
          stan::model::assign(y_hat,
            (((((stan::math::fma(
                   stan::model::rvalue(beta, "beta",
                     stan::model::index_uni(4)),
                   stan::model::rvalue(v_prev_full, "v_prev_full",
                     stan::model::index_uni(i)),
                   stan::math::fma(
                     (stan::model::rvalue(beta, "beta",
                        stan::model::index_uni(5)) *
                     stan::model::rvalue(female, "female",
                       stan::model::index_uni(i))),
                     stan::model::rvalue(black, "black",
                       stan::model::index_uni(i)),
                     stan::math::fma(
                       stan::model::rvalue(beta, "beta",
                         stan::model::index_uni(3)),
                       stan::model::rvalue(female, "female",
                         stan::model::index_uni(i)),
                       stan::math::fma(
                         stan::model::rvalue(beta, "beta",
                           stan::model::index_uni(2)),
                         stan::model::rvalue(black, "black",
                           stan::model::index_uni(i)),
                         stan::model::rvalue(beta, "beta",
                           stan::model::index_uni(1)))))) +
            stan::model::rvalue(a, "a",
              stan::model::index_uni(
                stan::model::rvalue(age, "age", stan::model::index_uni(i)))))
            +
            stan::model::rvalue(b, "b",
              stan::model::index_uni(
                stan::model::rvalue(edu, "edu", stan::model::index_uni(i)))))
            +
            stan::model::rvalue(c, "c",
              stan::model::index_uni(
                stan::model::rvalue(age_edu, "age_edu",
                  stan::model::index_uni(i))))) +
            stan::model::rvalue(d, "d",
              stan::model::index_uni(
                stan::model::rvalue(state, "state", stan::model::index_uni(i)))))
            +
            stan::model::rvalue(e, "e",
              stan::model::index_uni(
                stan::model::rvalue(region_full, "region_full",
                  stan::model::index_uni(i))))), "assigning variable y_hat",
            stan::model::index_uni(i));
        }
      }
      {
        current_statement__ = 15;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(a, 0, sigma_a));
        current_statement__ = 16;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b, 0, sigma_b));
        current_statement__ = 17;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(c, 0, sigma_c));
        current_statement__ = 18;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(d, 0, sigma_d));
        current_statement__ = 19;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(e, 0, sigma_e));
        current_statement__ = 20;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(beta, 0, 100));
        current_statement__ = 21;
        lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(y, y_hat));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "expr_prop_fail3_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym23__;
      double lcm_sym22__;
      int lcm_sym21__;
      int lcm_sym20__;
      int lcm_sym19__;
      Eigen::Matrix<double,-1,1> a;
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_age);
      Eigen::Matrix<double,-1,1> b;
      current_statement__ = 2;
      b = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_edu);
      Eigen::Matrix<double,-1,1> c;
      current_statement__ = 3;
      c = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_age_edu);
      Eigen::Matrix<double,-1,1> d;
      current_statement__ = 4;
      d = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_state);
      Eigen::Matrix<double,-1,1> e;
      current_statement__ = 5;
      e = in__.template read<
            Eigen::Matrix<local_scalar_t__,-1,1>>(n_region_full);
      Eigen::Matrix<double,-1,1> beta;
      current_statement__ = 6;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(5);
      double sigma_a;
      current_statement__ = 7;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      double sigma_b;
      current_statement__ = 8;
      sigma_b = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      double sigma_c;
      current_statement__ = 9;
      sigma_c = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      double sigma_d;
      current_statement__ = 10;
      sigma_d = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      double sigma_e;
      current_statement__ = 11;
      sigma_e = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<double,-1,1> y_hat =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(a);
      out__.write(b);
      out__.write(c);
      out__.write(d);
      out__.write(e);
      out__.write(beta);
      out__.write(sigma_a);
      out__.write(sigma_b);
      out__.write(sigma_c);
      out__.write(sigma_d);
      out__.write(sigma_e);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 14;
      if (stan::math::logical_gte(N, 1)) {
        current_statement__ = 13;
        stan::model::assign(y_hat,
          (((((stan::math::fma(
                 stan::model::rvalue(beta, "beta", stan::model::index_uni(4)),
                 stan::model::rvalue(v_prev_full, "v_prev_full",
                   stan::model::index_uni(1)),
                 stan::math::fma(
                   (stan::model::rvalue(beta, "beta",
                      stan::model::index_uni(5)) *
                   stan::model::rvalue(female, "female",
                     stan::model::index_uni(1))),
                   stan::model::rvalue(black, "black",
                     stan::model::index_uni(1)),
                   stan::math::fma(
                     stan::model::rvalue(beta, "beta",
                       stan::model::index_uni(3)),
                     stan::model::rvalue(female, "female",
                       stan::model::index_uni(1)),
                     stan::math::fma(
                       stan::model::rvalue(beta, "beta",
                         stan::model::index_uni(2)),
                       stan::model::rvalue(black, "black",
                         stan::model::index_uni(1)),
                       stan::model::rvalue(beta, "beta",
                         stan::model::index_uni(1)))))) +
          stan::model::rvalue(a, "a",
            stan::model::index_uni(
              stan::model::rvalue(age, "age", stan::model::index_uni(1))))) +
          stan::model::rvalue(b, "b",
            stan::model::index_uni(
              stan::model::rvalue(edu, "edu", stan::model::index_uni(1))))) +
          stan::model::rvalue(c, "c",
            stan::model::index_uni(
              stan::model::rvalue(age_edu, "age_edu",
                stan::model::index_uni(1))))) +
          stan::model::rvalue(d, "d",
            stan::model::index_uni(
              stan::model::rvalue(state, "state", stan::model::index_uni(1)))))
          +
          stan::model::rvalue(e, "e",
            stan::model::index_uni(
              stan::model::rvalue(region_full, "region_full",
                stan::model::index_uni(1))))), "assigning variable y_hat",
          stan::model::index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 13;
          stan::model::assign(y_hat,
            (((((stan::math::fma(
                   stan::model::rvalue(beta, "beta",
                     stan::model::index_uni(4)),
                   stan::model::rvalue(v_prev_full, "v_prev_full",
                     stan::model::index_uni(i)),
                   stan::math::fma(
                     (stan::model::rvalue(beta, "beta",
                        stan::model::index_uni(5)) *
                     stan::model::rvalue(female, "female",
                       stan::model::index_uni(i))),
                     stan::model::rvalue(black, "black",
                       stan::model::index_uni(i)),
                     stan::math::fma(
                       stan::model::rvalue(beta, "beta",
                         stan::model::index_uni(3)),
                       stan::model::rvalue(female, "female",
                         stan::model::index_uni(i)),
                       stan::math::fma(
                         stan::model::rvalue(beta, "beta",
                           stan::model::index_uni(2)),
                         stan::model::rvalue(black, "black",
                           stan::model::index_uni(i)),
                         stan::model::rvalue(beta, "beta",
                           stan::model::index_uni(1)))))) +
            stan::model::rvalue(a, "a",
              stan::model::index_uni(
                stan::model::rvalue(age, "age", stan::model::index_uni(i)))))
            +
            stan::model::rvalue(b, "b",
              stan::model::index_uni(
                stan::model::rvalue(edu, "edu", stan::model::index_uni(i)))))
            +
            stan::model::rvalue(c, "c",
              stan::model::index_uni(
                stan::model::rvalue(age_edu, "age_edu",
                  stan::model::index_uni(i))))) +
            stan::model::rvalue(d, "d",
              stan::model::index_uni(
                stan::model::rvalue(state, "state", stan::model::index_uni(i)))))
            +
            stan::model::rvalue(e, "e",
              stan::model::index_uni(
                stan::model::rvalue(region_full, "region_full",
                  stan::model::index_uni(i))))), "assigning variable y_hat",
            stan::model::index_uni(i));
        }
      }
      if (emit_transformed_parameters__) {
        out__.write(y_hat);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> a;
      current_statement__ = 1;
      stan::model::assign(a,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_age),
        "assigning variable a");
      out__.write(a);
      Eigen::Matrix<local_scalar_t__,-1,1> b;
      current_statement__ = 2;
      stan::model::assign(b,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_edu),
        "assigning variable b");
      out__.write(b);
      Eigen::Matrix<local_scalar_t__,-1,1> c;
      current_statement__ = 3;
      stan::model::assign(c,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_age_edu),
        "assigning variable c");
      out__.write(c);
      Eigen::Matrix<local_scalar_t__,-1,1> d;
      current_statement__ = 4;
      stan::model::assign(d,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_state),
        "assigning variable d");
      out__.write(d);
      Eigen::Matrix<local_scalar_t__,-1,1> e;
      current_statement__ = 5;
      stan::model::assign(e,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_region_full),
        "assigning variable e");
      out__.write(e);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 6;
      stan::model::assign(beta,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(5),
        "assigning variable beta");
      out__.write(beta);
      local_scalar_t__ sigma_a;
      current_statement__ = 7;
      sigma_a = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_a);
      local_scalar_t__ sigma_b;
      current_statement__ = 8;
      sigma_b = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_b);
      local_scalar_t__ sigma_c;
      current_statement__ = 9;
      sigma_c = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_c);
      local_scalar_t__ sigma_d;
      current_statement__ = 10;
      sigma_d = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_d);
      local_scalar_t__ sigma_e;
      current_statement__ = 11;
      sigma_e = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_e);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "a", "double",
        std::vector<size_t>{static_cast<size_t>(n_age)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "b", "double",
        std::vector<size_t>{static_cast<size_t>(n_edu)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "c", "double",
        std::vector<size_t>{static_cast<size_t>(n_age_edu)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "d", "double",
        std::vector<size_t>{static_cast<size_t>(n_state)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "e", "double",
        std::vector<size_t>{static_cast<size_t>(n_region_full)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "beta", "double",
        std::vector<size_t>{static_cast<size_t>(5)});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "sigma_a",
        "double", std::vector<size_t>{});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization", "sigma_b",
        "double", std::vector<size_t>{});
      current_statement__ = 9;
      context__.validate_dims("parameter initialization", "sigma_c",
        "double", std::vector<size_t>{});
      current_statement__ = 10;
      context__.validate_dims("parameter initialization", "sigma_d",
        "double", std::vector<size_t>{});
      current_statement__ = 11;
      context__.validate_dims("parameter initialization", "sigma_e",
        "double", std::vector<size_t>{});
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      double lcm_sym12__;
      double lcm_sym11__;
      double lcm_sym10__;
      double lcm_sym9__;
      double lcm_sym8__;
      double lcm_sym7__;
      int lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> a =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_age, DUMMY_VAR__);
      {
        std::vector<double> a_flat__;
        current_statement__ = 1;
        a_flat__ = context__.vals_r("a");
        pos__ = 1;
        if (stan::math::logical_gte(n_age, 1)) {
          stan::model::assign(a,
            stan::model::rvalue(a_flat__, "a_flat__",
              stan::model::index_uni(1)), "assigning variable a",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_age; ++sym1__) {
            stan::model::assign(a, a_flat__[(pos__ - 1)],
              "assigning variable a", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(a);
      Eigen::Matrix<local_scalar_t__,-1,1> b =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_edu, DUMMY_VAR__);
      {
        std::vector<double> b_flat__;
        current_statement__ = 2;
        b_flat__ = context__.vals_r("b");
        pos__ = 1;
        if (stan::math::logical_gte(n_edu, 1)) {
          stan::model::assign(b,
            stan::model::rvalue(b_flat__, "b_flat__",
              stan::model::index_uni(1)), "assigning variable b",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
            stan::model::assign(b, b_flat__[(pos__ - 1)],
              "assigning variable b", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(b);
      Eigen::Matrix<local_scalar_t__,-1,1> c =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_age_edu,
          DUMMY_VAR__);
      {
        std::vector<double> c_flat__;
        current_statement__ = 3;
        c_flat__ = context__.vals_r("c");
        pos__ = 1;
        if (stan::math::logical_gte(n_age_edu, 1)) {
          stan::model::assign(c,
            stan::model::rvalue(c_flat__, "c_flat__",
              stan::model::index_uni(1)), "assigning variable c",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_age_edu; ++sym1__) {
            stan::model::assign(c, c_flat__[(pos__ - 1)],
              "assigning variable c", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(c);
      Eigen::Matrix<local_scalar_t__,-1,1> d =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_state, DUMMY_VAR__);
      {
        std::vector<double> d_flat__;
        current_statement__ = 4;
        d_flat__ = context__.vals_r("d");
        pos__ = 1;
        if (stan::math::logical_gte(n_state, 1)) {
          stan::model::assign(d,
            stan::model::rvalue(d_flat__, "d_flat__",
              stan::model::index_uni(1)), "assigning variable d",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_state; ++sym1__) {
            stan::model::assign(d, d_flat__[(pos__ - 1)],
              "assigning variable d", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(d);
      Eigen::Matrix<local_scalar_t__,-1,1> e =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_region_full,
          DUMMY_VAR__);
      {
        std::vector<double> e_flat__;
        current_statement__ = 5;
        e_flat__ = context__.vals_r("e");
        pos__ = 1;
        if (stan::math::logical_gte(n_region_full, 1)) {
          stan::model::assign(e,
            stan::model::rvalue(e_flat__, "e_flat__",
              stan::model::index_uni(1)), "assigning variable e",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_region_full; ++sym1__) {
            stan::model::assign(e, e_flat__[(pos__ - 1)],
              "assigning variable e", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(e);
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(5, DUMMY_VAR__);
      {
        std::vector<double> beta_flat__;
        current_statement__ = 6;
        beta_flat__ = context__.vals_r("beta");
        pos__ = 1;
        {
          stan::model::assign(beta,
            stan::model::rvalue(beta_flat__, "beta_flat__",
              stan::model::index_uni(1)), "assigning variable beta",
            stan::model::index_uni(1));
          pos__ = 2;
          {
            stan::model::assign(beta, beta_flat__[(pos__ - 1)],
              "assigning variable beta", stan::model::index_uni(2));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(beta, beta_flat__[(pos__ - 1)],
              "assigning variable beta", stan::model::index_uni(3));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(beta, beta_flat__[(pos__ - 1)],
              "assigning variable beta", stan::model::index_uni(4));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(beta, beta_flat__[(pos__ - 1)],
              "assigning variable beta", stan::model::index_uni(5));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(beta);
      local_scalar_t__ sigma_a;
      current_statement__ = 7;
      sigma_a = context__.vals_r("sigma_a")[(1 - 1)];
      out__.write_free_lub(0, 100, sigma_a);
      local_scalar_t__ sigma_b;
      current_statement__ = 8;
      sigma_b = context__.vals_r("sigma_b")[(1 - 1)];
      out__.write_free_lub(0, 100, sigma_b);
      local_scalar_t__ sigma_c;
      current_statement__ = 9;
      sigma_c = context__.vals_r("sigma_c")[(1 - 1)];
      out__.write_free_lub(0, 100, sigma_c);
      local_scalar_t__ sigma_d;
      current_statement__ = 10;
      sigma_d = context__.vals_r("sigma_d")[(1 - 1)];
      out__.write_free_lub(0, 100, sigma_d);
      local_scalar_t__ sigma_e;
      current_statement__ = 11;
      sigma_e = context__.vals_r("sigma_e")[(1 - 1)];
      out__.write_free_lub(0, 100, sigma_e);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"a", "b", "c", "d", "e", "beta",
                "sigma_a", "sigma_b", "sigma_c", "sigma_d", "sigma_e"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"y_hat"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    n_age)},
                std::vector<size_t>{static_cast<size_t>(n_edu)},
                std::vector<size_t>{static_cast<size_t>(n_age_edu)},
                std::vector<size_t>{static_cast<size_t>(n_state)},
                std::vector<size_t>{static_cast<size_t>(n_region_full)},
                std::vector<size_t>{static_cast<size_t>(5)},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(N)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym52__ = 1; sym52__ <= n_age; ++sym52__) {
      param_names__.emplace_back(std::string() + "a" + '.' +
        std::to_string(sym52__));
    }
    for (int sym52__ = 1; sym52__ <= n_edu; ++sym52__) {
      param_names__.emplace_back(std::string() + "b" + '.' +
        std::to_string(sym52__));
    }
    for (int sym52__ = 1; sym52__ <= n_age_edu; ++sym52__) {
      param_names__.emplace_back(std::string() + "c" + '.' +
        std::to_string(sym52__));
    }
    for (int sym52__ = 1; sym52__ <= n_state; ++sym52__) {
      param_names__.emplace_back(std::string() + "d" + '.' +
        std::to_string(sym52__));
    }
    for (int sym52__ = 1; sym52__ <= n_region_full; ++sym52__) {
      param_names__.emplace_back(std::string() + "e" + '.' +
        std::to_string(sym52__));
    }
    for (int sym52__ = 1; sym52__ <= 5; ++sym52__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym52__));
    }
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_b");
    param_names__.emplace_back(std::string() + "sigma_c");
    param_names__.emplace_back(std::string() + "sigma_d");
    param_names__.emplace_back(std::string() + "sigma_e");
    if (emit_transformed_parameters__) {
      for (int sym52__ = 1; sym52__ <= N; ++sym52__) {
        param_names__.emplace_back(std::string() + "y_hat" + '.' +
          std::to_string(sym52__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym52__ = 1; sym52__ <= n_age; ++sym52__) {
      param_names__.emplace_back(std::string() + "a" + '.' +
        std::to_string(sym52__));
    }
    for (int sym52__ = 1; sym52__ <= n_edu; ++sym52__) {
      param_names__.emplace_back(std::string() + "b" + '.' +
        std::to_string(sym52__));
    }
    for (int sym52__ = 1; sym52__ <= n_age_edu; ++sym52__) {
      param_names__.emplace_back(std::string() + "c" + '.' +
        std::to_string(sym52__));
    }
    for (int sym52__ = 1; sym52__ <= n_state; ++sym52__) {
      param_names__.emplace_back(std::string() + "d" + '.' +
        std::to_string(sym52__));
    }
    for (int sym52__ = 1; sym52__ <= n_region_full; ++sym52__) {
      param_names__.emplace_back(std::string() + "e" + '.' +
        std::to_string(sym52__));
    }
    for (int sym52__ = 1; sym52__ <= 5; ++sym52__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym52__));
    }
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_b");
    param_names__.emplace_back(std::string() + "sigma_c");
    param_names__.emplace_back(std::string() + "sigma_d");
    param_names__.emplace_back(std::string() + "sigma_e");
    if (emit_transformed_parameters__) {
      for (int sym52__ = 1; sym52__ <= N; ++sym52__) {
        param_names__.emplace_back(std::string() + "y_hat" + '.' +
          std::to_string(sym52__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age) + "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"c\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age_edu) + "},\"block\":\"parameters\"},{\"name\":\"d\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_state) + "},\"block\":\"parameters\"},{\"name\":\"e\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_region_full) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_b\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_c\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_d\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_e\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age) + "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"c\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age_edu) + "},\"block\":\"parameters\"},{\"name\":\"d\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_state) + "},\"block\":\"parameters\"},{\"name\":\"e\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_region_full) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_b\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_c\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_d\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_e\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((((n_age + n_edu) + n_age_edu) +
      n_state) + n_region_full) + 5) + 1) + 1) + 1) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * (N);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((((n_age + n_edu) + n_age_edu) +
      n_state) + n_region_full) + 5) + 1) + 1) + 1) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * (N);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = expr_prop_fail3_model_namespace::expr_prop_fail3_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail3_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail4.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail4_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 43> locations_array__ =
  {" (found before start of program)",
  " (in 'expr-prop-fail4.stan', line 12, column 2 to column 24)",
  " (in 'expr-prop-fail4.stan', line 13, column 2 to column 28)",
  " (in 'expr-prop-fail4.stan', line 16, column 2 to column 47)",
  " (in 'expr-prop-fail4.stan', line 17, column 2 to column 16)",
  " (in 'expr-prop-fail4.stan', line 27, column 2 to column 13)",
  " (in 'expr-prop-fail4.stan', line 28, column 2 to column 13)",
  " (in 'expr-prop-fail4.stan', line 29, column 2 to column 26)",
  " (in 'expr-prop-fail4.stan', line 30, column 2 to column 28)",
  " (in 'expr-prop-fail4.stan', line 31, column 2 to column 18)",
  " (in 'expr-prop-fail4.stan', line 32, column 2 to column 22)",
  " (in 'expr-prop-fail4.stan', line 34, column 2 to column 14)",
  " (in 'expr-prop-fail4.stan', line 35, column 2 to column 17)",
  " (in 'expr-prop-fail4.stan', line 18, column 2 to column 33)",
  " (in 'expr-prop-fail4.stan', line 19, column 2 to column 29)",
  " (in 'expr-prop-fail4.stan', line 20, column 2 to column 24)",
  " (in 'expr-prop-fail4.stan', line 37, column 2 to column 27)",
  " (in 'expr-prop-fail4.stan', line 38, column 2 to column 27)",
  " (in 'expr-prop-fail4.stan', line 40, column 4 to column 36)",
  " (in 'expr-prop-fail4.stan', line 39, column 19 to line 41, column 3)",
  " (in 'expr-prop-fail4.stan', line 42, column 2 to column 38)",
  " (in 'expr-prop-fail4.stan', line 47, column 4 to column 28)",
  " (in 'expr-prop-fail4.stan', line 48, column 4 to line 49, column 39)",
  " (in 'expr-prop-fail4.stan', line 46, column 19 to line 50, column 3)",
  " (in 'expr-prop-fail4.stan', line 46, column 2 to line 50, column 3)",
  " (in 'expr-prop-fail4.stan', line 23, column 2 to column 53)",
  " (in 'expr-prop-fail4.stan', line 24, column 2 to column 24)",
  " (in 'expr-prop-fail4.stan', line 2, column 2 to column 17)",
  " (in 'expr-prop-fail4.stan', line 3, column 2 to column 23)",
  " (in 'expr-prop-fail4.stan', line 4, column 8 to column 15)",
  " (in 'expr-prop-fail4.stan', line 4, column 2 to column 45)",
  " (in 'expr-prop-fail4.stan', line 5, column 8 to column 15)",
  " (in 'expr-prop-fail4.stan', line 5, column 2 to column 45)",
  " (in 'expr-prop-fail4.stan', line 6, column 18 to column 19)",
  " (in 'expr-prop-fail4.stan', line 6, column 2 to column 23)",
  " (in 'expr-prop-fail4.stan', line 9, column 9 to column 10)",
  " (in 'expr-prop-fail4.stan', line 9, column 2 to column 27)",
  " (in 'expr-prop-fail4.stan', line 13, column 9 to column 14)",
  " (in 'expr-prop-fail4.stan', line 17, column 9 to column 10)",
  " (in 'expr-prop-fail4.stan', line 31, column 9 to column 10)",
  " (in 'expr-prop-fail4.stan', line 32, column 9 to column 10)",
  " (in 'expr-prop-fail4.stan', line 34, column 9 to column 10)",
  " (in 'expr-prop-fail4.stan', line 35, column 8 to column 9)"};
class expr_prop_fail4_model final : public model_base_crtp<expr_prop_fail4_model> {
 private:
  double lcm_sym37__;
  double lcm_sym36__;
  Eigen::Matrix<double,-1,1> lcm_sym35___data__;
  int lcm_sym34__;
  int lcm_sym33__;
  int lcm_sym32__;
  int N;
  int N_edges;
  std::vector<int> node1;
  std::vector<int> node2;
  Eigen::Matrix<double,-1,1> E_data__;
  Eigen::Matrix<double,-1,1> log_E_data__;
  int phi_std_raw_1dim__;
  Eigen::Map<Eigen::Matrix<double,-1,1>> lcm_sym35__{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> E{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> log_E{nullptr, 0};
 public:
  ~expr_prop_fail4_model() {}
  expr_prop_fail4_model(stan::io::var_context& context__, unsigned int
                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "expr_prop_fail4_model_namespace::expr_prop_fail4_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 27;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 27;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 27;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 28;
      context__.validate_dims("data initialization", "N_edges", "int",
        std::vector<size_t>{});
      N_edges = std::numeric_limits<int>::min();
      current_statement__ = 28;
      N_edges = context__.vals_i("N_edges")[(1 - 1)];
      current_statement__ = 28;
      stan::math::check_greater_or_equal(function__, "N_edges", N_edges, 0);
      current_statement__ = 29;
      stan::math::validate_non_negative_index("node1", "N_edges", N_edges);
      current_statement__ = 30;
      context__.validate_dims("data initialization", "node1", "int",
        std::vector<size_t>{static_cast<size_t>(N_edges)});
      node1 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      current_statement__ = 30;
      node1 = context__.vals_i("node1");
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "node1", node1, 1);
      current_statement__ = 30;
      stan::math::check_less_or_equal(function__, "node1", node1, N);
      current_statement__ = 31;
      stan::math::validate_non_negative_index("node2", "N_edges", N_edges);
      current_statement__ = 32;
      context__.validate_dims("data initialization", "node2", "int",
        std::vector<size_t>{static_cast<size_t>(N_edges)});
      node2 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      current_statement__ = 32;
      node2 = context__.vals_i("node2");
      current_statement__ = 32;
      stan::math::check_greater_or_equal(function__, "node2", node2, 1);
      current_statement__ = 32;
      stan::math::check_less_or_equal(function__, "node2", node2, N);
      current_statement__ = 33;
      stan::math::validate_non_negative_index("E", "N", N);
      current_statement__ = 34;
      context__.validate_dims("data initialization", "E", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      E_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                   std::numeric_limits<double>::quiet_NaN());
      new (&E) Eigen::Map<Eigen::Matrix<double,-1,1>>(E_data__.data(), N);
      {
        std::vector<double> E_flat__;
        current_statement__ = 34;
        E_flat__ = context__.vals_r("E");
        pos__ = 1;
        if (stan::math::logical_gte(N, 1)) {
          stan::model::assign(E,
            stan::model::rvalue(E_flat__, "E_flat__",
              stan::model::index_uni(1)), "assigning variable E",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(E, E_flat__[(pos__ - 1)],
              "assigning variable E", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 34;
      stan::math::check_greater_or_equal(function__, "E", E, 0);
      current_statement__ = 35;
      stan::math::validate_non_negative_index("log_E", "N", N);
      current_statement__ = 36;
      log_E_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                       std::numeric_limits<double>::quiet_NaN());
      new (&log_E)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(log_E_data__.data(), N);
      current_statement__ = 36;
      stan::model::assign(log_E, stan::math::log(E),
        "assigning variable log_E");
      current_statement__ = 37;
      phi_std_raw_1dim__ = std::numeric_limits<int>::min();
      lcm_sym33__ = (N - 1);
      phi_std_raw_1dim__ = lcm_sym33__;
      current_statement__ = 37;
      stan::math::validate_non_negative_index("phi_std_raw", "N - 1",
        lcm_sym33__);
      current_statement__ = 38;
      stan::math::validate_non_negative_index("phi", "N", N);
      current_statement__ = 39;
      stan::math::validate_non_negative_index("theta", "N", N);
      current_statement__ = 40;
      stan::math::validate_non_negative_index("theta_std", "N", N);
      current_statement__ = 41;
      stan::math::validate_non_negative_index("x", "N", N);
      current_statement__ = 42;
      stan::math::validate_non_negative_index("y", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + phi_std_raw_1dim__;
  }
  inline std::string model_name() const final {
    return "expr_prop_fail4_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail4_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ lcm_sym30__;
      double lcm_sym29__;
      double lcm_sym28__;
      Eigen::Matrix<double,-1,1> lcm_sym27__;
      double lcm_sym26__;
      int lcm_sym31__;
      local_scalar_t__ tau_phi;
      current_statement__ = 1;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__,
                  jacobian__>(0, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> phi_std_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant((N - 1), DUMMY_VAR__);
      lcm_sym31__ = (N - 1);
      phi_std_raw = in__.template read<
                      Eigen::Matrix<local_scalar_t__,-1,1>>(lcm_sym31__);
      local_scalar_t__ sigma_phi = DUMMY_VAR__;
      lcm_sym30__ = stan::math::inv_sqrt(tau_phi);
      sigma_phi = lcm_sym30__;
      Eigen::Matrix<local_scalar_t__,-1,1> phi =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 13;
      stan::model::assign(phi, phi_std_raw, "assigning variable phi",
        stan::model::index_min_max(1, lcm_sym31__));
      current_statement__ = 14;
      stan::model::assign(phi, -(stan::math::sum(phi_std_raw)),
        "assigning variable phi", stan::model::index_uni(N));
      current_statement__ = 15;
      stan::model::assign(phi,
        stan::math::multiply(stan::model::deep_copy(phi), lcm_sym30__),
        "assigning variable phi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "sigma_phi",
        lcm_sym30__, 0);
      {
        current_statement__ = 25;
        lp_accum__.add((-0.5 *
          stan::math::dot_self(
            stan::math::subtract(
              stan::model::rvalue(phi, "phi", stan::model::index_multi(node1)),
              stan::model::rvalue(phi, "phi", stan::model::index_multi(node2))))));
        current_statement__ = 26;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(tau_phi, 1, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail4_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      Eigen::Matrix<double,-1,1> lcm_sym20__;
      double lcm_sym19__;
      int lcm_sym24__;
      local_scalar_t__ tau_phi;
      current_statement__ = 1;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__,
                  jacobian__>(0, lp__);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> phi_std_raw =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant((N
                                                            - 1),
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      lcm_sym24__ = (N - 1);
      phi_std_raw = in__.template read<
                      stan::math::var_value<Eigen::Matrix<double,-1,1>>>(lcm_sym24__);
      local_scalar_t__ sigma_phi = DUMMY_VAR__;
      lcm_sym23__ = stan::math::inv_sqrt(tau_phi);
      sigma_phi = lcm_sym23__;
      stan::math::var_value<Eigen::Matrix<double,-1,1>> phi =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 13;
      stan::model::assign(phi, phi_std_raw, "assigning variable phi",
        stan::model::index_min_max(1, lcm_sym24__));
      current_statement__ = 14;
      stan::model::assign(phi, -(stan::math::sum(phi_std_raw)),
        "assigning variable phi", stan::model::index_uni(N));
      current_statement__ = 15;
      stan::model::assign(phi,
        stan::math::multiply(stan::model::deep_copy(phi), lcm_sym23__),
        "assigning variable phi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "sigma_phi",
        lcm_sym23__, 0);
      {
        current_statement__ = 25;
        lp_accum__.add((-0.5 *
          stan::math::dot_self(
            stan::math::subtract(
              stan::model::rvalue(phi, "phi", stan::model::index_multi(node1)),
              stan::model::rvalue(phi, "phi", stan::model::index_multi(node2))))));
        current_statement__ = 26;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(tau_phi, 1, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "expr_prop_fail4_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym14__;
      double lcm_sym13__;
      Eigen::Matrix<double,-1,1> lcm_sym12__;
      Eigen::Matrix<double,-1,1> lcm_sym11__;
      double lcm_sym16__;
      double lcm_sym15__;
      int lcm_sym10__;
      int lcm_sym9__;
      double lcm_sym8__;
      int lcm_sym17__;
      int lcm_sym6__;
      double tau_phi;
      current_statement__ = 1;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__,
                  jacobian__>(0, lp__);
      Eigen::Matrix<double,-1,1> phi_std_raw =
        Eigen::Matrix<double,-1,1>::Constant((N - 1),
          std::numeric_limits<double>::quiet_NaN());
      lcm_sym17__ = (N - 1);
      phi_std_raw = in__.template read<
                      Eigen::Matrix<local_scalar_t__,-1,1>>(lcm_sym17__);
      double sigma_phi = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double,-1,1> phi =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(tau_phi);
      out__.write(phi_std_raw);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      lcm_sym13__ = stan::math::inv_sqrt(tau_phi);
      sigma_phi = lcm_sym13__;
      current_statement__ = 13;
      stan::model::assign(phi, phi_std_raw, "assigning variable phi",
        stan::model::index_min_max(1, lcm_sym17__));
      current_statement__ = 14;
      stan::model::assign(phi, -(stan::math::sum(phi_std_raw)),
        "assigning variable phi", stan::model::index_uni(N));
      current_statement__ = 15;
      stan::model::assign(phi,
        stan::math::multiply(stan::model::deep_copy(phi), lcm_sym13__),
        "assigning variable phi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "sigma_phi",
        lcm_sym13__, 0);
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym13__);
        out__.write(phi);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      double beta0 = std::numeric_limits<double>::quiet_NaN();
      double beta1 = std::numeric_limits<double>::quiet_NaN();
      double tau_theta = std::numeric_limits<double>::quiet_NaN();
      double sigma_theta = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double,-1,1> theta =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> theta_std =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> x =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<int> y =
        std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 16;
      beta0 = stan::math::normal_rng(0, 1, base_rng__);
      current_statement__ = 17;
      beta1 = stan::math::normal_rng(0, 1, base_rng__);
      lcm_sym6__ = stan::math::logical_gte(N, 1);
      if (lcm_sym6__) {
        current_statement__ = 18;
        stan::model::assign(theta_std,
          stan::math::normal_rng(0, 1, base_rng__),
          "assigning variable theta_std", stan::model::index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 18;
          stan::model::assign(theta_std,
            stan::math::normal_rng(0, 1, base_rng__),
            "assigning variable theta_std", stan::model::index_uni(i));
        }
      }
      current_statement__ = 20;
      tau_theta = stan::math::gamma_rng(3.2761, 1.81, base_rng__);
      lcm_sym14__ = stan::math::inv_sqrt(tau_theta);
      sigma_theta = lcm_sym14__;
      stan::model::assign(lcm_sym12__,
        stan::math::multiply(theta_std, lcm_sym14__),
        "assigning variable lcm_sym12__");
      stan::model::assign(theta, lcm_sym12__, "assigning variable theta");
      current_statement__ = 24;
      if (lcm_sym6__) {
        current_statement__ = 21;
        stan::model::assign(x, stan::math::normal_rng(0, 1, base_rng__),
          "assigning variable x", stan::model::index_uni(1));
        current_statement__ = 22;
        stan::model::assign(y,
          stan::math::poisson_log_rng(
            ((stan::math::fma(beta1,
                stan::model::rvalue(x, "x", stan::model::index_uni(1)),
                (stan::model::rvalue(stan::math::log(E), "log(E)",
                   stan::model::index_uni(1)) + beta0)) +
            stan::model::rvalue(phi, "phi", stan::model::index_uni(1))) +
            stan::model::rvalue(lcm_sym12__, "lcm_sym12__",
              stan::model::index_uni(1))), base_rng__),
          "assigning variable y", stan::model::index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 21;
          stan::model::assign(x, stan::math::normal_rng(0, 1, base_rng__),
            "assigning variable x", stan::model::index_uni(i));
          current_statement__ = 22;
          stan::model::assign(y,
            stan::math::poisson_log_rng(
              ((stan::math::fma(beta1,
                  stan::model::rvalue(x, "x", stan::model::index_uni(i)),
                  (stan::model::rvalue(stan::math::log(E), "log(E)",
                     stan::model::index_uni(i)) + beta0)) +
              stan::model::rvalue(phi, "phi", stan::model::index_uni(i))) +
              stan::model::rvalue(lcm_sym12__, "lcm_sym12__",
                stan::model::index_uni(i))), base_rng__),
            "assigning variable y", stan::model::index_uni(i));
        }
      }
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "tau_theta", tau_theta,
        0);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "sigma_theta",
        lcm_sym14__, 0);
      out__.write(beta0);
      out__.write(beta1);
      out__.write(tau_theta);
      out__.write(lcm_sym14__);
      out__.write(lcm_sym12__);
      out__.write(theta_std);
      out__.write(x);
      out__.write(y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ tau_phi;
      current_statement__ = 1;
      tau_phi = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau_phi);
      Eigen::Matrix<local_scalar_t__,-1,1> phi_std_raw;
      current_statement__ = 2;
      stan::model::assign(phi_std_raw,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(phi_std_raw_1dim__),
        "assigning variable phi_std_raw");
      out__.write(phi_std_raw);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "tau_phi",
        "double", std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "phi_std_raw",
        "double",
        std::vector<size_t>{static_cast<size_t>(phi_std_raw_1dim__)});
      double lcm_sym5__;
      double lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ tau_phi;
      current_statement__ = 1;
      tau_phi = context__.vals_r("tau_phi")[(1 - 1)];
      out__.write_free_lb(0, tau_phi);
      Eigen::Matrix<local_scalar_t__,-1,1> phi_std_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant((N - 1), DUMMY_VAR__);
      {
        std::vector<double> phi_std_raw_flat__;
        current_statement__ = 2;
        phi_std_raw_flat__ = context__.vals_r("phi_std_raw");
        pos__ = 1;
        lcm_sym2__ = (N - 1);
        if (stan::math::logical_gte(lcm_sym2__, 1)) {
          stan::model::assign(phi_std_raw,
            stan::model::rvalue(phi_std_raw_flat__, "phi_std_raw_flat__",
              stan::model::index_uni(1)), "assigning variable phi_std_raw",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= lcm_sym2__; ++sym1__) {
            stan::model::assign(phi_std_raw, phi_std_raw_flat__[(pos__ - 1)],
              "assigning variable phi_std_raw",
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(phi_std_raw);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"tau_phi", "phi_std_raw"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"sigma_phi", "phi"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string>
        temp{"beta0", "beta1", "tau_theta", "sigma_theta", "theta",
             "theta_std", "x", "y"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(phi_std_raw_1dim__)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(N)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym38__ = 1; sym38__ <= phi_std_raw_1dim__; ++sym38__) {
      param_names__.emplace_back(std::string() + "phi_std_raw" + '.' +
        std::to_string(sym38__));
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym38__ = 1; sym38__ <= N; ++sym38__) {
        param_names__.emplace_back(std::string() + "phi" + '.' +
          std::to_string(sym38__));
      }
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "beta0");
      param_names__.emplace_back(std::string() + "beta1");
      param_names__.emplace_back(std::string() + "tau_theta");
      param_names__.emplace_back(std::string() + "sigma_theta");
      for (int sym38__ = 1; sym38__ <= N; ++sym38__) {
        param_names__.emplace_back(std::string() + "theta" + '.' +
          std::to_string(sym38__));
      }
      for (int sym38__ = 1; sym38__ <= N; ++sym38__) {
        param_names__.emplace_back(std::string() + "theta_std" + '.' +
          std::to_string(sym38__));
      }
      for (int sym38__ = 1; sym38__ <= N; ++sym38__) {
        param_names__.emplace_back(std::string() + "x" + '.' +
          std::to_string(sym38__));
      }
      for (int sym38__ = 1; sym38__ <= N; ++sym38__) {
        param_names__.emplace_back(std::string() + "y" + '.' +
          std::to_string(sym38__));
      }
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym38__ = 1; sym38__ <= phi_std_raw_1dim__; ++sym38__) {
      param_names__.emplace_back(std::string() + "phi_std_raw" + '.' +
        std::to_string(sym38__));
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym38__ = 1; sym38__ <= N; ++sym38__) {
        param_names__.emplace_back(std::string() + "phi" + '.' +
          std::to_string(sym38__));
      }
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "beta0");
      param_names__.emplace_back(std::string() + "beta1");
      param_names__.emplace_back(std::string() + "tau_theta");
      param_names__.emplace_back(std::string() + "sigma_theta");
      for (int sym38__ = 1; sym38__ <= N; ++sym38__) {
        param_names__.emplace_back(std::string() + "theta" + '.' +
          std::to_string(sym38__));
      }
      for (int sym38__ = 1; sym38__ <= N; ++sym38__) {
        param_names__.emplace_back(std::string() + "theta_std" + '.' +
          std::to_string(sym38__));
      }
      for (int sym38__ = 1; sym38__ <= N; ++sym38__) {
        param_names__.emplace_back(std::string() + "x" + '.' +
          std::to_string(sym38__));
      }
      for (int sym38__ = 1; sym38__ <= N; ++sym38__) {
        param_names__.emplace_back(std::string() + "y" + '.' +
          std::to_string(sym38__));
      }
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(phi_std_raw_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"sigma_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(phi_std_raw_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"sigma_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + phi_std_raw_1dim__);
    const size_t num_transformed = emit_transformed_parameters * ((1 + N));
    const size_t num_gen_quantities = emit_generated_quantities * ((((((((1 +
      1) + 1) + 1) + N) + N) + N) + N));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + phi_std_raw_1dim__);
    const size_t num_transformed = emit_transformed_parameters * ((1 + N));
    const size_t num_gen_quantities = emit_generated_quantities * ((((((((1 +
      1) + 1) + 1) + N) + N) + N) + N));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = expr_prop_fail4_model_namespace::expr_prop_fail4_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail4_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail5.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail5_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 70> locations_array__ =
  {" (found before start of program)",
  " (in 'expr-prop-fail5.stan', line 68, column 2 to column 34)",
  " (in 'expr-prop-fail5.stan', line 69, column 2 to column 32)",
  " (in 'expr-prop-fail5.stan', line 70, column 2 to column 23)",
  " (in 'expr-prop-fail5.stan', line 71, column 2 to column 31)",
  " (in 'expr-prop-fail5.stan', line 76, column 2 to column 52)",
  " (in 'expr-prop-fail5.stan', line 77, column 2 to column 50)",
  " (in 'expr-prop-fail5.stan', line 78, column 2 to column 50)",
  " (in 'expr-prop-fail5.stan', line 79, column 2 to column 10)",
  " (in 'expr-prop-fail5.stan', line 118, column 2 to column 23)",
  " (in 'expr-prop-fail5.stan', line 86, column 6 to column 18)",
  " (in 'expr-prop-fail5.stan', line 85, column 6 to column 20)",
  " (in 'expr-prop-fail5.stan', line 84, column 34 to line 87, column 5)",
  " (in 'expr-prop-fail5.stan', line 89, column 6 to column 45)",
  " (in 'expr-prop-fail5.stan', line 90, column 6 to column 23)",
  " (in 'expr-prop-fail5.stan', line 88, column 40 to line 91, column 5)",
  " (in 'expr-prop-fail5.stan', line 88, column 4 to line 91, column 5)",
  " (in 'expr-prop-fail5.stan', line 83, column 22 to line 92, column 3)",
  " (in 'expr-prop-fail5.stan', line 25, column 11 to column 15)",
  " (in 'expr-prop-fail5.stan', line 25, column 17 to column 28)",
  " (in 'expr-prop-fail5.stan', line 25, column 4 to column 34)",
  " (in 'expr-prop-fail5.stan', line 28, column 6 to column 32)",
  " (in 'expr-prop-fail5.stan', line 31, column 8 to column 37)",
  " (in 'expr-prop-fail5.stan', line 32, column 8 to column 32)",
  " (in 'expr-prop-fail5.stan', line 42, column 8 to line 44, column 44)",
  " (in 'expr-prop-fail5.stan', line 29, column 39 to line 45, column 7)",
  " (in 'expr-prop-fail5.stan', line 29, column 6 to line 45, column 7)",
  " (in 'expr-prop-fail5.stan', line 27, column 24 to line 46, column 5)",
  " (in 'expr-prop-fail5.stan', line 27, column 4 to line 46, column 5)",
  " (in 'expr-prop-fail5.stan', line 47, column 4 to column 15)",
  " (in 'expr-prop-fail5.stan', line 104, column 2 to column 29)",
  " (in 'expr-prop-fail5.stan', line 110, column 8 to column 37)",
  " (in 'expr-prop-fail5.stan', line 111, column 8 to column 41)",
  " (in 'expr-prop-fail5.stan', line 109, column 42 to line 112, column 7)",
  " (in 'expr-prop-fail5.stan', line 113, column 6 to column 37)",
  " (in 'expr-prop-fail5.stan', line 108, column 22 to line 114, column 5)",
  " (in 'expr-prop-fail5.stan', line 107, column 22 to line 115, column 3)",
  " (in 'expr-prop-fail5.stan', line 107, column 2 to line 115, column 3)",
  " (in 'expr-prop-fail5.stan', line 51, column 2 to column 20)",
  " (in 'expr-prop-fail5.stan', line 52, column 2 to column 27)",
  " (in 'expr-prop-fail5.stan', line 53, column 8 to column 12)",
  " (in 'expr-prop-fail5.stan', line 53, column 14 to column 25)",
  " (in 'expr-prop-fail5.stan', line 53, column 2 to column 51)",
  " (in 'expr-prop-fail5.stan', line 56, column 2 to column 38)",
  " (in 'expr-prop-fail5.stan', line 58, column 8 to column 12)",
  " (in 'expr-prop-fail5.stan', line 58, column 2 to column 52)",
  " (in 'expr-prop-fail5.stan', line 59, column 8 to column 12)",
  " (in 'expr-prop-fail5.stan', line 59, column 2 to column 51)",
  " (in 'expr-prop-fail5.stan', line 63, column 4 to column 35)",
  " (in 'expr-prop-fail5.stan', line 62, column 2 to line 63, column 35)",
  " (in 'expr-prop-fail5.stan', line 65, column 4 to column 33)",
  " (in 'expr-prop-fail5.stan', line 64, column 2 to line 65, column 33)",
  " (in 'expr-prop-fail5.stan', line 70, column 9 to column 13)",
  " (in 'expr-prop-fail5.stan', line 76, column 27 to column 31)",
  " (in 'expr-prop-fail5.stan', line 76, column 33 to column 46)",
  " (in 'expr-prop-fail5.stan', line 77, column 27 to column 31)",
  " (in 'expr-prop-fail5.stan', line 77, column 33 to column 46)",
  " (in 'expr-prop-fail5.stan', line 78, column 27 to column 31)",
  " (in 'expr-prop-fail5.stan', line 78, column 33 to column 44)",
  " (in 'expr-prop-fail5.stan', line 8, column 8 to column 17)",
  " (in 'expr-prop-fail5.stan', line 7, column 6 to line 8, column 17)",
  " (in 'expr-prop-fail5.stan', line 9, column 4 to column 13)",
  " (in 'expr-prop-fail5.stan', line 5, column 37 to line 10, column 3)",
  " (in 'expr-prop-fail5.stan', line 15, column 6 to column 32)",
  " (in 'expr-prop-fail5.stan', line 19, column 8 to column 17)",
  " (in 'expr-prop-fail5.stan', line 18, column 6 to line 19, column 17)",
  " (in 'expr-prop-fail5.stan', line 13, column 39 to line 20, column 5)",
  " (in 'expr-prop-fail5.stan', line 21, column 4 to column 13)",
  " (in 'expr-prop-fail5.stan', line 12, column 36 to line 22, column 3)",
  " (in 'expr-prop-fail5.stan', line 24, column 74 to line 48, column 3)"};
int first_capture(const std::vector<int>& y_i, std::ostream* pstream__);
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__);
template <typename T2__, typename T3__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T2__>,
                stan::base_type_t<T3__>>,-1,-1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__);
int first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym25__;
    int lcm_sym24__;
    int lcm_sym23__;
    int lcm_sym22__;
    {
      lcm_sym23__ = stan::math::size(y_i);
      if (stan::math::logical_gte(lcm_sym23__, 1)) {
        current_statement__ = 60;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(1))) {
          current_statement__ = 59;
          return 1;
        }
        for (int k = 2; k <= lcm_sym23__; ++k) {
          current_statement__ = 60;
          if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
            current_statement__ = 59;
            return k;
          }
        }
      }
      current_statement__ = 61;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym31__;
    int lcm_sym30__;
    int lcm_sym29__;
    int lcm_sym28__;
    int lcm_sym27__;
    int lcm_sym26__;
    {
      lcm_sym29__ = (stan::math::size(y_i) - 1);
      if (stan::math::logical_gte(lcm_sym29__, 0)) {
        int k = std::numeric_limits<int>::min();
        lcm_sym28__ = (stan::math::size(y_i) - 0);
        current_statement__ = 65;
        if (y_i[(lcm_sym28__ - 1)]) {
          current_statement__ = 64;
          return lcm_sym28__;
        }
        for (int k_rev = 1; k_rev <= lcm_sym29__; ++k_rev) {
          int k = std::numeric_limits<int>::min();
          lcm_sym27__ = (stan::math::size(y_i) - k_rev);
          current_statement__ = 65;
          if (y_i[(lcm_sym27__ - 1)]) {
            current_statement__ = 64;
            return lcm_sym27__;
          }
        }
      }
      current_statement__ = 67;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T2__, typename T3__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T2__>,
                stan::base_type_t<T3__>>,-1,-1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T2__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  const auto& p = stan::math::to_ref(p_arg__);
  const auto& phi = stan::math::to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym41__;
    double lcm_sym40__;
    double lcm_sym39__;
    double lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    int lcm_sym35__;
    int lcm_sym34__;
    int lcm_sym33__;
    int lcm_sym32__;
    {
      current_statement__ = 18;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 19;
      stan::math::validate_non_negative_index("chi", "n_occasions",
        n_occasions);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
          DUMMY_VAR__);
      current_statement__ = 28;
      if (stan::math::logical_gte(nind, 1)) {
        current_statement__ = 21;
        stan::model::assign(chi, 1.0, "assigning variable chi",
          stan::model::index_uni(1), stan::model::index_uni(n_occasions));
        lcm_sym35__ = (n_occasions - 1);
        lcm_sym33__ = stan::math::logical_gte(lcm_sym35__, 1);
        if (lcm_sym33__) {
          int t_curr = std::numeric_limits<int>::min();
          int t_next = std::numeric_limits<int>::min();
          lcm_sym37__ = (lcm_sym35__ + 1);
          current_statement__ = 24;
          stan::model::assign(chi,
            stan::math::fma(
              (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                 stan::model::index_uni(lcm_sym35__)) * (1 -
              stan::model::rvalue(p, "p", stan::model::index_uni(1),
                stan::model::index_uni((lcm_sym37__ - 1))))),
              stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym37__)), (1 -
              stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym35__)))),
            "assigning variable chi", stan::model::index_uni(1),
            stan::model::index_uni(lcm_sym35__));
          for (int t = 2; t <= lcm_sym35__; ++t) {
            int t_curr = std::numeric_limits<int>::min();
            lcm_sym34__ = (n_occasions - t);
            int t_next = std::numeric_limits<int>::min();
            lcm_sym36__ = (lcm_sym34__ + 1);
            current_statement__ = 24;
            stan::model::assign(chi,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym34__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym36__ - 1))))),
                stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym36__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym34__)))),
              "assigning variable chi", stan::model::index_uni(1),
              stan::model::index_uni(lcm_sym34__));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 21;
          stan::model::assign(chi, 1.0, "assigning variable chi",
            stan::model::index_uni(i), stan::model::index_uni(n_occasions));
          current_statement__ = 26;
          if (lcm_sym33__) {
            int t_curr = std::numeric_limits<int>::min();
            int t_next = std::numeric_limits<int>::min();
            lcm_sym37__ = (lcm_sym35__ + 1);
            current_statement__ = 24;
            stan::model::assign(chi,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                   stan::model::index_uni(lcm_sym35__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(i),
                  stan::model::index_uni((lcm_sym37__ - 1))))),
                stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym37__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym35__)))),
              "assigning variable chi", stan::model::index_uni(i),
              stan::model::index_uni(lcm_sym35__));
            for (int t = 2; t <= lcm_sym35__; ++t) {
              int t_curr = std::numeric_limits<int>::min();
              lcm_sym34__ = (n_occasions - t);
              int t_next = std::numeric_limits<int>::min();
              lcm_sym36__ = (lcm_sym34__ + 1);
              current_statement__ = 24;
              stan::model::assign(chi,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                     stan::model::index_uni(lcm_sym34__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(i),
                    stan::model::index_uni((lcm_sym36__ - 1))))),
                  stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym36__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym34__)))),
                "assigning variable chi", stan::model::index_uni(i),
                stan::model::index_uni(lcm_sym34__));
            }
          }
        }
      }
      current_statement__ = 29;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class expr_prop_fail5_model final : public model_base_crtp<expr_prop_fail5_model> {
 private:
  int lcm_sym168__;
  int lcm_sym167__;
  int lcm_sym166__;
  int lcm_sym165__;
  int lcm_sym164__;
  int lcm_sym163__;
  int lcm_sym162__;
  int lcm_sym161__;
  int lcm_sym160__;
  int lcm_sym159__;
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last;
 public:
  ~expr_prop_fail5_model() {}
  expr_prop_fail5_model(stan::io::var_context& context__, unsigned int
                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "expr_prop_fail5_model_namespace::expr_prop_fail5_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 38;
      context__.validate_dims("data initialization", "nind", "int",
        std::vector<size_t>{});
      nind = std::numeric_limits<int>::min();
      current_statement__ = 38;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 38;
      stan::math::check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 39;
      context__.validate_dims("data initialization", "n_occasions", "int",
        std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      current_statement__ = 39;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 39;
      stan::math::check_greater_or_equal(function__, "n_occasions",
        n_occasions, 2);
      current_statement__ = 40;
      stan::math::validate_non_negative_index("y", "nind", nind);
      current_statement__ = 41;
      stan::math::validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 42;
      context__.validate_dims("data initialization", "y", "int",
        std::vector<size_t>{static_cast<size_t>(nind),
          static_cast<size_t>(n_occasions)});
      y = std::vector<std::vector<int>>(nind,
            std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      {
        std::vector<int> y_flat__;
        current_statement__ = 42;
        y_flat__ = context__.vals_i("y");
        pos__ = 1;
        if (stan::math::logical_gte(n_occasions, 1)) {
          lcm_sym160__ = stan::math::logical_gte(nind, 1);
          if (lcm_sym160__) {
            stan::model::assign(y,
              stan::model::rvalue(y_flat__, "y_flat__",
                stan::model::index_uni(1)), "assigning variable y",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
            if (lcm_sym160__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                stan::model::assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        } else {
          lcm_sym160__ = stan::math::logical_gte(nind, 1);
        }
      }
      current_statement__ = 42;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 42;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 43;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      lcm_sym161__ = (n_occasions - 1);
      n_occ_minus_1 = lcm_sym161__;
      current_statement__ = 44;
      stan::math::validate_non_negative_index("first", "nind", nind);
      current_statement__ = 45;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      current_statement__ = 46;
      stan::math::validate_non_negative_index("last", "nind", nind);
      current_statement__ = 47;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      current_statement__ = 49;
      if (lcm_sym160__) {
        current_statement__ = 48;
        stan::model::assign(first,
          first_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(1)), pstream__),
          "assigning variable first", stan::model::index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 48;
          stan::model::assign(first,
            first_capture(
              stan::model::rvalue(y, "y", stan::model::index_uni(i)),
              pstream__), "assigning variable first",
            stan::model::index_uni(i));
        }
      }
      current_statement__ = 51;
      if (lcm_sym160__) {
        current_statement__ = 50;
        stan::model::assign(last,
          last_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(1)), pstream__),
          "assigning variable last", stan::model::index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 50;
          stan::model::assign(last,
            last_capture(
              stan::model::rvalue(y, "y", stan::model::index_uni(i)),
              pstream__), "assigning variable last",
            stan::model::index_uni(i));
        }
      }
      current_statement__ = 45;
      stan::math::check_greater_or_equal(function__, "first", first, 0);
      current_statement__ = 45;
      stan::math::check_less_or_equal(function__, "first", first, n_occasions);
      current_statement__ = 47;
      stan::math::check_greater_or_equal(function__, "last", last, 0);
      current_statement__ = 47;
      stan::math::check_less_or_equal(function__, "last", last, n_occasions);
      current_statement__ = 52;
      stan::math::validate_non_negative_index("epsilon", "nind", nind);
      current_statement__ = 53;
      stan::math::validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 54;
      stan::math::validate_non_negative_index("phi", "n_occ_minus_1",
        lcm_sym161__);
      current_statement__ = 55;
      stan::math::validate_non_negative_index("p", "nind", nind);
      current_statement__ = 56;
      stan::math::validate_non_negative_index("p", "n_occ_minus_1",
        lcm_sym161__);
      current_statement__ = 57;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 58;
      stan::math::validate_non_negative_index("chi", "n_occasions",
        n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + nind + 1;
  }
  inline std::string model_name() const final {
    return "expr_prop_fail5_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail5_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym158__;
      int lcm_sym157__;
      int lcm_sym156__;
      int lcm_sym155__;
      int lcm_sym154__;
      double lcm_sym153__;
      local_scalar_t__ lcm_sym152__;
      local_scalar_t__ lcm_sym151__;
      local_scalar_t__ lcm_sym150__;
      double lcm_sym149__;
      double lcm_sym148__;
      double lcm_sym147__;
      double lcm_sym146__;
      double lcm_sym145__;
      double lcm_sym144__;
      double lcm_sym143__;
      double lcm_sym142__;
      double lcm_sym141__;
      double lcm_sym140__;
      double lcm_sym139__;
      double lcm_sym138__;
      double lcm_sym137__;
      double lcm_sym136__;
      int lcm_sym135__;
      int lcm_sym134__;
      int lcm_sym133__;
      int lcm_sym132__;
      int lcm_sym131__;
      int lcm_sym130__;
      int lcm_sym129__;
      int lcm_sym128__;
      int lcm_sym127__;
      int lcm_sym126__;
      int lcm_sym125__;
      int lcm_sym124__;
      int lcm_sym123__;
      int lcm_sym122__;
      int lcm_sym121__;
      int lcm_sym120__;
      int lcm_sym119__;
      int lcm_sym118__;
      int lcm_sym117__;
      int lcm_sym116__;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> epsilon;
      current_statement__ = 3;
      epsilon = in__.template read<
                  Eigen::Matrix<local_scalar_t__,-1,1>>(nind);
      local_scalar_t__ sigma;
      current_statement__ = 4;
      sigma = in__.template read_constrain_lub<local_scalar_t__,
                jacobian__>(0, 5, lp__);
      Eigen::Matrix<local_scalar_t__,-1,-1> phi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
          DUMMY_VAR__);
      local_scalar_t__ mu = DUMMY_VAR__;
      lcm_sym152__ = stan::math::logit(mean_phi);
      mu = lcm_sym152__;
      lcm_sym116__ = stan::math::logical_gte(nind, 1);
      if (lcm_sym116__) {
        lcm_sym155__ = stan::model::rvalue(first, "first",
                         stan::model::index_uni(1));
        lcm_sym129__ = (lcm_sym155__ - 1);
        if (stan::math::logical_gte(lcm_sym129__, 1)) {
          stan::model::assign(phi, 0, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          current_statement__ = 10;
          stan::model::assign(p, 0, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int t = 2; t <= lcm_sym129__; ++t) {
            current_statement__ = 11;
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 10;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        lcm_sym127__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym127__, lcm_sym155__)) {
          lcm_sym151__ = stan::math::inv_logit((lcm_sym152__ +
                           stan::model::rvalue(epsilon, "epsilon",
                             stan::model::index_uni(1))));
          stan::model::assign(phi, lcm_sym151__, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym155__));
          lcm_sym135__ = (lcm_sym155__ + 1);
          stan::model::assign(p, mean_p, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym155__));
          for (int t = lcm_sym135__; t <= lcm_sym127__; ++t) {
            current_statement__ = 13;
            stan::model::assign(phi, lcm_sym151__, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 14;
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          lcm_sym154__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(i));
          lcm_sym128__ = (lcm_sym154__ - 1);
          if (stan::math::logical_gte(lcm_sym128__, 1)) {
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 10;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(1));
            for (int t = 2; t <= lcm_sym128__; ++t) {
              current_statement__ = 11;
              stan::model::assign(phi, 0, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 10;
              stan::model::assign(p, 0, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
          current_statement__ = 16;
          if (stan::math::logical_gte(lcm_sym127__, lcm_sym154__)) {
            lcm_sym150__ = stan::math::inv_logit((lcm_sym152__ +
                             stan::model::rvalue(epsilon, "epsilon",
                               stan::model::index_uni(i))));
            stan::model::assign(phi, lcm_sym150__, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym154__));
            lcm_sym134__ = (lcm_sym154__ + 1);
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym154__));
            for (int t = lcm_sym134__; t <= lcm_sym127__; ++t) {
              current_statement__ = 13;
              stan::model::assign(phi, lcm_sym150__,
                "assigning variable phi", stan::model::index_uni(i),
                stan::model::index_uni(t));
              current_statement__ = 14;
              stan::model::assign(p, mean_p, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
        }
      }
      Eigen::Matrix<local_scalar_t__,-1,-1>
        inline_prob_uncaptured_return_sym15__;
      {
        current_statement__ = 18;
        stan::math::validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 19;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          n_occasions);
        Eigen::Matrix<local_scalar_t__,-1,-1>
          inline_prob_uncaptured_chi_sym16__ =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
            DUMMY_VAR__);
        current_statement__ = 28;
        if (lcm_sym116__) {
          current_statement__ = 21;
          stan::model::assign(inline_prob_uncaptured_chi_sym16__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym16__",
            stan::model::index_uni(1), stan::model::index_uni(n_occasions));
          lcm_sym127__ = (n_occasions - 1);
          lcm_sym117__ = stan::math::logical_gte(lcm_sym127__, 1);
          if (lcm_sym117__) {
            int inline_prob_uncaptured_t_curr_sym17__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym18__ =
              std::numeric_limits<int>::min();
            lcm_sym131__ = (lcm_sym127__ + 1);
            current_statement__ = 24;
            stan::model::assign(inline_prob_uncaptured_chi_sym16__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym127__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym131__ - 1))))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                  "inline_prob_uncaptured_chi_sym16__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym131__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym127__)))),
              "assigning variable inline_prob_uncaptured_chi_sym16__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym127__));
            for (int inline_prob_uncaptured_t_sym19__ = 2; inline_prob_uncaptured_t_sym19__
                 <= lcm_sym127__; ++inline_prob_uncaptured_t_sym19__) {
              int inline_prob_uncaptured_t_curr_sym17__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym18__ =
                std::numeric_limits<int>::min();
              lcm_sym126__ = (n_occasions -
                inline_prob_uncaptured_t_sym19__);
              lcm_sym130__ = (lcm_sym126__ + 1);
              current_statement__ = 24;
              stan::model::assign(inline_prob_uncaptured_chi_sym16__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym126__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni((lcm_sym130__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                    "inline_prob_uncaptured_chi_sym16__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym130__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym126__)))),
                "assigning variable inline_prob_uncaptured_chi_sym16__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym126__));
            }
          }
          for (int inline_prob_uncaptured_i_sym20__ = 2; inline_prob_uncaptured_i_sym20__
               <= nind; ++inline_prob_uncaptured_i_sym20__) {
            current_statement__ = 21;
            stan::model::assign(inline_prob_uncaptured_chi_sym16__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym16__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
              stan::model::index_uni(n_occasions));
            current_statement__ = 26;
            if (lcm_sym117__) {
              int inline_prob_uncaptured_t_curr_sym17__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym18__ =
                std::numeric_limits<int>::min();
              lcm_sym131__ = (lcm_sym127__ + 1);
              current_statement__ = 24;
              stan::model::assign(inline_prob_uncaptured_chi_sym16__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                     stan::model::index_uni(lcm_sym127__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                    stan::model::index_uni((lcm_sym131__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                    "inline_prob_uncaptured_chi_sym16__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                    stan::model::index_uni(lcm_sym131__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                    stan::model::index_uni(lcm_sym127__)))),
                "assigning variable inline_prob_uncaptured_chi_sym16__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                stan::model::index_uni(lcm_sym127__));
              for (int inline_prob_uncaptured_t_sym19__ = 2; inline_prob_uncaptured_t_sym19__
                   <= lcm_sym127__; ++inline_prob_uncaptured_t_sym19__) {
                int inline_prob_uncaptured_t_curr_sym17__ =
                  std::numeric_limits<int>::min();
                int inline_prob_uncaptured_t_next_sym18__ =
                  std::numeric_limits<int>::min();
                lcm_sym126__ = (n_occasions -
                  inline_prob_uncaptured_t_sym19__);
                lcm_sym130__ = (lcm_sym126__ + 1);
                current_statement__ = 24;
                stan::model::assign(inline_prob_uncaptured_chi_sym16__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(
                         inline_prob_uncaptured_i_sym20__),
                       stan::model::index_uni(lcm_sym126__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                      stan::model::index_uni((lcm_sym130__ - 1))))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                      "inline_prob_uncaptured_chi_sym16__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                      stan::model::index_uni(lcm_sym130__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                      stan::model::index_uni(lcm_sym126__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym16__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                  stan::model::index_uni(lcm_sym126__));
              }
            }
          }
        }
        current_statement__ = 29;
        stan::model::assign(inline_prob_uncaptured_return_sym15__,
          inline_prob_uncaptured_chi_sym16__,
          "assigning variable inline_prob_uncaptured_return_sym15__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym15__,
        "assigning variable chi");
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 6;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 6;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym15__, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym15__, 1);
      {
        current_statement__ = 30;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(epsilon, 0, sigma));
        current_statement__ = 37;
        if (lcm_sym116__) {
          lcm_sym155__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(1));
          if (stan::math::logical_gt(lcm_sym155__, 0)) {
            lcm_sym157__ = stan::model::rvalue(last, "last",
                             stan::model::index_uni(1));
            lcm_sym135__ = (lcm_sym155__ + 1);
            if (stan::math::logical_gte(lcm_sym157__, lcm_sym135__)) {
              current_statement__ = 31;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym135__ - 1)))));
              lcm_sym133__ = (lcm_sym135__ + 1);
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(lcm_sym135__)),
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym135__ - 1)))));
              for (int t = lcm_sym133__; t <= lcm_sym157__; ++t) {
                current_statement__ = 31;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
                current_statement__ = 32;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni(t)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
              }
            }
            current_statement__ = 34;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             stan::model::rvalue(
                               inline_prob_uncaptured_return_sym15__,
                               "inline_prob_uncaptured_return_sym15__",
                               stan::model::index_uni(1),
                               stan::model::index_uni(lcm_sym157__))));
          }
          for (int i = 2; i <= nind; ++i) {
            lcm_sym154__ = stan::model::rvalue(first, "first",
                             stan::model::index_uni(i));
            if (stan::math::logical_gt(lcm_sym154__, 0)) {
              lcm_sym156__ = stan::model::rvalue(last, "last",
                               stan::model::index_uni(i));
              lcm_sym134__ = (lcm_sym154__ + 1);
              if (stan::math::logical_gte(lcm_sym156__, lcm_sym134__)) {
                current_statement__ = 31;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym134__ - 1)))));
                lcm_sym132__ = (lcm_sym134__ + 1);
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(lcm_sym134__)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym134__ - 1)))));
                for (int t = lcm_sym132__; t <= lcm_sym156__; ++t) {
                  current_statement__ = 31;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(phi, "phi",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                  current_statement__ = 32;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni(t)),
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                }
              }
              current_statement__ = 34;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(
                                 inline_prob_uncaptured_return_sym15__,
                                 "inline_prob_uncaptured_return_sym15__",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(lcm_sym156__))));
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail5_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym115__;
      int lcm_sym114__;
      int lcm_sym113__;
      int lcm_sym112__;
      int lcm_sym111__;
      double lcm_sym110__;
      local_scalar_t__ lcm_sym109__;
      local_scalar_t__ lcm_sym108__;
      local_scalar_t__ lcm_sym107__;
      double lcm_sym106__;
      double lcm_sym105__;
      double lcm_sym104__;
      double lcm_sym103__;
      double lcm_sym102__;
      double lcm_sym101__;
      double lcm_sym100__;
      double lcm_sym99__;
      double lcm_sym98__;
      double lcm_sym97__;
      double lcm_sym96__;
      double lcm_sym95__;
      double lcm_sym94__;
      double lcm_sym93__;
      int lcm_sym92__;
      int lcm_sym91__;
      int lcm_sym90__;
      int lcm_sym89__;
      int lcm_sym88__;
      int lcm_sym87__;
      int lcm_sym86__;
      int lcm_sym85__;
      int lcm_sym84__;
      int lcm_sym83__;
      int lcm_sym82__;
      int lcm_sym81__;
      int lcm_sym80__;
      int lcm_sym79__;
      int lcm_sym78__;
      int lcm_sym77__;
      int lcm_sym76__;
      int lcm_sym75__;
      int lcm_sym74__;
      int lcm_sym73__;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> epsilon;
      current_statement__ = 3;
      epsilon = in__.template read<
                  Eigen::Matrix<local_scalar_t__,-1,1>>(nind);
      local_scalar_t__ sigma;
      current_statement__ = 4;
      sigma = in__.template read_constrain_lub<local_scalar_t__,
                jacobian__>(0, 5, lp__);
      Eigen::Matrix<local_scalar_t__,-1,-1> phi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
          DUMMY_VAR__);
      local_scalar_t__ mu = DUMMY_VAR__;
      lcm_sym109__ = stan::math::logit(mean_phi);
      mu = lcm_sym109__;
      lcm_sym73__ = stan::math::logical_gte(nind, 1);
      if (lcm_sym73__) {
        lcm_sym112__ = stan::model::rvalue(first, "first",
                         stan::model::index_uni(1));
        lcm_sym86__ = (lcm_sym112__ - 1);
        if (stan::math::logical_gte(lcm_sym86__, 1)) {
          stan::model::assign(phi, 0, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          current_statement__ = 10;
          stan::model::assign(p, 0, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int t = 2; t <= lcm_sym86__; ++t) {
            current_statement__ = 11;
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 10;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        lcm_sym84__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym84__, lcm_sym112__)) {
          lcm_sym108__ = stan::math::inv_logit((lcm_sym109__ +
                           stan::model::rvalue(epsilon, "epsilon",
                             stan::model::index_uni(1))));
          stan::model::assign(phi, lcm_sym108__, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym112__));
          lcm_sym92__ = (lcm_sym112__ + 1);
          stan::model::assign(p, mean_p, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym112__));
          for (int t = lcm_sym92__; t <= lcm_sym84__; ++t) {
            current_statement__ = 13;
            stan::model::assign(phi, lcm_sym108__, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 14;
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          lcm_sym111__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(i));
          lcm_sym85__ = (lcm_sym111__ - 1);
          if (stan::math::logical_gte(lcm_sym85__, 1)) {
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 10;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(1));
            for (int t = 2; t <= lcm_sym85__; ++t) {
              current_statement__ = 11;
              stan::model::assign(phi, 0, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 10;
              stan::model::assign(p, 0, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
          current_statement__ = 16;
          if (stan::math::logical_gte(lcm_sym84__, lcm_sym111__)) {
            lcm_sym107__ = stan::math::inv_logit((lcm_sym109__ +
                             stan::model::rvalue(epsilon, "epsilon",
                               stan::model::index_uni(i))));
            stan::model::assign(phi, lcm_sym107__, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym111__));
            lcm_sym91__ = (lcm_sym111__ + 1);
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym111__));
            for (int t = lcm_sym91__; t <= lcm_sym84__; ++t) {
              current_statement__ = 13;
              stan::model::assign(phi, lcm_sym107__,
                "assigning variable phi", stan::model::index_uni(i),
                stan::model::index_uni(t));
              current_statement__ = 14;
              stan::model::assign(p, mean_p, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
        }
      }
      Eigen::Matrix<local_scalar_t__,-1,-1>
        inline_prob_uncaptured_return_sym8__;
      {
        current_statement__ = 18;
        stan::math::validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 19;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          n_occasions);
        Eigen::Matrix<local_scalar_t__,-1,-1>
          inline_prob_uncaptured_chi_sym9__ =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
            DUMMY_VAR__);
        current_statement__ = 28;
        if (lcm_sym73__) {
          current_statement__ = 21;
          stan::model::assign(inline_prob_uncaptured_chi_sym9__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym9__",
            stan::model::index_uni(1), stan::model::index_uni(n_occasions));
          lcm_sym84__ = (n_occasions - 1);
          lcm_sym74__ = stan::math::logical_gte(lcm_sym84__, 1);
          if (lcm_sym74__) {
            int inline_prob_uncaptured_t_curr_sym10__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym11__ =
              std::numeric_limits<int>::min();
            lcm_sym88__ = (lcm_sym84__ + 1);
            current_statement__ = 24;
            stan::model::assign(inline_prob_uncaptured_chi_sym9__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym84__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym88__ - 1))))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                  "inline_prob_uncaptured_chi_sym9__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym88__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym84__)))),
              "assigning variable inline_prob_uncaptured_chi_sym9__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym84__));
            for (int inline_prob_uncaptured_t_sym12__ = 2; inline_prob_uncaptured_t_sym12__
                 <= lcm_sym84__; ++inline_prob_uncaptured_t_sym12__) {
              int inline_prob_uncaptured_t_curr_sym10__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym11__ =
                std::numeric_limits<int>::min();
              lcm_sym83__ = (n_occasions - inline_prob_uncaptured_t_sym12__);
              lcm_sym87__ = (lcm_sym83__ + 1);
              current_statement__ = 24;
              stan::model::assign(inline_prob_uncaptured_chi_sym9__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym83__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni((lcm_sym87__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                    "inline_prob_uncaptured_chi_sym9__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym87__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym83__)))),
                "assigning variable inline_prob_uncaptured_chi_sym9__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym83__));
            }
          }
          for (int inline_prob_uncaptured_i_sym13__ = 2; inline_prob_uncaptured_i_sym13__
               <= nind; ++inline_prob_uncaptured_i_sym13__) {
            current_statement__ = 21;
            stan::model::assign(inline_prob_uncaptured_chi_sym9__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym9__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
              stan::model::index_uni(n_occasions));
            current_statement__ = 26;
            if (lcm_sym74__) {
              int inline_prob_uncaptured_t_curr_sym10__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym11__ =
                std::numeric_limits<int>::min();
              lcm_sym88__ = (lcm_sym84__ + 1);
              current_statement__ = 24;
              stan::model::assign(inline_prob_uncaptured_chi_sym9__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                     stan::model::index_uni(lcm_sym84__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                    stan::model::index_uni((lcm_sym88__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                    "inline_prob_uncaptured_chi_sym9__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                    stan::model::index_uni(lcm_sym88__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                    stan::model::index_uni(lcm_sym84__)))),
                "assigning variable inline_prob_uncaptured_chi_sym9__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                stan::model::index_uni(lcm_sym84__));
              for (int inline_prob_uncaptured_t_sym12__ = 2; inline_prob_uncaptured_t_sym12__
                   <= lcm_sym84__; ++inline_prob_uncaptured_t_sym12__) {
                int inline_prob_uncaptured_t_curr_sym10__ =
                  std::numeric_limits<int>::min();
                int inline_prob_uncaptured_t_next_sym11__ =
                  std::numeric_limits<int>::min();
                lcm_sym83__ = (n_occasions -
                  inline_prob_uncaptured_t_sym12__);
                lcm_sym87__ = (lcm_sym83__ + 1);
                current_statement__ = 24;
                stan::model::assign(inline_prob_uncaptured_chi_sym9__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(
                         inline_prob_uncaptured_i_sym13__),
                       stan::model::index_uni(lcm_sym83__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                      stan::model::index_uni((lcm_sym87__ - 1))))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                      "inline_prob_uncaptured_chi_sym9__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                      stan::model::index_uni(lcm_sym87__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                      stan::model::index_uni(lcm_sym83__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym9__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                  stan::model::index_uni(lcm_sym83__));
              }
            }
          }
        }
        current_statement__ = 29;
        stan::model::assign(inline_prob_uncaptured_return_sym8__,
          inline_prob_uncaptured_chi_sym9__,
          "assigning variable inline_prob_uncaptured_return_sym8__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym8__,
        "assigning variable chi");
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 6;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 6;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym8__, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym8__, 1);
      {
        current_statement__ = 30;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(epsilon, 0, sigma));
        current_statement__ = 37;
        if (lcm_sym73__) {
          lcm_sym112__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(1));
          if (stan::math::logical_gt(lcm_sym112__, 0)) {
            lcm_sym114__ = stan::model::rvalue(last, "last",
                             stan::model::index_uni(1));
            lcm_sym92__ = (lcm_sym112__ + 1);
            if (stan::math::logical_gte(lcm_sym114__, lcm_sym92__)) {
              current_statement__ = 31;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym92__ - 1)))));
              lcm_sym90__ = (lcm_sym92__ + 1);
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(lcm_sym92__)),
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym92__ - 1)))));
              for (int t = lcm_sym90__; t <= lcm_sym114__; ++t) {
                current_statement__ = 31;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
                current_statement__ = 32;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni(t)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
              }
            }
            current_statement__ = 34;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             stan::model::rvalue(
                               inline_prob_uncaptured_return_sym8__,
                               "inline_prob_uncaptured_return_sym8__",
                               stan::model::index_uni(1),
                               stan::model::index_uni(lcm_sym114__))));
          }
          for (int i = 2; i <= nind; ++i) {
            lcm_sym111__ = stan::model::rvalue(first, "first",
                             stan::model::index_uni(i));
            if (stan::math::logical_gt(lcm_sym111__, 0)) {
              lcm_sym113__ = stan::model::rvalue(last, "last",
                               stan::model::index_uni(i));
              lcm_sym91__ = (lcm_sym111__ + 1);
              if (stan::math::logical_gte(lcm_sym113__, lcm_sym91__)) {
                current_statement__ = 31;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym91__ - 1)))));
                lcm_sym89__ = (lcm_sym91__ + 1);
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(lcm_sym91__)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym91__ - 1)))));
                for (int t = lcm_sym89__; t <= lcm_sym113__; ++t) {
                  current_statement__ = 31;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(phi, "phi",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                  current_statement__ = 32;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni(t)),
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                }
              }
              current_statement__ = 34;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(
                                 inline_prob_uncaptured_return_sym8__,
                                 "inline_prob_uncaptured_return_sym8__",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(lcm_sym113__))));
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "expr_prop_fail5_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym72__;
      int lcm_sym71__;
      int lcm_sym70__;
      double lcm_sym69__;
      double lcm_sym68__;
      double lcm_sym67__;
      double lcm_sym66__;
      double lcm_sym65__;
      double lcm_sym64__;
      double lcm_sym63__;
      double lcm_sym62__;
      int lcm_sym61__;
      int lcm_sym60__;
      int lcm_sym59__;
      int lcm_sym58__;
      int lcm_sym57__;
      int lcm_sym56__;
      int lcm_sym55__;
      int lcm_sym54__;
      int lcm_sym53__;
      int lcm_sym52__;
      int lcm_sym51__;
      int lcm_sym50__;
      int lcm_sym49__;
      int lcm_sym48__;
      int lcm_sym47__;
      int lcm_sym46__;
      double mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      double mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<double,-1,1> epsilon;
      current_statement__ = 3;
      epsilon = in__.template read<
                  Eigen::Matrix<local_scalar_t__,-1,1>>(nind);
      double sigma;
      current_statement__ = 4;
      sigma = in__.template read_constrain_lub<local_scalar_t__,
                jacobian__>(0, 5, lp__);
      Eigen::Matrix<double,-1,-1> phi =
        Eigen::Matrix<double,-1,-1>::Constant(nind, (n_occasions - 1),
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> p =
        Eigen::Matrix<double,-1,-1>::Constant(nind, (n_occasions - 1),
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> chi =
        Eigen::Matrix<double,-1,-1>::Constant(nind, n_occasions,
          std::numeric_limits<double>::quiet_NaN());
      double mu = std::numeric_limits<double>::quiet_NaN();
      out__.write(mean_phi);
      out__.write(mean_p);
      out__.write(epsilon);
      out__.write(sigma);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      lcm_sym68__ = stan::math::logit(mean_phi);
      mu = lcm_sym68__;
      lcm_sym46__ = stan::math::logical_gte(nind, 1);
      if (lcm_sym46__) {
        lcm_sym71__ = stan::model::rvalue(first, "first",
                        stan::model::index_uni(1));
        lcm_sym55__ = (lcm_sym71__ - 1);
        if (stan::math::logical_gte(lcm_sym55__, 1)) {
          stan::model::assign(phi, 0, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          current_statement__ = 10;
          stan::model::assign(p, 0, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int t = 2; t <= lcm_sym55__; ++t) {
            current_statement__ = 11;
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 10;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        lcm_sym53__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym53__, lcm_sym71__)) {
          lcm_sym67__ = stan::math::inv_logit((lcm_sym68__ +
                          stan::model::rvalue(epsilon, "epsilon",
                            stan::model::index_uni(1))));
          stan::model::assign(phi, lcm_sym67__, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym71__));
          lcm_sym61__ = (lcm_sym71__ + 1);
          stan::model::assign(p, mean_p, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym71__));
          for (int t = lcm_sym61__; t <= lcm_sym53__; ++t) {
            current_statement__ = 13;
            stan::model::assign(phi, lcm_sym67__, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 14;
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          lcm_sym70__ = stan::model::rvalue(first, "first",
                          stan::model::index_uni(i));
          lcm_sym54__ = (lcm_sym70__ - 1);
          if (stan::math::logical_gte(lcm_sym54__, 1)) {
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 10;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(1));
            for (int t = 2; t <= lcm_sym54__; ++t) {
              current_statement__ = 11;
              stan::model::assign(phi, 0, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 10;
              stan::model::assign(p, 0, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
          current_statement__ = 16;
          if (stan::math::logical_gte(lcm_sym53__, lcm_sym70__)) {
            lcm_sym66__ = stan::math::inv_logit((lcm_sym68__ +
                            stan::model::rvalue(epsilon, "epsilon",
                              stan::model::index_uni(i))));
            stan::model::assign(phi, lcm_sym66__, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym70__));
            lcm_sym60__ = (lcm_sym70__ + 1);
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym70__));
            for (int t = lcm_sym60__; t <= lcm_sym53__; ++t) {
              current_statement__ = 13;
              stan::model::assign(phi, lcm_sym66__, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 14;
              stan::model::assign(p, mean_p, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
        }
      }
      Eigen::Matrix<double,-1,-1> inline_prob_uncaptured_return_sym1__;
      {
        current_statement__ = 18;
        stan::math::validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 19;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          n_occasions);
        Eigen::Matrix<double,-1,-1> inline_prob_uncaptured_chi_sym2__ =
          Eigen::Matrix<double,-1,-1>::Constant(nind, n_occasions,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 28;
        if (lcm_sym46__) {
          current_statement__ = 21;
          stan::model::assign(inline_prob_uncaptured_chi_sym2__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym2__",
            stan::model::index_uni(1), stan::model::index_uni(n_occasions));
          lcm_sym53__ = (n_occasions - 1);
          lcm_sym47__ = stan::math::logical_gte(lcm_sym53__, 1);
          if (lcm_sym47__) {
            int inline_prob_uncaptured_t_curr_sym3__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym4__ =
              std::numeric_limits<int>::min();
            lcm_sym59__ = (lcm_sym53__ + 1);
            current_statement__ = 24;
            stan::model::assign(inline_prob_uncaptured_chi_sym2__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym53__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym59__ - 1))))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                  "inline_prob_uncaptured_chi_sym2__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym59__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym53__)))),
              "assigning variable inline_prob_uncaptured_chi_sym2__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym53__));
            for (int inline_prob_uncaptured_t_sym5__ = 2; inline_prob_uncaptured_t_sym5__
                 <= lcm_sym53__; ++inline_prob_uncaptured_t_sym5__) {
              int inline_prob_uncaptured_t_curr_sym3__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym4__ =
                std::numeric_limits<int>::min();
              lcm_sym52__ = (n_occasions - inline_prob_uncaptured_t_sym5__);
              lcm_sym58__ = (lcm_sym52__ + 1);
              current_statement__ = 24;
              stan::model::assign(inline_prob_uncaptured_chi_sym2__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym52__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni((lcm_sym58__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                    "inline_prob_uncaptured_chi_sym2__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym58__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym52__)))),
                "assigning variable inline_prob_uncaptured_chi_sym2__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym52__));
            }
          }
          for (int inline_prob_uncaptured_i_sym6__ = 2; inline_prob_uncaptured_i_sym6__
               <= nind; ++inline_prob_uncaptured_i_sym6__) {
            current_statement__ = 21;
            stan::model::assign(inline_prob_uncaptured_chi_sym2__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym2__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
              stan::model::index_uni(n_occasions));
            current_statement__ = 26;
            if (lcm_sym47__) {
              int inline_prob_uncaptured_t_curr_sym3__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym4__ =
                std::numeric_limits<int>::min();
              lcm_sym59__ = (lcm_sym53__ + 1);
              current_statement__ = 24;
              stan::model::assign(inline_prob_uncaptured_chi_sym2__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                     stan::model::index_uni(lcm_sym53__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                    stan::model::index_uni((lcm_sym59__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                    "inline_prob_uncaptured_chi_sym2__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                    stan::model::index_uni(lcm_sym59__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                    stan::model::index_uni(lcm_sym53__)))),
                "assigning variable inline_prob_uncaptured_chi_sym2__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                stan::model::index_uni(lcm_sym53__));
              for (int inline_prob_uncaptured_t_sym5__ = 2; inline_prob_uncaptured_t_sym5__
                   <= lcm_sym53__; ++inline_prob_uncaptured_t_sym5__) {
                int inline_prob_uncaptured_t_curr_sym3__ =
                  std::numeric_limits<int>::min();
                int inline_prob_uncaptured_t_next_sym4__ =
                  std::numeric_limits<int>::min();
                lcm_sym52__ = (n_occasions -
                  inline_prob_uncaptured_t_sym5__);
                lcm_sym58__ = (lcm_sym52__ + 1);
                current_statement__ = 24;
                stan::model::assign(inline_prob_uncaptured_chi_sym2__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                       stan::model::index_uni(lcm_sym52__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                      stan::model::index_uni((lcm_sym58__ - 1))))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                      "inline_prob_uncaptured_chi_sym2__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                      stan::model::index_uni(lcm_sym58__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                      stan::model::index_uni(lcm_sym52__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym2__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                  stan::model::index_uni(lcm_sym52__));
              }
            }
          }
        }
        current_statement__ = 29;
        stan::model::assign(inline_prob_uncaptured_return_sym1__,
          inline_prob_uncaptured_chi_sym2__,
          "assigning variable inline_prob_uncaptured_return_sym1__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym1__,
        "assigning variable chi");
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 6;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 6;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym1__, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym1__, 1);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(inline_prob_uncaptured_return_sym1__);
        out__.write(lcm_sym68__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      double sigma2 = std::numeric_limits<double>::quiet_NaN();
      lcm_sym69__ = stan::math::square(sigma);
      sigma2 = lcm_sym69__;
      current_statement__ = 9;
      stan::math::check_greater_or_equal(function__, "sigma2", lcm_sym69__, 0);
      out__.write(lcm_sym69__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__,-1,1> epsilon;
      current_statement__ = 3;
      stan::model::assign(epsilon,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(nind),
        "assigning variable epsilon");
      out__.write(epsilon);
      local_scalar_t__ sigma;
      current_statement__ = 4;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 5, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mean_phi",
        "double", std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "mean_p", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "epsilon",
        "double", std::vector<size_t>{static_cast<size_t>(nind)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "sigma", "double",
        std::vector<size_t>{});
      double lcm_sym45__;
      double lcm_sym44__;
      int lcm_sym43__;
      int lcm_sym42__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = context__.vals_r("mean_phi")[(1 - 1)];
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__,-1,1> epsilon =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nind, DUMMY_VAR__);
      {
        std::vector<double> epsilon_flat__;
        current_statement__ = 3;
        epsilon_flat__ = context__.vals_r("epsilon");
        pos__ = 1;
        if (stan::math::logical_gte(nind, 1)) {
          stan::model::assign(epsilon,
            stan::model::rvalue(epsilon_flat__, "epsilon_flat__",
              stan::model::index_uni(1)), "assigning variable epsilon",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= nind; ++sym1__) {
            stan::model::assign(epsilon, epsilon_flat__[(pos__ - 1)],
              "assigning variable epsilon", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(epsilon);
      local_scalar_t__ sigma;
      current_statement__ = 4;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      out__.write_free_lub(0, 5, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mean_phi", "mean_p", "epsilon",
                "sigma"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"phi", "p", "chi", "mu"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string> temp{"sigma2"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(nind)},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(nind),
               static_cast<size_t>(n_occ_minus_1)},
             std::vector<size_t>{static_cast<size_t>(nind),
               static_cast<size_t>(n_occ_minus_1)},
             std::vector<size_t>{static_cast<size_t>(nind),
               static_cast<size_t>(n_occasions)}, std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>> temp{std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
      param_names__.emplace_back(std::string() + "epsilon" + '.' +
        std::to_string(sym169__));
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym169__ = 1; sym169__ <= n_occ_minus_1; ++sym169__) {
        for (int sym170__ = 1; sym170__ <= nind; ++sym170__) {
          param_names__.emplace_back(std::string() + "phi" + '.' +
            std::to_string(sym170__) + '.' + std::to_string(sym169__));
        }
      }
      for (int sym169__ = 1; sym169__ <= n_occ_minus_1; ++sym169__) {
        for (int sym170__ = 1; sym170__ <= nind; ++sym170__) {
          param_names__.emplace_back(std::string() + "p" + '.' +
            std::to_string(sym170__) + '.' + std::to_string(sym169__));
        }
      }
      for (int sym169__ = 1; sym169__ <= n_occasions; ++sym169__) {
        for (int sym170__ = 1; sym170__ <= nind; ++sym170__) {
          param_names__.emplace_back(std::string() + "chi" + '.' +
            std::to_string(sym170__) + '.' + std::to_string(sym169__));
        }
      }
      param_names__.emplace_back(std::string() + "mu");
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym169__ = 1; sym169__ <= nind; ++sym169__) {
      param_names__.emplace_back(std::string() + "epsilon" + '.' +
        std::to_string(sym169__));
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym169__ = 1; sym169__ <= n_occ_minus_1; ++sym169__) {
        for (int sym170__ = 1; sym170__ <= nind; ++sym170__) {
          param_names__.emplace_back(std::string() + "phi" + '.' +
            std::to_string(sym170__) + '.' + std::to_string(sym169__));
        }
      }
      for (int sym169__ = 1; sym169__ <= n_occ_minus_1; ++sym169__) {
        for (int sym170__ = 1; sym170__ <= nind; ++sym170__) {
          param_names__.emplace_back(std::string() + "p" + '.' +
            std::to_string(sym170__) + '.' + std::to_string(sym169__));
        }
      }
      for (int sym169__ = 1; sym169__ <= n_occasions; ++sym169__) {
        for (int sym170__ = 1; sym170__ <= nind; ++sym170__) {
          param_names__.emplace_back(std::string() + "chi" + '.' +
            std::to_string(sym170__) + '.' + std::to_string(sym169__));
        }
      }
      param_names__.emplace_back(std::string() + "mu");
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nind) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nind) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((1 + 1) + nind) + 1);
    const size_t num_transformed = emit_transformed_parameters * (((((nind *
      n_occ_minus_1) + (nind * n_occ_minus_1)) + (nind * n_occasions)) + 1));
    const size_t num_gen_quantities = emit_generated_quantities * (1);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((1 + 1) + nind) + 1);
    const size_t num_transformed = emit_transformed_parameters * (((((nind *
      n_occ_minus_1) + (nind * n_occ_minus_1)) + (nind * n_occasions)) + 1));
    const size_t num_gen_quantities = emit_generated_quantities * (1);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = expr_prop_fail5_model_namespace::expr_prop_fail5_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail5_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail6.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail6_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 147> locations_array__ =
  {" (found before start of program)",
  " (in 'expr-prop-fail6.stan', line 160, column 2 to column 34)",
  " (in 'expr-prop-fail6.stan', line 161, column 2 to column 32)",
  " (in 'expr-prop-fail6.stan', line 162, column 2 to column 29)",
  " (in 'expr-prop-fail6.stan', line 163, column 2 to column 36)",
  " (in 'expr-prop-fail6.stan', line 164, column 2 to column 20)",
  " (in 'expr-prop-fail6.stan', line 165, column 2 to column 31)",
  " (in 'expr-prop-fail6.stan', line 170, column 2 to column 51)",
  " (in 'expr-prop-fail6.stan', line 171, column 2 to column 45)",
  " (in 'expr-prop-fail6.stan', line 172, column 2 to column 25)",
  " (in 'expr-prop-fail6.stan', line 173, column 2 to column 43)",
  " (in 'expr-prop-fail6.stan', line 174, column 2 to column 47)",
  " (in 'expr-prop-fail6.stan', line 212, column 2 to column 23)",
  " (in 'expr-prop-fail6.stan', line 213, column 2 to column 22)",
  " (in 'expr-prop-fail6.stan', line 214, column 2 to column 36)",
  " (in 'expr-prop-fail6.stan', line 215, column 2 to column 36)",
  " (in 'expr-prop-fail6.stan', line 216, column 2 to column 48)",
  " (in 'expr-prop-fail6.stan', line 179, column 4 to column 51)",
  " (in 'expr-prop-fail6.stan', line 187, column 4 to column 22)",
  " (in 'expr-prop-fail6.stan', line 189, column 4 to column 17)",
  " (in 'expr-prop-fail6.stan', line 191, column 6 to column 35)",
  " (in 'expr-prop-fail6.stan', line 192, column 6 to column 27)",
  " (in 'expr-prop-fail6.stan', line 190, column 37 to line 193, column 5)",
  " (in 'expr-prop-fail6.stan', line 190, column 4 to line 193, column 5)",
  " (in 'expr-prop-fail6.stan', line 194, column 4 to column 26)",
  " (in 'expr-prop-fail6.stan', line 186, column 2 to line 195, column 3)",
  " (in 'expr-prop-fail6.stan', line 49, column 4 to column 24)",
  " (in 'expr-prop-fail6.stan', line 50, column 4 to column 30)",
  " (in 'expr-prop-fail6.stan', line 51, column 11 to column 16)",
  " (in 'expr-prop-fail6.stan', line 51, column 18 to column 29)",
  " (in 'expr-prop-fail6.stan', line 51, column 4 to column 35)",
  " (in 'expr-prop-fail6.stan', line 54, column 6 to column 32)",
  " (in 'expr-prop-fail6.stan', line 56, column 8 to column 37)",
  " (in 'expr-prop-fail6.stan', line 57, column 8 to column 32)",
  " (in 'expr-prop-fail6.stan', line 59, column 8 to line 61, column 44)",
  " (in 'expr-prop-fail6.stan', line 55, column 39 to line 62, column 7)",
  " (in 'expr-prop-fail6.stan', line 55, column 6 to line 62, column 7)",
  " (in 'expr-prop-fail6.stan', line 53, column 25 to line 63, column 5)",
  " (in 'expr-prop-fail6.stan', line 53, column 4 to line 63, column 5)",
  " (in 'expr-prop-fail6.stan', line 64, column 4 to column 15)",
  " (in 'expr-prop-fail6.stan', line 222, column 4 to column 14)",
  " (in 'expr-prop-fail6.stan', line 232, column 6 to column 44)",
  " (in 'expr-prop-fail6.stan', line 230, column 11 to line 233, column 5)",
  " (in 'expr-prop-fail6.stan', line 225, column 6 to column 37)",
  " (in 'expr-prop-fail6.stan', line 228, column 8 to column 73)",
  " (in 'expr-prop-fail6.stan', line 227, column 8 to column 34)",
  " (in 'expr-prop-fail6.stan', line 226, column 33 to line 229, column 7)",
  " (in 'expr-prop-fail6.stan', line 226, column 6 to line 229, column 7)",
  " (in 'expr-prop-fail6.stan', line 223, column 28 to line 230, column 5)",
  " (in 'expr-prop-fail6.stan', line 223, column 4 to line 233, column 5)",
  " (in 'expr-prop-fail6.stan', line 221, column 19 to line 234, column 3)",
  " (in 'expr-prop-fail6.stan', line 238, column 10 to column 11)",
  " (in 'expr-prop-fail6.stan', line 238, column 13 to column 24)",
  " (in 'expr-prop-fail6.stan', line 238, column 4 to column 69)",
  " (in 'expr-prop-fail6.stan', line 239, column 10 to column 11)",
  " (in 'expr-prop-fail6.stan', line 239, column 4 to column 22)",
  " (in 'expr-prop-fail6.stan', line 240, column 10 to column 11)",
  " (in 'expr-prop-fail6.stan', line 240, column 4 to column 24)",
  " (in 'expr-prop-fail6.stan', line 243, column 6 to column 39)",
  " (in 'expr-prop-fail6.stan', line 17, column 8 to column 17)",
  " (in 'expr-prop-fail6.stan', line 16, column 6 to line 17, column 17)",
  " (in 'expr-prop-fail6.stan', line 14, column 37 to line 19, column 3)",
  " (in 'expr-prop-fail6.stan', line 246, column 8 to column 26)",
  " (in 'expr-prop-fail6.stan', line 245, column 6 to line 246, column 26)",
  " (in 'expr-prop-fail6.stan', line 242, column 21 to line 247, column 5)",
  " (in 'expr-prop-fail6.stan', line 242, column 4 to line 247, column 5)",
  " (in 'expr-prop-fail6.stan', line 249, column 6 to column 28)",
  " (in 'expr-prop-fail6.stan', line 250, column 6 to column 34)",
  " (in 'expr-prop-fail6.stan', line 248, column 31 to line 251, column 5)",
  " (in 'expr-prop-fail6.stan', line 248, column 4 to line 251, column 5)",
  " (in 'expr-prop-fail6.stan', line 253, column 6 to column 26)",
  " (in 'expr-prop-fail6.stan', line 254, column 6 to column 32)",
  " (in 'expr-prop-fail6.stan', line 252, column 21 to line 255, column 5)",
  " (in 'expr-prop-fail6.stan', line 252, column 4 to line 255, column 5)",
  " (in 'expr-prop-fail6.stan', line 256, column 4 to column 25)",
  " (in 'expr-prop-fail6.stan', line 237, column 2 to line 257, column 3)",
  " (in 'expr-prop-fail6.stan', line 178, column 2 to line 179, column 51)",
  " (in 'expr-prop-fail6.stan', line 205, column 2 to column 29)",
  " (in 'expr-prop-fail6.stan', line 206, column 2 to column 21)",
  " (in 'expr-prop-fail6.stan', line 82, column 4 to column 27)",
  " (in 'expr-prop-fail6.stan', line 83, column 4 to column 33)",
  " (in 'expr-prop-fail6.stan', line 84, column 11 to column 22)",
  " (in 'expr-prop-fail6.stan', line 84, column 4 to column 39)",
  " (in 'expr-prop-fail6.stan', line 87, column 13 to column 24)",
  " (in 'expr-prop-fail6.stan', line 87, column 6 to column 43)",
  " (in 'expr-prop-fail6.stan', line 127, column 8 to column 35)",
  " (in 'expr-prop-fail6.stan', line 130, column 8 to line 131, column 78)",
  " (in 'expr-prop-fail6.stan', line 134, column 10 to line 137, column 50)",
  " (in 'expr-prop-fail6.stan', line 133, column 8 to line 137, column 50)",
  " (in 'expr-prop-fail6.stan', line 139, column 8 to column 54)",
  " (in 'expr-prop-fail6.stan', line 140, column 8 to column 34)",
  " (in 'expr-prop-fail6.stan', line 125, column 13 to line 141, column 7)",
  " (in 'expr-prop-fail6.stan', line 92, column 8 to column 27)",
  " (in 'expr-prop-fail6.stan', line 99, column 17 to column 25)",
  " (in 'expr-prop-fail6.stan', line 99, column 10 to column 30)",
  " (in 'expr-prop-fail6.stan', line 108, column 12 to line 112, column 57)",
  " (in 'expr-prop-fail6.stan', line 107, column 10 to line 112, column 57)",
  " (in 'expr-prop-fail6.stan', line 113, column 10 to line 115, column 62)",
  " (in 'expr-prop-fail6.stan', line 116, column 10 to column 36)",
  " (in 'expr-prop-fail6.stan', line 97, column 15 to line 117, column 9)",
  " (in 'expr-prop-fail6.stan', line 96, column 10 to column 41)",
  " (in 'expr-prop-fail6.stan', line 95, column 27 to line 97, column 9)",
  " (in 'expr-prop-fail6.stan', line 95, column 8 to line 117, column 9)",
  " (in 'expr-prop-fail6.stan', line 120, column 10 to column 39)",
  " (in 'expr-prop-fail6.stan', line 121, column 10 to column 39)",
  " (in 'expr-prop-fail6.stan', line 119, column 44 to line 122, column 9)",
  " (in 'expr-prop-fail6.stan', line 124, column 8 to column 39)",
  " (in 'expr-prop-fail6.stan', line 89, column 20 to line 125, column 7)",
  " (in 'expr-prop-fail6.stan', line 86, column 25 to line 142, column 5)",
  " (in 'expr-prop-fail6.stan', line 86, column 4 to line 142, column 5)",
  " (in 'expr-prop-fail6.stan', line 209, column 2 to column 52)",
  " (in 'expr-prop-fail6.stan', line 146, column 2 to column 17)",
  " (in 'expr-prop-fail6.stan', line 147, column 2 to column 27)",
  " (in 'expr-prop-fail6.stan', line 148, column 8 to column 9)",
  " (in 'expr-prop-fail6.stan', line 148, column 11 to column 22)",
  " (in 'expr-prop-fail6.stan', line 148, column 2 to column 48)",
  " (in 'expr-prop-fail6.stan', line 151, column 8 to column 9)",
  " (in 'expr-prop-fail6.stan', line 151, column 2 to column 49)",
  " (in 'expr-prop-fail6.stan', line 152, column 8 to column 9)",
  " (in 'expr-prop-fail6.stan', line 152, column 2 to column 48)",
  " (in 'expr-prop-fail6.stan', line 155, column 4 to column 35)",
  " (in 'expr-prop-fail6.stan', line 154, column 2 to line 155, column 35)",
  " (in 'expr-prop-fail6.stan', line 157, column 4 to column 33)",
  " (in 'expr-prop-fail6.stan', line 156, column 2 to line 157, column 33)",
  " (in 'expr-prop-fail6.stan', line 163, column 18 to column 29)",
  " (in 'expr-prop-fail6.stan', line 164, column 9 to column 10)",
  " (in 'expr-prop-fail6.stan', line 170, column 27 to column 28)",
  " (in 'expr-prop-fail6.stan', line 170, column 30 to column 45)",
  " (in 'expr-prop-fail6.stan', line 171, column 27 to column 28)",
  " (in 'expr-prop-fail6.stan', line 171, column 30 to column 41)",
  " (in 'expr-prop-fail6.stan', line 172, column 10 to column 21)",
  " (in 'expr-prop-fail6.stan', line 173, column 27 to column 38)",
  " (in 'expr-prop-fail6.stan', line 174, column 27 to column 28)",
  " (in 'expr-prop-fail6.stan', line 174, column 30 to column 41)",
  " (in 'expr-prop-fail6.stan', line 214, column 8 to column 19)",
  " (in 'expr-prop-fail6.stan', line 215, column 8 to column 19)",
  " (in 'expr-prop-fail6.stan', line 216, column 8 to column 9)",
  " (in 'expr-prop-fail6.stan', line 216, column 11 to column 22)",
  " (in 'expr-prop-fail6.stan', line 18, column 4 to column 13)",
  " (in 'expr-prop-fail6.stan', line 30, column 6 to column 32)",
  " (in 'expr-prop-fail6.stan', line 33, column 8 to column 17)",
  " (in 'expr-prop-fail6.stan', line 32, column 6 to line 33, column 17)",
  " (in 'expr-prop-fail6.stan', line 29, column 39 to line 34, column 5)",
  " (in 'expr-prop-fail6.stan', line 35, column 4 to column 13)",
  " (in 'expr-prop-fail6.stan', line 28, column 36 to line 36, column 3)",
  " (in 'expr-prop-fail6.stan', line 48, column 47 to line 65, column 3)",
  " (in 'expr-prop-fail6.stan', line 81, column 74 to line 143, column 3)"};
int first_capture(const std::vector<int>& y_i, std::ostream* pstream__);
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,-1>
prob_uncaptured(const T0__& p_arg__, const T1__& phi_arg__, std::ostream*
                pstream__);
template <bool propto__, typename T3__, typename T4__, typename T5__,
          typename T6__, typename T7__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>,
                              stan::is_eigen_matrix_dynamic<T4__>,
                              stan::is_vt_not_complex<T4__>,
                              stan::is_stan_scalar<T5__>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_eigen_matrix_dynamic<T7__>,
                              stan::is_vt_not_complex<T7__>>* = nullptr>
void
js_super_lp(const std::vector<std::vector<int>>& y, const std::vector<int>&
            first, const std::vector<int>& last, const T3__& p_arg__,
            const T4__& phi_arg__, const T5__& psi, const T6__& nu_arg__,
            const T7__& chi_arg__, T_lp__& lp__, T_lp_accum__& lp_accum__,
            std::ostream* pstream__);
int first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym51__;
    int lcm_sym50__;
    int lcm_sym49__;
    int lcm_sym48__;
    {
      lcm_sym49__ = stan::math::size(y_i);
      if (stan::math::logical_gte(lcm_sym49__, 1)) {
        current_statement__ = 60;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(1))) {
          current_statement__ = 59;
          return 1;
        }
        for (int k = 2; k <= lcm_sym49__; ++k) {
          current_statement__ = 60;
          if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
            current_statement__ = 59;
            return k;
          }
        }
      }
      current_statement__ = 138;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym57__;
    int lcm_sym56__;
    int lcm_sym55__;
    int lcm_sym54__;
    int lcm_sym53__;
    int lcm_sym52__;
    {
      lcm_sym55__ = (stan::math::size(y_i) - 1);
      if (stan::math::logical_gte(lcm_sym55__, 0)) {
        int k = std::numeric_limits<int>::min();
        lcm_sym54__ = (stan::math::size(y_i) - 0);
        current_statement__ = 141;
        if (y_i[(lcm_sym54__ - 1)]) {
          current_statement__ = 140;
          return lcm_sym54__;
        }
        for (int k_rev = 1; k_rev <= lcm_sym55__; ++k_rev) {
          int k = std::numeric_limits<int>::min();
          lcm_sym53__ = (stan::math::size(y_i) - k_rev);
          current_statement__ = 141;
          if (y_i[(lcm_sym53__ - 1)]) {
            current_statement__ = 140;
            return lcm_sym53__;
          }
        }
      }
      current_statement__ = 143;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,-1>
prob_uncaptured(const T0__& p_arg__, const T1__& phi_arg__, std::ostream*
                pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& p = stan::math::to_ref(p_arg__);
  const auto& phi = stan::math::to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym69__;
    double lcm_sym68__;
    double lcm_sym67__;
    double lcm_sym66__;
    double lcm_sym65__;
    int lcm_sym64__;
    int lcm_sym63__;
    int lcm_sym62__;
    int lcm_sym61__;
    int lcm_sym60__;
    int lcm_sym59__;
    int lcm_sym58__;
    {
      int n_ind = std::numeric_limits<int>::min();
      lcm_sym69__ = stan::math::rows(p);
      int n_occasions = std::numeric_limits<int>::min();
      lcm_sym64__ = stan::math::cols(p);
      n_occasions = lcm_sym64__;
      current_statement__ = 28;
      stan::math::validate_non_negative_index("chi", "n_ind", lcm_sym69__);
      current_statement__ = 29;
      stan::math::validate_non_negative_index("chi", "n_occasions",
        lcm_sym64__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(lcm_sym69__,
          lcm_sym64__, DUMMY_VAR__);
      current_statement__ = 38;
      if (stan::math::logical_gte(lcm_sym69__, 1)) {
        current_statement__ = 31;
        stan::model::assign(chi, 1.0, "assigning variable chi",
          stan::model::index_uni(1), stan::model::index_uni(lcm_sym64__));
        lcm_sym61__ = (lcm_sym64__ - 1);
        lcm_sym58__ = stan::math::logical_gte(lcm_sym61__, 1);
        if (lcm_sym58__) {
          int t_curr = std::numeric_limits<int>::min();
          int t_next = std::numeric_limits<int>::min();
          lcm_sym63__ = (lcm_sym61__ + 1);
          current_statement__ = 34;
          stan::model::assign(chi,
            stan::math::fma(
              (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                 stan::model::index_uni(lcm_sym61__)) * (1 -
              stan::model::rvalue(p, "p", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym63__)))),
              stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym63__)), (1 -
              stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym61__)))),
            "assigning variable chi", stan::model::index_uni(1),
            stan::model::index_uni(lcm_sym61__));
          for (int t = 2; t <= lcm_sym61__; ++t) {
            int t_curr = std::numeric_limits<int>::min();
            lcm_sym60__ = (lcm_sym64__ - t);
            int t_next = std::numeric_limits<int>::min();
            lcm_sym62__ = (lcm_sym60__ + 1);
            current_statement__ = 34;
            stan::model::assign(chi,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym60__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym62__)))),
                stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym62__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym60__)))),
              "assigning variable chi", stan::model::index_uni(1),
              stan::model::index_uni(lcm_sym60__));
          }
        }
        for (int i = 2; i <= lcm_sym69__; ++i) {
          current_statement__ = 31;
          stan::model::assign(chi, 1.0, "assigning variable chi",
            stan::model::index_uni(i), stan::model::index_uni(lcm_sym64__));
          current_statement__ = 36;
          if (lcm_sym58__) {
            int t_curr = std::numeric_limits<int>::min();
            int t_next = std::numeric_limits<int>::min();
            lcm_sym63__ = (lcm_sym61__ + 1);
            current_statement__ = 34;
            stan::model::assign(chi,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                   stan::model::index_uni(lcm_sym61__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym63__)))),
                stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym63__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym61__)))),
              "assigning variable chi", stan::model::index_uni(i),
              stan::model::index_uni(lcm_sym61__));
            for (int t = 2; t <= lcm_sym61__; ++t) {
              int t_curr = std::numeric_limits<int>::min();
              lcm_sym60__ = (lcm_sym64__ - t);
              int t_next = std::numeric_limits<int>::min();
              lcm_sym62__ = (lcm_sym60__ + 1);
              current_statement__ = 34;
              stan::model::assign(chi,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                     stan::model::index_uni(lcm_sym60__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym62__)))),
                  stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym62__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym60__)))),
                "assigning variable chi", stan::model::index_uni(i),
                stan::model::index_uni(lcm_sym60__));
            }
          }
        }
      }
      current_statement__ = 39;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <bool propto__, typename T3__, typename T4__, typename T5__,
          typename T6__, typename T7__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>,
                              stan::is_eigen_matrix_dynamic<T4__>,
                              stan::is_vt_not_complex<T4__>,
                              stan::is_stan_scalar<T5__>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_eigen_matrix_dynamic<T7__>,
                              stan::is_vt_not_complex<T7__>>*>
void
js_super_lp(const std::vector<std::vector<int>>& y, const std::vector<int>&
            first, const std::vector<int>& last, const T3__& p_arg__,
            const T4__& phi_arg__, const T5__& psi, const T6__& nu_arg__,
            const T7__& chi_arg__, T_lp__& lp__, T_lp_accum__& lp_accum__,
            std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T3__>,
                             stan::base_type_t<T4__>, T5__,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>>;
  int current_statement__ = 0;
  const auto& p = stan::math::to_ref(p_arg__);
  const auto& phi = stan::math::to_ref(phi_arg__);
  const auto& nu = stan::math::to_ref(nu_arg__);
  const auto& chi = stan::math::to_ref(chi_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym120__;
    int lcm_sym119__;
    int lcm_sym118__;
    int lcm_sym117__;
    int lcm_sym116__;
    int lcm_sym115__;
    double lcm_sym114__;
    double lcm_sym113__;
    double lcm_sym112__;
    double lcm_sym111__;
    double lcm_sym110__;
    double lcm_sym109__;
    double lcm_sym108__;
    double lcm_sym107__;
    double lcm_sym106__;
    double lcm_sym105__;
    double lcm_sym104__;
    double lcm_sym103__;
    double lcm_sym102__;
    double lcm_sym101__;
    double lcm_sym100__;
    int lcm_sym99__;
    int lcm_sym98__;
    int lcm_sym97__;
    double lcm_sym96__;
    double lcm_sym95__;
    double lcm_sym94__;
    double lcm_sym93__;
    double lcm_sym92__;
    double lcm_sym91__;
    double lcm_sym90__;
    double lcm_sym89__;
    double lcm_sym88__;
    double lcm_sym87__;
    double lcm_sym86__;
    double lcm_sym85__;
    double lcm_sym84__;
    double lcm_sym83__;
    int lcm_sym82__;
    int lcm_sym81__;
    Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym80__;
    Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym79__;
    Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym78__;
    int lcm_sym77__;
    int lcm_sym76__;
    int lcm_sym75__;
    int lcm_sym74__;
    int lcm_sym73__;
    int lcm_sym72__;
    int lcm_sym71__;
    int lcm_sym70__;
    {
      int n_ind = std::numeric_limits<int>::min();
      lcm_sym119__ = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                       stan::model::index_uni(1));
      int n_occasions = std::numeric_limits<int>::min();
      lcm_sym120__ = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                       stan::model::index_uni(2));
      n_occasions = lcm_sym120__;
      current_statement__ = 81;
      stan::math::validate_non_negative_index("qnu", "n_occasions",
        lcm_sym120__);
      Eigen::Matrix<double,-1,1> qnu =
        Eigen::Matrix<double,-1,1>::Constant(lcm_sym120__,
          std::numeric_limits<double>::quiet_NaN());
      stan::model::assign(lcm_sym78__, stan::math::subtract(1.0, nu),
        "assigning variable lcm_sym78__");
      current_statement__ = 109;
      if (stan::math::logical_gte(lcm_sym119__, 1)) {
        current_statement__ = 83;
        stan::math::validate_non_negative_index("qp", "n_occasions",
          lcm_sym120__);
        Eigen::Matrix<double,-1,1> qp =
          Eigen::Matrix<double,-1,1>::Constant(lcm_sym120__,
            std::numeric_limits<double>::quiet_NaN());
        stan::model::assign(lcm_sym80__,
          stan::math::subtract(1.0,
            stan::math::transpose(
              stan::model::rvalue(p, "p", stan::model::index_uni(1)))),
          "assigning variable lcm_sym80__");
        lcm_sym116__ = stan::model::rvalue(first, "first",
                         stan::model::index_uni(1));
        if (lcm_sym116__) {
          current_statement__ = 92;
          lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1, psi));
          current_statement__ = 102;
          if (stan::math::logical_eq(lcm_sym116__, 1)) {
            current_statement__ = 100;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             (stan::model::rvalue(nu, "nu",
                                stan::model::index_uni(1)) *
                             stan::model::rvalue(p, "p",
                               stan::model::index_uni(1),
                               stan::model::index_uni(1)))));
          } else {
            current_statement__ = 93;
            stan::math::validate_non_negative_index("lp", "first[i]",
              lcm_sym116__);
            Eigen::Matrix<local_scalar_t__,-1,1> lp =
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym116__,
                DUMMY_VAR__);
            lcm_sym82__ = (lcm_sym116__ - 1);
            stan::model::assign(lp,
              (((stan::math::bernoulli_lpmf<false>(1,
                   stan::model::rvalue(nu, "nu", stan::model::index_uni(1)))
              +
              stan::math::bernoulli_lpmf<false>(1,
                stan::math::prod(
                  stan::model::rvalue(lcm_sym80__, "lcm_sym80__",
                    stan::model::index_min_max(1, lcm_sym82__))))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::math::prod(
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_min_max(1, lcm_sym82__))))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym116__)))),
              "assigning variable lp", stan::model::index_uni(1));
            current_statement__ = 96;
            if (stan::math::logical_gte(lcm_sym82__, 2)) {
              current_statement__ = 95;
              stan::model::assign(lp,
                ((((stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym78__, "lcm_sym78__",
                          stan::model::index_min_max(1, 1)))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(nu, "nu", stan::model::index_uni(2))))
                +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(lcm_sym80__, "lcm_sym80__",
                      stan::model::index_min_max(2, lcm_sym82__))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(1),
                      stan::model::index_min_max(2, lcm_sym82__))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym116__)))),
                "assigning variable lp", stan::model::index_uni(2));
              for (int t = 3; t <= lcm_sym82__; ++t) {
                current_statement__ = 95;
                stan::model::assign(lp,
                  ((((stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym78__, "lcm_sym78__",
                            stan::model::index_min_max(1, (t - 1))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(nu, "nu", stan::model::index_uni(t))))
                  +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym80__, "lcm_sym80__",
                        stan::model::index_min_max(t, lcm_sym82__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(phi, "phi",
                        stan::model::index_uni(1),
                        stan::model::index_min_max(t, lcm_sym82__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(p, "p", stan::model::index_uni(1),
                      stan::model::index_uni(lcm_sym116__)))),
                  "assigning variable lp", stan::model::index_uni(t));
              }
            }
            current_statement__ = 97;
            stan::model::assign(lp,
              ((stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(lcm_sym78__, "lcm_sym78__",
                      stan::model::index_min_max(1, lcm_sym82__)))) +
              stan::math::bernoulli_lpmf<false>(1, nu[(lcm_sym116__ - 1)])) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym116__)))),
              "assigning variable lp", stan::model::index_uni(lcm_sym116__));
            current_statement__ = 98;
            lp_accum__.add(stan::math::log_sum_exp(lp));
          }
          lcm_sym118__ = stan::model::rvalue(last, "last",
                           stan::model::index_uni(1));
          if (stan::math::logical_gte(lcm_sym118__, (lcm_sym116__ + 1))) {
            current_statement__ = 103;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             stan::model::rvalue(phi, "phi",
                               stan::model::index_uni(1),
                               stan::model::index_uni(((lcm_sym116__ + 1) -
                                 1)))));
            lcm_sym98__ = ((lcm_sym116__ + 1) + 1);
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                             stan::model::rvalue(y, "y",
                               stan::model::index_uni(1),
                               stan::model::index_uni((lcm_sym116__ + 1))),
                             stan::model::rvalue(p, "p",
                               stan::model::index_uni(1),
                               stan::model::index_uni((lcm_sym116__ + 1)))));
            for (int t = lcm_sym98__; t <= lcm_sym118__; ++t) {
              current_statement__ = 103;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((t - 1)))));
              current_statement__ = 104;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(t)),
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(t))));
            }
          }
          current_statement__ = 106;
          lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                           stan::model::rvalue(chi, "chi",
                             stan::model::index_uni(1),
                             stan::model::index_uni(lcm_sym118__))));
        } else {
          lcm_sym99__ = (lcm_sym120__ + 1);
          stan::math::validate_non_negative_index("lp", "n_occasions + 1",
            lcm_sym99__);
          Eigen::Matrix<local_scalar_t__,-1,1> lp =
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym99__,
              DUMMY_VAR__);
          current_statement__ = 86;
          stan::model::assign(lp,
            (((stan::math::bernoulli_lpmf<false>(1, psi) +
            stan::math::bernoulli_lpmf<false>(1,
              stan::model::rvalue(nu, "nu", stan::model::index_uni(1)))) +
            stan::math::bernoulli_lpmf<false>(0,
              stan::model::rvalue(p, "p", stan::model::index_uni(1),
                stan::model::index_uni(1)))) +
            stan::math::bernoulli_lpmf<false>(1,
              stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                stan::model::index_uni(1)))), "assigning variable lp",
            stan::model::index_uni(1));
          current_statement__ = 88;
          if (stan::math::logical_gte(lcm_sym120__, 2)) {
            current_statement__ = 87;
            stan::model::assign(lp,
              ((((stan::math::bernoulli_lpmf<false>(1, psi) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::math::prod(
                  stan::model::rvalue(lcm_sym78__, "lcm_sym78__",
                    stan::model::index_min_max(1, 1))))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(nu, "nu", stan::model::index_uni(2)))) +
              stan::math::bernoulli_lpmf<false>(0,
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni(2)))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                  stan::model::index_uni(2)))), "assigning variable lp",
              stan::model::index_uni(2));
            for (int t = 3; t <= lcm_sym120__; ++t) {
              current_statement__ = 87;
              stan::model::assign(lp,
                ((((stan::math::bernoulli_lpmf<false>(1, psi) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(lcm_sym78__, "lcm_sym78__",
                      stan::model::index_min_max(1, (t - 1)))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(nu, "nu", stan::model::index_uni(t))))
                +
                stan::math::bernoulli_lpmf<false>(0,
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni(t)))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                    stan::model::index_uni(t)))), "assigning variable lp",
                stan::model::index_uni(t));
            }
          }
          current_statement__ = 89;
          stan::model::assign(lp, stan::math::bernoulli_lpmf<false>(0, psi),
            "assigning variable lp", stan::model::index_uni(lcm_sym99__));
          current_statement__ = 90;
          lp_accum__.add(stan::math::log_sum_exp(lp));
        }
        for (int i = 2; i <= lcm_sym119__; ++i) {
          current_statement__ = 83;
          stan::math::validate_non_negative_index("qp", "n_occasions",
            lcm_sym120__);
          Eigen::Matrix<double,-1,1> qp =
            Eigen::Matrix<double,-1,1>::Constant(lcm_sym120__,
              std::numeric_limits<double>::quiet_NaN());
          stan::model::assign(lcm_sym79__,
            stan::math::subtract(1.0,
              stan::math::transpose(
                stan::model::rvalue(p, "p", stan::model::index_uni(i)))),
            "assigning variable lcm_sym79__");
          lcm_sym115__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(i));
          if (lcm_sym115__) {
            current_statement__ = 92;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1, psi));
            current_statement__ = 102;
            if (stan::math::logical_eq(lcm_sym115__, 1)) {
              current_statement__ = 100;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               (stan::model::rvalue(nu, "nu",
                                  stan::model::index_uni(1)) *
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(1)))));
            } else {
              current_statement__ = 93;
              stan::math::validate_non_negative_index("lp", "first[i]",
                lcm_sym115__);
              Eigen::Matrix<local_scalar_t__,-1,1> lp =
                Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym115__,
                  DUMMY_VAR__);
              lcm_sym81__ = (lcm_sym115__ - 1);
              stan::model::assign(lp,
                (((stan::math::bernoulli_lpmf<false>(1,
                     stan::model::rvalue(nu, "nu", stan::model::index_uni(1)))
                +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(lcm_sym79__, "lcm_sym79__",
                      stan::model::index_min_max(1, lcm_sym81__))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(i),
                      stan::model::index_min_max(1, lcm_sym81__))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(p, "p", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym115__)))),
                "assigning variable lp", stan::model::index_uni(1));
              current_statement__ = 96;
              if (stan::math::logical_gte(lcm_sym81__, 2)) {
                current_statement__ = 95;
                stan::model::assign(lp,
                  ((((stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym78__, "lcm_sym78__",
                            stan::model::index_min_max(1, 1)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(nu, "nu", stan::model::index_uni(2))))
                  +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym79__, "lcm_sym79__",
                        stan::model::index_min_max(2, lcm_sym81__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(phi, "phi",
                        stan::model::index_uni(i),
                        stan::model::index_min_max(2, lcm_sym81__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(p, "p", stan::model::index_uni(i),
                      stan::model::index_uni(lcm_sym115__)))),
                  "assigning variable lp", stan::model::index_uni(2));
                for (int t = 3; t <= lcm_sym81__; ++t) {
                  current_statement__ = 95;
                  stan::model::assign(lp,
                    ((((stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(lcm_sym78__, "lcm_sym78__",
                              stan::model::index_min_max(1, (t - 1))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(nu, "nu", stan::model::index_uni(t))))
                    +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym79__, "lcm_sym79__",
                          stan::model::index_min_max(t, lcm_sym81__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(phi, "phi",
                          stan::model::index_uni(i),
                          stan::model::index_min_max(t, lcm_sym81__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(p, "p", stan::model::index_uni(i),
                        stan::model::index_uni(lcm_sym115__)))),
                    "assigning variable lp", stan::model::index_uni(t));
                }
              }
              current_statement__ = 97;
              stan::model::assign(lp,
                ((stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym78__, "lcm_sym78__",
                        stan::model::index_min_max(1, lcm_sym81__)))) +
                stan::math::bernoulli_lpmf<false>(1, nu[(lcm_sym115__ - 1)]))
                +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(p, "p", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym115__)))),
                "assigning variable lp", stan::model::index_uni(lcm_sym115__));
              current_statement__ = 98;
              lp_accum__.add(stan::math::log_sum_exp(lp));
            }
            lcm_sym117__ = stan::model::rvalue(last, "last",
                             stan::model::index_uni(i));
            if (stan::math::logical_gte(lcm_sym117__, (lcm_sym115__ + 1))) {
              current_statement__ = 103;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(((lcm_sym115__ + 1) -
                                   1)))));
              lcm_sym97__ = ((lcm_sym115__ + 1) + 1);
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni((lcm_sym115__ + 1))),
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni((lcm_sym115__ + 1)))));
              for (int t = lcm_sym97__; t <= lcm_sym117__; ++t) {
                current_statement__ = 103;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((t - 1)))));
                current_statement__ = 104;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(t)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(t))));
              }
            }
            current_statement__ = 106;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             stan::model::rvalue(chi, "chi",
                               stan::model::index_uni(i),
                               stan::model::index_uni(lcm_sym117__))));
          } else {
            lcm_sym99__ = (lcm_sym120__ + 1);
            stan::math::validate_non_negative_index("lp", "n_occasions + 1",
              lcm_sym99__);
            Eigen::Matrix<local_scalar_t__,-1,1> lp =
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym99__,
                DUMMY_VAR__);
            current_statement__ = 86;
            stan::model::assign(lp,
              (((stan::math::bernoulli_lpmf<false>(1, psi) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(nu, "nu", stan::model::index_uni(1)))) +
              stan::math::bernoulli_lpmf<false>(0,
                stan::model::rvalue(p, "p", stan::model::index_uni(i),
                  stan::model::index_uni(1)))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                  stan::model::index_uni(1)))), "assigning variable lp",
              stan::model::index_uni(1));
            current_statement__ = 88;
            if (stan::math::logical_gte(lcm_sym120__, 2)) {
              current_statement__ = 87;
              stan::model::assign(lp,
                ((((stan::math::bernoulli_lpmf<false>(1, psi) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(lcm_sym78__, "lcm_sym78__",
                      stan::model::index_min_max(1, 1))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(nu, "nu", stan::model::index_uni(2))))
                +
                stan::math::bernoulli_lpmf<false>(0,
                  stan::model::rvalue(p, "p", stan::model::index_uni(i),
                    stan::model::index_uni(2)))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                    stan::model::index_uni(2)))), "assigning variable lp",
                stan::model::index_uni(2));
              for (int t = 3; t <= lcm_sym120__; ++t) {
                current_statement__ = 87;
                stan::model::assign(lp,
                  ((((stan::math::bernoulli_lpmf<false>(1, psi) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym78__, "lcm_sym78__",
                        stan::model::index_min_max(1, (t - 1)))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(nu, "nu", stan::model::index_uni(t))))
                  +
                  stan::math::bernoulli_lpmf<false>(0,
                    stan::model::rvalue(p, "p", stan::model::index_uni(i),
                      stan::model::index_uni(t)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(chi, "chi",
                      stan::model::index_uni(i), stan::model::index_uni(t)))),
                  "assigning variable lp", stan::model::index_uni(t));
              }
            }
            current_statement__ = 89;
            stan::model::assign(lp,
              stan::math::bernoulli_lpmf<false>(0, psi),
              "assigning variable lp", stan::model::index_uni(lcm_sym99__));
            current_statement__ = 90;
            lp_accum__.add(stan::math::log_sum_exp(lp));
          }
        }
      }
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class expr_prop_fail6_model final : public model_base_crtp<expr_prop_fail6_model> {
 private:
  int lcm_sym346__;
  int lcm_sym345__;
  int lcm_sym344__;
  int lcm_sym343__;
  int lcm_sym342__;
  int lcm_sym341__;
  int lcm_sym340__;
  int lcm_sym339__;
  int lcm_sym338__;
  int lcm_sym337__;
  int M;
  int n_occasions;
  std::vector<std::vector<int>> y;
  std::vector<int> first;
  std::vector<int> last;
  int phi_2dim__;
 public:
  ~expr_prop_fail6_model() {}
  expr_prop_fail6_model(stan::io::var_context& context__, unsigned int
                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "expr_prop_fail6_model_namespace::expr_prop_fail6_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 111;
      context__.validate_dims("data initialization", "M", "int",
        std::vector<size_t>{});
      M = std::numeric_limits<int>::min();
      current_statement__ = 111;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 111;
      stan::math::check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 112;
      context__.validate_dims("data initialization", "n_occasions", "int",
        std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      current_statement__ = 112;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 112;
      stan::math::check_greater_or_equal(function__, "n_occasions",
        n_occasions, 0);
      current_statement__ = 113;
      stan::math::validate_non_negative_index("y", "M", M);
      current_statement__ = 114;
      stan::math::validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 115;
      context__.validate_dims("data initialization", "y", "int",
        std::vector<size_t>{static_cast<size_t>(M),
          static_cast<size_t>(n_occasions)});
      y = std::vector<std::vector<int>>(M,
            std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      {
        std::vector<int> y_flat__;
        current_statement__ = 115;
        y_flat__ = context__.vals_i("y");
        pos__ = 1;
        if (stan::math::logical_gte(n_occasions, 1)) {
          lcm_sym337__ = stan::math::logical_gte(M, 1);
          if (lcm_sym337__) {
            stan::model::assign(y,
              stan::model::rvalue(y_flat__, "y_flat__",
                stan::model::index_uni(1)), "assigning variable y",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
            if (lcm_sym337__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
                stan::model::assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        } else {
          lcm_sym337__ = stan::math::logical_gte(M, 1);
        }
      }
      current_statement__ = 115;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 115;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 116;
      stan::math::validate_non_negative_index("first", "M", M);
      current_statement__ = 117;
      first = std::vector<int>(M, std::numeric_limits<int>::min());
      current_statement__ = 118;
      stan::math::validate_non_negative_index("last", "M", M);
      current_statement__ = 119;
      last = std::vector<int>(M, std::numeric_limits<int>::min());
      current_statement__ = 121;
      if (lcm_sym337__) {
        current_statement__ = 120;
        stan::model::assign(first,
          first_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(1)), pstream__),
          "assigning variable first", stan::model::index_uni(1));
        for (int i = 2; i <= M; ++i) {
          current_statement__ = 120;
          stan::model::assign(first,
            first_capture(
              stan::model::rvalue(y, "y", stan::model::index_uni(i)),
              pstream__), "assigning variable first",
            stan::model::index_uni(i));
        }
      }
      current_statement__ = 123;
      if (lcm_sym337__) {
        current_statement__ = 122;
        stan::model::assign(last,
          last_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(1)), pstream__),
          "assigning variable last", stan::model::index_uni(1));
        for (int i = 2; i <= M; ++i) {
          current_statement__ = 122;
          stan::model::assign(last,
            last_capture(
              stan::model::rvalue(y, "y", stan::model::index_uni(i)),
              pstream__), "assigning variable last",
            stan::model::index_uni(i));
        }
      }
      current_statement__ = 117;
      stan::math::check_greater_or_equal(function__, "first", first, 0);
      current_statement__ = 117;
      stan::math::check_less_or_equal(function__, "first", first, n_occasions);
      current_statement__ = 119;
      stan::math::check_greater_or_equal(function__, "last", last, 0);
      current_statement__ = 119;
      stan::math::check_less_or_equal(function__, "last", last, n_occasions);
      current_statement__ = 124;
      stan::math::validate_non_negative_index("beta", "n_occasions",
        n_occasions);
      current_statement__ = 125;
      stan::math::validate_non_negative_index("epsilon", "M", M);
      current_statement__ = 126;
      stan::math::validate_non_negative_index("phi", "M", M);
      current_statement__ = 127;
      phi_2dim__ = std::numeric_limits<int>::min();
      lcm_sym339__ = (n_occasions - 1);
      phi_2dim__ = lcm_sym339__;
      current_statement__ = 127;
      stan::math::validate_non_negative_index("phi", "n_occasions - 1",
        lcm_sym339__);
      current_statement__ = 128;
      stan::math::validate_non_negative_index("p", "M", M);
      current_statement__ = 129;
      stan::math::validate_non_negative_index("p", "n_occasions", n_occasions);
      current_statement__ = 130;
      stan::math::validate_non_negative_index("b", "n_occasions", n_occasions);
      current_statement__ = 131;
      stan::math::validate_non_negative_index("nu", "n_occasions",
        n_occasions);
      current_statement__ = 132;
      stan::math::validate_non_negative_index("chi", "M", M);
      current_statement__ = 133;
      stan::math::validate_non_negative_index("chi", "n_occasions",
        n_occasions);
      current_statement__ = 134;
      stan::math::validate_non_negative_index("N", "n_occasions", n_occasions);
      current_statement__ = 135;
      stan::math::validate_non_negative_index("B", "n_occasions", n_occasions);
      current_statement__ = 136;
      stan::math::validate_non_negative_index("z", "M", M);
      current_statement__ = 137;
      stan::math::validate_non_negative_index("z", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + n_occasions + M + 1;
  }
  inline std::string model_name() const final {
    return "expr_prop_fail6_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail6_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym336__;
      int lcm_sym335__;
      local_scalar_t__ lcm_sym334__;
      int lcm_sym333__;
      int lcm_sym332__;
      int lcm_sym331__;
      int lcm_sym330__;
      int lcm_sym329__;
      Eigen::Matrix<local_scalar_t__,-1,-1> lcm_sym328__;
      double lcm_sym327__;
      double lcm_sym326__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym325__;
      double lcm_sym324__;
      double lcm_sym323__;
      double lcm_sym322__;
      double lcm_sym321__;
      double lcm_sym320__;
      int lcm_sym319__;
      double lcm_sym318__;
      double lcm_sym317__;
      double lcm_sym316__;
      double lcm_sym315__;
      double lcm_sym314__;
      double lcm_sym313__;
      double lcm_sym312__;
      double lcm_sym311__;
      double lcm_sym310__;
      double lcm_sym309__;
      double lcm_sym308__;
      double lcm_sym307__;
      double lcm_sym306__;
      double lcm_sym305__;
      int lcm_sym304__;
      double lcm_sym303__;
      int lcm_sym302__;
      int lcm_sym301__;
      double lcm_sym300__;
      double lcm_sym299__;
      double lcm_sym298__;
      double lcm_sym297__;
      double lcm_sym296__;
      double lcm_sym295__;
      double lcm_sym294__;
      double lcm_sym293__;
      double lcm_sym292__;
      double lcm_sym291__;
      double lcm_sym290__;
      double lcm_sym289__;
      double lcm_sym288__;
      double lcm_sym287__;
      int lcm_sym286__;
      int lcm_sym285__;
      double lcm_sym284__;
      int lcm_sym283__;
      int lcm_sym282__;
      int lcm_sym281__;
      int lcm_sym280__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym279__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym278__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym277__;
      int lcm_sym276__;
      int lcm_sym275__;
      int lcm_sym274__;
      int lcm_sym273__;
      int lcm_sym272__;
      int lcm_sym271__;
      int lcm_sym270__;
      int lcm_sym269__;
      int lcm_sym268__;
      int lcm_sym267__;
      int lcm_sym266__;
      int lcm_sym265__;
      int lcm_sym264__;
      double lcm_sym263__;
      double lcm_sym262__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym261__;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      local_scalar_t__ psi;
      current_statement__ = 3;
      psi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(0,
              1, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 4;
      beta = in__.template read_constrain_lb<
               Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__,
               n_occasions);
      Eigen::Matrix<local_scalar_t__,-1,1> epsilon;
      current_statement__ = 5;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      local_scalar_t__ sigma;
      current_statement__ = 6;
      sigma = in__.template read_constrain_lub<local_scalar_t__,
                jacobian__>(0, 5, lp__);
      Eigen::Matrix<local_scalar_t__,-1,-1> phi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, (n_occasions - 1),
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, n_occasions,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> b =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_occasions,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> nu =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_occasions,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, n_occasions,
          DUMMY_VAR__);
      lcm_sym276__ = (n_occasions - 1);
      stan::model::assign(lcm_sym328__,
        stan::math::rep_matrix(mean_phi, M, lcm_sym276__),
        "assigning variable lcm_sym328__");
      stan::model::assign(phi, lcm_sym328__, "assigning variable phi");
      current_statement__ = 76;
      if (stan::math::logical_gte(n_occasions, 1)) {
        stan::model::assign(lcm_sym325__,
          stan::math::inv_logit(
            stan::math::add(stan::math::logit(mean_p), epsilon)),
          "assigning variable lcm_sym325__");
        stan::model::assign(p, lcm_sym325__, "assigning variable p",
          stan::model::index_omni(), stan::model::index_uni(1));
        for (int t = 2; t <= n_occasions; ++t) {
          current_statement__ = 17;
          stan::model::assign(p, lcm_sym325__, "assigning variable p",
            stan::model::index_omni(), stan::model::index_uni(t));
        }
      }
      stan::model::assign(lcm_sym261__,
        stan::math::divide(beta, stan::math::sum(beta)),
        "assigning variable lcm_sym261__");
      stan::model::assign(b, lcm_sym261__, "assigning variable b");
      {
        local_scalar_t__ cum_b = DUMMY_VAR__;
        lcm_sym334__ = stan::model::rvalue(lcm_sym261__, "lcm_sym261__",
                         stan::model::index_uni(1));
        current_statement__ = 19;
        stan::model::assign(nu, lcm_sym334__, "assigning variable nu",
          stan::model::index_uni(1));
        current_statement__ = 23;
        if (stan::math::logical_gte(lcm_sym276__, 2)) {
          current_statement__ = 20;
          stan::model::assign(nu,
            (stan::model::rvalue(lcm_sym261__, "lcm_sym261__",
               stan::model::index_uni(2)) / (1.0 - lcm_sym334__)),
            "assigning variable nu", stan::model::index_uni(2));
          current_statement__ = 21;
          cum_b = (lcm_sym334__ +
            stan::model::rvalue(lcm_sym261__, "lcm_sym261__",
              stan::model::index_uni(2)));
          for (int t = 3; t <= lcm_sym276__; ++t) {
            current_statement__ = 20;
            stan::model::assign(nu,
              (stan::model::rvalue(lcm_sym261__, "lcm_sym261__",
                 stan::model::index_uni(t)) / (1.0 - cum_b)),
              "assigning variable nu", stan::model::index_uni(t));
            current_statement__ = 21;
            cum_b = (cum_b +
              stan::model::rvalue(lcm_sym261__, "lcm_sym261__",
                stan::model::index_uni(t)));
          }
        }
        current_statement__ = 24;
        stan::model::assign(nu, 1.0, "assigning variable nu",
          stan::model::index_uni(n_occasions));
      }
      Eigen::Matrix<local_scalar_t__,-1,-1>
        inline_prob_uncaptured_return_sym31__;
      {
        int inline_prob_uncaptured_n_ind_sym32__ =
          std::numeric_limits<int>::min();
        lcm_sym329__ = stan::math::rows(p);
        int inline_prob_uncaptured_n_occasions_sym33__ =
          std::numeric_limits<int>::min();
        lcm_sym319__ = stan::math::cols(p);
        current_statement__ = 28;
        stan::math::validate_non_negative_index("chi", "n_ind", lcm_sym329__);
        current_statement__ = 29;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          lcm_sym319__);
        Eigen::Matrix<local_scalar_t__,-1,-1>
          inline_prob_uncaptured_chi_sym34__ =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(lcm_sym329__,
            lcm_sym319__, DUMMY_VAR__);
        current_statement__ = 38;
        if (stan::math::logical_gte(lcm_sym329__, 1)) {
          current_statement__ = 31;
          stan::model::assign(inline_prob_uncaptured_chi_sym34__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym34__",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym319__));
          lcm_sym281__ = (lcm_sym319__ - 1);
          lcm_sym268__ = stan::math::logical_gte(lcm_sym281__, 1);
          if (lcm_sym268__) {
            int inline_prob_uncaptured_t_curr_sym35__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym36__ =
              std::numeric_limits<int>::min();
            lcm_sym286__ = (lcm_sym281__ + 1);
            current_statement__ = 34;
            stan::model::assign(inline_prob_uncaptured_chi_sym34__,
              stan::math::fma(
                (stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                   stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym281__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym286__)))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym34__,
                  "inline_prob_uncaptured_chi_sym34__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym286__)), (1 -
                stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym281__)))),
              "assigning variable inline_prob_uncaptured_chi_sym34__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym281__));
            for (int inline_prob_uncaptured_t_sym37__ = 2; inline_prob_uncaptured_t_sym37__
                 <= lcm_sym281__; ++inline_prob_uncaptured_t_sym37__) {
              int inline_prob_uncaptured_t_curr_sym35__ =
                std::numeric_limits<int>::min();
              lcm_sym280__ = (lcm_sym319__ -
                inline_prob_uncaptured_t_sym37__);
              int inline_prob_uncaptured_t_next_sym36__ =
                std::numeric_limits<int>::min();
              lcm_sym285__ = (lcm_sym280__ + 1);
              current_statement__ = 34;
              stan::model::assign(inline_prob_uncaptured_chi_sym34__,
                stan::math::fma(
                  (stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                     stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym280__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym285__)))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym34__,
                    "inline_prob_uncaptured_chi_sym34__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym285__)), (1 -
                  stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym280__)))),
                "assigning variable inline_prob_uncaptured_chi_sym34__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym280__));
            }
          }
          for (int inline_prob_uncaptured_i_sym38__ = 2; inline_prob_uncaptured_i_sym38__
               <= lcm_sym329__; ++inline_prob_uncaptured_i_sym38__) {
            current_statement__ = 31;
            stan::model::assign(inline_prob_uncaptured_chi_sym34__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym34__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym38__),
              stan::model::index_uni(lcm_sym319__));
            current_statement__ = 36;
            if (lcm_sym268__) {
              int inline_prob_uncaptured_t_curr_sym35__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym36__ =
                std::numeric_limits<int>::min();
              lcm_sym286__ = (lcm_sym281__ + 1);
              current_statement__ = 34;
              stan::model::assign(inline_prob_uncaptured_chi_sym34__,
                stan::math::fma(
                  (stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym38__),
                     stan::model::index_uni(lcm_sym281__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym38__),
                    stan::model::index_uni(lcm_sym286__)))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym34__,
                    "inline_prob_uncaptured_chi_sym34__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym38__),
                    stan::model::index_uni(lcm_sym286__)), (1 -
                  stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym38__),
                    stan::model::index_uni(lcm_sym281__)))),
                "assigning variable inline_prob_uncaptured_chi_sym34__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym38__),
                stan::model::index_uni(lcm_sym281__));
              for (int inline_prob_uncaptured_t_sym37__ = 2; inline_prob_uncaptured_t_sym37__
                   <= lcm_sym281__; ++inline_prob_uncaptured_t_sym37__) {
                int inline_prob_uncaptured_t_curr_sym35__ =
                  std::numeric_limits<int>::min();
                lcm_sym280__ = (lcm_sym319__ -
                  inline_prob_uncaptured_t_sym37__);
                int inline_prob_uncaptured_t_next_sym36__ =
                  std::numeric_limits<int>::min();
                lcm_sym285__ = (lcm_sym280__ + 1);
                current_statement__ = 34;
                stan::model::assign(inline_prob_uncaptured_chi_sym34__,
                  stan::math::fma(
                    (stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                       stan::model::index_uni(
                         inline_prob_uncaptured_i_sym38__),
                       stan::model::index_uni(lcm_sym280__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym38__),
                      stan::model::index_uni(lcm_sym285__)))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym34__,
                      "inline_prob_uncaptured_chi_sym34__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym38__),
                      stan::model::index_uni(lcm_sym285__)), (1 -
                    stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym38__),
                      stan::model::index_uni(lcm_sym280__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym34__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym38__),
                  stan::model::index_uni(lcm_sym280__));
              }
            }
          }
        }
        current_statement__ = 39;
        stan::model::assign(inline_prob_uncaptured_return_sym31__,
          inline_prob_uncaptured_chi_sym34__,
          "assigning variable inline_prob_uncaptured_return_sym31__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym31__,
        "assigning variable chi");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "phi", lcm_sym328__, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "phi", lcm_sym328__, 1);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 8;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 9;
      stan::math::check_simplex(function__, "b", lcm_sym261__);
      current_statement__ = 10;
      stan::math::check_greater_or_equal(function__, "nu", nu, 0);
      current_statement__ = 10;
      stan::math::check_less_or_equal(function__, "nu", nu, 1);
      current_statement__ = 11;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym31__, 0);
      current_statement__ = 11;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym31__, 1);
      {
        current_statement__ = 77;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(epsilon, 0, sigma));
        current_statement__ = 78;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(beta, 1, 1));
        {
          int inline_js_super_lp_n_ind_sym40__ =
            std::numeric_limits<int>::min();
          lcm_sym335__ = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                           stan::model::index_uni(1));
          int inline_js_super_lp_n_occasions_sym41__ =
            std::numeric_limits<int>::min();
          lcm_sym336__ = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                           stan::model::index_uni(2));
          current_statement__ = 81;
          stan::math::validate_non_negative_index("qnu", "n_occasions",
            lcm_sym336__);
          Eigen::Matrix<double,-1,1> inline_js_super_lp_qnu_sym42__ =
            Eigen::Matrix<double,-1,1>::Constant(lcm_sym336__,
              std::numeric_limits<double>::quiet_NaN());
          stan::model::assign(lcm_sym277__, stan::math::subtract(1.0, nu),
            "assigning variable lcm_sym277__");
          current_statement__ = 109;
          if (stan::math::logical_gte(lcm_sym335__, 1)) {
            current_statement__ = 83;
            stan::math::validate_non_negative_index("qp", "n_occasions",
              lcm_sym336__);
            Eigen::Matrix<double,-1,1> inline_js_super_lp_qp_sym43__ =
              Eigen::Matrix<double,-1,1>::Constant(lcm_sym336__,
                std::numeric_limits<double>::quiet_NaN());
            stan::model::assign(lcm_sym279__,
              stan::math::subtract(1.0,
                stan::math::transpose(
                  stan::model::rvalue(p, "p", stan::model::index_uni(1)))),
              "assigning variable lcm_sym279__");
            lcm_sym331__ = stan::model::rvalue(first, "first",
                             stan::model::index_uni(1));
            if (lcm_sym331__) {
              current_statement__ = 92;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1, psi));
              current_statement__ = 102;
              if (stan::math::logical_eq(lcm_sym331__, 1)) {
                current_statement__ = 100;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 (stan::model::rvalue(nu, "nu",
                                    stan::model::index_uni(1)) *
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni(1)))));
              } else {
                current_statement__ = 93;
                stan::math::validate_non_negative_index("lp", "first[i]",
                  lcm_sym331__);
                Eigen::Matrix<local_scalar_t__,-1,1>
                  inline_js_super_lp_lp_sym44__ =
                  Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym331__,
                    DUMMY_VAR__);
                lcm_sym283__ = (lcm_sym331__ - 1);
                stan::model::assign(inline_js_super_lp_lp_sym44__,
                  (((stan::math::bernoulli_lpmf<false>(1,
                       stan::model::rvalue(nu, "nu",
                         stan::model::index_uni(1))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym279__, "lcm_sym279__",
                        stan::model::index_min_max(1, lcm_sym283__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                        stan::model::index_uni(1),
                        stan::model::index_min_max(1, lcm_sym283__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(p, "p", stan::model::index_uni(1),
                      stan::model::index_uni(lcm_sym331__)))),
                  "assigning variable inline_js_super_lp_lp_sym44__",
                  stan::model::index_uni(1));
                current_statement__ = 96;
                if (stan::math::logical_gte(lcm_sym283__, 2)) {
                  current_statement__ = 95;
                  stan::model::assign(inline_js_super_lp_lp_sym44__,
                    ((((stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(lcm_sym277__, "lcm_sym277__",
                              stan::model::index_min_max(1, 1)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(nu, "nu", stan::model::index_uni(2))))
                    +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym279__, "lcm_sym279__",
                          stan::model::index_min_max(2, lcm_sym283__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                          stan::model::index_uni(1),
                          stan::model::index_min_max(2, lcm_sym283__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(p, "p", stan::model::index_uni(1),
                        stan::model::index_uni(lcm_sym331__)))),
                    "assigning variable inline_js_super_lp_lp_sym44__",
                    stan::model::index_uni(2));
                  for (int inline_js_super_lp_t_sym45__ = 3; inline_js_super_lp_t_sym45__
                       <= lcm_sym283__; ++inline_js_super_lp_t_sym45__) {
                    current_statement__ = 95;
                    stan::model::assign(inline_js_super_lp_lp_sym44__,
                      ((((stan::math::bernoulli_lpmf<false>(1,
                            stan::math::prod(
                              stan::model::rvalue(lcm_sym277__,
                                "lcm_sym277__",
                                stan::model::index_min_max(1,
                                  (inline_js_super_lp_t_sym45__ - 1))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        nu[(inline_js_super_lp_t_sym45__ - 1)])) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym279__, "lcm_sym279__",
                            stan::model::index_min_max(
                              inline_js_super_lp_t_sym45__, lcm_sym283__)))))
                      +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                            stan::model::index_uni(1),
                            stan::model::index_min_max(
                              inline_js_super_lp_t_sym45__, lcm_sym283__)))))
                      +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(p, "p",
                          stan::model::index_uni(1),
                          stan::model::index_uni(lcm_sym331__)))),
                      "assigning variable inline_js_super_lp_lp_sym44__",
                      stan::model::index_uni(inline_js_super_lp_t_sym45__));
                  }
                }
                current_statement__ = 97;
                stan::model::assign(inline_js_super_lp_lp_sym44__,
                  ((stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym277__, "lcm_sym277__",
                          stan::model::index_min_max(1, lcm_sym283__)))) +
                  stan::math::bernoulli_lpmf<false>(1, nu[(lcm_sym331__ - 1)]))
                  +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(p, "p", stan::model::index_uni(1),
                      stan::model::index_uni(lcm_sym331__)))),
                  "assigning variable inline_js_super_lp_lp_sym44__",
                  stan::model::index_uni(lcm_sym331__));
                current_statement__ = 98;
                lp_accum__.add(stan::math::log_sum_exp(
                                 inline_js_super_lp_lp_sym44__));
              }
              lcm_sym333__ = stan::model::rvalue(last, "last",
                               stan::model::index_uni(1));
              if (stan::math::logical_gte(lcm_sym333__, (lcm_sym331__ + 1))) {
                current_statement__ = 103;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(lcm_sym328__,
                                   "lcm_sym328__", stan::model::index_uni(1),
                                   stan::model::index_uni(((lcm_sym331__ + 1)
                                     - 1)))));
                lcm_sym302__ = ((lcm_sym331__ + 1) + 1);
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((lcm_sym331__ + 1))),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((lcm_sym331__ + 1)))));
                for (int inline_js_super_lp_t_sym45__ = lcm_sym302__; inline_js_super_lp_t_sym45__
                     <= lcm_sym333__; ++inline_js_super_lp_t_sym45__) {
                  current_statement__ = 103;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(lcm_sym328__,
                                     "lcm_sym328__",
                                     stan::model::index_uni(1),
                                     stan::model::index_uni(
                                       (inline_js_super_lp_t_sym45__ - 1)))));
                  current_statement__ = 104;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(1),
                                     stan::model::index_uni(
                                       inline_js_super_lp_t_sym45__)),
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(1),
                                     stan::model::index_uni(
                                       inline_js_super_lp_t_sym45__))));
                }
              }
              current_statement__ = 106;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(
                                 inline_prob_uncaptured_return_sym31__,
                                 "inline_prob_uncaptured_return_sym31__",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(lcm_sym333__))));
            } else {
              lcm_sym304__ = (lcm_sym336__ + 1);
              stan::math::validate_non_negative_index("lp",
                "n_occasions + 1", lcm_sym304__);
              Eigen::Matrix<local_scalar_t__,-1,1>
                inline_js_super_lp_lp_sym44__ =
                Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym304__,
                  DUMMY_VAR__);
              current_statement__ = 86;
              stan::model::assign(inline_js_super_lp_lp_sym44__,
                (((stan::math::bernoulli_lpmf<false>(1, psi) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(nu, "nu", stan::model::index_uni(1))))
                +
                stan::math::bernoulli_lpmf<false>(0,
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni(1)))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(inline_prob_uncaptured_return_sym31__,
                    "inline_prob_uncaptured_return_sym31__",
                    stan::model::index_uni(1), stan::model::index_uni(1)))),
                "assigning variable inline_js_super_lp_lp_sym44__",
                stan::model::index_uni(1));
              current_statement__ = 88;
              if (stan::math::logical_gte(lcm_sym336__, 2)) {
                current_statement__ = 87;
                stan::model::assign(inline_js_super_lp_lp_sym44__,
                  ((((stan::math::bernoulli_lpmf<false>(1, psi) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym277__, "lcm_sym277__",
                        stan::model::index_min_max(1, 1))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(nu, "nu", stan::model::index_uni(2))))
                  +
                  stan::math::bernoulli_lpmf<false>(0,
                    stan::model::rvalue(p, "p", stan::model::index_uni(1),
                      stan::model::index_uni(2)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(
                      inline_prob_uncaptured_return_sym31__,
                      "inline_prob_uncaptured_return_sym31__",
                      stan::model::index_uni(1), stan::model::index_uni(2)))),
                  "assigning variable inline_js_super_lp_lp_sym44__",
                  stan::model::index_uni(2));
                for (int inline_js_super_lp_t_sym45__ = 3; inline_js_super_lp_t_sym45__
                     <= lcm_sym336__; ++inline_js_super_lp_t_sym45__) {
                  current_statement__ = 87;
                  stan::model::assign(inline_js_super_lp_lp_sym44__,
                    ((((stan::math::bernoulli_lpmf<false>(1, psi) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym277__, "lcm_sym277__",
                          stan::model::index_min_max(1,
                            (inline_js_super_lp_t_sym45__ - 1)))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      nu[(inline_js_super_lp_t_sym45__ - 1)])) +
                    stan::math::bernoulli_lpmf<false>(0,
                      stan::model::rvalue(p, "p", stan::model::index_uni(1),
                        stan::model::index_uni(inline_js_super_lp_t_sym45__))))
                    +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(
                        inline_prob_uncaptured_return_sym31__,
                        "inline_prob_uncaptured_return_sym31__",
                        stan::model::index_uni(1),
                        stan::model::index_uni(inline_js_super_lp_t_sym45__)))),
                    "assigning variable inline_js_super_lp_lp_sym44__",
                    stan::model::index_uni(inline_js_super_lp_t_sym45__));
                }
              }
              current_statement__ = 89;
              stan::model::assign(inline_js_super_lp_lp_sym44__,
                stan::math::bernoulli_lpmf<false>(0, psi),
                "assigning variable inline_js_super_lp_lp_sym44__",
                stan::model::index_uni(lcm_sym304__));
              current_statement__ = 90;
              lp_accum__.add(stan::math::log_sum_exp(
                               inline_js_super_lp_lp_sym44__));
            }
            for (int inline_js_super_lp_i_sym46__ = 2; inline_js_super_lp_i_sym46__
                 <= lcm_sym335__; ++inline_js_super_lp_i_sym46__) {
              current_statement__ = 83;
              stan::math::validate_non_negative_index("qp", "n_occasions",
                lcm_sym336__);
              Eigen::Matrix<double,-1,1> inline_js_super_lp_qp_sym43__ =
                Eigen::Matrix<double,-1,1>::Constant(lcm_sym336__,
                  std::numeric_limits<double>::quiet_NaN());
              stan::model::assign(lcm_sym278__,
                stan::math::subtract(1.0,
                  stan::math::transpose(
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_js_super_lp_i_sym46__)))),
                "assigning variable lcm_sym278__");
              lcm_sym330__ = first[(inline_js_super_lp_i_sym46__ - 1)];
              if (lcm_sym330__) {
                current_statement__ = 92;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1, psi));
                current_statement__ = 102;
                if (stan::math::logical_eq(lcm_sym330__, 1)) {
                  current_statement__ = 100;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   (stan::model::rvalue(nu, "nu",
                                      stan::model::index_uni(1)) *
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(
                                       inline_js_super_lp_i_sym46__),
                                     stan::model::index_uni(1)))));
                } else {
                  current_statement__ = 93;
                  stan::math::validate_non_negative_index("lp", "first[i]",
                    lcm_sym330__);
                  Eigen::Matrix<local_scalar_t__,-1,1>
                    inline_js_super_lp_lp_sym44__ =
                    Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym330__,
                      DUMMY_VAR__);
                  lcm_sym282__ = (lcm_sym330__ - 1);
                  stan::model::assign(inline_js_super_lp_lp_sym44__,
                    (((stan::math::bernoulli_lpmf<false>(1,
                         stan::model::rvalue(nu, "nu",
                           stan::model::index_uni(1))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym278__, "lcm_sym278__",
                          stan::model::index_min_max(1, lcm_sym282__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                          stan::model::index_uni(inline_js_super_lp_i_sym46__),
                          stan::model::index_min_max(1, lcm_sym282__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(p, "p",
                        stan::model::index_uni(inline_js_super_lp_i_sym46__),
                        stan::model::index_uni(lcm_sym330__)))),
                    "assigning variable inline_js_super_lp_lp_sym44__",
                    stan::model::index_uni(1));
                  current_statement__ = 96;
                  if (stan::math::logical_gte(lcm_sym282__, 2)) {
                    current_statement__ = 95;
                    stan::model::assign(inline_js_super_lp_lp_sym44__,
                      ((((stan::math::bernoulli_lpmf<false>(1,
                            stan::math::prod(
                              stan::model::rvalue(lcm_sym277__,
                                "lcm_sym277__",
                                stan::model::index_min_max(1, 1)))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(nu, "nu",
                          stan::model::index_uni(2)))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym278__, "lcm_sym278__",
                            stan::model::index_min_max(2, lcm_sym282__))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                            stan::model::index_uni(
                              inline_js_super_lp_i_sym46__),
                            stan::model::index_min_max(2, lcm_sym282__))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(p, "p",
                          stan::model::index_uni(inline_js_super_lp_i_sym46__),
                          stan::model::index_uni(lcm_sym330__)))),
                      "assigning variable inline_js_super_lp_lp_sym44__",
                      stan::model::index_uni(2));
                    for (int inline_js_super_lp_t_sym45__ = 3; inline_js_super_lp_t_sym45__
                         <= lcm_sym282__; ++inline_js_super_lp_t_sym45__) {
                      current_statement__ = 95;
                      stan::model::assign(inline_js_super_lp_lp_sym44__,
                        ((((stan::math::bernoulli_lpmf<false>(1,
                              stan::math::prod(
                                stan::model::rvalue(lcm_sym277__,
                                  "lcm_sym277__",
                                  stan::model::index_min_max(1,
                                    (inline_js_super_lp_t_sym45__ - 1))))) +
                        stan::math::bernoulli_lpmf<false>(1,
                          nu[(inline_js_super_lp_t_sym45__ - 1)])) +
                        stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(lcm_sym278__, "lcm_sym278__",
                              stan::model::index_min_max(
                                inline_js_super_lp_t_sym45__, lcm_sym282__)))))
                        +
                        stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(lcm_sym328__, "lcm_sym328__",
                              stan::model::index_uni(
                                inline_js_super_lp_i_sym46__),
                              stan::model::index_min_max(
                                inline_js_super_lp_t_sym45__, lcm_sym282__)))))
                        +
                        stan::math::bernoulli_lpmf<false>(1,
                          stan::model::rvalue(p, "p",
                            stan::model::index_uni(
                              inline_js_super_lp_i_sym46__),
                            stan::model::index_uni(lcm_sym330__)))),
                        "assigning variable inline_js_super_lp_lp_sym44__",
                        stan::model::index_uni(inline_js_super_lp_t_sym45__));
                    }
                  }
                  current_statement__ = 97;
                  stan::model::assign(inline_js_super_lp_lp_sym44__,
                    ((stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym277__, "lcm_sym277__",
                            stan::model::index_min_max(1, lcm_sym282__)))) +
                    stan::math::bernoulli_lpmf<false>(1, nu[(lcm_sym330__ -
                      1)])) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(p, "p",
                        stan::model::index_uni(inline_js_super_lp_i_sym46__),
                        stan::model::index_uni(lcm_sym330__)))),
                    "assigning variable inline_js_super_lp_lp_sym44__",
                    stan::model::index_uni(lcm_sym330__));
                  current_statement__ = 98;
                  lp_accum__.add(stan::math::log_sum_exp(
                                   inline_js_super_lp_lp_sym44__));
                }
                lcm_sym332__ = last[(inline_js_super_lp_i_sym46__ - 1)];
                if (stan::math::logical_gte(lcm_sym332__, (lcm_sym330__ + 1))) {
                  current_statement__ = 103;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(lcm_sym328__,
                                     "lcm_sym328__",
                                     stan::model::index_uni(
                                       inline_js_super_lp_i_sym46__),
                                     stan::model::index_uni(((lcm_sym330__ +
                                       1) - 1)))));
                  lcm_sym301__ = ((lcm_sym330__ + 1) + 1);
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(
                                       inline_js_super_lp_i_sym46__),
                                     stan::model::index_uni((lcm_sym330__ +
                                       1))),
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(
                                       inline_js_super_lp_i_sym46__),
                                     stan::model::index_uni((lcm_sym330__ +
                                       1)))));
                  for (int inline_js_super_lp_t_sym45__ = lcm_sym301__; inline_js_super_lp_t_sym45__
                       <= lcm_sym332__; ++inline_js_super_lp_t_sym45__) {
                    current_statement__ = 103;
                    lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                     stan::model::rvalue(lcm_sym328__,
                                       "lcm_sym328__",
                                       stan::model::index_uni(
                                         inline_js_super_lp_i_sym46__),
                                       stan::model::index_uni(
                                         (inline_js_super_lp_t_sym45__ - 1)))));
                    current_statement__ = 104;
                    lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                     y[(inline_js_super_lp_i_sym46__ -
                                     1)][(inline_js_super_lp_t_sym45__ - 1)],
                                     stan::model::rvalue(p, "p",
                                       stan::model::index_uni(
                                         inline_js_super_lp_i_sym46__),
                                       stan::model::index_uni(
                                         inline_js_super_lp_t_sym45__))));
                  }
                }
                current_statement__ = 106;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(
                                   inline_prob_uncaptured_return_sym31__,
                                   "inline_prob_uncaptured_return_sym31__",
                                   stan::model::index_uni(
                                     inline_js_super_lp_i_sym46__),
                                   stan::model::index_uni(lcm_sym332__))));
              } else {
                lcm_sym304__ = (lcm_sym336__ + 1);
                stan::math::validate_non_negative_index("lp",
                  "n_occasions + 1", lcm_sym304__);
                Eigen::Matrix<local_scalar_t__,-1,1>
                  inline_js_super_lp_lp_sym44__ =
                  Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym304__,
                    DUMMY_VAR__);
                current_statement__ = 86;
                stan::model::assign(inline_js_super_lp_lp_sym44__,
                  (((stan::math::bernoulli_lpmf<false>(1, psi) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(nu, "nu", stan::model::index_uni(1))))
                  +
                  stan::math::bernoulli_lpmf<false>(0,
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_js_super_lp_i_sym46__),
                      stan::model::index_uni(1)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(
                      inline_prob_uncaptured_return_sym31__,
                      "inline_prob_uncaptured_return_sym31__",
                      stan::model::index_uni(inline_js_super_lp_i_sym46__),
                      stan::model::index_uni(1)))),
                  "assigning variable inline_js_super_lp_lp_sym44__",
                  stan::model::index_uni(1));
                current_statement__ = 88;
                if (stan::math::logical_gte(lcm_sym336__, 2)) {
                  current_statement__ = 87;
                  stan::model::assign(inline_js_super_lp_lp_sym44__,
                    ((((stan::math::bernoulli_lpmf<false>(1, psi) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym277__, "lcm_sym277__",
                          stan::model::index_min_max(1, 1))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(nu, "nu", stan::model::index_uni(2))))
                    +
                    stan::math::bernoulli_lpmf<false>(0,
                      stan::model::rvalue(p, "p",
                        stan::model::index_uni(inline_js_super_lp_i_sym46__),
                        stan::model::index_uni(2)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(
                        inline_prob_uncaptured_return_sym31__,
                        "inline_prob_uncaptured_return_sym31__",
                        stan::model::index_uni(inline_js_super_lp_i_sym46__),
                        stan::model::index_uni(2)))),
                    "assigning variable inline_js_super_lp_lp_sym44__",
                    stan::model::index_uni(2));
                  for (int inline_js_super_lp_t_sym45__ = 3; inline_js_super_lp_t_sym45__
                       <= lcm_sym336__; ++inline_js_super_lp_t_sym45__) {
                    current_statement__ = 87;
                    stan::model::assign(inline_js_super_lp_lp_sym44__,
                      ((((stan::math::bernoulli_lpmf<false>(1, psi) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym277__, "lcm_sym277__",
                            stan::model::index_min_max(1,
                              (inline_js_super_lp_t_sym45__ - 1)))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        nu[(inline_js_super_lp_t_sym45__ - 1)])) +
                      stan::math::bernoulli_lpmf<false>(0,
                        stan::model::rvalue(p, "p",
                          stan::model::index_uni(inline_js_super_lp_i_sym46__),
                          stan::model::index_uni(inline_js_super_lp_t_sym45__))))
                      +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(
                          inline_prob_uncaptured_return_sym31__,
                          "inline_prob_uncaptured_return_sym31__",
                          stan::model::index_uni(inline_js_super_lp_i_sym46__),
                          stan::model::index_uni(inline_js_super_lp_t_sym45__)))),
                      "assigning variable inline_js_super_lp_lp_sym44__",
                      stan::model::index_uni(inline_js_super_lp_t_sym45__));
                  }
                }
                current_statement__ = 89;
                stan::model::assign(inline_js_super_lp_lp_sym44__,
                  stan::math::bernoulli_lpmf<false>(0, psi),
                  "assigning variable inline_js_super_lp_lp_sym44__",
                  stan::model::index_uni(lcm_sym304__));
                current_statement__ = 90;
                lp_accum__.add(stan::math::log_sum_exp(
                                 inline_js_super_lp_lp_sym44__));
              }
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail6_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym260__;
      int lcm_sym259__;
      local_scalar_t__ lcm_sym258__;
      int lcm_sym257__;
      int lcm_sym256__;
      int lcm_sym255__;
      int lcm_sym254__;
      int lcm_sym253__;
      Eigen::Matrix<local_scalar_t__,-1,-1> lcm_sym252__;
      double lcm_sym251__;
      double lcm_sym250__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym249__;
      double lcm_sym248__;
      double lcm_sym247__;
      double lcm_sym246__;
      double lcm_sym245__;
      double lcm_sym244__;
      int lcm_sym243__;
      double lcm_sym242__;
      double lcm_sym241__;
      double lcm_sym240__;
      double lcm_sym239__;
      double lcm_sym238__;
      double lcm_sym237__;
      double lcm_sym236__;
      double lcm_sym235__;
      double lcm_sym234__;
      double lcm_sym233__;
      double lcm_sym232__;
      double lcm_sym231__;
      double lcm_sym230__;
      double lcm_sym229__;
      int lcm_sym228__;
      double lcm_sym227__;
      int lcm_sym226__;
      int lcm_sym225__;
      double lcm_sym224__;
      double lcm_sym223__;
      double lcm_sym222__;
      double lcm_sym221__;
      double lcm_sym220__;
      double lcm_sym219__;
      double lcm_sym218__;
      double lcm_sym217__;
      double lcm_sym216__;
      double lcm_sym215__;
      double lcm_sym214__;
      double lcm_sym213__;
      double lcm_sym212__;
      double lcm_sym211__;
      int lcm_sym210__;
      int lcm_sym209__;
      double lcm_sym208__;
      int lcm_sym207__;
      int lcm_sym206__;
      int lcm_sym205__;
      int lcm_sym204__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym203__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym202__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym201__;
      int lcm_sym200__;
      int lcm_sym199__;
      int lcm_sym198__;
      int lcm_sym197__;
      int lcm_sym196__;
      int lcm_sym195__;
      int lcm_sym194__;
      int lcm_sym193__;
      int lcm_sym192__;
      int lcm_sym191__;
      int lcm_sym190__;
      int lcm_sym189__;
      int lcm_sym188__;
      double lcm_sym187__;
      double lcm_sym186__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym185__;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      local_scalar_t__ psi;
      current_statement__ = 3;
      psi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(0,
              1, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 4;
      beta = in__.template read_constrain_lb<
               Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__,
               n_occasions);
      Eigen::Matrix<local_scalar_t__,-1,1> epsilon;
      current_statement__ = 5;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      local_scalar_t__ sigma;
      current_statement__ = 6;
      sigma = in__.template read_constrain_lub<local_scalar_t__,
                jacobian__>(0, 5, lp__);
      Eigen::Matrix<local_scalar_t__,-1,-1> phi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, (n_occasions - 1),
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, n_occasions,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> b =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_occasions,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> nu =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_occasions,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, n_occasions,
          DUMMY_VAR__);
      lcm_sym200__ = (n_occasions - 1);
      stan::model::assign(lcm_sym252__,
        stan::math::rep_matrix(mean_phi, M, lcm_sym200__),
        "assigning variable lcm_sym252__");
      stan::model::assign(phi, lcm_sym252__, "assigning variable phi");
      current_statement__ = 76;
      if (stan::math::logical_gte(n_occasions, 1)) {
        stan::model::assign(lcm_sym249__,
          stan::math::inv_logit(
            stan::math::add(stan::math::logit(mean_p), epsilon)),
          "assigning variable lcm_sym249__");
        stan::model::assign(p, lcm_sym249__, "assigning variable p",
          stan::model::index_omni(), stan::model::index_uni(1));
        for (int t = 2; t <= n_occasions; ++t) {
          current_statement__ = 17;
          stan::model::assign(p, lcm_sym249__, "assigning variable p",
            stan::model::index_omni(), stan::model::index_uni(t));
        }
      }
      stan::model::assign(lcm_sym185__,
        stan::math::divide(beta, stan::math::sum(beta)),
        "assigning variable lcm_sym185__");
      stan::model::assign(b, lcm_sym185__, "assigning variable b");
      {
        local_scalar_t__ cum_b = DUMMY_VAR__;
        lcm_sym258__ = stan::model::rvalue(lcm_sym185__, "lcm_sym185__",
                         stan::model::index_uni(1));
        current_statement__ = 19;
        stan::model::assign(nu, lcm_sym258__, "assigning variable nu",
          stan::model::index_uni(1));
        current_statement__ = 23;
        if (stan::math::logical_gte(lcm_sym200__, 2)) {
          current_statement__ = 20;
          stan::model::assign(nu,
            (stan::model::rvalue(lcm_sym185__, "lcm_sym185__",
               stan::model::index_uni(2)) / (1.0 - lcm_sym258__)),
            "assigning variable nu", stan::model::index_uni(2));
          current_statement__ = 21;
          cum_b = (lcm_sym258__ +
            stan::model::rvalue(lcm_sym185__, "lcm_sym185__",
              stan::model::index_uni(2)));
          for (int t = 3; t <= lcm_sym200__; ++t) {
            current_statement__ = 20;
            stan::model::assign(nu,
              (stan::model::rvalue(lcm_sym185__, "lcm_sym185__",
                 stan::model::index_uni(t)) / (1.0 - cum_b)),
              "assigning variable nu", stan::model::index_uni(t));
            current_statement__ = 21;
            cum_b = (cum_b +
              stan::model::rvalue(lcm_sym185__, "lcm_sym185__",
                stan::model::index_uni(t)));
          }
        }
        current_statement__ = 24;
        stan::model::assign(nu, 1.0, "assigning variable nu",
          stan::model::index_uni(n_occasions));
      }
      Eigen::Matrix<local_scalar_t__,-1,-1>
        inline_prob_uncaptured_return_sym14__;
      {
        int inline_prob_uncaptured_n_ind_sym15__ =
          std::numeric_limits<int>::min();
        lcm_sym253__ = stan::math::rows(p);
        int inline_prob_uncaptured_n_occasions_sym16__ =
          std::numeric_limits<int>::min();
        lcm_sym243__ = stan::math::cols(p);
        current_statement__ = 28;
        stan::math::validate_non_negative_index("chi", "n_ind", lcm_sym253__);
        current_statement__ = 29;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          lcm_sym243__);
        Eigen::Matrix<local_scalar_t__,-1,-1>
          inline_prob_uncaptured_chi_sym17__ =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(lcm_sym253__,
            lcm_sym243__, DUMMY_VAR__);
        current_statement__ = 38;
        if (stan::math::logical_gte(lcm_sym253__, 1)) {
          current_statement__ = 31;
          stan::model::assign(inline_prob_uncaptured_chi_sym17__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym17__",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym243__));
          lcm_sym205__ = (lcm_sym243__ - 1);
          lcm_sym192__ = stan::math::logical_gte(lcm_sym205__, 1);
          if (lcm_sym192__) {
            int inline_prob_uncaptured_t_curr_sym18__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym19__ =
              std::numeric_limits<int>::min();
            lcm_sym210__ = (lcm_sym205__ + 1);
            current_statement__ = 34;
            stan::model::assign(inline_prob_uncaptured_chi_sym17__,
              stan::math::fma(
                (stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                   stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym205__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym210__)))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym17__,
                  "inline_prob_uncaptured_chi_sym17__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym210__)), (1 -
                stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym205__)))),
              "assigning variable inline_prob_uncaptured_chi_sym17__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym205__));
            for (int inline_prob_uncaptured_t_sym20__ = 2; inline_prob_uncaptured_t_sym20__
                 <= lcm_sym205__; ++inline_prob_uncaptured_t_sym20__) {
              int inline_prob_uncaptured_t_curr_sym18__ =
                std::numeric_limits<int>::min();
              lcm_sym204__ = (lcm_sym243__ -
                inline_prob_uncaptured_t_sym20__);
              int inline_prob_uncaptured_t_next_sym19__ =
                std::numeric_limits<int>::min();
              lcm_sym209__ = (lcm_sym204__ + 1);
              current_statement__ = 34;
              stan::model::assign(inline_prob_uncaptured_chi_sym17__,
                stan::math::fma(
                  (stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                     stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym204__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym209__)))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym17__,
                    "inline_prob_uncaptured_chi_sym17__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym209__)), (1 -
                  stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym204__)))),
                "assigning variable inline_prob_uncaptured_chi_sym17__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym204__));
            }
          }
          for (int inline_prob_uncaptured_i_sym21__ = 2; inline_prob_uncaptured_i_sym21__
               <= lcm_sym253__; ++inline_prob_uncaptured_i_sym21__) {
            current_statement__ = 31;
            stan::model::assign(inline_prob_uncaptured_chi_sym17__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym17__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym21__),
              stan::model::index_uni(lcm_sym243__));
            current_statement__ = 36;
            if (lcm_sym192__) {
              int inline_prob_uncaptured_t_curr_sym18__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym19__ =
                std::numeric_limits<int>::min();
              lcm_sym210__ = (lcm_sym205__ + 1);
              current_statement__ = 34;
              stan::model::assign(inline_prob_uncaptured_chi_sym17__,
                stan::math::fma(
                  (stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym21__),
                     stan::model::index_uni(lcm_sym205__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym21__),
                    stan::model::index_uni(lcm_sym210__)))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym17__,
                    "inline_prob_uncaptured_chi_sym17__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym21__),
                    stan::model::index_uni(lcm_sym210__)), (1 -
                  stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym21__),
                    stan::model::index_uni(lcm_sym205__)))),
                "assigning variable inline_prob_uncaptured_chi_sym17__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym21__),
                stan::model::index_uni(lcm_sym205__));
              for (int inline_prob_uncaptured_t_sym20__ = 2; inline_prob_uncaptured_t_sym20__
                   <= lcm_sym205__; ++inline_prob_uncaptured_t_sym20__) {
                int inline_prob_uncaptured_t_curr_sym18__ =
                  std::numeric_limits<int>::min();
                lcm_sym204__ = (lcm_sym243__ -
                  inline_prob_uncaptured_t_sym20__);
                int inline_prob_uncaptured_t_next_sym19__ =
                  std::numeric_limits<int>::min();
                lcm_sym209__ = (lcm_sym204__ + 1);
                current_statement__ = 34;
                stan::model::assign(inline_prob_uncaptured_chi_sym17__,
                  stan::math::fma(
                    (stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                       stan::model::index_uni(
                         inline_prob_uncaptured_i_sym21__),
                       stan::model::index_uni(lcm_sym204__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym21__),
                      stan::model::index_uni(lcm_sym209__)))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym17__,
                      "inline_prob_uncaptured_chi_sym17__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym21__),
                      stan::model::index_uni(lcm_sym209__)), (1 -
                    stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym21__),
                      stan::model::index_uni(lcm_sym204__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym17__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym21__),
                  stan::model::index_uni(lcm_sym204__));
              }
            }
          }
        }
        current_statement__ = 39;
        stan::model::assign(inline_prob_uncaptured_return_sym14__,
          inline_prob_uncaptured_chi_sym17__,
          "assigning variable inline_prob_uncaptured_return_sym14__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym14__,
        "assigning variable chi");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "phi", lcm_sym252__, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "phi", lcm_sym252__, 1);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 8;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 9;
      stan::math::check_simplex(function__, "b", lcm_sym185__);
      current_statement__ = 10;
      stan::math::check_greater_or_equal(function__, "nu", nu, 0);
      current_statement__ = 10;
      stan::math::check_less_or_equal(function__, "nu", nu, 1);
      current_statement__ = 11;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym14__, 0);
      current_statement__ = 11;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym14__, 1);
      {
        current_statement__ = 77;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(epsilon, 0, sigma));
        current_statement__ = 78;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(beta, 1, 1));
        {
          int inline_js_super_lp_n_ind_sym23__ =
            std::numeric_limits<int>::min();
          lcm_sym259__ = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                           stan::model::index_uni(1));
          int inline_js_super_lp_n_occasions_sym24__ =
            std::numeric_limits<int>::min();
          lcm_sym260__ = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                           stan::model::index_uni(2));
          current_statement__ = 81;
          stan::math::validate_non_negative_index("qnu", "n_occasions",
            lcm_sym260__);
          stan::math::var_value<Eigen::Matrix<double,-1,1>>
            inline_js_super_lp_qnu_sym25__ =
            Eigen::Matrix<double,-1,1>::Constant(lcm_sym260__,
              std::numeric_limits<double>::quiet_NaN());
          stan::model::assign(lcm_sym201__, stan::math::subtract(1.0, nu),
            "assigning variable lcm_sym201__");
          current_statement__ = 109;
          if (stan::math::logical_gte(lcm_sym259__, 1)) {
            current_statement__ = 83;
            stan::math::validate_non_negative_index("qp", "n_occasions",
              lcm_sym260__);
            stan::math::var_value<Eigen::Matrix<double,-1,1>>
              inline_js_super_lp_qp_sym26__ =
              Eigen::Matrix<double,-1,1>::Constant(lcm_sym260__,
                std::numeric_limits<double>::quiet_NaN());
            stan::model::assign(lcm_sym203__,
              stan::math::subtract(1.0,
                stan::math::transpose(
                  stan::model::rvalue(p, "p", stan::model::index_uni(1)))),
              "assigning variable lcm_sym203__");
            lcm_sym255__ = stan::model::rvalue(first, "first",
                             stan::model::index_uni(1));
            if (lcm_sym255__) {
              current_statement__ = 92;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1, psi));
              current_statement__ = 102;
              if (stan::math::logical_eq(lcm_sym255__, 1)) {
                current_statement__ = 100;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 (stan::model::rvalue(nu, "nu",
                                    stan::model::index_uni(1)) *
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni(1)))));
              } else {
                current_statement__ = 93;
                stan::math::validate_non_negative_index("lp", "first[i]",
                  lcm_sym255__);
                Eigen::Matrix<local_scalar_t__,-1,1>
                  inline_js_super_lp_lp_sym27__ =
                  Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym255__,
                    DUMMY_VAR__);
                lcm_sym207__ = (lcm_sym255__ - 1);
                stan::model::assign(inline_js_super_lp_lp_sym27__,
                  (((stan::math::bernoulli_lpmf<false>(1,
                       stan::model::rvalue(nu, "nu",
                         stan::model::index_uni(1))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym203__, "lcm_sym203__",
                        stan::model::index_min_max(1, lcm_sym207__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                        stan::model::index_uni(1),
                        stan::model::index_min_max(1, lcm_sym207__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(p, "p", stan::model::index_uni(1),
                      stan::model::index_uni(lcm_sym255__)))),
                  "assigning variable inline_js_super_lp_lp_sym27__",
                  stan::model::index_uni(1));
                current_statement__ = 96;
                if (stan::math::logical_gte(lcm_sym207__, 2)) {
                  current_statement__ = 95;
                  stan::model::assign(inline_js_super_lp_lp_sym27__,
                    ((((stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(lcm_sym201__, "lcm_sym201__",
                              stan::model::index_min_max(1, 1)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(nu, "nu", stan::model::index_uni(2))))
                    +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym203__, "lcm_sym203__",
                          stan::model::index_min_max(2, lcm_sym207__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                          stan::model::index_uni(1),
                          stan::model::index_min_max(2, lcm_sym207__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(p, "p", stan::model::index_uni(1),
                        stan::model::index_uni(lcm_sym255__)))),
                    "assigning variable inline_js_super_lp_lp_sym27__",
                    stan::model::index_uni(2));
                  for (int inline_js_super_lp_t_sym28__ = 3; inline_js_super_lp_t_sym28__
                       <= lcm_sym207__; ++inline_js_super_lp_t_sym28__) {
                    current_statement__ = 95;
                    stan::model::assign(inline_js_super_lp_lp_sym27__,
                      ((((stan::math::bernoulli_lpmf<false>(1,
                            stan::math::prod(
                              stan::model::rvalue(lcm_sym201__,
                                "lcm_sym201__",
                                stan::model::index_min_max(1,
                                  (inline_js_super_lp_t_sym28__ - 1))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        nu[(inline_js_super_lp_t_sym28__ - 1)])) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym203__, "lcm_sym203__",
                            stan::model::index_min_max(
                              inline_js_super_lp_t_sym28__, lcm_sym207__)))))
                      +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                            stan::model::index_uni(1),
                            stan::model::index_min_max(
                              inline_js_super_lp_t_sym28__, lcm_sym207__)))))
                      +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(p, "p",
                          stan::model::index_uni(1),
                          stan::model::index_uni(lcm_sym255__)))),
                      "assigning variable inline_js_super_lp_lp_sym27__",
                      stan::model::index_uni(inline_js_super_lp_t_sym28__));
                  }
                }
                current_statement__ = 97;
                stan::model::assign(inline_js_super_lp_lp_sym27__,
                  ((stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym201__, "lcm_sym201__",
                          stan::model::index_min_max(1, lcm_sym207__)))) +
                  stan::math::bernoulli_lpmf<false>(1, nu[(lcm_sym255__ - 1)]))
                  +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(p, "p", stan::model::index_uni(1),
                      stan::model::index_uni(lcm_sym255__)))),
                  "assigning variable inline_js_super_lp_lp_sym27__",
                  stan::model::index_uni(lcm_sym255__));
                current_statement__ = 98;
                lp_accum__.add(stan::math::log_sum_exp(
                                 inline_js_super_lp_lp_sym27__));
              }
              lcm_sym257__ = stan::model::rvalue(last, "last",
                               stan::model::index_uni(1));
              if (stan::math::logical_gte(lcm_sym257__, (lcm_sym255__ + 1))) {
                current_statement__ = 103;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(lcm_sym252__,
                                   "lcm_sym252__", stan::model::index_uni(1),
                                   stan::model::index_uni(((lcm_sym255__ + 1)
                                     - 1)))));
                lcm_sym226__ = ((lcm_sym255__ + 1) + 1);
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((lcm_sym255__ + 1))),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((lcm_sym255__ + 1)))));
                for (int inline_js_super_lp_t_sym28__ = lcm_sym226__; inline_js_super_lp_t_sym28__
                     <= lcm_sym257__; ++inline_js_super_lp_t_sym28__) {
                  current_statement__ = 103;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(lcm_sym252__,
                                     "lcm_sym252__",
                                     stan::model::index_uni(1),
                                     stan::model::index_uni(
                                       (inline_js_super_lp_t_sym28__ - 1)))));
                  current_statement__ = 104;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(1),
                                     stan::model::index_uni(
                                       inline_js_super_lp_t_sym28__)),
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(1),
                                     stan::model::index_uni(
                                       inline_js_super_lp_t_sym28__))));
                }
              }
              current_statement__ = 106;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(
                                 inline_prob_uncaptured_return_sym14__,
                                 "inline_prob_uncaptured_return_sym14__",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(lcm_sym257__))));
            } else {
              lcm_sym228__ = (lcm_sym260__ + 1);
              stan::math::validate_non_negative_index("lp",
                "n_occasions + 1", lcm_sym228__);
              Eigen::Matrix<local_scalar_t__,-1,1>
                inline_js_super_lp_lp_sym27__ =
                Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym228__,
                  DUMMY_VAR__);
              current_statement__ = 86;
              stan::model::assign(inline_js_super_lp_lp_sym27__,
                (((stan::math::bernoulli_lpmf<false>(1, psi) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(nu, "nu", stan::model::index_uni(1))))
                +
                stan::math::bernoulli_lpmf<false>(0,
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni(1)))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(inline_prob_uncaptured_return_sym14__,
                    "inline_prob_uncaptured_return_sym14__",
                    stan::model::index_uni(1), stan::model::index_uni(1)))),
                "assigning variable inline_js_super_lp_lp_sym27__",
                stan::model::index_uni(1));
              current_statement__ = 88;
              if (stan::math::logical_gte(lcm_sym260__, 2)) {
                current_statement__ = 87;
                stan::model::assign(inline_js_super_lp_lp_sym27__,
                  ((((stan::math::bernoulli_lpmf<false>(1, psi) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym201__, "lcm_sym201__",
                        stan::model::index_min_max(1, 1))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(nu, "nu", stan::model::index_uni(2))))
                  +
                  stan::math::bernoulli_lpmf<false>(0,
                    stan::model::rvalue(p, "p", stan::model::index_uni(1),
                      stan::model::index_uni(2)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(
                      inline_prob_uncaptured_return_sym14__,
                      "inline_prob_uncaptured_return_sym14__",
                      stan::model::index_uni(1), stan::model::index_uni(2)))),
                  "assigning variable inline_js_super_lp_lp_sym27__",
                  stan::model::index_uni(2));
                for (int inline_js_super_lp_t_sym28__ = 3; inline_js_super_lp_t_sym28__
                     <= lcm_sym260__; ++inline_js_super_lp_t_sym28__) {
                  current_statement__ = 87;
                  stan::model::assign(inline_js_super_lp_lp_sym27__,
                    ((((stan::math::bernoulli_lpmf<false>(1, psi) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym201__, "lcm_sym201__",
                          stan::model::index_min_max(1,
                            (inline_js_super_lp_t_sym28__ - 1)))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      nu[(inline_js_super_lp_t_sym28__ - 1)])) +
                    stan::math::bernoulli_lpmf<false>(0,
                      stan::model::rvalue(p, "p", stan::model::index_uni(1),
                        stan::model::index_uni(inline_js_super_lp_t_sym28__))))
                    +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(
                        inline_prob_uncaptured_return_sym14__,
                        "inline_prob_uncaptured_return_sym14__",
                        stan::model::index_uni(1),
                        stan::model::index_uni(inline_js_super_lp_t_sym28__)))),
                    "assigning variable inline_js_super_lp_lp_sym27__",
                    stan::model::index_uni(inline_js_super_lp_t_sym28__));
                }
              }
              current_statement__ = 89;
              stan::model::assign(inline_js_super_lp_lp_sym27__,
                stan::math::bernoulli_lpmf<false>(0, psi),
                "assigning variable inline_js_super_lp_lp_sym27__",
                stan::model::index_uni(lcm_sym228__));
              current_statement__ = 90;
              lp_accum__.add(stan::math::log_sum_exp(
                               inline_js_super_lp_lp_sym27__));
            }
            for (int inline_js_super_lp_i_sym29__ = 2; inline_js_super_lp_i_sym29__
                 <= lcm_sym259__; ++inline_js_super_lp_i_sym29__) {
              current_statement__ = 83;
              stan::math::validate_non_negative_index("qp", "n_occasions",
                lcm_sym260__);
              stan::math::var_value<Eigen::Matrix<double,-1,1>>
                inline_js_super_lp_qp_sym26__ =
                Eigen::Matrix<double,-1,1>::Constant(lcm_sym260__,
                  std::numeric_limits<double>::quiet_NaN());
              stan::model::assign(lcm_sym202__,
                stan::math::subtract(1.0,
                  stan::math::transpose(
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_js_super_lp_i_sym29__)))),
                "assigning variable lcm_sym202__");
              lcm_sym254__ = first[(inline_js_super_lp_i_sym29__ - 1)];
              if (lcm_sym254__) {
                current_statement__ = 92;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1, psi));
                current_statement__ = 102;
                if (stan::math::logical_eq(lcm_sym254__, 1)) {
                  current_statement__ = 100;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   (stan::model::rvalue(nu, "nu",
                                      stan::model::index_uni(1)) *
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(
                                       inline_js_super_lp_i_sym29__),
                                     stan::model::index_uni(1)))));
                } else {
                  current_statement__ = 93;
                  stan::math::validate_non_negative_index("lp", "first[i]",
                    lcm_sym254__);
                  Eigen::Matrix<local_scalar_t__,-1,1>
                    inline_js_super_lp_lp_sym27__ =
                    Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym254__,
                      DUMMY_VAR__);
                  lcm_sym206__ = (lcm_sym254__ - 1);
                  stan::model::assign(inline_js_super_lp_lp_sym27__,
                    (((stan::math::bernoulli_lpmf<false>(1,
                         stan::model::rvalue(nu, "nu",
                           stan::model::index_uni(1))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym202__, "lcm_sym202__",
                          stan::model::index_min_max(1, lcm_sym206__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                          stan::model::index_uni(inline_js_super_lp_i_sym29__),
                          stan::model::index_min_max(1, lcm_sym206__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(p, "p",
                        stan::model::index_uni(inline_js_super_lp_i_sym29__),
                        stan::model::index_uni(lcm_sym254__)))),
                    "assigning variable inline_js_super_lp_lp_sym27__",
                    stan::model::index_uni(1));
                  current_statement__ = 96;
                  if (stan::math::logical_gte(lcm_sym206__, 2)) {
                    current_statement__ = 95;
                    stan::model::assign(inline_js_super_lp_lp_sym27__,
                      ((((stan::math::bernoulli_lpmf<false>(1,
                            stan::math::prod(
                              stan::model::rvalue(lcm_sym201__,
                                "lcm_sym201__",
                                stan::model::index_min_max(1, 1)))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(nu, "nu",
                          stan::model::index_uni(2)))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym202__, "lcm_sym202__",
                            stan::model::index_min_max(2, lcm_sym206__))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                            stan::model::index_uni(
                              inline_js_super_lp_i_sym29__),
                            stan::model::index_min_max(2, lcm_sym206__))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(p, "p",
                          stan::model::index_uni(inline_js_super_lp_i_sym29__),
                          stan::model::index_uni(lcm_sym254__)))),
                      "assigning variable inline_js_super_lp_lp_sym27__",
                      stan::model::index_uni(2));
                    for (int inline_js_super_lp_t_sym28__ = 3; inline_js_super_lp_t_sym28__
                         <= lcm_sym206__; ++inline_js_super_lp_t_sym28__) {
                      current_statement__ = 95;
                      stan::model::assign(inline_js_super_lp_lp_sym27__,
                        ((((stan::math::bernoulli_lpmf<false>(1,
                              stan::math::prod(
                                stan::model::rvalue(lcm_sym201__,
                                  "lcm_sym201__",
                                  stan::model::index_min_max(1,
                                    (inline_js_super_lp_t_sym28__ - 1))))) +
                        stan::math::bernoulli_lpmf<false>(1,
                          nu[(inline_js_super_lp_t_sym28__ - 1)])) +
                        stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(lcm_sym202__, "lcm_sym202__",
                              stan::model::index_min_max(
                                inline_js_super_lp_t_sym28__, lcm_sym206__)))))
                        +
                        stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(lcm_sym252__, "lcm_sym252__",
                              stan::model::index_uni(
                                inline_js_super_lp_i_sym29__),
                              stan::model::index_min_max(
                                inline_js_super_lp_t_sym28__, lcm_sym206__)))))
                        +
                        stan::math::bernoulli_lpmf<false>(1,
                          stan::model::rvalue(p, "p",
                            stan::model::index_uni(
                              inline_js_super_lp_i_sym29__),
                            stan::model::index_uni(lcm_sym254__)))),
                        "assigning variable inline_js_super_lp_lp_sym27__",
                        stan::model::index_uni(inline_js_super_lp_t_sym28__));
                    }
                  }
                  current_statement__ = 97;
                  stan::model::assign(inline_js_super_lp_lp_sym27__,
                    ((stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym201__, "lcm_sym201__",
                            stan::model::index_min_max(1, lcm_sym206__)))) +
                    stan::math::bernoulli_lpmf<false>(1, nu[(lcm_sym254__ -
                      1)])) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(p, "p",
                        stan::model::index_uni(inline_js_super_lp_i_sym29__),
                        stan::model::index_uni(lcm_sym254__)))),
                    "assigning variable inline_js_super_lp_lp_sym27__",
                    stan::model::index_uni(lcm_sym254__));
                  current_statement__ = 98;
                  lp_accum__.add(stan::math::log_sum_exp(
                                   inline_js_super_lp_lp_sym27__));
                }
                lcm_sym256__ = last[(inline_js_super_lp_i_sym29__ - 1)];
                if (stan::math::logical_gte(lcm_sym256__, (lcm_sym254__ + 1))) {
                  current_statement__ = 103;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(lcm_sym252__,
                                     "lcm_sym252__",
                                     stan::model::index_uni(
                                       inline_js_super_lp_i_sym29__),
                                     stan::model::index_uni(((lcm_sym254__ +
                                       1) - 1)))));
                  lcm_sym225__ = ((lcm_sym254__ + 1) + 1);
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(
                                       inline_js_super_lp_i_sym29__),
                                     stan::model::index_uni((lcm_sym254__ +
                                       1))),
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(
                                       inline_js_super_lp_i_sym29__),
                                     stan::model::index_uni((lcm_sym254__ +
                                       1)))));
                  for (int inline_js_super_lp_t_sym28__ = lcm_sym225__; inline_js_super_lp_t_sym28__
                       <= lcm_sym256__; ++inline_js_super_lp_t_sym28__) {
                    current_statement__ = 103;
                    lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                     stan::model::rvalue(lcm_sym252__,
                                       "lcm_sym252__",
                                       stan::model::index_uni(
                                         inline_js_super_lp_i_sym29__),
                                       stan::model::index_uni(
                                         (inline_js_super_lp_t_sym28__ - 1)))));
                    current_statement__ = 104;
                    lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                     y[(inline_js_super_lp_i_sym29__ -
                                     1)][(inline_js_super_lp_t_sym28__ - 1)],
                                     stan::model::rvalue(p, "p",
                                       stan::model::index_uni(
                                         inline_js_super_lp_i_sym29__),
                                       stan::model::index_uni(
                                         inline_js_super_lp_t_sym28__))));
                  }
                }
                current_statement__ = 106;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(
                                   inline_prob_uncaptured_return_sym14__,
                                   "inline_prob_uncaptured_return_sym14__",
                                   stan::model::index_uni(
                                     inline_js_super_lp_i_sym29__),
                                   stan::model::index_uni(lcm_sym256__))));
              } else {
                lcm_sym228__ = (lcm_sym260__ + 1);
                stan::math::validate_non_negative_index("lp",
                  "n_occasions + 1", lcm_sym228__);
                Eigen::Matrix<local_scalar_t__,-1,1>
                  inline_js_super_lp_lp_sym27__ =
                  Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym228__,
                    DUMMY_VAR__);
                current_statement__ = 86;
                stan::model::assign(inline_js_super_lp_lp_sym27__,
                  (((stan::math::bernoulli_lpmf<false>(1, psi) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(nu, "nu", stan::model::index_uni(1))))
                  +
                  stan::math::bernoulli_lpmf<false>(0,
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_js_super_lp_i_sym29__),
                      stan::model::index_uni(1)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(
                      inline_prob_uncaptured_return_sym14__,
                      "inline_prob_uncaptured_return_sym14__",
                      stan::model::index_uni(inline_js_super_lp_i_sym29__),
                      stan::model::index_uni(1)))),
                  "assigning variable inline_js_super_lp_lp_sym27__",
                  stan::model::index_uni(1));
                current_statement__ = 88;
                if (stan::math::logical_gte(lcm_sym260__, 2)) {
                  current_statement__ = 87;
                  stan::model::assign(inline_js_super_lp_lp_sym27__,
                    ((((stan::math::bernoulli_lpmf<false>(1, psi) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym201__, "lcm_sym201__",
                          stan::model::index_min_max(1, 1))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(nu, "nu", stan::model::index_uni(2))))
                    +
                    stan::math::bernoulli_lpmf<false>(0,
                      stan::model::rvalue(p, "p",
                        stan::model::index_uni(inline_js_super_lp_i_sym29__),
                        stan::model::index_uni(2)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(
                        inline_prob_uncaptured_return_sym14__,
                        "inline_prob_uncaptured_return_sym14__",
                        stan::model::index_uni(inline_js_super_lp_i_sym29__),
                        stan::model::index_uni(2)))),
                    "assigning variable inline_js_super_lp_lp_sym27__",
                    stan::model::index_uni(2));
                  for (int inline_js_super_lp_t_sym28__ = 3; inline_js_super_lp_t_sym28__
                       <= lcm_sym260__; ++inline_js_super_lp_t_sym28__) {
                    current_statement__ = 87;
                    stan::model::assign(inline_js_super_lp_lp_sym27__,
                      ((((stan::math::bernoulli_lpmf<false>(1, psi) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym201__, "lcm_sym201__",
                            stan::model::index_min_max(1,
                              (inline_js_super_lp_t_sym28__ - 1)))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        nu[(inline_js_super_lp_t_sym28__ - 1)])) +
                      stan::math::bernoulli_lpmf<false>(0,
                        stan::model::rvalue(p, "p",
                          stan::model::index_uni(inline_js_super_lp_i_sym29__),
                          stan::model::index_uni(inline_js_super_lp_t_sym28__))))
                      +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(
                          inline_prob_uncaptured_return_sym14__,
                          "inline_prob_uncaptured_return_sym14__",
                          stan::model::index_uni(inline_js_super_lp_i_sym29__),
                          stan::model::index_uni(inline_js_super_lp_t_sym28__)))),
                      "assigning variable inline_js_super_lp_lp_sym27__",
                      stan::model::index_uni(inline_js_super_lp_t_sym28__));
                  }
                }
                current_statement__ = 89;
                stan::model::assign(inline_js_super_lp_lp_sym27__,
                  stan::math::bernoulli_lpmf<false>(0, psi),
                  "assigning variable inline_js_super_lp_lp_sym27__",
                  stan::model::index_uni(lcm_sym228__));
                current_statement__ = 90;
                lp_accum__.add(stan::math::log_sum_exp(
                                 inline_js_super_lp_lp_sym27__));
              }
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "expr_prop_fail6_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym184__;
      int lcm_sym183__;
      double lcm_sym182__;
      int lcm_sym181__;
      int lcm_sym180__;
      int lcm_sym179__;
      int lcm_sym178__;
      double lcm_sym157__;
      int lcm_sym177__;
      int lcm_sym176__;
      int lcm_sym175__;
      int lcm_sym174__;
      int lcm_sym173__;
      int lcm_sym172__;
      int lcm_sym171__;
      double lcm_sym170__;
      int lcm_sym169__;
      int lcm_sym168__;
      int lcm_sym167__;
      Eigen::Matrix<double,-1,-1> lcm_sym166__;
      std::vector<int> lcm_sym165__;
      std::vector<std::vector<int>> lcm_sym164__;
      Eigen::Matrix<double,-1,1> lcm_sym163__;
      double lcm_sym156__;
      double lcm_sym155__;
      double lcm_sym154__;
      double lcm_sym153__;
      double lcm_sym162__;
      double lcm_sym161__;
      double lcm_sym160__;
      double lcm_sym159__;
      int lcm_sym158__;
      int lcm_sym152__;
      int lcm_sym151__;
      int lcm_sym150__;
      int lcm_sym149__;
      double lcm_sym148__;
      int lcm_sym147__;
      int lcm_sym146__;
      double lcm_sym145__;
      int lcm_sym144__;
      int lcm_sym143__;
      int lcm_sym142__;
      int lcm_sym141__;
      int lcm_sym140__;
      int lcm_sym139__;
      int lcm_sym138__;
      int lcm_sym137__;
      int lcm_sym136__;
      int lcm_sym135__;
      int lcm_sym134__;
      int lcm_sym133__;
      int lcm_sym132__;
      int lcm_sym131__;
      double lcm_sym130__;
      double lcm_sym129__;
      Eigen::Matrix<double,-1,1> lcm_sym128__;
      double mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      double mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      double psi;
      current_statement__ = 3;
      psi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(0,
              1, lp__);
      Eigen::Matrix<double,-1,1> beta;
      current_statement__ = 4;
      beta = in__.template read_constrain_lb<
               Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__,
               n_occasions);
      Eigen::Matrix<double,-1,1> epsilon;
      current_statement__ = 5;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      double sigma;
      current_statement__ = 6;
      sigma = in__.template read_constrain_lub<local_scalar_t__,
                jacobian__>(0, 5, lp__);
      Eigen::Matrix<double,-1,-1> phi =
        Eigen::Matrix<double,-1,-1>::Constant(M, (n_occasions - 1),
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> p =
        Eigen::Matrix<double,-1,-1>::Constant(M, n_occasions,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> b =
        Eigen::Matrix<double,-1,1>::Constant(n_occasions,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> nu =
        Eigen::Matrix<double,-1,1>::Constant(n_occasions,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> chi =
        Eigen::Matrix<double,-1,-1>::Constant(M, n_occasions,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(mean_phi);
      out__.write(mean_p);
      out__.write(psi);
      out__.write(beta);
      out__.write(epsilon);
      out__.write(sigma);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      lcm_sym140__ = (n_occasions - 1);
      stan::model::assign(lcm_sym166__,
        stan::math::rep_matrix(mean_phi, M, lcm_sym140__),
        "assigning variable lcm_sym166__");
      stan::model::assign(phi, lcm_sym166__, "assigning variable phi");
      lcm_sym132__ = stan::math::logical_gte(n_occasions, 1);
      if (lcm_sym132__) {
        stan::model::assign(lcm_sym163__,
          stan::math::inv_logit(
            stan::math::add(stan::math::logit(mean_p), epsilon)),
          "assigning variable lcm_sym163__");
        stan::model::assign(p, lcm_sym163__, "assigning variable p",
          stan::model::index_omni(), stan::model::index_uni(1));
        for (int t = 2; t <= n_occasions; ++t) {
          current_statement__ = 17;
          stan::model::assign(p, lcm_sym163__, "assigning variable p",
            stan::model::index_omni(), stan::model::index_uni(t));
        }
      }
      stan::model::assign(lcm_sym128__,
        stan::math::divide(beta, stan::math::sum(beta)),
        "assigning variable lcm_sym128__");
      stan::model::assign(b, lcm_sym128__, "assigning variable b");
      {
        double cum_b = std::numeric_limits<double>::quiet_NaN();
        lcm_sym182__ = stan::model::rvalue(lcm_sym128__, "lcm_sym128__",
                         stan::model::index_uni(1));
        current_statement__ = 19;
        stan::model::assign(nu, lcm_sym182__, "assigning variable nu",
          stan::model::index_uni(1));
        current_statement__ = 23;
        if (stan::math::logical_gte(lcm_sym140__, 2)) {
          current_statement__ = 20;
          stan::model::assign(nu,
            (stan::model::rvalue(lcm_sym128__, "lcm_sym128__",
               stan::model::index_uni(2)) / (1.0 - lcm_sym182__)),
            "assigning variable nu", stan::model::index_uni(2));
          current_statement__ = 21;
          cum_b = (lcm_sym182__ +
            stan::model::rvalue(lcm_sym128__, "lcm_sym128__",
              stan::model::index_uni(2)));
          for (int t = 3; t <= lcm_sym140__; ++t) {
            current_statement__ = 20;
            stan::model::assign(nu,
              (stan::model::rvalue(lcm_sym128__, "lcm_sym128__",
                 stan::model::index_uni(t)) / (1.0 - cum_b)),
              "assigning variable nu", stan::model::index_uni(t));
            current_statement__ = 21;
            cum_b = (cum_b +
              stan::model::rvalue(lcm_sym128__, "lcm_sym128__",
                stan::model::index_uni(t)));
          }
        }
        current_statement__ = 24;
        stan::model::assign(nu, 1.0, "assigning variable nu",
          stan::model::index_uni(n_occasions));
      }
      Eigen::Matrix<double,-1,-1> inline_prob_uncaptured_return_sym1__;
      {
        int inline_prob_uncaptured_n_ind_sym2__ =
          std::numeric_limits<int>::min();
        lcm_sym167__ = stan::math::rows(p);
        int inline_prob_uncaptured_n_occasions_sym3__ =
          std::numeric_limits<int>::min();
        lcm_sym158__ = stan::math::cols(p);
        current_statement__ = 28;
        stan::math::validate_non_negative_index("chi", "n_ind", lcm_sym167__);
        current_statement__ = 29;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          lcm_sym158__);
        Eigen::Matrix<double,-1,-1> inline_prob_uncaptured_chi_sym4__ =
          Eigen::Matrix<double,-1,-1>::Constant(lcm_sym167__, lcm_sym158__,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 38;
        if (stan::math::logical_gte(lcm_sym167__, 1)) {
          current_statement__ = 31;
          stan::model::assign(inline_prob_uncaptured_chi_sym4__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym4__",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym158__));
          lcm_sym142__ = (lcm_sym158__ - 1);
          lcm_sym135__ = stan::math::logical_gte(lcm_sym142__, 1);
          if (lcm_sym135__) {
            int inline_prob_uncaptured_t_curr_sym5__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym6__ =
              std::numeric_limits<int>::min();
            lcm_sym147__ = (lcm_sym142__ + 1);
            current_statement__ = 34;
            stan::model::assign(inline_prob_uncaptured_chi_sym4__,
              stan::math::fma(
                (stan::model::rvalue(lcm_sym166__, "lcm_sym166__",
                   stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym142__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym147__)))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym4__,
                  "inline_prob_uncaptured_chi_sym4__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym147__)), (1 -
                stan::model::rvalue(lcm_sym166__, "lcm_sym166__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym142__)))),
              "assigning variable inline_prob_uncaptured_chi_sym4__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym142__));
            for (int inline_prob_uncaptured_t_sym7__ = 2; inline_prob_uncaptured_t_sym7__
                 <= lcm_sym142__; ++inline_prob_uncaptured_t_sym7__) {
              int inline_prob_uncaptured_t_curr_sym5__ =
                std::numeric_limits<int>::min();
              lcm_sym141__ = (lcm_sym158__ -
                inline_prob_uncaptured_t_sym7__);
              int inline_prob_uncaptured_t_next_sym6__ =
                std::numeric_limits<int>::min();
              lcm_sym146__ = (lcm_sym141__ + 1);
              current_statement__ = 34;
              stan::model::assign(inline_prob_uncaptured_chi_sym4__,
                stan::math::fma(
                  (stan::model::rvalue(lcm_sym166__, "lcm_sym166__",
                     stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym141__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym146__)))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym4__,
                    "inline_prob_uncaptured_chi_sym4__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym146__)), (1 -
                  stan::model::rvalue(lcm_sym166__, "lcm_sym166__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym141__)))),
                "assigning variable inline_prob_uncaptured_chi_sym4__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym141__));
            }
          }
          for (int inline_prob_uncaptured_i_sym8__ = 2; inline_prob_uncaptured_i_sym8__
               <= lcm_sym167__; ++inline_prob_uncaptured_i_sym8__) {
            current_statement__ = 31;
            stan::model::assign(inline_prob_uncaptured_chi_sym4__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym4__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
              stan::model::index_uni(lcm_sym158__));
            current_statement__ = 36;
            if (lcm_sym135__) {
              int inline_prob_uncaptured_t_curr_sym5__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym6__ =
                std::numeric_limits<int>::min();
              lcm_sym147__ = (lcm_sym142__ + 1);
              current_statement__ = 34;
              stan::model::assign(inline_prob_uncaptured_chi_sym4__,
                stan::math::fma(
                  (stan::model::rvalue(lcm_sym166__, "lcm_sym166__",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                     stan::model::index_uni(lcm_sym142__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                    stan::model::index_uni(lcm_sym147__)))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym4__,
                    "inline_prob_uncaptured_chi_sym4__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                    stan::model::index_uni(lcm_sym147__)), (1 -
                  stan::model::rvalue(lcm_sym166__, "lcm_sym166__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                    stan::model::index_uni(lcm_sym142__)))),
                "assigning variable inline_prob_uncaptured_chi_sym4__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                stan::model::index_uni(lcm_sym142__));
              for (int inline_prob_uncaptured_t_sym7__ = 2; inline_prob_uncaptured_t_sym7__
                   <= lcm_sym142__; ++inline_prob_uncaptured_t_sym7__) {
                int inline_prob_uncaptured_t_curr_sym5__ =
                  std::numeric_limits<int>::min();
                lcm_sym141__ = (lcm_sym158__ -
                  inline_prob_uncaptured_t_sym7__);
                int inline_prob_uncaptured_t_next_sym6__ =
                  std::numeric_limits<int>::min();
                lcm_sym146__ = (lcm_sym141__ + 1);
                current_statement__ = 34;
                stan::model::assign(inline_prob_uncaptured_chi_sym4__,
                  stan::math::fma(
                    (stan::model::rvalue(lcm_sym166__, "lcm_sym166__",
                       stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                       stan::model::index_uni(lcm_sym141__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                      stan::model::index_uni(lcm_sym146__)))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym4__,
                      "inline_prob_uncaptured_chi_sym4__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                      stan::model::index_uni(lcm_sym146__)), (1 -
                    stan::model::rvalue(lcm_sym166__, "lcm_sym166__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                      stan::model::index_uni(lcm_sym141__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym4__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                  stan::model::index_uni(lcm_sym141__));
              }
            }
          }
        }
        current_statement__ = 39;
        stan::model::assign(inline_prob_uncaptured_return_sym1__,
          inline_prob_uncaptured_chi_sym4__,
          "assigning variable inline_prob_uncaptured_return_sym1__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym1__,
        "assigning variable chi");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "phi", lcm_sym166__, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "phi", lcm_sym166__, 1);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 8;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 9;
      stan::math::check_simplex(function__, "b", lcm_sym128__);
      current_statement__ = 10;
      stan::math::check_greater_or_equal(function__, "nu", nu, 0);
      current_statement__ = 10;
      stan::math::check_less_or_equal(function__, "nu", nu, 1);
      current_statement__ = 11;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym1__, 0);
      current_statement__ = 11;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym1__, 1);
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym166__);
        out__.write(p);
        out__.write(lcm_sym128__);
        out__.write(nu);
        out__.write(inline_prob_uncaptured_return_sym1__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      double sigma2 = std::numeric_limits<double>::quiet_NaN();
      int Nsuper = std::numeric_limits<int>::min();
      std::vector<int> N =
        std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      std::vector<int> B =
        std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      std::vector<std::vector<int>> z =
        std::vector<std::vector<int>>(M,
          std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      lcm_sym170__ = stan::math::square(sigma);
      sigma2 = lcm_sym170__;
      lcm_sym131__ = stan::math::logical_gte(M, 1);
      if (lcm_sym131__) {
        int q = std::numeric_limits<int>::min();
        current_statement__ = 49;
        if (stan::math::bernoulli_rng(psi, base_rng__)) {
          current_statement__ = 43;
          stan::model::assign(z,
            stan::math::bernoulli_rng(
              stan::model::rvalue(nu, "nu", stan::model::index_uni(1)),
              base_rng__), "assigning variable z", stan::model::index_uni(1),
            stan::model::index_uni(1));
          current_statement__ = 47;
          if (stan::math::logical_gte(n_occasions, 2)) {
            lcm_sym181__ = stan::model::rvalue(z, "z",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1));
            lcm_sym152__ = (1 * (1 - lcm_sym181__));
            q = lcm_sym152__;
            current_statement__ = 44;
            stan::model::assign(z,
              stan::math::bernoulli_rng(
                stan::math::fma(lcm_sym181__,
                  stan::model::rvalue(lcm_sym166__, "lcm_sym166__",
                    stan::model::index_uni(1), stan::model::index_uni(1)),
                  (lcm_sym152__ *
                  stan::model::rvalue(nu, "nu", stan::model::index_uni(2)))),
                base_rng__), "assigning variable z",
              stan::model::index_uni(1), stan::model::index_uni(2));
            for (int t = 3; t <= n_occasions; ++t) {
              current_statement__ = 45;
              q = (q * (1 -
                stan::model::rvalue(z, "z", stan::model::index_uni(1),
                  stan::model::index_uni((t - 1)))));
              current_statement__ = 44;
              stan::model::assign(z,
                stan::math::bernoulli_rng(
                  stan::math::fma(
                    stan::model::rvalue(z, "z", stan::model::index_uni(1),
                      stan::model::index_uni((t - 1))),
                    stan::model::rvalue(lcm_sym166__, "lcm_sym166__",
                      stan::model::index_uni(1),
                      stan::model::index_uni((t - 1))), (q *
                    stan::model::rvalue(nu, "nu", stan::model::index_uni(t)))),
                  base_rng__), "assigning variable z",
                stan::model::index_uni(1), stan::model::index_uni(t));
            }
          }
        } else {
          current_statement__ = 41;
          stan::model::assign(z, stan::math::rep_array(0, n_occasions),
            "assigning variable z", stan::model::index_uni(1),
            stan::model::index_omni());
        }
        for (int i = 2; i <= M; ++i) {
          int q = std::numeric_limits<int>::min();
          current_statement__ = 49;
          if (stan::math::bernoulli_rng(psi, base_rng__)) {
            current_statement__ = 43;
            stan::model::assign(z,
              stan::math::bernoulli_rng(
                stan::model::rvalue(nu, "nu", stan::model::index_uni(1)),
                base_rng__), "assigning variable z",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 47;
            if (stan::math::logical_gte(n_occasions, 2)) {
              lcm_sym151__ = (1 * (1 -
                stan::model::rvalue(z, "z", stan::model::index_uni(i),
                  stan::model::index_uni(1))));
              q = lcm_sym151__;
              current_statement__ = 44;
              stan::model::assign(z,
                stan::math::bernoulli_rng(
                  stan::math::fma(
                    stan::model::rvalue(z, "z", stan::model::index_uni(i),
                      stan::model::index_uni(1)),
                    stan::model::rvalue(lcm_sym166__, "lcm_sym166__",
                      stan::model::index_uni(i), stan::model::index_uni(1)),
                    (lcm_sym151__ *
                    stan::model::rvalue(nu, "nu", stan::model::index_uni(2)))),
                  base_rng__), "assigning variable z",
                stan::model::index_uni(i), stan::model::index_uni(2));
              for (int t = 3; t <= n_occasions; ++t) {
                current_statement__ = 45;
                q = (q * (1 -
                  stan::model::rvalue(z, "z", stan::model::index_uni(i),
                    stan::model::index_uni((t - 1)))));
                current_statement__ = 44;
                stan::model::assign(z,
                  stan::math::bernoulli_rng(
                    stan::math::fma(
                      stan::model::rvalue(z, "z", stan::model::index_uni(i),
                        stan::model::index_uni((t - 1))),
                      stan::model::rvalue(lcm_sym166__, "lcm_sym166__",
                        stan::model::index_uni(i),
                        stan::model::index_uni((t - 1))), (q *
                      stan::model::rvalue(nu, "nu", stan::model::index_uni(t)))),
                    base_rng__), "assigning variable z",
                  stan::model::index_uni(i), stan::model::index_uni(t));
              }
            }
          } else {
            current_statement__ = 41;
            stan::model::assign(z, stan::math::rep_array(0, n_occasions),
              "assigning variable z", stan::model::index_uni(i),
              stan::model::index_omni());
          }
        }
      }
      {
        current_statement__ = 51;
        stan::math::validate_non_negative_index("recruit", "M", M);
        current_statement__ = 52;
        stan::math::validate_non_negative_index("recruit", "n_occasions",
          n_occasions);
        std::vector<std::vector<int>> recruit =
          std::vector<std::vector<int>>(M,
            std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
        current_statement__ = 53;
        stan::model::assign(recruit,
          stan::math::rep_array(0, M, n_occasions),
          "assigning variable recruit");
        current_statement__ = 54;
        stan::math::validate_non_negative_index("Nind", "M", M);
        std::vector<int> Nind =
          std::vector<int>(M, std::numeric_limits<int>::min());
        current_statement__ = 56;
        stan::math::validate_non_negative_index("Nalive", "M", M);
        std::vector<int> Nalive =
          std::vector<int>(M, std::numeric_limits<int>::min());
        current_statement__ = 65;
        if (lcm_sym131__) {
          int f = std::numeric_limits<int>::min();
          int inline_first_capture_return_sym10__;
          int inline_first_capture_early_ret_check_sym12__;
          inline_first_capture_early_ret_check_sym12__ = 0;
          for (int inline_first_capture_iterator_sym13__ = 1; inline_first_capture_iterator_sym13__
               <= 1; ++inline_first_capture_iterator_sym13__) {
            lcm_sym169__ = stan::math::size(
                             stan::model::rvalue(z, "z",
                               stan::model::index_uni(1)));
            for (int inline_first_capture_k_sym11__ = 1; inline_first_capture_k_sym11__
                 <= lcm_sym169__; ++inline_first_capture_k_sym11__) {
              current_statement__ = 60;
              if (stan::model::rvalue(z, "z", stan::model::index_uni(1),
                    stan::model::index_uni(inline_first_capture_k_sym11__))) {
                inline_first_capture_early_ret_check_sym12__ = 1;
                inline_first_capture_return_sym10__ = inline_first_capture_k_sym11__;
                break;
              }
            }
            if (inline_first_capture_early_ret_check_sym12__) {
              break;
            }
            inline_first_capture_early_ret_check_sym12__ = 1;
            inline_first_capture_return_sym10__ = 0;
            break;
          }
          current_statement__ = 63;
          if (stan::math::logical_gt(inline_first_capture_return_sym10__, 0)) {
            current_statement__ = 62;
            stan::model::assign(recruit, 1, "assigning variable recruit",
              stan::model::index_uni(1),
              stan::model::index_uni(inline_first_capture_return_sym10__));
          }
          for (int i = 2; i <= M; ++i) {
            int f = std::numeric_limits<int>::min();
            int inline_first_capture_return_sym10__;
            int inline_first_capture_early_ret_check_sym12__;
            inline_first_capture_early_ret_check_sym12__ = 0;
            for (int inline_first_capture_iterator_sym13__ = 1; inline_first_capture_iterator_sym13__
                 <= 1; ++inline_first_capture_iterator_sym13__) {
              lcm_sym168__ = stan::math::size(
                               stan::model::rvalue(z, "z",
                                 stan::model::index_uni(i)));
              for (int inline_first_capture_k_sym11__ = 1; inline_first_capture_k_sym11__
                   <= lcm_sym168__; ++inline_first_capture_k_sym11__) {
                current_statement__ = 60;
                if (stan::model::rvalue(z, "z", stan::model::index_uni(i),
                      stan::model::index_uni(inline_first_capture_k_sym11__))) {
                  inline_first_capture_early_ret_check_sym12__ = 1;
                  inline_first_capture_return_sym10__ = inline_first_capture_k_sym11__;
                  break;
                }
              }
              if (inline_first_capture_early_ret_check_sym12__) {
                break;
              }
              inline_first_capture_early_ret_check_sym12__ = 1;
              inline_first_capture_return_sym10__ = 0;
              break;
            }
            current_statement__ = 63;
            if (stan::math::logical_gt(inline_first_capture_return_sym10__, 0)) {
              current_statement__ = 62;
              stan::model::assign(recruit, 1, "assigning variable recruit",
                stan::model::index_uni(i),
                stan::model::index_uni(inline_first_capture_return_sym10__));
            }
          }
        }
        current_statement__ = 69;
        if (lcm_sym132__) {
          current_statement__ = 66;
          stan::model::assign(N,
            stan::math::sum(
              stan::model::rvalue(z, "z", stan::model::index_omni(),
                stan::model::index_uni(1))), "assigning variable N",
            stan::model::index_uni(1));
          current_statement__ = 67;
          stan::model::assign(B,
            stan::math::sum(
              stan::model::rvalue(recruit, "recruit",
                stan::model::index_omni(), stan::model::index_uni(1))),
            "assigning variable B", stan::model::index_uni(1));
          for (int t = 2; t <= n_occasions; ++t) {
            current_statement__ = 66;
            stan::model::assign(N,
              stan::math::sum(
                stan::model::rvalue(z, "z", stan::model::index_omni(),
                  stan::model::index_uni(t))), "assigning variable N",
              stan::model::index_uni(t));
            current_statement__ = 67;
            stan::model::assign(B,
              stan::math::sum(
                stan::model::rvalue(recruit, "recruit",
                  stan::model::index_omni(), stan::model::index_uni(t))),
              "assigning variable B", stan::model::index_uni(t));
          }
        }
        current_statement__ = 73;
        if (lcm_sym131__) {
          current_statement__ = 70;
          stan::model::assign(Nind,
            stan::math::sum(
              stan::model::rvalue(z, "z", stan::model::index_uni(1))),
            "assigning variable Nind", stan::model::index_uni(1));
          current_statement__ = 71;
          stan::model::assign(Nalive,
            stan::math::logical_gt(
              stan::model::rvalue(Nind, "Nind", stan::model::index_uni(1)), 0),
            "assigning variable Nalive", stan::model::index_uni(1));
          for (int i = 2; i <= M; ++i) {
            current_statement__ = 70;
            stan::model::assign(Nind,
              stan::math::sum(
                stan::model::rvalue(z, "z", stan::model::index_uni(i))),
              "assigning variable Nind", stan::model::index_uni(i));
            current_statement__ = 71;
            stan::model::assign(Nalive,
              stan::math::logical_gt(
                stan::model::rvalue(Nind, "Nind", stan::model::index_uni(i)),
                0), "assigning variable Nalive", stan::model::index_uni(i));
          }
        }
        current_statement__ = 74;
        Nsuper = stan::math::sum(Nalive);
      }
      current_statement__ = 12;
      stan::math::check_greater_or_equal(function__, "sigma2", lcm_sym170__,
        0);
      current_statement__ = 13;
      stan::math::check_greater_or_equal(function__, "Nsuper", Nsuper, 0);
      current_statement__ = 14;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 15;
      stan::math::check_greater_or_equal(function__, "B", B, 0);
      current_statement__ = 16;
      stan::math::check_greater_or_equal(function__, "z", z, 0);
      current_statement__ = 16;
      stan::math::check_less_or_equal(function__, "z", z, 1);
      out__.write(lcm_sym170__);
      out__.write(Nsuper);
      out__.write(N);
      out__.write(B);
      current_statement__ = 16;
      if (lcm_sym132__) {
        if (lcm_sym131__) {
          out__.write(stan::model::rvalue(z, "z", stan::model::index_uni(1),
                        stan::model::index_uni(1)));
          for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
            out__.write(stan::model::rvalue(z, "z",
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(1)));
          }
        }
        for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym131__) {
            out__.write(stan::model::rvalue(z, "z",
                          stan::model::index_uni(1),
                          stan::model::index_uni(sym1__)));
            for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
              out__.write(z[(sym2__ - 1)][(sym1__ - 1)]);
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      local_scalar_t__ psi;
      current_statement__ = 3;
      psi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, psi);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 4;
      stan::model::assign(beta,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_occasions),
        "assigning variable beta");
      out__.write_free_lb(0, beta);
      Eigen::Matrix<local_scalar_t__,-1,1> epsilon;
      current_statement__ = 5;
      stan::model::assign(epsilon,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(M),
        "assigning variable epsilon");
      out__.write(epsilon);
      local_scalar_t__ sigma;
      current_statement__ = 6;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 5, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mean_phi",
        "double", std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "mean_p", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "psi", "double",
        std::vector<size_t>{});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "beta", "double",
        std::vector<size_t>{static_cast<size_t>(n_occasions)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "epsilon",
        "double", std::vector<size_t>{static_cast<size_t>(M)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "sigma", "double",
        std::vector<size_t>{});
      double lcm_sym127__;
      double lcm_sym126__;
      double lcm_sym125__;
      double lcm_sym124__;
      int lcm_sym123__;
      int lcm_sym122__;
      int lcm_sym121__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = context__.vals_r("mean_phi")[(1 - 1)];
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      out__.write_free_lub(0, 1, mean_p);
      local_scalar_t__ psi;
      current_statement__ = 3;
      psi = context__.vals_r("psi")[(1 - 1)];
      out__.write_free_lub(0, 1, psi);
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_occasions,
          DUMMY_VAR__);
      {
        std::vector<double> beta_flat__;
        current_statement__ = 4;
        beta_flat__ = context__.vals_r("beta");
        pos__ = 1;
        if (stan::math::logical_gte(n_occasions, 1)) {
          stan::model::assign(beta,
            stan::model::rvalue(beta_flat__, "beta_flat__",
              stan::model::index_uni(1)), "assigning variable beta",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
            stan::model::assign(beta, beta_flat__[(pos__ - 1)],
              "assigning variable beta", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_lb(0, beta);
      Eigen::Matrix<local_scalar_t__,-1,1> epsilon =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      {
        std::vector<double> epsilon_flat__;
        current_statement__ = 5;
        epsilon_flat__ = context__.vals_r("epsilon");
        pos__ = 1;
        if (stan::math::logical_gte(M, 1)) {
          stan::model::assign(epsilon,
            stan::model::rvalue(epsilon_flat__, "epsilon_flat__",
              stan::model::index_uni(1)), "assigning variable epsilon",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= M; ++sym1__) {
            stan::model::assign(epsilon, epsilon_flat__[(pos__ - 1)],
              "assigning variable epsilon", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(epsilon);
      local_scalar_t__ sigma;
      current_statement__ = 6;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      out__.write_free_lub(0, 5, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mean_phi", "mean_p", "psi", "beta",
                "epsilon", "sigma"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"phi", "p", "b", "nu", "chi"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string> temp{"sigma2", "Nsuper", "N", "B", "z"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(n_occasions)},
                std::vector<size_t>{static_cast<size_t>(M)},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(M),
               static_cast<size_t>(phi_2dim__)},
             std::vector<size_t>{static_cast<size_t>(M),
               static_cast<size_t>(n_occasions)},
             std::vector<size_t>{static_cast<size_t>(n_occasions)},
             std::vector<size_t>{static_cast<size_t>(n_occasions)},
             std::vector<size_t>{static_cast<size_t>(M),
               static_cast<size_t>(n_occasions)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(n_occasions)},
             std::vector<size_t>{static_cast<size_t>(n_occasions)},
             std::vector<size_t>{static_cast<size_t>(M),
               static_cast<size_t>(n_occasions)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    param_names__.emplace_back(std::string() + "psi");
    for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym347__));
    }
    for (int sym347__ = 1; sym347__ <= M; ++sym347__) {
      param_names__.emplace_back(std::string() + "epsilon" + '.' +
        std::to_string(sym347__));
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym347__ = 1; sym347__ <= phi_2dim__; ++sym347__) {
        for (int sym348__ = 1; sym348__ <= M; ++sym348__) {
          param_names__.emplace_back(std::string() + "phi" + '.' +
            std::to_string(sym348__) + '.' + std::to_string(sym347__));
        }
      }
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        for (int sym348__ = 1; sym348__ <= M; ++sym348__) {
          param_names__.emplace_back(std::string() + "p" + '.' +
            std::to_string(sym348__) + '.' + std::to_string(sym347__));
        }
      }
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        param_names__.emplace_back(std::string() + "b" + '.' +
          std::to_string(sym347__));
      }
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        param_names__.emplace_back(std::string() + "nu" + '.' +
          std::to_string(sym347__));
      }
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        for (int sym348__ = 1; sym348__ <= M; ++sym348__) {
          param_names__.emplace_back(std::string() + "chi" + '.' +
            std::to_string(sym348__) + '.' + std::to_string(sym347__));
        }
      }
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        param_names__.emplace_back(std::string() + "N" + '.' +
          std::to_string(sym347__));
      }
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        param_names__.emplace_back(std::string() + "B" + '.' +
          std::to_string(sym347__));
      }
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        for (int sym348__ = 1; sym348__ <= M; ++sym348__) {
          param_names__.emplace_back(std::string() + "z" + '.' +
            std::to_string(sym348__) + '.' + std::to_string(sym347__));
        }
      }
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    param_names__.emplace_back(std::string() + "psi");
    for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym347__));
    }
    for (int sym347__ = 1; sym347__ <= M; ++sym347__) {
      param_names__.emplace_back(std::string() + "epsilon" + '.' +
        std::to_string(sym347__));
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym347__ = 1; sym347__ <= phi_2dim__; ++sym347__) {
        for (int sym348__ = 1; sym348__ <= M; ++sym348__) {
          param_names__.emplace_back(std::string() + "phi" + '.' +
            std::to_string(sym348__) + '.' + std::to_string(sym347__));
        }
      }
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        for (int sym348__ = 1; sym348__ <= M; ++sym348__) {
          param_names__.emplace_back(std::string() + "p" + '.' +
            std::to_string(sym348__) + '.' + std::to_string(sym347__));
        }
      }
      for (int sym347__ = 1; sym347__ <= (n_occasions - 1); ++sym347__) {
        param_names__.emplace_back(std::string() + "b" + '.' +
          std::to_string(sym347__));
      }
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        param_names__.emplace_back(std::string() + "nu" + '.' +
          std::to_string(sym347__));
      }
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        for (int sym348__ = 1; sym348__ <= M; ++sym348__) {
          param_names__.emplace_back(std::string() + "chi" + '.' +
            std::to_string(sym348__) + '.' + std::to_string(sym347__));
        }
      }
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        param_names__.emplace_back(std::string() + "N" + '.' +
          std::to_string(sym347__));
      }
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        param_names__.emplace_back(std::string() + "B" + '.' +
          std::to_string(sym347__));
      }
      for (int sym347__ = 1; sym347__ <= n_occasions; ++sym347__) {
        for (int sym348__ = 1; sym348__ <= M; ++sym348__) {
          param_names__.emplace_back(std::string() + "z" + '.' +
            std::to_string(sym348__) + '.' + std::to_string(sym347__));
        }
      }
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(phi_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"nu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(phi_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((n_occasions -1)) + "},\"block\":\"transformed_parameters\"},{\"name\":\"nu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((1 + 1) + 1) + n_occasions) + M) + 1);
    const size_t num_transformed = emit_transformed_parameters * ((((((M *
      phi_2dim__) + (M * n_occasions)) + n_occasions) + n_occasions) + (M *
      n_occasions)));
    const size_t num_gen_quantities = emit_generated_quantities * (((((1 + 1)
      + n_occasions) + n_occasions) + (M * n_occasions)));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((1 + 1) + 1) + n_occasions) + M) + 1);
    const size_t num_transformed = emit_transformed_parameters * ((((((M *
      phi_2dim__) + (M * n_occasions)) + n_occasions) + n_occasions) + (M *
      n_occasions)));
    const size_t num_gen_quantities = emit_generated_quantities * (((((1 + 1)
      + n_occasions) + n_occasions) + (M * n_occasions)));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = expr_prop_fail6_model_namespace::expr_prop_fail6_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail6_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail7.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail7_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 37> locations_array__ =
  {" (found before start of program)",
  " (in 'expr-prop-fail7.stan', line 20, column 2 to column 16)",
  " (in 'expr-prop-fail7.stan', line 21, column 2 to column 31)",
  " (in 'expr-prop-fail7.stan', line 40, column 2 to column 30)",
  " (in 'expr-prop-fail7.stan', line 42, column 11 to column 12)",
  " (in 'expr-prop-fail7.stan', line 42, column 4 to column 30)",
  " (in 'expr-prop-fail7.stan', line 44, column 6 to column 52)",
  " (in 'expr-prop-fail7.stan', line 45, column 4 to column 45)",
  " (in 'expr-prop-fail7.stan', line 43, column 4 to line 44, column 52)",
  " (in 'expr-prop-fail7.stan', line 41, column 19 to line 46, column 3)",
  " (in 'expr-prop-fail7.stan', line 25, column 2 to column 24)",
  " (in 'expr-prop-fail7.stan', line 28, column 6 to column 39)",
  " (in 'expr-prop-fail7.stan', line 27, column 4 to line 28, column 39)",
  " (in 'expr-prop-fail7.stan', line 32, column 11 to column 12)",
  " (in 'expr-prop-fail7.stan', line 32, column 4 to column 30)",
  " (in 'expr-prop-fail7.stan', line 34, column 6 to column 54)",
  " (in 'expr-prop-fail7.stan', line 33, column 4 to line 34, column 54)",
  " (in 'expr-prop-fail7.stan', line 35, column 4 to column 33)",
  " (in 'expr-prop-fail7.stan', line 31, column 19 to line 36, column 3)",
  " (in 'expr-prop-fail7.stan', line 31, column 2 to line 36, column 3)",
  " (in 'expr-prop-fail7.stan', line 12, column 2 to column 17)",
  " (in 'expr-prop-fail7.stan', line 13, column 2 to column 17)",
  " (in 'expr-prop-fail7.stan', line 14, column 2 to column 17)",
  " (in 'expr-prop-fail7.stan', line 15, column 8 to column 9)",
  " (in 'expr-prop-fail7.stan', line 15, column 11 to column 12)",
  " (in 'expr-prop-fail7.stan', line 15, column 2 to column 38)",
  " (in 'expr-prop-fail7.stan', line 16, column 18 to column 19)",
  " (in 'expr-prop-fail7.stan', line 16, column 2 to column 27)",
  " (in 'expr-prop-fail7.stan', line 17, column 8 to column 9)",
  " (in 'expr-prop-fail7.stan', line 17, column 27 to column 28)",
  " (in 'expr-prop-fail7.stan', line 17, column 2 to column 35)",
  " (in 'expr-prop-fail7.stan', line 20, column 10 to column 11)",
  " (in 'expr-prop-fail7.stan', line 21, column 8 to column 9)",
  " (in 'expr-prop-fail7.stan', line 21, column 11 to column 12)",
  " (in 'expr-prop-fail7.stan', line 21, column 22 to column 23)",
  " (in 'expr-prop-fail7.stan', line 40, column 8 to column 9)",
  " (in 'expr-prop-fail7.stan', line 40, column 18 to column 19)"};
class expr_prop_fail7_model final : public model_base_crtp<expr_prop_fail7_model> {
 private:
  int lcm_sym68__;
  int lcm_sym67__;
  double lcm_sym66__;
  double lcm_sym65__;
  double lcm_sym64__;
  double lcm_sym63__;
  int lcm_sym62__;
  int lcm_sym61__;
  int lcm_sym60__;
  int lcm_sym59__;
  int K;
  int I;
  int J;
  std::vector<std::vector<int>> y;
  Eigen::Matrix<double,-1,1> alpha_data__;
  std::vector<Eigen::Matrix<double,-1,1>> beta;
  Eigen::Map<Eigen::Matrix<double,-1,1>> alpha{nullptr, 0};
 public:
  ~expr_prop_fail7_model() {}
  expr_prop_fail7_model(stan::io::var_context& context__, unsigned int
                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "expr_prop_fail7_model_namespace::expr_prop_fail7_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 20;
      context__.validate_dims("data initialization", "K", "int",
        std::vector<size_t>{});
      K = std::numeric_limits<int>::min();
      current_statement__ = 20;
      K = context__.vals_i("K")[(1 - 1)];
      current_statement__ = 20;
      stan::math::check_greater_or_equal(function__, "K", K, 2);
      current_statement__ = 21;
      context__.validate_dims("data initialization", "I", "int",
        std::vector<size_t>{});
      I = std::numeric_limits<int>::min();
      current_statement__ = 21;
      I = context__.vals_i("I")[(1 - 1)];
      current_statement__ = 21;
      stan::math::check_greater_or_equal(function__, "I", I, 1);
      current_statement__ = 22;
      context__.validate_dims("data initialization", "J", "int",
        std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      current_statement__ = 22;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 22;
      stan::math::check_greater_or_equal(function__, "J", J, 1);
      current_statement__ = 23;
      stan::math::validate_non_negative_index("y", "I", I);
      current_statement__ = 24;
      stan::math::validate_non_negative_index("y", "J", J);
      current_statement__ = 25;
      context__.validate_dims("data initialization", "y", "int",
        std::vector<size_t>{static_cast<size_t>(I), static_cast<size_t>(J)});
      y = std::vector<std::vector<int>>(I,
            std::vector<int>(J, std::numeric_limits<int>::min()));
      {
        std::vector<int> y_flat__;
        current_statement__ = 25;
        y_flat__ = context__.vals_i("y");
        pos__ = 1;
        if (stan::math::logical_gte(J, 1)) {
          lcm_sym59__ = stan::math::logical_gte(I, 1);
          if (lcm_sym59__) {
            stan::model::assign(y,
              stan::model::rvalue(y_flat__, "y_flat__",
                stan::model::index_uni(1)), "assigning variable y",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= J; ++sym1__) {
            if (lcm_sym59__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
                stan::model::assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 25;
      stan::math::check_greater_or_equal(function__, "y", y, 1);
      current_statement__ = 25;
      stan::math::check_less_or_equal(function__, "y", y, K);
      current_statement__ = 26;
      stan::math::validate_non_negative_index("alpha", "K", K);
      current_statement__ = 27;
      context__.validate_dims("data initialization", "alpha", "double",
        std::vector<size_t>{static_cast<size_t>(K)});
      alpha_data__ = Eigen::Matrix<double,-1,1>::Constant(K,
                       std::numeric_limits<double>::quiet_NaN());
      new (&alpha)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(alpha_data__.data(), K);
      {
        std::vector<double> alpha_flat__;
        current_statement__ = 27;
        alpha_flat__ = context__.vals_r("alpha");
        pos__ = 1;
        lcm_sym61__ = stan::math::logical_gte(K, 1);
        if (lcm_sym61__) {
          stan::model::assign(alpha,
            stan::model::rvalue(alpha_flat__, "alpha_flat__",
              stan::model::index_uni(1)), "assigning variable alpha",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
            stan::model::assign(alpha, alpha_flat__[(pos__ - 1)],
              "assigning variable alpha", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 27;
      stan::math::check_greater_or_equal(function__, "alpha", alpha, 0);
      current_statement__ = 28;
      stan::math::validate_non_negative_index("beta", "K", K);
      current_statement__ = 29;
      stan::math::validate_non_negative_index("beta", "K", K);
      current_statement__ = 30;
      context__.validate_dims("data initialization", "beta", "double",
        std::vector<size_t>{static_cast<size_t>(K), static_cast<size_t>(K)});
      beta = std::vector<Eigen::Matrix<double,-1,1>>(K,
               Eigen::Matrix<double,-1,1>::Constant(K,
                 std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<double> beta_flat__;
        current_statement__ = 30;
        beta_flat__ = context__.vals_r("beta");
        pos__ = 1;
        if (lcm_sym61__) {
          if (lcm_sym61__) {
            stan::model::assign(beta,
              stan::model::rvalue(beta_flat__, "beta_flat__",
                stan::model::index_uni(1)), "assigning variable beta",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
              stan::model::assign(beta, beta_flat__[(pos__ - 1)],
                "assigning variable beta", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
            if (lcm_sym61__) {
              stan::model::assign(beta, beta_flat__[(pos__ - 1)],
                "assigning variable beta", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
                stan::model::assign(beta, beta_flat__[(pos__ - 1)],
                  "assigning variable beta", stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "beta", beta, 0);
      current_statement__ = 31;
      stan::math::validate_positive_index("pi", "K", K);
      current_statement__ = 32;
      stan::math::validate_non_negative_index("theta", "J", J);
      current_statement__ = 33;
      stan::math::validate_non_negative_index("theta", "K", K);
      current_statement__ = 34;
      stan::math::validate_positive_index("theta", "K", K);
      current_statement__ = 35;
      stan::math::validate_non_negative_index("log_Pr_z", "I", I);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("log_Pr_z", "K", K);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (K - 1) + (J * (K * (K - 1)));
  }
  inline std::string model_name() const final {
    return "expr_prop_fail7_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail7_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym58__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym57__;
      double lcm_sym56__;
      double lcm_sym55__;
      double lcm_sym54__;
      double lcm_sym53__;
      double lcm_sym52__;
      Eigen::Matrix<double,-1,1> lcm_sym51__;
      Eigen::Matrix<double,-1,1> lcm_sym50__;
      Eigen::Matrix<double,-1,1> lcm_sym49__;
      Eigen::Matrix<double,-1,1> lcm_sym48__;
      int lcm_sym47__;
      int lcm_sym46__;
      int lcm_sym45__;
      Eigen::Matrix<local_scalar_t__,-1,1> pi;
      current_statement__ = 1;
      pi = in__.template read_constrain_simplex<
             Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lp__, K);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> theta =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(J,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__)));
      current_statement__ = 2;
      theta = in__.template read_constrain_simplex<
                std::vector<
                  std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>,
                jacobian__>(lp__, J, K, K);
      {
        current_statement__ = 10;
        lp_accum__.add(stan::math::dirichlet_lpdf<propto__>(pi, alpha));
        lcm_sym46__ = stan::math::logical_gte(J, 1);
        if (lcm_sym46__) {
          lcm_sym47__ = stan::math::logical_gte(K, 1);
          if (lcm_sym47__) {
            current_statement__ = 11;
            lp_accum__.add(stan::math::dirichlet_lpdf<propto__>(
                             stan::model::rvalue(theta, "theta",
                               stan::model::index_uni(1),
                               stan::model::index_uni(1)),
                             stan::model::rvalue(beta, "beta",
                               stan::model::index_uni(1))));
            for (int k = 2; k <= K; ++k) {
              current_statement__ = 11;
              lp_accum__.add(stan::math::dirichlet_lpdf<propto__>(
                               stan::model::rvalue(theta, "theta",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(k)),
                               stan::model::rvalue(beta, "beta",
                                 stan::model::index_uni(k))));
            }
          }
          for (int j = 2; j <= J; ++j) {
            current_statement__ = 12;
            if (lcm_sym47__) {
              current_statement__ = 11;
              lp_accum__.add(stan::math::dirichlet_lpdf<propto__>(
                               stan::model::rvalue(theta, "theta",
                                 stan::model::index_uni(j),
                                 stan::model::index_uni(1)),
                               stan::model::rvalue(beta, "beta",
                                 stan::model::index_uni(1))));
              for (int k = 2; k <= K; ++k) {
                current_statement__ = 11;
                lp_accum__.add(stan::math::dirichlet_lpdf<propto__>(
                                 stan::model::rvalue(theta, "theta",
                                   stan::model::index_uni(j),
                                   stan::model::index_uni(k)),
                                 stan::model::rvalue(beta, "beta",
                                   stan::model::index_uni(k))));
              }
            }
          }
        }
        current_statement__ = 19;
        if (stan::math::logical_gte(I, 1)) {
          current_statement__ = 13;
          stan::math::validate_non_negative_index("log_q", "K", K);
          Eigen::Matrix<local_scalar_t__,-1,1> log_q =
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
          stan::model::assign(lcm_sym57__, stan::math::log(pi),
            "assigning variable lcm_sym57__");
          stan::model::assign(log_q, lcm_sym57__, "assigning variable log_q");
          current_statement__ = 16;
          if (lcm_sym46__) {
            current_statement__ = 15;
            stan::model::assign(log_q,
              stan::math::add(lcm_sym57__,
                stan::math::to_vector(
                  stan::math::log(
                    stan::model::rvalue(theta, "theta",
                      stan::model::index_uni(1), stan::model::index_omni(),
                      stan::model::index_uni(
                        stan::model::rvalue(y, "y",
                          stan::model::index_uni(1),
                          stan::model::index_uni(1))))))),
              "assigning variable log_q");
            for (int j = 2; j <= J; ++j) {
              current_statement__ = 15;
              stan::model::assign(log_q,
                stan::math::add(stan::model::deep_copy(log_q),
                  stan::math::to_vector(
                    stan::math::log(
                      stan::model::rvalue(theta, "theta",
                        stan::model::index_uni(j), stan::model::index_omni(),
                        stan::model::index_uni(
                          stan::model::rvalue(y, "y",
                            stan::model::index_uni(1),
                            stan::model::index_uni(j))))))),
                "assigning variable log_q");
            }
          }
          current_statement__ = 17;
          lp_accum__.add(stan::math::log_sum_exp(log_q));
          for (int i = 2; i <= I; ++i) {
            current_statement__ = 13;
            stan::math::validate_non_negative_index("log_q", "K", K);
            Eigen::Matrix<local_scalar_t__,-1,1> log_q;
            current_statement__ = 14;
            stan::model::assign(log_q, lcm_sym57__,
              "assigning variable log_q");
            current_statement__ = 16;
            if (lcm_sym46__) {
              current_statement__ = 15;
              stan::model::assign(log_q,
                stan::math::add(lcm_sym57__,
                  stan::math::to_vector(
                    stan::math::log(
                      stan::model::rvalue(theta, "theta",
                        stan::model::index_uni(1), stan::model::index_omni(),
                        stan::model::index_uni(
                          stan::model::rvalue(y, "y",
                            stan::model::index_uni(i),
                            stan::model::index_uni(1))))))),
                "assigning variable log_q");
              for (int j = 2; j <= J; ++j) {
                current_statement__ = 15;
                stan::model::assign(log_q,
                  stan::math::add(stan::model::deep_copy(log_q),
                    stan::math::to_vector(
                      stan::math::log(
                        stan::model::rvalue(theta, "theta",
                          stan::model::index_uni(j),
                          stan::model::index_omni(),
                          stan::model::index_uni(
                            stan::model::rvalue(y, "y",
                              stan::model::index_uni(i),
                              stan::model::index_uni(j))))))),
                  "assigning variable log_q");
              }
            }
            current_statement__ = 17;
            lp_accum__.add(stan::math::log_sum_exp(log_q));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail7_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym44__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym43__;
      double lcm_sym42__;
      double lcm_sym41__;
      double lcm_sym40__;
      double lcm_sym39__;
      double lcm_sym38__;
      Eigen::Matrix<double,-1,1> lcm_sym37__;
      Eigen::Matrix<double,-1,1> lcm_sym36__;
      Eigen::Matrix<double,-1,1> lcm_sym35__;
      Eigen::Matrix<double,-1,1> lcm_sym34__;
      int lcm_sym33__;
      int lcm_sym32__;
      int lcm_sym31__;
      stan::math::var_value<Eigen::Matrix<double,-1,1>> pi;
      current_statement__ = 1;
      pi = in__.template read_constrain_simplex<
             stan::math::var_value<Eigen::Matrix<double,-1,1>>,
             jacobian__>(lp__, K);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> theta =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(J,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__)));
      current_statement__ = 2;
      theta = in__.template read_constrain_simplex<
                std::vector<
                  std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>,
                jacobian__>(lp__, J, K, K);
      {
        current_statement__ = 10;
        lp_accum__.add(stan::math::dirichlet_lpdf<propto__>(pi, alpha));
        lcm_sym32__ = stan::math::logical_gte(J, 1);
        if (lcm_sym32__) {
          lcm_sym33__ = stan::math::logical_gte(K, 1);
          if (lcm_sym33__) {
            current_statement__ = 11;
            lp_accum__.add(stan::math::dirichlet_lpdf<propto__>(
                             stan::model::rvalue(theta, "theta",
                               stan::model::index_uni(1),
                               stan::model::index_uni(1)),
                             stan::model::rvalue(beta, "beta",
                               stan::model::index_uni(1))));
            for (int k = 2; k <= K; ++k) {
              current_statement__ = 11;
              lp_accum__.add(stan::math::dirichlet_lpdf<propto__>(
                               stan::model::rvalue(theta, "theta",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(k)),
                               stan::model::rvalue(beta, "beta",
                                 stan::model::index_uni(k))));
            }
          }
          for (int j = 2; j <= J; ++j) {
            current_statement__ = 12;
            if (lcm_sym33__) {
              current_statement__ = 11;
              lp_accum__.add(stan::math::dirichlet_lpdf<propto__>(
                               stan::model::rvalue(theta, "theta",
                                 stan::model::index_uni(j),
                                 stan::model::index_uni(1)),
                               stan::model::rvalue(beta, "beta",
                                 stan::model::index_uni(1))));
              for (int k = 2; k <= K; ++k) {
                current_statement__ = 11;
                lp_accum__.add(stan::math::dirichlet_lpdf<propto__>(
                                 stan::model::rvalue(theta, "theta",
                                   stan::model::index_uni(j),
                                   stan::model::index_uni(k)),
                                 stan::model::rvalue(beta, "beta",
                                   stan::model::index_uni(k))));
              }
            }
          }
        }
        current_statement__ = 19;
        if (stan::math::logical_gte(I, 1)) {
          current_statement__ = 13;
          stan::math::validate_non_negative_index("log_q", "K", K);
          stan::math::var_value<Eigen::Matrix<double,-1,1>> log_q =
            stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(K,
                                                                std::numeric_limits<double>::quiet_NaN(
                                                                  )));
          stan::model::assign(lcm_sym43__, stan::math::log(pi),
            "assigning variable lcm_sym43__");
          stan::model::assign(log_q, lcm_sym43__, "assigning variable log_q");
          current_statement__ = 16;
          if (lcm_sym32__) {
            current_statement__ = 15;
            stan::model::assign(log_q,
              stan::math::add(lcm_sym43__,
                stan::math::to_vector(
                  stan::math::log(
                    stan::model::rvalue(theta, "theta",
                      stan::model::index_uni(1), stan::model::index_omni(),
                      stan::model::index_uni(
                        stan::model::rvalue(y, "y",
                          stan::model::index_uni(1),
                          stan::model::index_uni(1))))))),
              "assigning variable log_q");
            for (int j = 2; j <= J; ++j) {
              current_statement__ = 15;
              stan::model::assign(log_q,
                stan::math::add(stan::model::deep_copy(log_q),
                  stan::math::to_vector(
                    stan::math::log(
                      stan::model::rvalue(theta, "theta",
                        stan::model::index_uni(j), stan::model::index_omni(),
                        stan::model::index_uni(
                          stan::model::rvalue(y, "y",
                            stan::model::index_uni(1),
                            stan::model::index_uni(j))))))),
                "assigning variable log_q");
            }
          }
          current_statement__ = 17;
          lp_accum__.add(stan::math::log_sum_exp(log_q));
          for (int i = 2; i <= I; ++i) {
            current_statement__ = 13;
            stan::math::validate_non_negative_index("log_q", "K", K);
            stan::math::var_value<Eigen::Matrix<double,-1,1>> log_q;
            current_statement__ = 14;
            stan::model::assign(log_q, lcm_sym43__,
              "assigning variable log_q");
            current_statement__ = 16;
            if (lcm_sym32__) {
              current_statement__ = 15;
              stan::model::assign(log_q,
                stan::math::add(lcm_sym43__,
                  stan::math::to_vector(
                    stan::math::log(
                      stan::model::rvalue(theta, "theta",
                        stan::model::index_uni(1), stan::model::index_omni(),
                        stan::model::index_uni(
                          stan::model::rvalue(y, "y",
                            stan::model::index_uni(i),
                            stan::model::index_uni(1))))))),
                "assigning variable log_q");
              for (int j = 2; j <= J; ++j) {
                current_statement__ = 15;
                stan::model::assign(log_q,
                  stan::math::add(stan::model::deep_copy(log_q),
                    stan::math::to_vector(
                      stan::math::log(
                        stan::model::rvalue(theta, "theta",
                          stan::model::index_uni(j),
                          stan::model::index_omni(),
                          stan::model::index_uni(
                            stan::model::rvalue(y, "y",
                              stan::model::index_uni(i),
                              stan::model::index_uni(j))))))),
                  "assigning variable log_q");
              }
            }
            current_statement__ = 17;
            lp_accum__.add(stan::math::log_sum_exp(log_q));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "expr_prop_fail7_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym30__;
      double lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      Eigen::Matrix<double,-1,1> lcm_sym18__;
      Eigen::Matrix<double,-1,1> lcm_sym17__;
      Eigen::Matrix<double,-1,1> lcm_sym16__;
      Eigen::Matrix<double,-1,1> lcm_sym15__;
      Eigen::Matrix<double,-1,1> lcm_sym14__;
      int lcm_sym13__;
      int lcm_sym12__;
      Eigen::Matrix<double,-1,1> lcm_sym11__;
      int lcm_sym10__;
      int lcm_sym9__;
      int lcm_sym8__;
      Eigen::Matrix<double,-1,1> pi;
      current_statement__ = 1;
      pi = in__.template read_constrain_simplex<
             Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lp__, K);
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> theta =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(J,
          std::vector<Eigen::Matrix<double,-1,1>>(K,
            Eigen::Matrix<double,-1,1>::Constant(K,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 2;
      theta = in__.template read_constrain_simplex<
                std::vector<
                  std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>,
                jacobian__>(lp__, J, K, K);
      out__.write(pi);
      lcm_sym10__ = stan::math::logical_gte(K, 1);
      if (lcm_sym10__) {
        if (lcm_sym10__) {
          lcm_sym9__ = stan::math::logical_gte(J, 1);
          if (lcm_sym9__) {
            out__.write(stan::model::rvalue(theta, "theta",
                          stan::model::index_uni(1),
                          stan::model::index_uni(1),
                          stan::model::index_uni(1)));
            for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
              out__.write(stan::model::rvalue(theta, "theta",
                            stan::model::index_uni(sym3__),
                            stan::model::index_uni(1),
                            stan::model::index_uni(1)));
            }
          }
          for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
            if (lcm_sym9__) {
              out__.write(stan::model::rvalue(theta, "theta",
                            stan::model::index_uni(1),
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(1)));
              for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                out__.write(stan::model::rvalue(theta, "theta",
                              stan::model::index_uni(sym3__),
                              stan::model::index_uni(sym2__),
                              stan::model::index_uni(1)));
              }
            }
          }
        }
        for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
          if (lcm_sym10__) {
            lcm_sym9__ = stan::math::logical_gte(J, 1);
            if (lcm_sym9__) {
              out__.write(stan::model::rvalue(theta, "theta",
                            stan::model::index_uni(1),
                            stan::model::index_uni(1),
                            stan::model::index_uni(sym1__)));
              for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                out__.write(stan::model::rvalue(theta, "theta",
                              stan::model::index_uni(sym3__),
                              stan::model::index_uni(1),
                              stan::model::index_uni(sym1__)));
              }
            }
            for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
              if (lcm_sym9__) {
                out__.write(stan::model::rvalue(theta, "theta",
                              stan::model::index_uni(1),
                              stan::model::index_uni(sym2__),
                              stan::model::index_uni(sym1__)));
                for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                  out__.write(theta[(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
                    1)]);
                }
              }
            }
          }
        }
      }
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      std::vector<Eigen::Matrix<double,-1,1>> log_Pr_z =
        std::vector<Eigen::Matrix<double,-1,1>>(I,
          Eigen::Matrix<double,-1,1>::Constant(K,
            std::numeric_limits<double>::quiet_NaN()));
      lcm_sym8__ = stan::math::logical_gte(I, 1);
      if (lcm_sym8__) {
        current_statement__ = 4;
        stan::math::validate_non_negative_index("log_q", "K", K);
        Eigen::Matrix<double,-1,1> log_q =
          Eigen::Matrix<double,-1,1>::Constant(K,
            std::numeric_limits<double>::quiet_NaN());
        stan::model::assign(lcm_sym18__, stan::math::log(pi),
          "assigning variable lcm_sym18__");
        stan::model::assign(log_q, lcm_sym18__, "assigning variable log_q");
        lcm_sym9__ = stan::math::logical_gte(J, 1);
        if (lcm_sym9__) {
          current_statement__ = 6;
          stan::model::assign(log_q,
            stan::math::add(lcm_sym18__,
              stan::math::to_vector(
                stan::math::log(
                  stan::model::rvalue(theta, "theta",
                    stan::model::index_uni(1), stan::model::index_omni(),
                    stan::model::index_uni(
                      stan::model::rvalue(y, "y", stan::model::index_uni(1),
                        stan::model::index_uni(1))))))),
            "assigning variable log_q");
          for (int j = 2; j <= J; ++j) {
            current_statement__ = 6;
            stan::model::assign(log_q,
              stan::math::add(stan::model::deep_copy(log_q),
                stan::math::to_vector(
                  stan::math::log(
                    stan::model::rvalue(theta, "theta",
                      stan::model::index_uni(j), stan::model::index_omni(),
                      stan::model::index_uni(
                        stan::model::rvalue(y, "y",
                          stan::model::index_uni(1),
                          stan::model::index_uni(j))))))),
              "assigning variable log_q");
          }
        }
        current_statement__ = 7;
        stan::model::assign(log_Pr_z,
          stan::math::subtract(log_q, stan::math::log_sum_exp(log_q)),
          "assigning variable log_Pr_z", stan::model::index_uni(1));
        for (int i = 2; i <= I; ++i) {
          current_statement__ = 4;
          stan::math::validate_non_negative_index("log_q", "K", K);
          Eigen::Matrix<double,-1,1> log_q;
          current_statement__ = 5;
          stan::model::assign(log_q, lcm_sym18__, "assigning variable log_q");
          current_statement__ = 8;
          if (lcm_sym9__) {
            current_statement__ = 6;
            stan::model::assign(log_q,
              stan::math::add(lcm_sym18__,
                stan::math::to_vector(
                  stan::math::log(
                    stan::model::rvalue(theta, "theta",
                      stan::model::index_uni(1), stan::model::index_omni(),
                      stan::model::index_uni(
                        stan::model::rvalue(y, "y",
                          stan::model::index_uni(i),
                          stan::model::index_uni(1))))))),
              "assigning variable log_q");
            for (int j = 2; j <= J; ++j) {
              current_statement__ = 6;
              stan::model::assign(log_q,
                stan::math::add(stan::model::deep_copy(log_q),
                  stan::math::to_vector(
                    stan::math::log(
                      stan::model::rvalue(theta, "theta",
                        stan::model::index_uni(j), stan::model::index_omni(),
                        stan::model::index_uni(
                          stan::model::rvalue(y, "y",
                            stan::model::index_uni(i),
                            stan::model::index_uni(j))))))),
                "assigning variable log_q");
            }
          }
          current_statement__ = 7;
          stan::model::assign(log_Pr_z,
            stan::math::subtract(log_q, stan::math::log_sum_exp(log_q)),
            "assigning variable log_Pr_z", stan::model::index_uni(i));
        }
      }
      current_statement__ = 3;
      if (lcm_sym10__) {
        if (lcm_sym8__) {
          out__.write(stan::model::rvalue(log_Pr_z, "log_Pr_z",
                        stan::model::index_uni(1), stan::model::index_uni(1)));
          for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
            out__.write(stan::model::rvalue(log_Pr_z, "log_Pr_z",
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(1)));
          }
        }
        for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
          if (lcm_sym8__) {
            out__.write(stan::model::rvalue(log_Pr_z, "log_Pr_z",
                          stan::model::index_uni(1),
                          stan::model::index_uni(sym1__)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(log_Pr_z[(sym2__ - 1)][(sym1__ - 1)]);
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> pi;
      current_statement__ = 1;
      stan::model::assign(pi,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(K),
        "assigning variable pi");
      out__.write_free_simplex(pi);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> theta =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(J,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__)));
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= J; ++sym3__) {
            current_statement__ = 2;
            stan::model::assign(theta, in__.read<local_scalar_t__>(),
              "assigning variable theta", stan::model::index_uni(sym3__),
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write_free_simplex(theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "pi", "double",
        std::vector<size_t>{static_cast<size_t>(K)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "theta", "double",
        std::vector<size_t>{static_cast<size_t>(J), static_cast<size_t>(K),
          static_cast<size_t>(K)});
      double lcm_sym7__;
      double lcm_sym6__;
      double lcm_sym5__;
      double lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> pi =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
      {
        std::vector<double> pi_flat__;
        current_statement__ = 1;
        pi_flat__ = context__.vals_r("pi");
        pos__ = 1;
        lcm_sym2__ = stan::math::logical_gte(K, 1);
        if (lcm_sym2__) {
          stan::model::assign(pi,
            stan::model::rvalue(pi_flat__, "pi_flat__",
              stan::model::index_uni(1)), "assigning variable pi",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
            stan::model::assign(pi, pi_flat__[(pos__ - 1)],
              "assigning variable pi", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_simplex(pi);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> theta =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(J,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(K,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__)));
      {
        std::vector<double> theta_flat__;
        current_statement__ = 2;
        theta_flat__ = context__.vals_r("theta");
        pos__ = 1;
        if (lcm_sym2__) {
          if (lcm_sym2__) {
            lcm_sym1__ = stan::math::logical_gte(J, 1);
            if (lcm_sym1__) {
              stan::model::assign(theta,
                stan::model::rvalue(theta_flat__, "theta_flat__",
                  stan::model::index_uni(1)), "assigning variable theta",
                stan::model::index_uni(1), stan::model::index_uni(1),
                stan::model::index_uni(1));
              pos__ = 2;
              for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                stan::model::assign(theta, theta_flat__[(pos__ - 1)],
                  "assigning variable theta", stan::model::index_uni(sym3__),
                  stan::model::index_uni(1), stan::model::index_uni(1));
                pos__ = (pos__ + 1);
              }
            }
            for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
              if (lcm_sym1__) {
                stan::model::assign(theta, theta_flat__[(pos__ - 1)],
                  "assigning variable theta", stan::model::index_uni(1),
                  stan::model::index_uni(sym2__), stan::model::index_uni(1));
                pos__ = (pos__ + 1);
                for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                  stan::model::assign(theta, theta_flat__[(pos__ - 1)],
                    "assigning variable theta",
                    stan::model::index_uni(sym3__),
                    stan::model::index_uni(sym2__), stan::model::index_uni(1));
                  pos__ = (pos__ + 1);
                }
              }
            }
          }
          for (int sym1__ = 2; sym1__ <= K; ++sym1__) {
            if (lcm_sym2__) {
              lcm_sym1__ = stan::math::logical_gte(J, 1);
              if (lcm_sym1__) {
                stan::model::assign(theta, theta_flat__[(pos__ - 1)],
                  "assigning variable theta", stan::model::index_uni(1),
                  stan::model::index_uni(1), stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
                for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                  stan::model::assign(theta, theta_flat__[(pos__ - 1)],
                    "assigning variable theta",
                    stan::model::index_uni(sym3__),
                    stan::model::index_uni(1), stan::model::index_uni(sym1__));
                  pos__ = (pos__ + 1);
                }
              }
              for (int sym2__ = 2; sym2__ <= K; ++sym2__) {
                if (lcm_sym1__) {
                  stan::model::assign(theta, theta_flat__[(pos__ - 1)],
                    "assigning variable theta", stan::model::index_uni(1),
                    stan::model::index_uni(sym2__),
                    stan::model::index_uni(sym1__));
                  pos__ = (pos__ + 1);
                  for (int sym3__ = 2; sym3__ <= J; ++sym3__) {
                    stan::model::assign(theta, theta_flat__[(pos__ - 1)],
                      "assigning variable theta",
                      stan::model::index_uni(sym3__),
                      stan::model::index_uni(sym2__),
                      stan::model::index_uni(sym1__));
                    pos__ = (pos__ + 1);
                  }
                }
              }
            }
          }
        }
      }
      out__.write_free_simplex(theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"pi", "theta"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      std::vector<std::string> temp{"log_Pr_z"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(K)},
                std::vector<size_t>{static_cast<size_t>(J),
                  static_cast<size_t>(K), static_cast<size_t>(K)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(I),
               static_cast<size_t>(K)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym69__ = 1; sym69__ <= K; ++sym69__) {
      param_names__.emplace_back(std::string() + "pi" + '.' +
        std::to_string(sym69__));
    }
    for (int sym69__ = 1; sym69__ <= K; ++sym69__) {
      for (int sym70__ = 1; sym70__ <= K; ++sym70__) {
        for (int sym71__ = 1; sym71__ <= J; ++sym71__) {
          param_names__.emplace_back(std::string() + "theta" + '.' +
            std::to_string(sym71__) + '.' + std::to_string(sym70__) + '.' +
            std::to_string(sym69__));
        }
      }
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      for (int sym69__ = 1; sym69__ <= K; ++sym69__) {
        for (int sym70__ = 1; sym70__ <= I; ++sym70__) {
          param_names__.emplace_back(std::string() + "log_Pr_z" + '.' +
            std::to_string(sym70__) + '.' + std::to_string(sym69__));
        }
      }
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym69__ = 1; sym69__ <= (K - 1); ++sym69__) {
      param_names__.emplace_back(std::string() + "pi" + '.' +
        std::to_string(sym69__));
    }
    for (int sym69__ = 1; sym69__ <= (K - 1); ++sym69__) {
      for (int sym70__ = 1; sym70__ <= K; ++sym70__) {
        for (int sym71__ = 1; sym71__ <= J; ++sym71__) {
          param_names__.emplace_back(std::string() + "theta" + '.' +
            std::to_string(sym71__) + '.' + std::to_string(sym70__) + '.' +
            std::to_string(sym69__));
        }
      }
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      for (int sym69__ = 1; sym69__ <= K; ++sym69__) {
        for (int sym70__ = 1; sym70__ <= I; ++sym70__) {
          param_names__.emplace_back(std::string() + "log_Pr_z" + '.' +
            std::to_string(sym70__) + '.' + std::to_string(sym69__));
        }
      }
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"pi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}}},\"block\":\"parameters\"},{\"name\":\"log_Pr_z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(I) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"pi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((K -1)) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string((K -1)) + "}}},\"block\":\"parameters\"},{\"name\":\"log_Pr_z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(I) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (K + (J * (K * K)));
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * ((I * K));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (K + (J * (K * K)));
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * ((I * K));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = expr_prop_fail7_model_namespace::expr_prop_fail7_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail7_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail8.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail8_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 25> locations_array__ =
  {" (found before start of program)",
  " (in 'expr-prop-fail8.stan', line 11, column 2 to column 13)",
  " (in 'expr-prop-fail8.stan', line 12, column 2 to column 13)",
  " (in 'expr-prop-fail8.stan', line 14, column 2 to column 26)",
  " (in 'expr-prop-fail8.stan', line 15, column 2 to column 24)",
  " (in 'expr-prop-fail8.stan', line 17, column 2 to column 22)",
  " (in 'expr-prop-fail8.stan', line 18, column 2 to column 24)",
  " (in 'expr-prop-fail8.stan', line 21, column 2 to column 47)",
  " (in 'expr-prop-fail8.stan', line 22, column 2 to column 16)",
  " (in 'expr-prop-fail8.stan', line 23, column 2 to column 27)",
  " (in 'expr-prop-fail8.stan', line 24, column 2 to column 24)",
  " (in 'expr-prop-fail8.stan', line 27, column 2 to column 33)",
  " (in 'expr-prop-fail8.stan', line 2, column 2 to column 17)",
  " (in 'expr-prop-fail8.stan', line 3, column 2 to column 23)",
  " (in 'expr-prop-fail8.stan', line 4, column 8 to column 15)",
  " (in 'expr-prop-fail8.stan', line 4, column 2 to column 45)",
  " (in 'expr-prop-fail8.stan', line 5, column 8 to column 15)",
  " (in 'expr-prop-fail8.stan', line 5, column 2 to column 45)",
  " (in 'expr-prop-fail8.stan', line 7, column 8 to column 9)",
  " (in 'expr-prop-fail8.stan', line 7, column 2 to column 26)",
  " (in 'expr-prop-fail8.stan', line 8, column 9 to column 10)",
  " (in 'expr-prop-fail8.stan', line 8, column 2 to column 14)",
  " (in 'expr-prop-fail8.stan', line 17, column 9 to column 10)",
  " (in 'expr-prop-fail8.stan', line 18, column 9 to column 10)",
  " (in 'expr-prop-fail8.stan', line 22, column 9 to column 10)"};
class expr_prop_fail8_model final : public model_base_crtp<expr_prop_fail8_model> {
 private:
  double lcm_sym20__;
  double lcm_sym19__;
  int lcm_sym18__;
  int lcm_sym17__;
  int N;
  int N_edges;
  std::vector<int> node1;
  std::vector<int> node2;
  std::vector<int> y;
  Eigen::Matrix<double,-1,1> x_data__;
  Eigen::Map<Eigen::Matrix<double,-1,1>> x{nullptr, 0};
 public:
  ~expr_prop_fail8_model() {}
  expr_prop_fail8_model(stan::io::var_context& context__, unsigned int
                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "expr_prop_fail8_model_namespace::expr_prop_fail8_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 12;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 12;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 12;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 13;
      context__.validate_dims("data initialization", "N_edges", "int",
        std::vector<size_t>{});
      N_edges = std::numeric_limits<int>::min();
      current_statement__ = 13;
      N_edges = context__.vals_i("N_edges")[(1 - 1)];
      current_statement__ = 13;
      stan::math::check_greater_or_equal(function__, "N_edges", N_edges, 0);
      current_statement__ = 14;
      stan::math::validate_non_negative_index("node1", "N_edges", N_edges);
      current_statement__ = 15;
      context__.validate_dims("data initialization", "node1", "int",
        std::vector<size_t>{static_cast<size_t>(N_edges)});
      node1 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      current_statement__ = 15;
      node1 = context__.vals_i("node1");
      current_statement__ = 15;
      stan::math::check_greater_or_equal(function__, "node1", node1, 1);
      current_statement__ = 15;
      stan::math::check_less_or_equal(function__, "node1", node1, N);
      current_statement__ = 16;
      stan::math::validate_non_negative_index("node2", "N_edges", N_edges);
      current_statement__ = 17;
      context__.validate_dims("data initialization", "node2", "int",
        std::vector<size_t>{static_cast<size_t>(N_edges)});
      node2 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      current_statement__ = 17;
      node2 = context__.vals_i("node2");
      current_statement__ = 17;
      stan::math::check_greater_or_equal(function__, "node2", node2, 1);
      current_statement__ = 17;
      stan::math::check_less_or_equal(function__, "node2", node2, N);
      current_statement__ = 18;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 19;
      context__.validate_dims("data initialization", "y", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 19;
      y = context__.vals_i("y");
      current_statement__ = 19;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 20;
      stan::math::validate_non_negative_index("x", "N", N);
      current_statement__ = 21;
      context__.validate_dims("data initialization", "x", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      x_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                   std::numeric_limits<double>::quiet_NaN());
      new (&x) Eigen::Map<Eigen::Matrix<double,-1,1>>(x_data__.data(), N);
      {
        std::vector<double> x_flat__;
        current_statement__ = 21;
        x_flat__ = context__.vals_r("x");
        pos__ = 1;
        if (stan::math::logical_gte(N, 1)) {
          stan::model::assign(x,
            stan::model::rvalue(x_flat__, "x_flat__",
              stan::model::index_uni(1)), "assigning variable x",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(x, x_flat__[(pos__ - 1)],
              "assigning variable x", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 22;
      stan::math::validate_non_negative_index("theta_std", "N", N);
      current_statement__ = 23;
      stan::math::validate_non_negative_index("phi_std_raw", "N", N);
      current_statement__ = 24;
      stan::math::validate_non_negative_index("phi", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + N + N;
  }
  inline std::string model_name() const final {
    return "expr_prop_fail8_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail8_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ lcm_sym16__;
      double lcm_sym15__;
      Eigen::Matrix<double,-1,1> lcm_sym14__;
      local_scalar_t__ beta0;
      current_statement__ = 1;
      beta0 = in__.template read<local_scalar_t__>();
      local_scalar_t__ beta1;
      current_statement__ = 2;
      beta1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ tau_theta;
      current_statement__ = 3;
      tau_theta = in__.template read_constrain_lb<local_scalar_t__,
                    jacobian__>(0, lp__);
      local_scalar_t__ tau_phi;
      current_statement__ = 4;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__,
                  jacobian__>(0, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> theta_std;
      current_statement__ = 5;
      theta_std = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<local_scalar_t__,-1,1> phi_std_raw;
      current_statement__ = 6;
      phi_std_raw = in__.template read<
                      Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      local_scalar_t__ sigma_phi = DUMMY_VAR__;
      lcm_sym16__ = stan::math::inv_sqrt(tau_phi);
      sigma_phi = lcm_sym16__;
      Eigen::Matrix<local_scalar_t__,-1,1> phi =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 9;
      stan::model::assign(phi, phi_std_raw, "assigning variable phi",
        stan::model::index_min_max(1, N));
      current_statement__ = 10;
      stan::model::assign(phi,
        stan::math::multiply(stan::model::deep_copy(phi), lcm_sym16__),
        "assigning variable phi");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "sigma_phi",
        lcm_sym16__, 0);
      {
        current_statement__ = 11;
        lp_accum__.add(stan::math::dot_self(
                         stan::model::rvalue(phi, "phi",
                           stan::model::index_multi(node1))));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "expr_prop_fail8_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ lcm_sym13__;
      double lcm_sym12__;
      Eigen::Matrix<double,-1,1> lcm_sym11__;
      local_scalar_t__ beta0;
      current_statement__ = 1;
      beta0 = in__.template read<local_scalar_t__>();
      local_scalar_t__ beta1;
      current_statement__ = 2;
      beta1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ tau_theta;
      current_statement__ = 3;
      tau_theta = in__.template read_constrain_lb<local_scalar_t__,
                    jacobian__>(0, lp__);
      local_scalar_t__ tau_phi;
      current_statement__ = 4;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__,
                  jacobian__>(0, lp__);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> theta_std;
      current_statement__ = 5;
      theta_std = in__.template read<
                    stan::math::var_value<Eigen::Matrix<double,-1,1>>>(N);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> phi_std_raw;
      current_statement__ = 6;
      phi_std_raw = in__.template read<
                      stan::math::var_value<Eigen::Matrix<double,-1,1>>>(N);
      local_scalar_t__ sigma_phi = DUMMY_VAR__;
      lcm_sym13__ = stan::math::inv_sqrt(tau_phi);
      sigma_phi = lcm_sym13__;
      stan::math::var_value<Eigen::Matrix<double,-1,1>> phi =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 9;
      stan::model::assign(phi, phi_std_raw, "assigning variable phi",
        stan::model::index_min_max(1, N));
      current_statement__ = 10;
      stan::model::assign(phi,
        stan::math::multiply(stan::model::deep_copy(phi), lcm_sym13__),
        "assigning variable phi");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "sigma_phi",
        lcm_sym13__, 0);
      {
        current_statement__ = 11;
        lp_accum__.add(stan::math::dot_self(
                         stan::model::rvalue(phi, "phi",
                           stan::model::index_multi(node1))));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "expr_prop_fail8_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym10__;
      Eigen::Matrix<double,-1,1> lcm_sym9__;
      int lcm_sym8__;
      int lcm_sym7__;
      double beta0;
      current_statement__ = 1;
      beta0 = in__.template read<local_scalar_t__>();
      double beta1;
      current_statement__ = 2;
      beta1 = in__.template read<local_scalar_t__>();
      double tau_theta;
      current_statement__ = 3;
      tau_theta = in__.template read_constrain_lb<local_scalar_t__,
                    jacobian__>(0, lp__);
      double tau_phi;
      current_statement__ = 4;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__,
                  jacobian__>(0, lp__);
      Eigen::Matrix<double,-1,1> theta_std;
      current_statement__ = 5;
      theta_std = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<double,-1,1> phi_std_raw;
      current_statement__ = 6;
      phi_std_raw = in__.template read<
                      Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      double sigma_phi = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double,-1,1> phi =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(beta0);
      out__.write(beta1);
      out__.write(tau_theta);
      out__.write(tau_phi);
      out__.write(theta_std);
      out__.write(phi_std_raw);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      lcm_sym10__ = stan::math::inv_sqrt(tau_phi);
      sigma_phi = lcm_sym10__;
      current_statement__ = 9;
      stan::model::assign(phi, phi_std_raw, "assigning variable phi",
        stan::model::index_min_max(1, N));
      current_statement__ = 10;
      stan::model::assign(phi,
        stan::math::multiply(stan::model::deep_copy(phi), lcm_sym10__),
        "assigning variable phi");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "sigma_phi",
        lcm_sym10__, 0);
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym10__);
        out__.write(phi);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ beta0;
      current_statement__ = 1;
      beta0 = in__.read<local_scalar_t__>();
      out__.write(beta0);
      local_scalar_t__ beta1;
      current_statement__ = 2;
      beta1 = in__.read<local_scalar_t__>();
      out__.write(beta1);
      local_scalar_t__ tau_theta;
      current_statement__ = 3;
      tau_theta = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau_theta);
      local_scalar_t__ tau_phi;
      current_statement__ = 4;
      tau_phi = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau_phi);
      Eigen::Matrix<local_scalar_t__,-1,1> theta_std;
      current_statement__ = 5;
      stan::model::assign(theta_std,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable theta_std");
      out__.write(theta_std);
      Eigen::Matrix<local_scalar_t__,-1,1> phi_std_raw;
      current_statement__ = 6;
      stan::model::assign(phi_std_raw,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable phi_std_raw");
      out__.write(phi_std_raw);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "beta0", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "beta1", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "tau_theta",
        "double", std::vector<size_t>{});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "tau_phi",
        "double", std::vector<size_t>{});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "theta_std",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "phi_std_raw",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      double lcm_sym6__;
      double lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ beta0;
      current_statement__ = 1;
      beta0 = context__.vals_r("beta0")[(1 - 1)];
      out__.write(beta0);
      local_scalar_t__ beta1;
      current_statement__ = 2;
      beta1 = context__.vals_r("beta1")[(1 - 1)];
      out__.write(beta1);
      local_scalar_t__ tau_theta;
      current_statement__ = 3;
      tau_theta = context__.vals_r("tau_theta")[(1 - 1)];
      out__.write_free_lb(0, tau_theta);
      local_scalar_t__ tau_phi;
      current_statement__ = 4;
      tau_phi = context__.vals_r("tau_phi")[(1 - 1)];
      out__.write_free_lb(0, tau_phi);
      Eigen::Matrix<local_scalar_t__,-1,1> theta_std =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<double> theta_std_flat__;
        current_statement__ = 5;
        theta_std_flat__ = context__.vals_r("theta_std");
        pos__ = 1;
        lcm_sym1__ = stan::math::logical_gte(N, 1);
        if (lcm_sym1__) {
          stan::model::assign(theta_std,
            stan::model::rvalue(theta_std_flat__, "theta_std_flat__",
              stan::model::index_uni(1)), "assigning variable theta_std",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(theta_std, theta_std_flat__[(pos__ - 1)],
              "assigning variable theta_std", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(theta_std);
      Eigen::Matrix<local_scalar_t__,-1,1> phi_std_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<double> phi_std_raw_flat__;
        current_statement__ = 6;
        phi_std_raw_flat__ = context__.vals_r("phi_std_raw");
        pos__ = 1;
        if (lcm_sym1__) {
          stan::model::assign(phi_std_raw,
            stan::model::rvalue(phi_std_raw_flat__, "phi_std_raw_flat__",
              stan::model::index_uni(1)), "assigning variable phi_std_raw",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(phi_std_raw, phi_std_raw_flat__[(pos__ - 1)],
              "assigning variable phi_std_raw",
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(phi_std_raw);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"beta0", "beta1", "tau_theta",
                "tau_phi", "theta_std", "phi_std_raw"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"sigma_phi", "phi"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(N)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "beta0");
    param_names__.emplace_back(std::string() + "beta1");
    param_names__.emplace_back(std::string() + "tau_theta");
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym21__ = 1; sym21__ <= N; ++sym21__) {
      param_names__.emplace_back(std::string() + "theta_std" + '.' +
        std::to_string(sym21__));
    }
    for (int sym21__ = 1; sym21__ <= N; ++sym21__) {
      param_names__.emplace_back(std::string() + "phi_std_raw" + '.' +
        std::to_string(sym21__));
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym21__ = 1; sym21__ <= N; ++sym21__) {
        param_names__.emplace_back(std::string() + "phi" + '.' +
          std::to_string(sym21__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "beta0");
    param_names__.emplace_back(std::string() + "beta1");
    param_names__.emplace_back(std::string() + "tau_theta");
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym21__ = 1; sym21__ <= N; ++sym21__) {
      param_names__.emplace_back(std::string() + "theta_std" + '.' +
        std::to_string(sym21__));
    }
    for (int sym21__ = 1; sym21__ <= N; ++sym21__) {
      param_names__.emplace_back(std::string() + "phi_std_raw" + '.' +
        std::to_string(sym21__));
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym21__ = 1; sym21__ <= N; ++sym21__) {
        param_names__.emplace_back(std::string() + "phi" + '.' +
          std::to_string(sym21__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((1 + 1) + 1) + 1) + N) + N);
    const size_t num_transformed = emit_transformed_parameters * ((1 + N));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((1 + 1) + 1) + 1) + N) + N);
    const size_t num_transformed = emit_transformed_parameters * ((1 + N));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = expr_prop_fail8_model_namespace::expr_prop_fail8_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail8_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp fails-test.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace fails_test_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 68> locations_array__ =
  {" (found before start of program)",
  " (in 'fails-test.stan', line 68, column 2 to column 32)",
  " (in 'fails-test.stan', line 69, column 2 to column 41)",
  " (in 'fails-test.stan', line 72, column 2 to column 52)",
  " (in 'fails-test.stan', line 73, column 2 to column 50)",
  " (in 'fails-test.stan', line 74, column 2 to column 50)",
  " (in 'fails-test.stan', line 80, column 6 to column 18)",
  " (in 'fails-test.stan', line 79, column 6 to column 20)",
  " (in 'fails-test.stan', line 78, column 34 to line 81, column 5)",
  " (in 'fails-test.stan', line 83, column 6 to column 32)",
  " (in 'fails-test.stan', line 84, column 6 to column 23)",
  " (in 'fails-test.stan', line 82, column 40 to line 85, column 5)",
  " (in 'fails-test.stan', line 82, column 4 to line 85, column 5)",
  " (in 'fails-test.stan', line 77, column 22 to line 86, column 3)",
  " (in 'fails-test.stan', line 25, column 11 to column 15)",
  " (in 'fails-test.stan', line 25, column 17 to column 28)",
  " (in 'fails-test.stan', line 25, column 4 to column 34)",
  " (in 'fails-test.stan', line 28, column 6 to column 32)",
  " (in 'fails-test.stan', line 31, column 8 to column 37)",
  " (in 'fails-test.stan', line 32, column 8 to column 32)",
  " (in 'fails-test.stan', line 40, column 8 to line 42, column 44)",
  " (in 'fails-test.stan', line 29, column 39 to line 43, column 7)",
  " (in 'fails-test.stan', line 29, column 6 to line 43, column 7)",
  " (in 'fails-test.stan', line 27, column 24 to line 44, column 5)",
  " (in 'fails-test.stan', line 27, column 4 to line 44, column 5)",
  " (in 'fails-test.stan', line 45, column 4 to column 15)",
  " (in 'fails-test.stan', line 100, column 8 to column 37)",
  " (in 'fails-test.stan', line 101, column 8 to column 41)",
  " (in 'fails-test.stan', line 99, column 42 to line 102, column 7)",
  " (in 'fails-test.stan', line 103, column 6 to column 37)",
  " (in 'fails-test.stan', line 98, column 22 to line 104, column 5)",
  " (in 'fails-test.stan', line 97, column 22 to line 105, column 3)",
  " (in 'fails-test.stan', line 97, column 2 to line 105, column 3)",
  " (in 'fails-test.stan', line 49, column 2 to column 20)",
  " (in 'fails-test.stan', line 50, column 2 to column 27)",
  " (in 'fails-test.stan', line 51, column 8 to column 12)",
  " (in 'fails-test.stan', line 51, column 14 to column 25)",
  " (in 'fails-test.stan', line 51, column 2 to column 51)",
  " (in 'fails-test.stan', line 52, column 2 to column 23)",
  " (in 'fails-test.stan', line 53, column 8 to column 12)",
  " (in 'fails-test.stan', line 53, column 2 to column 61)",
  " (in 'fails-test.stan', line 56, column 2 to column 38)",
  " (in 'fails-test.stan', line 58, column 8 to column 12)",
  " (in 'fails-test.stan', line 58, column 2 to column 52)",
  " (in 'fails-test.stan', line 59, column 8 to column 12)",
  " (in 'fails-test.stan', line 59, column 2 to column 51)",
  " (in 'fails-test.stan', line 63, column 4 to column 35)",
  " (in 'fails-test.stan', line 62, column 2 to line 63, column 35)",
  " (in 'fails-test.stan', line 65, column 4 to column 33)",
  " (in 'fails-test.stan', line 64, column 2 to line 65, column 33)",
  " (in 'fails-test.stan', line 69, column 27 to column 34)",
  " (in 'fails-test.stan', line 72, column 27 to column 31)",
  " (in 'fails-test.stan', line 72, column 33 to column 46)",
  " (in 'fails-test.stan', line 73, column 27 to column 31)",
  " (in 'fails-test.stan', line 73, column 33 to column 46)",
  " (in 'fails-test.stan', line 74, column 27 to column 31)",
  " (in 'fails-test.stan', line 74, column 33 to column 44)",
  " (in 'fails-test.stan', line 8, column 8 to column 17)",
  " (in 'fails-test.stan', line 7, column 6 to line 8, column 17)",
  " (in 'fails-test.stan', line 9, column 4 to column 13)",
  " (in 'fails-test.stan', line 5, column 37 to line 10, column 3)",
  " (in 'fails-test.stan', line 15, column 6 to column 32)",
  " (in 'fails-test.stan', line 19, column 8 to column 17)",
  " (in 'fails-test.stan', line 18, column 6 to line 19, column 17)",
  " (in 'fails-test.stan', line 13, column 39 to line 20, column 5)",
  " (in 'fails-test.stan', line 21, column 4 to column 13)",
  " (in 'fails-test.stan', line 12, column 36 to line 22, column 3)",
  " (in 'fails-test.stan', line 24, column 74 to line 46, column 3)"};
int first_capture(const std::vector<int>& y_i, std::ostream* pstream__);
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__);
template <typename T2__, typename T3__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T2__>,
                stan::base_type_t<T3__>>,-1,-1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__);
int first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym25__;
    int lcm_sym24__;
    int lcm_sym23__;
    int lcm_sym22__;
    {
      lcm_sym23__ = stan::math::size(y_i);
      if (stan::math::logical_gte(lcm_sym23__, 1)) {
        current_statement__ = 58;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(1))) {
          current_statement__ = 57;
          return 1;
        }
        for (int k = 2; k <= lcm_sym23__; ++k) {
          current_statement__ = 58;
          if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
            current_statement__ = 57;
            return k;
          }
        }
      }
      current_statement__ = 59;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym31__;
    int lcm_sym30__;
    int lcm_sym29__;
    int lcm_sym28__;
    int lcm_sym27__;
    int lcm_sym26__;
    {
      lcm_sym29__ = (stan::math::size(y_i) - 1);
      if (stan::math::logical_gte(lcm_sym29__, 0)) {
        int k = std::numeric_limits<int>::min();
        lcm_sym28__ = (stan::math::size(y_i) - 0);
        current_statement__ = 63;
        if (y_i[(lcm_sym28__ - 1)]) {
          current_statement__ = 62;
          return lcm_sym28__;
        }
        for (int k_rev = 1; k_rev <= lcm_sym29__; ++k_rev) {
          int k = std::numeric_limits<int>::min();
          lcm_sym27__ = (stan::math::size(y_i) - k_rev);
          current_statement__ = 63;
          if (y_i[(lcm_sym27__ - 1)]) {
            current_statement__ = 62;
            return lcm_sym27__;
          }
        }
      }
      current_statement__ = 65;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T2__, typename T3__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T2__>,
                stan::base_type_t<T3__>>,-1,-1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T2__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  const auto& p = stan::math::to_ref(p_arg__);
  const auto& phi = stan::math::to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym41__;
    double lcm_sym40__;
    double lcm_sym39__;
    double lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    int lcm_sym35__;
    int lcm_sym34__;
    int lcm_sym33__;
    int lcm_sym32__;
    {
      current_statement__ = 14;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 15;
      stan::math::validate_non_negative_index("chi", "n_occasions",
        n_occasions);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
          DUMMY_VAR__);
      current_statement__ = 24;
      if (stan::math::logical_gte(nind, 1)) {
        current_statement__ = 17;
        stan::model::assign(chi, 1.0, "assigning variable chi",
          stan::model::index_uni(1), stan::model::index_uni(n_occasions));
        lcm_sym35__ = (n_occasions - 1);
        lcm_sym33__ = stan::math::logical_gte(lcm_sym35__, 1);
        if (lcm_sym33__) {
          int t_curr = std::numeric_limits<int>::min();
          int t_next = std::numeric_limits<int>::min();
          lcm_sym37__ = (lcm_sym35__ + 1);
          current_statement__ = 20;
          stan::model::assign(chi,
            stan::math::fma(
              (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                 stan::model::index_uni(lcm_sym35__)) * (1 -
              stan::model::rvalue(p, "p", stan::model::index_uni(1),
                stan::model::index_uni((lcm_sym37__ - 1))))),
              stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym37__)), (1 -
              stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym35__)))),
            "assigning variable chi", stan::model::index_uni(1),
            stan::model::index_uni(lcm_sym35__));
          for (int t = 2; t <= lcm_sym35__; ++t) {
            int t_curr = std::numeric_limits<int>::min();
            lcm_sym34__ = (n_occasions - t);
            int t_next = std::numeric_limits<int>::min();
            lcm_sym36__ = (lcm_sym34__ + 1);
            current_statement__ = 20;
            stan::model::assign(chi,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym34__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym36__ - 1))))),
                stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym36__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym34__)))),
              "assigning variable chi", stan::model::index_uni(1),
              stan::model::index_uni(lcm_sym34__));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 17;
          stan::model::assign(chi, 1.0, "assigning variable chi",
            stan::model::index_uni(i), stan::model::index_uni(n_occasions));
          current_statement__ = 22;
          if (lcm_sym33__) {
            int t_curr = std::numeric_limits<int>::min();
            int t_next = std::numeric_limits<int>::min();
            lcm_sym37__ = (lcm_sym35__ + 1);
            current_statement__ = 20;
            stan::model::assign(chi,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                   stan::model::index_uni(lcm_sym35__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(i),
                  stan::model::index_uni((lcm_sym37__ - 1))))),
                stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym37__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym35__)))),
              "assigning variable chi", stan::model::index_uni(i),
              stan::model::index_uni(lcm_sym35__));
            for (int t = 2; t <= lcm_sym35__; ++t) {
              int t_curr = std::numeric_limits<int>::min();
              lcm_sym34__ = (n_occasions - t);
              int t_next = std::numeric_limits<int>::min();
              lcm_sym36__ = (lcm_sym34__ + 1);
              current_statement__ = 20;
              stan::model::assign(chi,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                     stan::model::index_uni(lcm_sym34__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(i),
                    stan::model::index_uni((lcm_sym36__ - 1))))),
                  stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym36__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym34__)))),
                "assigning variable chi", stan::model::index_uni(i),
                stan::model::index_uni(lcm_sym34__));
            }
          }
        }
      }
      current_statement__ = 25;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class fails_test_model final : public model_base_crtp<fails_test_model> {
 private:
  int lcm_sym171__;
  int lcm_sym170__;
  int lcm_sym169__;
  int lcm_sym168__;
  int lcm_sym167__;
  int lcm_sym166__;
  int lcm_sym165__;
  int lcm_sym164__;
  int lcm_sym163__;
  int lcm_sym162__;
  int lcm_sym161__;
  int lcm_sym160__;
  int lcm_sym159__;
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int max_age;
  std::vector<std::vector<int>> x;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last;
 public:
  ~fails_test_model() {}
  fails_test_model(stan::io::var_context& context__, unsigned int
                   random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "fails_test_model_namespace::fails_test_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 33;
      context__.validate_dims("data initialization", "nind", "int",
        std::vector<size_t>{});
      nind = std::numeric_limits<int>::min();
      current_statement__ = 33;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 33;
      stan::math::check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 34;
      context__.validate_dims("data initialization", "n_occasions", "int",
        std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      current_statement__ = 34;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 34;
      stan::math::check_greater_or_equal(function__, "n_occasions",
        n_occasions, 2);
      current_statement__ = 35;
      stan::math::validate_non_negative_index("y", "nind", nind);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 37;
      context__.validate_dims("data initialization", "y", "int",
        std::vector<size_t>{static_cast<size_t>(nind),
          static_cast<size_t>(n_occasions)});
      y = std::vector<std::vector<int>>(nind,
            std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      {
        std::vector<int> y_flat__;
        current_statement__ = 37;
        y_flat__ = context__.vals_i("y");
        pos__ = 1;
        if (stan::math::logical_gte(n_occasions, 1)) {
          lcm_sym160__ = stan::math::logical_gte(nind, 1);
          if (lcm_sym160__) {
            stan::model::assign(y,
              stan::model::rvalue(y_flat__, "y_flat__",
                stan::model::index_uni(1)), "assigning variable y",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
            if (lcm_sym160__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                stan::model::assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        } else {
          lcm_sym160__ = stan::math::logical_gte(nind, 1);
        }
      }
      current_statement__ = 37;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 37;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 38;
      context__.validate_dims("data initialization", "max_age", "int",
        std::vector<size_t>{});
      max_age = std::numeric_limits<int>::min();
      current_statement__ = 38;
      max_age = context__.vals_i("max_age")[(1 - 1)];
      current_statement__ = 38;
      stan::math::check_greater_or_equal(function__, "max_age", max_age, 1);
      current_statement__ = 39;
      stan::math::validate_non_negative_index("x", "nind", nind);
      lcm_sym162__ = (n_occasions - 1);
      stan::math::validate_non_negative_index("x", "n_occasions - 1",
        lcm_sym162__);
      current_statement__ = 40;
      context__.validate_dims("data initialization", "x", "int",
        std::vector<size_t>{static_cast<size_t>(nind),
          static_cast<size_t>(lcm_sym162__)});
      x = std::vector<std::vector<int>>(nind,
            std::vector<int>(lcm_sym162__, std::numeric_limits<int>::min()));
      {
        std::vector<int> x_flat__;
        current_statement__ = 40;
        x_flat__ = context__.vals_i("x");
        pos__ = 1;
        if (stan::math::logical_gte(lcm_sym162__, 1)) {
          if (lcm_sym160__) {
            stan::model::assign(x,
              stan::model::rvalue(x_flat__, "x_flat__",
                stan::model::index_uni(1)), "assigning variable x",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
              stan::model::assign(x, x_flat__[(pos__ - 1)],
                "assigning variable x", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= lcm_sym162__; ++sym1__) {
            if (lcm_sym160__) {
              stan::model::assign(x, x_flat__[(pos__ - 1)],
                "assigning variable x", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                stan::model::assign(x, x_flat__[(pos__ - 1)],
                  "assigning variable x", stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 40;
      stan::math::check_greater_or_equal(function__, "x", x, 0);
      current_statement__ = 40;
      stan::math::check_less_or_equal(function__, "x", x, max_age);
      current_statement__ = 41;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      current_statement__ = 41;
      n_occ_minus_1 = lcm_sym162__;
      current_statement__ = 42;
      stan::math::validate_non_negative_index("first", "nind", nind);
      current_statement__ = 43;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      current_statement__ = 44;
      stan::math::validate_non_negative_index("last", "nind", nind);
      current_statement__ = 45;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      current_statement__ = 47;
      if (lcm_sym160__) {
        current_statement__ = 46;
        stan::model::assign(first,
          first_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(1)), pstream__),
          "assigning variable first", stan::model::index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 46;
          stan::model::assign(first,
            first_capture(
              stan::model::rvalue(y, "y", stan::model::index_uni(i)),
              pstream__), "assigning variable first",
            stan::model::index_uni(i));
        }
      }
      current_statement__ = 49;
      if (lcm_sym160__) {
        current_statement__ = 48;
        stan::model::assign(last,
          last_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(1)), pstream__),
          "assigning variable last", stan::model::index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 48;
          stan::model::assign(last,
            last_capture(
              stan::model::rvalue(y, "y", stan::model::index_uni(i)),
              pstream__), "assigning variable last",
            stan::model::index_uni(i));
        }
      }
      current_statement__ = 43;
      stan::math::check_greater_or_equal(function__, "first", first, 0);
      current_statement__ = 43;
      stan::math::check_less_or_equal(function__, "first", first, n_occasions);
      current_statement__ = 45;
      stan::math::check_greater_or_equal(function__, "last", last, 0);
      current_statement__ = 45;
      stan::math::check_less_or_equal(function__, "last", last, n_occasions);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("beta", "max_age", max_age);
      current_statement__ = 51;
      stan::math::validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 52;
      stan::math::validate_non_negative_index("phi", "n_occ_minus_1",
        lcm_sym162__);
      current_statement__ = 53;
      stan::math::validate_non_negative_index("p", "nind", nind);
      current_statement__ = 54;
      stan::math::validate_non_negative_index("p", "n_occ_minus_1",
        lcm_sym162__);
      current_statement__ = 55;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 56;
      stan::math::validate_non_negative_index("chi", "n_occasions",
        n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + max_age;
  }
  inline std::string model_name() const final {
    return "fails_test_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "fails_test_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym158__;
      int lcm_sym157__;
      int lcm_sym156__;
      int lcm_sym155__;
      int lcm_sym154__;
      double lcm_sym153__;
      double lcm_sym152__;
      double lcm_sym151__;
      double lcm_sym150__;
      double lcm_sym149__;
      double lcm_sym148__;
      double lcm_sym147__;
      double lcm_sym146__;
      double lcm_sym145__;
      double lcm_sym144__;
      double lcm_sym143__;
      double lcm_sym142__;
      double lcm_sym141__;
      double lcm_sym140__;
      double lcm_sym139__;
      double lcm_sym138__;
      double lcm_sym137__;
      double lcm_sym136__;
      int lcm_sym135__;
      int lcm_sym134__;
      int lcm_sym133__;
      int lcm_sym132__;
      int lcm_sym131__;
      int lcm_sym130__;
      int lcm_sym129__;
      int lcm_sym128__;
      int lcm_sym127__;
      int lcm_sym126__;
      int lcm_sym125__;
      int lcm_sym124__;
      int lcm_sym123__;
      int lcm_sym122__;
      int lcm_sym121__;
      int lcm_sym120__;
      int lcm_sym119__;
      int lcm_sym118__;
      int lcm_sym117__;
      int lcm_sym116__;
      local_scalar_t__ mean_p;
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, 1, lp__,
               max_age);
      Eigen::Matrix<local_scalar_t__,-1,-1> phi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
          DUMMY_VAR__);
      lcm_sym116__ = stan::math::logical_gte(nind, 1);
      if (lcm_sym116__) {
        lcm_sym155__ = stan::model::rvalue(first, "first",
                         stan::model::index_uni(1));
        lcm_sym129__ = (lcm_sym155__ - 1);
        if (stan::math::logical_gte(lcm_sym129__, 1)) {
          stan::model::assign(phi, 0, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          current_statement__ = 6;
          stan::model::assign(p, 0, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int t = 2; t <= lcm_sym129__; ++t) {
            current_statement__ = 7;
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        lcm_sym127__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym127__, lcm_sym155__)) {
          current_statement__ = 9;
          stan::model::assign(phi,
            stan::model::rvalue(beta, "beta",
              stan::model::index_uni(
                stan::model::rvalue(x, "x", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym155__)))),
            "assigning variable phi", stan::model::index_uni(1),
            stan::model::index_uni(lcm_sym155__));
          lcm_sym135__ = (lcm_sym155__ + 1);
          stan::model::assign(p, mean_p, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym155__));
          for (int t = lcm_sym135__; t <= lcm_sym127__; ++t) {
            current_statement__ = 9;
            stan::model::assign(phi,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni(
                  stan::model::rvalue(x, "x", stan::model::index_uni(1),
                    stan::model::index_uni(t)))), "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 10;
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          lcm_sym154__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(i));
          lcm_sym128__ = (lcm_sym154__ - 1);
          if (stan::math::logical_gte(lcm_sym128__, 1)) {
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(1));
            for (int t = 2; t <= lcm_sym128__; ++t) {
              current_statement__ = 7;
              stan::model::assign(phi, 0, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 6;
              stan::model::assign(p, 0, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
          current_statement__ = 12;
          if (stan::math::logical_gte(lcm_sym127__, lcm_sym154__)) {
            current_statement__ = 9;
            stan::model::assign(phi,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni(
                  stan::model::rvalue(x, "x", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym154__)))),
              "assigning variable phi", stan::model::index_uni(i),
              stan::model::index_uni(lcm_sym154__));
            lcm_sym134__ = (lcm_sym154__ + 1);
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym154__));
            for (int t = lcm_sym134__; t <= lcm_sym127__; ++t) {
              current_statement__ = 9;
              stan::model::assign(phi,
                stan::model::rvalue(beta, "beta",
                  stan::model::index_uni(
                    stan::model::rvalue(x, "x", stan::model::index_uni(i),
                      stan::model::index_uni(t)))), "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 10;
              stan::model::assign(p, mean_p, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
        }
      }
      Eigen::Matrix<local_scalar_t__,-1,-1>
        inline_prob_uncaptured_return_sym15__;
      {
        current_statement__ = 14;
        stan::math::validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          n_occasions);
        Eigen::Matrix<local_scalar_t__,-1,-1>
          inline_prob_uncaptured_chi_sym16__ =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
            DUMMY_VAR__);
        current_statement__ = 24;
        if (lcm_sym116__) {
          current_statement__ = 17;
          stan::model::assign(inline_prob_uncaptured_chi_sym16__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym16__",
            stan::model::index_uni(1), stan::model::index_uni(n_occasions));
          lcm_sym127__ = (n_occasions - 1);
          lcm_sym117__ = stan::math::logical_gte(lcm_sym127__, 1);
          if (lcm_sym117__) {
            int inline_prob_uncaptured_t_curr_sym17__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym18__ =
              std::numeric_limits<int>::min();
            lcm_sym131__ = (lcm_sym127__ + 1);
            current_statement__ = 20;
            stan::model::assign(inline_prob_uncaptured_chi_sym16__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym127__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym131__ - 1))))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                  "inline_prob_uncaptured_chi_sym16__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym131__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym127__)))),
              "assigning variable inline_prob_uncaptured_chi_sym16__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym127__));
            for (int inline_prob_uncaptured_t_sym19__ = 2; inline_prob_uncaptured_t_sym19__
                 <= lcm_sym127__; ++inline_prob_uncaptured_t_sym19__) {
              int inline_prob_uncaptured_t_curr_sym17__ =
                std::numeric_limits<int>::min();
              lcm_sym126__ = (n_occasions -
                inline_prob_uncaptured_t_sym19__);
              int inline_prob_uncaptured_t_next_sym18__ =
                std::numeric_limits<int>::min();
              lcm_sym130__ = (lcm_sym126__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym16__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym126__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni((lcm_sym130__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                    "inline_prob_uncaptured_chi_sym16__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym130__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym126__)))),
                "assigning variable inline_prob_uncaptured_chi_sym16__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym126__));
            }
          }
          for (int inline_prob_uncaptured_i_sym20__ = 2; inline_prob_uncaptured_i_sym20__
               <= nind; ++inline_prob_uncaptured_i_sym20__) {
            current_statement__ = 17;
            stan::model::assign(inline_prob_uncaptured_chi_sym16__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym16__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
              stan::model::index_uni(n_occasions));
            current_statement__ = 22;
            if (lcm_sym117__) {
              int inline_prob_uncaptured_t_curr_sym17__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym18__ =
                std::numeric_limits<int>::min();
              lcm_sym131__ = (lcm_sym127__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym16__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                     stan::model::index_uni(lcm_sym127__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                    stan::model::index_uni((lcm_sym131__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                    "inline_prob_uncaptured_chi_sym16__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                    stan::model::index_uni(lcm_sym131__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                    stan::model::index_uni(lcm_sym127__)))),
                "assigning variable inline_prob_uncaptured_chi_sym16__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                stan::model::index_uni(lcm_sym127__));
              for (int inline_prob_uncaptured_t_sym19__ = 2; inline_prob_uncaptured_t_sym19__
                   <= lcm_sym127__; ++inline_prob_uncaptured_t_sym19__) {
                int inline_prob_uncaptured_t_curr_sym17__ =
                  std::numeric_limits<int>::min();
                lcm_sym126__ = (n_occasions -
                  inline_prob_uncaptured_t_sym19__);
                int inline_prob_uncaptured_t_next_sym18__ =
                  std::numeric_limits<int>::min();
                lcm_sym130__ = (lcm_sym126__ + 1);
                current_statement__ = 20;
                stan::model::assign(inline_prob_uncaptured_chi_sym16__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(
                         inline_prob_uncaptured_i_sym20__),
                       stan::model::index_uni(lcm_sym126__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                      stan::model::index_uni((lcm_sym130__ - 1))))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                      "inline_prob_uncaptured_chi_sym16__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                      stan::model::index_uni(lcm_sym130__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                      stan::model::index_uni(lcm_sym126__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym16__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                  stan::model::index_uni(lcm_sym126__));
              }
            }
          }
        }
        current_statement__ = 25;
        stan::model::assign(inline_prob_uncaptured_return_sym15__,
          inline_prob_uncaptured_chi_sym16__,
          "assigning variable inline_prob_uncaptured_return_sym15__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym15__,
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym15__, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym15__, 1);
      {
        current_statement__ = 32;
        if (lcm_sym116__) {
          lcm_sym155__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(1));
          if (stan::math::logical_gt(lcm_sym155__, 0)) {
            lcm_sym157__ = stan::model::rvalue(last, "last",
                             stan::model::index_uni(1));
            lcm_sym135__ = (lcm_sym155__ + 1);
            if (stan::math::logical_gte(lcm_sym157__, lcm_sym135__)) {
              current_statement__ = 26;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym135__ - 1)))));
              lcm_sym133__ = (lcm_sym135__ + 1);
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(lcm_sym135__)),
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym135__ - 1)))));
              for (int t = lcm_sym133__; t <= lcm_sym157__; ++t) {
                current_statement__ = 26;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
                current_statement__ = 27;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni(t)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
              }
            }
            current_statement__ = 29;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             stan::model::rvalue(
                               inline_prob_uncaptured_return_sym15__,
                               "inline_prob_uncaptured_return_sym15__",
                               stan::model::index_uni(1),
                               stan::model::index_uni(lcm_sym157__))));
          }
          for (int i = 2; i <= nind; ++i) {
            lcm_sym154__ = stan::model::rvalue(first, "first",
                             stan::model::index_uni(i));
            if (stan::math::logical_gt(lcm_sym154__, 0)) {
              lcm_sym156__ = stan::model::rvalue(last, "last",
                               stan::model::index_uni(i));
              lcm_sym134__ = (lcm_sym154__ + 1);
              if (stan::math::logical_gte(lcm_sym156__, lcm_sym134__)) {
                current_statement__ = 26;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym134__ - 1)))));
                lcm_sym132__ = (lcm_sym134__ + 1);
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(lcm_sym134__)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym134__ - 1)))));
                for (int t = lcm_sym132__; t <= lcm_sym156__; ++t) {
                  current_statement__ = 26;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(phi, "phi",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                  current_statement__ = 27;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni(t)),
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                }
              }
              current_statement__ = 29;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(
                                 inline_prob_uncaptured_return_sym15__,
                                 "inline_prob_uncaptured_return_sym15__",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(lcm_sym156__))));
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "fails_test_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym115__;
      int lcm_sym114__;
      int lcm_sym113__;
      int lcm_sym112__;
      int lcm_sym111__;
      double lcm_sym110__;
      double lcm_sym109__;
      double lcm_sym108__;
      double lcm_sym107__;
      double lcm_sym106__;
      double lcm_sym105__;
      double lcm_sym104__;
      double lcm_sym103__;
      double lcm_sym102__;
      double lcm_sym101__;
      double lcm_sym100__;
      double lcm_sym99__;
      double lcm_sym98__;
      double lcm_sym97__;
      double lcm_sym96__;
      double lcm_sym95__;
      double lcm_sym94__;
      double lcm_sym93__;
      int lcm_sym92__;
      int lcm_sym91__;
      int lcm_sym90__;
      int lcm_sym89__;
      int lcm_sym88__;
      int lcm_sym87__;
      int lcm_sym86__;
      int lcm_sym85__;
      int lcm_sym84__;
      int lcm_sym83__;
      int lcm_sym82__;
      int lcm_sym81__;
      int lcm_sym80__;
      int lcm_sym79__;
      int lcm_sym78__;
      int lcm_sym77__;
      int lcm_sym76__;
      int lcm_sym75__;
      int lcm_sym74__;
      int lcm_sym73__;
      local_scalar_t__ mean_p;
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, 1, lp__,
               max_age);
      Eigen::Matrix<local_scalar_t__,-1,-1> phi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
          DUMMY_VAR__);
      lcm_sym73__ = stan::math::logical_gte(nind, 1);
      if (lcm_sym73__) {
        lcm_sym112__ = stan::model::rvalue(first, "first",
                         stan::model::index_uni(1));
        lcm_sym86__ = (lcm_sym112__ - 1);
        if (stan::math::logical_gte(lcm_sym86__, 1)) {
          stan::model::assign(phi, 0, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          current_statement__ = 6;
          stan::model::assign(p, 0, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int t = 2; t <= lcm_sym86__; ++t) {
            current_statement__ = 7;
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        lcm_sym84__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym84__, lcm_sym112__)) {
          current_statement__ = 9;
          stan::model::assign(phi,
            stan::model::rvalue(beta, "beta",
              stan::model::index_uni(
                stan::model::rvalue(x, "x", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym112__)))),
            "assigning variable phi", stan::model::index_uni(1),
            stan::model::index_uni(lcm_sym112__));
          lcm_sym92__ = (lcm_sym112__ + 1);
          stan::model::assign(p, mean_p, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym112__));
          for (int t = lcm_sym92__; t <= lcm_sym84__; ++t) {
            current_statement__ = 9;
            stan::model::assign(phi,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni(
                  stan::model::rvalue(x, "x", stan::model::index_uni(1),
                    stan::model::index_uni(t)))), "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 10;
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          lcm_sym111__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(i));
          lcm_sym85__ = (lcm_sym111__ - 1);
          if (stan::math::logical_gte(lcm_sym85__, 1)) {
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(1));
            for (int t = 2; t <= lcm_sym85__; ++t) {
              current_statement__ = 7;
              stan::model::assign(phi, 0, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 6;
              stan::model::assign(p, 0, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
          current_statement__ = 12;
          if (stan::math::logical_gte(lcm_sym84__, lcm_sym111__)) {
            current_statement__ = 9;
            stan::model::assign(phi,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni(
                  stan::model::rvalue(x, "x", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym111__)))),
              "assigning variable phi", stan::model::index_uni(i),
              stan::model::index_uni(lcm_sym111__));
            lcm_sym91__ = (lcm_sym111__ + 1);
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym111__));
            for (int t = lcm_sym91__; t <= lcm_sym84__; ++t) {
              current_statement__ = 9;
              stan::model::assign(phi,
                stan::model::rvalue(beta, "beta",
                  stan::model::index_uni(
                    stan::model::rvalue(x, "x", stan::model::index_uni(i),
                      stan::model::index_uni(t)))), "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 10;
              stan::model::assign(p, mean_p, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
        }
      }
      Eigen::Matrix<local_scalar_t__,-1,-1>
        inline_prob_uncaptured_return_sym8__;
      {
        current_statement__ = 14;
        stan::math::validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          n_occasions);
        Eigen::Matrix<local_scalar_t__,-1,-1>
          inline_prob_uncaptured_chi_sym9__ =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
            DUMMY_VAR__);
        current_statement__ = 24;
        if (lcm_sym73__) {
          current_statement__ = 17;
          stan::model::assign(inline_prob_uncaptured_chi_sym9__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym9__",
            stan::model::index_uni(1), stan::model::index_uni(n_occasions));
          lcm_sym84__ = (n_occasions - 1);
          lcm_sym74__ = stan::math::logical_gte(lcm_sym84__, 1);
          if (lcm_sym74__) {
            int inline_prob_uncaptured_t_curr_sym10__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym11__ =
              std::numeric_limits<int>::min();
            lcm_sym88__ = (lcm_sym84__ + 1);
            current_statement__ = 20;
            stan::model::assign(inline_prob_uncaptured_chi_sym9__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym84__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym88__ - 1))))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                  "inline_prob_uncaptured_chi_sym9__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym88__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym84__)))),
              "assigning variable inline_prob_uncaptured_chi_sym9__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym84__));
            for (int inline_prob_uncaptured_t_sym12__ = 2; inline_prob_uncaptured_t_sym12__
                 <= lcm_sym84__; ++inline_prob_uncaptured_t_sym12__) {
              int inline_prob_uncaptured_t_curr_sym10__ =
                std::numeric_limits<int>::min();
              lcm_sym83__ = (n_occasions - inline_prob_uncaptured_t_sym12__);
              int inline_prob_uncaptured_t_next_sym11__ =
                std::numeric_limits<int>::min();
              lcm_sym87__ = (lcm_sym83__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym9__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym83__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni((lcm_sym87__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                    "inline_prob_uncaptured_chi_sym9__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym87__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym83__)))),
                "assigning variable inline_prob_uncaptured_chi_sym9__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym83__));
            }
          }
          for (int inline_prob_uncaptured_i_sym13__ = 2; inline_prob_uncaptured_i_sym13__
               <= nind; ++inline_prob_uncaptured_i_sym13__) {
            current_statement__ = 17;
            stan::model::assign(inline_prob_uncaptured_chi_sym9__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym9__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
              stan::model::index_uni(n_occasions));
            current_statement__ = 22;
            if (lcm_sym74__) {
              int inline_prob_uncaptured_t_curr_sym10__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym11__ =
                std::numeric_limits<int>::min();
              lcm_sym88__ = (lcm_sym84__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym9__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                     stan::model::index_uni(lcm_sym84__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                    stan::model::index_uni((lcm_sym88__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                    "inline_prob_uncaptured_chi_sym9__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                    stan::model::index_uni(lcm_sym88__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                    stan::model::index_uni(lcm_sym84__)))),
                "assigning variable inline_prob_uncaptured_chi_sym9__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                stan::model::index_uni(lcm_sym84__));
              for (int inline_prob_uncaptured_t_sym12__ = 2; inline_prob_uncaptured_t_sym12__
                   <= lcm_sym84__; ++inline_prob_uncaptured_t_sym12__) {
                int inline_prob_uncaptured_t_curr_sym10__ =
                  std::numeric_limits<int>::min();
                lcm_sym83__ = (n_occasions -
                  inline_prob_uncaptured_t_sym12__);
                int inline_prob_uncaptured_t_next_sym11__ =
                  std::numeric_limits<int>::min();
                lcm_sym87__ = (lcm_sym83__ + 1);
                current_statement__ = 20;
                stan::model::assign(inline_prob_uncaptured_chi_sym9__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(
                         inline_prob_uncaptured_i_sym13__),
                       stan::model::index_uni(lcm_sym83__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                      stan::model::index_uni((lcm_sym87__ - 1))))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                      "inline_prob_uncaptured_chi_sym9__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                      stan::model::index_uni(lcm_sym87__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                      stan::model::index_uni(lcm_sym83__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym9__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                  stan::model::index_uni(lcm_sym83__));
              }
            }
          }
        }
        current_statement__ = 25;
        stan::model::assign(inline_prob_uncaptured_return_sym8__,
          inline_prob_uncaptured_chi_sym9__,
          "assigning variable inline_prob_uncaptured_return_sym8__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym8__,
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym8__, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym8__, 1);
      {
        current_statement__ = 32;
        if (lcm_sym73__) {
          lcm_sym112__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(1));
          if (stan::math::logical_gt(lcm_sym112__, 0)) {
            lcm_sym114__ = stan::model::rvalue(last, "last",
                             stan::model::index_uni(1));
            lcm_sym92__ = (lcm_sym112__ + 1);
            if (stan::math::logical_gte(lcm_sym114__, lcm_sym92__)) {
              current_statement__ = 26;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym92__ - 1)))));
              lcm_sym90__ = (lcm_sym92__ + 1);
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(lcm_sym92__)),
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym92__ - 1)))));
              for (int t = lcm_sym90__; t <= lcm_sym114__; ++t) {
                current_statement__ = 26;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
                current_statement__ = 27;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni(t)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
              }
            }
            current_statement__ = 29;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             stan::model::rvalue(
                               inline_prob_uncaptured_return_sym8__,
                               "inline_prob_uncaptured_return_sym8__",
                               stan::model::index_uni(1),
                               stan::model::index_uni(lcm_sym114__))));
          }
          for (int i = 2; i <= nind; ++i) {
            lcm_sym111__ = stan::model::rvalue(first, "first",
                             stan::model::index_uni(i));
            if (stan::math::logical_gt(lcm_sym111__, 0)) {
              lcm_sym113__ = stan::model::rvalue(last, "last",
                               stan::model::index_uni(i));
              lcm_sym91__ = (lcm_sym111__ + 1);
              if (stan::math::logical_gte(lcm_sym113__, lcm_sym91__)) {
                current_statement__ = 26;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym91__ - 1)))));
                lcm_sym89__ = (lcm_sym91__ + 1);
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(lcm_sym91__)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym91__ - 1)))));
                for (int t = lcm_sym89__; t <= lcm_sym113__; ++t) {
                  current_statement__ = 26;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(phi, "phi",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                  current_statement__ = 27;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni(t)),
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                }
              }
              current_statement__ = 29;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(
                                 inline_prob_uncaptured_return_sym8__,
                                 "inline_prob_uncaptured_return_sym8__",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(lcm_sym113__))));
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "fails_test_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym72__;
      int lcm_sym71__;
      int lcm_sym70__;
      double lcm_sym69__;
      double lcm_sym68__;
      double lcm_sym67__;
      double lcm_sym66__;
      double lcm_sym65__;
      double lcm_sym64__;
      double lcm_sym63__;
      double lcm_sym62__;
      int lcm_sym61__;
      int lcm_sym60__;
      int lcm_sym59__;
      int lcm_sym58__;
      int lcm_sym57__;
      int lcm_sym56__;
      int lcm_sym55__;
      int lcm_sym54__;
      int lcm_sym53__;
      int lcm_sym52__;
      int lcm_sym51__;
      int lcm_sym50__;
      int lcm_sym49__;
      int lcm_sym48__;
      int lcm_sym47__;
      int lcm_sym46__;
      double mean_p;
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<double,-1,1> beta;
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, 1, lp__,
               max_age);
      Eigen::Matrix<double,-1,-1> phi =
        Eigen::Matrix<double,-1,-1>::Constant(nind, (n_occasions - 1),
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> p =
        Eigen::Matrix<double,-1,-1>::Constant(nind, (n_occasions - 1),
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> chi =
        Eigen::Matrix<double,-1,-1>::Constant(nind, n_occasions,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(mean_p);
      out__.write(beta);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      lcm_sym46__ = stan::math::logical_gte(nind, 1);
      if (lcm_sym46__) {
        lcm_sym71__ = stan::model::rvalue(first, "first",
                        stan::model::index_uni(1));
        lcm_sym55__ = (lcm_sym71__ - 1);
        if (stan::math::logical_gte(lcm_sym55__, 1)) {
          stan::model::assign(phi, 0, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          current_statement__ = 6;
          stan::model::assign(p, 0, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int t = 2; t <= lcm_sym55__; ++t) {
            current_statement__ = 7;
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        lcm_sym53__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym53__, lcm_sym71__)) {
          current_statement__ = 9;
          stan::model::assign(phi,
            stan::model::rvalue(beta, "beta",
              stan::model::index_uni(
                stan::model::rvalue(x, "x", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym71__)))),
            "assigning variable phi", stan::model::index_uni(1),
            stan::model::index_uni(lcm_sym71__));
          lcm_sym61__ = (lcm_sym71__ + 1);
          stan::model::assign(p, mean_p, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym71__));
          for (int t = lcm_sym61__; t <= lcm_sym53__; ++t) {
            current_statement__ = 9;
            stan::model::assign(phi,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni(
                  stan::model::rvalue(x, "x", stan::model::index_uni(1),
                    stan::model::index_uni(t)))), "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 10;
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          lcm_sym70__ = stan::model::rvalue(first, "first",
                          stan::model::index_uni(i));
          lcm_sym54__ = (lcm_sym70__ - 1);
          if (stan::math::logical_gte(lcm_sym54__, 1)) {
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(1));
            for (int t = 2; t <= lcm_sym54__; ++t) {
              current_statement__ = 7;
              stan::model::assign(phi, 0, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 6;
              stan::model::assign(p, 0, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
          current_statement__ = 12;
          if (stan::math::logical_gte(lcm_sym53__, lcm_sym70__)) {
            current_statement__ = 9;
            stan::model::assign(phi,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni(
                  stan::model::rvalue(x, "x", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym70__)))),
              "assigning variable phi", stan::model::index_uni(i),
              stan::model::index_uni(lcm_sym70__));
            lcm_sym60__ = (lcm_sym70__ + 1);
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym70__));
            for (int t = lcm_sym60__; t <= lcm_sym53__; ++t) {
              current_statement__ = 9;
              stan::model::assign(phi,
                stan::model::rvalue(beta, "beta",
                  stan::model::index_uni(
                    stan::model::rvalue(x, "x", stan::model::index_uni(i),
                      stan::model::index_uni(t)))), "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 10;
              stan::model::assign(p, mean_p, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
        }
      }
      Eigen::Matrix<double,-1,-1> inline_prob_uncaptured_return_sym1__;
      {
        current_statement__ = 14;
        stan::math::validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          n_occasions);
        Eigen::Matrix<double,-1,-1> inline_prob_uncaptured_chi_sym2__ =
          Eigen::Matrix<double,-1,-1>::Constant(nind, n_occasions,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 24;
        if (lcm_sym46__) {
          current_statement__ = 17;
          stan::model::assign(inline_prob_uncaptured_chi_sym2__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym2__",
            stan::model::index_uni(1), stan::model::index_uni(n_occasions));
          lcm_sym53__ = (n_occasions - 1);
          lcm_sym47__ = stan::math::logical_gte(lcm_sym53__, 1);
          if (lcm_sym47__) {
            int inline_prob_uncaptured_t_curr_sym3__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym4__ =
              std::numeric_limits<int>::min();
            lcm_sym59__ = (lcm_sym53__ + 1);
            current_statement__ = 20;
            stan::model::assign(inline_prob_uncaptured_chi_sym2__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym53__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym59__ - 1))))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                  "inline_prob_uncaptured_chi_sym2__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym59__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym53__)))),
              "assigning variable inline_prob_uncaptured_chi_sym2__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym53__));
            for (int inline_prob_uncaptured_t_sym5__ = 2; inline_prob_uncaptured_t_sym5__
                 <= lcm_sym53__; ++inline_prob_uncaptured_t_sym5__) {
              int inline_prob_uncaptured_t_curr_sym3__ =
                std::numeric_limits<int>::min();
              lcm_sym52__ = (n_occasions - inline_prob_uncaptured_t_sym5__);
              int inline_prob_uncaptured_t_next_sym4__ =
                std::numeric_limits<int>::min();
              lcm_sym58__ = (lcm_sym52__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym2__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym52__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni((lcm_sym58__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                    "inline_prob_uncaptured_chi_sym2__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym58__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym52__)))),
                "assigning variable inline_prob_uncaptured_chi_sym2__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym52__));
            }
          }
          for (int inline_prob_uncaptured_i_sym6__ = 2; inline_prob_uncaptured_i_sym6__
               <= nind; ++inline_prob_uncaptured_i_sym6__) {
            current_statement__ = 17;
            stan::model::assign(inline_prob_uncaptured_chi_sym2__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym2__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
              stan::model::index_uni(n_occasions));
            current_statement__ = 22;
            if (lcm_sym47__) {
              int inline_prob_uncaptured_t_curr_sym3__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym4__ =
                std::numeric_limits<int>::min();
              lcm_sym59__ = (lcm_sym53__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym2__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                     stan::model::index_uni(lcm_sym53__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                    stan::model::index_uni((lcm_sym59__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                    "inline_prob_uncaptured_chi_sym2__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                    stan::model::index_uni(lcm_sym59__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                    stan::model::index_uni(lcm_sym53__)))),
                "assigning variable inline_prob_uncaptured_chi_sym2__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                stan::model::index_uni(lcm_sym53__));
              for (int inline_prob_uncaptured_t_sym5__ = 2; inline_prob_uncaptured_t_sym5__
                   <= lcm_sym53__; ++inline_prob_uncaptured_t_sym5__) {
                int inline_prob_uncaptured_t_curr_sym3__ =
                  std::numeric_limits<int>::min();
                lcm_sym52__ = (n_occasions -
                  inline_prob_uncaptured_t_sym5__);
                int inline_prob_uncaptured_t_next_sym4__ =
                  std::numeric_limits<int>::min();
                lcm_sym58__ = (lcm_sym52__ + 1);
                current_statement__ = 20;
                stan::model::assign(inline_prob_uncaptured_chi_sym2__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                       stan::model::index_uni(lcm_sym52__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                      stan::model::index_uni((lcm_sym58__ - 1))))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                      "inline_prob_uncaptured_chi_sym2__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                      stan::model::index_uni(lcm_sym58__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                      stan::model::index_uni(lcm_sym52__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym2__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                  stan::model::index_uni(lcm_sym52__));
              }
            }
          }
        }
        current_statement__ = 25;
        stan::model::assign(inline_prob_uncaptured_return_sym1__,
          inline_prob_uncaptured_chi_sym2__,
          "assigning variable inline_prob_uncaptured_return_sym1__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym1__,
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym1__, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym1__, 1);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(inline_prob_uncaptured_return_sym1__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ mean_p;
      current_statement__ = 1;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 2;
      stan::model::assign(beta,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(max_age),
        "assigning variable beta");
      out__.write_free_lub(0, 1, beta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mean_p", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "beta", "double",
        std::vector<size_t>{static_cast<size_t>(max_age)});
      double lcm_sym45__;
      double lcm_sym44__;
      int lcm_sym43__;
      int lcm_sym42__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ mean_p;
      current_statement__ = 1;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(max_age, DUMMY_VAR__);
      {
        std::vector<double> beta_flat__;
        current_statement__ = 2;
        beta_flat__ = context__.vals_r("beta");
        pos__ = 1;
        if (stan::math::logical_gte(max_age, 1)) {
          stan::model::assign(beta,
            stan::model::rvalue(beta_flat__, "beta_flat__",
              stan::model::index_uni(1)), "assigning variable beta",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= max_age; ++sym1__) {
            stan::model::assign(beta, beta_flat__[(pos__ - 1)],
              "assigning variable beta", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_lub(0, 1, beta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mean_p", "beta"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"phi", "p", "chi"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(max_age)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(nind),
               static_cast<size_t>(n_occ_minus_1)},
             std::vector<size_t>{static_cast<size_t>(nind),
               static_cast<size_t>(n_occ_minus_1)},
             std::vector<size_t>{static_cast<size_t>(nind),
               static_cast<size_t>(n_occasions)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym172__ = 1; sym172__ <= max_age; ++sym172__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym172__));
    }
    if (emit_transformed_parameters__) {
      for (int sym172__ = 1; sym172__ <= n_occ_minus_1; ++sym172__) {
        for (int sym173__ = 1; sym173__ <= nind; ++sym173__) {
          param_names__.emplace_back(std::string() + "phi" + '.' +
            std::to_string(sym173__) + '.' + std::to_string(sym172__));
        }
      }
      for (int sym172__ = 1; sym172__ <= n_occ_minus_1; ++sym172__) {
        for (int sym173__ = 1; sym173__ <= nind; ++sym173__) {
          param_names__.emplace_back(std::string() + "p" + '.' +
            std::to_string(sym173__) + '.' + std::to_string(sym172__));
        }
      }
      for (int sym172__ = 1; sym172__ <= n_occasions; ++sym172__) {
        for (int sym173__ = 1; sym173__ <= nind; ++sym173__) {
          param_names__.emplace_back(std::string() + "chi" + '.' +
            std::to_string(sym173__) + '.' + std::to_string(sym172__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym172__ = 1; sym172__ <= max_age; ++sym172__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym172__));
    }
    if (emit_transformed_parameters__) {
      for (int sym172__ = 1; sym172__ <= n_occ_minus_1; ++sym172__) {
        for (int sym173__ = 1; sym173__ <= nind; ++sym173__) {
          param_names__.emplace_back(std::string() + "phi" + '.' +
            std::to_string(sym173__) + '.' + std::to_string(sym172__));
        }
      }
      for (int sym172__ = 1; sym172__ <= n_occ_minus_1; ++sym172__) {
        for (int sym173__ = 1; sym173__ <= nind; ++sym173__) {
          param_names__.emplace_back(std::string() + "p" + '.' +
            std::to_string(sym173__) + '.' + std::to_string(sym172__));
        }
      }
      for (int sym172__ = 1; sym172__ <= n_occasions; ++sym172__) {
        for (int sym173__ = 1; sym173__ <= nind; ++sym173__) {
          param_names__.emplace_back(std::string() + "chi" + '.' +
            std::to_string(sym173__) + '.' + std::to_string(sym172__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(max_age) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(max_age) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + max_age);
    const size_t num_transformed = emit_transformed_parameters * ((((nind *
      n_occ_minus_1) + (nind * n_occ_minus_1)) + (nind * n_occasions)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + max_age);
    const size_t num_transformed = emit_transformed_parameters * ((((nind *
      n_occ_minus_1) + (nind * n_occ_minus_1)) + (nind * n_occasions)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = fails_test_model_namespace::fails_test_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return fails_test_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp function-in-function-inline.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace function_in_function_inline_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 8> locations_array__ =
  {" (found before start of program)",
  " (in 'function-in-function-inline.stan', line 14, column 2 to column 29)",
  " (in 'function-in-function-inline.stan', line 15, column 2 to column 16)",
  " (in 'function-in-function-inline.stan', line 11, column 2 to column 17)",
  " (in 'function-in-function-inline.stan', line 3, column 4 to column 20)",
  " (in 'function-in-function-inline.stan', line 2, column 30 to line 4, column 3)",
  " (in 'function-in-function-inline.stan', line 7, column 4 to column 27)",
  " (in 'function-in-function-inline.stan', line 6, column 30 to line 8, column 3)"};
template <bool propto__, typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
inner_lpdf(const T0__& phi_arg__, std::ostream* pstream__);
template <bool propto__, typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
outer_lpdf(const T0__& phi_arg__, std::ostream* pstream__);
template <bool propto__, typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
inner_lpdf(const T0__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& phi = stan::math::to_ref(phi_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym15__;
    {
      current_statement__ = 4;
      return stan::math::sum(phi);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <bool propto__, typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
outer_lpdf(const T0__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& phi = stan::math::to_ref(phi_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym16__;
    {
      current_statement__ = 6;
      return inner_lpdf<false>(phi, pstream__);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class function_in_function_inline_model final : public model_base_crtp<function_in_function_inline_model> {
 private:
  double lcm_sym23__;
  double lcm_sym22__;
  int lcm_sym21__;
  Eigen::Matrix<double,-1,1> phi_data__;
  Eigen::Map<Eigen::Matrix<double,-1,1>> phi{nullptr, 0};
 public:
  ~function_in_function_inline_model() {}
  function_in_function_inline_model(stan::io::var_context& context__,
                                    unsigned int random_seed__ = 0,
                                    std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "function_in_function_inline_model_namespace::function_in_function_inline_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 3;
      context__.validate_dims("data initialization", "phi", "double",
        std::vector<size_t>{static_cast<size_t>(10)});
      phi_data__ = Eigen::Matrix<double,-1,1>::Constant(10,
                     std::numeric_limits<double>::quiet_NaN());
      new (&phi) Eigen::Map<Eigen::Matrix<double,-1,1>>(phi_data__.data(),
        10);
      {
        std::vector<double> phi_flat__;
        current_statement__ = 3;
        phi_flat__ = context__.vals_r("phi");
        pos__ = 1;
        {
          stan::model::assign(phi,
            stan::model::rvalue(phi_flat__, "phi_flat__",
              stan::model::index_uni(1)), "assigning variable phi",
            stan::model::index_uni(1));
          pos__ = 2;
          {
            stan::model::assign(phi, phi_flat__[(pos__ - 1)],
              "assigning variable phi", stan::model::index_uni(2));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(phi, phi_flat__[(pos__ - 1)],
              "assigning variable phi", stan::model::index_uni(3));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(phi, phi_flat__[(pos__ - 1)],
              "assigning variable phi", stan::model::index_uni(4));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(phi, phi_flat__[(pos__ - 1)],
              "assigning variable phi", stan::model::index_uni(5));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(phi, phi_flat__[(pos__ - 1)],
              "assigning variable phi", stan::model::index_uni(6));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(phi, phi_flat__[(pos__ - 1)],
              "assigning variable phi", stan::model::index_uni(7));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(phi, phi_flat__[(pos__ - 1)],
              "assigning variable phi", stan::model::index_uni(8));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(phi, phi_flat__[(pos__ - 1)],
              "assigning variable phi", stan::model::index_uni(9));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(phi, phi_flat__[(pos__ - 1)],
              "assigning variable phi", stan::model::index_uni(10));
            pos__ = (pos__ + 1);
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "function_in_function_inline_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "function_in_function_inline_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym20__;
      {
        double ret = std::numeric_limits<double>::quiet_NaN();
        double inline_outer_lpdf_return_sym12__;
        {
          double inline_outer_lpdf_inline_inner_lpdf_return_sym5___sym13__;
          {
            lcm_sym20__ = stan::math::sum(phi);
          }
        }
        current_statement__ = 2;
        lp_accum__.add(lcm_sym20__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "function_in_function_inline_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym19__;
      {
        double ret = std::numeric_limits<double>::quiet_NaN();
        double inline_outer_lpdf_return_sym9__;
        {
          double inline_outer_lpdf_inline_inner_lpdf_return_sym5___sym10__;
          {
            lcm_sym19__ = stan::math::sum(phi);
          }
        }
        current_statement__ = 2;
        lp_accum__.add(lcm_sym19__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "function_in_function_inline_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym18__;
      int lcm_sym17__;
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = function_in_function_inline_model_namespace::function_in_function_inline_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return function_in_function_inline_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp function-in-function-loops.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace function_in_function_loops_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 16> locations_array__ =
  {" (found before start of program)",
  " (in 'function-in-function-loops.stan', line 25, column 9 to column 10)",
  " (in 'function-in-function-loops.stan', line 25, column 2 to column 37)",
  " (in 'function-in-function-loops.stan', line 26, column 2 to column 25)",
  " (in 'function-in-function-loops.stan', line 10, column 4 to column 21)",
  " (in 'function-in-function-loops.stan', line 11, column 4 to column 25)",
  " (in 'function-in-function-loops.stan', line 3, column 4 to line 6, column 15)",
  " (in 'function-in-function-loops.stan', line 2, column 27 to line 7, column 3)",
  " (in 'function-in-function-loops.stan', line 12, column 21 to line 14, column 5)",
  " (in 'function-in-function-loops.stan', line 12, column 4 to line 14, column 5)",
  " (in 'function-in-function-loops.stan', line 15, column 4 to column 23)",
  " (in 'function-in-function-loops.stan', line 27, column 2 to column 16)",
  " (in 'function-in-function-loops.stan', line 21, column 2 to column 8)",
  " (in 'function-in-function-loops.stan', line 6, column 6 to column 15)",
  " (in 'function-in-function-loops.stan', line 13, column 8 to column 43)",
  " (in 'function-in-function-loops.stan', line 9, column 24 to line 16, column 3)"};
template <typename T0__,
          stan::require_all_t<stan::is_stan_scalar<T0__>>* = nullptr>
stan::promote_args_t<T0__>
do_something(const T0__& x, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
summer(const T0__& et_arg__, std::ostream* pstream__);
template <typename T0__, stan::require_all_t<stan::is_stan_scalar<T0__>>*>
stan::promote_args_t<T0__>
do_something(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 13;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
summer(const T0__& et_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& et = stan::math::to_ref(et_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym27__;
    int lcm_sym26__;
    double lcm_sym25__;
    double lcm_sym24__;
    int lcm_sym23__;
    {
      int N = std::numeric_limits<int>::min();
      lcm_sym26__ = stan::math::size(et);
      N = lcm_sym26__;
      local_scalar_t__ running_sum;
      running_sum = 0;
      current_statement__ = 9;
      if (stan::math::logical_gte(lcm_sym26__, 1)) {
        current_statement__ = 14;
        running_sum = (0 +
          do_something(
            stan::model::rvalue(et, "et", stan::model::index_uni(1)),
            pstream__));
        for (int n = 2; n <= lcm_sym26__; ++n) {
          current_statement__ = 14;
          running_sum = (running_sum +
            do_something(
              stan::model::rvalue(et, "et", stan::model::index_uni(n)),
              pstream__));
        }
      }
      current_statement__ = 10;
      return running_sum;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class function_in_function_loops_model final : public model_base_crtp<function_in_function_loops_model> {
 private:
  int N;
 public:
  ~function_in_function_loops_model() {}
  function_in_function_loops_model(stan::io::var_context& context__,
                                   unsigned int random_seed__ = 0,
                                   std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "function_in_function_loops_model_namespace::function_in_function_loops_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 12;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 12;
      N = context__.vals_i("N")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "function_in_function_loops_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "function_in_function_loops_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym45__;
      double lcm_sym44__;
      double lcm_sym43__;
      int lcm_sym42__;
      Eigen::Matrix<double,-1,1> lcm_sym41__;
      double lcm_sym40__;
      double lcm_sym39__;
      int lcm_sym38__;
      {
        current_statement__ = 1;
        stan::math::validate_non_negative_index("eta", "N", N);
        Eigen::Matrix<double,-1,1> eta =
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN());
        stan::model::assign(lcm_sym41__, stan::math::rep_vector(0.0, N),
          "assigning variable lcm_sym41__");
        double out = std::numeric_limits<double>::quiet_NaN();
        double inline_summer_return_sym15__;
        {
          int inline_summer_N_sym16__ = std::numeric_limits<int>::min();
          lcm_sym42__ = stan::math::size(lcm_sym41__);
          double inline_summer_running_sum_sym17__;
          inline_summer_running_sum_sym17__ = 0;
          current_statement__ = 9;
          if (stan::math::logical_gte(lcm_sym42__, 1)) {
            double inline_summer_inline_do_something_return_sym4___sym18__;
            int
              inline_summer_inline_do_something_early_ret_check_sym5___sym19__ =
              std::numeric_limits<int>::min();
            for (int
                   inline_summer_inline_do_something_iterator_sym6___sym20__ =
                   1; inline_summer_inline_do_something_iterator_sym6___sym20__
                 <=
                 1; ++inline_summer_inline_do_something_iterator_sym6___sym20__) {
              inline_summer_inline_do_something_return_sym4___sym18__ = 
                stan::model::rvalue(lcm_sym41__, "lcm_sym41__",
                  stan::model::index_uni(1));
              break;
            }
            inline_summer_running_sum_sym17__ = (0 +
              inline_summer_inline_do_something_return_sym4___sym18__);
            for (int inline_summer_n_sym21__ = 2; inline_summer_n_sym21__ <=
                 lcm_sym42__; ++inline_summer_n_sym21__) {
              double inline_summer_inline_do_something_return_sym4___sym18__;
              int
                inline_summer_inline_do_something_early_ret_check_sym5___sym19__ =
                std::numeric_limits<int>::min();
              for (int
                     inline_summer_inline_do_something_iterator_sym6___sym20__ =
                     1; inline_summer_inline_do_something_iterator_sym6___sym20__
                   <=
                   1; ++inline_summer_inline_do_something_iterator_sym6___sym20__) {
                inline_summer_inline_do_something_return_sym4___sym18__ = lcm_sym41__[(inline_summer_n_sym21__
                  - 1)];
                break;
              }
              inline_summer_running_sum_sym17__ = (inline_summer_running_sum_sym17__
                + inline_summer_inline_do_something_return_sym4___sym18__);
            }
          }
          current_statement__ = 10;
          inline_summer_return_sym15__ = inline_summer_running_sum_sym17__;
        }
        current_statement__ = 11;
        lp_accum__.add(inline_summer_return_sym15__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "function_in_function_loops_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym37__;
      double lcm_sym36__;
      double lcm_sym35__;
      int lcm_sym34__;
      Eigen::Matrix<double,-1,1> lcm_sym33__;
      double lcm_sym32__;
      double lcm_sym31__;
      int lcm_sym30__;
      {
        current_statement__ = 1;
        stan::math::validate_non_negative_index("eta", "N", N);
        stan::math::var_value<Eigen::Matrix<double,-1,1>> eta =
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN());
        stan::model::assign(lcm_sym33__, stan::math::rep_vector(0.0, N),
          "assigning variable lcm_sym33__");
        double out = std::numeric_limits<double>::quiet_NaN();
        double inline_summer_return_sym7__;
        {
          int inline_summer_N_sym8__ = std::numeric_limits<int>::min();
          lcm_sym34__ = stan::math::size(lcm_sym33__);
          double inline_summer_running_sum_sym9__;
          inline_summer_running_sum_sym9__ = 0;
          current_statement__ = 9;
          if (stan::math::logical_gte(lcm_sym34__, 1)) {
            double inline_summer_inline_do_something_return_sym4___sym10__;
            int
              inline_summer_inline_do_something_early_ret_check_sym5___sym11__ =
              std::numeric_limits<int>::min();
            for (int
                   inline_summer_inline_do_something_iterator_sym6___sym12__ =
                   1; inline_summer_inline_do_something_iterator_sym6___sym12__
                 <=
                 1; ++inline_summer_inline_do_something_iterator_sym6___sym12__) {
              inline_summer_inline_do_something_return_sym4___sym10__ = 
                stan::model::rvalue(lcm_sym33__, "lcm_sym33__",
                  stan::model::index_uni(1));
              break;
            }
            inline_summer_running_sum_sym9__ = (0 +
              inline_summer_inline_do_something_return_sym4___sym10__);
            for (int inline_summer_n_sym13__ = 2; inline_summer_n_sym13__ <=
                 lcm_sym34__; ++inline_summer_n_sym13__) {
              double inline_summer_inline_do_something_return_sym4___sym10__;
              int
                inline_summer_inline_do_something_early_ret_check_sym5___sym11__ =
                std::numeric_limits<int>::min();
              for (int
                     inline_summer_inline_do_something_iterator_sym6___sym12__ =
                     1; inline_summer_inline_do_something_iterator_sym6___sym12__
                   <=
                   1; ++inline_summer_inline_do_something_iterator_sym6___sym12__) {
                inline_summer_inline_do_something_return_sym4___sym10__ = lcm_sym33__[(inline_summer_n_sym13__
                  - 1)];
                break;
              }
              inline_summer_running_sum_sym9__ = (inline_summer_running_sum_sym9__
                + inline_summer_inline_do_something_return_sym4___sym10__);
            }
          }
          current_statement__ = 10;
          inline_summer_return_sym7__ = inline_summer_running_sum_sym9__;
        }
        current_statement__ = 11;
        lp_accum__.add(inline_summer_return_sym7__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "function_in_function_loops_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym29__;
      int lcm_sym28__;
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = function_in_function_loops_model_namespace::function_in_function_loops_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return function_in_function_loops_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp initialize-SoA.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace initialize_SoA_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 7> locations_array__ =
  {" (found before start of program)",
  " (in 'initialize-SoA.stan', line 2, column 2 to column 14)",
  " (in 'initialize-SoA.stan', line 3, column 2 to column 29)",
  " (in 'initialize-SoA.stan', line 6, column 2 to column 25)",
  " (in 'initialize-SoA.stan', line 9, column 2 to column 19)",
  " (in 'initialize-SoA.stan', line 11, column 4 to column 30)",
  " (in 'initialize-SoA.stan', line 10, column 2 to line 12, column 3)"};
class initialize_SoA_model final : public model_base_crtp<initialize_SoA_model> {
 private:
  
 public:
  ~initialize_SoA_model() {}
  initialize_SoA_model(stan::io::var_context& context__, unsigned int
                       random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "initialize_SoA_model_namespace::initialize_SoA_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 3 + (3 * 4);
  }
  inline std::string model_name() const final {
    return "initialize_SoA_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "initialize_SoA_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      Eigen::Matrix<local_scalar_t__,-1,1> y;
      current_statement__ = 1;
      y = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(3);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> arr_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(3,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(4, DUMMY_VAR__));
      current_statement__ = 2;
      arr_vec = in__.template read<
                  std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(3, 4);
      Eigen::Matrix<local_scalar_t__,-1,1> x =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      stan::model::assign(lcm_sym20__,
        stan::model::rvalue(y, "y", stan::model::index_min_max(1, 3)),
        "assigning variable lcm_sym20__");
      stan::model::assign(x, lcm_sym20__, "assigning variable x");
      {
        current_statement__ = 4;
        lp_accum__.add(stan::math::std_normal_lpdf<propto__>(lcm_sym20__));
        {
          current_statement__ = 5;
          lp_accum__.add(stan::math::std_normal_lpdf<propto__>(
                           stan::model::rvalue(arr_vec, "arr_vec",
                             stan::model::index_uni(1))));
          {
            current_statement__ = 5;
            lp_accum__.add(stan::math::std_normal_lpdf<propto__>(
                             stan::model::rvalue(arr_vec, "arr_vec",
                               stan::model::index_uni(2))));
          }
          {
            current_statement__ = 5;
            lp_accum__.add(stan::math::std_normal_lpdf<propto__>(
                             stan::model::rvalue(arr_vec, "arr_vec",
                               stan::model::index_uni(3))));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "initialize_SoA_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      stan::math::var_value<Eigen::Matrix<double,-1,1>> y;
      current_statement__ = 1;
      y = in__.template read<
            stan::math::var_value<Eigen::Matrix<double,-1,1>>>(3);
      std::vector<stan::math::var_value<Eigen::Matrix<double,-1,1>>>
        arr_vec =
        std::vector<stan::math::var_value<Eigen::Matrix<double,-1,1>>>(3,
          stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(4,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                ))));
      current_statement__ = 2;
      arr_vec = in__.template read<
                  std::vector<
                    stan::math::var_value<Eigen::Matrix<double,-1,1>>>>(3, 4);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> x =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(3,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      stan::model::assign(lcm_sym16__,
        stan::model::rvalue(y, "y", stan::model::index_min_max(1, 3)),
        "assigning variable lcm_sym16__");
      stan::model::assign(x, lcm_sym16__, "assigning variable x");
      {
        current_statement__ = 4;
        lp_accum__.add(stan::math::std_normal_lpdf<propto__>(lcm_sym16__));
        {
          current_statement__ = 5;
          lp_accum__.add(stan::math::std_normal_lpdf<propto__>(
                           stan::model::rvalue(arr_vec, "arr_vec",
                             stan::model::index_uni(1))));
          {
            current_statement__ = 5;
            lp_accum__.add(stan::math::std_normal_lpdf<propto__>(
                             stan::model::rvalue(arr_vec, "arr_vec",
                               stan::model::index_uni(2))));
          }
          {
            current_statement__ = 5;
            lp_accum__.add(stan::math::std_normal_lpdf<propto__>(
                             stan::model::rvalue(arr_vec, "arr_vec",
                               stan::model::index_uni(3))));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "initialize_SoA_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,1> lcm_sym12__;
      double lcm_sym11__;
      double lcm_sym10__;
      double lcm_sym9__;
      double lcm_sym8__;
      int lcm_sym7__;
      int lcm_sym6__;
      Eigen::Matrix<double,-1,1> y;
      current_statement__ = 1;
      y = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(3);
      std::vector<Eigen::Matrix<double,-1,1>> arr_vec =
        std::vector<Eigen::Matrix<double,-1,1>>(3,
          Eigen::Matrix<double,-1,1>::Constant(4,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 2;
      arr_vec = in__.template read<
                  std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(3, 4);
      Eigen::Matrix<double,-1,1> x =
        Eigen::Matrix<double,-1,1>::Constant(3,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(y);
      {
        {
          out__.write(stan::model::rvalue(arr_vec, "arr_vec",
                        stan::model::index_uni(1), stan::model::index_uni(1)));
          {
            out__.write(stan::model::rvalue(arr_vec, "arr_vec",
                          stan::model::index_uni(2),
                          stan::model::index_uni(1)));
          }
          {
            out__.write(stan::model::rvalue(arr_vec, "arr_vec",
                          stan::model::index_uni(3),
                          stan::model::index_uni(1)));
          }
        }
        {
          out__.write(stan::model::rvalue(arr_vec, "arr_vec",
                        stan::model::index_uni(1), stan::model::index_uni(2)));
          {
            out__.write(stan::model::rvalue(arr_vec, "arr_vec",
                          stan::model::index_uni(2),
                          stan::model::index_uni(2)));
          }
          {
            out__.write(stan::model::rvalue(arr_vec, "arr_vec",
                          stan::model::index_uni(3),
                          stan::model::index_uni(2)));
          }
        }
        {
          out__.write(stan::model::rvalue(arr_vec, "arr_vec",
                        stan::model::index_uni(1), stan::model::index_uni(3)));
          {
            out__.write(stan::model::rvalue(arr_vec, "arr_vec",
                          stan::model::index_uni(2),
                          stan::model::index_uni(3)));
          }
          {
            out__.write(stan::model::rvalue(arr_vec, "arr_vec",
                          stan::model::index_uni(3),
                          stan::model::index_uni(3)));
          }
        }
        {
          out__.write(stan::model::rvalue(arr_vec, "arr_vec",
                        stan::model::index_uni(1), stan::model::index_uni(4)));
          {
            out__.write(stan::model::rvalue(arr_vec, "arr_vec",
                          stan::model::index_uni(2),
                          stan::model::index_uni(4)));
          }
          {
            out__.write(stan::model::rvalue(arr_vec, "arr_vec",
                          stan::model::index_uni(3),
                          stan::model::index_uni(4)));
          }
        }
      }
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      stan::model::assign(lcm_sym12__,
        stan::model::rvalue(y, "y", stan::model::index_min_max(1, 3)),
        "assigning variable lcm_sym12__");
      stan::model::assign(x, lcm_sym12__, "assigning variable x");
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym12__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> y;
      current_statement__ = 1;
      stan::model::assign(y,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(3),
        "assigning variable y");
      out__.write(y);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> arr_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(3,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(4, DUMMY_VAR__));
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          current_statement__ = 2;
          stan::model::assign(arr_vec, in__.read<local_scalar_t__>(),
            "assigning variable arr_vec", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write(arr_vec);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(3)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "arr_vec",
        "double",
        std::vector<size_t>{static_cast<size_t>(3), static_cast<size_t>(4)});
      double lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      double lcm_sym2__;
      int lcm_sym1__;
      int pos__ = std::numeric_limits<int>::min();
      Eigen::Matrix<local_scalar_t__,-1,1> y =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(3, DUMMY_VAR__);
      {
        std::vector<double> y_flat__;
        current_statement__ = 1;
        y_flat__ = context__.vals_r("y");
        {
          stan::model::assign(y,
            stan::model::rvalue(y_flat__, "y_flat__",
              stan::model::index_uni(1)), "assigning variable y",
            stan::model::index_uni(1));
          pos__ = 2;
          {
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(2));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(3));
          }
        }
      }
      out__.write(y);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> arr_vec =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(3,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(4, DUMMY_VAR__));
      {
        std::vector<double> arr_vec_flat__;
        current_statement__ = 2;
        arr_vec_flat__ = context__.vals_r("arr_vec");
        {
          {
            stan::model::assign(arr_vec,
              stan::model::rvalue(arr_vec_flat__, "arr_vec_flat__",
                stan::model::index_uni(1)), "assigning variable arr_vec",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            {
              stan::model::assign(arr_vec, arr_vec_flat__[(pos__ - 1)],
                "assigning variable arr_vec", stan::model::index_uni(2),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(arr_vec, arr_vec_flat__[(pos__ - 1)],
                "assigning variable arr_vec", stan::model::index_uni(3),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(arr_vec, arr_vec_flat__[(pos__ - 1)],
              "assigning variable arr_vec", stan::model::index_uni(1),
              stan::model::index_uni(2));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(arr_vec, arr_vec_flat__[(pos__ - 1)],
                "assigning variable arr_vec", stan::model::index_uni(2),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(arr_vec, arr_vec_flat__[(pos__ - 1)],
                "assigning variable arr_vec", stan::model::index_uni(3),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(arr_vec, arr_vec_flat__[(pos__ - 1)],
              "assigning variable arr_vec", stan::model::index_uni(1),
              stan::model::index_uni(3));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(arr_vec, arr_vec_flat__[(pos__ - 1)],
                "assigning variable arr_vec", stan::model::index_uni(2),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(arr_vec, arr_vec_flat__[(pos__ - 1)],
                "assigning variable arr_vec", stan::model::index_uni(3),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(arr_vec, arr_vec_flat__[(pos__ - 1)],
              "assigning variable arr_vec", stan::model::index_uni(1),
              stan::model::index_uni(4));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(arr_vec, arr_vec_flat__[(pos__ - 1)],
                "assigning variable arr_vec", stan::model::index_uni(2),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(arr_vec, arr_vec_flat__[(pos__ - 1)],
                "assigning variable arr_vec", stan::model::index_uni(3),
                stan::model::index_uni(4));
            }
          }
        }
      }
      out__.write(arr_vec);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"y", "arr_vec"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"x"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(3)},
                std::vector<size_t>{static_cast<size_t>(3),
                  static_cast<size_t>(4)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(3)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym21__ = 1; sym21__ <= 3; ++sym21__) {
      param_names__.emplace_back(std::string() + "y" + '.' +
        std::to_string(sym21__));
    }
    for (int sym21__ = 1; sym21__ <= 4; ++sym21__) {
      for (int sym22__ = 1; sym22__ <= 3; ++sym22__) {
        param_names__.emplace_back(std::string() + "arr_vec" + '.' +
          std::to_string(sym22__) + '.' + std::to_string(sym21__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym21__ = 1; sym21__ <= 3; ++sym21__) {
        param_names__.emplace_back(std::string() + "x" + '.' +
          std::to_string(sym21__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym21__ = 1; sym21__ <= 3; ++sym21__) {
      param_names__.emplace_back(std::string() + "y" + '.' +
        std::to_string(sym21__));
    }
    for (int sym21__ = 1; sym21__ <= 4; ++sym21__) {
      for (int sym22__ = 1; sym22__ <= 3; ++sym22__) {
        param_names__.emplace_back(std::string() + "arr_vec" + '.' +
          std::to_string(sym22__) + '.' + std::to_string(sym21__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym21__ = 1; sym21__ <= 3; ++sym21__) {
        param_names__.emplace_back(std::string() + "x" + '.' +
          std::to_string(sym21__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"y\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"parameters\"},{\"name\":\"arr_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(4) + "}},\"block\":\"parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"y\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"parameters\"},{\"name\":\"arr_vec\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(3) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(4) + "}},\"block\":\"parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (3 + (3 * 4));
    const size_t num_transformed = emit_transformed_parameters * (3);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (3 + (3 * 4));
    const size_t num_transformed = emit_transformed_parameters * (3);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = initialize_SoA_model_namespace::initialize_SoA_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return initialize_SoA_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp inline-functions-varmat.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace inline_functions_varmat_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 14> locations_array__ =
  {" (found before start of program)",
  " (in 'inline-functions-varmat.stan', line 16, column 1 to column 28)",
  " (in 'inline-functions-varmat.stan', line 17, column 1 to column 27)",
  " (in 'inline-functions-varmat.stan', line 21, column 2 to column 65)",
  " (in 'inline-functions-varmat.stan', line 22, column 2 to column 62)",
  " (in 'inline-functions-varmat.stan', line 6, column 4 to column 16)",
  " (in 'inline-functions-varmat.stan', line 9, column 11 to line 11, column 5)",
  " (in 'inline-functions-varmat.stan', line 7, column 20 to line 9, column 5)",
  " (in 'inline-functions-varmat.stan', line 7, column 4 to line 11, column 5)",
  " (in 'inline-functions-varmat.stan', line 5, column 33 to line 12, column 3)",
  " (in 'inline-functions-varmat.stan', line 3, column 4 to column 13)",
  " (in 'inline-functions-varmat.stan', line 2, column 34 to line 4, column 3)",
  " (in 'inline-functions-varmat.stan', line 10, column 6 to column 15)",
  " (in 'inline-functions-varmat.stan', line 8, column 6 to column 15)"};
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
single_ret_fun(const T0__& A_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
multi_ret_fun(const T0__& A_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
single_ret_fun(const T0__& A_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 10;
    return A;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
multi_ret_fun(const T0__& A_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym19__;
    {
      Eigen::Matrix<double,-1,1> B =
        Eigen::Matrix<double,-1,1>::Constant(5,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 8;
      if (stan::math::logical_gt(
            stan::model::rvalue(A, "A", stan::model::index_uni(0)), 1.0)) {
        current_statement__ = 13;
        return B;
      } else {
        current_statement__ = 12;
        return A;
      }
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class inline_functions_varmat_model final : public model_base_crtp<inline_functions_varmat_model> {
 private:
  
 public:
  ~inline_functions_varmat_model() {}
  inline_functions_varmat_model(stan::io::var_context& context__,
                                unsigned int random_seed__ = 0, std::ostream*
                                pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "inline_functions_varmat_model_namespace::inline_functions_varmat_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 5 + 5;
  }
  inline std::string model_name() const final {
    return "inline_functions_varmat_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "inline_functions_varmat_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym29__;
      Eigen::Matrix<local_scalar_t__,-1,1> p_single_ret_vec;
      current_statement__ = 1;
      p_single_ret_vec = in__.template read<
                           Eigen::Matrix<local_scalar_t__,-1,1>>(5);
      Eigen::Matrix<local_scalar_t__,-1,1> p_multi_ret_vec;
      current_statement__ = 2;
      p_multi_ret_vec = in__.template read<
                          Eigen::Matrix<local_scalar_t__,-1,1>>(5);
      Eigen::Matrix<local_scalar_t__,-1,1> tp_single_ret_vec =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(5, DUMMY_VAR__);
      Eigen::Matrix<double,-1,1> inline_single_ret_fun_return_sym13__;
      stan::model::assign(tp_single_ret_vec, p_single_ret_vec,
        "assigning variable tp_single_ret_vec");
      Eigen::Matrix<local_scalar_t__,-1,1> tp_multi_ret_vec =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(5, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1>
        inline_multi_ret_fun_return_sym15__;
      int inline_multi_ret_fun_early_ret_check_sym17__ =
        std::numeric_limits<int>::min();
      for (int inline_multi_ret_fun_iterator_sym18__ = 1; inline_multi_ret_fun_iterator_sym18__
           <= 1; ++inline_multi_ret_fun_iterator_sym18__) {
        Eigen::Matrix<double,-1,1> inline_multi_ret_fun_B_sym16__ =
          Eigen::Matrix<double,-1,1>::Constant(5,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 8;
        if (stan::math::logical_gt(
              stan::model::rvalue(p_multi_ret_vec, "p_multi_ret_vec",
                stan::model::index_uni(0)), 1.0)) {
          stan::model::assign(inline_multi_ret_fun_return_sym15__,
            inline_multi_ret_fun_B_sym16__,
            "assigning variable inline_multi_ret_fun_return_sym15__");
          break;
        } else {
          stan::model::assign(inline_multi_ret_fun_return_sym15__,
            p_multi_ret_vec,
            "assigning variable inline_multi_ret_fun_return_sym15__");
          break;
        }
      }
      stan::model::assign(tp_multi_ret_vec,
        inline_multi_ret_fun_return_sym15__,
        "assigning variable tp_multi_ret_vec");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "inline_functions_varmat_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym28__;
      stan::math::var_value<Eigen::Matrix<double,-1,1>> p_single_ret_vec;
      current_statement__ = 1;
      p_single_ret_vec = in__.template read<
                           stan::math::var_value<Eigen::Matrix<double,-1,1>>>(5);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> p_multi_ret_vec;
      current_statement__ = 2;
      p_multi_ret_vec = in__.template read<
                          stan::math::var_value<Eigen::Matrix<double,-1,1>>>(5);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> tp_single_ret_vec =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(5,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      stan::math::var_value<Eigen::Matrix<double,-1,1>>
        inline_single_ret_fun_return_sym7__;
      stan::model::assign(tp_single_ret_vec, p_single_ret_vec,
        "assigning variable tp_single_ret_vec");
      stan::math::var_value<Eigen::Matrix<double,-1,1>> tp_multi_ret_vec =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(5,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      stan::math::var_value<Eigen::Matrix<double,-1,1>>
        inline_multi_ret_fun_return_sym9__;
      int inline_multi_ret_fun_early_ret_check_sym11__ =
        std::numeric_limits<int>::min();
      for (int inline_multi_ret_fun_iterator_sym12__ = 1; inline_multi_ret_fun_iterator_sym12__
           <= 1; ++inline_multi_ret_fun_iterator_sym12__) {
        stan::math::var_value<Eigen::Matrix<double,-1,1>>
          inline_multi_ret_fun_B_sym10__ =
          Eigen::Matrix<double,-1,1>::Constant(5,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 8;
        if (stan::math::logical_gt(
              stan::model::rvalue(p_multi_ret_vec, "p_multi_ret_vec",
                stan::model::index_uni(0)), 1.0)) {
          stan::model::assign(inline_multi_ret_fun_return_sym9__,
            inline_multi_ret_fun_B_sym10__,
            "assigning variable inline_multi_ret_fun_return_sym9__");
          break;
        } else {
          stan::model::assign(inline_multi_ret_fun_return_sym9__,
            p_multi_ret_vec,
            "assigning variable inline_multi_ret_fun_return_sym9__");
          break;
        }
      }
      stan::model::assign(tp_multi_ret_vec,
        inline_multi_ret_fun_return_sym9__,
        "assigning variable tp_multi_ret_vec");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "inline_functions_varmat_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym27__;
      int lcm_sym26__;
      int lcm_sym25__;
      Eigen::Matrix<double,-1,1> p_single_ret_vec;
      current_statement__ = 1;
      p_single_ret_vec = in__.template read<
                           Eigen::Matrix<local_scalar_t__,-1,1>>(5);
      Eigen::Matrix<double,-1,1> p_multi_ret_vec;
      current_statement__ = 2;
      p_multi_ret_vec = in__.template read<
                          Eigen::Matrix<local_scalar_t__,-1,1>>(5);
      Eigen::Matrix<double,-1,1> tp_single_ret_vec =
        Eigen::Matrix<double,-1,1>::Constant(5,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> tp_multi_ret_vec =
        Eigen::Matrix<double,-1,1>::Constant(5,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(p_single_ret_vec);
      out__.write(p_multi_ret_vec);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      Eigen::Matrix<double,-1,1> inline_single_ret_fun_return_sym1__;
      stan::model::assign(tp_single_ret_vec, p_single_ret_vec,
        "assigning variable tp_single_ret_vec");
      Eigen::Matrix<double,-1,1> inline_multi_ret_fun_return_sym3__;
      int inline_multi_ret_fun_early_ret_check_sym5__ =
        std::numeric_limits<int>::min();
      for (int inline_multi_ret_fun_iterator_sym6__ = 1; inline_multi_ret_fun_iterator_sym6__
           <= 1; ++inline_multi_ret_fun_iterator_sym6__) {
        Eigen::Matrix<double,-1,1> inline_multi_ret_fun_B_sym4__ =
          Eigen::Matrix<double,-1,1>::Constant(5,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 8;
        if (stan::math::logical_gt(
              stan::model::rvalue(p_multi_ret_vec, "p_multi_ret_vec",
                stan::model::index_uni(0)), 1.0)) {
          stan::model::assign(inline_multi_ret_fun_return_sym3__,
            inline_multi_ret_fun_B_sym4__,
            "assigning variable inline_multi_ret_fun_return_sym3__");
          break;
        } else {
          stan::model::assign(inline_multi_ret_fun_return_sym3__,
            p_multi_ret_vec,
            "assigning variable inline_multi_ret_fun_return_sym3__");
          break;
        }
      }
      stan::model::assign(tp_multi_ret_vec,
        inline_multi_ret_fun_return_sym3__,
        "assigning variable tp_multi_ret_vec");
      if (emit_transformed_parameters__) {
        out__.write(p_single_ret_vec);
        out__.write(inline_multi_ret_fun_return_sym3__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> p_single_ret_vec;
      current_statement__ = 1;
      stan::model::assign(p_single_ret_vec,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(5),
        "assigning variable p_single_ret_vec");
      out__.write(p_single_ret_vec);
      Eigen::Matrix<local_scalar_t__,-1,1> p_multi_ret_vec;
      current_statement__ = 2;
      stan::model::assign(p_multi_ret_vec,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(5),
        "assigning variable p_multi_ret_vec");
      out__.write(p_multi_ret_vec);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "p_single_ret_vec",
        "double", std::vector<size_t>{static_cast<size_t>(5)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "p_multi_ret_vec",
        "double", std::vector<size_t>{static_cast<size_t>(5)});
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      int lcm_sym20__;
      int pos__ = std::numeric_limits<int>::min();
      Eigen::Matrix<local_scalar_t__,-1,1> p_single_ret_vec =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(5, DUMMY_VAR__);
      {
        std::vector<double> p_single_ret_vec_flat__;
        current_statement__ = 1;
        p_single_ret_vec_flat__ = context__.vals_r("p_single_ret_vec");
        {
          stan::model::assign(p_single_ret_vec,
            stan::model::rvalue(p_single_ret_vec_flat__,
              "p_single_ret_vec_flat__", stan::model::index_uni(1)),
            "assigning variable p_single_ret_vec", stan::model::index_uni(1));
          pos__ = 2;
          {
            stan::model::assign(p_single_ret_vec,
              p_single_ret_vec_flat__[(pos__ - 1)],
              "assigning variable p_single_ret_vec",
              stan::model::index_uni(2));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(p_single_ret_vec,
              p_single_ret_vec_flat__[(pos__ - 1)],
              "assigning variable p_single_ret_vec",
              stan::model::index_uni(3));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(p_single_ret_vec,
              p_single_ret_vec_flat__[(pos__ - 1)],
              "assigning variable p_single_ret_vec",
              stan::model::index_uni(4));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(p_single_ret_vec,
              p_single_ret_vec_flat__[(pos__ - 1)],
              "assigning variable p_single_ret_vec",
              stan::model::index_uni(5));
          }
        }
      }
      out__.write(p_single_ret_vec);
      Eigen::Matrix<local_scalar_t__,-1,1> p_multi_ret_vec =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(5, DUMMY_VAR__);
      {
        std::vector<double> p_multi_ret_vec_flat__;
        current_statement__ = 2;
        p_multi_ret_vec_flat__ = context__.vals_r("p_multi_ret_vec");
        {
          stan::model::assign(p_multi_ret_vec,
            stan::model::rvalue(p_multi_ret_vec_flat__,
              "p_multi_ret_vec_flat__", stan::model::index_uni(1)),
            "assigning variable p_multi_ret_vec", stan::model::index_uni(1));
          pos__ = 2;
          {
            stan::model::assign(p_multi_ret_vec,
              p_multi_ret_vec_flat__[(pos__ - 1)],
              "assigning variable p_multi_ret_vec", stan::model::index_uni(2));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(p_multi_ret_vec,
              p_multi_ret_vec_flat__[(pos__ - 1)],
              "assigning variable p_multi_ret_vec", stan::model::index_uni(3));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(p_multi_ret_vec,
              p_multi_ret_vec_flat__[(pos__ - 1)],
              "assigning variable p_multi_ret_vec", stan::model::index_uni(4));
            pos__ = (pos__ + 1);
          }
          {
            stan::model::assign(p_multi_ret_vec,
              p_multi_ret_vec_flat__[(pos__ - 1)],
              "assigning variable p_multi_ret_vec", stan::model::index_uni(5));
          }
        }
      }
      out__.write(p_multi_ret_vec);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"p_single_ret_vec", "p_multi_ret_vec"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"tp_single_ret_vec", "tp_multi_ret_vec"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(5)},
                std::vector<size_t>{static_cast<size_t>(5)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(5)},
             std::vector<size_t>{static_cast<size_t>(5)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym30__ = 1; sym30__ <= 5; ++sym30__) {
      param_names__.emplace_back(std::string() + "p_single_ret_vec" + '.' +
        std::to_string(sym30__));
    }
    for (int sym30__ = 1; sym30__ <= 5; ++sym30__) {
      param_names__.emplace_back(std::string() + "p_multi_ret_vec" + '.' +
        std::to_string(sym30__));
    }
    if (emit_transformed_parameters__) {
      for (int sym30__ = 1; sym30__ <= 5; ++sym30__) {
        param_names__.emplace_back(std::string() + "tp_single_ret_vec" + '.'
          + std::to_string(sym30__));
      }
      for (int sym30__ = 1; sym30__ <= 5; ++sym30__) {
        param_names__.emplace_back(std::string() + "tp_multi_ret_vec" + '.' +
          std::to_string(sym30__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym30__ = 1; sym30__ <= 5; ++sym30__) {
      param_names__.emplace_back(std::string() + "p_single_ret_vec" + '.' +
        std::to_string(sym30__));
    }
    for (int sym30__ = 1; sym30__ <= 5; ++sym30__) {
      param_names__.emplace_back(std::string() + "p_multi_ret_vec" + '.' +
        std::to_string(sym30__));
    }
    if (emit_transformed_parameters__) {
      for (int sym30__ = 1; sym30__ <= 5; ++sym30__) {
        param_names__.emplace_back(std::string() + "tp_single_ret_vec" + '.'
          + std::to_string(sym30__));
      }
      for (int sym30__ = 1; sym30__ <= 5; ++sym30__) {
        param_names__.emplace_back(std::string() + "tp_multi_ret_vec" + '.' +
          std::to_string(sym30__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"p_single_ret_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"parameters\"},{\"name\":\"p_multi_ret_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"parameters\"},{\"name\":\"tp_single_ret_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_multi_ret_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"p_single_ret_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"parameters\"},{\"name\":\"p_multi_ret_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"parameters\"},{\"name\":\"tp_single_ret_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_multi_ret_vec\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (5 + 5);
    const size_t num_transformed = emit_transformed_parameters * ((5 + 5));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (5 + 5);
    const size_t num_transformed = emit_transformed_parameters * ((5 + 5));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = inline_functions_varmat_model_namespace::inline_functions_varmat_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return inline_functions_varmat_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp inline-tdata.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace inline_tdata_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 10> locations_array__ =
  {" (found before start of program)",
  " (in 'inline-tdata.stan', line 14, column 2 to column 13)",
  " (in 'inline-tdata.stan', line 18, column 2 to column 32)",
  " (in 'inline-tdata.stan', line 8, column 3 to column 14)",
  " (in 'inline-tdata.stan', line 9, column 3 to column 14)",
  " (in 'inline-tdata.stan', line 10, column 10 to column 11)",
  " (in 'inline-tdata.stan', line 10, column 12 to column 13)",
  " (in 'inline-tdata.stan', line 10, column 3 to column 31)",
  " (in 'inline-tdata.stan', line 3, column 4 to column 31)",
  " (in 'inline-tdata.stan', line 2, column 26 to line 4, column 3)"};
Eigen::Matrix<double,-1,-1>
foo(const int& N, const int& M, std::ostream* pstream__);
Eigen::Matrix<double,-1,-1>
foo(const int& N, const int& M, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    Eigen::Matrix<double,-1,-1> lcm_sym1__;
    {
      current_statement__ = 8;
      return stan::math::promote_scalar<local_scalar_t__>(
               stan::math::rep_matrix(1, N, M));
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class inline_tdata_model final : public model_base_crtp<inline_tdata_model> {
 private:
  Eigen::Matrix<double,-1,-1> lcm_sym6___data__;
  int N;
  int M;
  Eigen::Matrix<double,-1,-1> bar_data__;
  Eigen::Map<Eigen::Matrix<double,-1,-1>> lcm_sym6__{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> bar{nullptr, 0, 0};
 public:
  ~inline_tdata_model() {}
  inline_tdata_model(stan::io::var_context& context__, unsigned int
                     random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "inline_tdata_model_namespace::inline_tdata_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 3;
      N = std::numeric_limits<int>::min();
      current_statement__ = 3;
      N = 10;
      current_statement__ = 4;
      M = std::numeric_limits<int>::min();
      current_statement__ = 4;
      M = 11;
      current_statement__ = 5;
      stan::math::validate_non_negative_index("bar", "N", 10);
      current_statement__ = 6;
      stan::math::validate_non_negative_index("bar", "M", 11);
      current_statement__ = 7;
      bar_data__ = Eigen::Matrix<double,-1,-1>::Constant(10, 11,
                     std::numeric_limits<double>::quiet_NaN());
      new (&bar) Eigen::Map<Eigen::Matrix<double,-1,-1>>(bar_data__.data(),
        10, 11);
      current_statement__ = 7;
      stan::model::assign(bar, foo(10, 11, pstream__),
        "assigning variable bar");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1;
  }
  inline std::string model_name() const final {
    return "inline_tdata_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "inline_tdata_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym5__;
      local_scalar_t__ alpha;
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      {
        current_statement__ = 2;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::sum(foo(10, 11, pstream__)), alpha, 0.1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "inline_tdata_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym4__;
      local_scalar_t__ alpha;
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      {
        current_statement__ = 2;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         stan::math::sum(foo(10, 11, pstream__)), alpha, 0.1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "inline_tdata_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym3__;
      int lcm_sym2__;
      double alpha;
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      out__.write(alpha);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ alpha;
      current_statement__ = 1;
      alpha = in__.read<local_scalar_t__>();
      out__.write(alpha);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "alpha", "double",
        std::vector<size_t>{});
      local_scalar_t__ alpha;
      current_statement__ = 1;
      alpha = context__.vals_r("alpha")[(1 - 1)];
      out__.write(alpha);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"alpha"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = inline_tdata_model_namespace::inline_tdata_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return inline_tdata_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp inliner-same-names.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace inliner_same_names_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 11> locations_array__ =
  {" (found before start of program)",
  " (in 'inliner-same-names.stan', line 16, column 2 to column 14)",
  " (in 'inliner-same-names.stan', line 17, column 2 to column 16)",
  " (in 'inliner-same-names.stan', line 5, column 4 to column 30)",
  " (in 'inliner-same-names.stan', line 7, column 11 to column 13)",
  " (in 'inliner-same-names.stan', line 7, column 4 to column 22)",
  " (in 'inliner-same-names.stan', line 13, column 2 to column 8)",
  " (in 'inliner-same-names.stan', line 16, column 9 to column 10)",
  " (in 'inliner-same-names.stan', line 17, column 9 to column 10)",
  " (in 'inliner-same-names.stan', line 9, column 4 to column 15)",
  " (in 'inliner-same-names.stan', line 2, column 24 to line 10, column 3)"};
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
foo(const T0__& oR_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
foo(const T0__& oR_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& oR = stan::math::to_ref(oR_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym13__;
    {
      int ot = std::numeric_limits<int>::min();
      lcm_sym13__ = stan::math::num_elements(oR);
      current_statement__ = 4;
      stan::math::validate_non_negative_index("R", "ot", lcm_sym13__);
      Eigen::Matrix<local_scalar_t__,-1,1> R;
      current_statement__ = 5;
      stan::model::assign(R, oR, "assigning variable R");
      current_statement__ = 9;
      return oR;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class inliner_same_names_model final : public model_base_crtp<inliner_same_names_model> {
 private:
  int N;
 public:
  ~inliner_same_names_model() {}
  inliner_same_names_model(stan::io::var_context& context__, unsigned int
                           random_seed__ = 0, std::ostream*
                           pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "inliner_same_names_model_namespace::inliner_same_names_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 6;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 6;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 7;
      stan::math::validate_non_negative_index("R", "N", N);
      current_statement__ = 8;
      stan::math::validate_non_negative_index("out", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "inliner_same_names_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "inliner_same_names_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym18__;
      Eigen::Matrix<double,-1,1> R =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> out =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> inline_foo_return_sym9__;
      {
        int inline_foo_ot_sym10__ = std::numeric_limits<int>::min();
        lcm_sym18__ = stan::math::num_elements(R);
        current_statement__ = 4;
        stan::math::validate_non_negative_index("R", "ot", lcm_sym18__);
        Eigen::Matrix<double,-1,1> inline_foo_R_sym11__ =
          Eigen::Matrix<double,-1,1>::Constant(stan::math::num_elements(R),
            std::numeric_limits<double>::quiet_NaN());
      }
      stan::model::assign(out, R, "assigning variable out");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "inliner_same_names_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym17__;
      stan::math::var_value<Eigen::Matrix<double,-1,1>> R =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      stan::math::var_value<Eigen::Matrix<double,-1,1>> out =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      stan::math::var_value<Eigen::Matrix<double,-1,1>>
        inline_foo_return_sym5__;
      {
        int inline_foo_ot_sym6__ = std::numeric_limits<int>::min();
        lcm_sym17__ = stan::math::num_elements(R);
        current_statement__ = 4;
        stan::math::validate_non_negative_index("R", "ot", lcm_sym17__);
        stan::math::var_value<Eigen::Matrix<double,-1,1>>
          inline_foo_R_sym7__ =
          Eigen::Matrix<double,-1,1>::Constant(stan::math::num_elements(R),
            std::numeric_limits<double>::quiet_NaN());
      }
      stan::model::assign(out, R, "assigning variable out");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "inliner_same_names_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym16__;
      int lcm_sym15__;
      int lcm_sym14__;
      Eigen::Matrix<double,-1,1> R =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> out =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      Eigen::Matrix<double,-1,1> inline_foo_return_sym1__;
      {
        int inline_foo_ot_sym2__ = std::numeric_limits<int>::min();
        lcm_sym16__ = stan::math::num_elements(R);
        current_statement__ = 4;
        stan::math::validate_non_negative_index("R", "ot", lcm_sym16__);
        Eigen::Matrix<double,-1,1> inline_foo_R_sym3__ =
          Eigen::Matrix<double,-1,1>::Constant(stan::math::num_elements(R),
            std::numeric_limits<double>::quiet_NaN());
      }
      stan::model::assign(out, R, "assigning variable out");
      if (emit_transformed_parameters__) {
        out__.write(R);
        out__.write(R);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"R", "out"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(N)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {
      for (int sym19__ = 1; sym19__ <= N; ++sym19__) {
        param_names__.emplace_back(std::string() + "R" + '.' +
          std::to_string(sym19__));
      }
      for (int sym19__ = 1; sym19__ <= N; ++sym19__) {
        param_names__.emplace_back(std::string() + "out" + '.' +
          std::to_string(sym19__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {
      for (int sym19__ = 1; sym19__ <= N; ++sym19__) {
        param_names__.emplace_back(std::string() + "R" + '.' +
          std::to_string(sym19__));
      }
      for (int sym19__ = 1; sym19__ <= N; ++sym19__) {
        param_names__.emplace_back(std::string() + "out" + '.' +
          std::to_string(sym19__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"R\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"out\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"R\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"out\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * ((N + N));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * ((N + N));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = inliner_same_names_model_namespace::inliner_same_names_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return inliner_same_names_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp inlining-fail2.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace inlining_fail2_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 146> locations_array__ =
  {" (found before start of program)",
  " (in 'inlining-fail2.stan', line 175, column 2 to column 34)",
  " (in 'inlining-fail2.stan', line 176, column 2 to column 32)",
  " (in 'inlining-fail2.stan', line 177, column 2 to column 46)",
  " (in 'inlining-fail2.stan', line 178, column 2 to column 34)",
  " (in 'inlining-fail2.stan', line 179, column 2 to column 31)",
  " (in 'inlining-fail2.stan', line 184, column 2 to column 51)",
  " (in 'inlining-fail2.stan', line 185, column 2 to column 45)",
  " (in 'inlining-fail2.stan', line 186, column 2 to column 47)",
  " (in 'inlining-fail2.stan', line 208, column 2 to column 14)",
  " (in 'inlining-fail2.stan', line 209, column 2 to column 11)",
  " (in 'inlining-fail2.stan', line 210, column 2 to column 24)",
  " (in 'inlining-fail2.stan', line 211, column 2 to column 13)",
  " (in 'inlining-fail2.stan', line 212, column 2 to column 27)",
  " (in 'inlining-fail2.stan', line 213, column 2 to column 27)",
  " (in 'inlining-fail2.stan', line 214, column 2 to column 30)",
  " (in 'inlining-fail2.stan', line 191, column 6 to column 58)",
  " (in 'inlining-fail2.stan', line 190, column 4 to line 191, column 58)",
  " (in 'inlining-fail2.stan', line 189, column 2 to line 191, column 58)",
  " (in 'inlining-fail2.stan', line 49, column 4 to column 24)",
  " (in 'inlining-fail2.stan', line 50, column 4 to column 30)",
  " (in 'inlining-fail2.stan', line 51, column 11 to column 16)",
  " (in 'inlining-fail2.stan', line 51, column 18 to column 29)",
  " (in 'inlining-fail2.stan', line 51, column 4 to column 35)",
  " (in 'inlining-fail2.stan', line 54, column 6 to column 32)",
  " (in 'inlining-fail2.stan', line 56, column 8 to column 37)",
  " (in 'inlining-fail2.stan', line 57, column 8 to column 32)",
  " (in 'inlining-fail2.stan', line 59, column 8 to line 61, column 44)",
  " (in 'inlining-fail2.stan', line 55, column 39 to line 62, column 7)",
  " (in 'inlining-fail2.stan', line 55, column 6 to line 62, column 7)",
  " (in 'inlining-fail2.stan', line 53, column 25 to line 63, column 5)",
  " (in 'inlining-fail2.stan', line 53, column 4 to line 63, column 5)",
  " (in 'inlining-fail2.stan', line 64, column 4 to column 15)",
  " (in 'inlining-fail2.stan', line 218, column 4 to column 14)",
  " (in 'inlining-fail2.stan', line 219, column 4 to column 13)",
  " (in 'inlining-fail2.stan', line 225, column 6 to column 35)",
  " (in 'inlining-fail2.stan', line 223, column 6 to column 32)",
  " (in 'inlining-fail2.stan', line 222, column 31 to line 226, column 5)",
  " (in 'inlining-fail2.stan', line 221, column 4 to column 38)",
  " (in 'inlining-fail2.stan', line 222, column 4 to line 226, column 5)",
  " (in 'inlining-fail2.stan', line 217, column 19 to line 227, column 3)",
  " (in 'inlining-fail2.stan', line 217, column 2 to line 227, column 3)",
  " (in 'inlining-fail2.stan', line 231, column 11 to column 22)",
  " (in 'inlining-fail2.stan', line 231, column 4 to column 49)",
  " (in 'inlining-fail2.stan', line 149, column 4 to column 24)",
  " (in 'inlining-fail2.stan', line 150, column 11 to column 12)",
  " (in 'inlining-fail2.stan', line 150, column 4 to column 24)",
  " (in 'inlining-fail2.stan', line 151, column 4 to column 31)",
  " (in 'inlining-fail2.stan', line 155, column 6 to column 64)",
  " (in 'inlining-fail2.stan', line 154, column 6 to column 55)",
  " (in 'inlining-fail2.stan', line 153, column 21 to line 156, column 5)",
  " (in 'inlining-fail2.stan', line 153, column 4 to line 156, column 5)",
  " (in 'inlining-fail2.stan', line 157, column 4 to column 26)",
  " (in 'inlining-fail2.stan', line 232, column 10 to column 11)",
  " (in 'inlining-fail2.stan', line 232, column 13 to column 24)",
  " (in 'inlining-fail2.stan', line 232, column 4 to column 69)",
  " (in 'inlining-fail2.stan', line 233, column 10 to column 11)",
  " (in 'inlining-fail2.stan', line 233, column 4 to column 22)",
  " (in 'inlining-fail2.stan', line 234, column 10 to column 11)",
  " (in 'inlining-fail2.stan', line 234, column 4 to column 24)",
  " (in 'inlining-fail2.stan', line 238, column 4 to column 20)",
  " (in 'inlining-fail2.stan', line 241, column 6 to column 39)",
  " (in 'inlining-fail2.stan', line 17, column 8 to column 17)",
  " (in 'inlining-fail2.stan', line 16, column 6 to line 17, column 17)",
  " (in 'inlining-fail2.stan', line 14, column 37 to line 19, column 3)",
  " (in 'inlining-fail2.stan', line 244, column 8 to column 26)",
  " (in 'inlining-fail2.stan', line 243, column 6 to line 244, column 26)",
  " (in 'inlining-fail2.stan', line 240, column 21 to line 245, column 5)",
  " (in 'inlining-fail2.stan', line 240, column 4 to line 245, column 5)",
  " (in 'inlining-fail2.stan', line 247, column 6 to column 28)",
  " (in 'inlining-fail2.stan', line 248, column 6 to column 34)",
  " (in 'inlining-fail2.stan', line 246, column 31 to line 249, column 5)",
  " (in 'inlining-fail2.stan', line 251, column 6 to column 26)",
  " (in 'inlining-fail2.stan', line 252, column 6 to column 31)",
  " (in 'inlining-fail2.stan', line 250, column 21 to line 253, column 5)",
  " (in 'inlining-fail2.stan', line 250, column 4 to line 253, column 5)",
  " (in 'inlining-fail2.stan', line 254, column 4 to column 25)",
  " (in 'inlining-fail2.stan', line 230, column 2 to line 255, column 3)",
  " (in 'inlining-fail2.stan', line 202, column 2 to column 29)",
  " (in 'inlining-fail2.stan', line 80, column 4 to column 27)",
  " (in 'inlining-fail2.stan', line 81, column 4 to column 33)",
  " (in 'inlining-fail2.stan', line 82, column 11 to column 22)",
  " (in 'inlining-fail2.stan', line 82, column 4 to column 45)",
  " (in 'inlining-fail2.stan', line 85, column 13 to column 24)",
  " (in 'inlining-fail2.stan', line 85, column 6 to column 43)",
  " (in 'inlining-fail2.stan', line 121, column 8 to column 35)",
  " (in 'inlining-fail2.stan', line 124, column 8 to line 125, column 48)",
  " (in 'inlining-fail2.stan', line 128, column 10 to line 131, column 50)",
  " (in 'inlining-fail2.stan', line 127, column 8 to line 131, column 50)",
  " (in 'inlining-fail2.stan', line 133, column 8 to column 63)",
  " (in 'inlining-fail2.stan', line 134, column 8 to column 34)",
  " (in 'inlining-fail2.stan', line 119, column 13 to line 135, column 7)",
  " (in 'inlining-fail2.stan', line 93, column 17 to column 25)",
  " (in 'inlining-fail2.stan', line 93, column 10 to column 30)",
  " (in 'inlining-fail2.stan', line 102, column 12 to line 106, column 57)",
  " (in 'inlining-fail2.stan', line 101, column 10 to line 106, column 57)",
  " (in 'inlining-fail2.stan', line 107, column 10 to line 109, column 62)",
  " (in 'inlining-fail2.stan', line 110, column 10 to column 36)",
  " (in 'inlining-fail2.stan', line 92, column 15 to line 111, column 9)",
  " (in 'inlining-fail2.stan', line 91, column 10 to column 44)",
  " (in 'inlining-fail2.stan', line 90, column 27 to line 92, column 9)",
  " (in 'inlining-fail2.stan', line 90, column 8 to line 111, column 9)",
  " (in 'inlining-fail2.stan', line 114, column 10 to column 39)",
  " (in 'inlining-fail2.stan', line 115, column 10 to column 39)",
  " (in 'inlining-fail2.stan', line 113, column 44 to line 116, column 9)",
  " (in 'inlining-fail2.stan', line 118, column 8 to column 39)",
  " (in 'inlining-fail2.stan', line 87, column 20 to line 119, column 7)",
  " (in 'inlining-fail2.stan', line 84, column 25 to line 136, column 5)",
  " (in 'inlining-fail2.stan', line 84, column 4 to line 136, column 5)",
  " (in 'inlining-fail2.stan', line 205, column 2 to column 53)",
  " (in 'inlining-fail2.stan', line 161, column 2 to column 17)",
  " (in 'inlining-fail2.stan', line 162, column 2 to column 27)",
  " (in 'inlining-fail2.stan', line 163, column 8 to column 9)",
  " (in 'inlining-fail2.stan', line 163, column 11 to column 22)",
  " (in 'inlining-fail2.stan', line 163, column 2 to column 48)",
  " (in 'inlining-fail2.stan', line 166, column 8 to column 9)",
  " (in 'inlining-fail2.stan', line 166, column 2 to column 49)",
  " (in 'inlining-fail2.stan', line 167, column 8 to column 9)",
  " (in 'inlining-fail2.stan', line 167, column 2 to column 48)",
  " (in 'inlining-fail2.stan', line 170, column 4 to column 35)",
  " (in 'inlining-fail2.stan', line 169, column 2 to line 170, column 35)",
  " (in 'inlining-fail2.stan', line 172, column 4 to column 33)",
  " (in 'inlining-fail2.stan', line 171, column 2 to line 172, column 33)",
  " (in 'inlining-fail2.stan', line 177, column 27 to column 38)",
  " (in 'inlining-fail2.stan', line 178, column 9 to column 24)",
  " (in 'inlining-fail2.stan', line 184, column 27 to column 28)",
  " (in 'inlining-fail2.stan', line 184, column 30 to column 45)",
  " (in 'inlining-fail2.stan', line 185, column 27 to column 28)",
  " (in 'inlining-fail2.stan', line 185, column 30 to column 41)",
  " (in 'inlining-fail2.stan', line 186, column 27 to column 28)",
  " (in 'inlining-fail2.stan', line 186, column 30 to column 41)",
  " (in 'inlining-fail2.stan', line 210, column 9 to column 20)",
  " (in 'inlining-fail2.stan', line 212, column 8 to column 19)",
  " (in 'inlining-fail2.stan', line 213, column 8 to column 19)",
  " (in 'inlining-fail2.stan', line 214, column 8 to column 9)",
  " (in 'inlining-fail2.stan', line 214, column 11 to column 22)",
  " (in 'inlining-fail2.stan', line 18, column 4 to column 13)",
  " (in 'inlining-fail2.stan', line 30, column 6 to column 32)",
  " (in 'inlining-fail2.stan', line 33, column 8 to column 17)",
  " (in 'inlining-fail2.stan', line 32, column 6 to line 33, column 17)",
  " (in 'inlining-fail2.stan', line 29, column 39 to line 34, column 5)",
  " (in 'inlining-fail2.stan', line 35, column 4 to column 13)",
  " (in 'inlining-fail2.stan', line 28, column 36 to line 36, column 3)",
  " (in 'inlining-fail2.stan', line 48, column 47 to line 65, column 3)",
  " (in 'inlining-fail2.stan', line 79, column 70 to line 137, column 3)",
  " (in 'inlining-fail2.stan', line 148, column 33 to line 158, column 3)"};
int first_capture(const std::vector<int>& y_i, std::ostream* pstream__);
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,-1>
prob_uncaptured(const T0__& p_arg__, const T1__& phi_arg__, std::ostream*
                pstream__);
template <bool propto__, typename T3__, typename T4__, typename T5__,
          typename T6__, typename T_lp__, typename T_lp_accum__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>,
                              stan::is_eigen_matrix_dynamic<T4__>,
                              stan::is_vt_not_complex<T4__>,
                              stan::is_col_vector<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_eigen_matrix_dynamic<T6__>,
                              stan::is_vt_not_complex<T6__>>* = nullptr>
void
jolly_seber_lp(const std::vector<std::vector<int>>& y,
               const std::vector<int>& first, const std::vector<int>& last,
               const T3__& p_arg__, const T4__& phi_arg__, const T5__&
               gamma_arg__, const T6__& chi_arg__, T_lp__& lp__,
               T_lp_accum__& lp_accum__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
seq_cprob(const T0__& gamma_arg__, std::ostream* pstream__);
int first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym57__;
    int lcm_sym56__;
    int lcm_sym55__;
    int lcm_sym54__;
    {
      lcm_sym55__ = stan::math::size(y_i);
      if (stan::math::logical_gte(lcm_sym55__, 1)) {
        current_statement__ = 63;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(1))) {
          current_statement__ = 62;
          return 1;
        }
        for (int k = 2; k <= lcm_sym55__; ++k) {
          current_statement__ = 63;
          if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
            current_statement__ = 62;
            return k;
          }
        }
      }
      current_statement__ = 136;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym63__;
    int lcm_sym62__;
    int lcm_sym61__;
    int lcm_sym60__;
    int lcm_sym59__;
    int lcm_sym58__;
    {
      lcm_sym61__ = (stan::math::size(y_i) - 1);
      if (stan::math::logical_gte(lcm_sym61__, 0)) {
        int k = std::numeric_limits<int>::min();
        lcm_sym60__ = (stan::math::size(y_i) - 0);
        current_statement__ = 139;
        if (y_i[(lcm_sym60__ - 1)]) {
          current_statement__ = 138;
          return lcm_sym60__;
        }
        for (int k_rev = 1; k_rev <= lcm_sym61__; ++k_rev) {
          int k = std::numeric_limits<int>::min();
          lcm_sym59__ = (stan::math::size(y_i) - k_rev);
          current_statement__ = 139;
          if (y_i[(lcm_sym59__ - 1)]) {
            current_statement__ = 138;
            return lcm_sym59__;
          }
        }
      }
      current_statement__ = 141;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,-1>
prob_uncaptured(const T0__& p_arg__, const T1__& phi_arg__, std::ostream*
                pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& p = stan::math::to_ref(p_arg__);
  const auto& phi = stan::math::to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym75__;
    double lcm_sym74__;
    double lcm_sym73__;
    double lcm_sym72__;
    double lcm_sym71__;
    int lcm_sym70__;
    int lcm_sym69__;
    int lcm_sym68__;
    int lcm_sym67__;
    int lcm_sym66__;
    int lcm_sym65__;
    int lcm_sym64__;
    {
      int n_ind = std::numeric_limits<int>::min();
      lcm_sym75__ = stan::math::rows(p);
      int n_occasions = std::numeric_limits<int>::min();
      lcm_sym70__ = stan::math::cols(p);
      n_occasions = lcm_sym70__;
      current_statement__ = 21;
      stan::math::validate_non_negative_index("chi", "n_ind", lcm_sym75__);
      current_statement__ = 22;
      stan::math::validate_non_negative_index("chi", "n_occasions",
        lcm_sym70__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(lcm_sym75__,
          lcm_sym70__, DUMMY_VAR__);
      current_statement__ = 31;
      if (stan::math::logical_gte(lcm_sym75__, 1)) {
        current_statement__ = 24;
        stan::model::assign(chi, 1.0, "assigning variable chi",
          stan::model::index_uni(1), stan::model::index_uni(lcm_sym70__));
        lcm_sym67__ = (lcm_sym70__ - 1);
        lcm_sym64__ = stan::math::logical_gte(lcm_sym67__, 1);
        if (lcm_sym64__) {
          int t_curr = std::numeric_limits<int>::min();
          int t_next = std::numeric_limits<int>::min();
          lcm_sym69__ = (lcm_sym67__ + 1);
          current_statement__ = 27;
          stan::model::assign(chi,
            stan::math::fma(
              (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                 stan::model::index_uni(lcm_sym67__)) * (1 -
              stan::model::rvalue(p, "p", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym69__)))),
              stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym69__)), (1 -
              stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym67__)))),
            "assigning variable chi", stan::model::index_uni(1),
            stan::model::index_uni(lcm_sym67__));
          for (int t = 2; t <= lcm_sym67__; ++t) {
            int t_curr = std::numeric_limits<int>::min();
            lcm_sym66__ = (lcm_sym70__ - t);
            int t_next = std::numeric_limits<int>::min();
            lcm_sym68__ = (lcm_sym66__ + 1);
            current_statement__ = 27;
            stan::model::assign(chi,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym66__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym68__)))),
                stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym68__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym66__)))),
              "assigning variable chi", stan::model::index_uni(1),
              stan::model::index_uni(lcm_sym66__));
          }
        }
        for (int i = 2; i <= lcm_sym75__; ++i) {
          current_statement__ = 24;
          stan::model::assign(chi, 1.0, "assigning variable chi",
            stan::model::index_uni(i), stan::model::index_uni(lcm_sym70__));
          current_statement__ = 29;
          if (lcm_sym64__) {
            int t_curr = std::numeric_limits<int>::min();
            int t_next = std::numeric_limits<int>::min();
            lcm_sym69__ = (lcm_sym67__ + 1);
            current_statement__ = 27;
            stan::model::assign(chi,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                   stan::model::index_uni(lcm_sym67__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym69__)))),
                stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym69__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym67__)))),
              "assigning variable chi", stan::model::index_uni(i),
              stan::model::index_uni(lcm_sym67__));
            for (int t = 2; t <= lcm_sym67__; ++t) {
              int t_curr = std::numeric_limits<int>::min();
              lcm_sym66__ = (lcm_sym70__ - t);
              int t_next = std::numeric_limits<int>::min();
              lcm_sym68__ = (lcm_sym66__ + 1);
              current_statement__ = 27;
              stan::model::assign(chi,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                     stan::model::index_uni(lcm_sym66__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym68__)))),
                  stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym68__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym66__)))),
                "assigning variable chi", stan::model::index_uni(i),
                stan::model::index_uni(lcm_sym66__));
            }
          }
        }
      }
      current_statement__ = 32;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <bool propto__, typename T3__, typename T4__, typename T5__,
          typename T6__, typename T_lp__, typename T_lp_accum__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>,
                              stan::is_eigen_matrix_dynamic<T4__>,
                              stan::is_vt_not_complex<T4__>,
                              stan::is_col_vector<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_eigen_matrix_dynamic<T6__>,
                              stan::is_vt_not_complex<T6__>>*>
void
jolly_seber_lp(const std::vector<std::vector<int>>& y,
               const std::vector<int>& first, const std::vector<int>& last,
               const T3__& p_arg__, const T4__& phi_arg__, const T5__&
               gamma_arg__, const T6__& chi_arg__, T_lp__& lp__,
               T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T3__>,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>>;
  int current_statement__ = 0;
  const auto& p = stan::math::to_ref(p_arg__);
  const auto& phi = stan::math::to_ref(phi_arg__);
  const auto& gamma = stan::math::to_ref(gamma_arg__);
  const auto& chi = stan::math::to_ref(chi_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym125__;
    int lcm_sym124__;
    int lcm_sym123__;
    int lcm_sym122__;
    int lcm_sym121__;
    int lcm_sym120__;
    double lcm_sym119__;
    double lcm_sym118__;
    double lcm_sym117__;
    double lcm_sym116__;
    double lcm_sym115__;
    double lcm_sym114__;
    double lcm_sym113__;
    double lcm_sym112__;
    double lcm_sym111__;
    double lcm_sym110__;
    double lcm_sym109__;
    double lcm_sym108__;
    double lcm_sym107__;
    double lcm_sym106__;
    int lcm_sym105__;
    int lcm_sym104__;
    int lcm_sym103__;
    double lcm_sym102__;
    double lcm_sym101__;
    double lcm_sym100__;
    double lcm_sym99__;
    double lcm_sym98__;
    double lcm_sym97__;
    double lcm_sym96__;
    double lcm_sym95__;
    double lcm_sym94__;
    double lcm_sym93__;
    double lcm_sym92__;
    double lcm_sym91__;
    double lcm_sym90__;
    double lcm_sym89__;
    int lcm_sym88__;
    int lcm_sym87__;
    Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym86__;
    Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym85__;
    Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym84__;
    int lcm_sym83__;
    int lcm_sym82__;
    int lcm_sym81__;
    int lcm_sym80__;
    int lcm_sym79__;
    int lcm_sym78__;
    int lcm_sym77__;
    int lcm_sym76__;
    {
      int n_ind = std::numeric_limits<int>::min();
      lcm_sym124__ = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                       stan::model::index_uni(1));
      int n_occasions = std::numeric_limits<int>::min();
      lcm_sym125__ = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                       stan::model::index_uni(2));
      n_occasions = lcm_sym125__;
      current_statement__ = 81;
      stan::math::validate_non_negative_index("qgamma", "n_occasions",
        lcm_sym125__);
      Eigen::Matrix<double,-1,1> qgamma =
        Eigen::Matrix<double,-1,1>::Constant(lcm_sym125__,
          std::numeric_limits<double>::quiet_NaN());
      stan::model::assign(lcm_sym84__, stan::math::subtract(1.0, gamma),
        "assigning variable lcm_sym84__");
      current_statement__ = 108;
      if (stan::math::logical_gte(lcm_sym124__, 1)) {
        current_statement__ = 83;
        stan::math::validate_non_negative_index("qp", "n_occasions",
          lcm_sym125__);
        Eigen::Matrix<double,-1,1> qp =
          Eigen::Matrix<double,-1,1>::Constant(lcm_sym125__,
            std::numeric_limits<double>::quiet_NaN());
        stan::model::assign(lcm_sym86__,
          stan::math::subtract(1.0,
            stan::math::transpose(
              stan::model::rvalue(p, "p", stan::model::index_uni(1)))),
          "assigning variable lcm_sym86__");
        lcm_sym121__ = stan::model::rvalue(first, "first",
                         stan::model::index_uni(1));
        if (lcm_sym121__) {
          current_statement__ = 101;
          if (stan::math::logical_eq(lcm_sym121__, 1)) {
            current_statement__ = 99;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             (stan::model::rvalue(gamma, "gamma",
                                stan::model::index_uni(1)) *
                             stan::model::rvalue(p, "p",
                               stan::model::index_uni(1),
                               stan::model::index_uni(1)))));
          } else {
            current_statement__ = 92;
            stan::math::validate_non_negative_index("lp", "first[i]",
              lcm_sym121__);
            Eigen::Matrix<local_scalar_t__,-1,1> lp =
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym121__,
                DUMMY_VAR__);
            lcm_sym88__ = (lcm_sym121__ - 1);
            stan::model::assign(lp,
              (((stan::math::bernoulli_lpmf<false>(1,
                   stan::model::rvalue(gamma, "gamma",
                     stan::model::index_uni(1))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::math::prod(
                  stan::model::rvalue(lcm_sym86__, "lcm_sym86__",
                    stan::model::index_min_max(1, lcm_sym88__))))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::math::prod(
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_min_max(1, lcm_sym88__))))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym121__)))),
              "assigning variable lp", stan::model::index_uni(1));
            current_statement__ = 95;
            if (stan::math::logical_gte(lcm_sym88__, 2)) {
              current_statement__ = 94;
              stan::model::assign(lp,
                ((((stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym84__, "lcm_sym84__",
                          stan::model::index_min_max(1, 1)))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(gamma, "gamma",
                    stan::model::index_uni(2)))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(lcm_sym86__, "lcm_sym86__",
                      stan::model::index_min_max(2, lcm_sym88__))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(1),
                      stan::model::index_min_max(2, lcm_sym88__))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym121__)))),
                "assigning variable lp", stan::model::index_uni(2));
              for (int t = 3; t <= lcm_sym88__; ++t) {
                current_statement__ = 94;
                stan::model::assign(lp,
                  ((((stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym84__, "lcm_sym84__",
                            stan::model::index_min_max(1, (t - 1))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(gamma, "gamma",
                      stan::model::index_uni(t)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym86__, "lcm_sym86__",
                        stan::model::index_min_max(t, lcm_sym88__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(phi, "phi",
                        stan::model::index_uni(1),
                        stan::model::index_min_max(t, lcm_sym88__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(p, "p", stan::model::index_uni(1),
                      stan::model::index_uni(lcm_sym121__)))),
                  "assigning variable lp", stan::model::index_uni(t));
              }
            }
            current_statement__ = 96;
            stan::model::assign(lp,
              ((stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(lcm_sym84__, "lcm_sym84__",
                      stan::model::index_min_max(1, lcm_sym88__)))) +
              stan::math::bernoulli_lpmf<false>(1, gamma[(lcm_sym121__ - 1)]))
              +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym121__)))),
              "assigning variable lp", stan::model::index_uni(lcm_sym121__));
            current_statement__ = 97;
            lp_accum__.add(stan::math::log_sum_exp(lp));
          }
          lcm_sym123__ = stan::model::rvalue(last, "last",
                           stan::model::index_uni(1));
          if (stan::math::logical_gte(lcm_sym123__, (lcm_sym121__ + 1))) {
            current_statement__ = 102;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             stan::model::rvalue(phi, "phi",
                               stan::model::index_uni(1),
                               stan::model::index_uni(((lcm_sym121__ + 1) -
                                 1)))));
            lcm_sym104__ = ((lcm_sym121__ + 1) + 1);
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                             stan::model::rvalue(y, "y",
                               stan::model::index_uni(1),
                               stan::model::index_uni((lcm_sym121__ + 1))),
                             stan::model::rvalue(p, "p",
                               stan::model::index_uni(1),
                               stan::model::index_uni((lcm_sym121__ + 1)))));
            for (int t = lcm_sym104__; t <= lcm_sym123__; ++t) {
              current_statement__ = 102;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((t - 1)))));
              current_statement__ = 103;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(t)),
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(t))));
            }
          }
          current_statement__ = 105;
          lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                           stan::model::rvalue(chi, "chi",
                             stan::model::index_uni(1),
                             stan::model::index_uni(lcm_sym123__))));
        } else {
          lcm_sym105__ = (lcm_sym125__ + 1);
          stan::math::validate_non_negative_index("lp", "n_occasions + 1",
            lcm_sym105__);
          Eigen::Matrix<local_scalar_t__,-1,1> lp =
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym105__,
              DUMMY_VAR__);
          current_statement__ = 86;
          stan::model::assign(lp,
            ((stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(gamma, "gamma", stan::model::index_uni(1)))
            +
            stan::math::bernoulli_lpmf<false>(0,
              stan::model::rvalue(p, "p", stan::model::index_uni(1),
                stan::model::index_uni(1)))) +
            stan::math::bernoulli_lpmf<false>(1,
              stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                stan::model::index_uni(1)))), "assigning variable lp",
            stan::model::index_uni(1));
          current_statement__ = 88;
          if (stan::math::logical_gte(lcm_sym125__, 2)) {
            current_statement__ = 87;
            stan::model::assign(lp,
              (((stan::math::bernoulli_lpmf<false>(1,
                   stan::math::prod(
                     stan::model::rvalue(lcm_sym84__, "lcm_sym84__",
                       stan::model::index_min_max(1, 1)))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(gamma, "gamma", stan::model::index_uni(2))))
              +
              stan::math::bernoulli_lpmf<false>(0,
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni(2)))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                  stan::model::index_uni(2)))), "assigning variable lp",
              stan::model::index_uni(2));
            for (int t = 3; t <= lcm_sym125__; ++t) {
              current_statement__ = 87;
              stan::model::assign(lp,
                (((stan::math::bernoulli_lpmf<false>(1,
                     stan::math::prod(
                       stan::model::rvalue(lcm_sym84__, "lcm_sym84__",
                         stan::model::index_min_max(1, (t - 1))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(gamma, "gamma",
                    stan::model::index_uni(t)))) +
                stan::math::bernoulli_lpmf<false>(0,
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni(t)))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                    stan::model::index_uni(t)))), "assigning variable lp",
                stan::model::index_uni(t));
            }
          }
          current_statement__ = 89;
          stan::model::assign(lp,
            stan::math::bernoulli_lpmf<false>(1,
              stan::math::prod(lcm_sym84__)), "assigning variable lp",
            stan::model::index_uni(lcm_sym105__));
          current_statement__ = 90;
          lp_accum__.add(stan::math::log_sum_exp(lp));
        }
        for (int i = 2; i <= lcm_sym124__; ++i) {
          current_statement__ = 83;
          stan::math::validate_non_negative_index("qp", "n_occasions",
            lcm_sym125__);
          Eigen::Matrix<double,-1,1> qp =
            Eigen::Matrix<double,-1,1>::Constant(lcm_sym125__,
              std::numeric_limits<double>::quiet_NaN());
          stan::model::assign(lcm_sym85__,
            stan::math::subtract(1.0,
              stan::math::transpose(
                stan::model::rvalue(p, "p", stan::model::index_uni(i)))),
            "assigning variable lcm_sym85__");
          lcm_sym120__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(i));
          if (lcm_sym120__) {
            current_statement__ = 101;
            if (stan::math::logical_eq(lcm_sym120__, 1)) {
              current_statement__ = 99;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               (stan::model::rvalue(gamma, "gamma",
                                  stan::model::index_uni(1)) *
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(1)))));
            } else {
              current_statement__ = 92;
              stan::math::validate_non_negative_index("lp", "first[i]",
                lcm_sym120__);
              Eigen::Matrix<local_scalar_t__,-1,1> lp =
                Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym120__,
                  DUMMY_VAR__);
              lcm_sym87__ = (lcm_sym120__ - 1);
              stan::model::assign(lp,
                (((stan::math::bernoulli_lpmf<false>(1,
                     stan::model::rvalue(gamma, "gamma",
                       stan::model::index_uni(1))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(lcm_sym85__, "lcm_sym85__",
                      stan::model::index_min_max(1, lcm_sym87__))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(i),
                      stan::model::index_min_max(1, lcm_sym87__))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(p, "p", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym120__)))),
                "assigning variable lp", stan::model::index_uni(1));
              current_statement__ = 95;
              if (stan::math::logical_gte(lcm_sym87__, 2)) {
                current_statement__ = 94;
                stan::model::assign(lp,
                  ((((stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym84__, "lcm_sym84__",
                            stan::model::index_min_max(1, 1)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(gamma, "gamma",
                      stan::model::index_uni(2)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym85__, "lcm_sym85__",
                        stan::model::index_min_max(2, lcm_sym87__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(phi, "phi",
                        stan::model::index_uni(i),
                        stan::model::index_min_max(2, lcm_sym87__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(p, "p", stan::model::index_uni(i),
                      stan::model::index_uni(lcm_sym120__)))),
                  "assigning variable lp", stan::model::index_uni(2));
                for (int t = 3; t <= lcm_sym87__; ++t) {
                  current_statement__ = 94;
                  stan::model::assign(lp,
                    ((((stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(lcm_sym84__, "lcm_sym84__",
                              stan::model::index_min_max(1, (t - 1))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(gamma, "gamma",
                        stan::model::index_uni(t)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym85__, "lcm_sym85__",
                          stan::model::index_min_max(t, lcm_sym87__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(phi, "phi",
                          stan::model::index_uni(i),
                          stan::model::index_min_max(t, lcm_sym87__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(p, "p", stan::model::index_uni(i),
                        stan::model::index_uni(lcm_sym120__)))),
                    "assigning variable lp", stan::model::index_uni(t));
                }
              }
              current_statement__ = 96;
              stan::model::assign(lp,
                ((stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym84__, "lcm_sym84__",
                        stan::model::index_min_max(1, lcm_sym87__)))) +
                stan::math::bernoulli_lpmf<false>(1, gamma[(lcm_sym120__ -
                  1)])) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(p, "p", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym120__)))),
                "assigning variable lp", stan::model::index_uni(lcm_sym120__));
              current_statement__ = 97;
              lp_accum__.add(stan::math::log_sum_exp(lp));
            }
            lcm_sym122__ = stan::model::rvalue(last, "last",
                             stan::model::index_uni(i));
            if (stan::math::logical_gte(lcm_sym122__, (lcm_sym120__ + 1))) {
              current_statement__ = 102;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(((lcm_sym120__ + 1) -
                                   1)))));
              lcm_sym103__ = ((lcm_sym120__ + 1) + 1);
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni((lcm_sym120__ + 1))),
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni((lcm_sym120__ + 1)))));
              for (int t = lcm_sym103__; t <= lcm_sym122__; ++t) {
                current_statement__ = 102;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((t - 1)))));
                current_statement__ = 103;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(t)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(t))));
              }
            }
            current_statement__ = 105;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             stan::model::rvalue(chi, "chi",
                               stan::model::index_uni(i),
                               stan::model::index_uni(lcm_sym122__))));
          } else {
            lcm_sym105__ = (lcm_sym125__ + 1);
            stan::math::validate_non_negative_index("lp", "n_occasions + 1",
              lcm_sym105__);
            Eigen::Matrix<local_scalar_t__,-1,1> lp =
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym105__,
                DUMMY_VAR__);
            current_statement__ = 86;
            stan::model::assign(lp,
              ((stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(gamma, "gamma",
                    stan::model::index_uni(1))) +
              stan::math::bernoulli_lpmf<false>(0,
                stan::model::rvalue(p, "p", stan::model::index_uni(i),
                  stan::model::index_uni(1)))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                  stan::model::index_uni(1)))), "assigning variable lp",
              stan::model::index_uni(1));
            current_statement__ = 88;
            if (stan::math::logical_gte(lcm_sym125__, 2)) {
              current_statement__ = 87;
              stan::model::assign(lp,
                (((stan::math::bernoulli_lpmf<false>(1,
                     stan::math::prod(
                       stan::model::rvalue(lcm_sym84__, "lcm_sym84__",
                         stan::model::index_min_max(1, 1)))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(gamma, "gamma",
                    stan::model::index_uni(2)))) +
                stan::math::bernoulli_lpmf<false>(0,
                  stan::model::rvalue(p, "p", stan::model::index_uni(i),
                    stan::model::index_uni(2)))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                    stan::model::index_uni(2)))), "assigning variable lp",
                stan::model::index_uni(2));
              for (int t = 3; t <= lcm_sym125__; ++t) {
                current_statement__ = 87;
                stan::model::assign(lp,
                  (((stan::math::bernoulli_lpmf<false>(1,
                       stan::math::prod(
                         stan::model::rvalue(lcm_sym84__, "lcm_sym84__",
                           stan::model::index_min_max(1, (t - 1))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(gamma, "gamma",
                      stan::model::index_uni(t)))) +
                  stan::math::bernoulli_lpmf<false>(0,
                    stan::model::rvalue(p, "p", stan::model::index_uni(i),
                      stan::model::index_uni(t)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(chi, "chi",
                      stan::model::index_uni(i), stan::model::index_uni(t)))),
                  "assigning variable lp", stan::model::index_uni(t));
              }
            }
            current_statement__ = 89;
            stan::model::assign(lp,
              stan::math::bernoulli_lpmf<false>(1,
                stan::math::prod(lcm_sym84__)), "assigning variable lp",
              stan::model::index_uni(lcm_sym105__));
            current_statement__ = 90;
            lp_accum__.add(stan::math::log_sum_exp(lp));
          }
        }
      }
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
seq_cprob(const T0__& gamma_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& gamma = stan::math::to_ref(gamma_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym133__;
    int lcm_sym132__;
    Eigen::Matrix<double,-1,1> lcm_sym131__;
    double lcm_sym130__;
    double lcm_sym129__;
    double lcm_sym128__;
    double lcm_sym127__;
    int lcm_sym126__;
    {
      int N = std::numeric_limits<int>::min();
      lcm_sym132__ = stan::math::rows(gamma);
      N = lcm_sym132__;
      current_statement__ = 45;
      stan::math::validate_non_negative_index("log_cprob", "N", lcm_sym132__);
      Eigen::Matrix<local_scalar_t__,-1,1> log_cprob =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym132__,
          DUMMY_VAR__);
      local_scalar_t__ log_residual_prob = DUMMY_VAR__;
      current_statement__ = 51;
      if (stan::math::logical_gte(lcm_sym132__, 1)) {
        current_statement__ = 49;
        stan::model::assign(log_cprob,
          (stan::math::log(
             stan::model::rvalue(gamma, "gamma", stan::model::index_uni(1)))
          + 0), "assigning variable log_cprob", stan::model::index_uni(1));
        current_statement__ = 48;
        log_residual_prob = (0 +
          stan::math::log1m(
            stan::model::rvalue(gamma, "gamma", stan::model::index_uni(1))));
        for (int n = 2; n <= lcm_sym132__; ++n) {
          current_statement__ = 49;
          stan::model::assign(log_cprob,
            (stan::math::log(
               stan::model::rvalue(gamma, "gamma", stan::model::index_uni(n)))
            + log_residual_prob), "assigning variable log_cprob",
            stan::model::index_uni(n));
          current_statement__ = 48;
          log_residual_prob = (log_residual_prob +
            stan::math::log1m(
              stan::model::rvalue(gamma, "gamma", stan::model::index_uni(n))));
        }
      }
      current_statement__ = 52;
      return stan::math::exp(log_cprob);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class inlining_fail2_model final : public model_base_crtp<inlining_fail2_model> {
 private:
  int lcm_sym357__;
  int lcm_sym356__;
  int lcm_sym355__;
  int lcm_sym354__;
  int lcm_sym353__;
  int lcm_sym352__;
  int lcm_sym351__;
  int lcm_sym350__;
  int lcm_sym349__;
  int lcm_sym348__;
  int M;
  int n_occasions;
  std::vector<std::vector<int>> y;
  std::vector<int> first;
  std::vector<int> last;
  int epsilon_1dim__;
  int phi_2dim__;
 public:
  ~inlining_fail2_model() {}
  inlining_fail2_model(stan::io::var_context& context__, unsigned int
                       random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "inlining_fail2_model_namespace::inlining_fail2_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 110;
      context__.validate_dims("data initialization", "M", "int",
        std::vector<size_t>{});
      M = std::numeric_limits<int>::min();
      current_statement__ = 110;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 110;
      stan::math::check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 111;
      context__.validate_dims("data initialization", "n_occasions", "int",
        std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      current_statement__ = 111;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 111;
      stan::math::check_greater_or_equal(function__, "n_occasions",
        n_occasions, 0);
      current_statement__ = 112;
      stan::math::validate_non_negative_index("y", "M", M);
      current_statement__ = 113;
      stan::math::validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 114;
      context__.validate_dims("data initialization", "y", "int",
        std::vector<size_t>{static_cast<size_t>(M),
          static_cast<size_t>(n_occasions)});
      y = std::vector<std::vector<int>>(M,
            std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      {
        std::vector<int> y_flat__;
        current_statement__ = 114;
        y_flat__ = context__.vals_i("y");
        pos__ = 1;
        if (stan::math::logical_gte(n_occasions, 1)) {
          lcm_sym348__ = stan::math::logical_gte(M, 1);
          if (lcm_sym348__) {
            stan::model::assign(y,
              stan::model::rvalue(y_flat__, "y_flat__",
                stan::model::index_uni(1)), "assigning variable y",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
            if (lcm_sym348__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
                stan::model::assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        } else {
          lcm_sym348__ = stan::math::logical_gte(M, 1);
        }
      }
      current_statement__ = 114;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 114;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 115;
      stan::math::validate_non_negative_index("first", "M", M);
      current_statement__ = 116;
      first = std::vector<int>(M, std::numeric_limits<int>::min());
      current_statement__ = 117;
      stan::math::validate_non_negative_index("last", "M", M);
      current_statement__ = 118;
      last = std::vector<int>(M, std::numeric_limits<int>::min());
      current_statement__ = 120;
      if (lcm_sym348__) {
        current_statement__ = 119;
        stan::model::assign(first,
          first_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(1)), pstream__),
          "assigning variable first", stan::model::index_uni(1));
        for (int i = 2; i <= M; ++i) {
          current_statement__ = 119;
          stan::model::assign(first,
            first_capture(
              stan::model::rvalue(y, "y", stan::model::index_uni(i)),
              pstream__), "assigning variable first",
            stan::model::index_uni(i));
        }
      }
      current_statement__ = 122;
      if (lcm_sym348__) {
        current_statement__ = 121;
        stan::model::assign(last,
          last_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(1)), pstream__),
          "assigning variable last", stan::model::index_uni(1));
        for (int i = 2; i <= M; ++i) {
          current_statement__ = 121;
          stan::model::assign(last,
            last_capture(
              stan::model::rvalue(y, "y", stan::model::index_uni(i)),
              pstream__), "assigning variable last",
            stan::model::index_uni(i));
        }
      }
      current_statement__ = 116;
      stan::math::check_greater_or_equal(function__, "first", first, 0);
      current_statement__ = 116;
      stan::math::check_less_or_equal(function__, "first", first, n_occasions);
      current_statement__ = 118;
      stan::math::check_greater_or_equal(function__, "last", last, 0);
      current_statement__ = 118;
      stan::math::check_less_or_equal(function__, "last", last, n_occasions);
      current_statement__ = 123;
      stan::math::validate_non_negative_index("gamma", "n_occasions",
        n_occasions);
      current_statement__ = 124;
      epsilon_1dim__ = std::numeric_limits<int>::min();
      lcm_sym350__ = (n_occasions - 1);
      epsilon_1dim__ = lcm_sym350__;
      current_statement__ = 124;
      stan::math::validate_non_negative_index("epsilon", "n_occasions - 1",
        lcm_sym350__);
      current_statement__ = 125;
      stan::math::validate_non_negative_index("phi", "M", M);
      current_statement__ = 126;
      phi_2dim__ = std::numeric_limits<int>::min();
      current_statement__ = 126;
      phi_2dim__ = lcm_sym350__;
      current_statement__ = 126;
      stan::math::validate_non_negative_index("phi", "n_occasions - 1",
        lcm_sym350__);
      current_statement__ = 127;
      stan::math::validate_non_negative_index("p", "M", M);
      current_statement__ = 128;
      stan::math::validate_non_negative_index("p", "n_occasions", n_occasions);
      current_statement__ = 129;
      stan::math::validate_non_negative_index("chi", "M", M);
      current_statement__ = 130;
      stan::math::validate_non_negative_index("chi", "n_occasions",
        n_occasions);
      current_statement__ = 131;
      stan::math::validate_non_negative_index("b", "n_occasions", n_occasions);
      current_statement__ = 132;
      stan::math::validate_non_negative_index("N", "n_occasions", n_occasions);
      current_statement__ = 133;
      stan::math::validate_non_negative_index("B", "n_occasions", n_occasions);
      current_statement__ = 134;
      stan::math::validate_non_negative_index("z", "M", M);
      current_statement__ = 135;
      stan::math::validate_non_negative_index("z", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + n_occasions + epsilon_1dim__ + 1;
  }
  inline std::string model_name() const final {
    return "inlining_fail2_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "inlining_fail2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym347__;
      int lcm_sym346__;
      int lcm_sym345__;
      int lcm_sym344__;
      int lcm_sym343__;
      int lcm_sym342__;
      int lcm_sym340__;
      Eigen::Matrix<local_scalar_t__,-1,-1> lcm_sym339__;
      double lcm_sym338__;
      double lcm_sym337__;
      local_scalar_t__ lcm_sym336__;
      local_scalar_t__ lcm_sym335__;
      double lcm_sym334__;
      double lcm_sym333__;
      double lcm_sym332__;
      double lcm_sym331__;
      int lcm_sym330__;
      double lcm_sym329__;
      double lcm_sym328__;
      double lcm_sym327__;
      double lcm_sym326__;
      double lcm_sym325__;
      double lcm_sym324__;
      double lcm_sym323__;
      double lcm_sym322__;
      double lcm_sym321__;
      double lcm_sym320__;
      double lcm_sym319__;
      double lcm_sym318__;
      double lcm_sym317__;
      int lcm_sym316__;
      int lcm_sym315__;
      int lcm_sym314__;
      double lcm_sym313__;
      double lcm_sym312__;
      double lcm_sym311__;
      double lcm_sym310__;
      double lcm_sym309__;
      double lcm_sym308__;
      double lcm_sym307__;
      double lcm_sym306__;
      double lcm_sym305__;
      double lcm_sym304__;
      double lcm_sym303__;
      double lcm_sym302__;
      double lcm_sym301__;
      double lcm_sym300__;
      int lcm_sym299__;
      int lcm_sym298__;
      int lcm_sym297__;
      int lcm_sym296__;
      int lcm_sym295__;
      int lcm_sym294__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym293__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym292__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym291__;
      int lcm_sym341__;
      int lcm_sym289__;
      int lcm_sym288__;
      int lcm_sym287__;
      int lcm_sym286__;
      int lcm_sym285__;
      int lcm_sym284__;
      int lcm_sym283__;
      int lcm_sym282__;
      int lcm_sym281__;
      int lcm_sym280__;
      int lcm_sym279__;
      int lcm_sym278__;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> gamma;
      current_statement__ = 3;
      gamma = in__.template read_constrain_lub<
                Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, 1, lp__,
                n_occasions);
      Eigen::Matrix<local_scalar_t__,-1,1> epsilon =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant((n_occasions - 1),
          DUMMY_VAR__);
      lcm_sym341__ = (n_occasions - 1);
      epsilon = in__.template read<
                  Eigen::Matrix<local_scalar_t__,-1,1>>(lcm_sym341__);
      local_scalar_t__ sigma;
      current_statement__ = 5;
      sigma = in__.template read_constrain_lub<local_scalar_t__,
                jacobian__>(0, 5, lp__);
      Eigen::Matrix<local_scalar_t__,-1,-1> phi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, lcm_sym341__,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, n_occasions,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, n_occasions,
          DUMMY_VAR__);
      current_statement__ = 18;
      if (stan::math::logical_gte(lcm_sym341__, 1)) {
        lcm_sym280__ = stan::math::logical_gte(M, 1);
        if (lcm_sym280__) {
          lcm_sym336__ = stan::math::inv_logit((stan::math::logit(mean_phi) +
                           stan::model::rvalue(epsilon, "epsilon",
                             stan::model::index_uni(1))));
          stan::model::assign(phi, lcm_sym336__, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int i = 2; i <= M; ++i) {
            current_statement__ = 16;
            stan::model::assign(phi, lcm_sym336__, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
          }
        }
        for (int t = 2; t <= lcm_sym341__; ++t) {
          current_statement__ = 17;
          if (lcm_sym280__) {
            lcm_sym335__ = stan::math::inv_logit((stan::math::logit(mean_phi)
                             +
                             stan::model::rvalue(epsilon, "epsilon",
                               stan::model::index_uni(t))));
            stan::model::assign(phi, lcm_sym335__, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            for (int i = 2; i <= M; ++i) {
              current_statement__ = 16;
              stan::model::assign(phi, lcm_sym335__,
                "assigning variable phi", stan::model::index_uni(i),
                stan::model::index_uni(t));
            }
          }
        }
      }
      stan::model::assign(lcm_sym339__,
        stan::math::rep_matrix(mean_p, M, n_occasions),
        "assigning variable lcm_sym339__");
      stan::model::assign(p, lcm_sym339__, "assigning variable p");
      Eigen::Matrix<local_scalar_t__,-1,-1>
        inline_prob_uncaptured_return_sym37__;
      {
        int inline_prob_uncaptured_n_ind_sym38__ =
          std::numeric_limits<int>::min();
        lcm_sym340__ = stan::math::rows(lcm_sym339__);
        int inline_prob_uncaptured_n_occasions_sym39__ =
          std::numeric_limits<int>::min();
        lcm_sym330__ = stan::math::cols(lcm_sym339__);
        current_statement__ = 21;
        stan::math::validate_non_negative_index("chi", "n_ind", lcm_sym340__);
        current_statement__ = 22;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          lcm_sym330__);
        Eigen::Matrix<local_scalar_t__,-1,-1>
          inline_prob_uncaptured_chi_sym40__ =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(lcm_sym340__,
            lcm_sym330__, DUMMY_VAR__);
        current_statement__ = 31;
        if (stan::math::logical_gte(lcm_sym340__, 1)) {
          current_statement__ = 24;
          stan::model::assign(inline_prob_uncaptured_chi_sym40__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym40__",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym330__));
          lcm_sym295__ = (lcm_sym330__ - 1);
          lcm_sym282__ = stan::math::logical_gte(lcm_sym295__, 1);
          if (lcm_sym282__) {
            int inline_prob_uncaptured_t_curr_sym41__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym42__ =
              std::numeric_limits<int>::min();
            lcm_sym299__ = (lcm_sym295__ + 1);
            current_statement__ = 27;
            stan::model::assign(inline_prob_uncaptured_chi_sym40__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym295__)) * (1 -
                stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym299__)))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym40__,
                  "inline_prob_uncaptured_chi_sym40__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym299__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym295__)))),
              "assigning variable inline_prob_uncaptured_chi_sym40__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym295__));
            for (int inline_prob_uncaptured_t_sym43__ = 2; inline_prob_uncaptured_t_sym43__
                 <= lcm_sym295__; ++inline_prob_uncaptured_t_sym43__) {
              int inline_prob_uncaptured_t_curr_sym41__ =
                std::numeric_limits<int>::min();
              lcm_sym294__ = (lcm_sym330__ -
                inline_prob_uncaptured_t_sym43__);
              int inline_prob_uncaptured_t_next_sym42__ =
                std::numeric_limits<int>::min();
              lcm_sym298__ = (lcm_sym294__ + 1);
              current_statement__ = 27;
              stan::model::assign(inline_prob_uncaptured_chi_sym40__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym294__)) * (1 -
                  stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym298__)))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym40__,
                    "inline_prob_uncaptured_chi_sym40__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym298__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym294__)))),
                "assigning variable inline_prob_uncaptured_chi_sym40__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym294__));
            }
          }
          for (int inline_prob_uncaptured_i_sym44__ = 2; inline_prob_uncaptured_i_sym44__
               <= lcm_sym340__; ++inline_prob_uncaptured_i_sym44__) {
            current_statement__ = 24;
            stan::model::assign(inline_prob_uncaptured_chi_sym40__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym40__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym44__),
              stan::model::index_uni(lcm_sym330__));
            current_statement__ = 29;
            if (lcm_sym282__) {
              int inline_prob_uncaptured_t_curr_sym41__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym42__ =
                std::numeric_limits<int>::min();
              lcm_sym299__ = (lcm_sym295__ + 1);
              current_statement__ = 27;
              stan::model::assign(inline_prob_uncaptured_chi_sym40__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym44__),
                     stan::model::index_uni(lcm_sym295__)) * (1 -
                  stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym44__),
                    stan::model::index_uni(lcm_sym299__)))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym40__,
                    "inline_prob_uncaptured_chi_sym40__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym44__),
                    stan::model::index_uni(lcm_sym299__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym44__),
                    stan::model::index_uni(lcm_sym295__)))),
                "assigning variable inline_prob_uncaptured_chi_sym40__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym44__),
                stan::model::index_uni(lcm_sym295__));
              for (int inline_prob_uncaptured_t_sym43__ = 2; inline_prob_uncaptured_t_sym43__
                   <= lcm_sym295__; ++inline_prob_uncaptured_t_sym43__) {
                int inline_prob_uncaptured_t_curr_sym41__ =
                  std::numeric_limits<int>::min();
                lcm_sym294__ = (lcm_sym330__ -
                  inline_prob_uncaptured_t_sym43__);
                int inline_prob_uncaptured_t_next_sym42__ =
                  std::numeric_limits<int>::min();
                lcm_sym298__ = (lcm_sym294__ + 1);
                current_statement__ = 27;
                stan::model::assign(inline_prob_uncaptured_chi_sym40__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(
                         inline_prob_uncaptured_i_sym44__),
                       stan::model::index_uni(lcm_sym294__)) * (1 -
                    stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym44__),
                      stan::model::index_uni(lcm_sym298__)))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym40__,
                      "inline_prob_uncaptured_chi_sym40__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym44__),
                      stan::model::index_uni(lcm_sym298__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym44__),
                      stan::model::index_uni(lcm_sym294__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym40__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym44__),
                  stan::model::index_uni(lcm_sym294__));
              }
            }
          }
        }
        current_statement__ = 32;
        stan::model::assign(inline_prob_uncaptured_return_sym37__,
          inline_prob_uncaptured_chi_sym40__,
          "assigning variable inline_prob_uncaptured_return_sym37__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym37__,
        "assigning variable chi");
      current_statement__ = 6;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 6;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "p", lcm_sym339__, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "p", lcm_sym339__, 1);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym37__, 0);
      current_statement__ = 8;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym37__, 1);
      {
        current_statement__ = 78;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(epsilon, 0, sigma));
        {
          int inline_jolly_seber_lp_n_ind_sym46__ =
            std::numeric_limits<int>::min();
          lcm_sym346__ = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                           stan::model::index_uni(1));
          int inline_jolly_seber_lp_n_occasions_sym47__ =
            std::numeric_limits<int>::min();
          lcm_sym347__ = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                           stan::model::index_uni(2));
          current_statement__ = 81;
          stan::math::validate_non_negative_index("qgamma", "n_occasions",
            lcm_sym347__);
          Eigen::Matrix<double,-1,1> inline_jolly_seber_lp_qgamma_sym48__ =
            Eigen::Matrix<double,-1,1>::Constant(lcm_sym347__,
              std::numeric_limits<double>::quiet_NaN());
          stan::model::assign(lcm_sym291__, stan::math::subtract(1.0, gamma),
            "assigning variable lcm_sym291__");
          current_statement__ = 108;
          if (stan::math::logical_gte(lcm_sym346__, 1)) {
            current_statement__ = 83;
            stan::math::validate_non_negative_index("qp", "n_occasions",
              lcm_sym347__);
            Eigen::Matrix<double,-1,1> inline_jolly_seber_lp_qp_sym49__ =
              Eigen::Matrix<double,-1,1>::Constant(lcm_sym347__,
                std::numeric_limits<double>::quiet_NaN());
            stan::model::assign(lcm_sym293__,
              stan::math::subtract(1.0,
                stan::math::transpose(
                  stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                    stan::model::index_uni(1)))),
              "assigning variable lcm_sym293__");
            lcm_sym343__ = stan::model::rvalue(first, "first",
                             stan::model::index_uni(1));
            if (lcm_sym343__) {
              current_statement__ = 101;
              if (stan::math::logical_eq(lcm_sym343__, 1)) {
                current_statement__ = 99;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 (stan::model::rvalue(gamma, "gamma",
                                    stan::model::index_uni(1)) *
                                 stan::model::rvalue(lcm_sym339__,
                                   "lcm_sym339__", stan::model::index_uni(1),
                                   stan::model::index_uni(1)))));
              } else {
                current_statement__ = 92;
                stan::math::validate_non_negative_index("lp", "first[i]",
                  lcm_sym343__);
                Eigen::Matrix<local_scalar_t__,-1,1>
                  inline_jolly_seber_lp_lp_sym50__ =
                  Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym343__,
                    DUMMY_VAR__);
                lcm_sym297__ = (lcm_sym343__ - 1);
                stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                  (((stan::math::bernoulli_lpmf<false>(1,
                       stan::model::rvalue(gamma, "gamma",
                         stan::model::index_uni(1))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym293__, "lcm_sym293__",
                        stan::model::index_min_max(1, lcm_sym297__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(phi, "phi",
                        stan::model::index_uni(1),
                        stan::model::index_min_max(1, lcm_sym297__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                      stan::model::index_uni(1),
                      stan::model::index_uni(lcm_sym343__)))),
                  "assigning variable inline_jolly_seber_lp_lp_sym50__",
                  stan::model::index_uni(1));
                current_statement__ = 95;
                if (stan::math::logical_gte(lcm_sym297__, 2)) {
                  current_statement__ = 94;
                  stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                    ((((stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(lcm_sym291__, "lcm_sym291__",
                              stan::model::index_min_max(1, 1)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(gamma, "gamma",
                        stan::model::index_uni(2)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym293__, "lcm_sym293__",
                          stan::model::index_min_max(2, lcm_sym297__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(phi, "phi",
                          stan::model::index_uni(1),
                          stan::model::index_min_max(2, lcm_sym297__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                        stan::model::index_uni(1),
                        stan::model::index_uni(lcm_sym343__)))),
                    "assigning variable inline_jolly_seber_lp_lp_sym50__",
                    stan::model::index_uni(2));
                  for (int inline_jolly_seber_lp_t_sym51__ = 3; inline_jolly_seber_lp_t_sym51__
                       <= lcm_sym297__; ++inline_jolly_seber_lp_t_sym51__) {
                    current_statement__ = 94;
                    stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                      ((((stan::math::bernoulli_lpmf<false>(1,
                            stan::math::prod(
                              stan::model::rvalue(lcm_sym291__,
                                "lcm_sym291__",
                                stan::model::index_min_max(1,
                                  (inline_jolly_seber_lp_t_sym51__ - 1))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        gamma[(inline_jolly_seber_lp_t_sym51__ - 1)])) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym293__, "lcm_sym293__",
                            stan::model::index_min_max(
                              inline_jolly_seber_lp_t_sym51__, lcm_sym297__)))))
                      +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(phi, "phi",
                            stan::model::index_uni(1),
                            stan::model::index_min_max(
                              inline_jolly_seber_lp_t_sym51__, lcm_sym297__)))))
                      +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                          stan::model::index_uni(1),
                          stan::model::index_uni(lcm_sym343__)))),
                      "assigning variable inline_jolly_seber_lp_lp_sym50__",
                      stan::model::index_uni(inline_jolly_seber_lp_t_sym51__));
                  }
                }
                current_statement__ = 96;
                stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                  ((stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym291__, "lcm_sym291__",
                          stan::model::index_min_max(1, lcm_sym297__)))) +
                  stan::math::bernoulli_lpmf<false>(1, gamma[(lcm_sym343__ -
                    1)])) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                      stan::model::index_uni(1),
                      stan::model::index_uni(lcm_sym343__)))),
                  "assigning variable inline_jolly_seber_lp_lp_sym50__",
                  stan::model::index_uni(lcm_sym343__));
                current_statement__ = 97;
                lp_accum__.add(stan::math::log_sum_exp(
                                 inline_jolly_seber_lp_lp_sym50__));
              }
              lcm_sym345__ = stan::model::rvalue(last, "last",
                               stan::model::index_uni(1));
              if (stan::math::logical_gte(lcm_sym345__, (lcm_sym343__ + 1))) {
                current_statement__ = 102;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni(((lcm_sym343__ + 1)
                                     - 1)))));
                lcm_sym315__ = ((lcm_sym343__ + 1) + 1);
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((lcm_sym343__ + 1))),
                                 stan::model::rvalue(lcm_sym339__,
                                   "lcm_sym339__", stan::model::index_uni(1),
                                   stan::model::index_uni((lcm_sym343__ + 1)))));
                for (int inline_jolly_seber_lp_t_sym51__ = lcm_sym315__; inline_jolly_seber_lp_t_sym51__
                     <= lcm_sym345__; ++inline_jolly_seber_lp_t_sym51__) {
                  current_statement__ = 102;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(phi, "phi",
                                     stan::model::index_uni(1),
                                     stan::model::index_uni(
                                       (inline_jolly_seber_lp_t_sym51__ - 1)))));
                  current_statement__ = 103;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(1),
                                     stan::model::index_uni(
                                       inline_jolly_seber_lp_t_sym51__)),
                                   stan::model::rvalue(lcm_sym339__,
                                     "lcm_sym339__",
                                     stan::model::index_uni(1),
                                     stan::model::index_uni(
                                       inline_jolly_seber_lp_t_sym51__))));
                }
              }
              current_statement__ = 105;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(
                                 inline_prob_uncaptured_return_sym37__,
                                 "inline_prob_uncaptured_return_sym37__",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(lcm_sym345__))));
            } else {
              lcm_sym316__ = (lcm_sym347__ + 1);
              stan::math::validate_non_negative_index("lp",
                "n_occasions + 1", lcm_sym316__);
              Eigen::Matrix<local_scalar_t__,-1,1>
                inline_jolly_seber_lp_lp_sym50__ =
                Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym316__,
                  DUMMY_VAR__);
              current_statement__ = 86;
              stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                ((stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(gamma, "gamma",
                      stan::model::index_uni(1))) +
                stan::math::bernoulli_lpmf<false>(0,
                  stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                    stan::model::index_uni(1), stan::model::index_uni(1)))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(inline_prob_uncaptured_return_sym37__,
                    "inline_prob_uncaptured_return_sym37__",
                    stan::model::index_uni(1), stan::model::index_uni(1)))),
                "assigning variable inline_jolly_seber_lp_lp_sym50__",
                stan::model::index_uni(1));
              current_statement__ = 88;
              if (stan::math::logical_gte(lcm_sym347__, 2)) {
                current_statement__ = 87;
                stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                  (((stan::math::bernoulli_lpmf<false>(1,
                       stan::math::prod(
                         stan::model::rvalue(lcm_sym291__, "lcm_sym291__",
                           stan::model::index_min_max(1, 1)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(gamma, "gamma",
                      stan::model::index_uni(2)))) +
                  stan::math::bernoulli_lpmf<false>(0,
                    stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                      stan::model::index_uni(1), stan::model::index_uni(2))))
                  +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(
                      inline_prob_uncaptured_return_sym37__,
                      "inline_prob_uncaptured_return_sym37__",
                      stan::model::index_uni(1), stan::model::index_uni(2)))),
                  "assigning variable inline_jolly_seber_lp_lp_sym50__",
                  stan::model::index_uni(2));
                for (int inline_jolly_seber_lp_t_sym51__ = 3; inline_jolly_seber_lp_t_sym51__
                     <= lcm_sym347__; ++inline_jolly_seber_lp_t_sym51__) {
                  current_statement__ = 87;
                  stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                    (((stan::math::bernoulli_lpmf<false>(1,
                         stan::math::prod(
                           stan::model::rvalue(lcm_sym291__, "lcm_sym291__",
                             stan::model::index_min_max(1,
                               (inline_jolly_seber_lp_t_sym51__ - 1))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      gamma[(inline_jolly_seber_lp_t_sym51__ - 1)])) +
                    stan::math::bernoulli_lpmf<false>(0,
                      stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                        stan::model::index_uni(1),
                        stan::model::index_uni(
                          inline_jolly_seber_lp_t_sym51__)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(
                        inline_prob_uncaptured_return_sym37__,
                        "inline_prob_uncaptured_return_sym37__",
                        stan::model::index_uni(1),
                        stan::model::index_uni(
                          inline_jolly_seber_lp_t_sym51__)))),
                    "assigning variable inline_jolly_seber_lp_lp_sym50__",
                    stan::model::index_uni(inline_jolly_seber_lp_t_sym51__));
                }
              }
              current_statement__ = 89;
              stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(lcm_sym291__)),
                "assigning variable inline_jolly_seber_lp_lp_sym50__",
                stan::model::index_uni(lcm_sym316__));
              current_statement__ = 90;
              lp_accum__.add(stan::math::log_sum_exp(
                               inline_jolly_seber_lp_lp_sym50__));
            }
            for (int inline_jolly_seber_lp_i_sym52__ = 2; inline_jolly_seber_lp_i_sym52__
                 <= lcm_sym346__; ++inline_jolly_seber_lp_i_sym52__) {
              current_statement__ = 83;
              stan::math::validate_non_negative_index("qp", "n_occasions",
                lcm_sym347__);
              Eigen::Matrix<double,-1,1> inline_jolly_seber_lp_qp_sym49__ =
                Eigen::Matrix<double,-1,1>::Constant(lcm_sym347__,
                  std::numeric_limits<double>::quiet_NaN());
              stan::model::assign(lcm_sym292__,
                stan::math::subtract(1.0,
                  stan::math::transpose(
                    stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                      stan::model::index_uni(inline_jolly_seber_lp_i_sym52__)))),
                "assigning variable lcm_sym292__");
              lcm_sym342__ = first[(inline_jolly_seber_lp_i_sym52__ - 1)];
              if (lcm_sym342__) {
                current_statement__ = 101;
                if (stan::math::logical_eq(lcm_sym342__, 1)) {
                  current_statement__ = 99;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   (stan::model::rvalue(gamma, "gamma",
                                      stan::model::index_uni(1)) *
                                   stan::model::rvalue(lcm_sym339__,
                                     "lcm_sym339__",
                                     stan::model::index_uni(
                                       inline_jolly_seber_lp_i_sym52__),
                                     stan::model::index_uni(1)))));
                } else {
                  current_statement__ = 92;
                  stan::math::validate_non_negative_index("lp", "first[i]",
                    lcm_sym342__);
                  Eigen::Matrix<local_scalar_t__,-1,1>
                    inline_jolly_seber_lp_lp_sym50__ =
                    Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym342__,
                      DUMMY_VAR__);
                  lcm_sym296__ = (lcm_sym342__ - 1);
                  stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                    (((stan::math::bernoulli_lpmf<false>(1,
                         stan::model::rvalue(gamma, "gamma",
                           stan::model::index_uni(1))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym292__, "lcm_sym292__",
                          stan::model::index_min_max(1, lcm_sym296__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(phi, "phi",
                          stan::model::index_uni(
                            inline_jolly_seber_lp_i_sym52__),
                          stan::model::index_min_max(1, lcm_sym296__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                        stan::model::index_uni(
                          inline_jolly_seber_lp_i_sym52__),
                        stan::model::index_uni(lcm_sym342__)))),
                    "assigning variable inline_jolly_seber_lp_lp_sym50__",
                    stan::model::index_uni(1));
                  current_statement__ = 95;
                  if (stan::math::logical_gte(lcm_sym296__, 2)) {
                    current_statement__ = 94;
                    stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                      ((((stan::math::bernoulli_lpmf<false>(1,
                            stan::math::prod(
                              stan::model::rvalue(lcm_sym291__,
                                "lcm_sym291__",
                                stan::model::index_min_max(1, 1)))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(gamma, "gamma",
                          stan::model::index_uni(2)))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym292__, "lcm_sym292__",
                            stan::model::index_min_max(2, lcm_sym296__))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(phi, "phi",
                            stan::model::index_uni(
                              inline_jolly_seber_lp_i_sym52__),
                            stan::model::index_min_max(2, lcm_sym296__))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                          stan::model::index_uni(
                            inline_jolly_seber_lp_i_sym52__),
                          stan::model::index_uni(lcm_sym342__)))),
                      "assigning variable inline_jolly_seber_lp_lp_sym50__",
                      stan::model::index_uni(2));
                    for (int inline_jolly_seber_lp_t_sym51__ = 3; inline_jolly_seber_lp_t_sym51__
                         <= lcm_sym296__; ++inline_jolly_seber_lp_t_sym51__) {
                      current_statement__ = 94;
                      stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                        ((((stan::math::bernoulli_lpmf<false>(1,
                              stan::math::prod(
                                stan::model::rvalue(lcm_sym291__,
                                  "lcm_sym291__",
                                  stan::model::index_min_max(1,
                                    (inline_jolly_seber_lp_t_sym51__ - 1)))))
                        +
                        stan::math::bernoulli_lpmf<false>(1,
                          gamma[(inline_jolly_seber_lp_t_sym51__ - 1)])) +
                        stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(lcm_sym292__, "lcm_sym292__",
                              stan::model::index_min_max(
                                inline_jolly_seber_lp_t_sym51__, lcm_sym296__)))))
                        +
                        stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(phi, "phi",
                              stan::model::index_uni(
                                inline_jolly_seber_lp_i_sym52__),
                              stan::model::index_min_max(
                                inline_jolly_seber_lp_t_sym51__, lcm_sym296__)))))
                        +
                        stan::math::bernoulli_lpmf<false>(1,
                          stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                            stan::model::index_uni(
                              inline_jolly_seber_lp_i_sym52__),
                            stan::model::index_uni(lcm_sym342__)))),
                        "assigning variable inline_jolly_seber_lp_lp_sym50__",
                        stan::model::index_uni(
                          inline_jolly_seber_lp_t_sym51__));
                    }
                  }
                  current_statement__ = 96;
                  stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                    ((stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym291__, "lcm_sym291__",
                            stan::model::index_min_max(1, lcm_sym296__)))) +
                    stan::math::bernoulli_lpmf<false>(1, gamma[(lcm_sym342__
                      - 1)])) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                        stan::model::index_uni(
                          inline_jolly_seber_lp_i_sym52__),
                        stan::model::index_uni(lcm_sym342__)))),
                    "assigning variable inline_jolly_seber_lp_lp_sym50__",
                    stan::model::index_uni(lcm_sym342__));
                  current_statement__ = 97;
                  lp_accum__.add(stan::math::log_sum_exp(
                                   inline_jolly_seber_lp_lp_sym50__));
                }
                lcm_sym344__ = last[(inline_jolly_seber_lp_i_sym52__ - 1)];
                if (stan::math::logical_gte(lcm_sym344__, (lcm_sym342__ + 1))) {
                  current_statement__ = 102;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(phi, "phi",
                                     stan::model::index_uni(
                                       inline_jolly_seber_lp_i_sym52__),
                                     stan::model::index_uni(((lcm_sym342__ +
                                       1) - 1)))));
                  lcm_sym314__ = ((lcm_sym342__ + 1) + 1);
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(
                                       inline_jolly_seber_lp_i_sym52__),
                                     stan::model::index_uni((lcm_sym342__ +
                                       1))),
                                   stan::model::rvalue(lcm_sym339__,
                                     "lcm_sym339__",
                                     stan::model::index_uni(
                                       inline_jolly_seber_lp_i_sym52__),
                                     stan::model::index_uni((lcm_sym342__ +
                                       1)))));
                  for (int inline_jolly_seber_lp_t_sym51__ = lcm_sym314__; inline_jolly_seber_lp_t_sym51__
                       <= lcm_sym344__; ++inline_jolly_seber_lp_t_sym51__) {
                    current_statement__ = 102;
                    lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                     stan::model::rvalue(phi, "phi",
                                       stan::model::index_uni(
                                         inline_jolly_seber_lp_i_sym52__),
                                       stan::model::index_uni(
                                         (inline_jolly_seber_lp_t_sym51__ -
                                         1)))));
                    current_statement__ = 103;
                    lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                     y[(inline_jolly_seber_lp_i_sym52__ -
                                     1)][(inline_jolly_seber_lp_t_sym51__ -
                                     1)],
                                     stan::model::rvalue(lcm_sym339__,
                                       "lcm_sym339__",
                                       stan::model::index_uni(
                                         inline_jolly_seber_lp_i_sym52__),
                                       stan::model::index_uni(
                                         inline_jolly_seber_lp_t_sym51__))));
                  }
                }
                current_statement__ = 105;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(
                                   inline_prob_uncaptured_return_sym37__,
                                   "inline_prob_uncaptured_return_sym37__",
                                   stan::model::index_uni(
                                     inline_jolly_seber_lp_i_sym52__),
                                   stan::model::index_uni(lcm_sym344__))));
              } else {
                lcm_sym316__ = (lcm_sym347__ + 1);
                stan::math::validate_non_negative_index("lp",
                  "n_occasions + 1", lcm_sym316__);
                Eigen::Matrix<local_scalar_t__,-1,1>
                  inline_jolly_seber_lp_lp_sym50__ =
                  Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym316__,
                    DUMMY_VAR__);
                current_statement__ = 86;
                stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                  ((stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(gamma, "gamma",
                        stan::model::index_uni(1))) +
                  stan::math::bernoulli_lpmf<false>(0,
                    stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                      stan::model::index_uni(inline_jolly_seber_lp_i_sym52__),
                      stan::model::index_uni(1)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(
                      inline_prob_uncaptured_return_sym37__,
                      "inline_prob_uncaptured_return_sym37__",
                      stan::model::index_uni(inline_jolly_seber_lp_i_sym52__),
                      stan::model::index_uni(1)))),
                  "assigning variable inline_jolly_seber_lp_lp_sym50__",
                  stan::model::index_uni(1));
                current_statement__ = 88;
                if (stan::math::logical_gte(lcm_sym347__, 2)) {
                  current_statement__ = 87;
                  stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                    (((stan::math::bernoulli_lpmf<false>(1,
                         stan::math::prod(
                           stan::model::rvalue(lcm_sym291__, "lcm_sym291__",
                             stan::model::index_min_max(1, 1)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(gamma, "gamma",
                        stan::model::index_uni(2)))) +
                    stan::math::bernoulli_lpmf<false>(0,
                      stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                        stan::model::index_uni(
                          inline_jolly_seber_lp_i_sym52__),
                        stan::model::index_uni(2)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(
                        inline_prob_uncaptured_return_sym37__,
                        "inline_prob_uncaptured_return_sym37__",
                        stan::model::index_uni(
                          inline_jolly_seber_lp_i_sym52__),
                        stan::model::index_uni(2)))),
                    "assigning variable inline_jolly_seber_lp_lp_sym50__",
                    stan::model::index_uni(2));
                  for (int inline_jolly_seber_lp_t_sym51__ = 3; inline_jolly_seber_lp_t_sym51__
                       <= lcm_sym347__; ++inline_jolly_seber_lp_t_sym51__) {
                    current_statement__ = 87;
                    stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                      (((stan::math::bernoulli_lpmf<false>(1,
                           stan::math::prod(
                             stan::model::rvalue(lcm_sym291__,
                               "lcm_sym291__",
                               stan::model::index_min_max(1,
                                 (inline_jolly_seber_lp_t_sym51__ - 1))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        gamma[(inline_jolly_seber_lp_t_sym51__ - 1)])) +
                      stan::math::bernoulli_lpmf<false>(0,
                        stan::model::rvalue(lcm_sym339__, "lcm_sym339__",
                          stan::model::index_uni(
                            inline_jolly_seber_lp_i_sym52__),
                          stan::model::index_uni(
                            inline_jolly_seber_lp_t_sym51__)))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(
                          inline_prob_uncaptured_return_sym37__,
                          "inline_prob_uncaptured_return_sym37__",
                          stan::model::index_uni(
                            inline_jolly_seber_lp_i_sym52__),
                          stan::model::index_uni(
                            inline_jolly_seber_lp_t_sym51__)))),
                      "assigning variable inline_jolly_seber_lp_lp_sym50__",
                      stan::model::index_uni(inline_jolly_seber_lp_t_sym51__));
                  }
                }
                current_statement__ = 89;
                stan::model::assign(inline_jolly_seber_lp_lp_sym50__,
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(lcm_sym291__)),
                  "assigning variable inline_jolly_seber_lp_lp_sym50__",
                  stan::model::index_uni(lcm_sym316__));
                current_statement__ = 90;
                lp_accum__.add(stan::math::log_sum_exp(
                                 inline_jolly_seber_lp_lp_sym50__));
              }
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "inlining_fail2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym277__;
      int lcm_sym276__;
      int lcm_sym275__;
      int lcm_sym274__;
      int lcm_sym273__;
      int lcm_sym272__;
      int lcm_sym270__;
      Eigen::Matrix<local_scalar_t__,-1,-1> lcm_sym269__;
      double lcm_sym268__;
      double lcm_sym267__;
      local_scalar_t__ lcm_sym266__;
      local_scalar_t__ lcm_sym265__;
      double lcm_sym264__;
      double lcm_sym263__;
      double lcm_sym262__;
      double lcm_sym261__;
      int lcm_sym260__;
      double lcm_sym259__;
      double lcm_sym258__;
      double lcm_sym257__;
      double lcm_sym256__;
      double lcm_sym255__;
      double lcm_sym254__;
      double lcm_sym253__;
      double lcm_sym252__;
      double lcm_sym251__;
      double lcm_sym250__;
      double lcm_sym249__;
      double lcm_sym248__;
      double lcm_sym247__;
      int lcm_sym246__;
      int lcm_sym245__;
      int lcm_sym244__;
      double lcm_sym243__;
      double lcm_sym242__;
      double lcm_sym241__;
      double lcm_sym240__;
      double lcm_sym239__;
      double lcm_sym238__;
      double lcm_sym237__;
      double lcm_sym236__;
      double lcm_sym235__;
      double lcm_sym234__;
      double lcm_sym233__;
      double lcm_sym232__;
      double lcm_sym231__;
      double lcm_sym230__;
      int lcm_sym229__;
      int lcm_sym228__;
      int lcm_sym227__;
      int lcm_sym226__;
      int lcm_sym225__;
      int lcm_sym224__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym223__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym222__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym221__;
      int lcm_sym271__;
      int lcm_sym219__;
      int lcm_sym218__;
      int lcm_sym217__;
      int lcm_sym216__;
      int lcm_sym215__;
      int lcm_sym214__;
      int lcm_sym213__;
      int lcm_sym212__;
      int lcm_sym211__;
      int lcm_sym210__;
      int lcm_sym209__;
      int lcm_sym208__;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> gamma;
      current_statement__ = 3;
      gamma = in__.template read_constrain_lub<
                Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, 1, lp__,
                n_occasions);
      Eigen::Matrix<local_scalar_t__,-1,1> epsilon =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant((n_occasions - 1),
          DUMMY_VAR__);
      lcm_sym271__ = (n_occasions - 1);
      epsilon = in__.template read<
                  Eigen::Matrix<local_scalar_t__,-1,1>>(lcm_sym271__);
      local_scalar_t__ sigma;
      current_statement__ = 5;
      sigma = in__.template read_constrain_lub<local_scalar_t__,
                jacobian__>(0, 5, lp__);
      Eigen::Matrix<local_scalar_t__,-1,-1> phi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, lcm_sym271__,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, n_occasions,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, n_occasions,
          DUMMY_VAR__);
      current_statement__ = 18;
      if (stan::math::logical_gte(lcm_sym271__, 1)) {
        lcm_sym210__ = stan::math::logical_gte(M, 1);
        if (lcm_sym210__) {
          lcm_sym266__ = stan::math::inv_logit((stan::math::logit(mean_phi) +
                           stan::model::rvalue(epsilon, "epsilon",
                             stan::model::index_uni(1))));
          stan::model::assign(phi, lcm_sym266__, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int i = 2; i <= M; ++i) {
            current_statement__ = 16;
            stan::model::assign(phi, lcm_sym266__, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
          }
        }
        for (int t = 2; t <= lcm_sym271__; ++t) {
          current_statement__ = 17;
          if (lcm_sym210__) {
            lcm_sym265__ = stan::math::inv_logit((stan::math::logit(mean_phi)
                             +
                             stan::model::rvalue(epsilon, "epsilon",
                               stan::model::index_uni(t))));
            stan::model::assign(phi, lcm_sym265__, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            for (int i = 2; i <= M; ++i) {
              current_statement__ = 16;
              stan::model::assign(phi, lcm_sym265__,
                "assigning variable phi", stan::model::index_uni(i),
                stan::model::index_uni(t));
            }
          }
        }
      }
      stan::model::assign(lcm_sym269__,
        stan::math::rep_matrix(mean_p, M, n_occasions),
        "assigning variable lcm_sym269__");
      stan::model::assign(p, lcm_sym269__, "assigning variable p");
      Eigen::Matrix<local_scalar_t__,-1,-1>
        inline_prob_uncaptured_return_sym20__;
      {
        int inline_prob_uncaptured_n_ind_sym21__ =
          std::numeric_limits<int>::min();
        lcm_sym270__ = stan::math::rows(lcm_sym269__);
        int inline_prob_uncaptured_n_occasions_sym22__ =
          std::numeric_limits<int>::min();
        lcm_sym260__ = stan::math::cols(lcm_sym269__);
        current_statement__ = 21;
        stan::math::validate_non_negative_index("chi", "n_ind", lcm_sym270__);
        current_statement__ = 22;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          lcm_sym260__);
        Eigen::Matrix<local_scalar_t__,-1,-1>
          inline_prob_uncaptured_chi_sym23__ =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(lcm_sym270__,
            lcm_sym260__, DUMMY_VAR__);
        current_statement__ = 31;
        if (stan::math::logical_gte(lcm_sym270__, 1)) {
          current_statement__ = 24;
          stan::model::assign(inline_prob_uncaptured_chi_sym23__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym23__",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym260__));
          lcm_sym225__ = (lcm_sym260__ - 1);
          lcm_sym212__ = stan::math::logical_gte(lcm_sym225__, 1);
          if (lcm_sym212__) {
            int inline_prob_uncaptured_t_curr_sym24__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym25__ =
              std::numeric_limits<int>::min();
            lcm_sym229__ = (lcm_sym225__ + 1);
            current_statement__ = 27;
            stan::model::assign(inline_prob_uncaptured_chi_sym23__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym225__)) * (1 -
                stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym229__)))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym23__,
                  "inline_prob_uncaptured_chi_sym23__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym229__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym225__)))),
              "assigning variable inline_prob_uncaptured_chi_sym23__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym225__));
            for (int inline_prob_uncaptured_t_sym26__ = 2; inline_prob_uncaptured_t_sym26__
                 <= lcm_sym225__; ++inline_prob_uncaptured_t_sym26__) {
              int inline_prob_uncaptured_t_curr_sym24__ =
                std::numeric_limits<int>::min();
              lcm_sym224__ = (lcm_sym260__ -
                inline_prob_uncaptured_t_sym26__);
              int inline_prob_uncaptured_t_next_sym25__ =
                std::numeric_limits<int>::min();
              lcm_sym228__ = (lcm_sym224__ + 1);
              current_statement__ = 27;
              stan::model::assign(inline_prob_uncaptured_chi_sym23__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym224__)) * (1 -
                  stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym228__)))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym23__,
                    "inline_prob_uncaptured_chi_sym23__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym228__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym224__)))),
                "assigning variable inline_prob_uncaptured_chi_sym23__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym224__));
            }
          }
          for (int inline_prob_uncaptured_i_sym27__ = 2; inline_prob_uncaptured_i_sym27__
               <= lcm_sym270__; ++inline_prob_uncaptured_i_sym27__) {
            current_statement__ = 24;
            stan::model::assign(inline_prob_uncaptured_chi_sym23__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym23__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym27__),
              stan::model::index_uni(lcm_sym260__));
            current_statement__ = 29;
            if (lcm_sym212__) {
              int inline_prob_uncaptured_t_curr_sym24__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym25__ =
                std::numeric_limits<int>::min();
              lcm_sym229__ = (lcm_sym225__ + 1);
              current_statement__ = 27;
              stan::model::assign(inline_prob_uncaptured_chi_sym23__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym27__),
                     stan::model::index_uni(lcm_sym225__)) * (1 -
                  stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym27__),
                    stan::model::index_uni(lcm_sym229__)))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym23__,
                    "inline_prob_uncaptured_chi_sym23__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym27__),
                    stan::model::index_uni(lcm_sym229__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym27__),
                    stan::model::index_uni(lcm_sym225__)))),
                "assigning variable inline_prob_uncaptured_chi_sym23__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym27__),
                stan::model::index_uni(lcm_sym225__));
              for (int inline_prob_uncaptured_t_sym26__ = 2; inline_prob_uncaptured_t_sym26__
                   <= lcm_sym225__; ++inline_prob_uncaptured_t_sym26__) {
                int inline_prob_uncaptured_t_curr_sym24__ =
                  std::numeric_limits<int>::min();
                lcm_sym224__ = (lcm_sym260__ -
                  inline_prob_uncaptured_t_sym26__);
                int inline_prob_uncaptured_t_next_sym25__ =
                  std::numeric_limits<int>::min();
                lcm_sym228__ = (lcm_sym224__ + 1);
                current_statement__ = 27;
                stan::model::assign(inline_prob_uncaptured_chi_sym23__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(
                         inline_prob_uncaptured_i_sym27__),
                       stan::model::index_uni(lcm_sym224__)) * (1 -
                    stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym27__),
                      stan::model::index_uni(lcm_sym228__)))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym23__,
                      "inline_prob_uncaptured_chi_sym23__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym27__),
                      stan::model::index_uni(lcm_sym228__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym27__),
                      stan::model::index_uni(lcm_sym224__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym23__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym27__),
                  stan::model::index_uni(lcm_sym224__));
              }
            }
          }
        }
        current_statement__ = 32;
        stan::model::assign(inline_prob_uncaptured_return_sym20__,
          inline_prob_uncaptured_chi_sym23__,
          "assigning variable inline_prob_uncaptured_return_sym20__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym20__,
        "assigning variable chi");
      current_statement__ = 6;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 6;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "p", lcm_sym269__, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "p", lcm_sym269__, 1);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym20__, 0);
      current_statement__ = 8;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym20__, 1);
      {
        current_statement__ = 78;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(epsilon, 0, sigma));
        {
          int inline_jolly_seber_lp_n_ind_sym29__ =
            std::numeric_limits<int>::min();
          lcm_sym276__ = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                           stan::model::index_uni(1));
          int inline_jolly_seber_lp_n_occasions_sym30__ =
            std::numeric_limits<int>::min();
          lcm_sym277__ = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                           stan::model::index_uni(2));
          current_statement__ = 81;
          stan::math::validate_non_negative_index("qgamma", "n_occasions",
            lcm_sym277__);
          stan::math::var_value<Eigen::Matrix<double,-1,1>>
            inline_jolly_seber_lp_qgamma_sym31__ =
            Eigen::Matrix<double,-1,1>::Constant(lcm_sym277__,
              std::numeric_limits<double>::quiet_NaN());
          stan::model::assign(lcm_sym221__, stan::math::subtract(1.0, gamma),
            "assigning variable lcm_sym221__");
          current_statement__ = 108;
          if (stan::math::logical_gte(lcm_sym276__, 1)) {
            current_statement__ = 83;
            stan::math::validate_non_negative_index("qp", "n_occasions",
              lcm_sym277__);
            stan::math::var_value<Eigen::Matrix<double,-1,1>>
              inline_jolly_seber_lp_qp_sym32__ =
              Eigen::Matrix<double,-1,1>::Constant(lcm_sym277__,
                std::numeric_limits<double>::quiet_NaN());
            stan::model::assign(lcm_sym223__,
              stan::math::subtract(1.0,
                stan::math::transpose(
                  stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                    stan::model::index_uni(1)))),
              "assigning variable lcm_sym223__");
            lcm_sym273__ = stan::model::rvalue(first, "first",
                             stan::model::index_uni(1));
            if (lcm_sym273__) {
              current_statement__ = 101;
              if (stan::math::logical_eq(lcm_sym273__, 1)) {
                current_statement__ = 99;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 (stan::model::rvalue(gamma, "gamma",
                                    stan::model::index_uni(1)) *
                                 stan::model::rvalue(lcm_sym269__,
                                   "lcm_sym269__", stan::model::index_uni(1),
                                   stan::model::index_uni(1)))));
              } else {
                current_statement__ = 92;
                stan::math::validate_non_negative_index("lp", "first[i]",
                  lcm_sym273__);
                Eigen::Matrix<local_scalar_t__,-1,1>
                  inline_jolly_seber_lp_lp_sym33__ =
                  Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym273__,
                    DUMMY_VAR__);
                lcm_sym227__ = (lcm_sym273__ - 1);
                stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                  (((stan::math::bernoulli_lpmf<false>(1,
                       stan::model::rvalue(gamma, "gamma",
                         stan::model::index_uni(1))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(lcm_sym223__, "lcm_sym223__",
                        stan::model::index_min_max(1, lcm_sym227__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(phi, "phi",
                        stan::model::index_uni(1),
                        stan::model::index_min_max(1, lcm_sym227__))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                      stan::model::index_uni(1),
                      stan::model::index_uni(lcm_sym273__)))),
                  "assigning variable inline_jolly_seber_lp_lp_sym33__",
                  stan::model::index_uni(1));
                current_statement__ = 95;
                if (stan::math::logical_gte(lcm_sym227__, 2)) {
                  current_statement__ = 94;
                  stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                    ((((stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(lcm_sym221__, "lcm_sym221__",
                              stan::model::index_min_max(1, 1)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(gamma, "gamma",
                        stan::model::index_uni(2)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym223__, "lcm_sym223__",
                          stan::model::index_min_max(2, lcm_sym227__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(phi, "phi",
                          stan::model::index_uni(1),
                          stan::model::index_min_max(2, lcm_sym227__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                        stan::model::index_uni(1),
                        stan::model::index_uni(lcm_sym273__)))),
                    "assigning variable inline_jolly_seber_lp_lp_sym33__",
                    stan::model::index_uni(2));
                  for (int inline_jolly_seber_lp_t_sym34__ = 3; inline_jolly_seber_lp_t_sym34__
                       <= lcm_sym227__; ++inline_jolly_seber_lp_t_sym34__) {
                    current_statement__ = 94;
                    stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                      ((((stan::math::bernoulli_lpmf<false>(1,
                            stan::math::prod(
                              stan::model::rvalue(lcm_sym221__,
                                "lcm_sym221__",
                                stan::model::index_min_max(1,
                                  (inline_jolly_seber_lp_t_sym34__ - 1))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        gamma[(inline_jolly_seber_lp_t_sym34__ - 1)])) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym223__, "lcm_sym223__",
                            stan::model::index_min_max(
                              inline_jolly_seber_lp_t_sym34__, lcm_sym227__)))))
                      +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(phi, "phi",
                            stan::model::index_uni(1),
                            stan::model::index_min_max(
                              inline_jolly_seber_lp_t_sym34__, lcm_sym227__)))))
                      +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                          stan::model::index_uni(1),
                          stan::model::index_uni(lcm_sym273__)))),
                      "assigning variable inline_jolly_seber_lp_lp_sym33__",
                      stan::model::index_uni(inline_jolly_seber_lp_t_sym34__));
                  }
                }
                current_statement__ = 96;
                stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                  ((stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym221__, "lcm_sym221__",
                          stan::model::index_min_max(1, lcm_sym227__)))) +
                  stan::math::bernoulli_lpmf<false>(1, gamma[(lcm_sym273__ -
                    1)])) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                      stan::model::index_uni(1),
                      stan::model::index_uni(lcm_sym273__)))),
                  "assigning variable inline_jolly_seber_lp_lp_sym33__",
                  stan::model::index_uni(lcm_sym273__));
                current_statement__ = 97;
                lp_accum__.add(stan::math::log_sum_exp(
                                 inline_jolly_seber_lp_lp_sym33__));
              }
              lcm_sym275__ = stan::model::rvalue(last, "last",
                               stan::model::index_uni(1));
              if (stan::math::logical_gte(lcm_sym275__, (lcm_sym273__ + 1))) {
                current_statement__ = 102;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni(((lcm_sym273__ + 1)
                                     - 1)))));
                lcm_sym245__ = ((lcm_sym273__ + 1) + 1);
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((lcm_sym273__ + 1))),
                                 stan::model::rvalue(lcm_sym269__,
                                   "lcm_sym269__", stan::model::index_uni(1),
                                   stan::model::index_uni((lcm_sym273__ + 1)))));
                for (int inline_jolly_seber_lp_t_sym34__ = lcm_sym245__; inline_jolly_seber_lp_t_sym34__
                     <= lcm_sym275__; ++inline_jolly_seber_lp_t_sym34__) {
                  current_statement__ = 102;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(phi, "phi",
                                     stan::model::index_uni(1),
                                     stan::model::index_uni(
                                       (inline_jolly_seber_lp_t_sym34__ - 1)))));
                  current_statement__ = 103;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(1),
                                     stan::model::index_uni(
                                       inline_jolly_seber_lp_t_sym34__)),
                                   stan::model::rvalue(lcm_sym269__,
                                     "lcm_sym269__",
                                     stan::model::index_uni(1),
                                     stan::model::index_uni(
                                       inline_jolly_seber_lp_t_sym34__))));
                }
              }
              current_statement__ = 105;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(
                                 inline_prob_uncaptured_return_sym20__,
                                 "inline_prob_uncaptured_return_sym20__",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(lcm_sym275__))));
            } else {
              lcm_sym246__ = (lcm_sym277__ + 1);
              stan::math::validate_non_negative_index("lp",
                "n_occasions + 1", lcm_sym246__);
              Eigen::Matrix<local_scalar_t__,-1,1>
                inline_jolly_seber_lp_lp_sym33__ =
                Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym246__,
                  DUMMY_VAR__);
              current_statement__ = 86;
              stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                ((stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(gamma, "gamma",
                      stan::model::index_uni(1))) +
                stan::math::bernoulli_lpmf<false>(0,
                  stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                    stan::model::index_uni(1), stan::model::index_uni(1)))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(inline_prob_uncaptured_return_sym20__,
                    "inline_prob_uncaptured_return_sym20__",
                    stan::model::index_uni(1), stan::model::index_uni(1)))),
                "assigning variable inline_jolly_seber_lp_lp_sym33__",
                stan::model::index_uni(1));
              current_statement__ = 88;
              if (stan::math::logical_gte(lcm_sym277__, 2)) {
                current_statement__ = 87;
                stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                  (((stan::math::bernoulli_lpmf<false>(1,
                       stan::math::prod(
                         stan::model::rvalue(lcm_sym221__, "lcm_sym221__",
                           stan::model::index_min_max(1, 1)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(gamma, "gamma",
                      stan::model::index_uni(2)))) +
                  stan::math::bernoulli_lpmf<false>(0,
                    stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                      stan::model::index_uni(1), stan::model::index_uni(2))))
                  +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(
                      inline_prob_uncaptured_return_sym20__,
                      "inline_prob_uncaptured_return_sym20__",
                      stan::model::index_uni(1), stan::model::index_uni(2)))),
                  "assigning variable inline_jolly_seber_lp_lp_sym33__",
                  stan::model::index_uni(2));
                for (int inline_jolly_seber_lp_t_sym34__ = 3; inline_jolly_seber_lp_t_sym34__
                     <= lcm_sym277__; ++inline_jolly_seber_lp_t_sym34__) {
                  current_statement__ = 87;
                  stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                    (((stan::math::bernoulli_lpmf<false>(1,
                         stan::math::prod(
                           stan::model::rvalue(lcm_sym221__, "lcm_sym221__",
                             stan::model::index_min_max(1,
                               (inline_jolly_seber_lp_t_sym34__ - 1))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      gamma[(inline_jolly_seber_lp_t_sym34__ - 1)])) +
                    stan::math::bernoulli_lpmf<false>(0,
                      stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                        stan::model::index_uni(1),
                        stan::model::index_uni(
                          inline_jolly_seber_lp_t_sym34__)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(
                        inline_prob_uncaptured_return_sym20__,
                        "inline_prob_uncaptured_return_sym20__",
                        stan::model::index_uni(1),
                        stan::model::index_uni(
                          inline_jolly_seber_lp_t_sym34__)))),
                    "assigning variable inline_jolly_seber_lp_lp_sym33__",
                    stan::model::index_uni(inline_jolly_seber_lp_t_sym34__));
                }
              }
              current_statement__ = 89;
              stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(lcm_sym221__)),
                "assigning variable inline_jolly_seber_lp_lp_sym33__",
                stan::model::index_uni(lcm_sym246__));
              current_statement__ = 90;
              lp_accum__.add(stan::math::log_sum_exp(
                               inline_jolly_seber_lp_lp_sym33__));
            }
            for (int inline_jolly_seber_lp_i_sym35__ = 2; inline_jolly_seber_lp_i_sym35__
                 <= lcm_sym276__; ++inline_jolly_seber_lp_i_sym35__) {
              current_statement__ = 83;
              stan::math::validate_non_negative_index("qp", "n_occasions",
                lcm_sym277__);
              stan::math::var_value<Eigen::Matrix<double,-1,1>>
                inline_jolly_seber_lp_qp_sym32__ =
                Eigen::Matrix<double,-1,1>::Constant(lcm_sym277__,
                  std::numeric_limits<double>::quiet_NaN());
              stan::model::assign(lcm_sym222__,
                stan::math::subtract(1.0,
                  stan::math::transpose(
                    stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                      stan::model::index_uni(inline_jolly_seber_lp_i_sym35__)))),
                "assigning variable lcm_sym222__");
              lcm_sym272__ = first[(inline_jolly_seber_lp_i_sym35__ - 1)];
              if (lcm_sym272__) {
                current_statement__ = 101;
                if (stan::math::logical_eq(lcm_sym272__, 1)) {
                  current_statement__ = 99;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   (stan::model::rvalue(gamma, "gamma",
                                      stan::model::index_uni(1)) *
                                   stan::model::rvalue(lcm_sym269__,
                                     "lcm_sym269__",
                                     stan::model::index_uni(
                                       inline_jolly_seber_lp_i_sym35__),
                                     stan::model::index_uni(1)))));
                } else {
                  current_statement__ = 92;
                  stan::math::validate_non_negative_index("lp", "first[i]",
                    lcm_sym272__);
                  Eigen::Matrix<local_scalar_t__,-1,1>
                    inline_jolly_seber_lp_lp_sym33__ =
                    Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym272__,
                      DUMMY_VAR__);
                  lcm_sym226__ = (lcm_sym272__ - 1);
                  stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                    (((stan::math::bernoulli_lpmf<false>(1,
                         stan::model::rvalue(gamma, "gamma",
                           stan::model::index_uni(1))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(lcm_sym222__, "lcm_sym222__",
                          stan::model::index_min_max(1, lcm_sym226__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(phi, "phi",
                          stan::model::index_uni(
                            inline_jolly_seber_lp_i_sym35__),
                          stan::model::index_min_max(1, lcm_sym226__))))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                        stan::model::index_uni(
                          inline_jolly_seber_lp_i_sym35__),
                        stan::model::index_uni(lcm_sym272__)))),
                    "assigning variable inline_jolly_seber_lp_lp_sym33__",
                    stan::model::index_uni(1));
                  current_statement__ = 95;
                  if (stan::math::logical_gte(lcm_sym226__, 2)) {
                    current_statement__ = 94;
                    stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                      ((((stan::math::bernoulli_lpmf<false>(1,
                            stan::math::prod(
                              stan::model::rvalue(lcm_sym221__,
                                "lcm_sym221__",
                                stan::model::index_min_max(1, 1)))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(gamma, "gamma",
                          stan::model::index_uni(2)))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym222__, "lcm_sym222__",
                            stan::model::index_min_max(2, lcm_sym226__))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(phi, "phi",
                            stan::model::index_uni(
                              inline_jolly_seber_lp_i_sym35__),
                            stan::model::index_min_max(2, lcm_sym226__))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                          stan::model::index_uni(
                            inline_jolly_seber_lp_i_sym35__),
                          stan::model::index_uni(lcm_sym272__)))),
                      "assigning variable inline_jolly_seber_lp_lp_sym33__",
                      stan::model::index_uni(2));
                    for (int inline_jolly_seber_lp_t_sym34__ = 3; inline_jolly_seber_lp_t_sym34__
                         <= lcm_sym226__; ++inline_jolly_seber_lp_t_sym34__) {
                      current_statement__ = 94;
                      stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                        ((((stan::math::bernoulli_lpmf<false>(1,
                              stan::math::prod(
                                stan::model::rvalue(lcm_sym221__,
                                  "lcm_sym221__",
                                  stan::model::index_min_max(1,
                                    (inline_jolly_seber_lp_t_sym34__ - 1)))))
                        +
                        stan::math::bernoulli_lpmf<false>(1,
                          gamma[(inline_jolly_seber_lp_t_sym34__ - 1)])) +
                        stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(lcm_sym222__, "lcm_sym222__",
                              stan::model::index_min_max(
                                inline_jolly_seber_lp_t_sym34__, lcm_sym226__)))))
                        +
                        stan::math::bernoulli_lpmf<false>(1,
                          stan::math::prod(
                            stan::model::rvalue(phi, "phi",
                              stan::model::index_uni(
                                inline_jolly_seber_lp_i_sym35__),
                              stan::model::index_min_max(
                                inline_jolly_seber_lp_t_sym34__, lcm_sym226__)))))
                        +
                        stan::math::bernoulli_lpmf<false>(1,
                          stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                            stan::model::index_uni(
                              inline_jolly_seber_lp_i_sym35__),
                            stan::model::index_uni(lcm_sym272__)))),
                        "assigning variable inline_jolly_seber_lp_lp_sym33__",
                        stan::model::index_uni(
                          inline_jolly_seber_lp_t_sym34__));
                    }
                  }
                  current_statement__ = 96;
                  stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                    ((stan::math::bernoulli_lpmf<false>(1,
                        stan::math::prod(
                          stan::model::rvalue(lcm_sym221__, "lcm_sym221__",
                            stan::model::index_min_max(1, lcm_sym226__)))) +
                    stan::math::bernoulli_lpmf<false>(1, gamma[(lcm_sym272__
                      - 1)])) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                        stan::model::index_uni(
                          inline_jolly_seber_lp_i_sym35__),
                        stan::model::index_uni(lcm_sym272__)))),
                    "assigning variable inline_jolly_seber_lp_lp_sym33__",
                    stan::model::index_uni(lcm_sym272__));
                  current_statement__ = 97;
                  lp_accum__.add(stan::math::log_sum_exp(
                                   inline_jolly_seber_lp_lp_sym33__));
                }
                lcm_sym274__ = last[(inline_jolly_seber_lp_i_sym35__ - 1)];
                if (stan::math::logical_gte(lcm_sym274__, (lcm_sym272__ + 1))) {
                  current_statement__ = 102;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(phi, "phi",
                                     stan::model::index_uni(
                                       inline_jolly_seber_lp_i_sym35__),
                                     stan::model::index_uni(((lcm_sym272__ +
                                       1) - 1)))));
                  lcm_sym244__ = ((lcm_sym272__ + 1) + 1);
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(
                                       inline_jolly_seber_lp_i_sym35__),
                                     stan::model::index_uni((lcm_sym272__ +
                                       1))),
                                   stan::model::rvalue(lcm_sym269__,
                                     "lcm_sym269__",
                                     stan::model::index_uni(
                                       inline_jolly_seber_lp_i_sym35__),
                                     stan::model::index_uni((lcm_sym272__ +
                                       1)))));
                  for (int inline_jolly_seber_lp_t_sym34__ = lcm_sym244__; inline_jolly_seber_lp_t_sym34__
                       <= lcm_sym274__; ++inline_jolly_seber_lp_t_sym34__) {
                    current_statement__ = 102;
                    lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                     stan::model::rvalue(phi, "phi",
                                       stan::model::index_uni(
                                         inline_jolly_seber_lp_i_sym35__),
                                       stan::model::index_uni(
                                         (inline_jolly_seber_lp_t_sym34__ -
                                         1)))));
                    current_statement__ = 103;
                    lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                     y[(inline_jolly_seber_lp_i_sym35__ -
                                     1)][(inline_jolly_seber_lp_t_sym34__ -
                                     1)],
                                     stan::model::rvalue(lcm_sym269__,
                                       "lcm_sym269__",
                                       stan::model::index_uni(
                                         inline_jolly_seber_lp_i_sym35__),
                                       stan::model::index_uni(
                                         inline_jolly_seber_lp_t_sym34__))));
                  }
                }
                current_statement__ = 105;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(
                                   inline_prob_uncaptured_return_sym20__,
                                   "inline_prob_uncaptured_return_sym20__",
                                   stan::model::index_uni(
                                     inline_jolly_seber_lp_i_sym35__),
                                   stan::model::index_uni(lcm_sym274__))));
              } else {
                lcm_sym246__ = (lcm_sym277__ + 1);
                stan::math::validate_non_negative_index("lp",
                  "n_occasions + 1", lcm_sym246__);
                Eigen::Matrix<local_scalar_t__,-1,1>
                  inline_jolly_seber_lp_lp_sym33__ =
                  Eigen::Matrix<local_scalar_t__,-1,1>::Constant(lcm_sym246__,
                    DUMMY_VAR__);
                current_statement__ = 86;
                stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                  ((stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(gamma, "gamma",
                        stan::model::index_uni(1))) +
                  stan::math::bernoulli_lpmf<false>(0,
                    stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                      stan::model::index_uni(inline_jolly_seber_lp_i_sym35__),
                      stan::model::index_uni(1)))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(
                      inline_prob_uncaptured_return_sym20__,
                      "inline_prob_uncaptured_return_sym20__",
                      stan::model::index_uni(inline_jolly_seber_lp_i_sym35__),
                      stan::model::index_uni(1)))),
                  "assigning variable inline_jolly_seber_lp_lp_sym33__",
                  stan::model::index_uni(1));
                current_statement__ = 88;
                if (stan::math::logical_gte(lcm_sym277__, 2)) {
                  current_statement__ = 87;
                  stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                    (((stan::math::bernoulli_lpmf<false>(1,
                         stan::math::prod(
                           stan::model::rvalue(lcm_sym221__, "lcm_sym221__",
                             stan::model::index_min_max(1, 1)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(gamma, "gamma",
                        stan::model::index_uni(2)))) +
                    stan::math::bernoulli_lpmf<false>(0,
                      stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                        stan::model::index_uni(
                          inline_jolly_seber_lp_i_sym35__),
                        stan::model::index_uni(2)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::model::rvalue(
                        inline_prob_uncaptured_return_sym20__,
                        "inline_prob_uncaptured_return_sym20__",
                        stan::model::index_uni(
                          inline_jolly_seber_lp_i_sym35__),
                        stan::model::index_uni(2)))),
                    "assigning variable inline_jolly_seber_lp_lp_sym33__",
                    stan::model::index_uni(2));
                  for (int inline_jolly_seber_lp_t_sym34__ = 3; inline_jolly_seber_lp_t_sym34__
                       <= lcm_sym277__; ++inline_jolly_seber_lp_t_sym34__) {
                    current_statement__ = 87;
                    stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                      (((stan::math::bernoulli_lpmf<false>(1,
                           stan::math::prod(
                             stan::model::rvalue(lcm_sym221__,
                               "lcm_sym221__",
                               stan::model::index_min_max(1,
                                 (inline_jolly_seber_lp_t_sym34__ - 1))))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        gamma[(inline_jolly_seber_lp_t_sym34__ - 1)])) +
                      stan::math::bernoulli_lpmf<false>(0,
                        stan::model::rvalue(lcm_sym269__, "lcm_sym269__",
                          stan::model::index_uni(
                            inline_jolly_seber_lp_i_sym35__),
                          stan::model::index_uni(
                            inline_jolly_seber_lp_t_sym34__)))) +
                      stan::math::bernoulli_lpmf<false>(1,
                        stan::model::rvalue(
                          inline_prob_uncaptured_return_sym20__,
                          "inline_prob_uncaptured_return_sym20__",
                          stan::model::index_uni(
                            inline_jolly_seber_lp_i_sym35__),
                          stan::model::index_uni(
                            inline_jolly_seber_lp_t_sym34__)))),
                      "assigning variable inline_jolly_seber_lp_lp_sym33__",
                      stan::model::index_uni(inline_jolly_seber_lp_t_sym34__));
                  }
                }
                current_statement__ = 89;
                stan::model::assign(inline_jolly_seber_lp_lp_sym33__,
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(lcm_sym221__)),
                  "assigning variable inline_jolly_seber_lp_lp_sym33__",
                  stan::model::index_uni(lcm_sym246__));
                current_statement__ = 90;
                lp_accum__.add(stan::math::log_sum_exp(
                                 inline_jolly_seber_lp_lp_sym33__));
              }
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "inlining_fail2_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym207__;
      int lcm_sym206__;
      int lcm_sym205__;
      int lcm_sym204__;
      int lcm_sym203__;
      int lcm_sym202__;
      int lcm_sym201__;
      double lcm_sym172__;
      int lcm_sym199__;
      int lcm_sym198__;
      int lcm_sym197__;
      int lcm_sym196__;
      int lcm_sym195__;
      int lcm_sym194__;
      double lcm_sym193__;
      int lcm_sym192__;
      double lcm_sym191__;
      int lcm_sym190__;
      int lcm_sym189__;
      int lcm_sym188__;
      int lcm_sym187__;
      Eigen::Matrix<double,-1,-1> lcm_sym186__;
      std::vector<std::vector<int>> lcm_sym185__;
      double lcm_sym184__;
      double lcm_sym183__;
      double lcm_sym182__;
      double lcm_sym181__;
      double lcm_sym180__;
      double lcm_sym179__;
      double lcm_sym178__;
      double lcm_sym177__;
      double lcm_sym176__;
      double lcm_sym175__;
      Eigen::Matrix<double,-1,1> lcm_sym174__;
      int lcm_sym173__;
      int lcm_sym167__;
      int lcm_sym166__;
      int lcm_sym165__;
      int lcm_sym164__;
      double lcm_sym163__;
      double lcm_sym162__;
      double lcm_sym161__;
      int lcm_sym160__;
      int lcm_sym159__;
      double lcm_sym158__;
      int lcm_sym157__;
      int lcm_sym156__;
      int lcm_sym155__;
      int lcm_sym154__;
      int lcm_sym153__;
      int lcm_sym152__;
      int lcm_sym200__;
      int lcm_sym150__;
      int lcm_sym149__;
      int lcm_sym148__;
      int lcm_sym147__;
      int lcm_sym146__;
      int lcm_sym145__;
      int lcm_sym144__;
      int lcm_sym143__;
      Eigen::Matrix<double,-1,1> lcm_sym142__;
      double mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      double mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<double,-1,1> gamma;
      current_statement__ = 3;
      gamma = in__.template read_constrain_lub<
                Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, 1, lp__,
                n_occasions);
      Eigen::Matrix<double,-1,1> epsilon =
        Eigen::Matrix<double,-1,1>::Constant((n_occasions - 1),
          std::numeric_limits<double>::quiet_NaN());
      lcm_sym200__ = (n_occasions - 1);
      epsilon = in__.template read<
                  Eigen::Matrix<local_scalar_t__,-1,1>>(lcm_sym200__);
      double sigma;
      current_statement__ = 5;
      sigma = in__.template read_constrain_lub<local_scalar_t__,
                jacobian__>(0, 5, lp__);
      Eigen::Matrix<double,-1,-1> phi =
        Eigen::Matrix<double,-1,-1>::Constant(M, lcm_sym200__,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> p =
        Eigen::Matrix<double,-1,-1>::Constant(M, n_occasions,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> chi =
        Eigen::Matrix<double,-1,-1>::Constant(M, n_occasions,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(mean_phi);
      out__.write(mean_p);
      out__.write(gamma);
      out__.write(epsilon);
      out__.write(sigma);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 18;
      if (stan::math::logical_gte(lcm_sym200__, 1)) {
        lcm_sym143__ = stan::math::logical_gte(M, 1);
        if (lcm_sym143__) {
          lcm_sym184__ = stan::math::inv_logit((stan::math::logit(mean_phi) +
                           stan::model::rvalue(epsilon, "epsilon",
                             stan::model::index_uni(1))));
          stan::model::assign(phi, lcm_sym184__, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int i = 2; i <= M; ++i) {
            current_statement__ = 16;
            stan::model::assign(phi, lcm_sym184__, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
          }
        }
        for (int t = 2; t <= lcm_sym200__; ++t) {
          current_statement__ = 17;
          if (lcm_sym143__) {
            lcm_sym183__ = stan::math::inv_logit((stan::math::logit(mean_phi)
                             +
                             stan::model::rvalue(epsilon, "epsilon",
                               stan::model::index_uni(t))));
            stan::model::assign(phi, lcm_sym183__, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            for (int i = 2; i <= M; ++i) {
              current_statement__ = 16;
              stan::model::assign(phi, lcm_sym183__,
                "assigning variable phi", stan::model::index_uni(i),
                stan::model::index_uni(t));
            }
          }
        }
      } else {
        lcm_sym143__ = stan::math::logical_gte(M, 1);
      }
      stan::model::assign(lcm_sym186__,
        stan::math::rep_matrix(mean_p, M, n_occasions),
        "assigning variable lcm_sym186__");
      stan::model::assign(p, lcm_sym186__, "assigning variable p");
      Eigen::Matrix<double,-1,-1> inline_prob_uncaptured_return_sym1__;
      {
        int inline_prob_uncaptured_n_ind_sym2__ =
          std::numeric_limits<int>::min();
        lcm_sym188__ = stan::math::rows(lcm_sym186__);
        int inline_prob_uncaptured_n_occasions_sym3__ =
          std::numeric_limits<int>::min();
        lcm_sym173__ = stan::math::cols(lcm_sym186__);
        current_statement__ = 21;
        stan::math::validate_non_negative_index("chi", "n_ind", lcm_sym188__);
        current_statement__ = 22;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          lcm_sym173__);
        Eigen::Matrix<double,-1,-1> inline_prob_uncaptured_chi_sym4__ =
          Eigen::Matrix<double,-1,-1>::Constant(lcm_sym188__, lcm_sym173__,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 31;
        if (stan::math::logical_gte(lcm_sym188__, 1)) {
          current_statement__ = 24;
          stan::model::assign(inline_prob_uncaptured_chi_sym4__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym4__",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym173__));
          lcm_sym155__ = (lcm_sym173__ - 1);
          lcm_sym147__ = stan::math::logical_gte(lcm_sym155__, 1);
          if (lcm_sym147__) {
            int inline_prob_uncaptured_t_curr_sym5__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym6__ =
              std::numeric_limits<int>::min();
            lcm_sym160__ = (lcm_sym155__ + 1);
            current_statement__ = 27;
            stan::model::assign(inline_prob_uncaptured_chi_sym4__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym155__)) * (1 -
                stan::model::rvalue(lcm_sym186__, "lcm_sym186__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym160__)))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym4__,
                  "inline_prob_uncaptured_chi_sym4__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym160__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym155__)))),
              "assigning variable inline_prob_uncaptured_chi_sym4__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym155__));
            for (int inline_prob_uncaptured_t_sym7__ = 2; inline_prob_uncaptured_t_sym7__
                 <= lcm_sym155__; ++inline_prob_uncaptured_t_sym7__) {
              int inline_prob_uncaptured_t_curr_sym5__ =
                std::numeric_limits<int>::min();
              lcm_sym154__ = (lcm_sym173__ -
                inline_prob_uncaptured_t_sym7__);
              int inline_prob_uncaptured_t_next_sym6__ =
                std::numeric_limits<int>::min();
              lcm_sym159__ = (lcm_sym154__ + 1);
              current_statement__ = 27;
              stan::model::assign(inline_prob_uncaptured_chi_sym4__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym154__)) * (1 -
                  stan::model::rvalue(lcm_sym186__, "lcm_sym186__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym159__)))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym4__,
                    "inline_prob_uncaptured_chi_sym4__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym159__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym154__)))),
                "assigning variable inline_prob_uncaptured_chi_sym4__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym154__));
            }
          }
          for (int inline_prob_uncaptured_i_sym8__ = 2; inline_prob_uncaptured_i_sym8__
               <= lcm_sym188__; ++inline_prob_uncaptured_i_sym8__) {
            current_statement__ = 24;
            stan::model::assign(inline_prob_uncaptured_chi_sym4__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym4__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
              stan::model::index_uni(lcm_sym173__));
            current_statement__ = 29;
            if (lcm_sym147__) {
              int inline_prob_uncaptured_t_curr_sym5__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym6__ =
                std::numeric_limits<int>::min();
              lcm_sym160__ = (lcm_sym155__ + 1);
              current_statement__ = 27;
              stan::model::assign(inline_prob_uncaptured_chi_sym4__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                     stan::model::index_uni(lcm_sym155__)) * (1 -
                  stan::model::rvalue(lcm_sym186__, "lcm_sym186__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                    stan::model::index_uni(lcm_sym160__)))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym4__,
                    "inline_prob_uncaptured_chi_sym4__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                    stan::model::index_uni(lcm_sym160__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                    stan::model::index_uni(lcm_sym155__)))),
                "assigning variable inline_prob_uncaptured_chi_sym4__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                stan::model::index_uni(lcm_sym155__));
              for (int inline_prob_uncaptured_t_sym7__ = 2; inline_prob_uncaptured_t_sym7__
                   <= lcm_sym155__; ++inline_prob_uncaptured_t_sym7__) {
                int inline_prob_uncaptured_t_curr_sym5__ =
                  std::numeric_limits<int>::min();
                lcm_sym154__ = (lcm_sym173__ -
                  inline_prob_uncaptured_t_sym7__);
                int inline_prob_uncaptured_t_next_sym6__ =
                  std::numeric_limits<int>::min();
                lcm_sym159__ = (lcm_sym154__ + 1);
                current_statement__ = 27;
                stan::model::assign(inline_prob_uncaptured_chi_sym4__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                       stan::model::index_uni(lcm_sym154__)) * (1 -
                    stan::model::rvalue(lcm_sym186__, "lcm_sym186__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                      stan::model::index_uni(lcm_sym159__)))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym4__,
                      "inline_prob_uncaptured_chi_sym4__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                      stan::model::index_uni(lcm_sym159__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                      stan::model::index_uni(lcm_sym154__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym4__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym8__),
                  stan::model::index_uni(lcm_sym154__));
              }
            }
          }
        }
        current_statement__ = 32;
        stan::model::assign(inline_prob_uncaptured_return_sym1__,
          inline_prob_uncaptured_chi_sym4__,
          "assigning variable inline_prob_uncaptured_return_sym1__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym1__,
        "assigning variable chi");
      current_statement__ = 6;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 6;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "p", lcm_sym186__, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "p", lcm_sym186__, 1);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym1__, 0);
      current_statement__ = 8;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym1__, 1);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(lcm_sym186__);
        out__.write(inline_prob_uncaptured_return_sym1__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      double sigma2 = std::numeric_limits<double>::quiet_NaN();
      double psi = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double,-1,1> b =
        Eigen::Matrix<double,-1,1>::Constant(n_occasions,
          std::numeric_limits<double>::quiet_NaN());
      int Nsuper = std::numeric_limits<int>::min();
      std::vector<int> N =
        std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      std::vector<int> B =
        std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      std::vector<std::vector<int>> z =
        std::vector<std::vector<int>>(M,
          std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      current_statement__ = 41;
      if (lcm_sym143__) {
        int q = std::numeric_limits<int>::min();
        double mu2 = std::numeric_limits<double>::quiet_NaN();
        lcm_sym172__ = stan::model::rvalue(gamma, "gamma",
                         stan::model::index_uni(1));
        stan::model::assign(z,
          stan::math::bernoulli_rng(lcm_sym172__, base_rng__),
          "assigning variable z", stan::model::index_uni(1),
          stan::model::index_uni(1));
        lcm_sym145__ = stan::math::logical_gte(n_occasions, 2);
        if (lcm_sym145__) {
          lcm_sym204__ = stan::model::rvalue(z, "z",
                           stan::model::index_uni(1),
                           stan::model::index_uni(1));
          lcm_sym167__ = (1 * (1 - lcm_sym204__));
          q = lcm_sym167__;
          lcm_sym181__ = stan::math::fma(
                           stan::model::rvalue(phi, "phi",
                             stan::model::index_uni(1),
                             stan::model::index_uni(1)), lcm_sym204__,
                           (stan::model::rvalue(gamma, "gamma",
                              stan::model::index_uni(2)) * lcm_sym167__));
          current_statement__ = 35;
          stan::model::assign(z,
            stan::math::bernoulli_rng(lcm_sym181__, base_rng__),
            "assigning variable z", stan::model::index_uni(1),
            stan::model::index_uni(2));
          for (int t = 3; t <= n_occasions; ++t) {
            current_statement__ = 36;
            q = (q * (1 -
              stan::model::rvalue(z, "z", stan::model::index_uni(1),
                stan::model::index_uni((t - 1)))));
            lcm_sym182__ = stan::math::fma(
                             stan::model::rvalue(phi, "phi",
                               stan::model::index_uni(1),
                               stan::model::index_uni((t - 1))),
                             stan::model::rvalue(z, "z",
                               stan::model::index_uni(1),
                               stan::model::index_uni((t - 1))),
                             (stan::model::rvalue(gamma, "gamma",
                                stan::model::index_uni(t)) * q));
            current_statement__ = 35;
            stan::model::assign(z,
              stan::math::bernoulli_rng(lcm_sym182__, base_rng__),
              "assigning variable z", stan::model::index_uni(1),
              stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= M; ++i) {
          int q = std::numeric_limits<int>::min();
          double mu2 = std::numeric_limits<double>::quiet_NaN();
          current_statement__ = 38;
          stan::model::assign(z,
            stan::math::bernoulli_rng(lcm_sym172__, base_rng__),
            "assigning variable z", stan::model::index_uni(i),
            stan::model::index_uni(1));
          current_statement__ = 39;
          if (lcm_sym145__) {
            lcm_sym166__ = (1 * (1 -
              stan::model::rvalue(z, "z", stan::model::index_uni(i),
                stan::model::index_uni(1))));
            q = lcm_sym166__;
            lcm_sym179__ = stan::math::fma(
                             stan::model::rvalue(phi, "phi",
                               stan::model::index_uni(i),
                               stan::model::index_uni(1)),
                             stan::model::rvalue(z, "z",
                               stan::model::index_uni(i),
                               stan::model::index_uni(1)),
                             (stan::model::rvalue(gamma, "gamma",
                                stan::model::index_uni(2)) * lcm_sym166__));
            current_statement__ = 35;
            stan::model::assign(z,
              stan::math::bernoulli_rng(lcm_sym179__, base_rng__),
              "assigning variable z", stan::model::index_uni(i),
              stan::model::index_uni(2));
            for (int t = 3; t <= n_occasions; ++t) {
              current_statement__ = 36;
              q = (q * (1 -
                stan::model::rvalue(z, "z", stan::model::index_uni(i),
                  stan::model::index_uni((t - 1)))));
              lcm_sym180__ = stan::math::fma(
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni((t - 1))),
                               stan::model::rvalue(z, "z",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni((t - 1))),
                               (stan::model::rvalue(gamma, "gamma",
                                  stan::model::index_uni(t)) * q));
              current_statement__ = 35;
              stan::model::assign(z,
                stan::math::bernoulli_rng(lcm_sym180__, base_rng__),
                "assigning variable z", stan::model::index_uni(i),
                stan::model::index_uni(t));
            }
          }
        }
      }
      {
        current_statement__ = 42;
        stan::math::validate_non_negative_index("cprob", "n_occasions",
          n_occasions);
        Eigen::Matrix<double,-1,1> cprob =
          Eigen::Matrix<double,-1,1>::Constant(n_occasions,
            std::numeric_limits<double>::quiet_NaN());
        Eigen::Matrix<double,-1,1> inline_seq_cprob_return_sym10__;
        {
          int inline_seq_cprob_N_sym11__ = std::numeric_limits<int>::min();
          lcm_sym187__ = stan::math::rows(gamma);
          current_statement__ = 45;
          stan::math::validate_non_negative_index("log_cprob", "N",
            lcm_sym187__);
          Eigen::Matrix<double,-1,1> inline_seq_cprob_log_cprob_sym12__ =
            Eigen::Matrix<double,-1,1>::Constant(lcm_sym187__,
              std::numeric_limits<double>::quiet_NaN());
          double inline_seq_cprob_log_residual_prob_sym13__ =
            std::numeric_limits<double>::quiet_NaN();
          current_statement__ = 51;
          if (stan::math::logical_gte(lcm_sym187__, 1)) {
            lcm_sym172__ = stan::model::rvalue(gamma, "gamma",
                             stan::model::index_uni(1));
            stan::model::assign(inline_seq_cprob_log_cprob_sym12__,
              (stan::math::log(lcm_sym172__) + 0),
              "assigning variable inline_seq_cprob_log_cprob_sym12__",
              stan::model::index_uni(1));
            current_statement__ = 48;
            inline_seq_cprob_log_residual_prob_sym13__ = (0 +
              stan::math::log1m(lcm_sym172__));
            for (int inline_seq_cprob_n_sym14__ = 2; inline_seq_cprob_n_sym14__
                 <= lcm_sym187__; ++inline_seq_cprob_n_sym14__) {
              current_statement__ = 49;
              stan::model::assign(inline_seq_cprob_log_cprob_sym12__,
                (stan::math::log(gamma[(inline_seq_cprob_n_sym14__ - 1)]) +
                inline_seq_cprob_log_residual_prob_sym13__),
                "assigning variable inline_seq_cprob_log_cprob_sym12__",
                stan::model::index_uni(inline_seq_cprob_n_sym14__));
              current_statement__ = 48;
              inline_seq_cprob_log_residual_prob_sym13__ = (inline_seq_cprob_log_residual_prob_sym13__
                +
                stan::math::log1m(gamma[(inline_seq_cprob_n_sym14__ - 1)]));
            }
          }
          current_statement__ = 52;
          stan::model::assign(inline_seq_cprob_return_sym10__,
            stan::math::exp(inline_seq_cprob_log_cprob_sym12__),
            "assigning variable inline_seq_cprob_return_sym10__");
        }
        current_statement__ = 53;
        stan::math::validate_non_negative_index("recruit", "M", M);
        current_statement__ = 54;
        stan::math::validate_non_negative_index("recruit", "n_occasions",
          n_occasions);
        std::vector<std::vector<int>> recruit =
          std::vector<std::vector<int>>(M,
            std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
        current_statement__ = 55;
        stan::model::assign(recruit,
          stan::math::rep_array(0, M, n_occasions),
          "assigning variable recruit");
        current_statement__ = 56;
        stan::math::validate_non_negative_index("Nind", "M", M);
        std::vector<int> Nind =
          std::vector<int>(M, std::numeric_limits<int>::min());
        current_statement__ = 58;
        stan::math::validate_non_negative_index("Nalive", "M", M);
        std::vector<int> Nalive =
          std::vector<int>(M, std::numeric_limits<int>::min());
        lcm_sym191__ = stan::math::square(sigma);
        sigma2 = lcm_sym191__;
        lcm_sym193__ = stan::math::sum(inline_seq_cprob_return_sym10__);
        psi = lcm_sym193__;
        current_statement__ = 60;
        stan::model::assign(b,
          stan::math::divide(inline_seq_cprob_return_sym10__, lcm_sym193__),
          "assigning variable b");
        current_statement__ = 68;
        if (lcm_sym143__) {
          int f = std::numeric_limits<int>::min();
          int inline_first_capture_return_sym16__;
          int inline_first_capture_early_ret_check_sym18__;
          inline_first_capture_early_ret_check_sym18__ = 0;
          for (int inline_first_capture_iterator_sym19__ = 1; inline_first_capture_iterator_sym19__
               <= 1; ++inline_first_capture_iterator_sym19__) {
            lcm_sym190__ = stan::math::size(
                             stan::model::rvalue(z, "z",
                               stan::model::index_uni(1)));
            for (int inline_first_capture_k_sym17__ = 1; inline_first_capture_k_sym17__
                 <= lcm_sym190__; ++inline_first_capture_k_sym17__) {
              current_statement__ = 63;
              if (stan::model::rvalue(z, "z", stan::model::index_uni(1),
                    stan::model::index_uni(inline_first_capture_k_sym17__))) {
                inline_first_capture_early_ret_check_sym18__ = 1;
                inline_first_capture_return_sym16__ = inline_first_capture_k_sym17__;
                break;
              }
            }
            if (inline_first_capture_early_ret_check_sym18__) {
              break;
            }
            inline_first_capture_early_ret_check_sym18__ = 1;
            inline_first_capture_return_sym16__ = 0;
            break;
          }
          current_statement__ = 66;
          if (stan::math::logical_gt(inline_first_capture_return_sym16__, 0)) {
            current_statement__ = 65;
            stan::model::assign(recruit, 1, "assigning variable recruit",
              stan::model::index_uni(1),
              stan::model::index_uni(inline_first_capture_return_sym16__));
          }
          for (int i = 2; i <= M; ++i) {
            int f = std::numeric_limits<int>::min();
            int inline_first_capture_return_sym16__;
            int inline_first_capture_early_ret_check_sym18__;
            inline_first_capture_early_ret_check_sym18__ = 0;
            for (int inline_first_capture_iterator_sym19__ = 1; inline_first_capture_iterator_sym19__
                 <= 1; ++inline_first_capture_iterator_sym19__) {
              lcm_sym189__ = stan::math::size(
                               stan::model::rvalue(z, "z",
                                 stan::model::index_uni(i)));
              for (int inline_first_capture_k_sym17__ = 1; inline_first_capture_k_sym17__
                   <= lcm_sym189__; ++inline_first_capture_k_sym17__) {
                current_statement__ = 63;
                if (stan::model::rvalue(z, "z", stan::model::index_uni(i),
                      stan::model::index_uni(inline_first_capture_k_sym17__))) {
                  inline_first_capture_early_ret_check_sym18__ = 1;
                  inline_first_capture_return_sym16__ = inline_first_capture_k_sym17__;
                  break;
                }
              }
              if (inline_first_capture_early_ret_check_sym18__) {
                break;
              }
              inline_first_capture_early_ret_check_sym18__ = 1;
              inline_first_capture_return_sym16__ = 0;
              break;
            }
            current_statement__ = 66;
            if (stan::math::logical_gt(inline_first_capture_return_sym16__, 0)) {
              current_statement__ = 65;
              stan::model::assign(recruit, 1, "assigning variable recruit",
                stan::model::index_uni(i),
                stan::model::index_uni(inline_first_capture_return_sym16__));
            }
          }
        }
        lcm_sym144__ = stan::math::logical_gte(n_occasions, 1);
        if (lcm_sym144__) {
          current_statement__ = 69;
          stan::model::assign(N,
            stan::math::sum(
              stan::model::rvalue(z, "z", stan::model::index_omni(),
                stan::model::index_uni(1))), "assigning variable N",
            stan::model::index_uni(1));
          current_statement__ = 70;
          stan::model::assign(B,
            stan::math::sum(
              stan::model::rvalue(recruit, "recruit",
                stan::model::index_omni(), stan::model::index_uni(1))),
            "assigning variable B", stan::model::index_uni(1));
          for (int t = 2; t <= n_occasions; ++t) {
            current_statement__ = 69;
            stan::model::assign(N,
              stan::math::sum(
                stan::model::rvalue(z, "z", stan::model::index_omni(),
                  stan::model::index_uni(t))), "assigning variable N",
              stan::model::index_uni(t));
            current_statement__ = 70;
            stan::model::assign(B,
              stan::math::sum(
                stan::model::rvalue(recruit, "recruit",
                  stan::model::index_omni(), stan::model::index_uni(t))),
              "assigning variable B", stan::model::index_uni(t));
          }
        }
        current_statement__ = 75;
        if (lcm_sym143__) {
          current_statement__ = 72;
          stan::model::assign(Nind,
            stan::math::sum(
              stan::model::rvalue(z, "z", stan::model::index_uni(1))),
            "assigning variable Nind", stan::model::index_uni(1));
          current_statement__ = 73;
          stan::model::assign(Nalive, (1 -
            stan::math::logical_negation(
              stan::model::rvalue(Nind, "Nind", stan::model::index_uni(1)))),
            "assigning variable Nalive", stan::model::index_uni(1));
          for (int i = 2; i <= M; ++i) {
            current_statement__ = 72;
            stan::model::assign(Nind,
              stan::math::sum(
                stan::model::rvalue(z, "z", stan::model::index_uni(i))),
              "assigning variable Nind", stan::model::index_uni(i));
            current_statement__ = 73;
            stan::model::assign(Nalive, (1 -
              stan::math::logical_negation(
                stan::model::rvalue(Nind, "Nind", stan::model::index_uni(i)))),
              "assigning variable Nalive", stan::model::index_uni(i));
          }
        }
        current_statement__ = 76;
        Nsuper = stan::math::sum(Nalive);
      }
      out__.write(lcm_sym191__);
      out__.write(psi);
      out__.write(b);
      out__.write(Nsuper);
      out__.write(N);
      out__.write(B);
      current_statement__ = 15;
      if (lcm_sym144__) {
        if (lcm_sym143__) {
          out__.write(stan::model::rvalue(z, "z", stan::model::index_uni(1),
                        stan::model::index_uni(1)));
          for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
            out__.write(stan::model::rvalue(z, "z",
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(1)));
          }
        }
        for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym143__) {
            out__.write(stan::model::rvalue(z, "z",
                          stan::model::index_uni(1),
                          stan::model::index_uni(sym1__)));
            for (int sym2__ = 2; sym2__ <= M; ++sym2__) {
              out__.write(z[(sym2__ - 1)][(sym1__ - 1)]);
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__,-1,1> gamma;
      current_statement__ = 3;
      stan::model::assign(gamma,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_occasions),
        "assigning variable gamma");
      out__.write_free_lub(0, 1, gamma);
      Eigen::Matrix<local_scalar_t__,-1,1> epsilon;
      current_statement__ = 4;
      stan::model::assign(epsilon,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(epsilon_1dim__),
        "assigning variable epsilon");
      out__.write(epsilon);
      local_scalar_t__ sigma;
      current_statement__ = 5;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 5, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mean_phi",
        "double", std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "mean_p", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "gamma", "double",
        std::vector<size_t>{static_cast<size_t>(n_occasions)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "epsilon",
        "double", std::vector<size_t>{static_cast<size_t>(epsilon_1dim__)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "sigma", "double",
        std::vector<size_t>{});
      double lcm_sym141__;
      double lcm_sym140__;
      double lcm_sym139__;
      double lcm_sym138__;
      int lcm_sym137__;
      int lcm_sym136__;
      int lcm_sym135__;
      int lcm_sym134__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = context__.vals_r("mean_phi")[(1 - 1)];
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__,-1,1> gamma =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_occasions,
          DUMMY_VAR__);
      {
        std::vector<double> gamma_flat__;
        current_statement__ = 3;
        gamma_flat__ = context__.vals_r("gamma");
        pos__ = 1;
        if (stan::math::logical_gte(n_occasions, 1)) {
          stan::model::assign(gamma,
            stan::model::rvalue(gamma_flat__, "gamma_flat__",
              stan::model::index_uni(1)), "assigning variable gamma",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
            stan::model::assign(gamma, gamma_flat__[(pos__ - 1)],
              "assigning variable gamma", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_lub(0, 1, gamma);
      Eigen::Matrix<local_scalar_t__,-1,1> epsilon =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant((n_occasions - 1),
          DUMMY_VAR__);
      {
        std::vector<double> epsilon_flat__;
        current_statement__ = 4;
        epsilon_flat__ = context__.vals_r("epsilon");
        pos__ = 1;
        lcm_sym136__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym136__, 1)) {
          stan::model::assign(epsilon,
            stan::model::rvalue(epsilon_flat__, "epsilon_flat__",
              stan::model::index_uni(1)), "assigning variable epsilon",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= lcm_sym136__; ++sym1__) {
            stan::model::assign(epsilon, epsilon_flat__[(pos__ - 1)],
              "assigning variable epsilon", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(epsilon);
      local_scalar_t__ sigma;
      current_statement__ = 5;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      out__.write_free_lub(0, 5, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mean_phi", "mean_p", "gamma",
                "epsilon", "sigma"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"phi", "p", "chi"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string>
        temp{"sigma2", "psi", "b", "Nsuper", "N", "B", "z"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(n_occasions)},
                std::vector<size_t>{static_cast<size_t>(epsilon_1dim__)},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(M),
               static_cast<size_t>(phi_2dim__)},
             std::vector<size_t>{static_cast<size_t>(M),
               static_cast<size_t>(n_occasions)},
             std::vector<size_t>{static_cast<size_t>(M),
               static_cast<size_t>(n_occasions)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(n_occasions)},
             std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(n_occasions)},
             std::vector<size_t>{static_cast<size_t>(n_occasions)},
             std::vector<size_t>{static_cast<size_t>(M),
               static_cast<size_t>(n_occasions)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
      param_names__.emplace_back(std::string() + "gamma" + '.' +
        std::to_string(sym358__));
    }
    for (int sym358__ = 1; sym358__ <= epsilon_1dim__; ++sym358__) {
      param_names__.emplace_back(std::string() + "epsilon" + '.' +
        std::to_string(sym358__));
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym358__ = 1; sym358__ <= phi_2dim__; ++sym358__) {
        for (int sym359__ = 1; sym359__ <= M; ++sym359__) {
          param_names__.emplace_back(std::string() + "phi" + '.' +
            std::to_string(sym359__) + '.' + std::to_string(sym358__));
        }
      }
      for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
        for (int sym359__ = 1; sym359__ <= M; ++sym359__) {
          param_names__.emplace_back(std::string() + "p" + '.' +
            std::to_string(sym359__) + '.' + std::to_string(sym358__));
        }
      }
      for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
        for (int sym359__ = 1; sym359__ <= M; ++sym359__) {
          param_names__.emplace_back(std::string() + "chi" + '.' +
            std::to_string(sym359__) + '.' + std::to_string(sym358__));
        }
      }
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "psi");
      for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
        param_names__.emplace_back(std::string() + "b" + '.' +
          std::to_string(sym358__));
      }
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
        param_names__.emplace_back(std::string() + "N" + '.' +
          std::to_string(sym358__));
      }
      for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
        param_names__.emplace_back(std::string() + "B" + '.' +
          std::to_string(sym358__));
      }
      for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
        for (int sym359__ = 1; sym359__ <= M; ++sym359__) {
          param_names__.emplace_back(std::string() + "z" + '.' +
            std::to_string(sym359__) + '.' + std::to_string(sym358__));
        }
      }
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
      param_names__.emplace_back(std::string() + "gamma" + '.' +
        std::to_string(sym358__));
    }
    for (int sym358__ = 1; sym358__ <= epsilon_1dim__; ++sym358__) {
      param_names__.emplace_back(std::string() + "epsilon" + '.' +
        std::to_string(sym358__));
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym358__ = 1; sym358__ <= phi_2dim__; ++sym358__) {
        for (int sym359__ = 1; sym359__ <= M; ++sym359__) {
          param_names__.emplace_back(std::string() + "phi" + '.' +
            std::to_string(sym359__) + '.' + std::to_string(sym358__));
        }
      }
      for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
        for (int sym359__ = 1; sym359__ <= M; ++sym359__) {
          param_names__.emplace_back(std::string() + "p" + '.' +
            std::to_string(sym359__) + '.' + std::to_string(sym358__));
        }
      }
      for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
        for (int sym359__ = 1; sym359__ <= M; ++sym359__) {
          param_names__.emplace_back(std::string() + "chi" + '.' +
            std::to_string(sym359__) + '.' + std::to_string(sym358__));
        }
      }
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "psi");
      for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
        param_names__.emplace_back(std::string() + "b" + '.' +
          std::to_string(sym358__));
      }
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
        param_names__.emplace_back(std::string() + "N" + '.' +
          std::to_string(sym358__));
      }
      for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
        param_names__.emplace_back(std::string() + "B" + '.' +
          std::to_string(sym358__));
      }
      for (int sym358__ = 1; sym358__ <= n_occasions; ++sym358__) {
        for (int sym359__ = 1; sym359__ <= M; ++sym359__) {
          param_names__.emplace_back(std::string() + "z" + '.' +
            std::to_string(sym359__) + '.' + std::to_string(sym358__));
        }
      }
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(epsilon_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(phi_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(epsilon_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(phi_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((1 + 1) + n_occasions) + epsilon_1dim__) +
      1);
    const size_t num_transformed = emit_transformed_parameters * ((((M *
      phi_2dim__) + (M * n_occasions)) + (M * n_occasions)));
    const size_t num_gen_quantities = emit_generated_quantities * (((((((1 +
      1) + n_occasions) + 1) + n_occasions) + n_occasions) + (M *
      n_occasions)));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((1 + 1) + n_occasions) + epsilon_1dim__) +
      1);
    const size_t num_transformed = emit_transformed_parameters * ((((M *
      phi_2dim__) + (M * n_occasions)) + (M * n_occasions)));
    const size_t num_gen_quantities = emit_generated_quantities * (((((((1 +
      1) + n_occasions) + 1) + n_occasions) + n_occasions) + (M *
      n_occasions)));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = inlining_fail2_model_namespace::inlining_fail2_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return inlining_fail2_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp lcm-experiment.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_experiment_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 7> locations_array__ =
  {" (found before start of program)",
  " (in 'lcm-experiment.stan', line 2, column 2 to column 8)",
  " (in 'lcm-experiment.stan', line 5, column 2 to column 13)",
  " (in 'lcm-experiment.stan', line 6, column 2 to column 9)",
  " (in 'lcm-experiment.stan', line 8, column 4 to column 27)",
  " (in 'lcm-experiment.stan', line 7, column 2 to line 10, column 3)",
  " (in 'lcm-experiment.stan', line 11, column 2 to column 38)"};
class lcm_experiment_model final : public model_base_crtp<lcm_experiment_model> {
 private:
  double lcm_sym4__;
  double lcm_sym3__;
  int j;
  double z;
  double x;
  double i;
 public:
  ~lcm_experiment_model() {}
  lcm_experiment_model(stan::io::var_context& context__, unsigned int
                       random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "lcm_experiment_model_namespace::lcm_experiment_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("data initialization", "j", "int",
        std::vector<size_t>{});
      j = std::numeric_limits<int>::min();
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      current_statement__ = 2;
      z = std::numeric_limits<double>::quiet_NaN();
      lcm_sym4__ = 1;
      z = 1;
      current_statement__ = 3;
      x = std::numeric_limits<double>::quiet_NaN();
      {
        current_statement__ = 4;
        x = stan::math::normal_rng(123, 1, base_rng__);
        lcm_sym3__ = stan::math::fma(stan::math::sqrt(j), 2, 1);
        z = stan::math::normal_rng(lcm_sym3__, 1, base_rng__);
      }
      current_statement__ = 6;
      i = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 6;
      i = stan::math::normal_rng(lcm_sym3__, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "lcm_experiment_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "lcm_experiment_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "lcm_experiment_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "lcm_experiment_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = lcm_experiment_model_namespace::lcm_experiment_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return lcm_experiment_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp lcm-experiment2.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_experiment2_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 8> locations_array__ =
  {" (found before start of program)",
  " (in 'lcm-experiment2.stan', line 2, column 2 to column 9)",
  " (in 'lcm-experiment2.stan', line 5, column 2 to column 18)",
  " (in 'lcm-experiment2.stan', line 7, column 4 to column 11)",
  " (in 'lcm-experiment2.stan', line 6, column 2 to line 8, column 3)",
  " (in 'lcm-experiment2.stan', line 10, column 4 to column 11)",
  " (in 'lcm-experiment2.stan', line 9, column 2 to line 10, column 11)",
  " (in 'lcm-experiment2.stan', line 11, column 2 to column 14)"};
class lcm_experiment2_model final : public model_base_crtp<lcm_experiment2_model> {
 private:
  
 public:
  ~lcm_experiment2_model() {}
  lcm_experiment2_model(stan::io::var_context& context__, unsigned int
                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "lcm_experiment2_model_namespace::lcm_experiment2_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 1;
  }
  inline std::string model_name() const final {
    return "lcm_experiment2_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "lcm_experiment2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ lcm_sym8__;
      double lcm_sym7__;
      double lcm_sym6__;
      local_scalar_t__ x;
      current_statement__ = 1;
      x = in__.template read<local_scalar_t__>();
      {
        local_scalar_t__ y = DUMMY_VAR__;
        lcm_sym8__ = stan::math::log(x);
        {
          current_statement__ = 3;
          y = (lcm_sym8__ + 1);
        }
        {
          current_statement__ = 5;
          y = (y + 1);
        }
        current_statement__ = 7;
        lp_accum__.add(y);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "lcm_experiment2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      local_scalar_t__ x;
      current_statement__ = 1;
      x = in__.template read<local_scalar_t__>();
      {
        local_scalar_t__ y = DUMMY_VAR__;
        lcm_sym5__ = stan::math::log(x);
        {
          current_statement__ = 3;
          y = (lcm_sym5__ + 1);
        }
        {
          current_statement__ = 5;
          y = (y + 1);
        }
        current_statement__ = 7;
        lp_accum__.add(y);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "lcm_experiment2_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      double x;
      current_statement__ = 1;
      x = in__.template read<local_scalar_t__>();
      out__.write(x);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ x;
      current_statement__ = 1;
      x = in__.read<local_scalar_t__>();
      out__.write(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "x", "double",
        std::vector<size_t>{});
      local_scalar_t__ x;
      current_statement__ = 1;
      x = context__.vals_r("x")[(1 - 1)];
      out__.write(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"x"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = lcm_experiment2_model_namespace::lcm_experiment2_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return lcm_experiment2_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp lcm-fails.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_fails_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 7> locations_array__ =
  {" (found before start of program)",
  " (in 'lcm-fails.stan', line 6, column 2 to column 22)",
  " (in 'lcm-fails.stan', line 9, column 2 to column 23)",
  " (in 'lcm-fails.stan', line 2, column 2 to column 17)",
  " (in 'lcm-fails.stan', line 3, column 8 to column 9)",
  " (in 'lcm-fails.stan', line 3, column 2 to column 18)",
  " (in 'lcm-fails.stan', line 6, column 8 to column 9)"};
class lcm_fails_model final : public model_base_crtp<lcm_fails_model> {
 private:
  int J;
  std::vector<double> y;
 public:
  ~lcm_fails_model() {}
  lcm_fails_model(stan::io::var_context& context__, unsigned int
                  random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "lcm_fails_model_namespace::lcm_fails_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 3;
      context__.validate_dims("data initialization", "J", "int",
        std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      current_statement__ = 3;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 4;
      stan::math::validate_non_negative_index("y", "J", J);
      current_statement__ = 5;
      context__.validate_dims("data initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(J)});
      y = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      y = context__.vals_r("y");
      current_statement__ = 6;
      stan::math::validate_non_negative_index("theta", "J", J);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = J;
  }
  inline std::string model_name() const final {
    return "lcm_fails_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "lcm_fails_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym4__;
      std::vector<local_scalar_t__> theta =
        std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      current_statement__ = 1;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      {
        current_statement__ = 2;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, theta, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "lcm_fails_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym3__;
      std::vector<local_scalar_t__> theta =
        std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      current_statement__ = 1;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      {
        current_statement__ = 2;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, theta, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "lcm_fails_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      std::vector<double> theta =
        std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      out__.write(theta);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      std::vector<local_scalar_t__> theta;
      current_statement__ = 1;
      stan::model::assign(theta, in__.read<std::vector<local_scalar_t__>>(J),
        "assigning variable theta");
      out__.write(theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "theta", "double",
        std::vector<size_t>{static_cast<size_t>(J)});
      std::vector<local_scalar_t__> theta =
        std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      current_statement__ = 1;
      theta = context__.vals_r("theta");
      out__.write(theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"theta"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(J)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym5__ = 1; sym5__ <= J; ++sym5__) {
      param_names__.emplace_back(std::string() + "theta" + '.' +
        std::to_string(sym5__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym5__ = 1; sym5__ <= J; ++sym5__) {
      param_names__.emplace_back(std::string() + "theta" + '.' +
        std::to_string(sym5__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = J;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = J;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = lcm_fails_model_namespace::lcm_fails_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return lcm_fails_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp lcm-fails2.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_fails2_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 64> locations_array__ =
  {" (found before start of program)",
  " (in 'lcm-fails2.stan', line 66, column 2 to column 34)",
  " (in 'lcm-fails2.stan', line 67, column 2 to column 32)",
  " (in 'lcm-fails2.stan', line 70, column 2 to column 52)",
  " (in 'lcm-fails2.stan', line 71, column 2 to column 50)",
  " (in 'lcm-fails2.stan', line 72, column 2 to column 50)",
  " (in 'lcm-fails2.stan', line 78, column 6 to column 18)",
  " (in 'lcm-fails2.stan', line 77, column 6 to column 20)",
  " (in 'lcm-fails2.stan', line 76, column 34 to line 79, column 5)",
  " (in 'lcm-fails2.stan', line 81, column 6 to column 27)",
  " (in 'lcm-fails2.stan', line 82, column 6 to column 23)",
  " (in 'lcm-fails2.stan', line 80, column 40 to line 83, column 5)",
  " (in 'lcm-fails2.stan', line 80, column 4 to line 83, column 5)",
  " (in 'lcm-fails2.stan', line 75, column 22 to line 84, column 3)",
  " (in 'lcm-fails2.stan', line 25, column 11 to column 15)",
  " (in 'lcm-fails2.stan', line 25, column 17 to column 28)",
  " (in 'lcm-fails2.stan', line 25, column 4 to column 34)",
  " (in 'lcm-fails2.stan', line 28, column 6 to column 32)",
  " (in 'lcm-fails2.stan', line 31, column 8 to column 37)",
  " (in 'lcm-fails2.stan', line 32, column 8 to column 32)",
  " (in 'lcm-fails2.stan', line 40, column 8 to line 42, column 44)",
  " (in 'lcm-fails2.stan', line 29, column 39 to line 43, column 7)",
  " (in 'lcm-fails2.stan', line 29, column 6 to line 43, column 7)",
  " (in 'lcm-fails2.stan', line 27, column 24 to line 44, column 5)",
  " (in 'lcm-fails2.stan', line 27, column 4 to line 44, column 5)",
  " (in 'lcm-fails2.stan', line 45, column 4 to column 15)",
  " (in 'lcm-fails2.stan', line 98, column 8 to column 37)",
  " (in 'lcm-fails2.stan', line 99, column 8 to column 41)",
  " (in 'lcm-fails2.stan', line 97, column 42 to line 100, column 7)",
  " (in 'lcm-fails2.stan', line 101, column 6 to column 37)",
  " (in 'lcm-fails2.stan', line 96, column 22 to line 102, column 5)",
  " (in 'lcm-fails2.stan', line 95, column 22 to line 103, column 3)",
  " (in 'lcm-fails2.stan', line 95, column 2 to line 103, column 3)",
  " (in 'lcm-fails2.stan', line 49, column 2 to column 20)",
  " (in 'lcm-fails2.stan', line 50, column 2 to column 27)",
  " (in 'lcm-fails2.stan', line 51, column 8 to column 12)",
  " (in 'lcm-fails2.stan', line 51, column 14 to column 25)",
  " (in 'lcm-fails2.stan', line 51, column 2 to column 51)",
  " (in 'lcm-fails2.stan', line 54, column 2 to column 38)",
  " (in 'lcm-fails2.stan', line 56, column 8 to column 12)",
  " (in 'lcm-fails2.stan', line 56, column 2 to column 52)",
  " (in 'lcm-fails2.stan', line 57, column 8 to column 12)",
  " (in 'lcm-fails2.stan', line 57, column 2 to column 51)",
  " (in 'lcm-fails2.stan', line 61, column 4 to column 35)",
  " (in 'lcm-fails2.stan', line 60, column 2 to line 61, column 35)",
  " (in 'lcm-fails2.stan', line 63, column 4 to column 33)",
  " (in 'lcm-fails2.stan', line 62, column 2 to line 63, column 33)",
  " (in 'lcm-fails2.stan', line 70, column 27 to column 31)",
  " (in 'lcm-fails2.stan', line 70, column 33 to column 46)",
  " (in 'lcm-fails2.stan', line 71, column 27 to column 31)",
  " (in 'lcm-fails2.stan', line 71, column 33 to column 46)",
  " (in 'lcm-fails2.stan', line 72, column 27 to column 31)",
  " (in 'lcm-fails2.stan', line 72, column 33 to column 44)",
  " (in 'lcm-fails2.stan', line 8, column 8 to column 17)",
  " (in 'lcm-fails2.stan', line 7, column 6 to line 8, column 17)",
  " (in 'lcm-fails2.stan', line 9, column 4 to column 13)",
  " (in 'lcm-fails2.stan', line 5, column 37 to line 10, column 3)",
  " (in 'lcm-fails2.stan', line 15, column 6 to column 32)",
  " (in 'lcm-fails2.stan', line 19, column 8 to column 17)",
  " (in 'lcm-fails2.stan', line 18, column 6 to line 19, column 17)",
  " (in 'lcm-fails2.stan', line 13, column 39 to line 20, column 5)",
  " (in 'lcm-fails2.stan', line 21, column 4 to column 13)",
  " (in 'lcm-fails2.stan', line 12, column 36 to line 22, column 3)",
  " (in 'lcm-fails2.stan', line 24, column 74 to line 46, column 3)"};
int first_capture(const std::vector<int>& y_i, std::ostream* pstream__);
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__);
template <typename T2__, typename T3__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T2__>,
                stan::base_type_t<T3__>>,-1,-1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__);
int first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym25__;
    int lcm_sym24__;
    int lcm_sym23__;
    int lcm_sym22__;
    {
      lcm_sym23__ = stan::math::size(y_i);
      if (stan::math::logical_gte(lcm_sym23__, 1)) {
        current_statement__ = 54;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(1))) {
          current_statement__ = 53;
          return 1;
        }
        for (int k = 2; k <= lcm_sym23__; ++k) {
          current_statement__ = 54;
          if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
            current_statement__ = 53;
            return k;
          }
        }
      }
      current_statement__ = 55;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym31__;
    int lcm_sym30__;
    int lcm_sym29__;
    int lcm_sym28__;
    int lcm_sym27__;
    int lcm_sym26__;
    {
      lcm_sym29__ = (stan::math::size(y_i) - 1);
      if (stan::math::logical_gte(lcm_sym29__, 0)) {
        int k = std::numeric_limits<int>::min();
        lcm_sym28__ = (stan::math::size(y_i) - 0);
        current_statement__ = 59;
        if (y_i[(lcm_sym28__ - 1)]) {
          current_statement__ = 58;
          return lcm_sym28__;
        }
        for (int k_rev = 1; k_rev <= lcm_sym29__; ++k_rev) {
          int k = std::numeric_limits<int>::min();
          lcm_sym27__ = (stan::math::size(y_i) - k_rev);
          current_statement__ = 59;
          if (y_i[(lcm_sym27__ - 1)]) {
            current_statement__ = 58;
            return lcm_sym27__;
          }
        }
      }
      current_statement__ = 61;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T2__, typename T3__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T2__>,
                stan::base_type_t<T3__>>,-1,-1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T2__>,
                             stan::base_type_t<T3__>>;
  int current_statement__ = 0;
  const auto& p = stan::math::to_ref(p_arg__);
  const auto& phi = stan::math::to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym41__;
    double lcm_sym40__;
    double lcm_sym39__;
    double lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    int lcm_sym35__;
    int lcm_sym34__;
    int lcm_sym33__;
    int lcm_sym32__;
    {
      current_statement__ = 14;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 15;
      stan::math::validate_non_negative_index("chi", "n_occasions",
        n_occasions);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
          DUMMY_VAR__);
      current_statement__ = 24;
      if (stan::math::logical_gte(nind, 1)) {
        current_statement__ = 17;
        stan::model::assign(chi, 1.0, "assigning variable chi",
          stan::model::index_uni(1), stan::model::index_uni(n_occasions));
        lcm_sym35__ = (n_occasions - 1);
        lcm_sym33__ = stan::math::logical_gte(lcm_sym35__, 1);
        if (lcm_sym33__) {
          int t_curr = std::numeric_limits<int>::min();
          int t_next = std::numeric_limits<int>::min();
          lcm_sym37__ = (lcm_sym35__ + 1);
          current_statement__ = 20;
          stan::model::assign(chi,
            stan::math::fma(
              (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                 stan::model::index_uni(lcm_sym35__)) * (1 -
              stan::model::rvalue(p, "p", stan::model::index_uni(1),
                stan::model::index_uni((lcm_sym37__ - 1))))),
              stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym37__)), (1 -
              stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym35__)))),
            "assigning variable chi", stan::model::index_uni(1),
            stan::model::index_uni(lcm_sym35__));
          for (int t = 2; t <= lcm_sym35__; ++t) {
            int t_curr = std::numeric_limits<int>::min();
            lcm_sym34__ = (n_occasions - t);
            int t_next = std::numeric_limits<int>::min();
            lcm_sym36__ = (lcm_sym34__ + 1);
            current_statement__ = 20;
            stan::model::assign(chi,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym34__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym36__ - 1))))),
                stan::model::rvalue(chi, "chi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym36__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym34__)))),
              "assigning variable chi", stan::model::index_uni(1),
              stan::model::index_uni(lcm_sym34__));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 17;
          stan::model::assign(chi, 1.0, "assigning variable chi",
            stan::model::index_uni(i), stan::model::index_uni(n_occasions));
          current_statement__ = 22;
          if (lcm_sym33__) {
            int t_curr = std::numeric_limits<int>::min();
            int t_next = std::numeric_limits<int>::min();
            lcm_sym37__ = (lcm_sym35__ + 1);
            current_statement__ = 20;
            stan::model::assign(chi,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                   stan::model::index_uni(lcm_sym35__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(i),
                  stan::model::index_uni((lcm_sym37__ - 1))))),
                stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym37__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                  stan::model::index_uni(lcm_sym35__)))),
              "assigning variable chi", stan::model::index_uni(i),
              stan::model::index_uni(lcm_sym35__));
            for (int t = 2; t <= lcm_sym35__; ++t) {
              int t_curr = std::numeric_limits<int>::min();
              lcm_sym34__ = (n_occasions - t);
              int t_next = std::numeric_limits<int>::min();
              lcm_sym36__ = (lcm_sym34__ + 1);
              current_statement__ = 20;
              stan::model::assign(chi,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                     stan::model::index_uni(lcm_sym34__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(i),
                    stan::model::index_uni((lcm_sym36__ - 1))))),
                  stan::model::rvalue(chi, "chi", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym36__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(i),
                    stan::model::index_uni(lcm_sym34__)))),
                "assigning variable chi", stan::model::index_uni(i),
                stan::model::index_uni(lcm_sym34__));
            }
          }
        }
      }
      current_statement__ = 25;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class lcm_fails2_model final : public model_base_crtp<lcm_fails2_model> {
 private:
  int lcm_sym152__;
  int lcm_sym151__;
  int lcm_sym150__;
  int lcm_sym149__;
  int lcm_sym148__;
  int lcm_sym147__;
  int lcm_sym146__;
  int lcm_sym145__;
  int lcm_sym144__;
  int lcm_sym143__;
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last;
 public:
  ~lcm_fails2_model() {}
  lcm_fails2_model(stan::io::var_context& context__, unsigned int
                   random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "lcm_fails2_model_namespace::lcm_fails2_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 33;
      context__.validate_dims("data initialization", "nind", "int",
        std::vector<size_t>{});
      nind = std::numeric_limits<int>::min();
      current_statement__ = 33;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 33;
      stan::math::check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 34;
      context__.validate_dims("data initialization", "n_occasions", "int",
        std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      current_statement__ = 34;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 34;
      stan::math::check_greater_or_equal(function__, "n_occasions",
        n_occasions, 2);
      current_statement__ = 35;
      stan::math::validate_non_negative_index("y", "nind", nind);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 37;
      context__.validate_dims("data initialization", "y", "int",
        std::vector<size_t>{static_cast<size_t>(nind),
          static_cast<size_t>(n_occasions)});
      y = std::vector<std::vector<int>>(nind,
            std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      {
        std::vector<int> y_flat__;
        current_statement__ = 37;
        y_flat__ = context__.vals_i("y");
        pos__ = 1;
        if (stan::math::logical_gte(n_occasions, 1)) {
          lcm_sym144__ = stan::math::logical_gte(nind, 1);
          if (lcm_sym144__) {
            stan::model::assign(y,
              stan::model::rvalue(y_flat__, "y_flat__",
                stan::model::index_uni(1)), "assigning variable y",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
            if (lcm_sym144__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= nind; ++sym2__) {
                stan::model::assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        } else {
          lcm_sym144__ = stan::math::logical_gte(nind, 1);
        }
      }
      current_statement__ = 37;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 37;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 38;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      lcm_sym145__ = (n_occasions - 1);
      n_occ_minus_1 = lcm_sym145__;
      current_statement__ = 39;
      stan::math::validate_non_negative_index("first", "nind", nind);
      current_statement__ = 40;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      current_statement__ = 41;
      stan::math::validate_non_negative_index("last", "nind", nind);
      current_statement__ = 42;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      current_statement__ = 44;
      if (lcm_sym144__) {
        current_statement__ = 43;
        stan::model::assign(first,
          first_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(1)), pstream__),
          "assigning variable first", stan::model::index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 43;
          stan::model::assign(first,
            first_capture(
              stan::model::rvalue(y, "y", stan::model::index_uni(i)),
              pstream__), "assigning variable first",
            stan::model::index_uni(i));
        }
      }
      current_statement__ = 46;
      if (lcm_sym144__) {
        current_statement__ = 45;
        stan::model::assign(last,
          last_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(1)), pstream__),
          "assigning variable last", stan::model::index_uni(1));
        for (int i = 2; i <= nind; ++i) {
          current_statement__ = 45;
          stan::model::assign(last,
            last_capture(
              stan::model::rvalue(y, "y", stan::model::index_uni(i)),
              pstream__), "assigning variable last",
            stan::model::index_uni(i));
        }
      }
      current_statement__ = 40;
      stan::math::check_greater_or_equal(function__, "first", first, 0);
      current_statement__ = 40;
      stan::math::check_less_or_equal(function__, "first", first, n_occasions);
      current_statement__ = 42;
      stan::math::check_greater_or_equal(function__, "last", last, 0);
      current_statement__ = 42;
      stan::math::check_less_or_equal(function__, "last", last, n_occasions);
      current_statement__ = 47;
      stan::math::validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 48;
      stan::math::validate_non_negative_index("phi", "n_occ_minus_1",
        lcm_sym145__);
      current_statement__ = 49;
      stan::math::validate_non_negative_index("p", "nind", nind);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("p", "n_occ_minus_1",
        lcm_sym145__);
      current_statement__ = 51;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 52;
      stan::math::validate_non_negative_index("chi", "n_occasions",
        n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1;
  }
  inline std::string model_name() const final {
    return "lcm_fails2_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "lcm_fails2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym142__;
      int lcm_sym141__;
      int lcm_sym140__;
      int lcm_sym139__;
      int lcm_sym138__;
      double lcm_sym137__;
      double lcm_sym136__;
      double lcm_sym135__;
      double lcm_sym134__;
      double lcm_sym133__;
      double lcm_sym132__;
      double lcm_sym131__;
      double lcm_sym130__;
      double lcm_sym129__;
      double lcm_sym128__;
      double lcm_sym127__;
      double lcm_sym126__;
      double lcm_sym125__;
      double lcm_sym124__;
      int lcm_sym123__;
      int lcm_sym122__;
      int lcm_sym121__;
      int lcm_sym120__;
      int lcm_sym119__;
      int lcm_sym118__;
      int lcm_sym117__;
      int lcm_sym116__;
      int lcm_sym115__;
      int lcm_sym114__;
      int lcm_sym113__;
      int lcm_sym112__;
      int lcm_sym111__;
      int lcm_sym110__;
      int lcm_sym109__;
      int lcm_sym108__;
      int lcm_sym107__;
      int lcm_sym106__;
      int lcm_sym105__;
      int lcm_sym104__;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__,-1,-1> phi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
          DUMMY_VAR__);
      lcm_sym104__ = stan::math::logical_gte(nind, 1);
      if (lcm_sym104__) {
        lcm_sym139__ = stan::model::rvalue(first, "first",
                         stan::model::index_uni(1));
        lcm_sym117__ = (lcm_sym139__ - 1);
        if (stan::math::logical_gte(lcm_sym117__, 1)) {
          stan::model::assign(phi, 0, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          current_statement__ = 6;
          stan::model::assign(p, 0, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int t = 2; t <= lcm_sym117__; ++t) {
            current_statement__ = 7;
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        lcm_sym115__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym115__, lcm_sym139__)) {
          current_statement__ = 9;
          stan::model::assign(phi, mean_phi, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym139__));
          lcm_sym123__ = (lcm_sym139__ + 1);
          stan::model::assign(p, mean_p, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym139__));
          for (int t = lcm_sym123__; t <= lcm_sym115__; ++t) {
            current_statement__ = 9;
            stan::model::assign(phi, mean_phi, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 10;
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          lcm_sym138__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(i));
          lcm_sym116__ = (lcm_sym138__ - 1);
          if (stan::math::logical_gte(lcm_sym116__, 1)) {
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(1));
            for (int t = 2; t <= lcm_sym116__; ++t) {
              current_statement__ = 7;
              stan::model::assign(phi, 0, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 6;
              stan::model::assign(p, 0, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
          current_statement__ = 12;
          if (stan::math::logical_gte(lcm_sym115__, lcm_sym138__)) {
            current_statement__ = 9;
            stan::model::assign(phi, mean_phi, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym138__));
            lcm_sym122__ = (lcm_sym138__ + 1);
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym138__));
            for (int t = lcm_sym122__; t <= lcm_sym115__; ++t) {
              current_statement__ = 9;
              stan::model::assign(phi, mean_phi, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 10;
              stan::model::assign(p, mean_p, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
        }
      }
      Eigen::Matrix<local_scalar_t__,-1,-1>
        inline_prob_uncaptured_return_sym15__;
      {
        current_statement__ = 14;
        stan::math::validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          n_occasions);
        Eigen::Matrix<local_scalar_t__,-1,-1>
          inline_prob_uncaptured_chi_sym16__ =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
            DUMMY_VAR__);
        current_statement__ = 24;
        if (lcm_sym104__) {
          current_statement__ = 17;
          stan::model::assign(inline_prob_uncaptured_chi_sym16__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym16__",
            stan::model::index_uni(1), stan::model::index_uni(n_occasions));
          lcm_sym115__ = (n_occasions - 1);
          lcm_sym105__ = stan::math::logical_gte(lcm_sym115__, 1);
          if (lcm_sym105__) {
            int inline_prob_uncaptured_t_curr_sym17__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym18__ =
              std::numeric_limits<int>::min();
            lcm_sym119__ = (lcm_sym115__ + 1);
            current_statement__ = 20;
            stan::model::assign(inline_prob_uncaptured_chi_sym16__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym115__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym119__ - 1))))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                  "inline_prob_uncaptured_chi_sym16__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym119__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym115__)))),
              "assigning variable inline_prob_uncaptured_chi_sym16__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym115__));
            for (int inline_prob_uncaptured_t_sym19__ = 2; inline_prob_uncaptured_t_sym19__
                 <= lcm_sym115__; ++inline_prob_uncaptured_t_sym19__) {
              int inline_prob_uncaptured_t_curr_sym17__ =
                std::numeric_limits<int>::min();
              lcm_sym114__ = (n_occasions -
                inline_prob_uncaptured_t_sym19__);
              int inline_prob_uncaptured_t_next_sym18__ =
                std::numeric_limits<int>::min();
              lcm_sym118__ = (lcm_sym114__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym16__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym114__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni((lcm_sym118__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                    "inline_prob_uncaptured_chi_sym16__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym118__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym114__)))),
                "assigning variable inline_prob_uncaptured_chi_sym16__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym114__));
            }
          }
          for (int inline_prob_uncaptured_i_sym20__ = 2; inline_prob_uncaptured_i_sym20__
               <= nind; ++inline_prob_uncaptured_i_sym20__) {
            current_statement__ = 17;
            stan::model::assign(inline_prob_uncaptured_chi_sym16__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym16__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
              stan::model::index_uni(n_occasions));
            current_statement__ = 22;
            if (lcm_sym105__) {
              int inline_prob_uncaptured_t_curr_sym17__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym18__ =
                std::numeric_limits<int>::min();
              lcm_sym119__ = (lcm_sym115__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym16__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                     stan::model::index_uni(lcm_sym115__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                    stan::model::index_uni((lcm_sym119__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                    "inline_prob_uncaptured_chi_sym16__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                    stan::model::index_uni(lcm_sym119__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                    stan::model::index_uni(lcm_sym115__)))),
                "assigning variable inline_prob_uncaptured_chi_sym16__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                stan::model::index_uni(lcm_sym115__));
              for (int inline_prob_uncaptured_t_sym19__ = 2; inline_prob_uncaptured_t_sym19__
                   <= lcm_sym115__; ++inline_prob_uncaptured_t_sym19__) {
                int inline_prob_uncaptured_t_curr_sym17__ =
                  std::numeric_limits<int>::min();
                lcm_sym114__ = (n_occasions -
                  inline_prob_uncaptured_t_sym19__);
                int inline_prob_uncaptured_t_next_sym18__ =
                  std::numeric_limits<int>::min();
                lcm_sym118__ = (lcm_sym114__ + 1);
                current_statement__ = 20;
                stan::model::assign(inline_prob_uncaptured_chi_sym16__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(
                         inline_prob_uncaptured_i_sym20__),
                       stan::model::index_uni(lcm_sym114__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                      stan::model::index_uni((lcm_sym118__ - 1))))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym16__,
                      "inline_prob_uncaptured_chi_sym16__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                      stan::model::index_uni(lcm_sym118__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                      stan::model::index_uni(lcm_sym114__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym16__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym20__),
                  stan::model::index_uni(lcm_sym114__));
              }
            }
          }
        }
        current_statement__ = 25;
        stan::model::assign(inline_prob_uncaptured_return_sym15__,
          inline_prob_uncaptured_chi_sym16__,
          "assigning variable inline_prob_uncaptured_return_sym15__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym15__,
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym15__, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym15__, 1);
      {
        current_statement__ = 32;
        if (lcm_sym104__) {
          lcm_sym139__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(1));
          if (stan::math::logical_gt(lcm_sym139__, 0)) {
            lcm_sym141__ = stan::model::rvalue(last, "last",
                             stan::model::index_uni(1));
            lcm_sym123__ = (lcm_sym139__ + 1);
            if (stan::math::logical_gte(lcm_sym141__, lcm_sym123__)) {
              current_statement__ = 26;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym123__ - 1)))));
              lcm_sym121__ = (lcm_sym123__ + 1);
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(lcm_sym123__)),
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym123__ - 1)))));
              for (int t = lcm_sym121__; t <= lcm_sym141__; ++t) {
                current_statement__ = 26;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
                current_statement__ = 27;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni(t)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
              }
            }
            current_statement__ = 29;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             stan::model::rvalue(
                               inline_prob_uncaptured_return_sym15__,
                               "inline_prob_uncaptured_return_sym15__",
                               stan::model::index_uni(1),
                               stan::model::index_uni(lcm_sym141__))));
          }
          for (int i = 2; i <= nind; ++i) {
            lcm_sym138__ = stan::model::rvalue(first, "first",
                             stan::model::index_uni(i));
            if (stan::math::logical_gt(lcm_sym138__, 0)) {
              lcm_sym140__ = stan::model::rvalue(last, "last",
                               stan::model::index_uni(i));
              lcm_sym122__ = (lcm_sym138__ + 1);
              if (stan::math::logical_gte(lcm_sym140__, lcm_sym122__)) {
                current_statement__ = 26;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym122__ - 1)))));
                lcm_sym120__ = (lcm_sym122__ + 1);
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(lcm_sym122__)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym122__ - 1)))));
                for (int t = lcm_sym120__; t <= lcm_sym140__; ++t) {
                  current_statement__ = 26;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(phi, "phi",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                  current_statement__ = 27;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni(t)),
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                }
              }
              current_statement__ = 29;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(
                                 inline_prob_uncaptured_return_sym15__,
                                 "inline_prob_uncaptured_return_sym15__",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(lcm_sym140__))));
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "lcm_fails2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym103__;
      int lcm_sym102__;
      int lcm_sym101__;
      int lcm_sym100__;
      int lcm_sym99__;
      double lcm_sym98__;
      double lcm_sym97__;
      double lcm_sym96__;
      double lcm_sym95__;
      double lcm_sym94__;
      double lcm_sym93__;
      double lcm_sym92__;
      double lcm_sym91__;
      double lcm_sym90__;
      double lcm_sym89__;
      double lcm_sym88__;
      double lcm_sym87__;
      double lcm_sym86__;
      double lcm_sym85__;
      int lcm_sym84__;
      int lcm_sym83__;
      int lcm_sym82__;
      int lcm_sym81__;
      int lcm_sym80__;
      int lcm_sym79__;
      int lcm_sym78__;
      int lcm_sym77__;
      int lcm_sym76__;
      int lcm_sym75__;
      int lcm_sym74__;
      int lcm_sym73__;
      int lcm_sym72__;
      int lcm_sym71__;
      int lcm_sym70__;
      int lcm_sym69__;
      int lcm_sym68__;
      int lcm_sym67__;
      int lcm_sym66__;
      int lcm_sym65__;
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__,-1,-1> phi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, (n_occasions -
          1), DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> chi =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
          DUMMY_VAR__);
      lcm_sym65__ = stan::math::logical_gte(nind, 1);
      if (lcm_sym65__) {
        lcm_sym100__ = stan::model::rvalue(first, "first",
                         stan::model::index_uni(1));
        lcm_sym78__ = (lcm_sym100__ - 1);
        if (stan::math::logical_gte(lcm_sym78__, 1)) {
          stan::model::assign(phi, 0, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          current_statement__ = 6;
          stan::model::assign(p, 0, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int t = 2; t <= lcm_sym78__; ++t) {
            current_statement__ = 7;
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        lcm_sym76__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym76__, lcm_sym100__)) {
          current_statement__ = 9;
          stan::model::assign(phi, mean_phi, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym100__));
          lcm_sym84__ = (lcm_sym100__ + 1);
          stan::model::assign(p, mean_p, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym100__));
          for (int t = lcm_sym84__; t <= lcm_sym76__; ++t) {
            current_statement__ = 9;
            stan::model::assign(phi, mean_phi, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 10;
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          lcm_sym99__ = stan::model::rvalue(first, "first",
                          stan::model::index_uni(i));
          lcm_sym77__ = (lcm_sym99__ - 1);
          if (stan::math::logical_gte(lcm_sym77__, 1)) {
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(1));
            for (int t = 2; t <= lcm_sym77__; ++t) {
              current_statement__ = 7;
              stan::model::assign(phi, 0, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 6;
              stan::model::assign(p, 0, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
          current_statement__ = 12;
          if (stan::math::logical_gte(lcm_sym76__, lcm_sym99__)) {
            current_statement__ = 9;
            stan::model::assign(phi, mean_phi, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym99__));
            lcm_sym83__ = (lcm_sym99__ + 1);
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym99__));
            for (int t = lcm_sym83__; t <= lcm_sym76__; ++t) {
              current_statement__ = 9;
              stan::model::assign(phi, mean_phi, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 10;
              stan::model::assign(p, mean_p, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
        }
      }
      Eigen::Matrix<local_scalar_t__,-1,-1>
        inline_prob_uncaptured_return_sym8__;
      {
        current_statement__ = 14;
        stan::math::validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          n_occasions);
        Eigen::Matrix<local_scalar_t__,-1,-1>
          inline_prob_uncaptured_chi_sym9__ =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nind, n_occasions,
            DUMMY_VAR__);
        current_statement__ = 24;
        if (lcm_sym65__) {
          current_statement__ = 17;
          stan::model::assign(inline_prob_uncaptured_chi_sym9__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym9__",
            stan::model::index_uni(1), stan::model::index_uni(n_occasions));
          lcm_sym76__ = (n_occasions - 1);
          lcm_sym66__ = stan::math::logical_gte(lcm_sym76__, 1);
          if (lcm_sym66__) {
            int inline_prob_uncaptured_t_curr_sym10__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym11__ =
              std::numeric_limits<int>::min();
            lcm_sym80__ = (lcm_sym76__ + 1);
            current_statement__ = 20;
            stan::model::assign(inline_prob_uncaptured_chi_sym9__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym76__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym80__ - 1))))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                  "inline_prob_uncaptured_chi_sym9__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym80__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym76__)))),
              "assigning variable inline_prob_uncaptured_chi_sym9__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym76__));
            for (int inline_prob_uncaptured_t_sym12__ = 2; inline_prob_uncaptured_t_sym12__
                 <= lcm_sym76__; ++inline_prob_uncaptured_t_sym12__) {
              int inline_prob_uncaptured_t_curr_sym10__ =
                std::numeric_limits<int>::min();
              lcm_sym75__ = (n_occasions - inline_prob_uncaptured_t_sym12__);
              int inline_prob_uncaptured_t_next_sym11__ =
                std::numeric_limits<int>::min();
              lcm_sym79__ = (lcm_sym75__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym9__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym75__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni((lcm_sym79__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                    "inline_prob_uncaptured_chi_sym9__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym79__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym75__)))),
                "assigning variable inline_prob_uncaptured_chi_sym9__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym75__));
            }
          }
          for (int inline_prob_uncaptured_i_sym13__ = 2; inline_prob_uncaptured_i_sym13__
               <= nind; ++inline_prob_uncaptured_i_sym13__) {
            current_statement__ = 17;
            stan::model::assign(inline_prob_uncaptured_chi_sym9__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym9__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
              stan::model::index_uni(n_occasions));
            current_statement__ = 22;
            if (lcm_sym66__) {
              int inline_prob_uncaptured_t_curr_sym10__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym11__ =
                std::numeric_limits<int>::min();
              lcm_sym80__ = (lcm_sym76__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym9__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                     stan::model::index_uni(lcm_sym76__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                    stan::model::index_uni((lcm_sym80__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                    "inline_prob_uncaptured_chi_sym9__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                    stan::model::index_uni(lcm_sym80__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                    stan::model::index_uni(lcm_sym76__)))),
                "assigning variable inline_prob_uncaptured_chi_sym9__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                stan::model::index_uni(lcm_sym76__));
              for (int inline_prob_uncaptured_t_sym12__ = 2; inline_prob_uncaptured_t_sym12__
                   <= lcm_sym76__; ++inline_prob_uncaptured_t_sym12__) {
                int inline_prob_uncaptured_t_curr_sym10__ =
                  std::numeric_limits<int>::min();
                lcm_sym75__ = (n_occasions -
                  inline_prob_uncaptured_t_sym12__);
                int inline_prob_uncaptured_t_next_sym11__ =
                  std::numeric_limits<int>::min();
                lcm_sym79__ = (lcm_sym75__ + 1);
                current_statement__ = 20;
                stan::model::assign(inline_prob_uncaptured_chi_sym9__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(
                         inline_prob_uncaptured_i_sym13__),
                       stan::model::index_uni(lcm_sym75__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                      stan::model::index_uni((lcm_sym79__ - 1))))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym9__,
                      "inline_prob_uncaptured_chi_sym9__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                      stan::model::index_uni(lcm_sym79__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                      stan::model::index_uni(lcm_sym75__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym9__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym13__),
                  stan::model::index_uni(lcm_sym75__));
              }
            }
          }
        }
        current_statement__ = 25;
        stan::model::assign(inline_prob_uncaptured_return_sym8__,
          inline_prob_uncaptured_chi_sym9__,
          "assigning variable inline_prob_uncaptured_return_sym8__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym8__,
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym8__, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym8__, 1);
      {
        current_statement__ = 32;
        if (lcm_sym65__) {
          lcm_sym100__ = stan::model::rvalue(first, "first",
                           stan::model::index_uni(1));
          if (stan::math::logical_gt(lcm_sym100__, 0)) {
            lcm_sym102__ = stan::model::rvalue(last, "last",
                             stan::model::index_uni(1));
            lcm_sym84__ = (lcm_sym100__ + 1);
            if (stan::math::logical_gte(lcm_sym102__, lcm_sym84__)) {
              current_statement__ = 26;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(phi, "phi",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym84__ - 1)))));
              lcm_sym82__ = (lcm_sym84__ + 1);
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni(lcm_sym84__)),
                               stan::model::rvalue(p, "p",
                                 stan::model::index_uni(1),
                                 stan::model::index_uni((lcm_sym84__ - 1)))));
              for (int t = lcm_sym82__; t <= lcm_sym102__; ++t) {
                current_statement__ = 26;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
                current_statement__ = 27;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni(t)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(1),
                                   stan::model::index_uni((t - 1)))));
              }
            }
            current_statement__ = 29;
            lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                             stan::model::rvalue(
                               inline_prob_uncaptured_return_sym8__,
                               "inline_prob_uncaptured_return_sym8__",
                               stan::model::index_uni(1),
                               stan::model::index_uni(lcm_sym102__))));
          }
          for (int i = 2; i <= nind; ++i) {
            lcm_sym99__ = stan::model::rvalue(first, "first",
                            stan::model::index_uni(i));
            if (stan::math::logical_gt(lcm_sym99__, 0)) {
              lcm_sym101__ = stan::model::rvalue(last, "last",
                               stan::model::index_uni(i));
              lcm_sym83__ = (lcm_sym99__ + 1);
              if (stan::math::logical_gte(lcm_sym101__, lcm_sym83__)) {
                current_statement__ = 26;
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                 stan::model::rvalue(phi, "phi",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym83__ - 1)))));
                lcm_sym81__ = (lcm_sym83__ + 1);
                lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                 stan::model::rvalue(y, "y",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(lcm_sym83__)),
                                 stan::model::rvalue(p, "p",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni((lcm_sym83__ - 1)))));
                for (int t = lcm_sym81__; t <= lcm_sym101__; ++t) {
                  current_statement__ = 26;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                                   stan::model::rvalue(phi, "phi",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                  current_statement__ = 27;
                  lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(
                                   stan::model::rvalue(y, "y",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni(t)),
                                   stan::model::rvalue(p, "p",
                                     stan::model::index_uni(i),
                                     stan::model::index_uni((t - 1)))));
                }
              }
              current_statement__ = 29;
              lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1,
                               stan::model::rvalue(
                                 inline_prob_uncaptured_return_sym8__,
                                 "inline_prob_uncaptured_return_sym8__",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(lcm_sym101__))));
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "lcm_fails2_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym64__;
      int lcm_sym63__;
      int lcm_sym62__;
      double lcm_sym61__;
      double lcm_sym60__;
      double lcm_sym59__;
      double lcm_sym58__;
      int lcm_sym57__;
      int lcm_sym56__;
      int lcm_sym55__;
      int lcm_sym54__;
      int lcm_sym53__;
      int lcm_sym52__;
      int lcm_sym51__;
      int lcm_sym50__;
      int lcm_sym49__;
      int lcm_sym48__;
      int lcm_sym47__;
      int lcm_sym46__;
      int lcm_sym45__;
      int lcm_sym44__;
      int lcm_sym43__;
      int lcm_sym42__;
      double mean_phi;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      double mean_p;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__,
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<double,-1,-1> phi =
        Eigen::Matrix<double,-1,-1>::Constant(nind, (n_occasions - 1),
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> p =
        Eigen::Matrix<double,-1,-1>::Constant(nind, (n_occasions - 1),
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> chi =
        Eigen::Matrix<double,-1,-1>::Constant(nind, n_occasions,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(mean_phi);
      out__.write(mean_p);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      lcm_sym42__ = stan::math::logical_gte(nind, 1);
      if (lcm_sym42__) {
        lcm_sym63__ = stan::model::rvalue(first, "first",
                        stan::model::index_uni(1));
        lcm_sym51__ = (lcm_sym63__ - 1);
        if (stan::math::logical_gte(lcm_sym51__, 1)) {
          stan::model::assign(phi, 0, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(1));
          current_statement__ = 6;
          stan::model::assign(p, 0, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(1));
          for (int t = 2; t <= lcm_sym51__; ++t) {
            current_statement__ = 7;
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        lcm_sym49__ = (n_occasions - 1);
        if (stan::math::logical_gte(lcm_sym49__, lcm_sym63__)) {
          current_statement__ = 9;
          stan::model::assign(phi, mean_phi, "assigning variable phi",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym63__));
          lcm_sym57__ = (lcm_sym63__ + 1);
          stan::model::assign(p, mean_p, "assigning variable p",
            stan::model::index_uni(1), stan::model::index_uni(lcm_sym63__));
          for (int t = lcm_sym57__; t <= lcm_sym49__; ++t) {
            current_statement__ = 9;
            stan::model::assign(phi, mean_phi, "assigning variable phi",
              stan::model::index_uni(1), stan::model::index_uni(t));
            current_statement__ = 10;
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(1), stan::model::index_uni(t));
          }
        }
        for (int i = 2; i <= nind; ++i) {
          lcm_sym62__ = stan::model::rvalue(first, "first",
                          stan::model::index_uni(i));
          lcm_sym50__ = (lcm_sym62__ - 1);
          if (stan::math::logical_gte(lcm_sym50__, 1)) {
            stan::model::assign(phi, 0, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(1));
            current_statement__ = 6;
            stan::model::assign(p, 0, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(1));
            for (int t = 2; t <= lcm_sym50__; ++t) {
              current_statement__ = 7;
              stan::model::assign(phi, 0, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 6;
              stan::model::assign(p, 0, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
          current_statement__ = 12;
          if (stan::math::logical_gte(lcm_sym49__, lcm_sym62__)) {
            current_statement__ = 9;
            stan::model::assign(phi, mean_phi, "assigning variable phi",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym62__));
            lcm_sym56__ = (lcm_sym62__ + 1);
            stan::model::assign(p, mean_p, "assigning variable p",
              stan::model::index_uni(i), stan::model::index_uni(lcm_sym62__));
            for (int t = lcm_sym56__; t <= lcm_sym49__; ++t) {
              current_statement__ = 9;
              stan::model::assign(phi, mean_phi, "assigning variable phi",
                stan::model::index_uni(i), stan::model::index_uni(t));
              current_statement__ = 10;
              stan::model::assign(p, mean_p, "assigning variable p",
                stan::model::index_uni(i), stan::model::index_uni(t));
            }
          }
        }
      }
      Eigen::Matrix<double,-1,-1> inline_prob_uncaptured_return_sym1__;
      {
        current_statement__ = 14;
        stan::math::validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        stan::math::validate_non_negative_index("chi", "n_occasions",
          n_occasions);
        Eigen::Matrix<double,-1,-1> inline_prob_uncaptured_chi_sym2__ =
          Eigen::Matrix<double,-1,-1>::Constant(nind, n_occasions,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 24;
        if (lcm_sym42__) {
          current_statement__ = 17;
          stan::model::assign(inline_prob_uncaptured_chi_sym2__, 1.0,
            "assigning variable inline_prob_uncaptured_chi_sym2__",
            stan::model::index_uni(1), stan::model::index_uni(n_occasions));
          lcm_sym49__ = (n_occasions - 1);
          lcm_sym43__ = stan::math::logical_gte(lcm_sym49__, 1);
          if (lcm_sym43__) {
            int inline_prob_uncaptured_t_curr_sym3__ =
              std::numeric_limits<int>::min();
            int inline_prob_uncaptured_t_next_sym4__ =
              std::numeric_limits<int>::min();
            lcm_sym55__ = (lcm_sym49__ + 1);
            current_statement__ = 20;
            stan::model::assign(inline_prob_uncaptured_chi_sym2__,
              stan::math::fma(
                (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                   stan::model::index_uni(lcm_sym49__)) * (1 -
                stan::model::rvalue(p, "p", stan::model::index_uni(1),
                  stan::model::index_uni((lcm_sym55__ - 1))))),
                stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                  "inline_prob_uncaptured_chi_sym2__",
                  stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym55__)), (1 -
                stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                  stan::model::index_uni(lcm_sym49__)))),
              "assigning variable inline_prob_uncaptured_chi_sym2__",
              stan::model::index_uni(1), stan::model::index_uni(lcm_sym49__));
            for (int inline_prob_uncaptured_t_sym5__ = 2; inline_prob_uncaptured_t_sym5__
                 <= lcm_sym49__; ++inline_prob_uncaptured_t_sym5__) {
              int inline_prob_uncaptured_t_curr_sym3__ =
                std::numeric_limits<int>::min();
              lcm_sym48__ = (n_occasions - inline_prob_uncaptured_t_sym5__);
              int inline_prob_uncaptured_t_next_sym4__ =
                std::numeric_limits<int>::min();
              lcm_sym54__ = (lcm_sym48__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym2__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                     stan::model::index_uni(lcm_sym48__)) * (1 -
                  stan::model::rvalue(p, "p", stan::model::index_uni(1),
                    stan::model::index_uni((lcm_sym54__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                    "inline_prob_uncaptured_chi_sym2__",
                    stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym54__)), (1 -
                  stan::model::rvalue(phi, "phi", stan::model::index_uni(1),
                    stan::model::index_uni(lcm_sym48__)))),
                "assigning variable inline_prob_uncaptured_chi_sym2__",
                stan::model::index_uni(1),
                stan::model::index_uni(lcm_sym48__));
            }
          }
          for (int inline_prob_uncaptured_i_sym6__ = 2; inline_prob_uncaptured_i_sym6__
               <= nind; ++inline_prob_uncaptured_i_sym6__) {
            current_statement__ = 17;
            stan::model::assign(inline_prob_uncaptured_chi_sym2__, 1.0,
              "assigning variable inline_prob_uncaptured_chi_sym2__",
              stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
              stan::model::index_uni(n_occasions));
            current_statement__ = 22;
            if (lcm_sym43__) {
              int inline_prob_uncaptured_t_curr_sym3__ =
                std::numeric_limits<int>::min();
              int inline_prob_uncaptured_t_next_sym4__ =
                std::numeric_limits<int>::min();
              lcm_sym55__ = (lcm_sym49__ + 1);
              current_statement__ = 20;
              stan::model::assign(inline_prob_uncaptured_chi_sym2__,
                stan::math::fma(
                  (stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                     stan::model::index_uni(lcm_sym49__)) * (1 -
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                    stan::model::index_uni((lcm_sym55__ - 1))))),
                  stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                    "inline_prob_uncaptured_chi_sym2__",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                    stan::model::index_uni(lcm_sym55__)), (1 -
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                    stan::model::index_uni(lcm_sym49__)))),
                "assigning variable inline_prob_uncaptured_chi_sym2__",
                stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                stan::model::index_uni(lcm_sym49__));
              for (int inline_prob_uncaptured_t_sym5__ = 2; inline_prob_uncaptured_t_sym5__
                   <= lcm_sym49__; ++inline_prob_uncaptured_t_sym5__) {
                int inline_prob_uncaptured_t_curr_sym3__ =
                  std::numeric_limits<int>::min();
                lcm_sym48__ = (n_occasions -
                  inline_prob_uncaptured_t_sym5__);
                int inline_prob_uncaptured_t_next_sym4__ =
                  std::numeric_limits<int>::min();
                lcm_sym54__ = (lcm_sym48__ + 1);
                current_statement__ = 20;
                stan::model::assign(inline_prob_uncaptured_chi_sym2__,
                  stan::math::fma(
                    (stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                       stan::model::index_uni(lcm_sym48__)) * (1 -
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                      stan::model::index_uni((lcm_sym54__ - 1))))),
                    stan::model::rvalue(inline_prob_uncaptured_chi_sym2__,
                      "inline_prob_uncaptured_chi_sym2__",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                      stan::model::index_uni(lcm_sym54__)), (1 -
                    stan::model::rvalue(phi, "phi",
                      stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                      stan::model::index_uni(lcm_sym48__)))),
                  "assigning variable inline_prob_uncaptured_chi_sym2__",
                  stan::model::index_uni(inline_prob_uncaptured_i_sym6__),
                  stan::model::index_uni(lcm_sym48__));
              }
            }
          }
        }
        current_statement__ = 25;
        stan::model::assign(inline_prob_uncaptured_return_sym1__,
          inline_prob_uncaptured_chi_sym2__,
          "assigning variable inline_prob_uncaptured_return_sym1__");
      }
      stan::model::assign(chi, inline_prob_uncaptured_return_sym1__,
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym1__, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi",
        inline_prob_uncaptured_return_sym1__, 1);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(inline_prob_uncaptured_return_sym1__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mean_phi",
        "double", std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "mean_p", "double",
        std::vector<size_t>{});
      local_scalar_t__ mean_phi;
      current_statement__ = 1;
      mean_phi = context__.vals_r("mean_phi")[(1 - 1)];
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p;
      current_statement__ = 2;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      out__.write_free_lub(0, 1, mean_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mean_phi", "mean_p"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"phi", "p", "chi"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(nind),
               static_cast<size_t>(n_occ_minus_1)},
             std::vector<size_t>{static_cast<size_t>(nind),
               static_cast<size_t>(n_occ_minus_1)},
             std::vector<size_t>{static_cast<size_t>(nind),
               static_cast<size_t>(n_occasions)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    if (emit_transformed_parameters__) {
      for (int sym153__ = 1; sym153__ <= n_occ_minus_1; ++sym153__) {
        for (int sym154__ = 1; sym154__ <= nind; ++sym154__) {
          param_names__.emplace_back(std::string() + "phi" + '.' +
            std::to_string(sym154__) + '.' + std::to_string(sym153__));
        }
      }
      for (int sym153__ = 1; sym153__ <= n_occ_minus_1; ++sym153__) {
        for (int sym154__ = 1; sym154__ <= nind; ++sym154__) {
          param_names__.emplace_back(std::string() + "p" + '.' +
            std::to_string(sym154__) + '.' + std::to_string(sym153__));
        }
      }
      for (int sym153__ = 1; sym153__ <= n_occasions; ++sym153__) {
        for (int sym154__ = 1; sym154__ <= nind; ++sym154__) {
          param_names__.emplace_back(std::string() + "chi" + '.' +
            std::to_string(sym154__) + '.' + std::to_string(sym153__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    if (emit_transformed_parameters__) {
      for (int sym153__ = 1; sym153__ <= n_occ_minus_1; ++sym153__) {
        for (int sym154__ = 1; sym154__ <= nind; ++sym154__) {
          param_names__.emplace_back(std::string() + "phi" + '.' +
            std::to_string(sym154__) + '.' + std::to_string(sym153__));
        }
      }
      for (int sym153__ = 1; sym153__ <= n_occ_minus_1; ++sym153__) {
        for (int sym154__ = 1; sym154__ <= nind; ++sym154__) {
          param_names__.emplace_back(std::string() + "p" + '.' +
            std::to_string(sym154__) + '.' + std::to_string(sym153__));
        }
      }
      for (int sym153__ = 1; sym153__ <= n_occasions; ++sym153__) {
        for (int sym154__ = 1; sym154__ <= nind; ++sym154__) {
          param_names__.emplace_back(std::string() + "chi" + '.' +
            std::to_string(sym154__) + '.' + std::to_string(sym153__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + 1);
    const size_t num_transformed = emit_transformed_parameters * ((((nind *
      n_occ_minus_1) + (nind * n_occ_minus_1)) + (nind * n_occasions)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + 1);
    const size_t num_transformed = emit_transformed_parameters * ((((nind *
      n_occ_minus_1) + (nind * n_occ_minus_1)) + (nind * n_occasions)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = lcm_fails2_model_namespace::lcm_fails2_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return lcm_fails2_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp lupdf-inlining.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lupdf_inlining_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 13> locations_array__ =
  {" (found before start of program)",
  " (in 'lupdf-inlining.stan', line 16, column 4 to column 12)",
  " (in 'lupdf-inlining.stan', line 19, column 4 to column 32)",
  " (in 'lupdf-inlining.stan', line 26, column 4 to column 30)",
  " (in 'lupdf-inlining.stan', line 27, column 4 to column 31)",
  " (in 'lupdf-inlining.stan', line 22, column 4 to column 29)",
  " (in 'lupdf-inlining.stan', line 13, column 4 to column 10)",
  " (in 'lupdf-inlining.stan', line 3, column 8 to column 36)",
  " (in 'lupdf-inlining.stan', line 2, column 35 to line 4, column 5)",
  " (in 'lupdf-inlining.stan', line 6, column 8 to column 35)",
  " (in 'lupdf-inlining.stan', line 5, column 34 to line 7, column 5)",
  " (in 'lupdf-inlining.stan', line 9, column 8 to column 32)",
  " (in 'lupdf-inlining.stan', line 8, column 26 to line 10, column 5)"};
template <bool propto__, typename T0__, typename T1__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_stan_scalar<T1__>>* = nullptr>
stan::promote_args_t<T0__, T1__>
foo_lpdf(const T0__& x, const T1__& mu, std::ostream* pstream__);
template <bool propto__, typename T1__,
          stan::require_all_t<stan::is_stan_scalar<T1__>>* = nullptr>
stan::promote_args_t<T1__>
bar_lpmf(const int& n, const T1__& mu, std::ostream* pstream__);
template <bool propto__, typename T0__,
          stan::require_all_t<stan::is_stan_scalar<T0__>>* = nullptr>
stan::promote_args_t<T0__> baz_lpdf(const T0__& x, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T1__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_stan_scalar<T1__>>*>
stan::promote_args_t<T0__, T1__>
foo_lpdf(const T0__& x, const T1__& mu, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym30__;
    {
      current_statement__ = 7;
      return stan::math::normal_lpdf<propto__>(x, mu, 1);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <bool propto__, typename T1__,
          stan::require_all_t<stan::is_stan_scalar<T1__>>*>
stan::promote_args_t<T1__>
bar_lpmf(const int& n, const T1__& mu, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__>;
  int current_statement__ = 0;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym31__;
    {
      current_statement__ = 9;
      return stan::math::poisson_lpmf<propto__>(n, mu);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <bool propto__, typename T0__,
          stan::require_all_t<stan::is_stan_scalar<T0__>>*>
stan::promote_args_t<T0__> baz_lpdf(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym32__;
    {
      current_statement__ = 11;
      return foo_lpdf<propto__>(x, 0.5, pstream__);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class lupdf_inlining_model final : public model_base_crtp<lupdf_inlining_model> {
 private:
  int n;
 public:
  ~lupdf_inlining_model() {}
  lupdf_inlining_model(stan::io::var_context& context__, unsigned int
                       random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "lupdf_inlining_model_namespace::lupdf_inlining_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 6;
      context__.validate_dims("data initialization", "n", "int",
        std::vector<size_t>{});
      n = std::numeric_limits<int>::min();
      current_statement__ = 6;
      n = context__.vals_i("n")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1;
  }
  inline std::string model_name() const final {
    return "lupdf_inlining_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "lupdf_inlining_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ lcm_sym43__;
      local_scalar_t__ lcm_sym42__;
      local_scalar_t__ lcm_sym41__;
      local_scalar_t__ mu;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      local_scalar_t__ tp = DUMMY_VAR__;
      double inline_foo_lpdf_return_sym23__;
      {
        lcm_sym41__ = stan::math::normal_lpdf<false>(mu, 1.0, 1);
      }
      tp = lcm_sym41__;
      {
        double inline_baz_lpdf_return_sym25__;
        {
          double inline_baz_lpdf_inline_foo_lpdf_return_sym7___sym26__;
          {
            lcm_sym42__ = stan::math::normal_lpdf<propto__>(mu, 0.5, 1);
          }
        }
        lp_accum__.add(lcm_sym42__);
        double inline_bar_lpmf_return_sym28__;
        {
          lcm_sym43__ = stan::math::poisson_lpmf<propto__>(n, mu);
        }
        lp_accum__.add(lcm_sym43__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "lupdf_inlining_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ lcm_sym40__;
      local_scalar_t__ lcm_sym39__;
      local_scalar_t__ lcm_sym38__;
      local_scalar_t__ mu;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      local_scalar_t__ tp = DUMMY_VAR__;
      double inline_foo_lpdf_return_sym16__;
      {
        lcm_sym38__ = stan::math::normal_lpdf<false>(mu, 1.0, 1);
      }
      tp = lcm_sym38__;
      {
        double inline_baz_lpdf_return_sym18__;
        {
          double inline_baz_lpdf_inline_foo_lpdf_return_sym7___sym19__;
          {
            lcm_sym39__ = stan::math::normal_lpdf<propto__>(mu, 0.5, 1);
          }
        }
        lp_accum__.add(lcm_sym39__);
        double inline_bar_lpmf_return_sym21__;
        {
          lcm_sym40__ = stan::math::poisson_lpmf<propto__>(n, mu);
        }
        lp_accum__.add(lcm_sym40__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "lupdf_inlining_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym37__;
      double lcm_sym36__;
      double lcm_sym35__;
      int lcm_sym34__;
      int lcm_sym33__;
      double mu;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      double tp = std::numeric_limits<double>::quiet_NaN();
      out__.write(mu);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      double inline_foo_lpdf_return_sym9__;
      {
        lcm_sym36__ = stan::math::normal_lpdf<false>(mu, 1.0, 1);
      }
      tp = lcm_sym36__;
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym36__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      double lbaz = std::numeric_limits<double>::quiet_NaN();
      double inline_baz_lpdf_return_sym11__;
      {
        double inline_baz_lpdf_inline_foo_lpdf_return_sym1___sym12__;
        {
          lcm_sym35__ = stan::math::normal_lpdf<false>(mu, 0.5, 1);
        }
      }
      lbaz = lcm_sym35__;
      double lbar = std::numeric_limits<double>::quiet_NaN();
      double inline_bar_lpmf_return_sym14__;
      {
        lcm_sym37__ = stan::math::poisson_lpmf<false>(n, mu);
      }
      lbar = lcm_sym37__;
      out__.write(lcm_sym35__);
      out__.write(lcm_sym37__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ mu;
      current_statement__ = 1;
      mu = in__.read<local_scalar_t__>();
      out__.write(mu);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "mu", "double",
        std::vector<size_t>{});
      local_scalar_t__ mu;
      current_statement__ = 1;
      mu = context__.vals_r("mu")[(1 - 1)];
      out__.write(mu);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"mu"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"tp"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string> temp{"lbaz", "lbar"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>> temp{std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{}, std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mu");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp");
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "lbaz");
      param_names__.emplace_back(std::string() + "lbar");
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "mu");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp");
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "lbaz");
      param_names__.emplace_back(std::string() + "lbar");
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tp\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"lbaz\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"lbar\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tp\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"lbaz\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"lbar\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (1);
    const size_t num_gen_quantities = emit_generated_quantities * ((1 + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * (1);
    const size_t num_gen_quantities = emit_generated_quantities * ((1 + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = lupdf_inlining_model_namespace::lupdf_inlining_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return lupdf_inlining_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp off-dce.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace off_dce_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 52> locations_array__ =
  {" (found before start of program)",
  " (in 'off-dce.stan', line 21, column 2 to column 17)",
  " (in 'off-dce.stan', line 22, column 2 to column 16)",
  " (in 'off-dce.stan', line 23, column 2 to column 15)",
  " (in 'off-dce.stan', line 24, column 2 to column 14)",
  " (in 'off-dce.stan', line 27, column 2 to column 22)",
  " (in 'off-dce.stan', line 28, column 2 to column 23)",
  " (in 'off-dce.stan', line 54, column 2 to column 13)",
  " (in 'off-dce.stan', line 55, column 2 to column 24)",
  " (in 'off-dce.stan', line 56, column 2 to column 17)",
  " (in 'off-dce.stan', line 69, column 6 to column 15)",
  " (in 'off-dce.stan', line 66, column 11 to line 70, column 5)",
  " (in 'off-dce.stan', line 61, column 6 to column 41)",
  " (in 'off-dce.stan', line 62, column 13 to column 14)",
  " (in 'off-dce.stan', line 62, column 6 to column 44)",
  " (in 'off-dce.stan', line 63, column 6 to column 29)",
  " (in 'off-dce.stan', line 65, column 6 to column 39)",
  " (in 'off-dce.stan', line 59, column 23 to line 66, column 5)",
  " (in 'off-dce.stan', line 59, column 4 to line 70, column 5)",
  " (in 'off-dce.stan', line 68, column 6 to column 21)",
  " (in 'off-dce.stan', line 64, column 6 to column 55)",
  " (in 'off-dce.stan', line 58, column 19 to line 71, column 3)",
  " (in 'off-dce.stan', line 58, column 2 to line 71, column 3)",
  " (in 'off-dce.stan', line 46, column 6 to line 49, column 68)",
  " (in 'off-dce.stan', line 44, column 11 to line 50, column 5)",
  " (in 'off-dce.stan', line 42, column 6 to column 40)",
  " (in 'off-dce.stan', line 43, column 6 to column 41)",
  " (in 'off-dce.stan', line 40, column 18 to line 44, column 5)",
  " (in 'off-dce.stan', line 40, column 4 to line 50, column 5)",
  " (in 'off-dce.stan', line 39, column 19 to line 51, column 3)",
  " (in 'off-dce.stan', line 39, column 2 to line 51, column 3)",
  " (in 'off-dce.stan', line 4, column 2 to column 17)",
  " (in 'off-dce.stan', line 5, column 2 to column 17)",
  " (in 'off-dce.stan', line 6, column 8 to column 9)",
  " (in 'off-dce.stan', line 6, column 11 to column 12)",
  " (in 'off-dce.stan', line 6, column 2 to column 38)",
  " (in 'off-dce.stan', line 7, column 9 to column 10)",
  " (in 'off-dce.stan', line 7, column 2 to column 14)",
  " (in 'off-dce.stan', line 10, column 8 to column 9)",
  " (in 'off-dce.stan', line 10, column 2 to column 39)",
  " (in 'off-dce.stan', line 11, column 2 to column 32)",
  " (in 'off-dce.stan', line 13, column 2 to column 14)",
  " (in 'off-dce.stan', line 15, column 4 to column 25)",
  " (in 'off-dce.stan', line 17, column 6 to column 28)",
  " (in 'off-dce.stan', line 16, column 4 to line 17, column 28)",
  " (in 'off-dce.stan', line 14, column 19 to line 18, column 3)",
  " (in 'off-dce.stan', line 14, column 2 to line 18, column 3)",
  " (in 'off-dce.stan', line 27, column 9 to column 10)",
  " (in 'off-dce.stan', line 28, column 9 to column 10)",
  " (in 'off-dce.stan', line 28, column 12 to column 13)",
  " (in 'off-dce.stan', line 55, column 8 to column 9)",
  " (in 'off-dce.stan', line 56, column 8 to column 9)"};
class off_dce_model final : public model_base_crtp<off_dce_model> {
 private:
  int lcm_sym53__;
  int lcm_sym52__;
  int lcm_sym51__;
  int lcm_sym50__;
  double lcm_sym49__;
  double lcm_sym48__;
  int lcm_sym47__;
  int lcm_sym46__;
  int lcm_sym45__;
  int lcm_sym44__;
  int lcm_sym43__;
  int lcm_sym42__;
  int R;
  int T;
  std::vector<std::vector<int>> y;
  Eigen::Matrix<double,-1,1> X_data__;
  std::vector<int> sum_y;
  int occ_obs;
  Eigen::Map<Eigen::Matrix<double,-1,1>> X{nullptr, 0};
 public:
  ~off_dce_model() {}
  off_dce_model(stan::io::var_context& context__, unsigned int
                random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "off_dce_model_namespace::off_dce_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 31;
      context__.validate_dims("data initialization", "R", "int",
        std::vector<size_t>{});
      R = std::numeric_limits<int>::min();
      current_statement__ = 31;
      R = context__.vals_i("R")[(1 - 1)];
      current_statement__ = 31;
      stan::math::check_greater_or_equal(function__, "R", R, 1);
      current_statement__ = 32;
      context__.validate_dims("data initialization", "T", "int",
        std::vector<size_t>{});
      T = std::numeric_limits<int>::min();
      current_statement__ = 32;
      T = context__.vals_i("T")[(1 - 1)];
      current_statement__ = 32;
      stan::math::check_greater_or_equal(function__, "T", T, 1);
      current_statement__ = 33;
      stan::math::validate_non_negative_index("y", "R", R);
      current_statement__ = 34;
      stan::math::validate_non_negative_index("y", "T", T);
      current_statement__ = 35;
      context__.validate_dims("data initialization", "y", "int",
        std::vector<size_t>{static_cast<size_t>(R), static_cast<size_t>(T)});
      y = std::vector<std::vector<int>>(R,
            std::vector<int>(T, std::numeric_limits<int>::min()));
      {
        std::vector<int> y_flat__;
        current_statement__ = 35;
        y_flat__ = context__.vals_i("y");
        pos__ = 1;
        if (stan::math::logical_gte(T, 1)) {
          lcm_sym42__ = stan::math::logical_gte(R, 1);
          if (lcm_sym42__) {
            stan::model::assign(y,
              stan::model::rvalue(y_flat__, "y_flat__",
                stan::model::index_uni(1)), "assigning variable y",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= R; ++sym2__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          for (int sym1__ = 2; sym1__ <= T; ++sym1__) {
            if (lcm_sym42__) {
              stan::model::assign(y, y_flat__[(pos__ - 1)],
                "assigning variable y", stan::model::index_uni(1),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= R; ++sym2__) {
                stan::model::assign(y, y_flat__[(pos__ - 1)],
                  "assigning variable y", stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                pos__ = (pos__ + 1);
              }
            }
          }
        } else {
          lcm_sym42__ = stan::math::logical_gte(R, 1);
        }
      }
      current_statement__ = 35;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 35;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("X", "R", R);
      current_statement__ = 37;
      context__.validate_dims("data initialization", "X", "double",
        std::vector<size_t>{static_cast<size_t>(R)});
      X_data__ = Eigen::Matrix<double,-1,1>::Constant(R,
                   std::numeric_limits<double>::quiet_NaN());
      new (&X) Eigen::Map<Eigen::Matrix<double,-1,1>>(X_data__.data(), R);
      {
        std::vector<double> X_flat__;
        current_statement__ = 37;
        X_flat__ = context__.vals_r("X");
        pos__ = 1;
        if (lcm_sym42__) {
          stan::model::assign(X,
            stan::model::rvalue(X_flat__, "X_flat__",
              stan::model::index_uni(1)), "assigning variable X",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= R; ++sym1__) {
            stan::model::assign(X, X_flat__[(pos__ - 1)],
              "assigning variable X", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 38;
      stan::math::validate_non_negative_index("sum_y", "R", R);
      current_statement__ = 39;
      sum_y = std::vector<int>(R, std::numeric_limits<int>::min());
      current_statement__ = 40;
      occ_obs = std::numeric_limits<int>::min();
      current_statement__ = 41;
      occ_obs = 0;
      current_statement__ = 46;
      if (lcm_sym42__) {
        current_statement__ = 42;
        stan::model::assign(sum_y,
          stan::math::sum(
            stan::model::rvalue(y, "y", stan::model::index_uni(1))),
          "assigning variable sum_y", stan::model::index_uni(1));
        current_statement__ = 44;
        if (stan::model::rvalue(sum_y, "sum_y", stan::model::index_uni(1))) {
          current_statement__ = 43;
          occ_obs = 1;
        }
        for (int i = 2; i <= R; ++i) {
          current_statement__ = 42;
          stan::model::assign(sum_y,
            stan::math::sum(
              stan::model::rvalue(y, "y", stan::model::index_uni(i))),
            "assigning variable sum_y", stan::model::index_uni(i));
          current_statement__ = 44;
          if (stan::model::rvalue(sum_y, "sum_y", stan::model::index_uni(i))) {
            current_statement__ = 43;
            occ_obs = (occ_obs + 1);
          }
        }
      }
      current_statement__ = 39;
      stan::math::check_greater_or_equal(function__, "sum_y", sum_y, 0);
      current_statement__ = 39;
      stan::math::check_less_or_equal(function__, "sum_y", sum_y, T);
      current_statement__ = 40;
      stan::math::check_greater_or_equal(function__, "occ_obs", occ_obs, 0);
      current_statement__ = 40;
      stan::math::check_less_or_equal(function__, "occ_obs", occ_obs, R);
      current_statement__ = 47;
      stan::math::validate_non_negative_index("logit_psi", "R", R);
      current_statement__ = 48;
      stan::math::validate_non_negative_index("logit_p", "R", R);
      current_statement__ = 49;
      stan::math::validate_non_negative_index("logit_p", "T", T);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("psi_con", "R", R);
      current_statement__ = 51;
      stan::math::validate_non_negative_index("z", "R", R);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1;
  }
  inline std::string model_name() const final {
    return "off_dce_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "off_dce_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym41__;
      int lcm_sym40__;
      Eigen::Matrix<local_scalar_t__,-1,-1> lcm_sym39__;
      double lcm_sym38__;
      double lcm_sym37__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym36__;
      double lcm_sym35__;
      double lcm_sym34__;
      double lcm_sym33__;
      double lcm_sym32__;
      int lcm_sym31__;
      local_scalar_t__ alpha_occ;
      current_statement__ = 1;
      alpha_occ = in__.template read<local_scalar_t__>();
      local_scalar_t__ beta_occ;
      current_statement__ = 2;
      beta_occ = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha_p;
      current_statement__ = 3;
      alpha_p = in__.template read<local_scalar_t__>();
      local_scalar_t__ beta_p;
      current_statement__ = 4;
      beta_p = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> logit_psi =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(R, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> logit_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(R, T, DUMMY_VAR__);
      stan::model::assign(lcm_sym36__,
        stan::math::fma(beta_occ, X, alpha_occ),
        "assigning variable lcm_sym36__");
      stan::model::assign(logit_psi, lcm_sym36__,
        "assigning variable logit_psi");
      stan::model::assign(lcm_sym39__,
        stan::math::rep_matrix(stan::math::fma(beta_p, X, alpha_p), T),
        "assigning variable lcm_sym39__");
      stan::model::assign(logit_p, lcm_sym39__, "assigning variable logit_p");
      {
        current_statement__ = 30;
        if (stan::math::logical_gte(R, 1)) {
          current_statement__ = 28;
          if (stan::model::rvalue(sum_y, "sum_y", stan::model::index_uni(1))) {
            current_statement__ = 25;
            lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(1,
                             stan::model::rvalue(lcm_sym36__, "lcm_sym36__",
                               stan::model::index_uni(1))));
            current_statement__ = 26;
            lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(
                             stan::model::rvalue(y, "y",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(lcm_sym39__, "lcm_sym39__",
                               stan::model::index_uni(1))));
          } else {
            current_statement__ = 23;
            lp_accum__.add(stan::math::log_sum_exp(
                             (stan::math::bernoulli_logit_lpmf<false>(1,
                                stan::model::rvalue(lcm_sym36__,
                                  "lcm_sym36__", stan::model::index_uni(1)))
                             +
                             stan::math::bernoulli_logit_lpmf<false>(0,
                               stan::model::rvalue(lcm_sym39__,
                                 "lcm_sym39__", stan::model::index_uni(1)))),
                             stan::math::bernoulli_logit_lpmf<false>(0,
                               stan::model::rvalue(lcm_sym36__,
                                 "lcm_sym36__", stan::model::index_uni(1)))));
          }
          for (int i = 2; i <= R; ++i) {
            current_statement__ = 28;
            if (stan::model::rvalue(sum_y, "sum_y", stan::model::index_uni(i))) {
              current_statement__ = 25;
              lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(1,
                               stan::model::rvalue(lcm_sym36__,
                                 "lcm_sym36__", stan::model::index_uni(i))));
              current_statement__ = 26;
              lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(i)),
                               stan::model::rvalue(lcm_sym39__,
                                 "lcm_sym39__", stan::model::index_uni(i))));
            } else {
              current_statement__ = 23;
              lp_accum__.add(stan::math::log_sum_exp(
                               (stan::math::bernoulli_logit_lpmf<false>(1,
                                  stan::model::rvalue(lcm_sym36__,
                                    "lcm_sym36__", stan::model::index_uni(i)))
                               +
                               stan::math::bernoulli_logit_lpmf<false>(0,
                                 stan::model::rvalue(lcm_sym39__,
                                   "lcm_sym39__", stan::model::index_uni(i)))),
                               stan::math::bernoulli_logit_lpmf<false>(0,
                                 stan::model::rvalue(lcm_sym36__,
                                   "lcm_sym36__", stan::model::index_uni(i)))));
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "off_dce_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym30__;
      int lcm_sym29__;
      Eigen::Matrix<local_scalar_t__,-1,-1> lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym25__;
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      int lcm_sym20__;
      local_scalar_t__ alpha_occ;
      current_statement__ = 1;
      alpha_occ = in__.template read<local_scalar_t__>();
      local_scalar_t__ beta_occ;
      current_statement__ = 2;
      beta_occ = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha_p;
      current_statement__ = 3;
      alpha_p = in__.template read<local_scalar_t__>();
      local_scalar_t__ beta_p;
      current_statement__ = 4;
      beta_p = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> logit_psi =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(R, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> logit_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(R, T, DUMMY_VAR__);
      stan::model::assign(lcm_sym25__,
        stan::math::fma(beta_occ, X, alpha_occ),
        "assigning variable lcm_sym25__");
      stan::model::assign(logit_psi, lcm_sym25__,
        "assigning variable logit_psi");
      stan::model::assign(lcm_sym28__,
        stan::math::rep_matrix(stan::math::fma(beta_p, X, alpha_p), T),
        "assigning variable lcm_sym28__");
      stan::model::assign(logit_p, lcm_sym28__, "assigning variable logit_p");
      {
        current_statement__ = 30;
        if (stan::math::logical_gte(R, 1)) {
          current_statement__ = 28;
          if (stan::model::rvalue(sum_y, "sum_y", stan::model::index_uni(1))) {
            current_statement__ = 25;
            lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(1,
                             stan::model::rvalue(lcm_sym25__, "lcm_sym25__",
                               stan::model::index_uni(1))));
            current_statement__ = 26;
            lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(
                             stan::model::rvalue(y, "y",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(lcm_sym28__, "lcm_sym28__",
                               stan::model::index_uni(1))));
          } else {
            current_statement__ = 23;
            lp_accum__.add(stan::math::log_sum_exp(
                             (stan::math::bernoulli_logit_lpmf<false>(1,
                                stan::model::rvalue(lcm_sym25__,
                                  "lcm_sym25__", stan::model::index_uni(1)))
                             +
                             stan::math::bernoulli_logit_lpmf<false>(0,
                               stan::model::rvalue(lcm_sym28__,
                                 "lcm_sym28__", stan::model::index_uni(1)))),
                             stan::math::bernoulli_logit_lpmf<false>(0,
                               stan::model::rvalue(lcm_sym25__,
                                 "lcm_sym25__", stan::model::index_uni(1)))));
          }
          for (int i = 2; i <= R; ++i) {
            current_statement__ = 28;
            if (stan::model::rvalue(sum_y, "sum_y", stan::model::index_uni(i))) {
              current_statement__ = 25;
              lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(1,
                               stan::model::rvalue(lcm_sym25__,
                                 "lcm_sym25__", stan::model::index_uni(i))));
              current_statement__ = 26;
              lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(
                               stan::model::rvalue(y, "y",
                                 stan::model::index_uni(i)),
                               stan::model::rvalue(lcm_sym28__,
                                 "lcm_sym28__", stan::model::index_uni(i))));
            } else {
              current_statement__ = 23;
              lp_accum__.add(stan::math::log_sum_exp(
                               (stan::math::bernoulli_logit_lpmf<false>(1,
                                  stan::model::rvalue(lcm_sym25__,
                                    "lcm_sym25__", stan::model::index_uni(i)))
                               +
                               stan::math::bernoulli_logit_lpmf<false>(0,
                                 stan::model::rvalue(lcm_sym28__,
                                   "lcm_sym28__", stan::model::index_uni(i)))),
                               stan::math::bernoulli_logit_lpmf<false>(0,
                                 stan::model::rvalue(lcm_sym25__,
                                   "lcm_sym25__", stan::model::index_uni(i)))));
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "off_dce_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym19__;
      double lcm_sym11__;
      double lcm_sym10__;
      int lcm_sym18__;
      Eigen::Matrix<double,-1,-1> lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      Eigen::Matrix<double,-1,1> lcm_sym12__;
      Eigen::Matrix<double,-1,1> lcm_sym9__;
      Eigen::Matrix<double,-1,1> lcm_sym8__;
      int lcm_sym7__;
      int lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      double lcm_sym2__;
      double lcm_sym1__;
      double alpha_occ;
      current_statement__ = 1;
      alpha_occ = in__.template read<local_scalar_t__>();
      double beta_occ;
      current_statement__ = 2;
      beta_occ = in__.template read<local_scalar_t__>();
      double alpha_p;
      current_statement__ = 3;
      alpha_p = in__.template read<local_scalar_t__>();
      double beta_p;
      current_statement__ = 4;
      beta_p = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,1> logit_psi =
        Eigen::Matrix<double,-1,1>::Constant(R,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> logit_p =
        Eigen::Matrix<double,-1,-1>::Constant(R, T,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(alpha_occ);
      out__.write(beta_occ);
      out__.write(alpha_p);
      out__.write(beta_p);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      stan::model::assign(lcm_sym12__,
        stan::math::fma(beta_occ, X, alpha_occ),
        "assigning variable lcm_sym12__");
      stan::model::assign(logit_psi, lcm_sym12__,
        "assigning variable logit_psi");
      stan::model::assign(lcm_sym17__,
        stan::math::rep_matrix(stan::math::fma(beta_p, X, alpha_p), T),
        "assigning variable lcm_sym17__");
      stan::model::assign(logit_p, lcm_sym17__, "assigning variable logit_p");
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym12__);
        out__.write(lcm_sym17__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      int occ_fs = std::numeric_limits<int>::min();
      std::vector<double> psi_con =
        std::vector<double>(R, std::numeric_limits<double>::quiet_NaN());
      std::vector<int> z =
        std::vector<int>(R, std::numeric_limits<int>::min());
      current_statement__ = 22;
      if (stan::math::logical_gte(R, 1)) {
        current_statement__ = 18;
        if (stan::math::logical_eq(
              stan::model::rvalue(sum_y, "sum_y", stan::model::index_uni(1)),
              0)) {
          double psi = std::numeric_limits<double>::quiet_NaN();
          lcm_sym14__ = stan::math::inv_logit(
                          stan::model::rvalue(lcm_sym12__, "lcm_sym12__",
                            stan::model::index_uni(1)));
          current_statement__ = 13;
          stan::math::validate_non_negative_index("q", "T", T);
          Eigen::Matrix<double,-1,1> q =
            Eigen::Matrix<double,-1,1>::Constant(T,
              std::numeric_limits<double>::quiet_NaN());
          stan::model::assign(lcm_sym9__,
            stan::math::transpose(
              stan::math::inv_logit(
                stan::math::minus(
                  stan::model::rvalue(lcm_sym17__, "lcm_sym17__",
                    stan::model::index_uni(1))))),
            "assigning variable lcm_sym9__");
          double qT = std::numeric_limits<double>::quiet_NaN();
          lcm_sym16__ = stan::math::prod(lcm_sym9__);
          stan::model::assign(psi_con, ((lcm_sym14__ * lcm_sym16__) /
            stan::math::fma(lcm_sym14__, lcm_sym16__, (1 - lcm_sym14__))),
            "assigning variable psi_con", stan::model::index_uni(1));
          current_statement__ = 16;
          stan::model::assign(z,
            stan::math::bernoulli_rng(
              stan::model::rvalue(psi_con, "psi_con",
                stan::model::index_uni(1)), base_rng__),
            "assigning variable z", stan::model::index_uni(1));
        } else {
          stan::model::assign(psi_con, 1, "assigning variable psi_con",
            stan::model::index_uni(1));
          current_statement__ = 10;
          stan::model::assign(z, 1, "assigning variable z",
            stan::model::index_uni(1));
        }
        for (int i = 2; i <= R; ++i) {
          current_statement__ = 18;
          if (stan::math::logical_eq(
                stan::model::rvalue(sum_y, "sum_y", stan::model::index_uni(i)),
                0)) {
            double psi = std::numeric_limits<double>::quiet_NaN();
            lcm_sym13__ = stan::math::inv_logit(
                            stan::model::rvalue(lcm_sym12__, "lcm_sym12__",
                              stan::model::index_uni(i)));
            current_statement__ = 13;
            stan::math::validate_non_negative_index("q", "T", T);
            Eigen::Matrix<double,-1,1> q =
              Eigen::Matrix<double,-1,1>::Constant(T,
                std::numeric_limits<double>::quiet_NaN());
            stan::model::assign(lcm_sym8__,
              stan::math::transpose(
                stan::math::inv_logit(
                  stan::math::minus(
                    stan::model::rvalue(lcm_sym17__, "lcm_sym17__",
                      stan::model::index_uni(i))))),
              "assigning variable lcm_sym8__");
            double qT = std::numeric_limits<double>::quiet_NaN();
            lcm_sym15__ = stan::math::prod(lcm_sym8__);
            current_statement__ = 20;
            stan::model::assign(psi_con, ((lcm_sym13__ * lcm_sym15__) /
              stan::math::fma(lcm_sym13__, lcm_sym15__, (1 - lcm_sym13__))),
              "assigning variable psi_con", stan::model::index_uni(i));
            current_statement__ = 16;
            stan::model::assign(z,
              stan::math::bernoulli_rng(
                stan::model::rvalue(psi_con, "psi_con",
                  stan::model::index_uni(i)), base_rng__),
              "assigning variable z", stan::model::index_uni(i));
          } else {
            current_statement__ = 19;
            stan::model::assign(psi_con, 1, "assigning variable psi_con",
              stan::model::index_uni(i));
            current_statement__ = 10;
            stan::model::assign(z, 1, "assigning variable z",
              stan::model::index_uni(i));
          }
        }
      }
      lcm_sym18__ = stan::math::sum(z);
      occ_fs = lcm_sym18__;
      out__.write(lcm_sym18__);
      out__.write(psi_con);
      out__.write(z);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ alpha_occ;
      current_statement__ = 1;
      alpha_occ = in__.read<local_scalar_t__>();
      out__.write(alpha_occ);
      local_scalar_t__ beta_occ;
      current_statement__ = 2;
      beta_occ = in__.read<local_scalar_t__>();
      out__.write(beta_occ);
      local_scalar_t__ alpha_p;
      current_statement__ = 3;
      alpha_p = in__.read<local_scalar_t__>();
      out__.write(alpha_p);
      local_scalar_t__ beta_p;
      current_statement__ = 4;
      beta_p = in__.read<local_scalar_t__>();
      out__.write(beta_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "alpha_occ",
        "double", std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "beta_occ",
        "double", std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "alpha_p",
        "double", std::vector<size_t>{});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "beta_p", "double",
        std::vector<size_t>{});
      local_scalar_t__ alpha_occ;
      current_statement__ = 1;
      alpha_occ = context__.vals_r("alpha_occ")[(1 - 1)];
      out__.write(alpha_occ);
      local_scalar_t__ beta_occ;
      current_statement__ = 2;
      beta_occ = context__.vals_r("beta_occ")[(1 - 1)];
      out__.write(beta_occ);
      local_scalar_t__ alpha_p;
      current_statement__ = 3;
      alpha_p = context__.vals_r("alpha_p")[(1 - 1)];
      out__.write(alpha_p);
      local_scalar_t__ beta_p;
      current_statement__ = 4;
      beta_p = context__.vals_r("beta_p")[(1 - 1)];
      out__.write(beta_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"alpha_occ", "beta_occ", "alpha_p",
                "beta_p"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"logit_psi", "logit_p"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string> temp{"occ_fs", "psi_con", "z"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(R)},
             std::vector<size_t>{static_cast<size_t>(R),
               static_cast<size_t>(T)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(R)},
             std::vector<size_t>{static_cast<size_t>(R)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha_occ");
    param_names__.emplace_back(std::string() + "beta_occ");
    param_names__.emplace_back(std::string() + "alpha_p");
    param_names__.emplace_back(std::string() + "beta_p");
    if (emit_transformed_parameters__) {
      for (int sym54__ = 1; sym54__ <= R; ++sym54__) {
        param_names__.emplace_back(std::string() + "logit_psi" + '.' +
          std::to_string(sym54__));
      }
      for (int sym54__ = 1; sym54__ <= T; ++sym54__) {
        for (int sym55__ = 1; sym55__ <= R; ++sym55__) {
          param_names__.emplace_back(std::string() + "logit_p" + '.' +
            std::to_string(sym55__) + '.' + std::to_string(sym54__));
        }
      }
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "occ_fs");
      for (int sym54__ = 1; sym54__ <= R; ++sym54__) {
        param_names__.emplace_back(std::string() + "psi_con" + '.' +
          std::to_string(sym54__));
      }
      for (int sym54__ = 1; sym54__ <= R; ++sym54__) {
        param_names__.emplace_back(std::string() + "z" + '.' +
          std::to_string(sym54__));
      }
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha_occ");
    param_names__.emplace_back(std::string() + "beta_occ");
    param_names__.emplace_back(std::string() + "alpha_p");
    param_names__.emplace_back(std::string() + "beta_p");
    if (emit_transformed_parameters__) {
      for (int sym54__ = 1; sym54__ <= R; ++sym54__) {
        param_names__.emplace_back(std::string() + "logit_psi" + '.' +
          std::to_string(sym54__));
      }
      for (int sym54__ = 1; sym54__ <= T; ++sym54__) {
        for (int sym55__ = 1; sym55__ <= R; ++sym55__) {
          param_names__.emplace_back(std::string() + "logit_p" + '.' +
            std::to_string(sym55__) + '.' + std::to_string(sym54__));
        }
      }
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "occ_fs");
      for (int sym54__ = 1; sym54__ <= R; ++sym54__) {
        param_names__.emplace_back(std::string() + "psi_con" + '.' +
          std::to_string(sym54__));
      }
      for (int sym54__ = 1; sym54__ <= R; ++sym54__) {
        param_names__.emplace_back(std::string() + "z" + '.' +
          std::to_string(sym54__));
      }
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"logit_psi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(R) + "},\"block\":\"transformed_parameters\"},{\"name\":\"logit_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(R) + ",\"cols\":" + std::to_string(T) + "},\"block\":\"transformed_parameters\"},{\"name\":\"occ_fs\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"psi_con\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(R) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(R) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"logit_psi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(R) + "},\"block\":\"transformed_parameters\"},{\"name\":\"logit_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(R) + ",\"cols\":" + std::to_string(T) + "},\"block\":\"transformed_parameters\"},{\"name\":\"occ_fs\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"psi_con\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(R) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(R) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((1 + 1) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * ((R + (R *
      T)));
    const size_t num_gen_quantities = emit_generated_quantities * (((1 + R) +
      R));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((1 + 1) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * ((R + (R *
      T)));
    const size_t num_gen_quantities = emit_generated_quantities * (((1 + R) +
      R));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = off_dce_model_namespace::off_dce_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return off_dce_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp off-small.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace off_small_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 35> locations_array__ =
  {" (found before start of program)",
  " (in 'off-small.stan', line 10, column 2 to column 12)",
  " (in 'off-small.stan', line 11, column 2 to column 17)",
  " (in 'off-small.stan', line 12, column 2 to column 17)",
  " (in 'off-small.stan', line 13, column 2 to column 13)",
  " (in 'off-small.stan', line 14, column 2 to column 13)",
  " (in 'off-small.stan', line 15, column 2 to column 36)",
  " (in 'off-small.stan', line 16, column 2 to column 36)",
  " (in 'off-small.stan', line 17, column 2 to column 35)",
  " (in 'off-small.stan', line 20, column 2 to column 15)",
  " (in 'off-small.stan', line 21, column 2 to column 15)",
  " (in 'off-small.stan', line 22, column 2 to column 18)",
  " (in 'off-small.stan', line 28, column 4 to line 29, column 41)",
  " (in 'off-small.stan', line 27, column 2 to line 29, column 41)",
  " (in 'off-small.stan', line 32, column 2 to column 23)",
  " (in 'off-small.stan', line 33, column 2 to column 22)",
  " (in 'off-small.stan', line 34, column 2 to column 23)",
  " (in 'off-small.stan', line 35, column 2 to column 22)",
  " (in 'off-small.stan', line 37, column 2 to column 22)",
  " (in 'off-small.stan', line 39, column 2 to column 29)",
  " (in 'off-small.stan', line 2, column 2 to column 17)",
  " (in 'off-small.stan', line 3, column 2 to column 17)",
  " (in 'off-small.stan', line 4, column 8 to column 9)",
  " (in 'off-small.stan', line 4, column 2 to column 40)",
  " (in 'off-small.stan', line 5, column 9 to column 10)",
  " (in 'off-small.stan', line 5, column 2 to column 17)",
  " (in 'off-small.stan', line 6, column 9 to column 10)",
  " (in 'off-small.stan', line 6, column 2 to column 22)",
  " (in 'off-small.stan', line 7, column 9 to column 10)",
  " (in 'off-small.stan', line 7, column 2 to column 14)",
  " (in 'off-small.stan', line 11, column 9 to column 10)",
  " (in 'off-small.stan', line 12, column 9 to column 10)",
  " (in 'off-small.stan', line 20, column 9 to column 10)",
  " (in 'off-small.stan', line 21, column 9 to column 10)",
  " (in 'off-small.stan', line 22, column 9 to column 10)"};
class off_small_model final : public model_base_crtp<off_small_model> {
 private:
  double lcm_sym43__;
  double lcm_sym42__;
  double lcm_sym41__;
  double lcm_sym40__;
  double lcm_sym39__;
  double lcm_sym38__;
  int lcm_sym37__;
  int lcm_sym36__;
  int J;
  int N;
  std::vector<int> person;
  Eigen::Matrix<double,-1,1> time_data__;
  Eigen::Matrix<double,-1,1> treatment_data__;
  Eigen::Matrix<double,-1,1> y_data__;
  Eigen::Map<Eigen::Matrix<double,-1,1>> time{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> treatment{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> y{nullptr, 0};
 public:
  ~off_small_model() {}
  off_small_model(stan::io::var_context& context__, unsigned int
                  random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "off_small_model_namespace::off_small_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 20;
      context__.validate_dims("data initialization", "J", "int",
        std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      current_statement__ = 20;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 20;
      stan::math::check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 21;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 21;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 21;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 22;
      stan::math::validate_non_negative_index("person", "N", N);
      current_statement__ = 23;
      context__.validate_dims("data initialization", "person", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      person = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 23;
      person = context__.vals_i("person");
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "person", person, 1);
      current_statement__ = 23;
      stan::math::check_less_or_equal(function__, "person", person, J);
      current_statement__ = 24;
      stan::math::validate_non_negative_index("time", "N", N);
      current_statement__ = 25;
      context__.validate_dims("data initialization", "time", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      time_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                      std::numeric_limits<double>::quiet_NaN());
      new (&time) Eigen::Map<Eigen::Matrix<double,-1,1>>(time_data__.data(),
        N);
      {
        std::vector<double> time_flat__;
        current_statement__ = 25;
        time_flat__ = context__.vals_r("time");
        pos__ = 1;
        lcm_sym36__ = stan::math::logical_gte(N, 1);
        if (lcm_sym36__) {
          stan::model::assign(time,
            stan::model::rvalue(time_flat__, "time_flat__",
              stan::model::index_uni(1)), "assigning variable time",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(time, time_flat__[(pos__ - 1)],
              "assigning variable time", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 26;
      stan::math::validate_non_negative_index("treatment", "N", N);
      current_statement__ = 27;
      context__.validate_dims("data initialization", "treatment", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      treatment_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                           std::numeric_limits<double>::quiet_NaN());
      new (&treatment)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(treatment_data__.data(), N);
      {
        std::vector<double> treatment_flat__;
        current_statement__ = 27;
        treatment_flat__ = context__.vals_r("treatment");
        pos__ = 1;
        if (lcm_sym36__) {
          stan::model::assign(treatment,
            stan::model::rvalue(treatment_flat__, "treatment_flat__",
              stan::model::index_uni(1)), "assigning variable treatment",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(treatment, treatment_flat__[(pos__ - 1)],
              "assigning variable treatment", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 28;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 29;
      context__.validate_dims("data initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      y_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                   std::numeric_limits<double>::quiet_NaN());
      new (&y) Eigen::Map<Eigen::Matrix<double,-1,1>>(y_data__.data(), N);
      {
        std::vector<double> y_flat__;
        current_statement__ = 29;
        y_flat__ = context__.vals_r("y");
        pos__ = 1;
        if (lcm_sym36__) {
          stan::model::assign(y,
            stan::model::rvalue(y_flat__, "y_flat__",
              stan::model::index_uni(1)), "assigning variable y",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 30;
      stan::math::validate_non_negative_index("eta1", "J", J);
      current_statement__ = 31;
      stan::math::validate_non_negative_index("eta2", "J", J);
      current_statement__ = 32;
      stan::math::validate_non_negative_index("a1", "J", J);
      current_statement__ = 33;
      stan::math::validate_non_negative_index("a2", "J", J);
      current_statement__ = 34;
      stan::math::validate_non_negative_index("y_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + J + J + 1 + 1 + 1 + 1 + 1;
  }
  inline std::string model_name() const final {
    return "off_small_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "off_small_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym35__;
      double lcm_sym34__;
      double lcm_sym33__;
      double lcm_sym32__;
      double lcm_sym31__;
      double lcm_sym30__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym26__;
      int lcm_sym25__;
      local_scalar_t__ beta;
      current_statement__ = 1;
      beta = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> eta1;
      current_statement__ = 2;
      eta1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(J);
      Eigen::Matrix<local_scalar_t__,-1,1> eta2;
      current_statement__ = 3;
      eta2 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(J);
      local_scalar_t__ mu_a1;
      current_statement__ = 4;
      mu_a1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ mu_a2;
      current_statement__ = 5;
      mu_a2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma_a1;
      current_statement__ = 6;
      sigma_a1 = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_a2;
      current_statement__ = 7;
      sigma_a2 = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_y;
      current_statement__ = 8;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> a1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> a2 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> y_hat =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      stan::model::assign(lcm_sym29__,
        stan::math::fma(10, mu_a1, stan::math::multiply(sigma_a1, eta1)),
        "assigning variable lcm_sym29__");
      stan::model::assign(a1, lcm_sym29__, "assigning variable a1");
      stan::model::assign(lcm_sym26__,
        stan::math::fma(0.1, mu_a2, stan::math::multiply(sigma_a2, eta2)),
        "assigning variable lcm_sym26__");
      stan::model::assign(a2, lcm_sym26__, "assigning variable a2");
      current_statement__ = 13;
      if (stan::math::logical_gte(N, 1)) {
        current_statement__ = 12;
        stan::model::assign(y_hat,
          stan::math::fma(
            stan::model::rvalue(lcm_sym26__, "lcm_sym26__",
              stan::model::index_uni(
                stan::model::rvalue(person, "person",
                  stan::model::index_uni(1)))),
            stan::model::rvalue(time, "time", stan::model::index_uni(1)),
            stan::math::fma((beta *
              stan::model::rvalue(time, "time", stan::model::index_uni(1))),
              stan::model::rvalue(treatment, "treatment",
                stan::model::index_uni(1)),
              stan::model::rvalue(lcm_sym29__, "lcm_sym29__",
                stan::model::index_uni(
                  stan::model::rvalue(person, "person",
                    stan::model::index_uni(1)))))),
          "assigning variable y_hat", stan::model::index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 12;
          stan::model::assign(y_hat,
            stan::math::fma(
              stan::model::rvalue(lcm_sym26__, "lcm_sym26__",
                stan::model::index_uni(
                  stan::model::rvalue(person, "person",
                    stan::model::index_uni(i)))),
              stan::model::rvalue(time, "time", stan::model::index_uni(i)),
              stan::math::fma((beta *
                stan::model::rvalue(time, "time", stan::model::index_uni(i))),
                stan::model::rvalue(treatment, "treatment",
                  stan::model::index_uni(i)),
                stan::model::rvalue(lcm_sym29__, "lcm_sym29__",
                  stan::model::index_uni(
                    stan::model::rvalue(person, "person",
                      stan::model::index_uni(i)))))),
            "assigning variable y_hat", stan::model::index_uni(i));
        }
      }
      {
        current_statement__ = 14;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu_a1, 0, 1));
        current_statement__ = 15;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(eta1, 0, 1));
        current_statement__ = 16;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu_a2, 0, 1));
        current_statement__ = 17;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(eta2, 0, 1));
        current_statement__ = 18;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(beta, 0, 1));
        current_statement__ = 19;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, y_hat, sigma_y));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "off_small_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      Eigen::Matrix<local_scalar_t__,-1,1> lcm_sym15__;
      int lcm_sym14__;
      local_scalar_t__ beta;
      current_statement__ = 1;
      beta = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> eta1;
      current_statement__ = 2;
      eta1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(J);
      Eigen::Matrix<local_scalar_t__,-1,1> eta2;
      current_statement__ = 3;
      eta2 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(J);
      local_scalar_t__ mu_a1;
      current_statement__ = 4;
      mu_a1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ mu_a2;
      current_statement__ = 5;
      mu_a2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma_a1;
      current_statement__ = 6;
      sigma_a1 = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_a2;
      current_statement__ = 7;
      sigma_a2 = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_y;
      current_statement__ = 8;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> a1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> a2 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> y_hat =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      stan::model::assign(lcm_sym18__,
        stan::math::fma(10, mu_a1, stan::math::multiply(sigma_a1, eta1)),
        "assigning variable lcm_sym18__");
      stan::model::assign(a1, lcm_sym18__, "assigning variable a1");
      stan::model::assign(lcm_sym15__,
        stan::math::fma(0.1, mu_a2, stan::math::multiply(sigma_a2, eta2)),
        "assigning variable lcm_sym15__");
      stan::model::assign(a2, lcm_sym15__, "assigning variable a2");
      current_statement__ = 13;
      if (stan::math::logical_gte(N, 1)) {
        current_statement__ = 12;
        stan::model::assign(y_hat,
          stan::math::fma(
            stan::model::rvalue(lcm_sym15__, "lcm_sym15__",
              stan::model::index_uni(
                stan::model::rvalue(person, "person",
                  stan::model::index_uni(1)))),
            stan::model::rvalue(time, "time", stan::model::index_uni(1)),
            stan::math::fma((beta *
              stan::model::rvalue(time, "time", stan::model::index_uni(1))),
              stan::model::rvalue(treatment, "treatment",
                stan::model::index_uni(1)),
              stan::model::rvalue(lcm_sym18__, "lcm_sym18__",
                stan::model::index_uni(
                  stan::model::rvalue(person, "person",
                    stan::model::index_uni(1)))))),
          "assigning variable y_hat", stan::model::index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 12;
          stan::model::assign(y_hat,
            stan::math::fma(
              stan::model::rvalue(lcm_sym15__, "lcm_sym15__",
                stan::model::index_uni(
                  stan::model::rvalue(person, "person",
                    stan::model::index_uni(i)))),
              stan::model::rvalue(time, "time", stan::model::index_uni(i)),
              stan::math::fma((beta *
                stan::model::rvalue(time, "time", stan::model::index_uni(i))),
                stan::model::rvalue(treatment, "treatment",
                  stan::model::index_uni(i)),
                stan::model::rvalue(lcm_sym18__, "lcm_sym18__",
                  stan::model::index_uni(
                    stan::model::rvalue(person, "person",
                      stan::model::index_uni(i)))))),
            "assigning variable y_hat", stan::model::index_uni(i));
        }
      }
      {
        current_statement__ = 14;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu_a1, 0, 1));
        current_statement__ = 15;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(eta1, 0, 1));
        current_statement__ = 16;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu_a2, 0, 1));
        current_statement__ = 17;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(eta2, 0, 1));
        current_statement__ = 18;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(beta, 0, 1));
        current_statement__ = 19;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, y_hat, sigma_y));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "off_small_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,1> lcm_sym13__;
      double lcm_sym12__;
      double lcm_sym11__;
      Eigen::Matrix<double,-1,1> lcm_sym10__;
      int lcm_sym9__;
      int lcm_sym8__;
      int lcm_sym7__;
      double beta;
      current_statement__ = 1;
      beta = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,1> eta1;
      current_statement__ = 2;
      eta1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(J);
      Eigen::Matrix<double,-1,1> eta2;
      current_statement__ = 3;
      eta2 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(J);
      double mu_a1;
      current_statement__ = 4;
      mu_a1 = in__.template read<local_scalar_t__>();
      double mu_a2;
      current_statement__ = 5;
      mu_a2 = in__.template read<local_scalar_t__>();
      double sigma_a1;
      current_statement__ = 6;
      sigma_a1 = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 100, lp__);
      double sigma_a2;
      current_statement__ = 7;
      sigma_a2 = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 100, lp__);
      double sigma_y;
      current_statement__ = 8;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<double,-1,1> a1 =
        Eigen::Matrix<double,-1,1>::Constant(J,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> a2 =
        Eigen::Matrix<double,-1,1>::Constant(J,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> y_hat =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(beta);
      out__.write(eta1);
      out__.write(eta2);
      out__.write(mu_a1);
      out__.write(mu_a2);
      out__.write(sigma_a1);
      out__.write(sigma_a2);
      out__.write(sigma_y);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      stan::model::assign(lcm_sym13__,
        stan::math::fma(10, mu_a1, stan::math::multiply(sigma_a1, eta1)),
        "assigning variable lcm_sym13__");
      stan::model::assign(a1, lcm_sym13__, "assigning variable a1");
      stan::model::assign(lcm_sym10__,
        stan::math::fma(0.1, mu_a2, stan::math::multiply(sigma_a2, eta2)),
        "assigning variable lcm_sym10__");
      stan::model::assign(a2, lcm_sym10__, "assigning variable a2");
      current_statement__ = 13;
      if (stan::math::logical_gte(N, 1)) {
        current_statement__ = 12;
        stan::model::assign(y_hat,
          stan::math::fma(
            stan::model::rvalue(lcm_sym10__, "lcm_sym10__",
              stan::model::index_uni(
                stan::model::rvalue(person, "person",
                  stan::model::index_uni(1)))),
            stan::model::rvalue(time, "time", stan::model::index_uni(1)),
            stan::math::fma((beta *
              stan::model::rvalue(time, "time", stan::model::index_uni(1))),
              stan::model::rvalue(treatment, "treatment",
                stan::model::index_uni(1)),
              stan::model::rvalue(lcm_sym13__, "lcm_sym13__",
                stan::model::index_uni(
                  stan::model::rvalue(person, "person",
                    stan::model::index_uni(1)))))),
          "assigning variable y_hat", stan::model::index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 12;
          stan::model::assign(y_hat,
            stan::math::fma(
              stan::model::rvalue(lcm_sym10__, "lcm_sym10__",
                stan::model::index_uni(
                  stan::model::rvalue(person, "person",
                    stan::model::index_uni(i)))),
              stan::model::rvalue(time, "time", stan::model::index_uni(i)),
              stan::math::fma((beta *
                stan::model::rvalue(time, "time", stan::model::index_uni(i))),
                stan::model::rvalue(treatment, "treatment",
                  stan::model::index_uni(i)),
                stan::model::rvalue(lcm_sym13__, "lcm_sym13__",
                  stan::model::index_uni(
                    stan::model::rvalue(person, "person",
                      stan::model::index_uni(i)))))),
            "assigning variable y_hat", stan::model::index_uni(i));
        }
      }
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym13__);
        out__.write(lcm_sym10__);
        out__.write(y_hat);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ beta;
      current_statement__ = 1;
      beta = in__.read<local_scalar_t__>();
      out__.write(beta);
      Eigen::Matrix<local_scalar_t__,-1,1> eta1;
      current_statement__ = 2;
      stan::model::assign(eta1,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(J),
        "assigning variable eta1");
      out__.write(eta1);
      Eigen::Matrix<local_scalar_t__,-1,1> eta2;
      current_statement__ = 3;
      stan::model::assign(eta2,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(J),
        "assigning variable eta2");
      out__.write(eta2);
      local_scalar_t__ mu_a1;
      current_statement__ = 4;
      mu_a1 = in__.read<local_scalar_t__>();
      out__.write(mu_a1);
      local_scalar_t__ mu_a2;
      current_statement__ = 5;
      mu_a2 = in__.read<local_scalar_t__>();
      out__.write(mu_a2);
      local_scalar_t__ sigma_a1;
      current_statement__ = 6;
      sigma_a1 = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_a1);
      local_scalar_t__ sigma_a2;
      current_statement__ = 7;
      sigma_a2 = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_a2);
      local_scalar_t__ sigma_y;
      current_statement__ = 8;
      sigma_y = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "beta", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "eta1", "double",
        std::vector<size_t>{static_cast<size_t>(J)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "eta2", "double",
        std::vector<size_t>{static_cast<size_t>(J)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "mu_a1", "double",
        std::vector<size_t>{});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "mu_a2", "double",
        std::vector<size_t>{});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "sigma_a1",
        "double", std::vector<size_t>{});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "sigma_a2",
        "double", std::vector<size_t>{});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization", "sigma_y",
        "double", std::vector<size_t>{});
      double lcm_sym6__;
      double lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ beta;
      current_statement__ = 1;
      beta = context__.vals_r("beta")[(1 - 1)];
      out__.write(beta);
      Eigen::Matrix<local_scalar_t__,-1,1> eta1 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      {
        std::vector<double> eta1_flat__;
        current_statement__ = 2;
        eta1_flat__ = context__.vals_r("eta1");
        pos__ = 1;
        lcm_sym1__ = stan::math::logical_gte(J, 1);
        if (lcm_sym1__) {
          stan::model::assign(eta1,
            stan::model::rvalue(eta1_flat__, "eta1_flat__",
              stan::model::index_uni(1)), "assigning variable eta1",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= J; ++sym1__) {
            stan::model::assign(eta1, eta1_flat__[(pos__ - 1)],
              "assigning variable eta1", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(eta1);
      Eigen::Matrix<local_scalar_t__,-1,1> eta2 =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
      {
        std::vector<double> eta2_flat__;
        current_statement__ = 3;
        eta2_flat__ = context__.vals_r("eta2");
        pos__ = 1;
        if (lcm_sym1__) {
          stan::model::assign(eta2,
            stan::model::rvalue(eta2_flat__, "eta2_flat__",
              stan::model::index_uni(1)), "assigning variable eta2",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= J; ++sym1__) {
            stan::model::assign(eta2, eta2_flat__[(pos__ - 1)],
              "assigning variable eta2", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(eta2);
      local_scalar_t__ mu_a1;
      current_statement__ = 4;
      mu_a1 = context__.vals_r("mu_a1")[(1 - 1)];
      out__.write(mu_a1);
      local_scalar_t__ mu_a2;
      current_statement__ = 5;
      mu_a2 = context__.vals_r("mu_a2")[(1 - 1)];
      out__.write(mu_a2);
      local_scalar_t__ sigma_a1;
      current_statement__ = 6;
      sigma_a1 = context__.vals_r("sigma_a1")[(1 - 1)];
      out__.write_free_lub(0, 100, sigma_a1);
      local_scalar_t__ sigma_a2;
      current_statement__ = 7;
      sigma_a2 = context__.vals_r("sigma_a2")[(1 - 1)];
      out__.write_free_lub(0, 100, sigma_a2);
      local_scalar_t__ sigma_y;
      current_statement__ = 8;
      sigma_y = context__.vals_r("sigma_y")[(1 - 1)];
      out__.write_free_lub(0, 100, sigma_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"beta", "eta1", "eta2", "mu_a1",
                "mu_a2", "sigma_a1", "sigma_a2", "sigma_y"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"a1", "a2", "y_hat"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(J)},
                std::vector<size_t>{static_cast<size_t>(J)},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(J)},
             std::vector<size_t>{static_cast<size_t>(J)},
             std::vector<size_t>{static_cast<size_t>(N)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "beta");
    for (int sym44__ = 1; sym44__ <= J; ++sym44__) {
      param_names__.emplace_back(std::string() + "eta1" + '.' +
        std::to_string(sym44__));
    }
    for (int sym44__ = 1; sym44__ <= J; ++sym44__) {
      param_names__.emplace_back(std::string() + "eta2" + '.' +
        std::to_string(sym44__));
    }
    param_names__.emplace_back(std::string() + "mu_a1");
    param_names__.emplace_back(std::string() + "mu_a2");
    param_names__.emplace_back(std::string() + "sigma_a1");
    param_names__.emplace_back(std::string() + "sigma_a2");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym44__ = 1; sym44__ <= J; ++sym44__) {
        param_names__.emplace_back(std::string() + "a1" + '.' +
          std::to_string(sym44__));
      }
      for (int sym44__ = 1; sym44__ <= J; ++sym44__) {
        param_names__.emplace_back(std::string() + "a2" + '.' +
          std::to_string(sym44__));
      }
      for (int sym44__ = 1; sym44__ <= N; ++sym44__) {
        param_names__.emplace_back(std::string() + "y_hat" + '.' +
          std::to_string(sym44__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "beta");
    for (int sym44__ = 1; sym44__ <= J; ++sym44__) {
      param_names__.emplace_back(std::string() + "eta1" + '.' +
        std::to_string(sym44__));
    }
    for (int sym44__ = 1; sym44__ <= J; ++sym44__) {
      param_names__.emplace_back(std::string() + "eta2" + '.' +
        std::to_string(sym44__));
    }
    param_names__.emplace_back(std::string() + "mu_a1");
    param_names__.emplace_back(std::string() + "mu_a2");
    param_names__.emplace_back(std::string() + "sigma_a1");
    param_names__.emplace_back(std::string() + "sigma_a2");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym44__ = 1; sym44__ <= J; ++sym44__) {
        param_names__.emplace_back(std::string() + "a1" + '.' +
          std::to_string(sym44__));
      }
      for (int sym44__ = 1; sym44__ <= J; ++sym44__) {
        param_names__.emplace_back(std::string() + "a2" + '.' +
          std::to_string(sym44__));
      }
      for (int sym44__ = 1; sym44__ <= N; ++sym44__) {
        param_names__.emplace_back(std::string() + "y_hat" + '.' +
          std::to_string(sym44__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eta1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"eta2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"mu_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eta1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"eta2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"mu_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((1 + J) + J) + 1) + 1) + 1) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * (((J + J) +
      N));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((1 + J) + J) + 1) + 1) + 1) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * (((J + J) +
      N));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = off_small_model_namespace::off_small_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return off_small_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp optimizations.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace optimizations_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 93> locations_array__ =
  {" (found before start of program)",
  " (in 'optimizations.stan', line 20, column 4 to column 15)",
  " (in 'optimizations.stan', line 21, column 4 to column 13)",
  " (in 'optimizations.stan', line 22, column 4 to column 26)",
  " (in 'optimizations.stan', line 23, column 4 to column 23)",
  " (in 'optimizations.stan', line 24, column 4 to column 24)",
  " (in 'optimizations.stan', line 27, column 4 to column 11)",
  " (in 'optimizations.stan', line 5, column 8 to column 20)",
  " (in 'optimizations.stan', line 28, column 4 to column 19)",
  " (in 'optimizations.stan', line 9, column 8 to line 10, column 26)",
  " (in 'optimizations.stan', line 8, column 20 to line 12, column 5)",
  " (in 'optimizations.stan', line 30, column 17 to column 28)",
  " (in 'optimizations.stan', line 33, column 6 to column 22)",
  " (in 'optimizations.stan', line 31, column 33 to line 34, column 5)",
  " (in 'optimizations.stan', line 36, column 8 to column 21)",
  " (in 'optimizations.stan', line 35, column 4 to line 37, column 5)",
  " (in 'optimizations.stan', line 41, column 16 to column 29)",
  " (in 'optimizations.stan', line 40, column 12 to line 41, column 29)",
  " (in 'optimizations.stan', line 39, column 8 to line 41, column 29)",
  " (in 'optimizations.stan', line 38, column 4 to line 41, column 29)",
  " (in 'optimizations.stan', line 44, column 10 to column 16)",
  " (in 'optimizations.stan', line 43, column 8 to line 44, column 16)",
  " (in 'optimizations.stan', line 45, column 8 to column 20)",
  " (in 'optimizations.stan', line 42, column 21 to line 46, column 5)",
  " (in 'optimizations.stan', line 42, column 4 to line 46, column 5)",
  " (in 'optimizations.stan', line 49, column 10 to column 19)",
  " (in 'optimizations.stan', line 48, column 8 to line 49, column 19)",
  " (in 'optimizations.stan', line 50, column 8 to column 20)",
  " (in 'optimizations.stan', line 47, column 21 to line 51, column 5)",
  " (in 'optimizations.stan', line 47, column 4 to line 51, column 5)",
  " (in 'optimizations.stan', line 54, column 10 to column 19)",
  " (in 'optimizations.stan', line 53, column 8 to line 54, column 19)",
  " (in 'optimizations.stan', line 55, column 8 to column 20)",
  " (in 'optimizations.stan', line 52, column 21 to line 56, column 5)",
  " (in 'optimizations.stan', line 52, column 4 to line 56, column 5)",
  " (in 'optimizations.stan', line 58, column 4 to column 16)",
  " (in 'optimizations.stan', line 60, column 6 to column 12)",
  " (in 'optimizations.stan', line 59, column 4 to line 60, column 12)",
  " (in 'optimizations.stan', line 61, column 4 to column 16)",
  " (in 'optimizations.stan', line 64, column 4 to column 16)",
  " (in 'optimizations.stan', line 66, column 4 to column 16)",
  " (in 'optimizations.stan', line 68, column 6 to column 19)",
  " (in 'optimizations.stan', line 69, column 4 to column 16)",
  " (in 'optimizations.stan', line 70, column 4 to column 11)",
  " (in 'optimizations.stan', line 71, column 4 to column 10)",
  " (in 'optimizations.stan', line 72, column 4 to column 16)",
  " (in 'optimizations.stan', line 74, column 6 to column 12)",
  " (in 'optimizations.stan', line 73, column 4 to line 74, column 12)",
  " (in 'optimizations.stan', line 75, column 4 to column 16)",
  " (in 'optimizations.stan', line 78, column 4 to column 16)",
  " (in 'optimizations.stan', line 80, column 8 to column 19)",
  " (in 'optimizations.stan', line 82, column 8 to column 20)",
  " (in 'optimizations.stan', line 79, column 4 to line 83, column 5)",
  " (in 'optimizations.stan', line 85, column 8 to column 20)",
  " (in 'optimizations.stan', line 87, column 8 to column 20)",
  " (in 'optimizations.stan', line 84, column 4 to line 88, column 5)",
  " (in 'optimizations.stan', line 90, column 11 to column 23)",
  " (in 'optimizations.stan', line 90, column 4 to column 23)",
  " (in 'optimizations.stan', line 15, column 8 to column 20)",
  " (in 'optimizations.stan', line 97, column 20 to column 26)",
  " (in 'optimizations.stan', line 98, column 22 to column 28)",
  " (in 'optimizations.stan', line 100, column 6 to column 15)",
  " (in 'optimizations.stan', line 99, column 4 to line 100, column 15)",
  " (in 'optimizations.stan', line 102, column 6 to column 12)",
  " (in 'optimizations.stan', line 101, column 4 to line 102, column 12)",
  " (in 'optimizations.stan', line 106, column 6 to column 15)",
  " (in 'optimizations.stan', line 108, column 6 to column 12)",
  " (in 'optimizations.stan', line 112, column 8 to column 20)",
  " (in 'optimizations.stan', line 115, column 8 to column 21)",
  " (in 'optimizations.stan', line 111, column 4 to line 116, column 5)",
  " (in 'optimizations.stan', line 119, column 12 to column 24)",
  " (in 'optimizations.stan', line 118, column 8 to line 121, column 9)",
  " (in 'optimizations.stan', line 117, column 4 to line 127, column 5)",
  " (in 'optimizations.stan', line 128, column 4 to column 14)",
  " (in 'optimizations.stan', line 132, column 6 to column 21)",
  " (in 'optimizations.stan', line 129, column 4 to line 132, column 21)",
  " (in 'optimizations.stan', line 134, column 4 to column 15)",
  " (in 'optimizations.stan', line 137, column 8 to column 23)",
  " (in 'optimizations.stan', line 138, column 8 to column 24)",
  " (in 'optimizations.stan', line 135, column 4 to line 139, column 5)",
  " (in 'optimizations.stan', line 140, column 4 to column 25)",
  " (in 'optimizations.stan', line 143, column 4 to column 26)",
  " (in 'optimizations.stan', line 144, column 4 to column 22)",
  " (in 'optimizations.stan', line 146, column 6 to column 28)",
  " (in 'optimizations.stan', line 145, column 4 to line 146, column 28)",
  " (in 'optimizations.stan', line 147, column 4 to column 23)",
  " (in 'optimizations.stan', line 4, column 10 to column 17)",
  " (in 'optimizations.stan', line 3, column 8 to line 4, column 17)",
  " (in 'optimizations.stan', line 2, column 33 to line 6, column 5)",
  " (in 'optimizations.stan', line 10, column 12 to column 26)",
  " (in 'optimizations.stan', line 11, column 8 to column 21)",
  " (in 'optimizations.stan', line 16, column 8 to column 18)",
  " (in 'optimizations.stan', line 14, column 18 to line 17, column 5)"};
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::is_stan_scalar<T0__>>* = nullptr>
void
nrfun_lp(const T0__& x, const int& y, T_lp__& lp__, T_lp_accum__& lp_accum__,
         std::ostream* pstream__);
int rfun(const int& y, std::ostream* pstream__);
template <bool propto__, typename T_lp__, typename T_lp_accum__> int
rfun_lp(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_all_t<stan::is_stan_scalar<T0__>>*>
void
nrfun_lp(const T0__& x, const int& y, T_lp__& lp__, T_lp_accum__& lp_accum__,
         std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym55__;
    {
      current_statement__ = 87;
      if (stan::math::logical_gt(x, 342)) {
        current_statement__ = 86;
        return ;
      }
      current_statement__ = 7;
      lp_accum__.add(y);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int rfun(const int& y, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int lcm_sym58__;
    int lcm_sym57__;
    int lcm_sym56__;
    {
      current_statement__ = 9;
      if (stan::math::logical_gt(y, 2)) {
        current_statement__ = 89;
        return (y + 24);
      }
      current_statement__ = 90;
      return (y + 2);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <bool propto__, typename T_lp__, typename T_lp_accum__> int
rfun_lp(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 58;
    lp_accum__.add(2);
    current_statement__ = 91;
    return 24;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class optimizations_model final : public model_base_crtp<optimizations_model> {
 private:
  
 public:
  ~optimizations_model() {}
  optimizations_model(stan::io::var_context& context__, unsigned int
                      random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "optimizations_model_namespace::optimizations_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 1 + 1 + (3 * 2) + 2 + 3;
  }
  inline std::string model_name() const final {
    return "optimizations_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "optimizations_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym115__;
      double lcm_sym114__;
      double lcm_sym113__;
      double lcm_sym112__;
      double lcm_sym111__;
      double lcm_sym110__;
      double lcm_sym109__;
      double lcm_sym108__;
      double lcm_sym107__;
      double lcm_sym106__;
      double lcm_sym105__;
      int lcm_sym104__;
      int lcm_sym103__;
      int lcm_sym102__;
      int lcm_sym101__;
      int lcm_sym100__;
      int lcm_sym99__;
      int lcm_sym98__;
      int lcm_sym97__;
      int lcm_sym96__;
      int lcm_sym95__;
      int lcm_sym94__;
      int lcm_sym93__;
      int lcm_sym92__;
      local_scalar_t__ theta;
      current_statement__ = 1;
      theta = in__.template read<local_scalar_t__>();
      local_scalar_t__ phi;
      current_statement__ = 2;
      phi = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,-1> x_matrix;
      current_statement__ = 3;
      x_matrix = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(3,
                   2);
      Eigen::Matrix<local_scalar_t__,-1,1> x_vector;
      current_statement__ = 4;
      x_vector = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      Eigen::Matrix<local_scalar_t__,-1,-1> x_cov;
      current_statement__ = 5;
      x_cov = in__.template read_constrain_cov_matrix<
                Eigen::Matrix<local_scalar_t__,-1,-1>, jacobian__>(lp__, 2);
      {
        double x = std::numeric_limits<double>::quiet_NaN();
        {
          current_statement__ = 7;
          lp_accum__.add(3);
        }
        int inline_rfun_return_sym29__;
        int inline_rfun_early_ret_check_sym30__ =
          std::numeric_limits<int>::min();
        for (int inline_rfun_iterator_sym31__ = 1; inline_rfun_iterator_sym31__
             <= 1; ++inline_rfun_iterator_sym31__) {
          {
            inline_rfun_return_sym29__ = 27;
            break;
          }
          inline_rfun_return_sym29__ = 5;
          break;
        }
        if (pstream__) {
          stan::math::stan_print(pstream__, inline_rfun_return_sym29__);
          *(pstream__) << std::endl;
        }
        int inline_rfun_return_sym32__;
        int inline_rfun_early_ret_check_sym33__ =
          std::numeric_limits<int>::min();
        for (int inline_rfun_iterator_sym34__ = 1; inline_rfun_iterator_sym34__
             <= 1; ++inline_rfun_iterator_sym34__) {
          {
            inline_rfun_return_sym32__ = 28;
            break;
          }
          inline_rfun_return_sym32__ = 6;
          break;
        }
        if (inline_rfun_return_sym32__) {
          current_statement__ = 11;
          if (pstream__) {
            stan::math::stan_print(pstream__, "a");
            *(pstream__) << std::endl;
          }
        }
        int inline_rfun_return_sym35__;
        int inline_rfun_return_sym38__;
        int inline_rfun_early_ret_check_sym36__ =
          std::numeric_limits<int>::min();
        for (int inline_rfun_iterator_sym37__ = 1; inline_rfun_iterator_sym37__
             <= 1; ++inline_rfun_iterator_sym37__) {
          {
            inline_rfun_return_sym35__ = 31;
            break;
          }
          inline_rfun_return_sym35__ = 9;
          break;
        }
        int inline_rfun_early_ret_check_sym39__ =
          std::numeric_limits<int>::min();
        for (int inline_rfun_iterator_sym40__ = 1; inline_rfun_iterator_sym40__
             <= 1; ++inline_rfun_iterator_sym40__) {
          {
            inline_rfun_return_sym38__ = 29;
            break;
          }
          inline_rfun_return_sym38__ = 7;
          break;
        }
        if (stan::math::logical_gte(inline_rfun_return_sym38__,
              inline_rfun_return_sym35__)) {
          {
            int inline_rfun_return_sym41__;
            int inline_rfun_early_ret_check_sym42__ =
              std::numeric_limits<int>::min();
            for (int inline_rfun_iterator_sym43__ = 1; inline_rfun_iterator_sym43__
                 <= 1; ++inline_rfun_iterator_sym43__) {
              {
                inline_rfun_return_sym41__ = 32;
                break;
              }
              inline_rfun_return_sym41__ = 10;
              break;
            }
            lp_accum__.add(inline_rfun_return_sym41__);
            {
              current_statement__ = 7;
              lp_accum__.add(3);
            }
          }
          int inline_rfun_early_ret_check_sym39__ =
            std::numeric_limits<int>::min();
          lcm_sym101__ = (inline_rfun_return_sym35__ + 1);
          for (int inline_rfun_iterator_sym40__ = 1; inline_rfun_iterator_sym40__
               <= 1; ++inline_rfun_iterator_sym40__) {
            {
              inline_rfun_return_sym38__ = 29;
              lcm_sym101__ = (inline_rfun_return_sym35__ + 1);
              break;
            }
            inline_rfun_return_sym38__ = 7;
            lcm_sym101__ = (inline_rfun_return_sym35__ + 1);
            break;
          }
          for (int i = lcm_sym101__; i <= inline_rfun_return_sym38__; ++i) {
            {
              int inline_rfun_return_sym41__;
              int inline_rfun_early_ret_check_sym42__ =
                std::numeric_limits<int>::min();
              for (int inline_rfun_iterator_sym43__ = 1; inline_rfun_iterator_sym43__
                   <= 1; ++inline_rfun_iterator_sym43__) {
                {
                  inline_rfun_return_sym41__ = 32;
                  break;
                }
                inline_rfun_return_sym41__ = 10;
                break;
              }
              lp_accum__.add(inline_rfun_return_sym41__);
              {
                current_statement__ = 7;
                lp_accum__.add(3);
              }
            }
            int inline_rfun_early_ret_check_sym39__ =
              std::numeric_limits<int>::min();
            for (int inline_rfun_iterator_sym40__ = 1; inline_rfun_iterator_sym40__
                 <= 1; ++inline_rfun_iterator_sym40__) {
              {
                inline_rfun_return_sym38__ = 29;
                break;
              }
              inline_rfun_return_sym38__ = 7;
              break;
            }
          }
        }
        {
          current_statement__ = 14;
          lp_accum__.add(53);
          {
            current_statement__ = 14;
            lp_accum__.add(53);
          }
          {
            current_statement__ = 14;
            lp_accum__.add(53);
          }
          {
            current_statement__ = 14;
            lp_accum__.add(53);
          }
          {
            current_statement__ = 14;
            lp_accum__.add(53);
          }
        }
        {
          {
            {
              current_statement__ = 16;
              lp_accum__.add(53);
              {
                current_statement__ = 16;
                lp_accum__.add(53);
              }
            }
            {
              lcm_sym104__ = (2 * 2);
              if (stan::math::logical_gte(lcm_sym104__, 2)) {
                lcm_sym102__ = (2 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym102__; k <= lcm_sym104__; ++k) {
                  current_statement__ = 16;
                  lp_accum__.add(53);
                }
              }
            }
            {
              lcm_sym104__ = (3 * 2);
              if (stan::math::logical_gte(lcm_sym104__, 3)) {
                lcm_sym102__ = (3 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym102__; k <= lcm_sym104__; ++k) {
                  current_statement__ = 16;
                  lp_accum__.add(53);
                }
              }
            }
          }
          {
            lcm_sym100__ = (2 + 2);
            if (stan::math::logical_gte(lcm_sym100__, 2)) {
              lcm_sym103__ = (2 * 2);
              if (stan::math::logical_gte(lcm_sym103__, 2)) {
                lcm_sym99__ = (2 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym99__; k <= lcm_sym103__; ++k) {
                  current_statement__ = 16;
                  lp_accum__.add(53);
                }
              } else {
                lcm_sym99__ = (2 + 1);
              }
              for (int j = lcm_sym99__; j <= lcm_sym100__; ++j) {
                lcm_sym104__ = (j * 2);
                if (stan::math::logical_gte(lcm_sym104__, j)) {
                  lcm_sym102__ = (j + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym102__; k <= lcm_sym104__; ++k) {
                    current_statement__ = 16;
                    lp_accum__.add(53);
                  }
                }
              }
            }
          }
          {
            lcm_sym100__ = (3 + 2);
            if (stan::math::logical_gte(lcm_sym100__, 3)) {
              lcm_sym103__ = (3 * 2);
              if (stan::math::logical_gte(lcm_sym103__, 3)) {
                lcm_sym99__ = (3 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym99__; k <= lcm_sym103__; ++k) {
                  current_statement__ = 16;
                  lp_accum__.add(53);
                }
              } else {
                lcm_sym99__ = (3 + 1);
              }
              for (int j = lcm_sym99__; j <= lcm_sym100__; ++j) {
                lcm_sym104__ = (j * 2);
                if (stan::math::logical_gte(lcm_sym104__, j)) {
                  lcm_sym102__ = (j + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym102__; k <= lcm_sym104__; ++k) {
                    current_statement__ = 16;
                    lp_accum__.add(53);
                  }
                }
              }
            }
          }
          {
            lcm_sym100__ = (4 + 2);
            if (stan::math::logical_gte(lcm_sym100__, 4)) {
              lcm_sym103__ = (4 * 2);
              if (stan::math::logical_gte(lcm_sym103__, 4)) {
                lcm_sym99__ = (4 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym99__; k <= lcm_sym103__; ++k) {
                  current_statement__ = 16;
                  lp_accum__.add(53);
                }
              } else {
                lcm_sym99__ = (4 + 1);
              }
              for (int j = lcm_sym99__; j <= lcm_sym100__; ++j) {
                lcm_sym104__ = (j * 2);
                if (stan::math::logical_gte(lcm_sym104__, j)) {
                  lcm_sym102__ = (j + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym102__; k <= lcm_sym104__; ++k) {
                    current_statement__ = 16;
                    lp_accum__.add(53);
                  }
                }
              }
            }
          }
          {
            lcm_sym100__ = (5 + 2);
            if (stan::math::logical_gte(lcm_sym100__, 5)) {
              lcm_sym103__ = (5 * 2);
              if (stan::math::logical_gte(lcm_sym103__, 5)) {
                lcm_sym99__ = (5 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym99__; k <= lcm_sym103__; ++k) {
                  current_statement__ = 16;
                  lp_accum__.add(53);
                }
              } else {
                lcm_sym99__ = (5 + 1);
              }
              for (int j = lcm_sym99__; j <= lcm_sym100__; ++j) {
                lcm_sym104__ = (j * 2);
                if (stan::math::logical_gte(lcm_sym104__, j)) {
                  lcm_sym102__ = (j + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym102__; k <= lcm_sym104__; ++k) {
                    current_statement__ = 16;
                    lp_accum__.add(53);
                  }
                }
              }
            }
          }
        }
        current_statement__ = 24;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 21;
          if (stan::math::logical_gt(i, 4)) {
            break;
          }
          current_statement__ = 22;
          lp_accum__.add(2);
        }
        current_statement__ = 29;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 26;
          if (stan::math::logical_gt(i, 4)) {
            continue;
          }
          current_statement__ = 27;
          lp_accum__.add(2);
        }
        current_statement__ = 34;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 31;
          if (stan::math::logical_gt(i, 4)) {
            continue;
          }
          current_statement__ = 32;
          lp_accum__.add(2);
        }
        x = 3;
        current_statement__ = 35;
        lp_accum__.add(3);
        current_statement__ = 37;
        if (stan::math::logical_gt(theta, 2)) {
          current_statement__ = 36;
          x = 2;
        }
        current_statement__ = 38;
        lp_accum__.add(x);
        current_statement__ = 39;
        lp_accum__.add(247);
        x = 576;
        current_statement__ = 40;
        lp_accum__.add(576);
        lcm_sym98__ = stan::math::logical_gt(theta, 46);
        if (lcm_sym98__) {
          current_statement__ = 41;
          x = 5880;
        }
        current_statement__ = 42;
        lp_accum__.add(x);
        double z;
        current_statement__ = 44;
        z = x;
        current_statement__ = 45;
        lp_accum__.add(x);
        current_statement__ = 47;
        if (lcm_sym98__) {
          current_statement__ = 46;
          z = x;
        }
        current_statement__ = 48;
        lp_accum__.add(z);
        current_statement__ = 49;
        lp_accum__.add(2);
        {
          double y = std::numeric_limits<double>::quiet_NaN();
          current_statement__ = 51;
          lp_accum__.add(24);
        }
        {
          double y = std::numeric_limits<double>::quiet_NaN();
          current_statement__ = 54;
          lp_accum__.add(245);
        }
        {
          current_statement__ = 56;
          lp_accum__.add(2);
        }
        int inline_rfun_lp_return_sym45__;
        {
          current_statement__ = 58;
          lp_accum__.add(2);
        }
        current_statement__ = 59;
        while (576) {
          break;
        }
        int inline_rfun_lp_return_sym47__;
        {
          current_statement__ = 58;
          lp_accum__.add(2);
        }
        while (24) {
          {
            break;
          }
          {
            current_statement__ = 58;
            lp_accum__.add(2);
          }
        }
        current_statement__ = 62;
        for (int i = 31; i <= 225; ++i) {
          continue;
        }
        current_statement__ = 64;
        for (int i = 31; i <= 225; ++i) {
          break;
        }
        int inline_rfun_lp_return_sym49__;
        {
          current_statement__ = 58;
          lp_accum__.add(2);
        }
        for (int i = 24; i <= 225; ++i) {
          continue;
        }
        int inline_rfun_lp_return_sym51__;
        {
          current_statement__ = 58;
          lp_accum__.add(2);
        }
        for (int i = 24; i <= 225; ++i) {
          break;
        }
        int inline_rfun_lp_return_sym53__;
        {
          current_statement__ = 58;
          lp_accum__.add(2);
        }
        {
          current_statement__ = 67;
          lp_accum__.add(1);
          current_statement__ = 68;
          lp_accum__.add(24);
        }
        {
          current_statement__ = 70;
          lp_accum__.add(1);
        }
        double temp = std::numeric_limits<double>::quiet_NaN();
        {
          current_statement__ = 74;
          if (pstream__) {
            stan::math::stan_print(pstream__, "hello");
            *(pstream__) << std::endl;
          }
        }
        double temp2 = std::numeric_limits<double>::quiet_NaN();
        {
          lp_accum__.add(4);
          lp_accum__.add(6);
          {
            current_statement__ = 77;
            lp_accum__.add(4);
            current_statement__ = 78;
            lp_accum__.add(6);
          }
        }
        double dataonlyvar;
        current_statement__ = 80;
        dataonlyvar = 3;
        current_statement__ = 81;
        lp_accum__.add(dataonlyvar);
        local_scalar_t__ paramvar = DUMMY_VAR__;
        {
          current_statement__ = 83;
          paramvar = (theta * 34);
        }
        current_statement__ = 85;
        lp_accum__.add(paramvar);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "optimizations_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym91__;
      double lcm_sym90__;
      double lcm_sym89__;
      double lcm_sym88__;
      double lcm_sym87__;
      double lcm_sym86__;
      double lcm_sym85__;
      double lcm_sym84__;
      double lcm_sym83__;
      double lcm_sym82__;
      double lcm_sym81__;
      int lcm_sym80__;
      int lcm_sym79__;
      int lcm_sym78__;
      int lcm_sym77__;
      int lcm_sym76__;
      int lcm_sym75__;
      int lcm_sym74__;
      int lcm_sym73__;
      int lcm_sym72__;
      int lcm_sym71__;
      int lcm_sym70__;
      int lcm_sym69__;
      int lcm_sym68__;
      local_scalar_t__ theta;
      current_statement__ = 1;
      theta = in__.template read<local_scalar_t__>();
      local_scalar_t__ phi;
      current_statement__ = 2;
      phi = in__.template read<local_scalar_t__>();
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> x_matrix;
      current_statement__ = 3;
      x_matrix = in__.template read<
                   stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(3, 2);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> x_vector;
      current_statement__ = 4;
      x_vector = in__.template read<
                   stan::math::var_value<Eigen::Matrix<double,-1,1>>>(2);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> x_cov;
      current_statement__ = 5;
      x_cov = in__.template read_constrain_cov_matrix<
                stan::math::var_value<Eigen::Matrix<double,-1,-1>>,
                jacobian__>(lp__, 2);
      {
        double x = std::numeric_limits<double>::quiet_NaN();
        {
          current_statement__ = 7;
          lp_accum__.add(3);
        }
        int inline_rfun_return_sym2__;
        int inline_rfun_early_ret_check_sym3__ =
          std::numeric_limits<int>::min();
        for (int inline_rfun_iterator_sym4__ = 1; inline_rfun_iterator_sym4__
             <= 1; ++inline_rfun_iterator_sym4__) {
          {
            inline_rfun_return_sym2__ = 27;
            break;
          }
          inline_rfun_return_sym2__ = 5;
          break;
        }
        if (pstream__) {
          stan::math::stan_print(pstream__, inline_rfun_return_sym2__);
          *(pstream__) << std::endl;
        }
        int inline_rfun_return_sym5__;
        int inline_rfun_early_ret_check_sym6__ =
          std::numeric_limits<int>::min();
        for (int inline_rfun_iterator_sym7__ = 1; inline_rfun_iterator_sym7__
             <= 1; ++inline_rfun_iterator_sym7__) {
          {
            inline_rfun_return_sym5__ = 28;
            break;
          }
          inline_rfun_return_sym5__ = 6;
          break;
        }
        if (inline_rfun_return_sym5__) {
          current_statement__ = 11;
          if (pstream__) {
            stan::math::stan_print(pstream__, "a");
            *(pstream__) << std::endl;
          }
        }
        int inline_rfun_return_sym8__;
        int inline_rfun_return_sym11__;
        int inline_rfun_early_ret_check_sym9__ =
          std::numeric_limits<int>::min();
        for (int inline_rfun_iterator_sym10__ = 1; inline_rfun_iterator_sym10__
             <= 1; ++inline_rfun_iterator_sym10__) {
          {
            inline_rfun_return_sym8__ = 31;
            break;
          }
          inline_rfun_return_sym8__ = 9;
          break;
        }
        int inline_rfun_early_ret_check_sym12__ =
          std::numeric_limits<int>::min();
        for (int inline_rfun_iterator_sym13__ = 1; inline_rfun_iterator_sym13__
             <= 1; ++inline_rfun_iterator_sym13__) {
          {
            inline_rfun_return_sym11__ = 29;
            break;
          }
          inline_rfun_return_sym11__ = 7;
          break;
        }
        if (stan::math::logical_gte(inline_rfun_return_sym11__,
              inline_rfun_return_sym8__)) {
          {
            int inline_rfun_return_sym14__;
            int inline_rfun_early_ret_check_sym15__ =
              std::numeric_limits<int>::min();
            for (int inline_rfun_iterator_sym16__ = 1; inline_rfun_iterator_sym16__
                 <= 1; ++inline_rfun_iterator_sym16__) {
              {
                inline_rfun_return_sym14__ = 32;
                break;
              }
              inline_rfun_return_sym14__ = 10;
              break;
            }
            lp_accum__.add(inline_rfun_return_sym14__);
            {
              current_statement__ = 7;
              lp_accum__.add(3);
            }
          }
          int inline_rfun_early_ret_check_sym12__ =
            std::numeric_limits<int>::min();
          lcm_sym77__ = (inline_rfun_return_sym8__ + 1);
          for (int inline_rfun_iterator_sym13__ = 1; inline_rfun_iterator_sym13__
               <= 1; ++inline_rfun_iterator_sym13__) {
            {
              inline_rfun_return_sym11__ = 29;
              lcm_sym77__ = (inline_rfun_return_sym8__ + 1);
              break;
            }
            inline_rfun_return_sym11__ = 7;
            lcm_sym77__ = (inline_rfun_return_sym8__ + 1);
            break;
          }
          for (int i = lcm_sym77__; i <= inline_rfun_return_sym11__; ++i) {
            {
              int inline_rfun_return_sym14__;
              int inline_rfun_early_ret_check_sym15__ =
                std::numeric_limits<int>::min();
              for (int inline_rfun_iterator_sym16__ = 1; inline_rfun_iterator_sym16__
                   <= 1; ++inline_rfun_iterator_sym16__) {
                {
                  inline_rfun_return_sym14__ = 32;
                  break;
                }
                inline_rfun_return_sym14__ = 10;
                break;
              }
              lp_accum__.add(inline_rfun_return_sym14__);
              {
                current_statement__ = 7;
                lp_accum__.add(3);
              }
            }
            int inline_rfun_early_ret_check_sym12__ =
              std::numeric_limits<int>::min();
            for (int inline_rfun_iterator_sym13__ = 1; inline_rfun_iterator_sym13__
                 <= 1; ++inline_rfun_iterator_sym13__) {
              {
                inline_rfun_return_sym11__ = 29;
                break;
              }
              inline_rfun_return_sym11__ = 7;
              break;
            }
          }
        }
        {
          current_statement__ = 14;
          lp_accum__.add(53);
          {
            current_statement__ = 14;
            lp_accum__.add(53);
          }
          {
            current_statement__ = 14;
            lp_accum__.add(53);
          }
          {
            current_statement__ = 14;
            lp_accum__.add(53);
          }
          {
            current_statement__ = 14;
            lp_accum__.add(53);
          }
        }
        {
          {
            {
              current_statement__ = 16;
              lp_accum__.add(53);
              {
                current_statement__ = 16;
                lp_accum__.add(53);
              }
            }
            {
              lcm_sym80__ = (2 * 2);
              if (stan::math::logical_gte(lcm_sym80__, 2)) {
                lcm_sym78__ = (2 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym78__; k <= lcm_sym80__; ++k) {
                  current_statement__ = 16;
                  lp_accum__.add(53);
                }
              }
            }
            {
              lcm_sym80__ = (3 * 2);
              if (stan::math::logical_gte(lcm_sym80__, 3)) {
                lcm_sym78__ = (3 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym78__; k <= lcm_sym80__; ++k) {
                  current_statement__ = 16;
                  lp_accum__.add(53);
                }
              }
            }
          }
          {
            lcm_sym76__ = (2 + 2);
            if (stan::math::logical_gte(lcm_sym76__, 2)) {
              lcm_sym79__ = (2 * 2);
              if (stan::math::logical_gte(lcm_sym79__, 2)) {
                lcm_sym75__ = (2 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym75__; k <= lcm_sym79__; ++k) {
                  current_statement__ = 16;
                  lp_accum__.add(53);
                }
              } else {
                lcm_sym75__ = (2 + 1);
              }
              for (int j = lcm_sym75__; j <= lcm_sym76__; ++j) {
                lcm_sym80__ = (j * 2);
                if (stan::math::logical_gte(lcm_sym80__, j)) {
                  lcm_sym78__ = (j + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym78__; k <= lcm_sym80__; ++k) {
                    current_statement__ = 16;
                    lp_accum__.add(53);
                  }
                }
              }
            }
          }
          {
            lcm_sym76__ = (3 + 2);
            if (stan::math::logical_gte(lcm_sym76__, 3)) {
              lcm_sym79__ = (3 * 2);
              if (stan::math::logical_gte(lcm_sym79__, 3)) {
                lcm_sym75__ = (3 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym75__; k <= lcm_sym79__; ++k) {
                  current_statement__ = 16;
                  lp_accum__.add(53);
                }
              } else {
                lcm_sym75__ = (3 + 1);
              }
              for (int j = lcm_sym75__; j <= lcm_sym76__; ++j) {
                lcm_sym80__ = (j * 2);
                if (stan::math::logical_gte(lcm_sym80__, j)) {
                  lcm_sym78__ = (j + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym78__; k <= lcm_sym80__; ++k) {
                    current_statement__ = 16;
                    lp_accum__.add(53);
                  }
                }
              }
            }
          }
          {
            lcm_sym76__ = (4 + 2);
            if (stan::math::logical_gte(lcm_sym76__, 4)) {
              lcm_sym79__ = (4 * 2);
              if (stan::math::logical_gte(lcm_sym79__, 4)) {
                lcm_sym75__ = (4 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym75__; k <= lcm_sym79__; ++k) {
                  current_statement__ = 16;
                  lp_accum__.add(53);
                }
              } else {
                lcm_sym75__ = (4 + 1);
              }
              for (int j = lcm_sym75__; j <= lcm_sym76__; ++j) {
                lcm_sym80__ = (j * 2);
                if (stan::math::logical_gte(lcm_sym80__, j)) {
                  lcm_sym78__ = (j + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym78__; k <= lcm_sym80__; ++k) {
                    current_statement__ = 16;
                    lp_accum__.add(53);
                  }
                }
              }
            }
          }
          {
            lcm_sym76__ = (5 + 2);
            if (stan::math::logical_gte(lcm_sym76__, 5)) {
              lcm_sym79__ = (5 * 2);
              if (stan::math::logical_gte(lcm_sym79__, 5)) {
                lcm_sym75__ = (5 + 1);
                lp_accum__.add(53);
                for (int k = lcm_sym75__; k <= lcm_sym79__; ++k) {
                  current_statement__ = 16;
                  lp_accum__.add(53);
                }
              } else {
                lcm_sym75__ = (5 + 1);
              }
              for (int j = lcm_sym75__; j <= lcm_sym76__; ++j) {
                lcm_sym80__ = (j * 2);
                if (stan::math::logical_gte(lcm_sym80__, j)) {
                  lcm_sym78__ = (j + 1);
                  lp_accum__.add(53);
                  for (int k = lcm_sym78__; k <= lcm_sym80__; ++k) {
                    current_statement__ = 16;
                    lp_accum__.add(53);
                  }
                }
              }
            }
          }
        }
        current_statement__ = 24;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 21;
          if (stan::math::logical_gt(i, 4)) {
            break;
          }
          current_statement__ = 22;
          lp_accum__.add(2);
        }
        current_statement__ = 29;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 26;
          if (stan::math::logical_gt(i, 4)) {
            continue;
          }
          current_statement__ = 27;
          lp_accum__.add(2);
        }
        current_statement__ = 34;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 31;
          if (stan::math::logical_gt(i, 4)) {
            continue;
          }
          current_statement__ = 32;
          lp_accum__.add(2);
        }
        x = 3;
        current_statement__ = 35;
        lp_accum__.add(3);
        current_statement__ = 37;
        if (stan::math::logical_gt(theta, 2)) {
          current_statement__ = 36;
          x = 2;
        }
        current_statement__ = 38;
        lp_accum__.add(x);
        current_statement__ = 39;
        lp_accum__.add(247);
        x = 576;
        current_statement__ = 40;
        lp_accum__.add(576);
        lcm_sym74__ = stan::math::logical_gt(theta, 46);
        if (lcm_sym74__) {
          current_statement__ = 41;
          x = 5880;
        }
        current_statement__ = 42;
        lp_accum__.add(x);
        double z;
        current_statement__ = 44;
        z = x;
        current_statement__ = 45;
        lp_accum__.add(x);
        current_statement__ = 47;
        if (lcm_sym74__) {
          current_statement__ = 46;
          z = x;
        }
        current_statement__ = 48;
        lp_accum__.add(z);
        current_statement__ = 49;
        lp_accum__.add(2);
        {
          double y = std::numeric_limits<double>::quiet_NaN();
          current_statement__ = 51;
          lp_accum__.add(24);
        }
        {
          double y = std::numeric_limits<double>::quiet_NaN();
          current_statement__ = 54;
          lp_accum__.add(245);
        }
        {
          current_statement__ = 56;
          lp_accum__.add(2);
        }
        int inline_rfun_lp_return_sym18__;
        {
          current_statement__ = 58;
          lp_accum__.add(2);
        }
        current_statement__ = 59;
        while (576) {
          break;
        }
        int inline_rfun_lp_return_sym20__;
        {
          current_statement__ = 58;
          lp_accum__.add(2);
        }
        while (24) {
          {
            break;
          }
          {
            current_statement__ = 58;
            lp_accum__.add(2);
          }
        }
        current_statement__ = 62;
        for (int i = 31; i <= 225; ++i) {
          continue;
        }
        current_statement__ = 64;
        for (int i = 31; i <= 225; ++i) {
          break;
        }
        int inline_rfun_lp_return_sym22__;
        {
          current_statement__ = 58;
          lp_accum__.add(2);
        }
        for (int i = 24; i <= 225; ++i) {
          continue;
        }
        int inline_rfun_lp_return_sym24__;
        {
          current_statement__ = 58;
          lp_accum__.add(2);
        }
        for (int i = 24; i <= 225; ++i) {
          break;
        }
        int inline_rfun_lp_return_sym26__;
        {
          current_statement__ = 58;
          lp_accum__.add(2);
        }
        {
          current_statement__ = 67;
          lp_accum__.add(1);
          current_statement__ = 68;
          lp_accum__.add(24);
        }
        {
          current_statement__ = 70;
          lp_accum__.add(1);
        }
        double temp = std::numeric_limits<double>::quiet_NaN();
        {
          current_statement__ = 74;
          if (pstream__) {
            stan::math::stan_print(pstream__, "hello");
            *(pstream__) << std::endl;
          }
        }
        double temp2 = std::numeric_limits<double>::quiet_NaN();
        {
          lp_accum__.add(4);
          lp_accum__.add(6);
          {
            current_statement__ = 77;
            lp_accum__.add(4);
            current_statement__ = 78;
            lp_accum__.add(6);
          }
        }
        double dataonlyvar;
        current_statement__ = 80;
        dataonlyvar = 3;
        current_statement__ = 81;
        lp_accum__.add(dataonlyvar);
        local_scalar_t__ paramvar = DUMMY_VAR__;
        {
          current_statement__ = 83;
          paramvar = (theta * 34);
        }
        current_statement__ = 85;
        lp_accum__.add(paramvar);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "optimizations_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym67__;
      int lcm_sym66__;
      double theta;
      current_statement__ = 1;
      theta = in__.template read<local_scalar_t__>();
      double phi;
      current_statement__ = 2;
      phi = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,-1> x_matrix;
      current_statement__ = 3;
      x_matrix = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(3,
                   2);
      Eigen::Matrix<double,-1,1> x_vector;
      current_statement__ = 4;
      x_vector = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      Eigen::Matrix<double,-1,-1> x_cov;
      current_statement__ = 5;
      x_cov = in__.template read_constrain_cov_matrix<
                Eigen::Matrix<local_scalar_t__,-1,-1>, jacobian__>(lp__, 2);
      out__.write(theta);
      out__.write(phi);
      out__.write(x_matrix);
      out__.write(x_vector);
      out__.write(x_cov);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ theta;
      current_statement__ = 1;
      theta = in__.read<local_scalar_t__>();
      out__.write(theta);
      local_scalar_t__ phi;
      current_statement__ = 2;
      phi = in__.read<local_scalar_t__>();
      out__.write(phi);
      Eigen::Matrix<local_scalar_t__,-1,-1> x_matrix;
      current_statement__ = 3;
      stan::model::assign(x_matrix,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(3, 2),
        "assigning variable x_matrix");
      out__.write(x_matrix);
      Eigen::Matrix<local_scalar_t__,-1,1> x_vector;
      current_statement__ = 4;
      stan::model::assign(x_vector,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(2),
        "assigning variable x_vector");
      out__.write(x_vector);
      Eigen::Matrix<local_scalar_t__,-1,-1> x_cov;
      current_statement__ = 5;
      stan::model::assign(x_cov,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(2, 2),
        "assigning variable x_cov");
      out__.write_free_cov_matrix(x_cov);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "theta", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "phi", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "x_matrix",
        "double",
        std::vector<size_t>{static_cast<size_t>(3), static_cast<size_t>(2)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "x_vector",
        "double", std::vector<size_t>{static_cast<size_t>(2)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "x_cov", "double",
        std::vector<size_t>{static_cast<size_t>(2), static_cast<size_t>(2)});
      double lcm_sym65__;
      double lcm_sym64__;
      double lcm_sym63__;
      double lcm_sym62__;
      double lcm_sym61__;
      double lcm_sym60__;
      int lcm_sym59__;
      int pos__ = std::numeric_limits<int>::min();
      local_scalar_t__ theta;
      current_statement__ = 1;
      theta = context__.vals_r("theta")[(1 - 1)];
      out__.write(theta);
      local_scalar_t__ phi;
      current_statement__ = 2;
      phi = context__.vals_r("phi")[(1 - 1)];
      out__.write(phi);
      Eigen::Matrix<local_scalar_t__,-1,-1> x_matrix =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(3, 2, DUMMY_VAR__);
      {
        std::vector<double> x_matrix_flat__;
        current_statement__ = 3;
        x_matrix_flat__ = context__.vals_r("x_matrix");
        {
          {
            stan::model::assign(x_matrix,
              stan::model::rvalue(x_matrix_flat__, "x_matrix_flat__",
                stan::model::index_uni(1)), "assigning variable x_matrix",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            {
              stan::model::assign(x_matrix, x_matrix_flat__[(pos__ - 1)],
                "assigning variable x_matrix", stan::model::index_uni(2),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(x_matrix, x_matrix_flat__[(pos__ - 1)],
                "assigning variable x_matrix", stan::model::index_uni(3),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(x_matrix, x_matrix_flat__[(pos__ - 1)],
              "assigning variable x_matrix", stan::model::index_uni(1),
              stan::model::index_uni(2));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(x_matrix, x_matrix_flat__[(pos__ - 1)],
                "assigning variable x_matrix", stan::model::index_uni(2),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(x_matrix, x_matrix_flat__[(pos__ - 1)],
                "assigning variable x_matrix", stan::model::index_uni(3),
                stan::model::index_uni(2));
            }
          }
        }
      }
      out__.write(x_matrix);
      Eigen::Matrix<local_scalar_t__,-1,1> x_vector =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      {
        std::vector<double> x_vector_flat__;
        current_statement__ = 4;
        x_vector_flat__ = context__.vals_r("x_vector");
        {
          stan::model::assign(x_vector,
            stan::model::rvalue(x_vector_flat__, "x_vector_flat__",
              stan::model::index_uni(1)), "assigning variable x_vector",
            stan::model::index_uni(1));
          pos__ = 2;
          {
            stan::model::assign(x_vector, x_vector_flat__[(pos__ - 1)],
              "assigning variable x_vector", stan::model::index_uni(2));
          }
        }
      }
      out__.write(x_vector);
      Eigen::Matrix<local_scalar_t__,-1,-1> x_cov =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__);
      {
        std::vector<double> x_cov_flat__;
        current_statement__ = 5;
        x_cov_flat__ = context__.vals_r("x_cov");
        {
          {
            stan::model::assign(x_cov,
              stan::model::rvalue(x_cov_flat__, "x_cov_flat__",
                stan::model::index_uni(1)), "assigning variable x_cov",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            {
              stan::model::assign(x_cov, x_cov_flat__[(pos__ - 1)],
                "assigning variable x_cov", stan::model::index_uni(2),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(x_cov, x_cov_flat__[(pos__ - 1)],
              "assigning variable x_cov", stan::model::index_uni(1),
              stan::model::index_uni(2));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(x_cov, x_cov_flat__[(pos__ - 1)],
                "assigning variable x_cov", stan::model::index_uni(2),
                stan::model::index_uni(2));
            }
          }
        }
      }
      out__.write_free_cov_matrix(x_cov);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"theta", "phi", "x_matrix",
                "x_vector", "x_cov"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(3),
                  static_cast<size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(2),
                  static_cast<size_t>(2)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "theta");
    param_names__.emplace_back(std::string() + "phi");
    for (int sym116__ = 1; sym116__ <= 2; ++sym116__) {
      for (int sym117__ = 1; sym117__ <= 3; ++sym117__) {
        param_names__.emplace_back(std::string() + "x_matrix" + '.' +
          std::to_string(sym117__) + '.' + std::to_string(sym116__));
      }
    }
    for (int sym116__ = 1; sym116__ <= 2; ++sym116__) {
      param_names__.emplace_back(std::string() + "x_vector" + '.' +
        std::to_string(sym116__));
    }
    for (int sym116__ = 1; sym116__ <= 2; ++sym116__) {
      for (int sym117__ = 1; sym117__ <= 2; ++sym117__) {
        param_names__.emplace_back(std::string() + "x_cov" + '.' +
          std::to_string(sym117__) + '.' + std::to_string(sym116__));
      }
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "theta");
    param_names__.emplace_back(std::string() + "phi");
    for (int sym116__ = 1; sym116__ <= 2; ++sym116__) {
      for (int sym117__ = 1; sym117__ <= 3; ++sym117__) {
        param_names__.emplace_back(std::string() + "x_matrix" + '.' +
          std::to_string(sym117__) + '.' + std::to_string(sym116__));
      }
    }
    for (int sym116__ = 1; sym116__ <= 2; ++sym116__) {
      param_names__.emplace_back(std::string() + "x_vector" + '.' +
        std::to_string(sym116__));
    }
    for (int sym116__ = 1; sym116__ <= 3; ++sym116__) {
      param_names__.emplace_back(std::string() + "x_cov" + '.' +
        std::to_string(sym116__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_matrix\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"x_vector\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"x_cov\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(2) + "},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_matrix\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"x_vector\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"x_cov\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(3) + "},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((1 + 1) + (3 * 2)) + 2) + (2 * 2));
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((1 + 1) + (3 * 2)) + 2) + (2 * 2));
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = optimizations_model_namespace::optimizations_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return optimizations_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp overloaded-fn.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace overloaded_fn_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 6> locations_array__ =
  {" (found before start of program)",
  " (in 'overloaded-fn.stan', line 13, column 2 to column 22)",
  " (in 'overloaded-fn.stan', line 3, column 5 to column 20)",
  " (in 'overloaded-fn.stan', line 2, column 20 to line 4, column 4)",
  " (in 'overloaded-fn.stan', line 7, column 5 to column 20)",
  " (in 'overloaded-fn.stan', line 6, column 19 to line 8, column 4)"};
template <typename T0__,
          stan::require_all_t<stan::is_stan_scalar<T0__>>* = nullptr>
stan::promote_args_t<T0__> dumb(const T0__& x, std::ostream* pstream__);
double dumb(const int& x, std::ostream* pstream__);
template <typename T0__, stan::require_all_t<stan::is_stan_scalar<T0__>>*>
stan::promote_args_t<T0__> dumb(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym1__;
    {
      current_statement__ = 2;
      return (x + 0.5);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
double dumb(const int& x, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym2__;
    {
      current_statement__ = 4;
      return (x - 0.5);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class overloaded_fn_model final : public model_base_crtp<overloaded_fn_model> {
 private:
  
 public:
  ~overloaded_fn_model() {}
  overloaded_fn_model(stan::io::var_context& context__, unsigned int
                      random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "overloaded_fn_model_namespace::overloaded_fn_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "overloaded_fn_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "overloaded_fn_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym6__;
      {
        current_statement__ = 1;
        lp_accum__.add(dumb(1.0, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "overloaded_fn_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym5__;
      {
        current_statement__ = 1;
        lp_accum__.add(dumb(1.0, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "overloaded_fn_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym4__;
      int lcm_sym3__;
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = overloaded_fn_model_namespace::overloaded_fn_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return overloaded_fn_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp overloaded-fn2.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace overloaded_fn2_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 8> locations_array__ =
  {" (found before start of program)",
  " (in 'overloaded-fn2.stan', line 7, column 4 to column 26)",
  " (in 'overloaded-fn2.stan', line 14, column 2 to column 11)",
  " (in 'overloaded-fn2.stan', line 3, column 4 to column 18)",
  " (in 'overloaded-fn2.stan', line 2, column 21 to line 4, column 3)",
  " (in 'overloaded-fn2.stan', line 5, column 16 to line 8, column 3)",
  " (in 'overloaded-fn2.stan', line 10, column 4 to column 16)",
  " (in 'overloaded-fn2.stan', line 9, column 21 to line 11, column 3)"};
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& x_arg__, std::ostream* pstream__);
template <bool propto__, typename T_lp__, typename T_lp_accum__> void
bar_lp(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_stan_scalar<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T0__>,-1,1>
foo(const T0__& x, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
stan::promote_args_t<stan::base_type_t<T0__>>
foo(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& x = stan::math::to_ref(x_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym3__;
    {
      current_statement__ = 3;
      return stan::math::sum(x);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <bool propto__, typename T_lp__, typename T_lp_accum__> void
bar_lp(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    double lcm_sym4__;
    {
      current_statement__ = 1;
      lp_accum__.add(stan::model::rvalue(foo(1.0, pstream__), "foo(1.0)",
                       stan::model::index_uni(1)));
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, stan::require_all_t<stan::is_stan_scalar<T0__>>*>
Eigen::Matrix<stan::promote_args_t<T0__>,-1,1>
foo(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    Eigen::Matrix<double,-1,1> lcm_sym5__;
    {
      current_statement__ = 6;
      return (Eigen::Matrix<local_scalar_t__,-1,1>(1) << x).finished();
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class overloaded_fn2_model final : public model_base_crtp<overloaded_fn2_model> {
 private:
  
 public:
  ~overloaded_fn2_model() {}
  overloaded_fn2_model(stan::io::var_context& context__, unsigned int
                       random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "overloaded_fn2_model_namespace::overloaded_fn2_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "overloaded_fn2_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "overloaded_fn2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym9__;
      {
        current_statement__ = 1;
        lp_accum__.add(stan::model::rvalue(foo(1.0, pstream__), "foo(1.0)",
                         stan::model::index_uni(1)));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "overloaded_fn2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym8__;
      {
        current_statement__ = 1;
        lp_accum__.add(stan::model::rvalue(foo(1.0, pstream__), "foo(1.0)",
                         stan::model::index_uni(1)));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "overloaded_fn2_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym7__;
      int lcm_sym6__;
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = overloaded_fn2_model_namespace::overloaded_fn2_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return overloaded_fn2_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp partial-eval-tuple.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace partial_eval_tuple_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 5> locations_array__ =
  {" (found before start of program)",
  " (in 'partial-eval-tuple.stan', line 2, column 2 to column 31)",
  " (in 'partial-eval-tuple.stan', line 3, column 2 to column 12)",
  " (in 'partial-eval-tuple.stan', line 6, column 3 to column 26)",
  " (in 'partial-eval-tuple.stan', line 7, column 3 to column 17)"};
class partial_eval_tuple_model final : public model_base_crtp<partial_eval_tuple_model> {
 private:
  
 public:
  ~partial_eval_tuple_model() {}
  partial_eval_tuple_model(stan::io::var_context& context__, unsigned int
                           random_seed__ = 0, std::ostream*
                           pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "partial_eval_tuple_model_namespace::partial_eval_tuple_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "partial_eval_tuple_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "partial_eval_tuple_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym6__;
      std::tuple<double, Eigen::Matrix<double,-1,-1>> x;
      current_statement__ = 2;
      std::get<0>(x) = 0.4;
      {
        current_statement__ = 3;
        lp_accum__.add(0.3);
        current_statement__ = 4;
        lp_accum__.add(std::get<0>(x));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "partial_eval_tuple_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym5__;
      std::tuple<double, Eigen::Matrix<double,-1,-1>> x;
      current_statement__ = 2;
      std::get<0>(x) = 0.4;
      {
        current_statement__ = 3;
        lp_accum__.add(0.3);
        current_statement__ = 4;
        lp_accum__.add(std::get<0>(x));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "partial_eval_tuple_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> lcm_sym4__;
      double lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      std::tuple<double, Eigen::Matrix<double,-1,-1>> x =
        std::tuple<double, Eigen::Matrix<double,-1,-1>>{std::numeric_limits<double>::quiet_NaN(
                                                          ),
          Eigen::Matrix<double,-1,-1>::Constant(10, 10,
            std::numeric_limits<double>::quiet_NaN())};
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 2;
      std::get<0>(x) = 0.4;
      if (emit_transformed_parameters__) {
        out__.write(std::get<0>(x));
        out__.write(std::get<1>(x));
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"x.1", "x.2"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "x" + ':' +
        std::to_string(1));
      for (int sym7__ = 1; sym7__ <= 10; ++sym7__) {
        for (int sym8__ = 1; sym8__ <= 10; ++sym8__) {
          param_names__.emplace_back(std::string() + "x" + ':' +
            std::to_string(2) + '.' + std::to_string(sym8__) + '.' +
            std::to_string(sym7__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "x" + ':' +
        std::to_string(1));
      for (int sym7__ = 1; sym7__ <= 10; ++sym7__) {
        for (int sym8__ = 1; sym8__ <= 10; ++sym8__) {
          param_names__.emplace_back(std::string() + "x" + ':' +
            std::to_string(2) + '.' + std::to_string(sym8__) + '.' +
            std::to_string(sym7__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"tuple\",\"num_elements\":\"2\",\"element_types\":[{\"name\":\"real\"},{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "}]},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"tuple\",\"num_elements\":\"2\",\"element_types\":[{\"name\":\"real\"},{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "}]},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * ((1 + (10 *
      10)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * ((1 + (10 *
      10)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = partial_eval_tuple_model_namespace::partial_eval_tuple_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return partial_eval_tuple_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp partial-eval.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace partial_eval_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 28> locations_array__ =
  {" (found before start of program)",
  " (in 'partial-eval.stan', line 10, column 2 to column 19)",
  " (in 'partial-eval.stan', line 11, column 2 to column 17)",
  " (in 'partial-eval.stan', line 12, column 2 to column 12)",
  " (in 'partial-eval.stan', line 13, column 2 to column 35)",
  " (in 'partial-eval.stan', line 14, column 2 to column 35)",
  " (in 'partial-eval.stan', line 17, column 2 to column 18)",
  " (in 'partial-eval.stan', line 20, column 4 to column 75)",
  " (in 'partial-eval.stan', line 19, column 2 to line 20, column 75)",
  " (in 'partial-eval.stan', line 24, column 2 to column 22)",
  " (in 'partial-eval.stan', line 25, column 2 to column 34)",
  " (in 'partial-eval.stan', line 26, column 2 to column 24)",
  " (in 'partial-eval.stan', line 27, column 2 to column 29)",
  " (in 'partial-eval.stan', line 29, column 2 to column 25)",
  " (in 'partial-eval.stan', line 30, column 2 to column 11)",
  " (in 'partial-eval.stan', line 32, column 2 to column 24)",
  " (in 'partial-eval.stan', line 2, column 2 to column 17)",
  " (in 'partial-eval.stan', line 3, column 2 to column 22)",
  " (in 'partial-eval.stan', line 4, column 8 to column 9)",
  " (in 'partial-eval.stan', line 4, column 2 to column 43)",
  " (in 'partial-eval.stan', line 5, column 9 to column 10)",
  " (in 'partial-eval.stan', line 5, column 2 to column 21)",
  " (in 'partial-eval.stan', line 6, column 27 to column 28)",
  " (in 'partial-eval.stan', line 6, column 2 to column 40)",
  " (in 'partial-eval.stan', line 7, column 9 to column 10)",
  " (in 'partial-eval.stan', line 7, column 2 to column 14)",
  " (in 'partial-eval.stan', line 10, column 9 to column 15)",
  " (in 'partial-eval.stan', line 17, column 9 to column 10)"};
class partial_eval_model final : public model_base_crtp<partial_eval_model> {
 private:
  double lcm_sym39__;
  double lcm_sym38__;
  double lcm_sym37__;
  double lcm_sym36__;
  double lcm_sym35__;
  double lcm_sym34__;
  int lcm_sym33__;
  int lcm_sym32__;
  int N;
  int n_pair;
  std::vector<int> pair;
  Eigen::Matrix<double,-1,1> pre_test_data__;
  Eigen::Matrix<double,-1,1> treatment_data__;
  Eigen::Matrix<double,-1,1> y_data__;
  Eigen::Map<Eigen::Matrix<double,-1,1>> pre_test{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> treatment{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> y{nullptr, 0};
 public:
  ~partial_eval_model() {}
  partial_eval_model(stan::io::var_context& context__, unsigned int
                     random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "partial_eval_model_namespace::partial_eval_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 16;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 16;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 16;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 17;
      context__.validate_dims("data initialization", "n_pair", "int",
        std::vector<size_t>{});
      n_pair = std::numeric_limits<int>::min();
      current_statement__ = 17;
      n_pair = context__.vals_i("n_pair")[(1 - 1)];
      current_statement__ = 17;
      stan::math::check_greater_or_equal(function__, "n_pair", n_pair, 0);
      current_statement__ = 18;
      stan::math::validate_non_negative_index("pair", "N", N);
      current_statement__ = 19;
      context__.validate_dims("data initialization", "pair", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      pair = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 19;
      pair = context__.vals_i("pair");
      current_statement__ = 19;
      stan::math::check_greater_or_equal(function__, "pair", pair, 1);
      current_statement__ = 19;
      stan::math::check_less_or_equal(function__, "pair", pair, n_pair);
      current_statement__ = 20;
      stan::math::validate_non_negative_index("pre_test", "N", N);
      current_statement__ = 21;
      context__.validate_dims("data initialization", "pre_test", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      pre_test_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                          std::numeric_limits<double>::quiet_NaN());
      new (&pre_test)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(pre_test_data__.data(), N);
      {
        std::vector<double> pre_test_flat__;
        current_statement__ = 21;
        pre_test_flat__ = context__.vals_r("pre_test");
        pos__ = 1;
        lcm_sym32__ = stan::math::logical_gte(N, 1);
        if (lcm_sym32__) {
          stan::model::assign(pre_test,
            stan::model::rvalue(pre_test_flat__, "pre_test_flat__",
              stan::model::index_uni(1)), "assigning variable pre_test",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(pre_test, pre_test_flat__[(pos__ - 1)],
              "assigning variable pre_test", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 22;
      stan::math::validate_non_negative_index("treatment", "N", N);
      current_statement__ = 23;
      context__.validate_dims("data initialization", "treatment", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      treatment_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                           std::numeric_limits<double>::quiet_NaN());
      new (&treatment)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(treatment_data__.data(), N);
      {
        std::vector<double> treatment_flat__;
        current_statement__ = 23;
        treatment_flat__ = context__.vals_r("treatment");
        pos__ = 1;
        if (lcm_sym32__) {
          stan::model::assign(treatment,
            stan::model::rvalue(treatment_flat__, "treatment_flat__",
              stan::model::index_uni(1)), "assigning variable treatment",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(treatment, treatment_flat__[(pos__ - 1)],
              "assigning variable treatment", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "treatment", treatment,
        0);
      current_statement__ = 23;
      stan::math::check_less_or_equal(function__, "treatment", treatment, 1);
      current_statement__ = 24;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 25;
      context__.validate_dims("data initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      y_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                   std::numeric_limits<double>::quiet_NaN());
      new (&y) Eigen::Map<Eigen::Matrix<double,-1,1>>(y_data__.data(), N);
      {
        std::vector<double> y_flat__;
        current_statement__ = 25;
        y_flat__ = context__.vals_r("y");
        pos__ = 1;
        if (lcm_sym32__) {
          stan::model::assign(y,
            stan::model::rvalue(y_flat__, "y_flat__",
              stan::model::index_uni(1)), "assigning variable y",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= N; ++sym1__) {
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 26;
      stan::math::validate_non_negative_index("a", "n_pair", n_pair);
      current_statement__ = 27;
      stan::math::validate_non_negative_index("y_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = n_pair + 2 + 1 + 1 + 1;
  }
  inline std::string model_name() const final {
    return "partial_eval_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "partial_eval_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::complex<double> lcm_sym31__;
      std::complex<double> lcm_sym30__;
      double lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      double lcm_sym24__;
      double lcm_sym23__;
      int lcm_sym22__;
      Eigen::Matrix<local_scalar_t__,-1,1> a;
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_pair);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 2;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      local_scalar_t__ mu_a;
      current_statement__ = 3;
      mu_a = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma_a;
      current_statement__ = 4;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_y;
      current_statement__ = 5;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> y_hat =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 8;
      if (stan::math::logical_gte(N, 1)) {
        current_statement__ = 7;
        stan::model::assign(y_hat,
          stan::math::fma(
            stan::model::rvalue(beta, "beta", stan::model::index_uni(2)),
            stan::model::rvalue(pre_test, "pre_test",
              stan::model::index_uni(1)),
            stan::math::fma(
              stan::model::rvalue(beta, "beta", stan::model::index_uni(1)),
              stan::model::rvalue(treatment, "treatment",
                stan::model::index_uni(1)),
              stan::model::rvalue(a, "a",
                stan::model::index_uni(
                  stan::model::rvalue(pair, "pair", stan::model::index_uni(1)))))),
          "assigning variable y_hat", stan::model::index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 7;
          stan::model::assign(y_hat,
            stan::math::fma(
              stan::model::rvalue(beta, "beta", stan::model::index_uni(2)),
              stan::model::rvalue(pre_test, "pre_test",
                stan::model::index_uni(i)),
              stan::math::fma(
                stan::model::rvalue(beta, "beta", stan::model::index_uni(1)),
                stan::model::rvalue(treatment, "treatment",
                  stan::model::index_uni(i)),
                stan::model::rvalue(a, "a",
                  stan::model::index_uni(
                    stan::model::rvalue(pair, "pair",
                      stan::model::index_uni(i)))))),
            "assigning variable y_hat", stan::model::index_uni(i));
        }
      }
      {
        current_statement__ = 9;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu_a, 0, 1));
        current_statement__ = 10;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(a, (100 * mu_a),
                         sigma_a));
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(beta, 0, 100));
        current_statement__ = 12;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, y_hat, sigma_y));
        std::complex<double> z =
          std::complex<double>(std::numeric_limits<double>::quiet_NaN(),
            std::numeric_limits<double>::quiet_NaN());
        lcm_sym31__ = stan::math::to_complex(7, 5);
        current_statement__ = 14;
        if (pstream__) {
          stan::math::stan_print(pstream__, lcm_sym31__);
          *(pstream__) << std::endl;
        }
        lcm_sym30__ = stan::math::to_complex(5, 4);
        current_statement__ = 15;
        lp_accum__.add(stan::math::get_real(lcm_sym30__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "partial_eval_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::complex<double> lcm_sym21__;
      std::complex<double> lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      int lcm_sym12__;
      Eigen::Matrix<local_scalar_t__,-1,1> a;
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_pair);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 2;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      local_scalar_t__ mu_a;
      current_statement__ = 3;
      mu_a = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma_a;
      current_statement__ = 4;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_y;
      current_statement__ = 5;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> y_hat =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 8;
      if (stan::math::logical_gte(N, 1)) {
        current_statement__ = 7;
        stan::model::assign(y_hat,
          stan::math::fma(
            stan::model::rvalue(beta, "beta", stan::model::index_uni(2)),
            stan::model::rvalue(pre_test, "pre_test",
              stan::model::index_uni(1)),
            stan::math::fma(
              stan::model::rvalue(beta, "beta", stan::model::index_uni(1)),
              stan::model::rvalue(treatment, "treatment",
                stan::model::index_uni(1)),
              stan::model::rvalue(a, "a",
                stan::model::index_uni(
                  stan::model::rvalue(pair, "pair", stan::model::index_uni(1)))))),
          "assigning variable y_hat", stan::model::index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 7;
          stan::model::assign(y_hat,
            stan::math::fma(
              stan::model::rvalue(beta, "beta", stan::model::index_uni(2)),
              stan::model::rvalue(pre_test, "pre_test",
                stan::model::index_uni(i)),
              stan::math::fma(
                stan::model::rvalue(beta, "beta", stan::model::index_uni(1)),
                stan::model::rvalue(treatment, "treatment",
                  stan::model::index_uni(i)),
                stan::model::rvalue(a, "a",
                  stan::model::index_uni(
                    stan::model::rvalue(pair, "pair",
                      stan::model::index_uni(i)))))),
            "assigning variable y_hat", stan::model::index_uni(i));
        }
      }
      {
        current_statement__ = 9;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu_a, 0, 1));
        current_statement__ = 10;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(a, (100 * mu_a),
                         sigma_a));
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(beta, 0, 100));
        current_statement__ = 12;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, y_hat, sigma_y));
        std::complex<double> z =
          std::complex<double>(std::numeric_limits<double>::quiet_NaN(),
            std::numeric_limits<double>::quiet_NaN());
        lcm_sym21__ = stan::math::to_complex(7, 5);
        current_statement__ = 14;
        if (pstream__) {
          stan::math::stan_print(pstream__, lcm_sym21__);
          *(pstream__) << std::endl;
        }
        lcm_sym20__ = stan::math::to_complex(5, 4);
        current_statement__ = 15;
        lp_accum__.add(stan::math::get_real(lcm_sym20__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "partial_eval_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym11__;
      double lcm_sym10__;
      int lcm_sym9__;
      int lcm_sym8__;
      int lcm_sym7__;
      Eigen::Matrix<double,-1,1> a;
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_pair);
      Eigen::Matrix<double,-1,1> beta;
      current_statement__ = 2;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      double mu_a;
      current_statement__ = 3;
      mu_a = in__.template read<local_scalar_t__>();
      double sigma_a;
      current_statement__ = 4;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      double sigma_y;
      current_statement__ = 5;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__,
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<double,-1,1> y_hat =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(a);
      out__.write(beta);
      out__.write(mu_a);
      out__.write(sigma_a);
      out__.write(sigma_y);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 8;
      if (stan::math::logical_gte(N, 1)) {
        current_statement__ = 7;
        stan::model::assign(y_hat,
          stan::math::fma(
            stan::model::rvalue(beta, "beta", stan::model::index_uni(2)),
            stan::model::rvalue(pre_test, "pre_test",
              stan::model::index_uni(1)),
            stan::math::fma(
              stan::model::rvalue(beta, "beta", stan::model::index_uni(1)),
              stan::model::rvalue(treatment, "treatment",
                stan::model::index_uni(1)),
              stan::model::rvalue(a, "a",
                stan::model::index_uni(
                  stan::model::rvalue(pair, "pair", stan::model::index_uni(1)))))),
          "assigning variable y_hat", stan::model::index_uni(1));
        for (int i = 2; i <= N; ++i) {
          current_statement__ = 7;
          stan::model::assign(y_hat,
            stan::math::fma(
              stan::model::rvalue(beta, "beta", stan::model::index_uni(2)),
              stan::model::rvalue(pre_test, "pre_test",
                stan::model::index_uni(i)),
              stan::math::fma(
                stan::model::rvalue(beta, "beta", stan::model::index_uni(1)),
                stan::model::rvalue(treatment, "treatment",
                  stan::model::index_uni(i)),
                stan::model::rvalue(a, "a",
                  stan::model::index_uni(
                    stan::model::rvalue(pair, "pair",
                      stan::model::index_uni(i)))))),
            "assigning variable y_hat", stan::model::index_uni(i));
        }
      }
      if (emit_transformed_parameters__) {
        out__.write(y_hat);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> a;
      current_statement__ = 1;
      stan::model::assign(a,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_pair),
        "assigning variable a");
      out__.write(a);
      Eigen::Matrix<local_scalar_t__,-1,1> beta;
      current_statement__ = 2;
      stan::model::assign(beta,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(2),
        "assigning variable beta");
      out__.write(beta);
      local_scalar_t__ mu_a;
      current_statement__ = 3;
      mu_a = in__.read<local_scalar_t__>();
      out__.write(mu_a);
      local_scalar_t__ sigma_a;
      current_statement__ = 4;
      sigma_a = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_a);
      local_scalar_t__ sigma_y;
      current_statement__ = 5;
      sigma_y = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "a", "double",
        std::vector<size_t>{static_cast<size_t>(n_pair)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "beta", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "mu_a", "double",
        std::vector<size_t>{});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "sigma_a",
        "double", std::vector<size_t>{});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "sigma_y",
        "double", std::vector<size_t>{});
      double lcm_sym6__;
      double lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> a =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_pair, DUMMY_VAR__);
      {
        std::vector<double> a_flat__;
        current_statement__ = 1;
        a_flat__ = context__.vals_r("a");
        pos__ = 1;
        if (stan::math::logical_gte(n_pair, 1)) {
          stan::model::assign(a,
            stan::model::rvalue(a_flat__, "a_flat__",
              stan::model::index_uni(1)), "assigning variable a",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= n_pair; ++sym1__) {
            stan::model::assign(a, a_flat__[(pos__ - 1)],
              "assigning variable a", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(a);
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      {
        std::vector<double> beta_flat__;
        current_statement__ = 2;
        beta_flat__ = context__.vals_r("beta");
        pos__ = 1;
        {
          stan::model::assign(beta,
            stan::model::rvalue(beta_flat__, "beta_flat__",
              stan::model::index_uni(1)), "assigning variable beta",
            stan::model::index_uni(1));
          pos__ = 2;
          {
            stan::model::assign(beta, beta_flat__[(pos__ - 1)],
              "assigning variable beta", stan::model::index_uni(2));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(beta);
      local_scalar_t__ mu_a;
      current_statement__ = 3;
      mu_a = context__.vals_r("mu_a")[(1 - 1)];
      out__.write(mu_a);
      local_scalar_t__ sigma_a;
      current_statement__ = 4;
      sigma_a = context__.vals_r("sigma_a")[(1 - 1)];
      out__.write_free_lub(0, 100, sigma_a);
      local_scalar_t__ sigma_y;
      current_statement__ = 5;
      sigma_y = context__.vals_r("sigma_y")[(1 - 1)];
      out__.write_free_lub(0, 100, sigma_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"a", "beta", "mu_a", "sigma_a",
                "sigma_y"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"y_hat"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    n_pair)},
                std::vector<size_t>{static_cast<size_t>(2)},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(N)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym40__ = 1; sym40__ <= n_pair; ++sym40__) {
      param_names__.emplace_back(std::string() + "a" + '.' +
        std::to_string(sym40__));
    }
    for (int sym40__ = 1; sym40__ <= 2; ++sym40__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym40__));
    }
    param_names__.emplace_back(std::string() + "mu_a");
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym40__ = 1; sym40__ <= N; ++sym40__) {
        param_names__.emplace_back(std::string() + "y_hat" + '.' +
          std::to_string(sym40__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym40__ = 1; sym40__ <= n_pair; ++sym40__) {
      param_names__.emplace_back(std::string() + "a" + '.' +
        std::to_string(sym40__));
    }
    for (int sym40__ = 1; sym40__ <= 2; ++sym40__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym40__));
    }
    param_names__.emplace_back(std::string() + "mu_a");
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym40__ = 1; sym40__ <= N; ++sym40__) {
        param_names__.emplace_back(std::string() + "y_hat" + '.' +
          std::to_string(sym40__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_pair) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"mu_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_pair) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"mu_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((n_pair + 2) + 1) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * (N);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((n_pair + 2) + 1) + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * (N);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = partial_eval_model_namespace::partial_eval_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return partial_eval_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp partial_eval_multiply.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace partial_eval_multiply_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 11> locations_array__ =
  {" (found before start of program)",
  " (in 'partial_eval_multiply.stan', line 8, column 2 to column 20)",
  " (in 'partial_eval_multiply.stan', line 9, column 2 to column 20)",
  " (in 'partial_eval_multiply.stan', line 12, column 2 to column 52)",
  " (in 'partial_eval_multiply.stan', line 13, column 2 to column 36)",
  " (in 'partial_eval_multiply.stan', line 14, column 2 to column 36)",
  " (in 'partial_eval_multiply.stan', line 15, column 2 to column 40)",
  " (in 'partial_eval_multiply.stan', line 2, column 2 to column 20)",
  " (in 'partial_eval_multiply.stan', line 3, column 2 to column 20)",
  " (in 'partial_eval_multiply.stan', line 4, column 2 to column 20)",
  " (in 'partial_eval_multiply.stan', line 5, column 2 to column 20)"};
class partial_eval_multiply_model final : public model_base_crtp<partial_eval_multiply_model> {
 private:
  double lcm_sym18__;
  double lcm_sym17__;
  double lcm_sym16__;
  double lcm_sym15__;
  int lcm_sym14__;
  Eigen::Matrix<double,-1,-1> m1_data__;
  Eigen::Matrix<double,-1,-1> m4_data__;
  std::vector<int> idx;
  std::vector<int> idy;
  Eigen::Map<Eigen::Matrix<double,-1,-1>> m1{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> m4{nullptr, 0, 0};
 public:
  ~partial_eval_multiply_model() {}
  partial_eval_multiply_model(stan::io::var_context& context__, unsigned int
                              random_seed__ = 0, std::ostream*
                              pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "partial_eval_multiply_model_namespace::partial_eval_multiply_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 7;
      context__.validate_dims("data initialization", "m1", "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      m1_data__ = Eigen::Matrix<double,-1,-1>::Constant(10, 10,
                    std::numeric_limits<double>::quiet_NaN());
      new (&m1) Eigen::Map<Eigen::Matrix<double,-1,-1>>(m1_data__.data(), 10,
        10);
      {
        std::vector<double> m1_flat__;
        current_statement__ = 7;
        m1_flat__ = context__.vals_r("m1");
        pos__ = 1;
        {
          {
            stan::model::assign(m1,
              stan::model::rvalue(m1_flat__, "m1_flat__",
                stan::model::index_uni(1)), "assigning variable m1",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(2),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(3),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(4),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(5),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(6),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(7),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(8),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(9),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(10),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m1, m1_flat__[(pos__ - 1)],
              "assigning variable m1", stan::model::index_uni(1),
              stan::model::index_uni(2));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(2),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(3),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(4),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(5),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(6),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(7),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(8),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(9),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(10),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m1, m1_flat__[(pos__ - 1)],
              "assigning variable m1", stan::model::index_uni(1),
              stan::model::index_uni(3));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(2),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(3),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(4),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(5),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(6),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(7),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(8),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(9),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(10),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m1, m1_flat__[(pos__ - 1)],
              "assigning variable m1", stan::model::index_uni(1),
              stan::model::index_uni(4));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(2),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(3),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(4),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(5),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(6),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(7),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(8),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(9),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(10),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m1, m1_flat__[(pos__ - 1)],
              "assigning variable m1", stan::model::index_uni(1),
              stan::model::index_uni(5));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(2),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(3),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(4),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(5),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(6),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(7),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(8),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(9),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(10),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m1, m1_flat__[(pos__ - 1)],
              "assigning variable m1", stan::model::index_uni(1),
              stan::model::index_uni(6));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(2),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(3),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(4),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(5),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(6),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(7),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(8),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(9),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(10),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m1, m1_flat__[(pos__ - 1)],
              "assigning variable m1", stan::model::index_uni(1),
              stan::model::index_uni(7));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(2),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(3),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(4),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(5),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(6),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(7),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(8),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(9),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(10),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m1, m1_flat__[(pos__ - 1)],
              "assigning variable m1", stan::model::index_uni(1),
              stan::model::index_uni(8));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(2),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(3),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(4),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(5),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(6),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(7),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(8),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(9),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(10),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m1, m1_flat__[(pos__ - 1)],
              "assigning variable m1", stan::model::index_uni(1),
              stan::model::index_uni(9));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(2),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(3),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(4),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(5),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(6),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(7),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(8),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(9),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(10),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m1, m1_flat__[(pos__ - 1)],
              "assigning variable m1", stan::model::index_uni(1),
              stan::model::index_uni(10));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(2),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(3),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(4),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(5),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(6),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(7),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(8),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(9),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m1, m1_flat__[(pos__ - 1)],
                "assigning variable m1", stan::model::index_uni(10),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 8;
      context__.validate_dims("data initialization", "m4", "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      m4_data__ = Eigen::Matrix<double,-1,-1>::Constant(10, 10,
                    std::numeric_limits<double>::quiet_NaN());
      new (&m4) Eigen::Map<Eigen::Matrix<double,-1,-1>>(m4_data__.data(), 10,
        10);
      {
        std::vector<double> m4_flat__;
        current_statement__ = 8;
        m4_flat__ = context__.vals_r("m4");
        pos__ = 1;
        {
          {
            stan::model::assign(m4,
              stan::model::rvalue(m4_flat__, "m4_flat__",
                stan::model::index_uni(1)), "assigning variable m4",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(2),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(3),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(4),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(5),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(6),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(7),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(8),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(9),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(10),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m4, m4_flat__[(pos__ - 1)],
              "assigning variable m4", stan::model::index_uni(1),
              stan::model::index_uni(2));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(2),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(3),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(4),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(5),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(6),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(7),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(8),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(9),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(10),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m4, m4_flat__[(pos__ - 1)],
              "assigning variable m4", stan::model::index_uni(1),
              stan::model::index_uni(3));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(2),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(3),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(4),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(5),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(6),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(7),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(8),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(9),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(10),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m4, m4_flat__[(pos__ - 1)],
              "assigning variable m4", stan::model::index_uni(1),
              stan::model::index_uni(4));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(2),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(3),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(4),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(5),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(6),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(7),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(8),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(9),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(10),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m4, m4_flat__[(pos__ - 1)],
              "assigning variable m4", stan::model::index_uni(1),
              stan::model::index_uni(5));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(2),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(3),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(4),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(5),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(6),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(7),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(8),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(9),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(10),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m4, m4_flat__[(pos__ - 1)],
              "assigning variable m4", stan::model::index_uni(1),
              stan::model::index_uni(6));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(2),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(3),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(4),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(5),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(6),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(7),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(8),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(9),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(10),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m4, m4_flat__[(pos__ - 1)],
              "assigning variable m4", stan::model::index_uni(1),
              stan::model::index_uni(7));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(2),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(3),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(4),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(5),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(6),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(7),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(8),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(9),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(10),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m4, m4_flat__[(pos__ - 1)],
              "assigning variable m4", stan::model::index_uni(1),
              stan::model::index_uni(8));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(2),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(3),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(4),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(5),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(6),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(7),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(8),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(9),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(10),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m4, m4_flat__[(pos__ - 1)],
              "assigning variable m4", stan::model::index_uni(1),
              stan::model::index_uni(9));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(2),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(3),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(4),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(5),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(6),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(7),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(8),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(9),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(10),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m4, m4_flat__[(pos__ - 1)],
              "assigning variable m4", stan::model::index_uni(1),
              stan::model::index_uni(10));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(2),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(3),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(4),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(5),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(6),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(7),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(8),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(9),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m4, m4_flat__[(pos__ - 1)],
                "assigning variable m4", stan::model::index_uni(10),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 9;
      context__.validate_dims("data initialization", "idx", "int",
        std::vector<size_t>{static_cast<size_t>(10)});
      idx = std::vector<int>(10, std::numeric_limits<int>::min());
      current_statement__ = 9;
      idx = context__.vals_i("idx");
      current_statement__ = 10;
      context__.validate_dims("data initialization", "idy", "int",
        std::vector<size_t>{static_cast<size_t>(10)});
      idy = std::vector<int>(10, std::numeric_limits<int>::min());
      current_statement__ = 10;
      idy = context__.vals_i("idy");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (10 * 10) + (10 * 10);
  }
  inline std::string model_name() const final {
    return "partial_eval_multiply_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "partial_eval_multiply_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> lcm_sym13__;
      Eigen::Matrix<local_scalar_t__,-1,-1> lcm_sym12__;
      double lcm_sym11__;
      Eigen::Matrix<local_scalar_t__,-1,-1> m2;
      current_statement__ = 1;
      m2 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<local_scalar_t__,-1,-1> m3;
      current_statement__ = 2;
      m3 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      {
        Eigen::Matrix<double,-1,-1> m5 =
          Eigen::Matrix<double,-1,-1>::Constant(10, 10,
            std::numeric_limits<double>::quiet_NaN());
        stan::model::assign(lcm_sym12__,
          stan::math::add(
            stan::math::multiply(m1,
              stan::math::elt_multiply(m2,
                stan::model::rvalue(m3, "m3", stan::model::index_multi(idx),
                  stan::model::index_multi(idy)))), m4),
          "assigning variable lcm_sym12__");
        Eigen::Matrix<double,-1,-1> m6 =
          Eigen::Matrix<double,-1,-1>::Constant(10, 10,
            std::numeric_limits<double>::quiet_NaN());
        stan::model::assign(lcm_sym13__, stan::math::fma(m1, m2, m4),
          "assigning variable lcm_sym13__");
        Eigen::Matrix<double,-1,-1> m7 =
          Eigen::Matrix<double,-1,-1>::Constant(10, 10,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 6;
        lp_accum__.add(((stan::math::sum(lcm_sym12__) +
          stan::math::sum(lcm_sym13__)) + stan::math::sum(lcm_sym13__)));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "partial_eval_multiply_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> lcm_sym10__;
      Eigen::Matrix<local_scalar_t__,-1,-1> lcm_sym9__;
      double lcm_sym8__;
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> m2;
      current_statement__ = 1;
      m2 = in__.template read<
             stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(10, 10);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> m3;
      current_statement__ = 2;
      m3 = in__.template read<
             stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(10, 10);
      {
        stan::math::var_value<Eigen::Matrix<double,-1,-1>> m5 =
          Eigen::Matrix<double,-1,-1>::Constant(10, 10,
            std::numeric_limits<double>::quiet_NaN());
        stan::model::assign(lcm_sym9__,
          stan::math::add(
            stan::math::multiply(m1,
              stan::math::elt_multiply(m2,
                stan::model::rvalue(m3, "m3", stan::model::index_multi(idx),
                  stan::model::index_multi(idy)))), m4),
          "assigning variable lcm_sym9__");
        stan::math::var_value<Eigen::Matrix<double,-1,-1>> m6 =
          Eigen::Matrix<double,-1,-1>::Constant(10, 10,
            std::numeric_limits<double>::quiet_NaN());
        stan::model::assign(lcm_sym10__, stan::math::fma(m1, m2, m4),
          "assigning variable lcm_sym10__");
        stan::math::var_value<Eigen::Matrix<double,-1,-1>> m7 =
          Eigen::Matrix<double,-1,-1>::Constant(10, 10,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 6;
        lp_accum__.add(((stan::math::sum(lcm_sym9__) +
          stan::math::sum(lcm_sym10__)) + stan::math::sum(lcm_sym10__)));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "partial_eval_multiply_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym7__;
      int lcm_sym6__;
      Eigen::Matrix<double,-1,-1> m2;
      current_statement__ = 1;
      m2 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<double,-1,-1> m3;
      current_statement__ = 2;
      m3 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      out__.write(m2);
      out__.write(m3);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> m2;
      current_statement__ = 1;
      stan::model::assign(m2,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10),
        "assigning variable m2");
      out__.write(m2);
      Eigen::Matrix<local_scalar_t__,-1,-1> m3;
      current_statement__ = 2;
      stan::model::assign(m3,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10),
        "assigning variable m3");
      out__.write(m3);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "m2", "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "m3", "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      double lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      double lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,-1> m2 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      {
        std::vector<double> m2_flat__;
        current_statement__ = 1;
        m2_flat__ = context__.vals_r("m2");
        pos__ = 1;
        {
          {
            stan::model::assign(m2,
              stan::model::rvalue(m2_flat__, "m2_flat__",
                stan::model::index_uni(1)), "assigning variable m2",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(2),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(3),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(4),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(5),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(6),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(7),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(8),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(9),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(10),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m2, m2_flat__[(pos__ - 1)],
              "assigning variable m2", stan::model::index_uni(1),
              stan::model::index_uni(2));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(2),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(3),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(4),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(5),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(6),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(7),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(8),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(9),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(10),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m2, m2_flat__[(pos__ - 1)],
              "assigning variable m2", stan::model::index_uni(1),
              stan::model::index_uni(3));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(2),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(3),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(4),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(5),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(6),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(7),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(8),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(9),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(10),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m2, m2_flat__[(pos__ - 1)],
              "assigning variable m2", stan::model::index_uni(1),
              stan::model::index_uni(4));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(2),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(3),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(4),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(5),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(6),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(7),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(8),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(9),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(10),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m2, m2_flat__[(pos__ - 1)],
              "assigning variable m2", stan::model::index_uni(1),
              stan::model::index_uni(5));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(2),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(3),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(4),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(5),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(6),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(7),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(8),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(9),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(10),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m2, m2_flat__[(pos__ - 1)],
              "assigning variable m2", stan::model::index_uni(1),
              stan::model::index_uni(6));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(2),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(3),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(4),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(5),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(6),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(7),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(8),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(9),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(10),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m2, m2_flat__[(pos__ - 1)],
              "assigning variable m2", stan::model::index_uni(1),
              stan::model::index_uni(7));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(2),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(3),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(4),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(5),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(6),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(7),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(8),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(9),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(10),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m2, m2_flat__[(pos__ - 1)],
              "assigning variable m2", stan::model::index_uni(1),
              stan::model::index_uni(8));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(2),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(3),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(4),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(5),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(6),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(7),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(8),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(9),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(10),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m2, m2_flat__[(pos__ - 1)],
              "assigning variable m2", stan::model::index_uni(1),
              stan::model::index_uni(9));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(2),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(3),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(4),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(5),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(6),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(7),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(8),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(9),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(10),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m2, m2_flat__[(pos__ - 1)],
              "assigning variable m2", stan::model::index_uni(1),
              stan::model::index_uni(10));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(2),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(3),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(4),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(5),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(6),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(7),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(8),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(9),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m2, m2_flat__[(pos__ - 1)],
                "assigning variable m2", stan::model::index_uni(10),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(m2);
      Eigen::Matrix<local_scalar_t__,-1,-1> m3 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      {
        std::vector<double> m3_flat__;
        current_statement__ = 2;
        m3_flat__ = context__.vals_r("m3");
        pos__ = 1;
        {
          {
            stan::model::assign(m3,
              stan::model::rvalue(m3_flat__, "m3_flat__",
                stan::model::index_uni(1)), "assigning variable m3",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(2),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(3),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(4),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(5),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(6),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(7),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(8),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(9),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(10),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m3, m3_flat__[(pos__ - 1)],
              "assigning variable m3", stan::model::index_uni(1),
              stan::model::index_uni(2));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(2),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(3),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(4),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(5),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(6),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(7),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(8),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(9),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(10),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m3, m3_flat__[(pos__ - 1)],
              "assigning variable m3", stan::model::index_uni(1),
              stan::model::index_uni(3));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(2),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(3),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(4),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(5),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(6),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(7),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(8),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(9),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(10),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m3, m3_flat__[(pos__ - 1)],
              "assigning variable m3", stan::model::index_uni(1),
              stan::model::index_uni(4));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(2),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(3),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(4),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(5),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(6),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(7),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(8),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(9),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(10),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m3, m3_flat__[(pos__ - 1)],
              "assigning variable m3", stan::model::index_uni(1),
              stan::model::index_uni(5));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(2),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(3),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(4),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(5),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(6),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(7),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(8),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(9),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(10),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m3, m3_flat__[(pos__ - 1)],
              "assigning variable m3", stan::model::index_uni(1),
              stan::model::index_uni(6));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(2),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(3),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(4),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(5),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(6),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(7),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(8),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(9),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(10),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m3, m3_flat__[(pos__ - 1)],
              "assigning variable m3", stan::model::index_uni(1),
              stan::model::index_uni(7));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(2),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(3),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(4),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(5),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(6),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(7),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(8),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(9),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(10),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m3, m3_flat__[(pos__ - 1)],
              "assigning variable m3", stan::model::index_uni(1),
              stan::model::index_uni(8));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(2),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(3),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(4),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(5),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(6),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(7),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(8),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(9),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(10),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m3, m3_flat__[(pos__ - 1)],
              "assigning variable m3", stan::model::index_uni(1),
              stan::model::index_uni(9));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(2),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(3),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(4),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(5),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(6),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(7),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(8),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(9),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(10),
                stan::model::index_uni(9));
              pos__ = (pos__ + 1);
            }
          }
          {
            stan::model::assign(m3, m3_flat__[(pos__ - 1)],
              "assigning variable m3", stan::model::index_uni(1),
              stan::model::index_uni(10));
            pos__ = (pos__ + 1);
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(2),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(3),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(4),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(5),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(6),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(7),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(8),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(9),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
            {
              stan::model::assign(m3, m3_flat__[(pos__ - 1)],
                "assigning variable m3", stan::model::index_uni(10),
                stan::model::index_uni(10));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(m3);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"m2", "m3"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    10),
                                                 static_cast<size_t>(10)},
                std::vector<size_t>{static_cast<size_t>(10),
                  static_cast<size_t>(10)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym19__ = 1; sym19__ <= 10; ++sym19__) {
      for (int sym20__ = 1; sym20__ <= 10; ++sym20__) {
        param_names__.emplace_back(std::string() + "m2" + '.' +
          std::to_string(sym20__) + '.' + std::to_string(sym19__));
      }
    }
    for (int sym19__ = 1; sym19__ <= 10; ++sym19__) {
      for (int sym20__ = 1; sym20__ <= 10; ++sym20__) {
        param_names__.emplace_back(std::string() + "m3" + '.' +
          std::to_string(sym20__) + '.' + std::to_string(sym19__));
      }
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym19__ = 1; sym19__ <= 10; ++sym19__) {
      for (int sym20__ = 1; sym20__ <= 10; ++sym20__) {
        param_names__.emplace_back(std::string() + "m2" + '.' +
          std::to_string(sym20__) + '.' + std::to_string(sym19__));
      }
    }
    for (int sym19__ = 1; sym19__ <= 10; ++sym19__) {
      for (int sym20__ = 1; sym20__ <= 10; ++sym20__) {
        param_names__.emplace_back(std::string() + "m3" + '.' +
          std::to_string(sym20__) + '.' + std::to_string(sym19__));
      }
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"m2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"m3\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"m2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"m3\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((10 * 10) + (10 * 10));
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((10 * 10) + (10 * 10));
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = partial_eval_multiply_model_namespace::partial_eval_multiply_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return partial_eval_multiply_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp partial_eval_zeros.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace partial_eval_zeros_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 6> locations_array__ =
  {" (found before start of program)",
  " (in 'partial_eval_zeros.stan', line 2, column 2 to column 20)",
  " (in 'partial_eval_zeros.stan', line 3, column 2 to column 15)",
  " (in 'partial_eval_zeros.stan', line 4, column 2 to column 11)",
  " (in 'partial_eval_zeros.stan', line 5, column 2 to column 9)",
  " (in 'partial_eval_zeros.stan', line 6, column 2 to column 11)"};
class partial_eval_zeros_model final : public model_base_crtp<partial_eval_zeros_model> {
 private:
  Eigen::Matrix<double,-1,1> lcm_sym3___data__;
  Eigen::Matrix<double,-1,1> v_data__;
  double y;
  Eigen::Map<Eigen::Matrix<double,-1,1>> lcm_sym3__{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> v{nullptr, 0};
 public:
  ~partial_eval_zeros_model() {}
  partial_eval_zeros_model(stan::io::var_context& context__, unsigned int
                           random_seed__ = 0, std::ostream*
                           pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "partial_eval_zeros_model_namespace::partial_eval_zeros_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 1;
      v_data__ = Eigen::Matrix<double,-1,1>::Constant(0,
                   std::numeric_limits<double>::quiet_NaN());
      new (&v) Eigen::Map<Eigen::Matrix<double,-1,1>>(v_data__.data(), 0);
      current_statement__ = 1;
      stan::model::assign(v, Eigen::Matrix<double,-1,1>(0),
        "assigning variable v");
      current_statement__ = 2;
      y = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      y = 0E0;
      current_statement__ = 3;
      if (pstream__) {
        stan::math::stan_print(pstream__, 0);
        *(pstream__) << std::endl;
      }
      current_statement__ = 4;
      y = 0.;
      current_statement__ = 5;
      if (pstream__) {
        stan::math::stan_print(pstream__, 0);
        *(pstream__) << std::endl;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "partial_eval_zeros_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "partial_eval_zeros_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "partial_eval_zeros_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "partial_eval_zeros_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = partial_eval_zeros_model_namespace::partial_eval_zeros_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return partial_eval_zeros_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp stalled1-failure.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace stalled1_failure_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 33> locations_array__ =
  {" (found before start of program)",
  " (in 'stalled1-failure.stan', line 27, column 2 to column 14)",
  " (in 'stalled1-failure.stan', line 28, column 2 to column 14)",
  " (in 'stalled1-failure.stan', line 29, column 2 to column 14)",
  " (in 'stalled1-failure.stan', line 30, column 2 to column 15)",
  " (in 'stalled1-failure.stan', line 31, column 2 to column 20)",
  " (in 'stalled1-failure.stan', line 32, column 2 to column 23)",
  " (in 'stalled1-failure.stan', line 35, column 2 to column 13)",
  " (in 'stalled1-failure.stan', line 39, column 2 to column 30)",
  " (in 'stalled1-failure.stan', line 40, column 2 to column 30)",
  " (in 'stalled1-failure.stan', line 41, column 2 to column 30)",
  " (in 'stalled1-failure.stan', line 42, column 2 to column 31)",
  " (in 'stalled1-failure.stan', line 43, column 2 to column 30)",
  " (in 'stalled1-failure.stan', line 45, column 4 to column 30)",
  " (in 'stalled1-failure.stan', line 46, column 4 to line 48, column 54)",
  " (in 'stalled1-failure.stan', line 44, column 19 to line 49, column 3)",
  " (in 'stalled1-failure.stan', line 44, column 2 to line 49, column 3)",
  " (in 'stalled1-failure.stan', line 14, column 2 to column 17)",
  " (in 'stalled1-failure.stan', line 15, column 8 to column 9)",
  " (in 'stalled1-failure.stan', line 15, column 2 to column 26)",
  " (in 'stalled1-failure.stan', line 16, column 8 to column 9)",
  " (in 'stalled1-failure.stan', line 16, column 2 to column 26)",
  " (in 'stalled1-failure.stan', line 17, column 9 to column 10)",
  " (in 'stalled1-failure.stan', line 17, column 2 to column 15)",
  " (in 'stalled1-failure.stan', line 18, column 9 to column 10)",
  " (in 'stalled1-failure.stan', line 18, column 2 to column 15)",
  " (in 'stalled1-failure.stan', line 21, column 2 to column 8)",
  " (in 'stalled1-failure.stan', line 22, column 9 to column 10)",
  " (in 'stalled1-failure.stan', line 22, column 2 to column 17)",
  " (in 'stalled1-failure.stan', line 23, column 2 to column 8)",
  " (in 'stalled1-failure.stan', line 24, column 2 to column 18)",
  " (in 'stalled1-failure.stan', line 32, column 8 to column 9)",
  " (in 'stalled1-failure.stan', line 32, column 18 to column 19)"};
class stalled1_failure_model final : public model_base_crtp<stalled1_failure_model> {
 private:
  double lcm_sym41__;
  double lcm_sym40__;
  double lcm_sym39__;
  double lcm_sym38__;
  int lcm_sym37__;
  int lcm_sym36__;
  Eigen::Matrix<double,-1,1> lcm_sym35___data__;
  int I;
  std::vector<int> n;
  std::vector<int> N;
  Eigen::Matrix<double,-1,1> x1_data__;
  Eigen::Matrix<double,-1,1> x2_data__;
  int K;
  Eigen::Matrix<double,-1,1> x1x2_data__;
  Eigen::Map<Eigen::Matrix<double,-1,1>> lcm_sym35__{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> x1{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> x2{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> x1x2{nullptr, 0};
 public:
  ~stalled1_failure_model() {}
  stalled1_failure_model(stan::io::var_context& context__, unsigned int
                         random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "stalled1_failure_model_namespace::stalled1_failure_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 17;
      context__.validate_dims("data initialization", "I", "int",
        std::vector<size_t>{});
      I = std::numeric_limits<int>::min();
      current_statement__ = 17;
      I = context__.vals_i("I")[(1 - 1)];
      current_statement__ = 17;
      stan::math::check_greater_or_equal(function__, "I", I, 0);
      current_statement__ = 18;
      stan::math::validate_non_negative_index("n", "I", I);
      current_statement__ = 19;
      context__.validate_dims("data initialization", "n", "int",
        std::vector<size_t>{static_cast<size_t>(I)});
      n = std::vector<int>(I, std::numeric_limits<int>::min());
      current_statement__ = 19;
      n = context__.vals_i("n");
      current_statement__ = 19;
      stan::math::check_greater_or_equal(function__, "n", n, 0);
      current_statement__ = 20;
      stan::math::validate_non_negative_index("N", "I", I);
      current_statement__ = 21;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{static_cast<size_t>(I)});
      N = std::vector<int>(I, std::numeric_limits<int>::min());
      current_statement__ = 21;
      N = context__.vals_i("N");
      current_statement__ = 21;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 22;
      stan::math::validate_non_negative_index("x1", "I", I);
      current_statement__ = 23;
      context__.validate_dims("data initialization", "x1", "double",
        std::vector<size_t>{static_cast<size_t>(I)});
      x1_data__ = Eigen::Matrix<double,-1,1>::Constant(I,
                    std::numeric_limits<double>::quiet_NaN());
      new (&x1) Eigen::Map<Eigen::Matrix<double,-1,1>>(x1_data__.data(), I);
      {
        std::vector<double> x1_flat__;
        current_statement__ = 23;
        x1_flat__ = context__.vals_r("x1");
        pos__ = 1;
        lcm_sym36__ = stan::math::logical_gte(I, 1);
        if (lcm_sym36__) {
          stan::model::assign(x1,
            stan::model::rvalue(x1_flat__, "x1_flat__",
              stan::model::index_uni(1)), "assigning variable x1",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= I; ++sym1__) {
            stan::model::assign(x1, x1_flat__[(pos__ - 1)],
              "assigning variable x1", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 24;
      stan::math::validate_non_negative_index("x2", "I", I);
      current_statement__ = 25;
      context__.validate_dims("data initialization", "x2", "double",
        std::vector<size_t>{static_cast<size_t>(I)});
      x2_data__ = Eigen::Matrix<double,-1,1>::Constant(I,
                    std::numeric_limits<double>::quiet_NaN());
      new (&x2) Eigen::Map<Eigen::Matrix<double,-1,1>>(x2_data__.data(), I);
      {
        std::vector<double> x2_flat__;
        current_statement__ = 25;
        x2_flat__ = context__.vals_r("x2");
        pos__ = 1;
        if (lcm_sym36__) {
          stan::model::assign(x2,
            stan::model::rvalue(x2_flat__, "x2_flat__",
              stan::model::index_uni(1)), "assigning variable x2",
            stan::model::index_uni(1));
          pos__ = 2;
          for (int sym1__ = 2; sym1__ <= I; ++sym1__) {
            stan::model::assign(x2, x2_flat__[(pos__ - 1)],
              "assigning variable x2", stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 26;
      K = std::numeric_limits<int>::min();
      current_statement__ = 27;
      stan::math::validate_non_negative_index("x1x2", "I", I);
      current_statement__ = 28;
      x1x2_data__ = Eigen::Matrix<double,-1,1>::Constant(I,
                      std::numeric_limits<double>::quiet_NaN());
      new (&x1x2) Eigen::Map<Eigen::Matrix<double,-1,1>>(x1x2_data__.data(),
        I);
      current_statement__ = 29;
      K = 8;
      current_statement__ = 30;
      stan::model::assign(x1x2, stan::math::elt_multiply(x1, x2),
        "assigning variable x1x2");
      current_statement__ = 31;
      stan::math::validate_non_negative_index("b", "I", I);
      current_statement__ = 32;
      stan::math::validate_non_negative_index("b", "K", 8);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + 1 + (I * K);
  }
  inline std::string model_name() const final {
    return "stalled1_failure_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "stalled1_failure_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym34__;
      double lcm_sym33__;
      double lcm_sym32__;
      double lcm_sym31__;
      double lcm_sym30__;
      double lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      int lcm_sym25__;
      local_scalar_t__ lcm_sym24__;
      local_scalar_t__ alpha0;
      current_statement__ = 1;
      alpha0 = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha1;
      current_statement__ = 2;
      alpha1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha2;
      current_statement__ = 3;
      alpha2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha12;
      current_statement__ = 4;
      alpha12 = in__.template read<local_scalar_t__>();
      local_scalar_t__ tau;
      current_statement__ = 5;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> b =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(I,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(8, DUMMY_VAR__));
      current_statement__ = 6;
      b = in__.template read<
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(I, 8);
      local_scalar_t__ sigma = DUMMY_VAR__;
      lcm_sym24__ = (1 / stan::math::sqrt(tau));
      sigma = lcm_sym24__;
      {
        current_statement__ = 8;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha0, 0.0, 1.0E3));
        current_statement__ = 9;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha1, 0.0, 1.0E3));
        current_statement__ = 10;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha2, 0.0, 1.0E3));
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha12, 0.0, 1.0E3));
        current_statement__ = 12;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(tau, 1.0E-3, 1.0E-3));
        current_statement__ = 16;
        if (stan::math::logical_gte(I, 1)) {
          current_statement__ = 13;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(b, "b",
                             stan::model::index_uni(1)), 0.0, lcm_sym24__));
          current_statement__ = 14;
          lp_accum__.add(stan::math::binomial_logit_lpmf<propto__>(
                           stan::model::rvalue(n, "n",
                             stan::model::index_uni(1)),
                           stan::model::rvalue(N, "N",
                             stan::model::index_uni(1)),
                           stan::math::add(
                             stan::math::fma(alpha12,
                               stan::model::rvalue(
                                 stan::math::elt_multiply(x1, x2),
                                 "(x1 .* x2)", stan::model::index_uni(1)),
                               stan::math::fma(alpha2,
                                 stan::model::rvalue(x2, "x2",
                                   stan::model::index_uni(1)),
                                 stan::math::fma(alpha1,
                                   stan::model::rvalue(x1, "x1",
                                     stan::model::index_uni(1)), alpha0))),
                             stan::model::rvalue(b, "b",
                               stan::model::index_uni(1)))));
          for (int i = 2; i <= I; ++i) {
            current_statement__ = 13;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(
                             stan::model::rvalue(b, "b",
                               stan::model::index_uni(i)), 0.0, lcm_sym24__));
            current_statement__ = 14;
            lp_accum__.add(stan::math::binomial_logit_lpmf<propto__>(
                             stan::model::rvalue(n, "n",
                               stan::model::index_uni(i)),
                             stan::model::rvalue(N, "N",
                               stan::model::index_uni(i)),
                             stan::math::add(
                               stan::math::fma(alpha12,
                                 stan::model::rvalue(
                                   stan::math::elt_multiply(x1, x2),
                                   "(x1 .* x2)", stan::model::index_uni(i)),
                                 stan::math::fma(alpha2,
                                   stan::model::rvalue(x2, "x2",
                                     stan::model::index_uni(i)),
                                   stan::math::fma(alpha1,
                                     stan::model::rvalue(x1, "x1",
                                       stan::model::index_uni(i)), alpha0))),
                               stan::model::rvalue(b, "b",
                                 stan::model::index_uni(i)))));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "stalled1_failure_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      int lcm_sym14__;
      local_scalar_t__ lcm_sym13__;
      local_scalar_t__ alpha0;
      current_statement__ = 1;
      alpha0 = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha1;
      current_statement__ = 2;
      alpha1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha2;
      current_statement__ = 3;
      alpha2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha12;
      current_statement__ = 4;
      alpha12 = in__.template read<local_scalar_t__>();
      local_scalar_t__ tau;
      current_statement__ = 5;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      std::vector<stan::math::var_value<Eigen::Matrix<double,-1,1>>> b =
        std::vector<stan::math::var_value<Eigen::Matrix<double,-1,1>>>(I,
          stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(8,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                ))));
      current_statement__ = 6;
      b = in__.template read<
            std::vector<stan::math::var_value<Eigen::Matrix<double,-1,1>>>>(I,
            8);
      local_scalar_t__ sigma = DUMMY_VAR__;
      lcm_sym13__ = (1 / stan::math::sqrt(tau));
      sigma = lcm_sym13__;
      {
        current_statement__ = 8;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha0, 0.0, 1.0E3));
        current_statement__ = 9;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha1, 0.0, 1.0E3));
        current_statement__ = 10;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha2, 0.0, 1.0E3));
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha12, 0.0, 1.0E3));
        current_statement__ = 12;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(tau, 1.0E-3, 1.0E-3));
        current_statement__ = 16;
        if (stan::math::logical_gte(I, 1)) {
          current_statement__ = 13;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(
                           stan::model::rvalue(b, "b",
                             stan::model::index_uni(1)), 0.0, lcm_sym13__));
          current_statement__ = 14;
          lp_accum__.add(stan::math::binomial_logit_lpmf<propto__>(
                           stan::model::rvalue(n, "n",
                             stan::model::index_uni(1)),
                           stan::model::rvalue(N, "N",
                             stan::model::index_uni(1)),
                           stan::math::add(
                             stan::math::fma(alpha12,
                               stan::model::rvalue(
                                 stan::math::elt_multiply(x1, x2),
                                 "(x1 .* x2)", stan::model::index_uni(1)),
                               stan::math::fma(alpha2,
                                 stan::model::rvalue(x2, "x2",
                                   stan::model::index_uni(1)),
                                 stan::math::fma(alpha1,
                                   stan::model::rvalue(x1, "x1",
                                     stan::model::index_uni(1)), alpha0))),
                             stan::model::rvalue(b, "b",
                               stan::model::index_uni(1)))));
          for (int i = 2; i <= I; ++i) {
            current_statement__ = 13;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(
                             stan::model::rvalue(b, "b",
                               stan::model::index_uni(i)), 0.0, lcm_sym13__));
            current_statement__ = 14;
            lp_accum__.add(stan::math::binomial_logit_lpmf<propto__>(
                             stan::model::rvalue(n, "n",
                               stan::model::index_uni(i)),
                             stan::model::rvalue(N, "N",
                               stan::model::index_uni(i)),
                             stan::math::add(
                               stan::math::fma(alpha12,
                                 stan::model::rvalue(
                                   stan::math::elt_multiply(x1, x2),
                                   "(x1 .* x2)", stan::model::index_uni(i)),
                                 stan::math::fma(alpha2,
                                   stan::model::rvalue(x2, "x2",
                                     stan::model::index_uni(i)),
                                   stan::math::fma(alpha1,
                                     stan::model::rvalue(x1, "x1",
                                       stan::model::index_uni(i)), alpha0))),
                               stan::model::rvalue(b, "b",
                                 stan::model::index_uni(i)))));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "stalled1_failure_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym12__;
      double lcm_sym11__;
      double lcm_sym10__;
      double lcm_sym9__;
      int lcm_sym8__;
      int lcm_sym7__;
      int lcm_sym6__;
      double lcm_sym5__;
      double alpha0;
      current_statement__ = 1;
      alpha0 = in__.template read<local_scalar_t__>();
      double alpha1;
      current_statement__ = 2;
      alpha1 = in__.template read<local_scalar_t__>();
      double alpha2;
      current_statement__ = 3;
      alpha2 = in__.template read<local_scalar_t__>();
      double alpha12;
      current_statement__ = 4;
      alpha12 = in__.template read<local_scalar_t__>();
      double tau;
      current_statement__ = 5;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      std::vector<Eigen::Matrix<double,-1,1>> b =
        std::vector<Eigen::Matrix<double,-1,1>>(I,
          Eigen::Matrix<double,-1,1>::Constant(8,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 6;
      b = in__.template read<
            std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(I, 8);
      double sigma = std::numeric_limits<double>::quiet_NaN();
      out__.write(alpha0);
      out__.write(alpha1);
      out__.write(alpha2);
      out__.write(alpha12);
      out__.write(tau);
      {
        lcm_sym6__ = stan::math::logical_gte(I, 1);
        if (lcm_sym6__) {
          out__.write(stan::model::rvalue(b, "b", stan::model::index_uni(1),
                        stan::model::index_uni(1)));
          for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
            out__.write(stan::model::rvalue(b, "b",
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(1)));
          }
        }
        {
          if (lcm_sym6__) {
            out__.write(stan::model::rvalue(b, "b",
                          stan::model::index_uni(1),
                          stan::model::index_uni(2)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(stan::model::rvalue(b, "b",
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(2)));
            }
          }
        }
        {
          if (lcm_sym6__) {
            out__.write(stan::model::rvalue(b, "b",
                          stan::model::index_uni(1),
                          stan::model::index_uni(3)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(stan::model::rvalue(b, "b",
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(3)));
            }
          }
        }
        {
          if (lcm_sym6__) {
            out__.write(stan::model::rvalue(b, "b",
                          stan::model::index_uni(1),
                          stan::model::index_uni(4)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(stan::model::rvalue(b, "b",
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(4)));
            }
          }
        }
        {
          if (lcm_sym6__) {
            out__.write(stan::model::rvalue(b, "b",
                          stan::model::index_uni(1),
                          stan::model::index_uni(5)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(stan::model::rvalue(b, "b",
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(5)));
            }
          }
        }
        {
          if (lcm_sym6__) {
            out__.write(stan::model::rvalue(b, "b",
                          stan::model::index_uni(1),
                          stan::model::index_uni(6)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(stan::model::rvalue(b, "b",
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(6)));
            }
          }
        }
        {
          if (lcm_sym6__) {
            out__.write(stan::model::rvalue(b, "b",
                          stan::model::index_uni(1),
                          stan::model::index_uni(7)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(stan::model::rvalue(b, "b",
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(7)));
            }
          }
        }
        {
          if (lcm_sym6__) {
            out__.write(stan::model::rvalue(b, "b",
                          stan::model::index_uni(1),
                          stan::model::index_uni(8)));
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              out__.write(stan::model::rvalue(b, "b",
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(8)));
            }
          }
        }
      }
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      lcm_sym5__ = (1 / stan::math::sqrt(tau));
      sigma = lcm_sym5__;
      if (emit_transformed_parameters__) {
        out__.write(lcm_sym5__);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ alpha0;
      current_statement__ = 1;
      alpha0 = in__.read<local_scalar_t__>();
      out__.write(alpha0);
      local_scalar_t__ alpha1;
      current_statement__ = 2;
      alpha1 = in__.read<local_scalar_t__>();
      out__.write(alpha1);
      local_scalar_t__ alpha2;
      current_statement__ = 3;
      alpha2 = in__.read<local_scalar_t__>();
      out__.write(alpha2);
      local_scalar_t__ alpha12;
      current_statement__ = 4;
      alpha12 = in__.read<local_scalar_t__>();
      out__.write(alpha12);
      local_scalar_t__ tau;
      current_statement__ = 5;
      tau = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> b =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(I,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__));
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
          current_statement__ = 6;
          stan::model::assign(b, in__.read<local_scalar_t__>(),
            "assigning variable b", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write(b);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "alpha0", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "alpha1", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "alpha2", "double",
        std::vector<size_t>{});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "alpha12",
        "double", std::vector<size_t>{});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "tau", "double",
        std::vector<size_t>{});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "b", "double",
        std::vector<size_t>{static_cast<size_t>(I), static_cast<size_t>(K)});
      double lcm_sym4__;
      double lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      pos__ = 1;
      local_scalar_t__ alpha0;
      current_statement__ = 1;
      alpha0 = context__.vals_r("alpha0")[(1 - 1)];
      out__.write(alpha0);
      local_scalar_t__ alpha1;
      current_statement__ = 2;
      alpha1 = context__.vals_r("alpha1")[(1 - 1)];
      out__.write(alpha1);
      local_scalar_t__ alpha2;
      current_statement__ = 3;
      alpha2 = context__.vals_r("alpha2")[(1 - 1)];
      out__.write(alpha2);
      local_scalar_t__ alpha12;
      current_statement__ = 4;
      alpha12 = context__.vals_r("alpha12")[(1 - 1)];
      out__.write(alpha12);
      local_scalar_t__ tau;
      current_statement__ = 5;
      tau = context__.vals_r("tau")[(1 - 1)];
      out__.write_free_lb(0, tau);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> b =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(I,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(8, DUMMY_VAR__));
      {
        std::vector<double> b_flat__;
        current_statement__ = 6;
        b_flat__ = context__.vals_r("b");
        pos__ = 1;
        {
          lcm_sym1__ = stan::math::logical_gte(I, 1);
          if (lcm_sym1__) {
            stan::model::assign(b,
              stan::model::rvalue(b_flat__, "b_flat__",
                stan::model::index_uni(1)), "assigning variable b",
              stan::model::index_uni(1), stan::model::index_uni(1));
            pos__ = 2;
            for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
              stan::model::assign(b, b_flat__[(pos__ - 1)],
                "assigning variable b", stan::model::index_uni(sym2__),
                stan::model::index_uni(1));
              pos__ = (pos__ + 1);
            }
          }
          {
            if (lcm_sym1__) {
              stan::model::assign(b, b_flat__[(pos__ - 1)],
                "assigning variable b", stan::model::index_uni(1),
                stan::model::index_uni(2));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
                stan::model::assign(b, b_flat__[(pos__ - 1)],
                  "assigning variable b", stan::model::index_uni(sym2__),
                  stan::model::index_uni(2));
                pos__ = (pos__ + 1);
              }
            }
          }
          {
            if (lcm_sym1__) {
              stan::model::assign(b, b_flat__[(pos__ - 1)],
                "assigning variable b", stan::model::index_uni(1),
                stan::model::index_uni(3));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
                stan::model::assign(b, b_flat__[(pos__ - 1)],
                  "assigning variable b", stan::model::index_uni(sym2__),
                  stan::model::index_uni(3));
                pos__ = (pos__ + 1);
              }
            }
          }
          {
            if (lcm_sym1__) {
              stan::model::assign(b, b_flat__[(pos__ - 1)],
                "assigning variable b", stan::model::index_uni(1),
                stan::model::index_uni(4));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
                stan::model::assign(b, b_flat__[(pos__ - 1)],
                  "assigning variable b", stan::model::index_uni(sym2__),
                  stan::model::index_uni(4));
                pos__ = (pos__ + 1);
              }
            }
          }
          {
            if (lcm_sym1__) {
              stan::model::assign(b, b_flat__[(pos__ - 1)],
                "assigning variable b", stan::model::index_uni(1),
                stan::model::index_uni(5));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
                stan::model::assign(b, b_flat__[(pos__ - 1)],
                  "assigning variable b", stan::model::index_uni(sym2__),
                  stan::model::index_uni(5));
                pos__ = (pos__ + 1);
              }
            }
          }
          {
            if (lcm_sym1__) {
              stan::model::assign(b, b_flat__[(pos__ - 1)],
                "assigning variable b", stan::model::index_uni(1),
                stan::model::index_uni(6));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
                stan::model::assign(b, b_flat__[(pos__ - 1)],
                  "assigning variable b", stan::model::index_uni(sym2__),
                  stan::model::index_uni(6));
                pos__ = (pos__ + 1);
              }
            }
          }
          {
            if (lcm_sym1__) {
              stan::model::assign(b, b_flat__[(pos__ - 1)],
                "assigning variable b", stan::model::index_uni(1),
                stan::model::index_uni(7));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
                stan::model::assign(b, b_flat__[(pos__ - 1)],
                  "assigning variable b", stan::model::index_uni(sym2__),
                  stan::model::index_uni(7));
                pos__ = (pos__ + 1);
              }
            }
          }
          {
            if (lcm_sym1__) {
              stan::model::assign(b, b_flat__[(pos__ - 1)],
                "assigning variable b", stan::model::index_uni(1),
                stan::model::index_uni(8));
              pos__ = (pos__ + 1);
              for (int sym2__ = 2; sym2__ <= I; ++sym2__) {
                stan::model::assign(b, b_flat__[(pos__ - 1)],
                  "assigning variable b", stan::model::index_uni(sym2__),
                  stan::model::index_uni(8));
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      out__.write(b);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"alpha0", "alpha1", "alpha2",
                "alpha12", "tau", "b"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"sigma"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(I),
                  static_cast<size_t>(K)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>> temp{std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha0");
    param_names__.emplace_back(std::string() + "alpha1");
    param_names__.emplace_back(std::string() + "alpha2");
    param_names__.emplace_back(std::string() + "alpha12");
    param_names__.emplace_back(std::string() + "tau");
    for (int sym42__ = 1; sym42__ <= K; ++sym42__) {
      for (int sym43__ = 1; sym43__ <= I; ++sym43__) {
        param_names__.emplace_back(std::string() + "b" + '.' +
          std::to_string(sym43__) + '.' + std::to_string(sym42__));
      }
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma");
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha0");
    param_names__.emplace_back(std::string() + "alpha1");
    param_names__.emplace_back(std::string() + "alpha2");
    param_names__.emplace_back(std::string() + "alpha12");
    param_names__.emplace_back(std::string() + "tau");
    for (int sym42__ = 1; sym42__ <= K; ++sym42__) {
      for (int sym43__ = 1; sym43__ <= I; ++sym43__) {
        param_names__.emplace_back(std::string() + "b" + '.' +
          std::to_string(sym43__) + '.' + std::to_string(sym42__));
      }
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma");
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha12\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(I) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha12\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(I) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((1 + 1) + 1) + 1) + 1) + (I * K));
    const size_t num_transformed = emit_transformed_parameters * (1);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((1 + 1) + 1) + 1) + 1) + (I * K));
    const size_t num_transformed = emit_transformed_parameters * (1);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = stalled1_failure_model_namespace::stalled1_failure_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return stalled1_failure_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp unenforce-initialize-should-fail.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace unenforce_initialize_should_fail_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 8> locations_array__ =
  {" (found before start of program)",
  " (in 'unenforce-initialize-should-fail.stan', line 5, column 2 to column 13)",
  " (in 'unenforce-initialize-should-fail.stan', line 8, column 2 to column 36)",
  " (in 'unenforce-initialize-should-fail.stan', line 11, column 6 to column 23)",
  " (in 'unenforce-initialize-should-fail.stan', line 10, column 4 to line 12, column 5)",
  " (in 'unenforce-initialize-should-fail.stan', line 9, column 2 to line 13, column 3)",
  " (in 'unenforce-initialize-should-fail.stan', line 16, column 2 to column 23)",
  " (in 'unenforce-initialize-should-fail.stan', line 2, column 2 to column 60)"};
class unenforce_initialize_should_fail_model final : public model_base_crtp<unenforce_initialize_should_fail_model> {
 private:
  std::vector<Eigen::Matrix<double,-1,1>> lcm_sym24__;
  std::vector<Eigen::Matrix<double,-1,1>> inputs;
 public:
  ~unenforce_initialize_should_fail_model() {}
  unenforce_initialize_should_fail_model(stan::io::var_context& context__,
                                         unsigned int random_seed__ = 0,
                                         std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "unenforce_initialize_should_fail_model_namespace::unenforce_initialize_should_fail_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__;
      pos__ = 1;
      current_statement__ = 7;
      inputs = std::vector<Eigen::Matrix<double,-1,1>>(2,
                 Eigen::Matrix<double,-1,1>::Constant(5,
                   std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 7;
      stan::model::assign(inputs,
        stan::math::rep_array(stan::math::zeros_vector(5), 2),
        "assigning variable inputs");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1;
  }
  inline std::string model_name() const final {
    return "unenforce_initialize_should_fail_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "unenforce_initialize_should_fail_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym23__;
      std::vector<Eigen::Matrix<double,-1,1>> lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      local_scalar_t__ param;
      current_statement__ = 1;
      param = in__.template read<local_scalar_t__>();
      std::vector<Eigen::Matrix<double,-1,1>> local =
        std::vector<Eigen::Matrix<double,-1,1>>(2,
          Eigen::Matrix<double,-1,1>::Constant(5,
            std::numeric_limits<double>::quiet_NaN()));
      stan::model::assign(lcm_sym22__,
        stan::math::rep_array(stan::math::zeros_vector(5), 2),
        "assigning variable lcm_sym22__");
      stan::model::assign(local, lcm_sym22__, "assigning variable local");
      {
        {
          current_statement__ = 3;
          stan::model::assign(local,
            (stan::model::rvalue(lcm_sym22__, "lcm_sym22__",
               stan::model::index_uni(1), stan::model::index_uni(1)) + 1),
            "assigning variable local", stan::model::index_uni(1),
            stan::model::index_uni(1));
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(1),
                 stan::model::index_uni(2)) + 1), "assigning variable local",
              stan::model::index_uni(1), stan::model::index_uni(2));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(1),
                 stan::model::index_uni(3)) + 1), "assigning variable local",
              stan::model::index_uni(1), stan::model::index_uni(3));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(1),
                 stan::model::index_uni(4)) + 1), "assigning variable local",
              stan::model::index_uni(1), stan::model::index_uni(4));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(1),
                 stan::model::index_uni(5)) + 1), "assigning variable local",
              stan::model::index_uni(1), stan::model::index_uni(5));
          }
        }
        {
          current_statement__ = 3;
          stan::model::assign(local,
            (stan::model::rvalue(local, "local", stan::model::index_uni(2),
               stan::model::index_uni(1)) + 1), "assigning variable local",
            stan::model::index_uni(2), stan::model::index_uni(1));
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(2),
                 stan::model::index_uni(2)) + 1), "assigning variable local",
              stan::model::index_uni(2), stan::model::index_uni(2));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(2),
                 stan::model::index_uni(3)) + 1), "assigning variable local",
              stan::model::index_uni(2), stan::model::index_uni(3));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(2),
                 stan::model::index_uni(4)) + 1), "assigning variable local",
              stan::model::index_uni(2), stan::model::index_uni(4));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(2),
                 stan::model::index_uni(5)) + 1), "assigning variable local",
              stan::model::index_uni(2), stan::model::index_uni(5));
          }
        }
      }
      {
        current_statement__ = 6;
        lp_accum__.add(stan::math::std_normal_lpdf<propto__>(param));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "unenforce_initialize_should_fail_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym17__;
      std::vector<Eigen::Matrix<double,-1,1>> lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      double lcm_sym12__;
      local_scalar_t__ param;
      current_statement__ = 1;
      param = in__.template read<local_scalar_t__>();
      std::vector<stan::math::var_value<Eigen::Matrix<double,-1,1>>> local =
        std::vector<Eigen::Matrix<double,-1,1>>(2,
          Eigen::Matrix<double,-1,1>::Constant(5,
            std::numeric_limits<double>::quiet_NaN()));
      stan::model::assign(lcm_sym16__,
        stan::math::rep_array(stan::math::zeros_vector(5), 2),
        "assigning variable lcm_sym16__");
      stan::model::assign(local, lcm_sym16__, "assigning variable local");
      {
        {
          current_statement__ = 3;
          stan::model::assign(local,
            (stan::model::rvalue(lcm_sym16__, "lcm_sym16__",
               stan::model::index_uni(1), stan::model::index_uni(1)) + 1),
            "assigning variable local", stan::model::index_uni(1),
            stan::model::index_uni(1));
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(1),
                 stan::model::index_uni(2)) + 1), "assigning variable local",
              stan::model::index_uni(1), stan::model::index_uni(2));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(1),
                 stan::model::index_uni(3)) + 1), "assigning variable local",
              stan::model::index_uni(1), stan::model::index_uni(3));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(1),
                 stan::model::index_uni(4)) + 1), "assigning variable local",
              stan::model::index_uni(1), stan::model::index_uni(4));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(1),
                 stan::model::index_uni(5)) + 1), "assigning variable local",
              stan::model::index_uni(1), stan::model::index_uni(5));
          }
        }
        {
          current_statement__ = 3;
          stan::model::assign(local,
            (stan::model::rvalue(local, "local", stan::model::index_uni(2),
               stan::model::index_uni(1)) + 1), "assigning variable local",
            stan::model::index_uni(2), stan::model::index_uni(1));
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(2),
                 stan::model::index_uni(2)) + 1), "assigning variable local",
              stan::model::index_uni(2), stan::model::index_uni(2));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(2),
                 stan::model::index_uni(3)) + 1), "assigning variable local",
              stan::model::index_uni(2), stan::model::index_uni(3));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(2),
                 stan::model::index_uni(4)) + 1), "assigning variable local",
              stan::model::index_uni(2), stan::model::index_uni(4));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(2),
                 stan::model::index_uni(5)) + 1), "assigning variable local",
              stan::model::index_uni(2), stan::model::index_uni(5));
          }
        }
      }
      {
        current_statement__ = 6;
        lp_accum__.add(stan::math::std_normal_lpdf<propto__>(param));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "unenforce_initialize_should_fail_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym11__;
      double lcm_sym10__;
      double lcm_sym9__;
      double lcm_sym8__;
      std::vector<Eigen::Matrix<double,-1,1>> lcm_sym7__;
      double lcm_sym6__;
      double lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      double param;
      current_statement__ = 1;
      param = in__.template read<local_scalar_t__>();
      std::vector<Eigen::Matrix<double,-1,1>> local =
        std::vector<Eigen::Matrix<double,-1,1>>(2,
          Eigen::Matrix<double,-1,1>::Constant(5,
            std::numeric_limits<double>::quiet_NaN()));
      out__.write(param);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      stan::model::assign(lcm_sym7__,
        stan::math::rep_array(stan::math::zeros_vector(5), 2),
        "assigning variable lcm_sym7__");
      stan::model::assign(local, lcm_sym7__, "assigning variable local");
      {
        {
          current_statement__ = 3;
          stan::model::assign(local,
            (stan::model::rvalue(lcm_sym7__, "lcm_sym7__",
               stan::model::index_uni(1), stan::model::index_uni(1)) + 1),
            "assigning variable local", stan::model::index_uni(1),
            stan::model::index_uni(1));
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(1),
                 stan::model::index_uni(2)) + 1), "assigning variable local",
              stan::model::index_uni(1), stan::model::index_uni(2));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(1),
                 stan::model::index_uni(3)) + 1), "assigning variable local",
              stan::model::index_uni(1), stan::model::index_uni(3));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(1),
                 stan::model::index_uni(4)) + 1), "assigning variable local",
              stan::model::index_uni(1), stan::model::index_uni(4));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(1),
                 stan::model::index_uni(5)) + 1), "assigning variable local",
              stan::model::index_uni(1), stan::model::index_uni(5));
          }
        }
        {
          current_statement__ = 3;
          stan::model::assign(local,
            (stan::model::rvalue(local, "local", stan::model::index_uni(2),
               stan::model::index_uni(1)) + 1), "assigning variable local",
            stan::model::index_uni(2), stan::model::index_uni(1));
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(2),
                 stan::model::index_uni(2)) + 1), "assigning variable local",
              stan::model::index_uni(2), stan::model::index_uni(2));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(2),
                 stan::model::index_uni(3)) + 1), "assigning variable local",
              stan::model::index_uni(2), stan::model::index_uni(3));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(2),
                 stan::model::index_uni(4)) + 1), "assigning variable local",
              stan::model::index_uni(2), stan::model::index_uni(4));
          }
          {
            current_statement__ = 3;
            stan::model::assign(local,
              (stan::model::rvalue(local, "local", stan::model::index_uni(2),
                 stan::model::index_uni(5)) + 1), "assigning variable local",
              stan::model::index_uni(2), stan::model::index_uni(5));
          }
        }
      }
      if (emit_transformed_parameters__) {
        {
          out__.write(stan::model::rvalue(local, "local",
                        stan::model::index_uni(1), stan::model::index_uni(1)));
          {
            out__.write(stan::model::rvalue(local, "local",
                          stan::model::index_uni(2),
                          stan::model::index_uni(1)));
          }
        }
        {
          out__.write(stan::model::rvalue(local, "local",
                        stan::model::index_uni(1), stan::model::index_uni(2)));
          {
            out__.write(stan::model::rvalue(local, "local",
                          stan::model::index_uni(2),
                          stan::model::index_uni(2)));
          }
        }
        {
          out__.write(stan::model::rvalue(local, "local",
                        stan::model::index_uni(1), stan::model::index_uni(3)));
          {
            out__.write(stan::model::rvalue(local, "local",
                          stan::model::index_uni(2),
                          stan::model::index_uni(3)));
          }
        }
        {
          out__.write(stan::model::rvalue(local, "local",
                        stan::model::index_uni(1), stan::model::index_uni(4)));
          {
            out__.write(stan::model::rvalue(local, "local",
                          stan::model::index_uni(2),
                          stan::model::index_uni(4)));
          }
        }
        {
          out__.write(stan::model::rvalue(local, "local",
                        stan::model::index_uni(1), stan::model::index_uni(5)));
          {
            out__.write(stan::model::rvalue(local, "local",
                          stan::model::index_uni(2),
                          stan::model::index_uni(5)));
          }
        }
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ param;
      current_statement__ = 1;
      param = in__.read<local_scalar_t__>();
      out__.write(param);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "param", "double",
        std::vector<size_t>{});
      local_scalar_t__ param;
      current_statement__ = 1;
      param = context__.vals_r("param")[(1 - 1)];
      out__.write(param);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"param"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"local"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(2),
               static_cast<size_t>(5)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "param");
    if (emit_transformed_parameters__) {
      for (int sym25__ = 1; sym25__ <= 5; ++sym25__) {
        for (int sym26__ = 1; sym26__ <= 2; ++sym26__) {
          param_names__.emplace_back(std::string() + "local" + '.' +
            std::to_string(sym26__) + '.' + std::to_string(sym25__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "param");
    if (emit_transformed_parameters__) {
      for (int sym25__ = 1; sym25__ <= 5; ++sym25__) {
        for (int sym26__ = 1; sym26__ <= 2; ++sym26__) {
          param_names__.emplace_back(std::string() + "local" + '.' +
            std::to_string(sym26__) + '.' + std::to_string(sym25__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"param\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"local\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "}},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"param\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"local\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "}},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * ((2 * 5));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * ((2 * 5));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = unenforce_initialize_should_fail_model_namespace::unenforce_initialize_should_fail_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return unenforce_initialize_should_fail_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp unenforce-initialize.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace unenforce_initialize_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 12> locations_array__ =
  {" (found before start of program)",
  " (in 'unenforce-initialize.stan', line 2, column 2 to column 9)",
  " (in 'unenforce-initialize.stan', line 5, column 2 to column 15)",
  " (in 'unenforce-initialize.stan', line 6, column 2 to column 33)",
  " (in 'unenforce-initialize.stan', line 7, column 2 to column 39)",
  " (in 'unenforce-initialize.stan', line 8, column 2 to column 33)",
  " (in 'unenforce-initialize.stan', line 9, column 2 to column 18)",
  " (in 'unenforce-initialize.stan', line 13, column 2 to column 20)",
  " (in 'unenforce-initialize.stan', line 11, column 4 to column 21)",
  " (in 'unenforce-initialize.stan', line 10, column 2 to line 12, column 3)",
  " (in 'unenforce-initialize.stan', line 15, column 4 to column 21)",
  " (in 'unenforce-initialize.stan', line 14, column 2 to line 16, column 3)"};
class unenforce_initialize_model final : public model_base_crtp<unenforce_initialize_model> {
 private:
  
 public:
  ~unenforce_initialize_model() {}
  unenforce_initialize_model(stan::io::var_context& context__, unsigned int
                             random_seed__ = 0, std::ostream*
                             pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "unenforce_initialize_model_namespace::unenforce_initialize_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 1;
  }
  inline std::string model_name() const final {
    return "unenforce_initialize_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "unenforce_initialize_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym11__;
      double lcm_sym10__;
      double lcm_sym9__;
      local_scalar_t__ y;
      current_statement__ = 1;
      y = in__.template read<local_scalar_t__>();
      double no_init = std::numeric_limits<double>::quiet_NaN();
      local_scalar_t__ init_from_param;
      current_statement__ = 3;
      init_from_param = (y * 5.0);
      local_scalar_t__ dependent_no_init;
      current_statement__ = 4;
      dependent_no_init = (no_init * y);
      double used_on_lhs = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      used_on_lhs = used_on_lhs;
      double no_init_if = std::numeric_limits<double>::quiet_NaN();
      {
        current_statement__ = 8;
        no_init_if = 1.0;
      }
      double for_loop_var = std::numeric_limits<double>::quiet_NaN();
      {
        for_loop_var = 1;
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "unenforce_initialize_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym8__;
      double lcm_sym7__;
      double lcm_sym6__;
      local_scalar_t__ y;
      current_statement__ = 1;
      y = in__.template read<local_scalar_t__>();
      double no_init = std::numeric_limits<double>::quiet_NaN();
      local_scalar_t__ init_from_param;
      current_statement__ = 3;
      init_from_param = (y * 5.0);
      local_scalar_t__ dependent_no_init;
      current_statement__ = 4;
      dependent_no_init = (no_init * y);
      double used_on_lhs = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      used_on_lhs = used_on_lhs;
      double no_init_if = std::numeric_limits<double>::quiet_NaN();
      {
        current_statement__ = 8;
        no_init_if = 1.0;
      }
      double for_loop_var = std::numeric_limits<double>::quiet_NaN();
      {
        for_loop_var = 1;
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "unenforce_initialize_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      double y;
      current_statement__ = 1;
      y = in__.template read<local_scalar_t__>();
      double no_init = std::numeric_limits<double>::quiet_NaN();
      double init_from_param = std::numeric_limits<double>::quiet_NaN();
      double dependent_no_init = std::numeric_limits<double>::quiet_NaN();
      double used_on_lhs = std::numeric_limits<double>::quiet_NaN();
      double no_init_if = std::numeric_limits<double>::quiet_NaN();
      double for_loop_var = std::numeric_limits<double>::quiet_NaN();
      out__.write(y);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      lcm_sym4__ = (y * 5.0);
      init_from_param = lcm_sym4__;
      lcm_sym3__ = (no_init * y);
      dependent_no_init = lcm_sym3__;
      current_statement__ = 5;
      used_on_lhs = used_on_lhs;
      {
        current_statement__ = 8;
        no_init_if = 1.0;
      }
      {
        for_loop_var = 1;
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
        {
          current_statement__ = 10;
          for_loop_var = 1;
        }
      }
      if (emit_transformed_parameters__) {
        out__.write(no_init);
        out__.write(lcm_sym4__);
        out__.write(lcm_sym3__);
        out__.write(used_on_lhs);
        out__.write(no_init_if);
        out__.write(for_loop_var);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ y;
      current_statement__ = 1;
      y = in__.read<local_scalar_t__>();
      out__.write(y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "y", "double",
        std::vector<size_t>{});
      local_scalar_t__ y;
      current_statement__ = 1;
      y = context__.vals_r("y")[(1 - 1)];
      out__.write(y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"y"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"no_init", "init_from_param", "dependent_no_init",
             "used_on_lhs", "no_init_if", "for_loop_var"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{}, std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "y");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "no_init");
      param_names__.emplace_back(std::string() + "init_from_param");
      param_names__.emplace_back(std::string() + "dependent_no_init");
      param_names__.emplace_back(std::string() + "used_on_lhs");
      param_names__.emplace_back(std::string() + "no_init_if");
      param_names__.emplace_back(std::string() + "for_loop_var");
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "y");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "no_init");
      param_names__.emplace_back(std::string() + "init_from_param");
      param_names__.emplace_back(std::string() + "dependent_no_init");
      param_names__.emplace_back(std::string() + "used_on_lhs");
      param_names__.emplace_back(std::string() + "no_init_if");
      param_names__.emplace_back(std::string() + "for_loop_var");
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"no_init\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"init_from_param\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"dependent_no_init\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"used_on_lhs\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"no_init_if\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"for_loop_var\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"no_init\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"init_from_param\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"dependent_no_init\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"used_on_lhs\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"no_init_if\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"for_loop_var\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * ((((((1 + 1)
      + 1) + 1) + 1) + 1));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 1;
    const size_t num_transformed = emit_transformed_parameters * ((((((1 + 1)
      + 1) + 1) + 1) + 1));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = unenforce_initialize_model_namespace::unenforce_initialize_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return unenforce_initialize_model_namespace::profiles__;
}
#endif
  $ ../../../../../install/default/bin/stanc --O --print-cpp unroll-limit.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace unroll_limit_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 14> locations_array__ =
  {" (found before start of program)",
  " (in 'unroll-limit.stan', line 2, column 2 to column 8)",
  " (in 'unroll-limit.stan', line 4, column 4 to column 15)",
  " (in 'unroll-limit.stan', line 3, column 19 to line 5, column 3)",
  " (in 'unroll-limit.stan', line 3, column 2 to line 5, column 3)",
  " (in 'unroll-limit.stan', line 7, column 4 to column 15)",
  " (in 'unroll-limit.stan', line 6, column 2 to line 8, column 3)",
  " (in 'unroll-limit.stan', line 10, column 4 to column 15)",
  " (in 'unroll-limit.stan', line 9, column 2 to line 11, column 3)",
  " (in 'unroll-limit.stan', line 13, column 4 to column 15)",
  " (in 'unroll-limit.stan', line 12, column 2 to line 14, column 3)",
  " (in 'unroll-limit.stan', line 16, column 4 to column 15)",
  " (in 'unroll-limit.stan', line 15, column 20 to line 17, column 3)",
  " (in 'unroll-limit.stan', line 15, column 2 to line 17, column 3)"};
class unroll_limit_model final : public model_base_crtp<unroll_limit_model> {
 private:
  
 public:
  ~unroll_limit_model() {}
  unroll_limit_model(stan::io::var_context& context__, unsigned int
                     random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "unroll_limit_model_namespace::unroll_limit_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = 0U;
  }
  inline std::string model_name() const final {
    return "unroll_limit_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = --O --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "unroll_limit_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "unroll_limit_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "unroll_limit_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      int lcm_sym12__;
      int lcm_sym11__;
      int lcm_sym10__;
      int lcm_sym9__;
      int lcm_sym8__;
      int lcm_sym7__;
      int lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      int x = std::numeric_limits<int>::min();
      {
        current_statement__ = 2;
        x = (x + 2);
        for (int i = 2; i <= 100; ++i) {
          current_statement__ = 2;
          x = (x + (1 + i));
        }
      }
      {
        current_statement__ = 5;
        x = (x + 3);
        {
          current_statement__ = 5;
          x = (x + (2 + 2));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 3));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 4));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 5));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 6));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 7));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 8));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 9));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 10));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 11));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 12));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 13));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 14));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 15));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 16));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 17));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 18));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 19));
        }
        {
          current_statement__ = 5;
          x = (x + (2 + 20));
        }
      }
      {
        current_statement__ = 7;
        x = (x + 53);
        {
          current_statement__ = 7;
          x = (x + (3 + 51));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 52));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 53));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 54));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 55));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 56));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 57));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 58));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 59));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 60));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 61));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 62));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 63));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 64));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 65));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 66));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 67));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 68));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 69));
        }
        {
          current_statement__ = 7;
          x = (x + (3 + 70));
        }
      }
      {
        current_statement__ = 9;
        x = (x + -6);
        {
          current_statement__ = 9;
          x = (x + (4 + -9));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -8));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -7));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -6));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -5));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -4));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -3));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -2));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + -1));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 0));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 1));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 2));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 3));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 4));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 5));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 6));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 7));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 8));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 9));
        }
        {
          current_statement__ = 9;
          x = (x + (4 + 10));
        }
      }
      {
        current_statement__ = 11;
        x = (x + -5);
        for (int i = -9; i <= 40; ++i) {
          current_statement__ = 11;
          x = (x + (5 + i));
        }
      }
      out__.write(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      std::vector<std::string> temp{"x"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>> temp{std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "x");
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "x");
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (1);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = 0;
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (1);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = unroll_limit_model_namespace::unroll_limit_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return unroll_limit_model_namespace::profiles__;
}
#endif
