  $ ../../../../../install/default/bin/stanc --print-cpp --O0 ad-level-deep-dependence.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace ad_level_deep_dependence_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 11> locations_array__ = 
{" (found before start of program)",
 " (in 'ad-level-deep-dependence.stan', line 10, column 4 to column 23)",
 " (in 'ad-level-deep-dependence.stan', line 14, column 4 to column 31)",
 " (in 'ad-level-deep-dependence.stan', line 15, column 4 to column 38)",
 " (in 'ad-level-deep-dependence.stan', line 16, column 4 to column 38)",
 " (in 'ad-level-deep-dependence.stan', line 17, column 4 to column 38)",
 " (in 'ad-level-deep-dependence.stan', line 18, column 4 to column 38)",
 " (in 'ad-level-deep-dependence.stan', line 19, column 4 to column 38)",
 " (in 'ad-level-deep-dependence.stan', line 20, column 4 to column 38)",
 " (in 'ad-level-deep-dependence.stan', line 21, column 4 to column 16)",
 " (in 'ad-level-deep-dependence.stan', line 7, column 4 to column 23)"};




class ad_level_deep_dependence_model final : public model_base_crtp<ad_level_deep_dependence_model> {

 private:
  Eigen::Matrix<double, -1, -1> X_d__; 
  Eigen::Map<Eigen::Matrix<double, -1, -1>> X_d{nullptr, 0, 0};
 
 public:
  ~ad_level_deep_dependence_model() { }
  
  inline std::string model_name() const final { return "ad_level_deep_dependence_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  ad_level_deep_dependence_model(stan::io::var_context& context__,
                                 unsigned int random_seed__ = 0,
                                 std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "ad_level_deep_dependence_model_namespace::ad_level_deep_dependence_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 10;
      context__.validate_dims("data initialization","X_d","double",
           std::vector<size_t>{static_cast<size_t>(10),
            static_cast<size_t>(10)});
      X_d__ = 
        Eigen::Matrix<double, -1, -1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      new (&X_d) Eigen::Map<Eigen::Matrix<double, -1, -1>>(X_d__.data(), 10, 10);
        
      
      {
        std::vector<local_scalar_t__> X_d_flat__;
        current_statement__ = 10;
        X_d_flat__ = context__.vals_r("X_d");
        current_statement__ = 10;
        pos__ = 1;
        current_statement__ = 10;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          current_statement__ = 10;
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            current_statement__ = 10;
            stan::model::assign(X_d, X_d_flat__[(pos__ - 1)],
              "assigning variable X_d", stan::model::index_uni(sym2__),
                                          stan::model::index_uni(sym1__));
            current_statement__ = 10;
            pos__ = (pos__ + 1);
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (10 * 10);
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "ad_level_deep_dependence_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, -1> X_p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
              10);
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp1 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(X_tp1, X_d, "assigning variable X_tp1");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp2 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(X_tp2, stan::math::exp(X_tp1),
        "assigning variable X_tp2");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp3 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(X_tp3, stan::math::exp(X_tp2),
        "assigning variable X_tp3");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp4 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(X_tp4, stan::math::exp(X_tp3),
        "assigning variable X_tp4");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp5 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(X_tp5, stan::math::exp(X_tp4),
        "assigning variable X_tp5");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp6 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(X_tp6, stan::math::exp(X_tp5),
        "assigning variable X_tp6");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp7 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(X_tp7, stan::math::exp(X_tp6),
        "assigning variable X_tp7");
      current_statement__ = 9;
      stan::model::assign(X_tp1, X_p, "assigning variable X_tp1");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "ad_level_deep_dependence_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, -1> X_p =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
              10);
      Eigen::Matrix<double, -1, -1> X_tp1 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp2 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp3 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp4 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp5 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp6 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp7 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(X_p);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 2;
      stan::model::assign(X_tp1, X_d, "assigning variable X_tp1");
      current_statement__ = 3;
      stan::model::assign(X_tp2, stan::math::exp(X_tp1),
        "assigning variable X_tp2");
      current_statement__ = 4;
      stan::model::assign(X_tp3, stan::math::exp(X_tp2),
        "assigning variable X_tp3");
      current_statement__ = 5;
      stan::model::assign(X_tp4, stan::math::exp(X_tp3),
        "assigning variable X_tp4");
      current_statement__ = 6;
      stan::model::assign(X_tp5, stan::math::exp(X_tp4),
        "assigning variable X_tp5");
      current_statement__ = 7;
      stan::model::assign(X_tp6, stan::math::exp(X_tp5),
        "assigning variable X_tp6");
      current_statement__ = 8;
      stan::model::assign(X_tp7, stan::math::exp(X_tp6),
        "assigning variable X_tp7");
      current_statement__ = 9;
      stan::model::assign(X_tp1, X_p, "assigning variable X_tp1");
      if (emit_transformed_parameters__) {
        out__.write(X_tp1);
        out__.write(X_tp2);
        out__.write(X_tp3);
        out__.write(X_tp4);
        out__.write(X_tp5);
        out__.write(X_tp6);
        out__.write(X_tp7);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, -1> X_p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          stan::model::assign(X_p, in__.read<local_scalar_t__>(),
            "assigning variable X_p", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
        }
      }
      out__.write(X_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"X_p", "X_tp1", "X_tp2", "X_tp3",
      "X_tp4", "X_tp5", "X_tp6", "X_tp7"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(10)
                                                                   ,
                                                                   static_cast<size_t>(10)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "X_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp3" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp4" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp5" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp6" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp7" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "X_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp3" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp4" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp5" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp6" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp7" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"X_tp1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp3\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp4\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp5\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp6\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp7\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"X_tp1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp3\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp4\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp5\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp6\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp7\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (10 * 10);
      const size_t num_transformed = (((((((10 * 10) +
                                                         (10 * 10)) +
                                                        (10 * 10)) +
                                                       (10 * 10)) +
                                                      (10 * 10)) + (10 * 10))
                                                    + (10 * 10));
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (10 * 10);
      const size_t num_transformed = (((((((10 * 10) +
                                                         (10 * 10)) +
                                                        (10 * 10)) +
                                                       (10 * 10)) +
                                                      (10 * 10)) + (10 * 10))
                                                    + (10 * 10));
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 1> names__{"X_p"};
      const std::array<Eigen::Index, 1> constrain_param_sizes__{(10 * 10)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}

using stan_model = ad_level_deep_dependence_model_namespace::ad_level_deep_dependence_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return ad_level_deep_dependence_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 ad-level-failing.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace ad_level_failing_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 37> locations_array__ = 
{" (found before start of program)",
 " (in 'ad-level-failing.stan', line 37, column 2 to column 21)",
 " (in 'ad-level-failing.stan', line 38, column 2 to column 22)",
 " (in 'ad-level-failing.stan', line 39, column 2 to column 19)",
 " (in 'ad-level-failing.stan', line 40, column 2 to column 22)",
 " (in 'ad-level-failing.stan', line 43, column 2 to column 32)",
 " (in 'ad-level-failing.stan', line 45, column 4 to column 58)",
 " (in 'ad-level-failing.stan', line 46, column 4 to column 67)",
 " (in 'ad-level-failing.stan', line 44, column 2 to line 47, column 3)",
 " (in 'ad-level-failing.stan', line 50, column 2 to column 24)",
 " (in 'ad-level-failing.stan', line 51, column 2 to column 23)",
 " (in 'ad-level-failing.stan', line 52, column 2 to column 21)",
 " (in 'ad-level-failing.stan', line 53, column 2 to column 23)",
 " (in 'ad-level-failing.stan', line 55, column 2 to column 41)",
 " (in 'ad-level-failing.stan', line 57, column 4 to column 49)",
 " (in 'ad-level-failing.stan', line 56, column 2 to line 57, column 49)",
 " (in 'ad-level-failing.stan', line 59, column 2 to column 53)",
 " (in 'ad-level-failing.stan', line 23, column 2 to column 19)",
 " (in 'ad-level-failing.stan', line 24, column 8 to column 11)",
 " (in 'ad-level-failing.stan', line 24, column 2 to column 20)",
 " (in 'ad-level-failing.stan', line 25, column 2 to column 19)",
 " (in 'ad-level-failing.stan', line 26, column 8 to column 11)",
 " (in 'ad-level-failing.stan', line 26, column 2 to column 26)",
 " (in 'ad-level-failing.stan', line 27, column 8 to column 11)",
 " (in 'ad-level-failing.stan', line 27, column 2 to column 24)",
 " (in 'ad-level-failing.stan', line 30, column 2 to column 14)",
 " (in 'ad-level-failing.stan', line 31, column 2 to column 32)",
 " (in 'ad-level-failing.stan', line 33, column 2 to column 20)",
 " (in 'ad-level-failing.stan', line 34, column 2 to column 19)",
 " (in 'ad-level-failing.stan', line 43, column 8 to column 11)",
 " (in 'ad-level-failing.stan', line 12, column 4 to column 23)",
 " (in 'ad-level-failing.stan', line 14, column 4 to column 58)",
 " (in 'ad-level-failing.stan', line 15, column 4 to column 75)",
 " (in 'ad-level-failing.stan', line 16, column 4 to column 30)",
 " (in 'ad-level-failing.stan', line 17, column 4 to column 48)",
 " (in 'ad-level-failing.stan', line 19, column 4 to column 16)",
 " (in 'ad-level-failing.stan', line 11, column 61 to line 20, column 3)"};

struct simple_SIR_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            stan::require_stan_scalar_t<T0__>* = nullptr,
            stan::require_stan_scalar_t<T1__>* = nullptr,
            stan::require_stan_scalar_t<T2__>* = nullptr,
            stan::require_stan_scalar_t<T3__>* = nullptr>
  std::vector<stan::promote_args_t<T0__, T1__, T2__, T3__>>
  operator()(const T0__& t, const std::vector<T1__>& y,
             const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
             const std::vector<int>& x_i, std::ostream* pstream__) const;
};

template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_stan_scalar_t<T0__>* = nullptr,
          stan::require_stan_scalar_t<T1__>* = nullptr,
          stan::require_stan_scalar_t<T2__>* = nullptr,
          stan::require_stan_scalar_t<T3__>* = nullptr>
  std::vector<stan::promote_args_t<T0__, T1__, T2__, T3__>>
  simple_SIR(const T0__& t, const std::vector<T1__>& y,
             const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
             const std::vector<int>& x_i, std::ostream* pstream__) {
    using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__>;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      std::vector<local_scalar_t__> dydt =
         std::vector<local_scalar_t__>(4, DUMMY_VAR__);
      current_statement__ = 31;
      stan::model::assign(dydt,
        (((-stan::model::rvalue(theta, "theta", stan::model::index_uni(1)) *
            stan::model::rvalue(y, "y", stan::model::index_uni(4))) /
           (stan::model::rvalue(y, "y", stan::model::index_uni(4)) +
             stan::model::rvalue(theta, "theta", stan::model::index_uni(2))))
          * stan::model::rvalue(y, "y", stan::model::index_uni(1))),
        "assigning variable dydt", stan::model::index_uni(1));
      current_statement__ = 32;
      stan::model::assign(dydt,
        ((((stan::model::rvalue(theta, "theta", stan::model::index_uni(1)) *
             stan::model::rvalue(y, "y", stan::model::index_uni(4))) /
            (stan::model::rvalue(y, "y", stan::model::index_uni(4)) +
              stan::model::rvalue(theta, "theta", stan::model::index_uni(2))))
           * stan::model::rvalue(y, "y", stan::model::index_uni(1))) -
          (stan::model::rvalue(theta, "theta", stan::model::index_uni(3)) *
            stan::model::rvalue(y, "y", stan::model::index_uni(2)))),
        "assigning variable dydt", stan::model::index_uni(2));
      current_statement__ = 33;
      stan::model::assign(dydt,
        (stan::model::rvalue(theta, "theta", stan::model::index_uni(3)) *
          stan::model::rvalue(y, "y", stan::model::index_uni(2))),
        "assigning variable dydt", stan::model::index_uni(3));
      current_statement__ = 34;
      stan::model::assign(dydt,
        ((stan::model::rvalue(theta, "theta", stan::model::index_uni(4)) *
           stan::model::rvalue(y, "y", stan::model::index_uni(2))) -
          (stan::model::rvalue(theta, "theta", stan::model::index_uni(5)) *
            stan::model::rvalue(y, "y", stan::model::index_uni(4)))),
        "assigning variable dydt", stan::model::index_uni(4));
      current_statement__ = 35;
      return dydt;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_stan_scalar_t<T0__>*,
          stan::require_stan_scalar_t<T1__>*,
          stan::require_stan_scalar_t<T2__>*,
          stan::require_stan_scalar_t<T3__>*>
std::vector<stan::promote_args_t<T0__, T1__, T2__, T3__>>
simple_SIR_functor__::operator()(const T0__& t, const std::vector<T1__>& y,
                                 const std::vector<T2__>& theta,
                                 const std::vector<T3__>& x_r,
                                 const std::vector<int>& x_i,
                                 std::ostream* pstream__)  const
{
  return simple_SIR(t, y, theta, x_r, x_i, pstream__);
}


class ad_level_failing_model final : public model_base_crtp<ad_level_failing_model> {

 private:
  int N_t;
  std::vector<double> t;
  std::vector<double> y0;
  std::vector<int> stoi_hat;
  std::vector<double> B_hat;
  double t0;
  double kappa;
  std::vector<double> x_r;
  std::vector<int> x_i; 
  
 
 public:
  ~ad_level_failing_model() { }
  
  inline std::string model_name() const final { return "ad_level_failing_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  ad_level_failing_model(stan::io::var_context& context__,
                         unsigned int random_seed__ = 0,
                         std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "ad_level_failing_model_namespace::ad_level_failing_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 17;
      context__.validate_dims("data initialization","N_t","int",
           std::vector<size_t>{});
      N_t = std::numeric_limits<int>::min();
      
      
      current_statement__ = 17;
      N_t = context__.vals_i("N_t")[(1 - 1)];
      current_statement__ = 17;
      stan::math::check_greater_or_equal(function__, "N_t", N_t, 0);
      current_statement__ = 18;
      stan::math::validate_non_negative_index("t", "N_t", N_t);
      current_statement__ = 19;
      context__.validate_dims("data initialization","t","double",
           std::vector<size_t>{static_cast<size_t>(N_t)});
      t = std::vector<double>(N_t, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 19;
      t = context__.vals_r("t");
      current_statement__ = 20;
      context__.validate_dims("data initialization","y0","double",
           std::vector<size_t>{static_cast<size_t>(4)});
      y0 = std::vector<double>(4, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 20;
      y0 = context__.vals_r("y0");
      current_statement__ = 21;
      stan::math::validate_non_negative_index("stoi_hat", "N_t", N_t);
      current_statement__ = 22;
      context__.validate_dims("data initialization","stoi_hat","int",
           std::vector<size_t>{static_cast<size_t>(N_t)});
      stoi_hat = std::vector<int>(N_t, std::numeric_limits<int>::min());
      
      
      current_statement__ = 22;
      stoi_hat = context__.vals_i("stoi_hat");
      current_statement__ = 23;
      stan::math::validate_non_negative_index("B_hat", "N_t", N_t);
      current_statement__ = 24;
      context__.validate_dims("data initialization","B_hat","double",
           std::vector<size_t>{static_cast<size_t>(N_t)});
      B_hat = 
        std::vector<double>(N_t, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 24;
      B_hat = context__.vals_r("B_hat");
      current_statement__ = 25;
      t0 = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 25;
      t0 = 0;
      current_statement__ = 26;
      kappa = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 26;
      kappa = 1000000;
      current_statement__ = 27;
      x_r = std::vector<double>(0, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 28;
      x_i = std::vector<int>(0, std::numeric_limits<int>::min());
      
      
      current_statement__ = 26;
      stan::math::check_greater_or_equal(function__, "kappa", kappa, 0);
      current_statement__ = 29;
      stan::math::validate_non_negative_index("y", "N_t", N_t);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "ad_level_failing_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ beta = DUMMY_VAR__;
      current_statement__ = 1;
      beta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      local_scalar_t__ gamma = DUMMY_VAR__;
      current_statement__ = 2;
      gamma = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                0, lp__);
      local_scalar_t__ xi = DUMMY_VAR__;
      current_statement__ = 3;
      xi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
             lp__);
      local_scalar_t__ delta = DUMMY_VAR__;
      current_statement__ = 4;
      delta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                0, lp__);
      std::vector<std::vector<local_scalar_t__>> y =
         std::vector<std::vector<local_scalar_t__>>(N_t, 
           std::vector<local_scalar_t__>(4, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> theta =
           std::vector<local_scalar_t__>(5, DUMMY_VAR__);
        current_statement__ = 6;
        stan::model::assign(theta, std::vector<local_scalar_t__>{beta,
          stan::math::promote_scalar<local_scalar_t__>(kappa), gamma, xi,
          delta}, "assigning variable theta");
        current_statement__ = 7;
        stan::model::assign(y,
          stan::math::integrate_ode_rk45(simple_SIR_functor__(), y0, t0, t,
            theta, x_r, x_i, pstream__), "assigning variable y");
      }
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      {
        current_statement__ = 9;
        lp_accum__.add(stan::math::cauchy_lpdf<propto__>(beta, 0, 2.5));
        current_statement__ = 10;
        lp_accum__.add(stan::math::cauchy_lpdf<propto__>(gamma, 0, 1));
        current_statement__ = 11;
        lp_accum__.add(stan::math::cauchy_lpdf<propto__>(xi, 0, 25));
        current_statement__ = 12;
        lp_accum__.add(stan::math::cauchy_lpdf<propto__>(delta, 0, 1));
        current_statement__ = 13;
        lp_accum__.add(
          stan::math::poisson_lpmf<propto__>(
            stan::model::rvalue(stoi_hat, "stoi_hat",
              stan::model::index_uni(1)),
            (stan::model::rvalue(y0, "y0", stan::model::index_uni(1)) -
              stan::model::rvalue(y, "y",
                stan::model::index_uni(1), stan::model::index_uni(1)))));
        current_statement__ = 15;
        for (int n = 2; n <= N_t; ++n) {
          current_statement__ = 14;
          lp_accum__.add(
            stan::math::poisson_lpmf<propto__>(
              stan::model::rvalue(stoi_hat, "stoi_hat",
                stan::model::index_uni(n)),
              (stan::model::rvalue(y, "y",
                 stan::model::index_uni((n - 1)), stan::model::index_uni(1))
                -
                stan::model::rvalue(y, "y",
                  stan::model::index_uni(n), stan::model::index_uni(1)))));
        }
        current_statement__ = 16;
        lp_accum__.add(
          stan::math::lognormal_lpdf<propto__>(B_hat,
            stan::math::log(stan::math::col(stan::math::to_matrix(y), 4)),
            0.15));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "ad_level_failing_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double beta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      beta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      double gamma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      gamma = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                0, lp__);
      double xi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      xi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
             lp__);
      double delta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      delta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                0, lp__);
      std::vector<std::vector<double>> y =
         std::vector<std::vector<double>>(N_t, 
           std::vector<double>(4, std::numeric_limits<double>::quiet_NaN()));
      out__.write(beta);
      out__.write(gamma);
      out__.write(xi);
      out__.write(delta);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      {
        std::vector<double> theta =
           std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 6;
        stan::model::assign(theta, std::vector<local_scalar_t__>{beta,
          stan::math::promote_scalar<local_scalar_t__>(kappa), gamma, xi,
          delta}, "assigning variable theta");
        current_statement__ = 7;
        stan::model::assign(y,
          stan::math::integrate_ode_rk45(simple_SIR_functor__(), y0, t0, t,
            theta, x_r, x_i, pstream__), "assigning variable y");
      }
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N_t; ++sym2__) {
            out__.write(y[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ beta = DUMMY_VAR__;
      beta = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, beta);
      local_scalar_t__ gamma = DUMMY_VAR__;
      gamma = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, gamma);
      local_scalar_t__ xi = DUMMY_VAR__;
      xi = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, xi);
      local_scalar_t__ delta = DUMMY_VAR__;
      delta = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, delta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"beta", "gamma", "xi", "delta", "y"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      },
      std::vector<size_t>{static_cast<size_t>(N_t), static_cast<size_t>(4)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta");
    param_names__.emplace_back(std::string() + "gamma");
    param_names__.emplace_back(std::string() + "xi");
    param_names__.emplace_back(std::string() + "delta");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N_t; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta");
    param_names__.emplace_back(std::string() + "gamma");
    param_names__.emplace_back(std::string() + "xi");
    param_names__.emplace_back(std::string() + "delta");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N_t; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"xi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N_t) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"xi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N_t) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(4) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((1 + 1) + 1) + 1);
      const size_t num_transformed = (N_t * 4);
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((1 + 1) + 1) + 1);
      const size_t num_transformed = (N_t * 4);
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 4> names__{"beta", "gamma", "xi",
      "delta"};
      const std::array<Eigen::Index, 4> constrain_param_sizes__{1, 1, 1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } 
using stan_model = ad_level_failing_model_namespace::ad_level_failing_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return ad_level_failing_model_namespace::profiles__;
}

#endif



Warning in 'ad-level-failing.stan', line 46, column 8: integrate_ode_rk45 is
    deprecated and will be removed in Stan 3.0. Use ode_rk45 instead. 
    The new interface is slightly different, see:
    https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../../install/default/bin/stanc --print-cpp --O0 ad-levels-deep.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace ad_levels_deep_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 6> locations_array__ = 
{" (found before start of program)",
 " (in 'ad-levels-deep.stan', line 6, column 4 to column 23)",
 " (in 'ad-levels-deep.stan', line 10, column 4 to column 39)",
 " (in 'ad-levels-deep.stan', line 11, column 4 to column 38)",
 " (in 'ad-levels-deep.stan', line 12, column 4 to column 16)",
 " (in 'ad-levels-deep.stan', line 2, column 4 to column 26)"};




class ad_levels_deep_model final : public model_base_crtp<ad_levels_deep_model> {

 private:
  Eigen::Matrix<double, -1, -1> X_data__; 
  Eigen::Map<Eigen::Matrix<double, -1, -1>> X_data{nullptr, 0, 0};
 
 public:
  ~ad_levels_deep_model() { }
  
  inline std::string model_name() const final { return "ad_levels_deep_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  ad_levels_deep_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "ad_levels_deep_model_namespace::ad_levels_deep_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 5;
      context__.validate_dims("data initialization","X_data","double",
           std::vector<size_t>{static_cast<size_t>(10),
            static_cast<size_t>(10)});
      X_data__ = 
        Eigen::Matrix<double, -1, -1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      new (&X_data) Eigen::Map<Eigen::Matrix<double, -1, -1>>(X_data__.data(), 10, 10);
        
      
      {
        std::vector<local_scalar_t__> X_data_flat__;
        current_statement__ = 5;
        X_data_flat__ = context__.vals_r("X_data");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          current_statement__ = 5;
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            current_statement__ = 5;
            stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
              "assigning variable X_data", stan::model::index_uni(sym2__),
                                             stan::model::index_uni(sym1__));
            current_statement__ = 5;
            pos__ = (pos__ + 1);
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (10 * 10);
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "ad_levels_deep_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, -1> X_p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
              10);
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp1 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(X_tp1, stan::math::exp(X_data),
        "assigning variable X_tp1");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp2 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(X_tp2, stan::math::exp(X_tp1),
        "assigning variable X_tp2");
      current_statement__ = 4;
      stan::model::assign(X_tp1, X_p, "assigning variable X_tp1");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "ad_levels_deep_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, -1> X_p =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
              10);
      Eigen::Matrix<double, -1, -1> X_tp1 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp2 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(X_p);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 2;
      stan::model::assign(X_tp1, stan::math::exp(X_data),
        "assigning variable X_tp1");
      current_statement__ = 3;
      stan::model::assign(X_tp2, stan::math::exp(X_tp1),
        "assigning variable X_tp2");
      current_statement__ = 4;
      stan::model::assign(X_tp1, X_p, "assigning variable X_tp1");
      if (emit_transformed_parameters__) {
        out__.write(X_tp1);
        out__.write(X_tp2);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, -1> X_p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          stan::model::assign(X_p, in__.read<local_scalar_t__>(),
            "assigning variable X_p", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
        }
      }
      out__.write(X_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"X_p", "X_tp1", "X_tp2"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(10)
                                                                   ,
                                                                   static_cast<size_t>(10)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "X_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "X_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"X_tp1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"X_tp1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (10 * 10);
      const size_t num_transformed = ((10 * 10) + (10 * 10));
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (10 * 10);
      const size_t num_transformed = ((10 * 10) + (10 * 10));
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 1> names__{"X_p"};
      const std::array<Eigen::Index, 1> constrain_param_sizes__{(10 * 10)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = ad_levels_deep_model_namespace::ad_levels_deep_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return ad_levels_deep_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 copy_fail.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace copy_fail_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 76> locations_array__ = 
{" (found before start of program)",
 " (in 'copy_fail.stan', line 68, column 2 to column 32)",
 " (in 'copy_fail.stan', line 69, column 2 to column 41)",
 " (in 'copy_fail.stan', line 72, column 2 to column 52)",
 " (in 'copy_fail.stan', line 73, column 2 to column 50)",
 " (in 'copy_fail.stan', line 74, column 2 to column 50)",
 " (in 'copy_fail.stan', line 79, column 6 to column 20)",
 " (in 'copy_fail.stan', line 80, column 6 to column 18)",
 " (in 'copy_fail.stan', line 78, column 34 to line 81, column 5)",
 " (in 'copy_fail.stan', line 78, column 4 to line 81, column 5)",
 " (in 'copy_fail.stan', line 83, column 6 to column 32)",
 " (in 'copy_fail.stan', line 84, column 6 to column 23)",
 " (in 'copy_fail.stan', line 82, column 40 to line 85, column 5)",
 " (in 'copy_fail.stan', line 82, column 4 to line 85, column 5)",
 " (in 'copy_fail.stan', line 77, column 22 to line 86, column 3)",
 " (in 'copy_fail.stan', line 77, column 2 to line 86, column 3)",
 " (in 'copy_fail.stan', line 88, column 2 to column 51)",
 " (in 'copy_fail.stan', line 100, column 8 to column 37)",
 " (in 'copy_fail.stan', line 101, column 8 to column 41)",
 " (in 'copy_fail.stan', line 99, column 42 to line 102, column 7)",
 " (in 'copy_fail.stan', line 99, column 6 to line 102, column 7)",
 " (in 'copy_fail.stan', line 103, column 6 to column 37)",
 " (in 'copy_fail.stan', line 98, column 22 to line 104, column 5)",
 " (in 'copy_fail.stan', line 98, column 4 to line 104, column 5)",
 " (in 'copy_fail.stan', line 97, column 22 to line 105, column 3)",
 " (in 'copy_fail.stan', line 97, column 2 to line 105, column 3)",
 " (in 'copy_fail.stan', line 49, column 2 to column 20)",
 " (in 'copy_fail.stan', line 50, column 2 to column 27)",
 " (in 'copy_fail.stan', line 51, column 8 to column 12)",
 " (in 'copy_fail.stan', line 51, column 14 to column 25)",
 " (in 'copy_fail.stan', line 51, column 2 to column 51)",
 " (in 'copy_fail.stan', line 52, column 2 to column 23)",
 " (in 'copy_fail.stan', line 53, column 8 to column 12)",
 " (in 'copy_fail.stan', line 53, column 14 to column 29)",
 " (in 'copy_fail.stan', line 53, column 2 to column 61)",
 " (in 'copy_fail.stan', line 56, column 2 to column 38)",
 " (in 'copy_fail.stan', line 58, column 8 to column 12)",
 " (in 'copy_fail.stan', line 58, column 2 to column 52)",
 " (in 'copy_fail.stan', line 59, column 8 to column 12)",
 " (in 'copy_fail.stan', line 59, column 2 to column 51)",
 " (in 'copy_fail.stan', line 63, column 4 to column 35)",
 " (in 'copy_fail.stan', line 62, column 2 to line 63, column 35)",
 " (in 'copy_fail.stan', line 65, column 4 to column 33)",
 " (in 'copy_fail.stan', line 64, column 2 to line 65, column 33)",
 " (in 'copy_fail.stan', line 69, column 27 to column 34)",
 " (in 'copy_fail.stan', line 72, column 27 to column 31)",
 " (in 'copy_fail.stan', line 72, column 33 to column 46)",
 " (in 'copy_fail.stan', line 73, column 27 to column 31)",
 " (in 'copy_fail.stan', line 73, column 33 to column 46)",
 " (in 'copy_fail.stan', line 74, column 27 to column 31)",
 " (in 'copy_fail.stan', line 74, column 33 to column 44)",
 " (in 'copy_fail.stan', line 8, column 8 to column 17)",
 " (in 'copy_fail.stan', line 7, column 6 to line 8, column 17)",
 " (in 'copy_fail.stan', line 6, column 4 to line 8, column 17)",
 " (in 'copy_fail.stan', line 9, column 4 to column 13)",
 " (in 'copy_fail.stan', line 5, column 37 to line 10, column 3)",
 " (in 'copy_fail.stan', line 15, column 6 to column 32)",
 " (in 'copy_fail.stan', line 19, column 8 to column 17)",
 " (in 'copy_fail.stan', line 18, column 6 to line 19, column 17)",
 " (in 'copy_fail.stan', line 13, column 39 to line 20, column 5)",
 " (in 'copy_fail.stan', line 13, column 4 to line 20, column 5)",
 " (in 'copy_fail.stan', line 21, column 4 to column 13)",
 " (in 'copy_fail.stan', line 12, column 36 to line 22, column 3)",
 " (in 'copy_fail.stan', line 25, column 11 to column 15)",
 " (in 'copy_fail.stan', line 25, column 17 to column 28)",
 " (in 'copy_fail.stan', line 25, column 4 to column 34)",
 " (in 'copy_fail.stan', line 28, column 6 to column 32)",
 " (in 'copy_fail.stan', line 31, column 8 to column 37)",
 " (in 'copy_fail.stan', line 32, column 8 to column 32)",
 " (in 'copy_fail.stan', line 40, column 8 to line 42, column 44)",
 " (in 'copy_fail.stan', line 29, column 39 to line 43, column 7)",
 " (in 'copy_fail.stan', line 29, column 6 to line 43, column 7)",
 " (in 'copy_fail.stan', line 27, column 24 to line 44, column 5)",
 " (in 'copy_fail.stan', line 27, column 4 to line 44, column 5)",
 " (in 'copy_fail.stan', line 45, column 4 to column 15)",
 " (in 'copy_fail.stan', line 24, column 74 to line 46, column 3)"};

struct first_capture_functor__ {
  int
  operator()(const std::vector<int>& y_i, std::ostream* pstream__) const;
};
struct prob_uncaptured_functor__ {
  template <typename T2__, typename T3__,
            stan::require_eigen_matrix_dynamic_t<T2__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>, stan::value_type_t<T3__>>, -1, -1>
  operator()(const int& nind, const int& n_occasions, const T2__& p,
             const T3__& phi, std::ostream* pstream__) const;
};
struct last_capture_functor__ {
  int
  operator()(const std::vector<int>& y_i, std::ostream* pstream__) const;
};

int first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 53;
      for (int k = 1; k <= stan::math::size(y_i); ++k) {
        current_statement__ = 52;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
          current_statement__ = 51;
          return k;
        } 
      }
      current_statement__ = 54;
      return 0;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 60;
      for (int k_rev = 0; k_rev <= (stan::math::size(y_i) - 1); ++k_rev) {
        int k = std::numeric_limits<int>::min();
        current_statement__ = 56;
        k = (stan::math::size(y_i) - k_rev);
        current_statement__ = 58;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
          current_statement__ = 57;
          return k;
        } 
      }
      current_statement__ = 61;
      return 0;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T2__, typename T3__,
          stan::require_eigen_matrix_dynamic_t<T2__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>, stan::value_type_t<T3__>>, -1, -1>
  prob_uncaptured(const int& nind, const int& n_occasions,
                  const T2__& p_arg__, const T3__& phi_arg__,
                  std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<stan::value_type_t<T2__>,
                                 stan::value_type_t<T3__>>;
    int current_statement__ = 0; 
    const auto& p = stan::math::to_ref(p_arg__);
    const auto& phi = stan::math::to_ref(phi_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 63;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 64;
      stan::math::validate_non_negative_index("chi", "n_occasions",
                                              n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind, n_occasions,
           DUMMY_VAR__);
      current_statement__ = 73;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 66;
        stan::model::assign(chi, 1.0,
          "assigning variable chi", stan::model::index_uni(i),
                                      stan::model::index_uni(n_occasions));
        current_statement__ = 71;
        for (int t = 1; t <= (n_occasions - 1); ++t) {
          int t_curr = std::numeric_limits<int>::min();
          current_statement__ = 67;
          t_curr = (n_occasions - t);
          int t_next = std::numeric_limits<int>::min();
          current_statement__ = 68;
          t_next = (t_curr + 1);
          current_statement__ = 69;
          stan::model::assign(chi,
            ((1 -
               stan::model::rvalue(phi, "phi",
                 stan::model::index_uni(i), stan::model::index_uni(t_curr)))
              +
              ((stan::model::rvalue(phi, "phi",
                  stan::model::index_uni(i), stan::model::index_uni(t_curr))
                 *
                 (1 -
                   stan::model::rvalue(p, "p",
                     stan::model::index_uni(i),
                       stan::model::index_uni((t_next - 1))))) *
                stan::model::rvalue(chi, "chi",
                  stan::model::index_uni(i), stan::model::index_uni(t_next)))),
            "assigning variable chi", stan::model::index_uni(i),
                                        stan::model::index_uni(t_curr));
        }
      }
      current_statement__ = 74;
      return chi;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int
first_capture_functor__::operator()(const std::vector<int>& y_i,
                                    std::ostream* pstream__)  const
{
  return first_capture(y_i, pstream__);
}

template <typename T2__, typename T3__,
          stan::require_eigen_matrix_dynamic_t<T2__>*,
          stan::require_eigen_matrix_dynamic_t<T3__>*>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>, stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured_functor__::operator()(const int& nind,
                                      const int& n_occasions, const T2__& p,
                                      const T3__& phi,
                                      std::ostream* pstream__)  const
{
  return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}

int
last_capture_functor__::operator()(const std::vector<int>& y_i,
                                   std::ostream* pstream__)  const
{
  return last_capture(y_i, pstream__);
}

 class copy_fail_model final : public model_base_crtp<copy_fail_model> {

 private:
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int max_age;
  std::vector<std::vector<int>> x;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last; 
  
 
 public:
  ~copy_fail_model() { }
  
  inline std::string model_name() const final { return "copy_fail_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  copy_fail_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "copy_fail_model_namespace::copy_fail_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 26;
      context__.validate_dims("data initialization","nind","int",
           std::vector<size_t>{});
      nind = std::numeric_limits<int>::min();
      
      
      current_statement__ = 26;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 26;
      stan::math::check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 27;
      context__.validate_dims("data initialization","n_occasions","int",
           std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      
      
      current_statement__ = 27;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 27;
      stan::math::check_greater_or_equal(function__, "n_occasions",
                                            n_occasions, 2);
      current_statement__ = 28;
      stan::math::validate_non_negative_index("y", "nind", nind);
      current_statement__ = 29;
      stan::math::validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 30;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(nind),
            static_cast<size_t>(n_occasions)});
      y = 
        std::vector<std::vector<int>>(nind, 
          std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 30;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 30;
        pos__ = 1;
        current_statement__ = 30;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 30;
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            current_statement__ = 30;
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
            current_statement__ = 30;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 30;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 31;
      context__.validate_dims("data initialization","max_age","int",
           std::vector<size_t>{});
      max_age = std::numeric_limits<int>::min();
      
      
      current_statement__ = 31;
      max_age = context__.vals_i("max_age")[(1 - 1)];
      current_statement__ = 31;
      stan::math::check_greater_or_equal(function__, "max_age", max_age, 1);
      current_statement__ = 32;
      stan::math::validate_non_negative_index("x", "nind", nind);
      current_statement__ = 33;
      stan::math::validate_non_negative_index("x", "n_occasions - 1",
                                              (n_occasions - 1));
      current_statement__ = 34;
      context__.validate_dims("data initialization","x","int",
           std::vector<size_t>{static_cast<size_t>(nind),
            static_cast<size_t>((n_occasions - 1))});
      x = 
        std::vector<std::vector<int>>(nind, 
          std::vector<int>((n_occasions - 1), 
            std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> x_flat__;
        current_statement__ = 34;
        x_flat__ = context__.vals_i("x");
        current_statement__ = 34;
        pos__ = 1;
        current_statement__ = 34;
        for (int sym1__ = 1; sym1__ <= (n_occasions - 1); ++sym1__) {
          current_statement__ = 34;
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            current_statement__ = 34;
            stan::model::assign(x, x_flat__[(pos__ - 1)],
              "assigning variable x", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
            current_statement__ = 34;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 34;
      stan::math::check_greater_or_equal(function__, "x", x, 0);
      current_statement__ = 34;
      stan::math::check_less_or_equal(function__, "x", x, max_age);
      current_statement__ = 35;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      
      
      current_statement__ = 35;
      n_occ_minus_1 = (n_occasions - 1);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("first", "nind", nind);
      current_statement__ = 37;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      
      current_statement__ = 38;
      stan::math::validate_non_negative_index("last", "nind", nind);
      current_statement__ = 39;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      
      current_statement__ = 41;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 40;
        stan::model::assign(first,
          first_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(i)), pstream__),
          "assigning variable first", stan::model::index_uni(i));
      }
      current_statement__ = 43;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 42;
        stan::model::assign(last,
          last_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(i)), pstream__),
          "assigning variable last", stan::model::index_uni(i));
      }
      current_statement__ = 37;
      stan::math::check_greater_or_equal(function__, "first", first, 0);
      current_statement__ = 37;
      stan::math::check_less_or_equal(function__, "first", first, n_occasions);
      current_statement__ = 39;
      stan::math::check_greater_or_equal(function__, "last", last, 0);
      current_statement__ = 39;
      stan::math::check_less_or_equal(function__, "last", last, n_occasions);
      current_statement__ = 44;
      stan::math::validate_non_negative_index("beta", "max_age", max_age);
      current_statement__ = 45;
      stan::math::validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 46;
      stan::math::validate_non_negative_index("phi", "n_occ_minus_1",
                                              n_occ_minus_1);
      current_statement__ = 47;
      stan::math::validate_non_negative_index("p", "nind", nind);
      current_statement__ = 48;
      stan::math::validate_non_negative_index("p", "n_occ_minus_1",
                                              n_occ_minus_1);
      current_statement__ = 49;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("chi", "n_occasions",
                                              n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + max_age;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "copy_fail_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ mean_p = DUMMY_VAR__;
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, 
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(max_age,
           DUMMY_VAR__);
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(0, 1,
               lp__, max_age);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind,
           n_occ_minus_1, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind,
           n_occ_minus_1, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind, n_occasions,
           DUMMY_VAR__);
      current_statement__ = 15;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 9;
        for (int t = 1;
             t <= (stan::model::rvalue(first, "first",
                     stan::model::index_uni(i)) - 1);
             ++t) {
          current_statement__ = 6;
          stan::model::assign(phi, 0,
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 7;
          stan::model::assign(p, 0,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
        current_statement__ = 13;
        for (int t = stan::model::rvalue(first, "first",
                       stan::model::index_uni(i));
             t <= n_occ_minus_1; ++t) {
          current_statement__ = 10;
          stan::model::assign(phi,
            stan::model::rvalue(beta, "beta",
              stan::model::index_uni(stan::model::rvalue(x, "x",
                                       stan::model::index_uni(i),
                                         stan::model::index_uni(t)))),
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 11;
          stan::model::assign(p, mean_p,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
      }
      current_statement__ = 16;
      stan::model::assign(chi,
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi", chi, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi", chi, 1);
      {
        current_statement__ = 25;
        for (int i = 1; i <= nind; ++i) {
          current_statement__ = 23;
          if (stan::math::logical_gt(
                stan::model::rvalue(first, "first",
                  stan::model::index_uni(i)), 0)) {
            current_statement__ = 20;
            for (int t = (stan::model::rvalue(first, "first",
                            stan::model::index_uni(i)) + 1);
                 t <= stan::model::rvalue(last, "last",
                        stan::model::index_uni(i));
                 ++t) {
              current_statement__ = 17;
              lp_accum__.add(
                stan::math::bernoulli_lpmf<propto__>(1,
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(i),
                      stan::model::index_uni((t - 1)))));
              current_statement__ = 18;
              lp_accum__.add(
                stan::math::bernoulli_lpmf<propto__>(
                  stan::model::rvalue(y, "y",
                    stan::model::index_uni(i), stan::model::index_uni(t)),
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(i),
                      stan::model::index_uni((t - 1)))));
            }
            current_statement__ = 21;
            lp_accum__.add(
              stan::math::bernoulli_lpmf<propto__>(1,
                stan::model::rvalue(chi, "chi",
                  stan::model::index_uni(i),
                    stan::model::index_uni(stan::model::rvalue(last, "last",
                                             stan::model::index_uni(i))))));
          } 
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "copy_fail_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double mean_p = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, 
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<double, -1, 1> beta =
         Eigen::Matrix<double, -1, 1>::Constant(max_age,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(0, 1,
               lp__, max_age);
      Eigen::Matrix<double, -1, -1> phi =
         Eigen::Matrix<double, -1, -1>::Constant(nind, n_occ_minus_1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> p =
         Eigen::Matrix<double, -1, -1>::Constant(nind, n_occ_minus_1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> chi =
         Eigen::Matrix<double, -1, -1>::Constant(nind, n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(mean_p);
      out__.write(beta);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 15;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 9;
        for (int t = 1;
             t <= (stan::model::rvalue(first, "first",
                     stan::model::index_uni(i)) - 1);
             ++t) {
          current_statement__ = 6;
          stan::model::assign(phi, 0,
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 7;
          stan::model::assign(p, 0,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
        current_statement__ = 13;
        for (int t = stan::model::rvalue(first, "first",
                       stan::model::index_uni(i));
             t <= n_occ_minus_1; ++t) {
          current_statement__ = 10;
          stan::model::assign(phi,
            stan::model::rvalue(beta, "beta",
              stan::model::index_uni(stan::model::rvalue(x, "x",
                                       stan::model::index_uni(i),
                                         stan::model::index_uni(t)))),
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 11;
          stan::model::assign(p, mean_p,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
      }
      current_statement__ = 16;
      stan::model::assign(chi,
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi", chi, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi", chi, 1);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(chi);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ mean_p = DUMMY_VAR__;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(max_age,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
        stan::model::assign(beta, in__.read<local_scalar_t__>(),
          "assigning variable beta", stan::model::index_uni(sym1__));
      }
      out__.write_free_lub(0, 1, beta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mean_p", "beta", "phi", "p", "chi"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(max_age)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occasions)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(max_age) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(max_age) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + max_age);
      const size_t num_transformed = (((nind *
                                                          n_occ_minus_1) +
                                                         (nind *
                                                           n_occ_minus_1)) +
                                                        (nind * n_occasions));
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + max_age);
      const size_t num_transformed = (((nind *
                                                          n_occ_minus_1) +
                                                         (nind *
                                                           n_occ_minus_1)) +
                                                        (nind * n_occasions));
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"mean_p", "beta"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{1, max_age};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } using stan_model = copy_fail_model_namespace::copy_fail_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return copy_fail_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 dce-fail.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace dce_fail_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 66> locations_array__ = 
{" (found before start of program)",
 " (in 'dce-fail.stan', line 18, column 2 to column 22)",
 " (in 'dce-fail.stan', line 19, column 2 to column 26)",
 " (in 'dce-fail.stan', line 20, column 2 to column 26)",
 " (in 'dce-fail.stan', line 21, column 2 to column 28)",
 " (in 'dce-fail.stan', line 22, column 2 to column 29)",
 " (in 'dce-fail.stan', line 23, column 2 to column 30)",
 " (in 'dce-fail.stan', line 25, column 2 to column 11)",
 " (in 'dce-fail.stan', line 26, column 2 to column 16)",
 " (in 'dce-fail.stan', line 27, column 2 to column 15)",
 " (in 'dce-fail.stan', line 28, column 2 to column 22)",
 " (in 'dce-fail.stan', line 30, column 2 to column 16)",
 " (in 'dce-fail.stan', line 32, column 2 to column 22)",
 " (in 'dce-fail.stan', line 33, column 2 to column 22)",
 " (in 'dce-fail.stan', line 34, column 2 to column 28)",
 " (in 'dce-fail.stan', line 35, column 2 to column 32)",
 " (in 'dce-fail.stan', line 37, column 2 to column 24)",
 " (in 'dce-fail.stan', line 40, column 9 to column 10)",
 " (in 'dce-fail.stan', line 40, column 2 to column 14)",
 " (in 'dce-fail.stan', line 41, column 9 to column 16)",
 " (in 'dce-fail.stan', line 41, column 2 to column 30)",
 " (in 'dce-fail.stan', line 43, column 2 to column 23)",
 " (in 'dce-fail.stan', line 44, column 2 to column 28)",
 " (in 'dce-fail.stan', line 45, column 2 to column 27)",
 " (in 'dce-fail.stan', line 46, column 2 to column 34)",
 " (in 'dce-fail.stan', line 48, column 2 to column 31)",
 " (in 'dce-fail.stan', line 49, column 2 to column 31)",
 " (in 'dce-fail.stan', line 50, column 2 to column 37)",
 " (in 'dce-fail.stan', line 54, column 6 to column 48)",
 " (in 'dce-fail.stan', line 53, column 4 to line 54, column 48)",
 " (in 'dce-fail.stan', line 52, column 21 to line 55, column 3)",
 " (in 'dce-fail.stan', line 52, column 2 to line 55, column 3)",
 " (in 'dce-fail.stan', line 57, column 2 to column 28)",
 " (in 'dce-fail.stan', line 60, column 4 to column 64)",
 " (in 'dce-fail.stan', line 59, column 2 to line 60, column 64)",
 " (in 'dce-fail.stan', line 62, column 2 to column 43)",
 " (in 'dce-fail.stan', line 65, column 4 to line 68, column 25)",
 " (in 'dce-fail.stan', line 64, column 2 to line 68, column 25)",
 " (in 'dce-fail.stan', line 70, column 2 to column 19)",
 " (in 'dce-fail.stan', line 2, column 2 to column 17)",
 " (in 'dce-fail.stan', line 3, column 2 to column 21)",
 " (in 'dce-fail.stan', line 4, column 2 to column 21)",
 " (in 'dce-fail.stan', line 5, column 2 to column 24)",
 " (in 'dce-fail.stan', line 6, column 2 to column 23)",
 " (in 'dce-fail.stan', line 8, column 8 to column 9)",
 " (in 'dce-fail.stan', line 8, column 2 to column 40)",
 " (in 'dce-fail.stan', line 9, column 8 to column 9)",
 " (in 'dce-fail.stan', line 9, column 2 to column 39)",
 " (in 'dce-fail.stan', line 10, column 8 to column 9)",
 " (in 'dce-fail.stan', line 10, column 2 to column 41)",
 " (in 'dce-fail.stan', line 11, column 8 to column 9)",
 " (in 'dce-fail.stan', line 11, column 2 to column 41)",
 " (in 'dce-fail.stan', line 12, column 8 to column 15)",
 " (in 'dce-fail.stan', line 12, column 2 to column 52)",
 " (in 'dce-fail.stan', line 13, column 8 to column 9)",
 " (in 'dce-fail.stan', line 13, column 2 to column 45)",
 " (in 'dce-fail.stan', line 14, column 8 to column 9)",
 " (in 'dce-fail.stan', line 14, column 2 to column 35)",
 " (in 'dce-fail.stan', line 15, column 9 to column 16)",
 " (in 'dce-fail.stan', line 15, column 2 to column 25)",
 " (in 'dce-fail.stan', line 32, column 9 to column 14)",
 " (in 'dce-fail.stan', line 33, column 9 to column 14)",
 " (in 'dce-fail.stan', line 34, column 9 to column 17)",
 " (in 'dce-fail.stan', line 35, column 9 to column 14)",
 " (in 'dce-fail.stan', line 35, column 15 to column 20)",
 " (in 'dce-fail.stan', line 37, column 9 to column 16)"};




class dce_fail_model final : public model_base_crtp<dce_fail_model> {

 private:
  int N;
  int n_age;
  int n_edu;
  int n_region;
  int n_state;
  std::vector<int> female;
  std::vector<int> black;
  std::vector<int> age;
  std::vector<int> edu;
  std::vector<int> region;
  std::vector<int> state;
  std::vector<int> y;
  Eigen::Matrix<double, -1, 1> v_prev__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> v_prev{nullptr, 0};
 
 public:
  ~dce_fail_model() { }
  
  inline std::string model_name() const final { return "dce_fail_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  dce_fail_model(stan::io::var_context& context__,
                 unsigned int random_seed__ = 0,
                 std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "dce_fail_model_namespace::dce_fail_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 39;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      
      current_statement__ = 39;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 39;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 40;
      context__.validate_dims("data initialization","n_age","int",
           std::vector<size_t>{});
      n_age = std::numeric_limits<int>::min();
      
      
      current_statement__ = 40;
      n_age = context__.vals_i("n_age")[(1 - 1)];
      current_statement__ = 40;
      stan::math::check_greater_or_equal(function__, "n_age", n_age, 0);
      current_statement__ = 41;
      context__.validate_dims("data initialization","n_edu","int",
           std::vector<size_t>{});
      n_edu = std::numeric_limits<int>::min();
      
      
      current_statement__ = 41;
      n_edu = context__.vals_i("n_edu")[(1 - 1)];
      current_statement__ = 41;
      stan::math::check_greater_or_equal(function__, "n_edu", n_edu, 0);
      current_statement__ = 42;
      context__.validate_dims("data initialization","n_region","int",
           std::vector<size_t>{});
      n_region = std::numeric_limits<int>::min();
      
      
      current_statement__ = 42;
      n_region = context__.vals_i("n_region")[(1 - 1)];
      current_statement__ = 42;
      stan::math::check_greater_or_equal(function__, "n_region", n_region, 0);
      current_statement__ = 43;
      context__.validate_dims("data initialization","n_state","int",
           std::vector<size_t>{});
      n_state = std::numeric_limits<int>::min();
      
      
      current_statement__ = 43;
      n_state = context__.vals_i("n_state")[(1 - 1)];
      current_statement__ = 43;
      stan::math::check_greater_or_equal(function__, "n_state", n_state, 0);
      current_statement__ = 44;
      stan::math::validate_non_negative_index("female", "N", N);
      current_statement__ = 45;
      context__.validate_dims("data initialization","female","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      female = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 45;
      female = context__.vals_i("female");
      current_statement__ = 45;
      stan::math::check_greater_or_equal(function__, "female", female, 0);
      current_statement__ = 45;
      stan::math::check_less_or_equal(function__, "female", female, 1);
      current_statement__ = 46;
      stan::math::validate_non_negative_index("black", "N", N);
      current_statement__ = 47;
      context__.validate_dims("data initialization","black","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      black = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 47;
      black = context__.vals_i("black");
      current_statement__ = 47;
      stan::math::check_greater_or_equal(function__, "black", black, 0);
      current_statement__ = 47;
      stan::math::check_less_or_equal(function__, "black", black, 1);
      current_statement__ = 48;
      stan::math::validate_non_negative_index("age", "N", N);
      current_statement__ = 49;
      context__.validate_dims("data initialization","age","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      age = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 49;
      age = context__.vals_i("age");
      current_statement__ = 49;
      stan::math::check_greater_or_equal(function__, "age", age, 0);
      current_statement__ = 49;
      stan::math::check_less_or_equal(function__, "age", age, n_age);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("edu", "N", N);
      current_statement__ = 51;
      context__.validate_dims("data initialization","edu","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      edu = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 51;
      edu = context__.vals_i("edu");
      current_statement__ = 51;
      stan::math::check_greater_or_equal(function__, "edu", edu, 0);
      current_statement__ = 51;
      stan::math::check_less_or_equal(function__, "edu", edu, n_edu);
      current_statement__ = 52;
      stan::math::validate_non_negative_index("region", "n_state", n_state);
      current_statement__ = 53;
      context__.validate_dims("data initialization","region","int",
           std::vector<size_t>{static_cast<size_t>(n_state)});
      region = std::vector<int>(n_state, std::numeric_limits<int>::min());
      
      
      current_statement__ = 53;
      region = context__.vals_i("region");
      current_statement__ = 53;
      stan::math::check_greater_or_equal(function__, "region", region, 0);
      current_statement__ = 53;
      stan::math::check_less_or_equal(function__, "region", region, n_state);
      current_statement__ = 54;
      stan::math::validate_non_negative_index("state", "N", N);
      current_statement__ = 55;
      context__.validate_dims("data initialization","state","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      state = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 55;
      state = context__.vals_i("state");
      current_statement__ = 55;
      stan::math::check_greater_or_equal(function__, "state", state, 0);
      current_statement__ = 55;
      stan::math::check_less_or_equal(function__, "state", state, n_state);
      current_statement__ = 56;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 57;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 57;
      y = context__.vals_i("y");
      current_statement__ = 57;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 57;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 58;
      stan::math::validate_non_negative_index("v_prev", "n_state", n_state);
      current_statement__ = 59;
      context__.validate_dims("data initialization","v_prev","double",
           std::vector<size_t>{static_cast<size_t>(n_state)});
      v_prev__ = 
        Eigen::Matrix<double, -1, 1>::Constant(n_state,
          std::numeric_limits<double>::quiet_NaN());
      new (&v_prev) Eigen::Map<Eigen::Matrix<double, -1, 1>>(v_prev__.data(), n_state);
        
      
      {
        std::vector<local_scalar_t__> v_prev_flat__;
        current_statement__ = 59;
        v_prev_flat__ = context__.vals_r("v_prev");
        current_statement__ = 59;
        pos__ = 1;
        current_statement__ = 59;
        for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
          current_statement__ = 59;
          stan::model::assign(v_prev, v_prev_flat__[(pos__ - 1)],
            "assigning variable v_prev", stan::model::index_uni(sym1__));
          current_statement__ = 59;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 60;
      stan::math::validate_non_negative_index("b_age", "n_age", n_age);
      current_statement__ = 61;
      stan::math::validate_non_negative_index("b_edu", "n_edu", n_edu);
      current_statement__ = 62;
      stan::math::validate_non_negative_index("b_region", "n_region",
                                              n_region);
      current_statement__ = 63;
      stan::math::validate_non_negative_index("b_age_edu", "n_age", n_age);
      current_statement__ = 64;
      stan::math::validate_non_negative_index("b_age_edu", "n_edu", n_edu);
      current_statement__ = 65;
      stan::math::validate_non_negative_index("b_hat", "n_state", n_state);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + n_age
       + n_edu + n_region + (n_age * n_edu) + n_state;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "dce_fail_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 1;
      sigma = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                0, lp__);
      local_scalar_t__ sigma_age = DUMMY_VAR__;
      current_statement__ = 2;
      sigma_age = in__.template read_constrain_lb<local_scalar_t__, 
                    jacobian__>(0, lp__);
      local_scalar_t__ sigma_edu = DUMMY_VAR__;
      current_statement__ = 3;
      sigma_edu = in__.template read_constrain_lb<local_scalar_t__, 
                    jacobian__>(0, lp__);
      local_scalar_t__ sigma_state = DUMMY_VAR__;
      current_statement__ = 4;
      sigma_state = in__.template read_constrain_lb<local_scalar_t__, 
                      jacobian__>(0, lp__);
      local_scalar_t__ sigma_region = DUMMY_VAR__;
      current_statement__ = 5;
      sigma_region = in__.template read_constrain_lb<local_scalar_t__, 
                       jacobian__>(0, lp__);
      local_scalar_t__ sigma_age_edu = DUMMY_VAR__;
      current_statement__ = 6;
      sigma_age_edu = in__.template read_constrain_lb<local_scalar_t__, 
                        jacobian__>(0, lp__);
      local_scalar_t__ b_0 = DUMMY_VAR__;
      current_statement__ = 7;
      b_0 = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_female = DUMMY_VAR__;
      current_statement__ = 8;
      b_female = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_black = DUMMY_VAR__;
      current_statement__ = 9;
      b_black = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_female_black = DUMMY_VAR__;
      current_statement__ = 10;
      b_female_black = in__.template read<local_scalar_t__>();
      local_scalar_t__ b_v_prev = DUMMY_VAR__;
      current_statement__ = 11;
      b_v_prev = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__, -1, 1> b_age =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_age, DUMMY_VAR__);
      current_statement__ = 12;
      b_age = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                n_age);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_edu =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_edu, DUMMY_VAR__);
      current_statement__ = 13;
      b_edu = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                n_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_region =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_region,
           DUMMY_VAR__);
      current_statement__ = 14;
      b_region = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                   n_region);
      Eigen::Matrix<local_scalar_t__, -1, -1> b_age_edu =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(n_age, n_edu,
           DUMMY_VAR__);
      current_statement__ = 15;
      b_age_edu = in__.template read<
                    Eigen::Matrix<local_scalar_t__, -1, -1>>(n_age, n_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_hat =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_state,
           DUMMY_VAR__);
      current_statement__ = 16;
      b_hat = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                n_state);
      {
        current_statement__ = 17;
        stan::math::validate_non_negative_index("p", "N", N);
        Eigen::Matrix<local_scalar_t__, -1, 1> p =
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 19;
        stan::math::validate_non_negative_index("b_state_hat", "n_state",
                                                n_state);
        Eigen::Matrix<local_scalar_t__, -1, 1> b_state_hat =
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_state,
             DUMMY_VAR__);
        current_statement__ = 21;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_0, 0, 100));
        current_statement__ = 22;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_female, 0, 100));
        current_statement__ = 23;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_black, 0, 100));
        current_statement__ = 24;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(b_female_black, 0, 100));
        current_statement__ = 25;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_age, 0, sigma_age));
        current_statement__ = 26;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_edu, 0, sigma_edu));
        current_statement__ = 27;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(b_region, 0, sigma_region));
        current_statement__ = 31;
        for (int j = 1; j <= n_age; ++j) {
          current_statement__ = 29;
          for (int i = 1; i <= n_edu; ++i) {
            current_statement__ = 28;
            lp_accum__.add(
              stan::math::normal_lpdf<propto__>(
                stan::model::rvalue(b_age_edu, "b_age_edu",
                  stan::model::index_uni(j), stan::model::index_uni(i)), 0,
                sigma_age_edu));
          }
        }
        current_statement__ = 32;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b_v_prev, 0, 100));
        current_statement__ = 34;
        for (int j = 1; j <= n_state; ++j) {
          current_statement__ = 33;
          stan::model::assign(b_state_hat,
            (stan::model::rvalue(b_region, "b_region",
               stan::model::index_uni(stan::model::rvalue(region, "region",
                                        stan::model::index_uni(j)))) +
              (b_v_prev *
                stan::model::rvalue(v_prev, "v_prev",
                  stan::model::index_uni(j)))),
            "assigning variable b_state_hat", stan::model::index_uni(j));
        }
        current_statement__ = 35;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(b_hat, b_state_hat, sigma_state));
        current_statement__ = 37;
        for (int i = 1; i <= N; ++i) {
          current_statement__ = 36;
          stan::model::assign(p,
            stan::math::fmax(0,
              stan::math::fmin(1,
                stan::math::inv_logit(
                  (((((((b_0 +
                          (b_female *
                            stan::model::rvalue(female, "female",
                              stan::model::index_uni(i)))) +
                         (b_black *
                           stan::model::rvalue(black, "black",
                             stan::model::index_uni(i)))) +
                        ((b_female_black *
                           stan::model::rvalue(female, "female",
                             stan::model::index_uni(i))) *
                          stan::model::rvalue(black, "black",
                            stan::model::index_uni(i)))) +
                       stan::model::rvalue(b_age, "b_age",
                         stan::model::index_uni(stan::model::rvalue(age,
                                                  "age",
                                                  stan::model::index_uni(i)))))
                      +
                      stan::model::rvalue(b_edu, "b_edu",
                        stan::model::index_uni(stan::model::rvalue(edu,
                                                 "edu",
                                                 stan::model::index_uni(i)))))
                     +
                     stan::model::rvalue(b_age_edu, "b_age_edu",
                       stan::model::index_uni(stan::model::rvalue(age, "age",
                                                stan::model::index_uni(i))),
                         stan::model::index_uni(stan::model::rvalue(edu,
                                                  "edu",
                                                  stan::model::index_uni(i)))))
                    +
                    stan::model::rvalue(b_hat, "b_hat",
                      stan::model::index_uni(stan::model::rvalue(state,
                                               "state",
                                               stan::model::index_uni(i)))))))),
            "assigning variable p", stan::model::index_uni(i));
        }
        current_statement__ = 38;
        lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(y, p));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "dce_fail_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double sigma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      sigma = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                0, lp__);
      double sigma_age = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      sigma_age = in__.template read_constrain_lb<local_scalar_t__, 
                    jacobian__>(0, lp__);
      double sigma_edu = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      sigma_edu = in__.template read_constrain_lb<local_scalar_t__, 
                    jacobian__>(0, lp__);
      double sigma_state = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      sigma_state = in__.template read_constrain_lb<local_scalar_t__, 
                      jacobian__>(0, lp__);
      double sigma_region = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      sigma_region = in__.template read_constrain_lb<local_scalar_t__, 
                       jacobian__>(0, lp__);
      double sigma_age_edu = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 6;
      sigma_age_edu = in__.template read_constrain_lb<local_scalar_t__, 
                        jacobian__>(0, lp__);
      double b_0 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 7;
      b_0 = in__.template read<local_scalar_t__>();
      double b_female = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 8;
      b_female = in__.template read<local_scalar_t__>();
      double b_black = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 9;
      b_black = in__.template read<local_scalar_t__>();
      double b_female_black = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 10;
      b_female_black = in__.template read<local_scalar_t__>();
      double b_v_prev = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 11;
      b_v_prev = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, 1> b_age =
         Eigen::Matrix<double, -1, 1>::Constant(n_age,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 12;
      b_age = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                n_age);
      Eigen::Matrix<double, -1, 1> b_edu =
         Eigen::Matrix<double, -1, 1>::Constant(n_edu,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 13;
      b_edu = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                n_edu);
      Eigen::Matrix<double, -1, 1> b_region =
         Eigen::Matrix<double, -1, 1>::Constant(n_region,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 14;
      b_region = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                   n_region);
      Eigen::Matrix<double, -1, -1> b_age_edu =
         Eigen::Matrix<double, -1, -1>::Constant(n_age, n_edu,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 15;
      b_age_edu = in__.template read<
                    Eigen::Matrix<local_scalar_t__, -1, -1>>(n_age, n_edu);
      Eigen::Matrix<double, -1, 1> b_hat =
         Eigen::Matrix<double, -1, 1>::Constant(n_state,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 16;
      b_hat = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                n_state);
      out__.write(sigma);
      out__.write(sigma_age);
      out__.write(sigma_edu);
      out__.write(sigma_state);
      out__.write(sigma_region);
      out__.write(sigma_age_edu);
      out__.write(b_0);
      out__.write(b_female);
      out__.write(b_black);
      out__.write(b_female_black);
      out__.write(b_v_prev);
      out__.write(b_age);
      out__.write(b_edu);
      out__.write(b_region);
      out__.write(b_age_edu);
      out__.write(b_hat);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ sigma = DUMMY_VAR__;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma);
      local_scalar_t__ sigma_age = DUMMY_VAR__;
      sigma_age = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_age);
      local_scalar_t__ sigma_edu = DUMMY_VAR__;
      sigma_edu = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_edu);
      local_scalar_t__ sigma_state = DUMMY_VAR__;
      sigma_state = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_state);
      local_scalar_t__ sigma_region = DUMMY_VAR__;
      sigma_region = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_region);
      local_scalar_t__ sigma_age_edu = DUMMY_VAR__;
      sigma_age_edu = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma_age_edu);
      local_scalar_t__ b_0 = DUMMY_VAR__;
      b_0 = in__.read<local_scalar_t__>();
      out__.write(b_0);
      local_scalar_t__ b_female = DUMMY_VAR__;
      b_female = in__.read<local_scalar_t__>();
      out__.write(b_female);
      local_scalar_t__ b_black = DUMMY_VAR__;
      b_black = in__.read<local_scalar_t__>();
      out__.write(b_black);
      local_scalar_t__ b_female_black = DUMMY_VAR__;
      b_female_black = in__.read<local_scalar_t__>();
      out__.write(b_female_black);
      local_scalar_t__ b_v_prev = DUMMY_VAR__;
      b_v_prev = in__.read<local_scalar_t__>();
      out__.write(b_v_prev);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_age =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_age, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
        stan::model::assign(b_age, in__.read<local_scalar_t__>(),
          "assigning variable b_age", stan::model::index_uni(sym1__));
      }
      out__.write(b_age);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_edu =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_edu, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
        stan::model::assign(b_edu, in__.read<local_scalar_t__>(),
          "assigning variable b_edu", stan::model::index_uni(sym1__));
      }
      out__.write(b_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_region =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_region,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_region; ++sym1__) {
        stan::model::assign(b_region, in__.read<local_scalar_t__>(),
          "assigning variable b_region", stan::model::index_uni(sym1__));
      }
      out__.write(b_region);
      Eigen::Matrix<local_scalar_t__, -1, -1> b_age_edu =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(n_age, n_edu,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_age; ++sym2__) {
          stan::model::assign(b_age_edu, in__.read<local_scalar_t__>(),
            "assigning variable b_age_edu", stan::model::index_uni(sym2__),
                                              stan::model::index_uni(sym1__));
        }
      }
      out__.write(b_age_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_hat =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_state,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
        stan::model::assign(b_hat, in__.read<local_scalar_t__>(),
          "assigning variable b_hat", stan::model::index_uni(sym1__));
      }
      out__.write(b_hat);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"sigma", "sigma_age", "sigma_edu",
      "sigma_state", "sigma_region", "sigma_age_edu", "b_0", "b_female",
      "b_black", "b_female_black", "b_v_prev", "b_age", "b_edu", "b_region",
      "b_age_edu", "b_hat"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(n_age)},
      std::vector<size_t>{static_cast<size_t>(n_edu)},
      std::vector<size_t>{static_cast<size_t>(n_region)},
      std::vector<size_t>{static_cast<size_t>(n_age),
                          static_cast<size_t>(n_edu)},
      std::vector<size_t>{static_cast<size_t>(n_state)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "sigma");
    param_names__.emplace_back(std::string() + "sigma_age");
    param_names__.emplace_back(std::string() + "sigma_edu");
    param_names__.emplace_back(std::string() + "sigma_state");
    param_names__.emplace_back(std::string() + "sigma_region");
    param_names__.emplace_back(std::string() + "sigma_age_edu");
    param_names__.emplace_back(std::string() + "b_0");
    param_names__.emplace_back(std::string() + "b_female");
    param_names__.emplace_back(std::string() + "b_black");
    param_names__.emplace_back(std::string() + "b_female_black");
    param_names__.emplace_back(std::string() + "b_v_prev");
    for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_age" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_edu" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_region; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_region" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= n_age; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "b_age_edu" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_hat" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "sigma");
    param_names__.emplace_back(std::string() + "sigma_age");
    param_names__.emplace_back(std::string() + "sigma_edu");
    param_names__.emplace_back(std::string() + "sigma_state");
    param_names__.emplace_back(std::string() + "sigma_region");
    param_names__.emplace_back(std::string() + "sigma_age_edu");
    param_names__.emplace_back(std::string() + "b_0");
    param_names__.emplace_back(std::string() + "b_female");
    param_names__.emplace_back(std::string() + "b_black");
    param_names__.emplace_back(std::string() + "b_female_black");
    param_names__.emplace_back(std::string() + "b_v_prev");
    for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_age" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_edu" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_region; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_region" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= n_age; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "b_age_edu" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_hat" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_state\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_region\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_v_prev\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_age\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age) + "},\"block\":\"parameters\"},{\"name\":\"b_edu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"b_region\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_region) + "},\"block\":\"parameters\"},{\"name\":\"b_age_edu\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_age) + ",\"cols\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"b_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_state) + "},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_state\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_region\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_v_prev\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_age\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age) + "},\"block\":\"parameters\"},{\"name\":\"b_edu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"b_region\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_region) + "},\"block\":\"parameters\"},{\"name\":\"b_age_edu\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_age) + ",\"cols\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"b_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_state) + "},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((((((((((((1 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + n_age)
       + n_edu) + n_region) + (n_age * n_edu)) + n_state);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((((((((((((1 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + n_age)
       + n_edu) + n_region) + (n_age * n_edu)) + n_state);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 16> names__{"sigma", "sigma_age",
      "sigma_edu", "sigma_state", "sigma_region", "sigma_age_edu", "b_0",
      "b_female", "b_black", "b_female_black", "b_v_prev", "b_age", "b_edu",
      "b_region", "b_age_edu", "b_hat"};
      const std::array<Eigen::Index, 16> constrain_param_sizes__{1, 1, 
       1, 1, 1, 1, 1, 1, 1, 1, 1, n_age, n_edu, n_region, (n_age * n_edu),
       n_state};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = dce_fail_model_namespace::dce_fail_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return dce_fail_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 expr-prop-experiment.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_experiment_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 10> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-experiment.stan', line 2, column 2 to column 8)",
 " (in 'expr-prop-experiment.stan', line 5, column 2 to column 9)",
 " (in 'expr-prop-experiment.stan', line 6, column 2 to column 9)",
 " (in 'expr-prop-experiment.stan', line 7, column 2 to column 9)",
 " (in 'expr-prop-experiment.stan', line 8, column 2 to column 28)",
 " (in 'expr-prop-experiment.stan', line 9, column 2 to column 12)",
 " (in 'expr-prop-experiment.stan', line 10, column 2 to column 23)",
 " (in 'expr-prop-experiment.stan', line 11, column 2 to column 23)",
 " (in 'expr-prop-experiment.stan', line 12, column 2 to column 23)"};




class expr_prop_experiment_model final : public model_base_crtp<expr_prop_experiment_model> {

 private:
  int j;
  double z;
  double x;
  double y;
  double i; 
  
 
 public:
  ~expr_prop_experiment_model() { }
  
  inline std::string model_name() const final { return "expr_prop_experiment_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  expr_prop_experiment_model(stan::io::var_context& context__,
                             unsigned int random_seed__ = 0,
                             std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_experiment_model_namespace::expr_prop_experiment_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 1;
      context__.validate_dims("data initialization","j","int",
           std::vector<size_t>{});
      j = std::numeric_limits<int>::min();
      
      
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      current_statement__ = 2;
      z = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 3;
      x = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 4;
      y = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 5;
      i = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 5;
      i = stan::math::normal_rng(5, 1, base_rng__);
      current_statement__ = 6;
      z = (i * j);
      current_statement__ = 7;
      x = stan::math::normal_rng(z, 1, base_rng__);
      current_statement__ = 8;
      i = stan::math::normal_rng(5, 1, base_rng__);
      current_statement__ = 9;
      y = stan::math::normal_rng(z, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_experiment_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_experiment_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 0> names__{};
      const std::array<Eigen::Index, 0> constrain_param_sizes__{};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}

using stan_model = expr_prop_experiment_model_namespace::expr_prop_experiment_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_experiment_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 expr-prop-experiment2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_experiment2_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 9> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-experiment2.stan', line 2, column 2 to column 8)",
 " (in 'expr-prop-experiment2.stan', line 5, column 2 to column 13)",
 " (in 'expr-prop-experiment2.stan', line 6, column 2 to column 9)",
 " (in 'expr-prop-experiment2.stan', line 8, column 4 to column 32)",
 " (in 'expr-prop-experiment2.stan', line 9, column 4 to column 14)",
 " (in 'expr-prop-experiment2.stan', line 10, column 4 to column 25)",
 " (in 'expr-prop-experiment2.stan', line 7, column 2 to line 11, column 3)",
 " (in 'expr-prop-experiment2.stan', line 12, column 2 to column 23)"};




class expr_prop_experiment2_model final : public model_base_crtp<expr_prop_experiment2_model> {

 private:
  int j;
  double z;
  double y; 
  
 
 public:
  ~expr_prop_experiment2_model() { }
  
  inline std::string model_name() const final { return "expr_prop_experiment2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  expr_prop_experiment2_model(stan::io::var_context& context__,
                              unsigned int random_seed__ = 0,
                              std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_experiment2_model_namespace::expr_prop_experiment2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 1;
      context__.validate_dims("data initialization","j","int",
           std::vector<size_t>{});
      j = std::numeric_limits<int>::min();
      
      
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      current_statement__ = 2;
      z = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 2;
      z = 1;
      current_statement__ = 3;
      y = std::numeric_limits<double>::quiet_NaN();
      
      
      {
        double x = std::numeric_limits<double>::quiet_NaN();
        current_statement__ = 4;
        x = stan::math::normal_rng(123, 1, base_rng__);
        current_statement__ = 5;
        z = (x * 2);
        current_statement__ = 6;
        y = stan::math::normal_rng(z, 1, base_rng__);
      }
      current_statement__ = 8;
      y = stan::math::normal_rng(z, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_experiment2_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_experiment2_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 0> names__{};
      const std::array<Eigen::Index, 0> constrain_param_sizes__{};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}

using stan_model = expr_prop_experiment2_model_namespace::expr_prop_experiment2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_experiment2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 expr-prop-fail.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 12> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail.stan', line 6, column 2 to column 16)",
 " (in 'expr-prop-fail.stan', line 7, column 2 to column 31)",
 " (in 'expr-prop-fail.stan', line 8, column 2 to column 31)",
 " (in 'expr-prop-fail.stan', line 11, column 2 to column 23)",
 " (in 'expr-prop-fail.stan', line 12, column 2 to column 20)",
 " (in 'expr-prop-fail.stan', line 13, column 2 to column 21)",
 " (in 'expr-prop-fail.stan', line 15, column 4 to line 16, column 59)",
 " (in 'expr-prop-fail.stan', line 14, column 2 to line 16, column 59)",
 " (in 'expr-prop-fail.stan', line 2, column 2 to column 17)",
 " (in 'expr-prop-fail.stan', line 3, column 9 to column 10)",
 " (in 'expr-prop-fail.stan', line 3, column 2 to column 14)"};




class expr_prop_fail_model final : public model_base_crtp<expr_prop_fail_model> {

 private:
  int N;
  Eigen::Matrix<double, -1, 1> y__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> y{nullptr, 0};
 
 public:
  ~expr_prop_fail_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  expr_prop_fail_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail_model_namespace::expr_prop_fail_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 9;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      
      current_statement__ = 9;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 9;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 10;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 11;
      context__.validate_dims("data initialization","y","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      y__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&y) Eigen::Map<Eigen::Matrix<double, -1, 1>>(y__.data(), N);
      
      {
        std::vector<local_scalar_t__> y_flat__;
        current_statement__ = 11;
        y_flat__ = context__.vals_r("y");
        current_statement__ = 11;
        pos__ = 1;
        current_statement__ = 11;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 11;
          stan::model::assign(y, y_flat__[(pos__ - 1)],
            "assigning variable y", stan::model::index_uni(sym1__));
          current_statement__ = 11;
          pos__ = (pos__ + 1);
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 2 + 2 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> mu =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 1;
      mu = in__.template read_constrain_ordered<
             Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(lp__, 2);
      std::vector<local_scalar_t__> sigma =
         std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<std::vector<local_scalar_t__>, 
                jacobian__>(0, lp__, 2);
      local_scalar_t__ theta = DUMMY_VAR__;
      current_statement__ = 3;
      theta = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 1, lp__);
      {
        current_statement__ = 4;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(sigma, 0, 2));
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu, 0, 2));
        current_statement__ = 6;
        lp_accum__.add(stan::math::beta_lpdf<propto__>(theta, 5, 5));
        current_statement__ = 8;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 7;
          lp_accum__.add(
            stan::math::log_mix(theta,
              stan::math::normal_lpdf<false>(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)),
                stan::model::rvalue(mu, "mu", stan::model::index_uni(1)),
                stan::model::rvalue(sigma, "sigma",
                  stan::model::index_uni(1))),
              stan::math::normal_lpdf<false>(
                stan::model::rvalue(y, "y", stan::model::index_uni(n)),
                stan::model::rvalue(mu, "mu", stan::model::index_uni(2)),
                stan::model::rvalue(sigma, "sigma",
                  stan::model::index_uni(2)))));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, 1> mu =
         Eigen::Matrix<double, -1, 1>::Constant(2,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      mu = in__.template read_constrain_ordered<
             Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(lp__, 2);
      std::vector<double> sigma =
         std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      sigma = in__.template read_constrain_lb<std::vector<local_scalar_t__>, 
                jacobian__>(0, lp__, 2);
      double theta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      theta = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 1, lp__);
      out__.write(mu);
      out__.write(sigma);
      out__.write(theta);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, 1> mu =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(2, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        stan::model::assign(mu, in__.read<local_scalar_t__>(),
          "assigning variable mu", stan::model::index_uni(sym1__));
      }
      out__.write_free_ordered(mu);
      std::vector<local_scalar_t__> sigma =
         std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        sigma[(sym1__ - 1)] = in__.read<local_scalar_t__>();
      }
      out__.write_free_lb(0, sigma);
      local_scalar_t__ theta = DUMMY_VAR__;
      theta = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mu", "sigma", "theta"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(2)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(2)}, std::vector<size_t>{
      }};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "mu" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "theta");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "mu" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "theta");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((2 + 2) + 1);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((2 + 2) + 1);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 3> names__{"mu", "sigma", "theta"};
      const std::array<Eigen::Index, 3> constrain_param_sizes__{2, 2, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail_model_namespace::expr_prop_fail_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 expr-prop-fail2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail2_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 12> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail2.stan', line 7, column 2 to column 10)",
 " (in 'expr-prop-fail2.stan', line 8, column 2 to column 22)",
 " (in 'expr-prop-fail2.stan', line 9, column 2 to column 20)",
 " (in 'expr-prop-fail2.stan', line 12, column 2 to column 26)",
 " (in 'expr-prop-fail2.stan', line 13, column 2 to column 27)",
 " (in 'expr-prop-fail2.stan', line 2, column 2 to column 17)",
 " (in 'expr-prop-fail2.stan', line 3, column 8 to column 9)",
 " (in 'expr-prop-fail2.stan', line 3, column 2 to column 18)",
 " (in 'expr-prop-fail2.stan', line 4, column 8 to column 9)",
 " (in 'expr-prop-fail2.stan', line 4, column 2 to column 31)",
 " (in 'expr-prop-fail2.stan', line 8, column 8 to column 9)"};




class expr_prop_fail2_model final : public model_base_crtp<expr_prop_fail2_model> {

 private:
  int J;
  std::vector<double> y;
  std::vector<double> sigma; 
  
 
 public:
  ~expr_prop_fail2_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  expr_prop_fail2_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail2_model_namespace::expr_prop_fail2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 6;
      context__.validate_dims("data initialization","J","int",
           std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      
      
      current_statement__ = 6;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 6;
      stan::math::check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 7;
      stan::math::validate_non_negative_index("y", "J", J);
      current_statement__ = 8;
      context__.validate_dims("data initialization","y","double",
           std::vector<size_t>{static_cast<size_t>(J)});
      y = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 8;
      y = context__.vals_r("y");
      current_statement__ = 9;
      stan::math::validate_non_negative_index("sigma", "J", J);
      current_statement__ = 10;
      context__.validate_dims("data initialization","sigma","double",
           std::vector<size_t>{static_cast<size_t>(J)});
      sigma = 
        std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 10;
      sigma = context__.vals_r("sigma");
      current_statement__ = 10;
      stan::math::check_greater_or_equal(function__, "sigma", sigma, 0);
      current_statement__ = 11;
      stan::math::validate_non_negative_index("theta", "J", J);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + J + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail2_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      std::vector<local_scalar_t__> theta =
         std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      current_statement__ = 2;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      local_scalar_t__ tau = DUMMY_VAR__;
      current_statement__ = 3;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      {
        current_statement__ = 4;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(theta, mu, tau));
        current_statement__ = 5;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, theta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail2_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double mu = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      std::vector<double> theta =
         std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      double tau = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      out__.write(mu);
      out__.write(theta);
      out__.write(tau);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ mu = DUMMY_VAR__;
      mu = in__.read<local_scalar_t__>();
      out__.write(mu);
      std::vector<local_scalar_t__> theta =
         std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        theta[(sym1__ - 1)] = in__.read<local_scalar_t__>();
      }
      out__.write(theta);
      local_scalar_t__ tau = DUMMY_VAR__;
      tau = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mu", "theta", "tau"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(J)}, std::vector<size_t>{
      }};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "tau");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "tau");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((1 + J) + 1);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((1 + J) + 1);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 3> names__{"mu", "theta", "tau"};
      const std::array<Eigen::Index, 3> constrain_param_sizes__{1, J, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail2_model_namespace::expr_prop_fail2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 expr-prop-fail3.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail3_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 52> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail3.stan', line 19, column 2 to column 18)",
 " (in 'expr-prop-fail3.stan', line 20, column 2 to column 18)",
 " (in 'expr-prop-fail3.stan', line 21, column 2 to column 22)",
 " (in 'expr-prop-fail3.stan', line 22, column 2 to column 20)",
 " (in 'expr-prop-fail3.stan', line 23, column 2 to column 26)",
 " (in 'expr-prop-fail3.stan', line 24, column 2 to column 17)",
 " (in 'expr-prop-fail3.stan', line 25, column 2 to column 35)",
 " (in 'expr-prop-fail3.stan', line 26, column 2 to column 35)",
 " (in 'expr-prop-fail3.stan', line 27, column 2 to column 35)",
 " (in 'expr-prop-fail3.stan', line 28, column 2 to column 35)",
 " (in 'expr-prop-fail3.stan', line 29, column 2 to column 35)",
 " (in 'expr-prop-fail3.stan', line 32, column 2 to column 18)",
 " (in 'expr-prop-fail3.stan', line 35, column 4 to line 38, column 35)",
 " (in 'expr-prop-fail3.stan', line 34, column 2 to line 38, column 35)",
 " (in 'expr-prop-fail3.stan', line 41, column 2 to column 25)",
 " (in 'expr-prop-fail3.stan', line 42, column 2 to column 25)",
 " (in 'expr-prop-fail3.stan', line 43, column 2 to column 25)",
 " (in 'expr-prop-fail3.stan', line 44, column 2 to column 25)",
 " (in 'expr-prop-fail3.stan', line 45, column 2 to column 25)",
 " (in 'expr-prop-fail3.stan', line 46, column 2 to column 24)",
 " (in 'expr-prop-fail3.stan', line 47, column 2 to column 29)",
 " (in 'expr-prop-fail3.stan', line 2, column 2 to column 17)",
 " (in 'expr-prop-fail3.stan', line 3, column 2 to column 21)",
 " (in 'expr-prop-fail3.stan', line 4, column 2 to column 25)",
 " (in 'expr-prop-fail3.stan', line 5, column 2 to column 21)",
 " (in 'expr-prop-fail3.stan', line 6, column 2 to column 29)",
 " (in 'expr-prop-fail3.stan', line 7, column 2 to column 23)",
 " (in 'expr-prop-fail3.stan', line 8, column 8 to column 9)",
 " (in 'expr-prop-fail3.stan', line 8, column 2 to column 41)",
 " (in 'expr-prop-fail3.stan', line 9, column 8 to column 9)",
 " (in 'expr-prop-fail3.stan', line 9, column 2 to column 49)",
 " (in 'expr-prop-fail3.stan', line 10, column 27 to column 28)",
 " (in 'expr-prop-fail3.stan', line 10, column 2 to column 36)",
 " (in 'expr-prop-fail3.stan', line 11, column 8 to column 9)",
 " (in 'expr-prop-fail3.stan', line 11, column 2 to column 41)",
 " (in 'expr-prop-fail3.stan', line 12, column 27 to column 28)",
 " (in 'expr-prop-fail3.stan', line 12, column 2 to column 37)",
 " (in 'expr-prop-fail3.stan', line 13, column 8 to column 9)",
 " (in 'expr-prop-fail3.stan', line 13, column 2 to column 57)",
 " (in 'expr-prop-fail3.stan', line 14, column 8 to column 9)",
 " (in 'expr-prop-fail3.stan', line 14, column 2 to column 45)",
 " (in 'expr-prop-fail3.stan', line 15, column 9 to column 10)",
 " (in 'expr-prop-fail3.stan', line 15, column 2 to column 24)",
 " (in 'expr-prop-fail3.stan', line 16, column 8 to column 9)",
 " (in 'expr-prop-fail3.stan', line 16, column 2 to column 35)",
 " (in 'expr-prop-fail3.stan', line 19, column 9 to column 14)",
 " (in 'expr-prop-fail3.stan', line 20, column 9 to column 14)",
 " (in 'expr-prop-fail3.stan', line 21, column 9 to column 18)",
 " (in 'expr-prop-fail3.stan', line 22, column 9 to column 16)",
 " (in 'expr-prop-fail3.stan', line 23, column 9 to column 22)",
 " (in 'expr-prop-fail3.stan', line 32, column 9 to column 10)"};




class expr_prop_fail3_model final : public model_base_crtp<expr_prop_fail3_model> {

 private:
  int N;
  int n_age;
  int n_age_edu;
  int n_edu;
  int n_region_full;
  int n_state;
  std::vector<int> age;
  std::vector<int> age_edu;
  Eigen::Matrix<double, -1, 1> black__;
  std::vector<int> edu;
  Eigen::Matrix<double, -1, 1> female__;
  std::vector<int> region_full;
  std::vector<int> state;
  Eigen::Matrix<double, -1, 1> v_prev_full__;
  std::vector<int> y; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> black{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> female{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> v_prev_full{nullptr, 0};
 
 public:
  ~expr_prop_fail3_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail3_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  expr_prop_fail3_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail3_model_namespace::expr_prop_fail3_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 22;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      
      current_statement__ = 22;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 22;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 23;
      context__.validate_dims("data initialization","n_age","int",
           std::vector<size_t>{});
      n_age = std::numeric_limits<int>::min();
      
      
      current_statement__ = 23;
      n_age = context__.vals_i("n_age")[(1 - 1)];
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "n_age", n_age, 0);
      current_statement__ = 24;
      context__.validate_dims("data initialization","n_age_edu","int",
           std::vector<size_t>{});
      n_age_edu = std::numeric_limits<int>::min();
      
      
      current_statement__ = 24;
      n_age_edu = context__.vals_i("n_age_edu")[(1 - 1)];
      current_statement__ = 24;
      stan::math::check_greater_or_equal(function__, "n_age_edu", n_age_edu,
                                            0);
      current_statement__ = 25;
      context__.validate_dims("data initialization","n_edu","int",
           std::vector<size_t>{});
      n_edu = std::numeric_limits<int>::min();
      
      
      current_statement__ = 25;
      n_edu = context__.vals_i("n_edu")[(1 - 1)];
      current_statement__ = 25;
      stan::math::check_greater_or_equal(function__, "n_edu", n_edu, 0);
      current_statement__ = 26;
      context__.validate_dims("data initialization","n_region_full","int",
           std::vector<size_t>{});
      n_region_full = std::numeric_limits<int>::min();
      
      
      current_statement__ = 26;
      n_region_full = context__.vals_i("n_region_full")[(1 - 1)];
      current_statement__ = 26;
      stan::math::check_greater_or_equal(function__, "n_region_full",
                                            n_region_full, 0);
      current_statement__ = 27;
      context__.validate_dims("data initialization","n_state","int",
           std::vector<size_t>{});
      n_state = std::numeric_limits<int>::min();
      
      
      current_statement__ = 27;
      n_state = context__.vals_i("n_state")[(1 - 1)];
      current_statement__ = 27;
      stan::math::check_greater_or_equal(function__, "n_state", n_state, 0);
      current_statement__ = 28;
      stan::math::validate_non_negative_index("age", "N", N);
      current_statement__ = 29;
      context__.validate_dims("data initialization","age","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      age = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 29;
      age = context__.vals_i("age");
      current_statement__ = 29;
      stan::math::check_greater_or_equal(function__, "age", age, 0);
      current_statement__ = 29;
      stan::math::check_less_or_equal(function__, "age", age, n_age);
      current_statement__ = 30;
      stan::math::validate_non_negative_index("age_edu", "N", N);
      current_statement__ = 31;
      context__.validate_dims("data initialization","age_edu","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      age_edu = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 31;
      age_edu = context__.vals_i("age_edu");
      current_statement__ = 31;
      stan::math::check_greater_or_equal(function__, "age_edu", age_edu, 0);
      current_statement__ = 31;
      stan::math::check_less_or_equal(function__, "age_edu", age_edu,
                                         n_age_edu);
      current_statement__ = 32;
      stan::math::validate_non_negative_index("black", "N", N);
      current_statement__ = 33;
      context__.validate_dims("data initialization","black","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      black__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&black) Eigen::Map<Eigen::Matrix<double, -1, 1>>(black__.data(), N);
        
      
      {
        std::vector<local_scalar_t__> black_flat__;
        current_statement__ = 33;
        black_flat__ = context__.vals_r("black");
        current_statement__ = 33;
        pos__ = 1;
        current_statement__ = 33;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 33;
          stan::model::assign(black, black_flat__[(pos__ - 1)],
            "assigning variable black", stan::model::index_uni(sym1__));
          current_statement__ = 33;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 33;
      stan::math::check_greater_or_equal(function__, "black", black, 0);
      current_statement__ = 33;
      stan::math::check_less_or_equal(function__, "black", black, 1);
      current_statement__ = 34;
      stan::math::validate_non_negative_index("edu", "N", N);
      current_statement__ = 35;
      context__.validate_dims("data initialization","edu","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      edu = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 35;
      edu = context__.vals_i("edu");
      current_statement__ = 35;
      stan::math::check_greater_or_equal(function__, "edu", edu, 0);
      current_statement__ = 35;
      stan::math::check_less_or_equal(function__, "edu", edu, n_edu);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("female", "N", N);
      current_statement__ = 37;
      context__.validate_dims("data initialization","female","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      female__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&female) Eigen::Map<Eigen::Matrix<double, -1, 1>>(female__.data(), N);
        
      
      {
        std::vector<local_scalar_t__> female_flat__;
        current_statement__ = 37;
        female_flat__ = context__.vals_r("female");
        current_statement__ = 37;
        pos__ = 1;
        current_statement__ = 37;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 37;
          stan::model::assign(female, female_flat__[(pos__ - 1)],
            "assigning variable female", stan::model::index_uni(sym1__));
          current_statement__ = 37;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 37;
      stan::math::check_greater_or_equal(function__, "female", female, 0);
      current_statement__ = 37;
      stan::math::check_less_or_equal(function__, "female", female, 1);
      current_statement__ = 38;
      stan::math::validate_non_negative_index("region_full", "N", N);
      current_statement__ = 39;
      context__.validate_dims("data initialization","region_full","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      region_full = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 39;
      region_full = context__.vals_i("region_full");
      current_statement__ = 39;
      stan::math::check_greater_or_equal(function__, "region_full",
                                            region_full, 0);
      current_statement__ = 39;
      stan::math::check_less_or_equal(function__, "region_full", region_full,
                                         n_region_full);
      current_statement__ = 40;
      stan::math::validate_non_negative_index("state", "N", N);
      current_statement__ = 41;
      context__.validate_dims("data initialization","state","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      state = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 41;
      state = context__.vals_i("state");
      current_statement__ = 41;
      stan::math::check_greater_or_equal(function__, "state", state, 0);
      current_statement__ = 41;
      stan::math::check_less_or_equal(function__, "state", state, n_state);
      current_statement__ = 42;
      stan::math::validate_non_negative_index("v_prev_full", "N", N);
      current_statement__ = 43;
      context__.validate_dims("data initialization","v_prev_full","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      v_prev_full__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&v_prev_full) Eigen::Map<Eigen::Matrix<double, -1, 1>>(v_prev_full__.data(), N);
        
      
      {
        std::vector<local_scalar_t__> v_prev_full_flat__;
        current_statement__ = 43;
        v_prev_full_flat__ = context__.vals_r("v_prev_full");
        current_statement__ = 43;
        pos__ = 1;
        current_statement__ = 43;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 43;
          stan::model::assign(v_prev_full, v_prev_full_flat__[(pos__ - 1)],
            "assigning variable v_prev_full", stan::model::index_uni(sym1__));
          current_statement__ = 43;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 44;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 45;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 45;
      y = context__.vals_i("y");
      current_statement__ = 45;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 45;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 46;
      stan::math::validate_non_negative_index("a", "n_age", n_age);
      current_statement__ = 47;
      stan::math::validate_non_negative_index("b", "n_edu", n_edu);
      current_statement__ = 48;
      stan::math::validate_non_negative_index("c", "n_age_edu", n_age_edu);
      current_statement__ = 49;
      stan::math::validate_non_negative_index("d", "n_state", n_state);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("e", "n_region_full",
                                              n_region_full);
      current_statement__ = 51;
      stan::math::validate_non_negative_index("y_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = n_age + n_edu + n_age_edu + n_state + n_region_full + 
      5 + 1 + 1 + 1 + 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail3_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_age, DUMMY_VAR__);
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_age);
      Eigen::Matrix<local_scalar_t__, -1, 1> b =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_edu, DUMMY_VAR__);
      current_statement__ = 2;
      b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> c =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_age_edu,
           DUMMY_VAR__);
      current_statement__ = 3;
      c = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
            n_age_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> d =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_state,
           DUMMY_VAR__);
      current_statement__ = 4;
      d = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_state);
      Eigen::Matrix<local_scalar_t__, -1, 1> e =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_region_full,
           DUMMY_VAR__);
      current_statement__ = 5;
      e = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
            n_region_full);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(5, DUMMY_VAR__);
      current_statement__ = 6;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(5);
      local_scalar_t__ sigma_a = DUMMY_VAR__;
      current_statement__ = 7;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_b = DUMMY_VAR__;
      current_statement__ = 8;
      sigma_b = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_c = DUMMY_VAR__;
      current_statement__ = 9;
      sigma_c = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_d = DUMMY_VAR__;
      current_statement__ = 10;
      sigma_d = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_e = DUMMY_VAR__;
      current_statement__ = 11;
      sigma_e = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 14;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 13;
        stan::model::assign(y_hat,
          (((((((((stan::model::rvalue(beta, "beta",
                     stan::model::index_uni(1)) +
                    (stan::model::rvalue(beta, "beta",
                       stan::model::index_uni(2)) *
                      stan::model::rvalue(black, "black",
                        stan::model::index_uni(i)))) +
                   (stan::model::rvalue(beta, "beta",
                      stan::model::index_uni(3)) *
                     stan::model::rvalue(female, "female",
                       stan::model::index_uni(i)))) +
                  ((stan::model::rvalue(beta, "beta",
                      stan::model::index_uni(5)) *
                     stan::model::rvalue(female, "female",
                       stan::model::index_uni(i))) *
                    stan::model::rvalue(black, "black",
                      stan::model::index_uni(i)))) +
                 (stan::model::rvalue(beta, "beta",
                    stan::model::index_uni(4)) *
                   stan::model::rvalue(v_prev_full, "v_prev_full",
                     stan::model::index_uni(i)))) +
                stan::model::rvalue(a, "a",
                  stan::model::index_uni(stan::model::rvalue(age, "age",
                                           stan::model::index_uni(i))))) +
               stan::model::rvalue(b, "b",
                 stan::model::index_uni(stan::model::rvalue(edu, "edu",
                                          stan::model::index_uni(i))))) +
              stan::model::rvalue(c, "c",
                stan::model::index_uni(stan::model::rvalue(age_edu,
                                         "age_edu",
                                         stan::model::index_uni(i))))) +
             stan::model::rvalue(d, "d",
               stan::model::index_uni(stan::model::rvalue(state, "state",
                                        stan::model::index_uni(i))))) +
            stan::model::rvalue(e, "e",
              stan::model::index_uni(stan::model::rvalue(region_full,
                                       "region_full",
                                       stan::model::index_uni(i))))),
          "assigning variable y_hat", stan::model::index_uni(i));
      }
      {
        current_statement__ = 15;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(a, 0, sigma_a));
        current_statement__ = 16;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(b, 0, sigma_b));
        current_statement__ = 17;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(c, 0, sigma_c));
        current_statement__ = 18;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(d, 0, sigma_d));
        current_statement__ = 19;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(e, 0, sigma_e));
        current_statement__ = 20;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(beta, 0, 100));
        current_statement__ = 21;
        lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(y, y_hat));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail3_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, 1> a =
         Eigen::Matrix<double, -1, 1>::Constant(n_age,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_age);
      Eigen::Matrix<double, -1, 1> b =
         Eigen::Matrix<double, -1, 1>::Constant(n_edu,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_edu);
      Eigen::Matrix<double, -1, 1> c =
         Eigen::Matrix<double, -1, 1>::Constant(n_age_edu,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      c = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
            n_age_edu);
      Eigen::Matrix<double, -1, 1> d =
         Eigen::Matrix<double, -1, 1>::Constant(n_state,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 4;
      d = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_state);
      Eigen::Matrix<double, -1, 1> e =
         Eigen::Matrix<double, -1, 1>::Constant(n_region_full,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      e = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
            n_region_full);
      Eigen::Matrix<double, -1, 1> beta =
         Eigen::Matrix<double, -1, 1>::Constant(5,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 6;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(5);
      double sigma_a = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 7;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      double sigma_b = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 8;
      sigma_b = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      double sigma_c = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 9;
      sigma_c = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      double sigma_d = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 10;
      sigma_d = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      double sigma_e = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 11;
      sigma_e = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<double, -1, 1> y_hat =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(a);
      out__.write(b);
      out__.write(c);
      out__.write(d);
      out__.write(e);
      out__.write(beta);
      out__.write(sigma_a);
      out__.write(sigma_b);
      out__.write(sigma_c);
      out__.write(sigma_d);
      out__.write(sigma_e);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 14;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 13;
        stan::model::assign(y_hat,
          (((((((((stan::model::rvalue(beta, "beta",
                     stan::model::index_uni(1)) +
                    (stan::model::rvalue(beta, "beta",
                       stan::model::index_uni(2)) *
                      stan::model::rvalue(black, "black",
                        stan::model::index_uni(i)))) +
                   (stan::model::rvalue(beta, "beta",
                      stan::model::index_uni(3)) *
                     stan::model::rvalue(female, "female",
                       stan::model::index_uni(i)))) +
                  ((stan::model::rvalue(beta, "beta",
                      stan::model::index_uni(5)) *
                     stan::model::rvalue(female, "female",
                       stan::model::index_uni(i))) *
                    stan::model::rvalue(black, "black",
                      stan::model::index_uni(i)))) +
                 (stan::model::rvalue(beta, "beta",
                    stan::model::index_uni(4)) *
                   stan::model::rvalue(v_prev_full, "v_prev_full",
                     stan::model::index_uni(i)))) +
                stan::model::rvalue(a, "a",
                  stan::model::index_uni(stan::model::rvalue(age, "age",
                                           stan::model::index_uni(i))))) +
               stan::model::rvalue(b, "b",
                 stan::model::index_uni(stan::model::rvalue(edu, "edu",
                                          stan::model::index_uni(i))))) +
              stan::model::rvalue(c, "c",
                stan::model::index_uni(stan::model::rvalue(age_edu,
                                         "age_edu",
                                         stan::model::index_uni(i))))) +
             stan::model::rvalue(d, "d",
               stan::model::index_uni(stan::model::rvalue(state, "state",
                                        stan::model::index_uni(i))))) +
            stan::model::rvalue(e, "e",
              stan::model::index_uni(stan::model::rvalue(region_full,
                                       "region_full",
                                       stan::model::index_uni(i))))),
          "assigning variable y_hat", stan::model::index_uni(i));
      }
      if (emit_transformed_parameters__) {
        out__.write(y_hat);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, 1> a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_age, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
        stan::model::assign(a, in__.read<local_scalar_t__>(),
          "assigning variable a", stan::model::index_uni(sym1__));
      }
      out__.write(a);
      Eigen::Matrix<local_scalar_t__, -1, 1> b =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_edu, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
        stan::model::assign(b, in__.read<local_scalar_t__>(),
          "assigning variable b", stan::model::index_uni(sym1__));
      }
      out__.write(b);
      Eigen::Matrix<local_scalar_t__, -1, 1> c =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_age_edu,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_age_edu; ++sym1__) {
        stan::model::assign(c, in__.read<local_scalar_t__>(),
          "assigning variable c", stan::model::index_uni(sym1__));
      }
      out__.write(c);
      Eigen::Matrix<local_scalar_t__, -1, 1> d =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_state,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
        stan::model::assign(d, in__.read<local_scalar_t__>(),
          "assigning variable d", stan::model::index_uni(sym1__));
      }
      out__.write(d);
      Eigen::Matrix<local_scalar_t__, -1, 1> e =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_region_full,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_region_full; ++sym1__) {
        stan::model::assign(e, in__.read<local_scalar_t__>(),
          "assigning variable e", stan::model::index_uni(sym1__));
      }
      out__.write(e);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(5, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        stan::model::assign(beta, in__.read<local_scalar_t__>(),
          "assigning variable beta", stan::model::index_uni(sym1__));
      }
      out__.write(beta);
      local_scalar_t__ sigma_a = DUMMY_VAR__;
      sigma_a = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_a);
      local_scalar_t__ sigma_b = DUMMY_VAR__;
      sigma_b = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_b);
      local_scalar_t__ sigma_c = DUMMY_VAR__;
      sigma_c = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_c);
      local_scalar_t__ sigma_d = DUMMY_VAR__;
      sigma_d = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_d);
      local_scalar_t__ sigma_e = DUMMY_VAR__;
      sigma_e = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_e);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"a", "b", "c", "d", "e", "beta",
      "sigma_a", "sigma_b", "sigma_c", "sigma_d", "sigma_e", "y_hat"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(n_age)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(n_edu)},
      std::vector<size_t>{static_cast<size_t>(n_age_edu)},
      std::vector<size_t>{static_cast<size_t>(n_state)},
      std::vector<size_t>{static_cast<size_t>(n_region_full)},
      std::vector<size_t>{static_cast<size_t>(5)}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(N)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_age_edu; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "c" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "d" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_region_full; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "e" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_b");
    param_names__.emplace_back(std::string() + "sigma_c");
    param_names__.emplace_back(std::string() + "sigma_d");
    param_names__.emplace_back(std::string() + "sigma_e");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_age_edu; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "c" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "d" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= n_region_full; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "e" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_b");
    param_names__.emplace_back(std::string() + "sigma_c");
    param_names__.emplace_back(std::string() + "sigma_d");
    param_names__.emplace_back(std::string() + "sigma_e");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age) + "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"c\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age_edu) + "},\"block\":\"parameters\"},{\"name\":\"d\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_state) + "},\"block\":\"parameters\"},{\"name\":\"e\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_region_full) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_b\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_c\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_d\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_e\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age) + "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_edu) + "},\"block\":\"parameters\"},{\"name\":\"c\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_age_edu) + "},\"block\":\"parameters\"},{\"name\":\"d\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_state) + "},\"block\":\"parameters\"},{\"name\":\"e\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_region_full) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(5) + "},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_b\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_c\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_d\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_e\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((((((((n_age + n_edu) + n_age_edu) + n_state) + n_region_full) + 5) + 1)
       + 1) + 1) + 1) + 1);
      const size_t num_transformed = N;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((((((((n_age + n_edu) + n_age_edu) + n_state) + n_region_full) + 5) + 1)
       + 1) + 1) + 1) + 1);
      const size_t num_transformed = N;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 11> names__{"a", "b", "c", "d", "e",
      "beta", "sigma_a", "sigma_b", "sigma_c", "sigma_d", "sigma_e"};
      const std::array<Eigen::Index, 11> constrain_param_sizes__{n_age, 
       n_edu, n_age_edu, n_state, n_region_full, 5, 1, 1, 1, 1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail3_model_namespace::expr_prop_fail3_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail3_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 expr-prop-fail4.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail4_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 46> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail4.stan', line 12, column 2 to column 24)",
 " (in 'expr-prop-fail4.stan', line 13, column 2 to column 28)",
 " (in 'expr-prop-fail4.stan', line 16, column 2 to column 47)",
 " (in 'expr-prop-fail4.stan', line 17, column 2 to column 16)",
 " (in 'expr-prop-fail4.stan', line 18, column 2 to column 33)",
 " (in 'expr-prop-fail4.stan', line 19, column 2 to column 29)",
 " (in 'expr-prop-fail4.stan', line 20, column 2 to column 24)",
 " (in 'expr-prop-fail4.stan', line 27, column 2 to column 13)",
 " (in 'expr-prop-fail4.stan', line 28, column 2 to column 13)",
 " (in 'expr-prop-fail4.stan', line 29, column 2 to column 26)",
 " (in 'expr-prop-fail4.stan', line 30, column 2 to column 28)",
 " (in 'expr-prop-fail4.stan', line 31, column 2 to column 18)",
 " (in 'expr-prop-fail4.stan', line 32, column 2 to column 22)",
 " (in 'expr-prop-fail4.stan', line 34, column 2 to column 14)",
 " (in 'expr-prop-fail4.stan', line 35, column 2 to column 17)",
 " (in 'expr-prop-fail4.stan', line 37, column 2 to column 27)",
 " (in 'expr-prop-fail4.stan', line 38, column 2 to column 27)",
 " (in 'expr-prop-fail4.stan', line 40, column 4 to column 36)",
 " (in 'expr-prop-fail4.stan', line 39, column 19 to line 41, column 3)",
 " (in 'expr-prop-fail4.stan', line 39, column 2 to line 41, column 3)",
 " (in 'expr-prop-fail4.stan', line 42, column 2 to column 38)",
 " (in 'expr-prop-fail4.stan', line 43, column 2 to column 37)",
 " (in 'expr-prop-fail4.stan', line 44, column 2 to column 34)",
 " (in 'expr-prop-fail4.stan', line 47, column 4 to column 28)",
 " (in 'expr-prop-fail4.stan', line 48, column 4 to line 49, column 39)",
 " (in 'expr-prop-fail4.stan', line 46, column 19 to line 50, column 3)",
 " (in 'expr-prop-fail4.stan', line 46, column 2 to line 50, column 3)",
 " (in 'expr-prop-fail4.stan', line 23, column 2 to column 53)",
 " (in 'expr-prop-fail4.stan', line 24, column 2 to column 24)",
 " (in 'expr-prop-fail4.stan', line 2, column 2 to column 17)",
 " (in 'expr-prop-fail4.stan', line 3, column 2 to column 23)",
 " (in 'expr-prop-fail4.stan', line 4, column 8 to column 15)",
 " (in 'expr-prop-fail4.stan', line 4, column 2 to column 45)",
 " (in 'expr-prop-fail4.stan', line 5, column 8 to column 15)",
 " (in 'expr-prop-fail4.stan', line 5, column 2 to column 45)",
 " (in 'expr-prop-fail4.stan', line 6, column 18 to column 19)",
 " (in 'expr-prop-fail4.stan', line 6, column 2 to column 23)",
 " (in 'expr-prop-fail4.stan', line 9, column 9 to column 10)",
 " (in 'expr-prop-fail4.stan', line 9, column 2 to column 27)",
 " (in 'expr-prop-fail4.stan', line 13, column 9 to column 14)",
 " (in 'expr-prop-fail4.stan', line 17, column 9 to column 10)",
 " (in 'expr-prop-fail4.stan', line 31, column 9 to column 10)",
 " (in 'expr-prop-fail4.stan', line 32, column 9 to column 10)",
 " (in 'expr-prop-fail4.stan', line 34, column 9 to column 10)",
 " (in 'expr-prop-fail4.stan', line 35, column 8 to column 9)"};




class expr_prop_fail4_model final : public model_base_crtp<expr_prop_fail4_model> {

 private:
  int N;
  int N_edges;
  std::vector<int> node1;
  std::vector<int> node2;
  Eigen::Matrix<double, -1, 1> E__;
  Eigen::Matrix<double, -1, 1> log_E__;
  int phi_std_raw_1dim__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> E{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> log_E{nullptr, 0};
 
 public:
  ~expr_prop_fail4_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail4_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  expr_prop_fail4_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail4_model_namespace::expr_prop_fail4_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 30;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      
      current_statement__ = 30;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 31;
      context__.validate_dims("data initialization","N_edges","int",
           std::vector<size_t>{});
      N_edges = std::numeric_limits<int>::min();
      
      
      current_statement__ = 31;
      N_edges = context__.vals_i("N_edges")[(1 - 1)];
      current_statement__ = 31;
      stan::math::check_greater_or_equal(function__, "N_edges", N_edges, 0);
      current_statement__ = 32;
      stan::math::validate_non_negative_index("node1", "N_edges", N_edges);
      current_statement__ = 33;
      context__.validate_dims("data initialization","node1","int",
           std::vector<size_t>{static_cast<size_t>(N_edges)});
      node1 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      
      
      current_statement__ = 33;
      node1 = context__.vals_i("node1");
      current_statement__ = 33;
      stan::math::check_greater_or_equal(function__, "node1", node1, 1);
      current_statement__ = 33;
      stan::math::check_less_or_equal(function__, "node1", node1, N);
      current_statement__ = 34;
      stan::math::validate_non_negative_index("node2", "N_edges", N_edges);
      current_statement__ = 35;
      context__.validate_dims("data initialization","node2","int",
           std::vector<size_t>{static_cast<size_t>(N_edges)});
      node2 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      
      
      current_statement__ = 35;
      node2 = context__.vals_i("node2");
      current_statement__ = 35;
      stan::math::check_greater_or_equal(function__, "node2", node2, 1);
      current_statement__ = 35;
      stan::math::check_less_or_equal(function__, "node2", node2, N);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("E", "N", N);
      current_statement__ = 37;
      context__.validate_dims("data initialization","E","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      E__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&E) Eigen::Map<Eigen::Matrix<double, -1, 1>>(E__.data(), N);
      
      {
        std::vector<local_scalar_t__> E_flat__;
        current_statement__ = 37;
        E_flat__ = context__.vals_r("E");
        current_statement__ = 37;
        pos__ = 1;
        current_statement__ = 37;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 37;
          stan::model::assign(E, E_flat__[(pos__ - 1)],
            "assigning variable E", stan::model::index_uni(sym1__));
          current_statement__ = 37;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 37;
      stan::math::check_greater_or_equal(function__, "E", E, 0);
      current_statement__ = 38;
      stan::math::validate_non_negative_index("log_E", "N", N);
      current_statement__ = 39;
      log_E__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&log_E) Eigen::Map<Eigen::Matrix<double, -1, 1>>(log_E__.data(), N);
        
      
      current_statement__ = 39;
      stan::model::assign(log_E, stan::math::log(E),
        "assigning variable log_E");
      current_statement__ = 40;
      phi_std_raw_1dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 40;
      phi_std_raw_1dim__ = (N - 1);
      current_statement__ = 40;
      stan::math::validate_non_negative_index("phi_std_raw", "N - 1",
                                              phi_std_raw_1dim__);
      current_statement__ = 41;
      stan::math::validate_non_negative_index("phi", "N", N);
      current_statement__ = 42;
      stan::math::validate_non_negative_index("theta", "N", N);
      current_statement__ = 43;
      stan::math::validate_non_negative_index("theta_std", "N", N);
      current_statement__ = 44;
      stan::math::validate_non_negative_index("x", "N", N);
      current_statement__ = 45;
      stan::math::validate_non_negative_index("y", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + phi_std_raw_1dim__;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail4_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ tau_phi = DUMMY_VAR__;
      current_statement__ = 1;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__, 
                  jacobian__>(0, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_std_raw =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(phi_std_raw_1dim__,
           DUMMY_VAR__);
      current_statement__ = 2;
      phi_std_raw = in__.template read<
                      Eigen::Matrix<local_scalar_t__, -1, 1>>(
                      phi_std_raw_1dim__);
      local_scalar_t__ sigma_phi = DUMMY_VAR__;
      current_statement__ = 3;
      sigma_phi = stan::math::inv(stan::math::sqrt(tau_phi));
      Eigen::Matrix<local_scalar_t__, -1, 1> phi =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(phi, phi_std_raw,
        "assigning variable phi", stan::model::index_min_max(1, (N - 1)));
      current_statement__ = 6;
      stan::model::assign(phi, -stan::math::sum(phi_std_raw),
        "assigning variable phi", stan::model::index_uni(N));
      current_statement__ = 7;
      stan::model::assign(phi,
        stan::math::multiply(stan::model::deep_copy(phi), sigma_phi),
        "assigning variable phi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "sigma_phi", sigma_phi,
                                            0);
      {
        current_statement__ = 28;
        lp_accum__.add(
          (-0.5 *
            stan::math::dot_self(
              stan::math::subtract(
                stan::model::rvalue(phi, "phi",
                  stan::model::index_multi(node1)),
                stan::model::rvalue(phi, "phi",
                  stan::model::index_multi(node2))))));
        current_statement__ = 29;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(tau_phi, 1, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail4_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double tau_phi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__, 
                  jacobian__>(0, lp__);
      Eigen::Matrix<double, -1, 1> phi_std_raw =
         Eigen::Matrix<double, -1, 1>::Constant(phi_std_raw_1dim__,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      phi_std_raw = in__.template read<
                      Eigen::Matrix<local_scalar_t__, -1, 1>>(
                      phi_std_raw_1dim__);
      double sigma_phi = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double, -1, 1> phi =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(tau_phi);
      out__.write(phi_std_raw);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 3;
      sigma_phi = stan::math::inv(stan::math::sqrt(tau_phi));
      current_statement__ = 5;
      stan::model::assign(phi, phi_std_raw,
        "assigning variable phi", stan::model::index_min_max(1, (N - 1)));
      current_statement__ = 6;
      stan::model::assign(phi, -stan::math::sum(phi_std_raw),
        "assigning variable phi", stan::model::index_uni(N));
      current_statement__ = 7;
      stan::model::assign(phi,
        stan::math::multiply(stan::model::deep_copy(phi), sigma_phi),
        "assigning variable phi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "sigma_phi", sigma_phi,
                                            0);
      if (emit_transformed_parameters__) {
        out__.write(sigma_phi);
        out__.write(phi);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double beta0 = std::numeric_limits<double>::quiet_NaN();
      double beta1 = std::numeric_limits<double>::quiet_NaN();
      double tau_theta = std::numeric_limits<double>::quiet_NaN();
      double sigma_theta = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double, -1, 1> theta =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> theta_std =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> x =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      std::vector<int> y =
         std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 16;
      beta0 = stan::math::normal_rng(0, 1, base_rng__);
      current_statement__ = 17;
      beta1 = stan::math::normal_rng(0, 1, base_rng__);
      current_statement__ = 20;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 18;
        stan::model::assign(theta_std,
          stan::math::normal_rng(0, 1, base_rng__),
          "assigning variable theta_std", stan::model::index_uni(i));
      }
      current_statement__ = 21;
      tau_theta = stan::math::gamma_rng(3.2761, 1.81, base_rng__);
      current_statement__ = 22;
      sigma_theta = stan::math::inv(stan::math::sqrt(tau_theta));
      current_statement__ = 23;
      stan::model::assign(theta,
        stan::math::multiply(theta_std, sigma_theta),
        "assigning variable theta");
      current_statement__ = 27;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 24;
        stan::model::assign(x, stan::math::normal_rng(0, 1, base_rng__),
          "assigning variable x", stan::model::index_uni(i));
        current_statement__ = 25;
        stan::model::assign(y,
          stan::math::poisson_log_rng(
            ((((stan::model::rvalue(log_E, "log_E",
                  stan::model::index_uni(i)) + beta0) +
                (beta1 *
                  stan::model::rvalue(x, "x", stan::model::index_uni(i)))) +
               stan::model::rvalue(phi, "phi", stan::model::index_uni(i))) +
              stan::model::rvalue(theta, "theta", stan::model::index_uni(i))),
            base_rng__), "assigning variable y", stan::model::index_uni(i));
      }
      current_statement__ = 10;
      stan::math::check_greater_or_equal(function__, "tau_theta", tau_theta,
                                            0);
      current_statement__ = 11;
      stan::math::check_greater_or_equal(function__, "sigma_theta",
                                            sigma_theta, 0);
      out__.write(beta0);
      out__.write(beta1);
      out__.write(tau_theta);
      out__.write(sigma_theta);
      out__.write(theta);
      out__.write(theta_std);
      out__.write(x);
      out__.write(y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ tau_phi = DUMMY_VAR__;
      tau_phi = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau_phi);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_std_raw =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(phi_std_raw_1dim__,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= phi_std_raw_1dim__; ++sym1__) {
        stan::model::assign(phi_std_raw, in__.read<local_scalar_t__>(),
          "assigning variable phi_std_raw", stan::model::index_uni(sym1__));
      }
      out__.write(phi_std_raw);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"tau_phi", "phi_std_raw", "sigma_phi",
      "phi", "beta0", "beta1", "tau_theta", "sigma_theta", "theta",
      "theta_std", "x", "y"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(phi_std_raw_1dim__)},
      std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym1__ = 1; sym1__ <= phi_std_raw_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "beta0");
      param_names__.emplace_back(std::string() + "beta1");
      param_names__.emplace_back(std::string() + "tau_theta");
      param_names__.emplace_back(std::string() + "sigma_theta");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "theta_std" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym1__ = 1; sym1__ <= phi_std_raw_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "beta0");
      param_names__.emplace_back(std::string() + "beta1");
      param_names__.emplace_back(std::string() + "tau_theta");
      param_names__.emplace_back(std::string() + "sigma_theta");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "theta_std" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(phi_std_raw_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"sigma_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(phi_std_raw_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"sigma_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"generated_quantities\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(N) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + phi_std_raw_1dim__);
      const size_t num_transformed = (1 + N);
      const size_t num_gen_quantities = 
  (((((((1 + 1) + 1) + 1) + N) + N) + N) + N);
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + phi_std_raw_1dim__);
      const size_t num_transformed = (1 + N);
      const size_t num_gen_quantities = 
  (((((((1 + 1) + 1) + 1) + N) + N) + N) + N);
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"tau_phi", "phi_std_raw"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{1,
       phi_std_raw_1dim__};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail4_model_namespace::expr_prop_fail4_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail4_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 expr-prop-fail5.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail5_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 81> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail5.stan', line 68, column 2 to column 34)",
 " (in 'expr-prop-fail5.stan', line 69, column 2 to column 32)",
 " (in 'expr-prop-fail5.stan', line 70, column 2 to column 23)",
 " (in 'expr-prop-fail5.stan', line 71, column 2 to column 31)",
 " (in 'expr-prop-fail5.stan', line 76, column 2 to column 52)",
 " (in 'expr-prop-fail5.stan', line 77, column 2 to column 50)",
 " (in 'expr-prop-fail5.stan', line 78, column 2 to column 50)",
 " (in 'expr-prop-fail5.stan', line 79, column 2 to column 10)",
 " (in 'expr-prop-fail5.stan', line 82, column 2 to column 23)",
 " (in 'expr-prop-fail5.stan', line 85, column 6 to column 20)",
 " (in 'expr-prop-fail5.stan', line 86, column 6 to column 18)",
 " (in 'expr-prop-fail5.stan', line 84, column 34 to line 87, column 5)",
 " (in 'expr-prop-fail5.stan', line 84, column 4 to line 87, column 5)",
 " (in 'expr-prop-fail5.stan', line 89, column 6 to column 45)",
 " (in 'expr-prop-fail5.stan', line 90, column 6 to column 23)",
 " (in 'expr-prop-fail5.stan', line 88, column 40 to line 91, column 5)",
 " (in 'expr-prop-fail5.stan', line 88, column 4 to line 91, column 5)",
 " (in 'expr-prop-fail5.stan', line 83, column 22 to line 92, column 3)",
 " (in 'expr-prop-fail5.stan', line 83, column 2 to line 92, column 3)",
 " (in 'expr-prop-fail5.stan', line 94, column 2 to column 51)",
 " (in 'expr-prop-fail5.stan', line 118, column 2 to column 23)",
 " (in 'expr-prop-fail5.stan', line 120, column 2 to column 25)",
 " (in 'expr-prop-fail5.stan', line 104, column 2 to column 29)",
 " (in 'expr-prop-fail5.stan', line 110, column 8 to column 37)",
 " (in 'expr-prop-fail5.stan', line 111, column 8 to column 41)",
 " (in 'expr-prop-fail5.stan', line 109, column 42 to line 112, column 7)",
 " (in 'expr-prop-fail5.stan', line 109, column 6 to line 112, column 7)",
 " (in 'expr-prop-fail5.stan', line 113, column 6 to column 37)",
 " (in 'expr-prop-fail5.stan', line 108, column 22 to line 114, column 5)",
 " (in 'expr-prop-fail5.stan', line 108, column 4 to line 114, column 5)",
 " (in 'expr-prop-fail5.stan', line 107, column 22 to line 115, column 3)",
 " (in 'expr-prop-fail5.stan', line 107, column 2 to line 115, column 3)",
 " (in 'expr-prop-fail5.stan', line 51, column 2 to column 20)",
 " (in 'expr-prop-fail5.stan', line 52, column 2 to column 27)",
 " (in 'expr-prop-fail5.stan', line 53, column 8 to column 12)",
 " (in 'expr-prop-fail5.stan', line 53, column 14 to column 25)",
 " (in 'expr-prop-fail5.stan', line 53, column 2 to column 51)",
 " (in 'expr-prop-fail5.stan', line 56, column 2 to column 38)",
 " (in 'expr-prop-fail5.stan', line 58, column 8 to column 12)",
 " (in 'expr-prop-fail5.stan', line 58, column 2 to column 52)",
 " (in 'expr-prop-fail5.stan', line 59, column 8 to column 12)",
 " (in 'expr-prop-fail5.stan', line 59, column 2 to column 51)",
 " (in 'expr-prop-fail5.stan', line 63, column 4 to column 35)",
 " (in 'expr-prop-fail5.stan', line 62, column 2 to line 63, column 35)",
 " (in 'expr-prop-fail5.stan', line 65, column 4 to column 33)",
 " (in 'expr-prop-fail5.stan', line 64, column 2 to line 65, column 33)",
 " (in 'expr-prop-fail5.stan', line 70, column 9 to column 13)",
 " (in 'expr-prop-fail5.stan', line 76, column 27 to column 31)",
 " (in 'expr-prop-fail5.stan', line 76, column 33 to column 46)",
 " (in 'expr-prop-fail5.stan', line 77, column 27 to column 31)",
 " (in 'expr-prop-fail5.stan', line 77, column 33 to column 46)",
 " (in 'expr-prop-fail5.stan', line 78, column 27 to column 31)",
 " (in 'expr-prop-fail5.stan', line 78, column 33 to column 44)",
 " (in 'expr-prop-fail5.stan', line 8, column 8 to column 17)",
 " (in 'expr-prop-fail5.stan', line 7, column 6 to line 8, column 17)",
 " (in 'expr-prop-fail5.stan', line 6, column 4 to line 8, column 17)",
 " (in 'expr-prop-fail5.stan', line 9, column 4 to column 13)",
 " (in 'expr-prop-fail5.stan', line 5, column 37 to line 10, column 3)",
 " (in 'expr-prop-fail5.stan', line 15, column 6 to column 32)",
 " (in 'expr-prop-fail5.stan', line 19, column 8 to column 17)",
 " (in 'expr-prop-fail5.stan', line 18, column 6 to line 19, column 17)",
 " (in 'expr-prop-fail5.stan', line 13, column 39 to line 20, column 5)",
 " (in 'expr-prop-fail5.stan', line 13, column 4 to line 20, column 5)",
 " (in 'expr-prop-fail5.stan', line 21, column 4 to column 13)",
 " (in 'expr-prop-fail5.stan', line 12, column 36 to line 22, column 3)",
 " (in 'expr-prop-fail5.stan', line 25, column 11 to column 15)",
 " (in 'expr-prop-fail5.stan', line 25, column 17 to column 28)",
 " (in 'expr-prop-fail5.stan', line 25, column 4 to column 34)",
 " (in 'expr-prop-fail5.stan', line 28, column 6 to column 32)",
 " (in 'expr-prop-fail5.stan', line 31, column 8 to column 37)",
 " (in 'expr-prop-fail5.stan', line 32, column 8 to column 32)",
 " (in 'expr-prop-fail5.stan', line 40, column 8 to column 33)",
 " (in 'expr-prop-fail5.stan', line 41, column 8 to column 28)",
 " (in 'expr-prop-fail5.stan', line 42, column 8 to line 44, column 44)",
 " (in 'expr-prop-fail5.stan', line 29, column 39 to line 45, column 7)",
 " (in 'expr-prop-fail5.stan', line 29, column 6 to line 45, column 7)",
 " (in 'expr-prop-fail5.stan', line 27, column 24 to line 46, column 5)",
 " (in 'expr-prop-fail5.stan', line 27, column 4 to line 46, column 5)",
 " (in 'expr-prop-fail5.stan', line 47, column 4 to column 15)",
 " (in 'expr-prop-fail5.stan', line 24, column 74 to line 48, column 3)"};

struct first_capture_functor__ {
  int
  operator()(const std::vector<int>& y_i, std::ostream* pstream__) const;
};
struct prob_uncaptured_functor__ {
  template <typename T2__, typename T3__,
            stan::require_eigen_matrix_dynamic_t<T2__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>, stan::value_type_t<T3__>>, -1, -1>
  operator()(const int& nind, const int& n_occasions, const T2__& p,
             const T3__& phi, std::ostream* pstream__) const;
};
struct last_capture_functor__ {
  int
  operator()(const std::vector<int>& y_i, std::ostream* pstream__) const;
};

int first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 56;
      for (int k = 1; k <= stan::math::size(y_i); ++k) {
        current_statement__ = 55;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
          current_statement__ = 54;
          return k;
        } 
      }
      current_statement__ = 57;
      return 0;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 63;
      for (int k_rev = 0; k_rev <= (stan::math::size(y_i) - 1); ++k_rev) {
        int k = std::numeric_limits<int>::min();
        current_statement__ = 59;
        k = (stan::math::size(y_i) - k_rev);
        current_statement__ = 61;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
          current_statement__ = 60;
          return k;
        } 
      }
      current_statement__ = 64;
      return 0;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T2__, typename T3__,
          stan::require_eigen_matrix_dynamic_t<T2__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>, stan::value_type_t<T3__>>, -1, -1>
  prob_uncaptured(const int& nind, const int& n_occasions,
                  const T2__& p_arg__, const T3__& phi_arg__,
                  std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<stan::value_type_t<T2__>,
                                 stan::value_type_t<T3__>>;
    int current_statement__ = 0; 
    const auto& p = stan::math::to_ref(p_arg__);
    const auto& phi = stan::math::to_ref(phi_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 66;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 67;
      stan::math::validate_non_negative_index("chi", "n_occasions",
                                              n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind, n_occasions,
           DUMMY_VAR__);
      current_statement__ = 78;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 69;
        stan::model::assign(chi, 1.0,
          "assigning variable chi", stan::model::index_uni(i),
                                      stan::model::index_uni(n_occasions));
        current_statement__ = 76;
        for (int t = 1; t <= (n_occasions - 1); ++t) {
          int t_curr = std::numeric_limits<int>::min();
          current_statement__ = 70;
          t_curr = (n_occasions - t);
          int t_next = std::numeric_limits<int>::min();
          current_statement__ = 71;
          t_next = (t_curr + 1);
          current_statement__ = 72;
          t_curr = (n_occasions - t);
          current_statement__ = 73;
          t_next = (t_curr + 1);
          current_statement__ = 74;
          stan::model::assign(chi,
            ((1 -
               stan::model::rvalue(phi, "phi",
                 stan::model::index_uni(i), stan::model::index_uni(t_curr)))
              +
              ((stan::model::rvalue(phi, "phi",
                  stan::model::index_uni(i), stan::model::index_uni(t_curr))
                 *
                 (1 -
                   stan::model::rvalue(p, "p",
                     stan::model::index_uni(i),
                       stan::model::index_uni((t_next - 1))))) *
                stan::model::rvalue(chi, "chi",
                  stan::model::index_uni(i), stan::model::index_uni(t_next)))),
            "assigning variable chi", stan::model::index_uni(i),
                                        stan::model::index_uni(t_curr));
        }
      }
      current_statement__ = 79;
      return chi;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int
first_capture_functor__::operator()(const std::vector<int>& y_i,
                                    std::ostream* pstream__)  const
{
  return first_capture(y_i, pstream__);
}

template <typename T2__, typename T3__,
          stan::require_eigen_matrix_dynamic_t<T2__>*,
          stan::require_eigen_matrix_dynamic_t<T3__>*>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>, stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured_functor__::operator()(const int& nind,
                                      const int& n_occasions, const T2__& p,
                                      const T3__& phi,
                                      std::ostream* pstream__)  const
{
  return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}

int
last_capture_functor__::operator()(const std::vector<int>& y_i,
                                   std::ostream* pstream__)  const
{
  return last_capture(y_i, pstream__);
}


class expr_prop_fail5_model final : public model_base_crtp<expr_prop_fail5_model> {

 private:
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last; 
  
 
 public:
  ~expr_prop_fail5_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail5_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  expr_prop_fail5_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail5_model_namespace::expr_prop_fail5_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 33;
      context__.validate_dims("data initialization","nind","int",
           std::vector<size_t>{});
      nind = std::numeric_limits<int>::min();
      
      
      current_statement__ = 33;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 33;
      stan::math::check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 34;
      context__.validate_dims("data initialization","n_occasions","int",
           std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      
      
      current_statement__ = 34;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 34;
      stan::math::check_greater_or_equal(function__, "n_occasions",
                                            n_occasions, 2);
      current_statement__ = 35;
      stan::math::validate_non_negative_index("y", "nind", nind);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 37;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(nind),
            static_cast<size_t>(n_occasions)});
      y = 
        std::vector<std::vector<int>>(nind, 
          std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 37;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 37;
        pos__ = 1;
        current_statement__ = 37;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 37;
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            current_statement__ = 37;
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
            current_statement__ = 37;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 37;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 37;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 38;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      
      
      current_statement__ = 38;
      n_occ_minus_1 = (n_occasions - 1);
      current_statement__ = 39;
      stan::math::validate_non_negative_index("first", "nind", nind);
      current_statement__ = 40;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      
      current_statement__ = 41;
      stan::math::validate_non_negative_index("last", "nind", nind);
      current_statement__ = 42;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      
      current_statement__ = 44;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 43;
        stan::model::assign(first,
          first_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(i)), pstream__),
          "assigning variable first", stan::model::index_uni(i));
      }
      current_statement__ = 46;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 45;
        stan::model::assign(last,
          last_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(i)), pstream__),
          "assigning variable last", stan::model::index_uni(i));
      }
      current_statement__ = 40;
      stan::math::check_greater_or_equal(function__, "first", first, 0);
      current_statement__ = 40;
      stan::math::check_less_or_equal(function__, "first", first, n_occasions);
      current_statement__ = 42;
      stan::math::check_greater_or_equal(function__, "last", last, 0);
      current_statement__ = 42;
      stan::math::check_less_or_equal(function__, "last", last, n_occasions);
      current_statement__ = 47;
      stan::math::validate_non_negative_index("epsilon", "nind", nind);
      current_statement__ = 48;
      stan::math::validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 49;
      stan::math::validate_non_negative_index("phi", "n_occ_minus_1",
                                              n_occ_minus_1);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("p", "nind", nind);
      current_statement__ = 51;
      stan::math::validate_non_negative_index("p", "n_occ_minus_1",
                                              n_occ_minus_1);
      current_statement__ = 52;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 53;
      stan::math::validate_non_negative_index("chi", "n_occasions",
                                              n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + nind + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail5_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ mean_phi = DUMMY_VAR__;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ mean_p = DUMMY_VAR__;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, 
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nind, DUMMY_VAR__);
      current_statement__ = 3;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  nind);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 4;
      sigma = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 5, lp__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind,
           n_occ_minus_1, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind,
           n_occ_minus_1, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind, n_occasions,
           DUMMY_VAR__);
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 9;
      mu = stan::math::logit(mean_phi);
      current_statement__ = 19;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 13;
        for (int t = 1;
             t <= (stan::model::rvalue(first, "first",
                     stan::model::index_uni(i)) - 1);
             ++t) {
          current_statement__ = 10;
          stan::model::assign(phi, 0,
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 11;
          stan::model::assign(p, 0,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
        current_statement__ = 17;
        for (int t = stan::model::rvalue(first, "first",
                       stan::model::index_uni(i));
             t <= n_occ_minus_1; ++t) {
          current_statement__ = 14;
          stan::model::assign(phi,
            stan::math::inv_logit(
              (mu +
                stan::model::rvalue(epsilon, "epsilon",
                  stan::model::index_uni(i)))),
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 15;
          stan::model::assign(p, mean_p,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
      }
      current_statement__ = 20;
      stan::model::assign(chi,
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 6;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 6;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "chi", chi, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "chi", chi, 1);
      {
        current_statement__ = 23;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(epsilon, 0, sigma));
        current_statement__ = 32;
        for (int i = 1; i <= nind; ++i) {
          current_statement__ = 30;
          if (stan::math::logical_gt(
                stan::model::rvalue(first, "first",
                  stan::model::index_uni(i)), 0)) {
            current_statement__ = 27;
            for (int t = (stan::model::rvalue(first, "first",
                            stan::model::index_uni(i)) + 1);
                 t <= stan::model::rvalue(last, "last",
                        stan::model::index_uni(i));
                 ++t) {
              current_statement__ = 24;
              lp_accum__.add(
                stan::math::bernoulli_lpmf<propto__>(1,
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(i),
                      stan::model::index_uni((t - 1)))));
              current_statement__ = 25;
              lp_accum__.add(
                stan::math::bernoulli_lpmf<propto__>(
                  stan::model::rvalue(y, "y",
                    stan::model::index_uni(i), stan::model::index_uni(t)),
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(i),
                      stan::model::index_uni((t - 1)))));
            }
            current_statement__ = 28;
            lp_accum__.add(
              stan::math::bernoulli_lpmf<propto__>(1,
                stan::model::rvalue(chi, "chi",
                  stan::model::index_uni(i),
                    stan::model::index_uni(stan::model::rvalue(last, "last",
                                             stan::model::index_uni(i))))));
          } 
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail5_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double mean_phi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 1, lp__);
      double mean_p = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, 
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<double, -1, 1> epsilon =
         Eigen::Matrix<double, -1, 1>::Constant(nind,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  nind);
      double sigma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      sigma = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 5, lp__);
      Eigen::Matrix<double, -1, -1> phi =
         Eigen::Matrix<double, -1, -1>::Constant(nind, n_occ_minus_1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> p =
         Eigen::Matrix<double, -1, -1>::Constant(nind, n_occ_minus_1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> chi =
         Eigen::Matrix<double, -1, -1>::Constant(nind, n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      double mu = std::numeric_limits<double>::quiet_NaN();
      out__.write(mean_phi);
      out__.write(mean_p);
      out__.write(epsilon);
      out__.write(sigma);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 9;
      mu = stan::math::logit(mean_phi);
      current_statement__ = 19;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 13;
        for (int t = 1;
             t <= (stan::model::rvalue(first, "first",
                     stan::model::index_uni(i)) - 1);
             ++t) {
          current_statement__ = 10;
          stan::model::assign(phi, 0,
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 11;
          stan::model::assign(p, 0,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
        current_statement__ = 17;
        for (int t = stan::model::rvalue(first, "first",
                       stan::model::index_uni(i));
             t <= n_occ_minus_1; ++t) {
          current_statement__ = 14;
          stan::model::assign(phi,
            stan::math::inv_logit(
              (mu +
                stan::model::rvalue(epsilon, "epsilon",
                  stan::model::index_uni(i)))),
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 15;
          stan::model::assign(p, mean_p,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
      }
      current_statement__ = 20;
      stan::model::assign(chi,
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 6;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 6;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "chi", chi, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "chi", chi, 1);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(chi);
        out__.write(mu);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double sigma2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 22;
      sigma2 = stan::math::square(sigma);
      current_statement__ = 21;
      stan::math::check_greater_or_equal(function__, "sigma2", sigma2, 0);
      out__.write(sigma2);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ mean_phi = DUMMY_VAR__;
      mean_phi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p = DUMMY_VAR__;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nind, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        stan::model::assign(epsilon, in__.read<local_scalar_t__>(),
          "assigning variable epsilon", stan::model::index_uni(sym1__));
      }
      out__.write(epsilon);
      local_scalar_t__ sigma = DUMMY_VAR__;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 5, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mean_phi", "mean_p", "epsilon",
      "sigma", "phi", "p", "chi", "mu", "sigma2"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(nind)},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occasions)},
      std::vector<size_t>{}, std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      param_names__.emplace_back(std::string() + "mu");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      param_names__.emplace_back(std::string() + "mu");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nind) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nind) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((1 + 1) + nind) + 1);
      const size_t num_transformed = ((((nind *
                                                                    n_occ_minus_1)
                                                                   +
                                                                   (nind *
                                                                    n_occ_minus_1))
                                                                  +
                                                                  (nind *
                                                                    n_occasions))
                                                                 + 1);
      const size_t num_gen_quantities = 1;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((1 + 1) + nind) + 1);
      const size_t num_transformed = ((((nind *
                                                                    n_occ_minus_1)
                                                                   +
                                                                   (nind *
                                                                    n_occ_minus_1))
                                                                  +
                                                                  (nind *
                                                                    n_occasions))
                                                                 + 1);
      const size_t num_gen_quantities = 1;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 4> names__{"mean_phi", "mean_p",
      "epsilon", "sigma"};
      const std::array<Eigen::Index, 4> constrain_param_sizes__{1, 1, 
       nind, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } 
using stan_model = expr_prop_fail5_model_namespace::expr_prop_fail5_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail5_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 expr-prop-fail6.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail6_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 158> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail6.stan', line 160, column 2 to column 34)",
 " (in 'expr-prop-fail6.stan', line 161, column 2 to column 32)",
 " (in 'expr-prop-fail6.stan', line 162, column 2 to column 29)",
 " (in 'expr-prop-fail6.stan', line 163, column 2 to column 36)",
 " (in 'expr-prop-fail6.stan', line 164, column 2 to column 20)",
 " (in 'expr-prop-fail6.stan', line 165, column 2 to column 31)",
 " (in 'expr-prop-fail6.stan', line 170, column 2 to column 51)",
 " (in 'expr-prop-fail6.stan', line 171, column 2 to column 45)",
 " (in 'expr-prop-fail6.stan', line 172, column 2 to column 25)",
 " (in 'expr-prop-fail6.stan', line 173, column 2 to column 43)",
 " (in 'expr-prop-fail6.stan', line 174, column 2 to column 47)",
 " (in 'expr-prop-fail6.stan', line 177, column 2 to column 49)",
 " (in 'expr-prop-fail6.stan', line 179, column 4 to column 51)",
 " (in 'expr-prop-fail6.stan', line 178, column 2 to line 179, column 51)",
 " (in 'expr-prop-fail6.stan', line 183, column 2 to column 23)",
 " (in 'expr-prop-fail6.stan', line 187, column 4 to column 22)",
 " (in 'expr-prop-fail6.stan', line 189, column 4 to column 17)",
 " (in 'expr-prop-fail6.stan', line 191, column 6 to column 35)",
 " (in 'expr-prop-fail6.stan', line 192, column 6 to column 27)",
 " (in 'expr-prop-fail6.stan', line 190, column 37 to line 193, column 5)",
 " (in 'expr-prop-fail6.stan', line 190, column 4 to line 193, column 5)",
 " (in 'expr-prop-fail6.stan', line 194, column 4 to column 26)",
 " (in 'expr-prop-fail6.stan', line 186, column 2 to line 195, column 3)",
 " (in 'expr-prop-fail6.stan', line 198, column 2 to column 32)",
 " (in 'expr-prop-fail6.stan', line 212, column 2 to column 23)",
 " (in 'expr-prop-fail6.stan', line 213, column 2 to column 22)",
 " (in 'expr-prop-fail6.stan', line 214, column 2 to column 36)",
 " (in 'expr-prop-fail6.stan', line 215, column 2 to column 36)",
 " (in 'expr-prop-fail6.stan', line 216, column 2 to column 48)",
 " (in 'expr-prop-fail6.stan', line 218, column 2 to column 25)",
 " (in 'expr-prop-fail6.stan', line 222, column 4 to column 14)",
 " (in 'expr-prop-fail6.stan', line 232, column 6 to column 44)",
 " (in 'expr-prop-fail6.stan', line 230, column 11 to line 233, column 5)",
 " (in 'expr-prop-fail6.stan', line 225, column 6 to column 37)",
 " (in 'expr-prop-fail6.stan', line 227, column 8 to column 34)",
 " (in 'expr-prop-fail6.stan', line 228, column 8 to column 73)",
 " (in 'expr-prop-fail6.stan', line 226, column 33 to line 229, column 7)",
 " (in 'expr-prop-fail6.stan', line 226, column 6 to line 229, column 7)",
 " (in 'expr-prop-fail6.stan', line 223, column 28 to line 230, column 5)",
 " (in 'expr-prop-fail6.stan', line 223, column 4 to line 233, column 5)",
 " (in 'expr-prop-fail6.stan', line 221, column 19 to line 234, column 3)",
 " (in 'expr-prop-fail6.stan', line 221, column 2 to line 234, column 3)",
 " (in 'expr-prop-fail6.stan', line 238, column 10 to column 11)",
 " (in 'expr-prop-fail6.stan', line 238, column 13 to column 24)",
 " (in 'expr-prop-fail6.stan', line 238, column 4 to column 69)",
 " (in 'expr-prop-fail6.stan', line 239, column 10 to column 11)",
 " (in 'expr-prop-fail6.stan', line 239, column 4 to column 22)",
 " (in 'expr-prop-fail6.stan', line 240, column 10 to column 11)",
 " (in 'expr-prop-fail6.stan', line 240, column 4 to column 24)",
 " (in 'expr-prop-fail6.stan', line 243, column 6 to column 39)",
 " (in 'expr-prop-fail6.stan', line 246, column 8 to column 26)",
 " (in 'expr-prop-fail6.stan', line 245, column 6 to line 246, column 26)",
 " (in 'expr-prop-fail6.stan', line 242, column 21 to line 247, column 5)",
 " (in 'expr-prop-fail6.stan', line 242, column 4 to line 247, column 5)",
 " (in 'expr-prop-fail6.stan', line 249, column 6 to column 28)",
 " (in 'expr-prop-fail6.stan', line 250, column 6 to column 34)",
 " (in 'expr-prop-fail6.stan', line 248, column 31 to line 251, column 5)",
 " (in 'expr-prop-fail6.stan', line 248, column 4 to line 251, column 5)",
 " (in 'expr-prop-fail6.stan', line 253, column 6 to column 26)",
 " (in 'expr-prop-fail6.stan', line 254, column 6 to column 32)",
 " (in 'expr-prop-fail6.stan', line 252, column 21 to line 255, column 5)",
 " (in 'expr-prop-fail6.stan', line 252, column 4 to line 255, column 5)",
 " (in 'expr-prop-fail6.stan', line 256, column 4 to column 25)",
 " (in 'expr-prop-fail6.stan', line 237, column 2 to line 257, column 3)",
 " (in 'expr-prop-fail6.stan', line 205, column 2 to column 29)",
 " (in 'expr-prop-fail6.stan', line 206, column 2 to column 21)",
 " (in 'expr-prop-fail6.stan', line 209, column 2 to column 52)",
 " (in 'expr-prop-fail6.stan', line 146, column 2 to column 17)",
 " (in 'expr-prop-fail6.stan', line 147, column 2 to column 27)",
 " (in 'expr-prop-fail6.stan', line 148, column 8 to column 9)",
 " (in 'expr-prop-fail6.stan', line 148, column 11 to column 22)",
 " (in 'expr-prop-fail6.stan', line 148, column 2 to column 48)",
 " (in 'expr-prop-fail6.stan', line 151, column 8 to column 9)",
 " (in 'expr-prop-fail6.stan', line 151, column 2 to column 49)",
 " (in 'expr-prop-fail6.stan', line 152, column 8 to column 9)",
 " (in 'expr-prop-fail6.stan', line 152, column 2 to column 48)",
 " (in 'expr-prop-fail6.stan', line 155, column 4 to column 35)",
 " (in 'expr-prop-fail6.stan', line 154, column 2 to line 155, column 35)",
 " (in 'expr-prop-fail6.stan', line 157, column 4 to column 33)",
 " (in 'expr-prop-fail6.stan', line 156, column 2 to line 157, column 33)",
 " (in 'expr-prop-fail6.stan', line 163, column 18 to column 29)",
 " (in 'expr-prop-fail6.stan', line 164, column 9 to column 10)",
 " (in 'expr-prop-fail6.stan', line 170, column 27 to column 28)",
 " (in 'expr-prop-fail6.stan', line 170, column 30 to column 45)",
 " (in 'expr-prop-fail6.stan', line 171, column 27 to column 28)",
 " (in 'expr-prop-fail6.stan', line 171, column 30 to column 41)",
 " (in 'expr-prop-fail6.stan', line 172, column 10 to column 21)",
 " (in 'expr-prop-fail6.stan', line 173, column 27 to column 38)",
 " (in 'expr-prop-fail6.stan', line 174, column 27 to column 28)",
 " (in 'expr-prop-fail6.stan', line 174, column 30 to column 41)",
 " (in 'expr-prop-fail6.stan', line 214, column 8 to column 19)",
 " (in 'expr-prop-fail6.stan', line 215, column 8 to column 19)",
 " (in 'expr-prop-fail6.stan', line 216, column 8 to column 9)",
 " (in 'expr-prop-fail6.stan', line 216, column 11 to column 22)",
 " (in 'expr-prop-fail6.stan', line 17, column 8 to column 17)",
 " (in 'expr-prop-fail6.stan', line 16, column 6 to line 17, column 17)",
 " (in 'expr-prop-fail6.stan', line 15, column 4 to line 17, column 17)",
 " (in 'expr-prop-fail6.stan', line 18, column 4 to column 13)",
 " (in 'expr-prop-fail6.stan', line 14, column 37 to line 19, column 3)",
 " (in 'expr-prop-fail6.stan', line 30, column 6 to column 32)",
 " (in 'expr-prop-fail6.stan', line 33, column 8 to column 17)",
 " (in 'expr-prop-fail6.stan', line 32, column 6 to line 33, column 17)",
 " (in 'expr-prop-fail6.stan', line 29, column 39 to line 34, column 5)",
 " (in 'expr-prop-fail6.stan', line 29, column 4 to line 34, column 5)",
 " (in 'expr-prop-fail6.stan', line 35, column 4 to column 13)",
 " (in 'expr-prop-fail6.stan', line 28, column 36 to line 36, column 3)",
 " (in 'expr-prop-fail6.stan', line 49, column 4 to column 24)",
 " (in 'expr-prop-fail6.stan', line 50, column 4 to column 30)",
 " (in 'expr-prop-fail6.stan', line 51, column 11 to column 16)",
 " (in 'expr-prop-fail6.stan', line 51, column 18 to column 29)",
 " (in 'expr-prop-fail6.stan', line 51, column 4 to column 35)",
 " (in 'expr-prop-fail6.stan', line 54, column 6 to column 32)",
 " (in 'expr-prop-fail6.stan', line 56, column 8 to column 37)",
 " (in 'expr-prop-fail6.stan', line 57, column 8 to column 32)",
 " (in 'expr-prop-fail6.stan', line 59, column 8 to line 61, column 44)",
 " (in 'expr-prop-fail6.stan', line 55, column 39 to line 62, column 7)",
 " (in 'expr-prop-fail6.stan', line 55, column 6 to line 62, column 7)",
 " (in 'expr-prop-fail6.stan', line 53, column 25 to line 63, column 5)",
 " (in 'expr-prop-fail6.stan', line 53, column 4 to line 63, column 5)",
 " (in 'expr-prop-fail6.stan', line 64, column 4 to column 15)",
 " (in 'expr-prop-fail6.stan', line 48, column 47 to line 65, column 3)",
 " (in 'expr-prop-fail6.stan', line 82, column 4 to column 27)",
 " (in 'expr-prop-fail6.stan', line 83, column 4 to column 33)",
 " (in 'expr-prop-fail6.stan', line 84, column 11 to column 22)",
 " (in 'expr-prop-fail6.stan', line 84, column 4 to column 39)",
 " (in 'expr-prop-fail6.stan', line 87, column 13 to column 24)",
 " (in 'expr-prop-fail6.stan', line 87, column 6 to column 43)",
 " (in 'expr-prop-fail6.stan', line 127, column 15 to column 30)",
 " (in 'expr-prop-fail6.stan', line 127, column 8 to column 35)",
 " (in 'expr-prop-fail6.stan', line 130, column 8 to line 131, column 78)",
 " (in 'expr-prop-fail6.stan', line 134, column 10 to line 137, column 50)",
 " (in 'expr-prop-fail6.stan', line 133, column 8 to line 137, column 50)",
 " (in 'expr-prop-fail6.stan', line 139, column 8 to column 54)",
 " (in 'expr-prop-fail6.stan', line 140, column 8 to column 34)",
 " (in 'expr-prop-fail6.stan', line 125, column 13 to line 141, column 7)",
 " (in 'expr-prop-fail6.stan', line 92, column 8 to column 27)",
 " (in 'expr-prop-fail6.stan', line 99, column 17 to column 25)",
 " (in 'expr-prop-fail6.stan', line 99, column 10 to column 30)",
 " (in 'expr-prop-fail6.stan', line 102, column 10 to line 105, column 55)",
 " (in 'expr-prop-fail6.stan', line 108, column 12 to line 112, column 57)",
 " (in 'expr-prop-fail6.stan', line 107, column 10 to line 112, column 57)",
 " (in 'expr-prop-fail6.stan', line 113, column 10 to line 115, column 62)",
 " (in 'expr-prop-fail6.stan', line 116, column 10 to column 36)",
 " (in 'expr-prop-fail6.stan', line 97, column 15 to line 117, column 9)",
 " (in 'expr-prop-fail6.stan', line 96, column 10 to column 41)",
 " (in 'expr-prop-fail6.stan', line 95, column 27 to line 97, column 9)",
 " (in 'expr-prop-fail6.stan', line 95, column 8 to line 117, column 9)",
 " (in 'expr-prop-fail6.stan', line 120, column 10 to column 39)",
 " (in 'expr-prop-fail6.stan', line 121, column 10 to column 39)",
 " (in 'expr-prop-fail6.stan', line 119, column 44 to line 122, column 9)",
 " (in 'expr-prop-fail6.stan', line 119, column 8 to line 122, column 9)",
 " (in 'expr-prop-fail6.stan', line 124, column 8 to column 39)",
 " (in 'expr-prop-fail6.stan', line 89, column 20 to line 125, column 7)",
 " (in 'expr-prop-fail6.stan', line 89, column 6 to line 141, column 7)",
 " (in 'expr-prop-fail6.stan', line 86, column 25 to line 142, column 5)",
 " (in 'expr-prop-fail6.stan', line 86, column 4 to line 142, column 5)",
 " (in 'expr-prop-fail6.stan', line 81, column 74 to line 143, column 3)"};

struct first_capture_functor__ {
  int
  operator()(const std::vector<int>& y_i, std::ostream* pstream__) const;
};
struct prob_uncaptured_functor__ {
  template <typename T0__, typename T1__,
            stan::require_eigen_matrix_dynamic_t<T0__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T1__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>>, -1, -1>
  operator()(const T0__& p, const T1__& phi, std::ostream* pstream__) const;
};
struct last_capture_functor__ {
  int
  operator()(const std::vector<int>& y_i, std::ostream* pstream__) const;
};
struct js_super_lp_functor__ {
  template <bool propto__, typename T3__, typename T4__, typename T5__,
            typename T6__, typename T7__, typename T_lp__,
            typename T_lp_accum__,
            stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T4__>* = nullptr,
            stan::require_stan_scalar_t<T5__>* = nullptr,
            stan::require_col_vector_t<T6__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T7__>* = nullptr>
  void
  operator()(const std::vector<std::vector<int>>& y,
             const std::vector<int>& first, const std::vector<int>& last,
             const T3__& p, const T4__& phi, const T5__& psi, const T6__& nu,
             const T7__& chi, T_lp__& lp__, T_lp_accum__& lp_accum__,
             std::ostream* pstream__) const;
};

int first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 97;
      for (int k = 1; k <= stan::math::size(y_i); ++k) {
        current_statement__ = 96;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
          current_statement__ = 95;
          return k;
        } 
      }
      current_statement__ = 98;
      return 0;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 104;
      for (int k_rev = 0; k_rev <= (stan::math::size(y_i) - 1); ++k_rev) {
        int k = std::numeric_limits<int>::min();
        current_statement__ = 100;
        k = (stan::math::size(y_i) - k_rev);
        current_statement__ = 102;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
          current_statement__ = 101;
          return k;
        } 
      }
      current_statement__ = 105;
      return 0;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, typename T1__,
          stan::require_eigen_matrix_dynamic_t<T0__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T1__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>>, -1, -1>
  prob_uncaptured(const T0__& p_arg__, const T1__& phi_arg__,
                  std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<stan::value_type_t<T0__>,
                                 stan::value_type_t<T1__>>;
    int current_statement__ = 0; 
    const auto& p = stan::math::to_ref(p_arg__);
    const auto& phi = stan::math::to_ref(phi_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int n_ind = std::numeric_limits<int>::min();
      current_statement__ = 107;
      n_ind = stan::math::rows(p);
      int n_occasions = std::numeric_limits<int>::min();
      current_statement__ = 108;
      n_occasions = stan::math::cols(p);
      current_statement__ = 109;
      stan::math::validate_non_negative_index("chi", "n_ind", n_ind);
      current_statement__ = 110;
      stan::math::validate_non_negative_index("chi", "n_occasions",
                                              n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(n_ind,
           n_occasions, DUMMY_VAR__);
      current_statement__ = 119;
      for (int i = 1; i <= n_ind; ++i) {
        current_statement__ = 112;
        stan::model::assign(chi, 1.0,
          "assigning variable chi", stan::model::index_uni(i),
                                      stan::model::index_uni(n_occasions));
        current_statement__ = 117;
        for (int t = 1; t <= (n_occasions - 1); ++t) {
          int t_curr = std::numeric_limits<int>::min();
          current_statement__ = 113;
          t_curr = (n_occasions - t);
          int t_next = std::numeric_limits<int>::min();
          current_statement__ = 114;
          t_next = (t_curr + 1);
          current_statement__ = 115;
          stan::model::assign(chi,
            ((1 -
               stan::model::rvalue(phi, "phi",
                 stan::model::index_uni(i), stan::model::index_uni(t_curr)))
              +
              ((stan::model::rvalue(phi, "phi",
                  stan::model::index_uni(i), stan::model::index_uni(t_curr))
                 *
                 (1 -
                   stan::model::rvalue(p, "p",
                     stan::model::index_uni(i),
                       stan::model::index_uni(t_next)))) *
                stan::model::rvalue(chi, "chi",
                  stan::model::index_uni(i), stan::model::index_uni(t_next)))),
            "assigning variable chi", stan::model::index_uni(i),
                                        stan::model::index_uni(t_curr));
        }
      }
      current_statement__ = 120;
      return chi;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <bool propto__, typename T3__, typename T4__, typename T5__,
          typename T6__, typename T7__, typename T_lp__,
          typename T_lp_accum__,
          stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T4__>* = nullptr,
          stan::require_stan_scalar_t<T5__>* = nullptr,
          stan::require_col_vector_t<T6__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T7__>* = nullptr> void
  js_super_lp(const std::vector<std::vector<int>>& y,
              const std::vector<int>& first, const std::vector<int>& last,
              const T3__& p_arg__, const T4__& phi_arg__, const T5__& psi,
              const T6__& nu_arg__, const T7__& chi_arg__, T_lp__& lp__,
              T_lp_accum__& lp_accum__, std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<stan::value_type_t<T3__>,
                                 stan::value_type_t<T4__>, T5__,
                                 stan::value_type_t<T6__>,
                                 stan::value_type_t<T7__>>;
    int current_statement__ = 0; 
    const auto& p = stan::math::to_ref(p_arg__);
    const auto& phi = stan::math::to_ref(phi_arg__);
    const auto& nu = stan::math::to_ref(nu_arg__);
    const auto& chi = stan::math::to_ref(chi_arg__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int n_ind = std::numeric_limits<int>::min();
      current_statement__ = 122;
      n_ind = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                stan::model::index_uni(1));
      int n_occasions = std::numeric_limits<int>::min();
      current_statement__ = 123;
      n_occasions = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                      stan::model::index_uni(2));
      current_statement__ = 124;
      stan::math::validate_non_negative_index("qnu", "n_occasions",
                                              n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> qnu =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_occasions,
           DUMMY_VAR__);
      current_statement__ = 125;
      stan::model::assign(qnu, stan::math::subtract(1.0, nu),
        "assigning variable qnu");
      current_statement__ = 156;
      for (int i = 1; i <= n_ind; ++i) {
        current_statement__ = 126;
        stan::math::validate_non_negative_index("qp", "n_occasions",
                                                n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, 1> qp =
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_occasions,
             DUMMY_VAR__);
        current_statement__ = 127;
        stan::model::assign(qp,
          stan::math::subtract(1.0,
            stan::math::transpose(
              stan::model::rvalue(p, "p", stan::model::index_uni(i)))),
          "assigning variable qp");
        current_statement__ = 154;
        if (stan::model::rvalue(first, "first", stan::model::index_uni(i))) {
          current_statement__ = 136;
          lp_accum__.add(stan::math::bernoulli_lpmf<propto__>(1, psi));
          current_statement__ = 147;
          if (stan::math::logical_eq(
                stan::model::rvalue(first, "first",
                  stan::model::index_uni(i)), 1)) {
            current_statement__ = 145;
            lp_accum__.add(
              stan::math::bernoulli_lpmf<propto__>(1,
                (stan::model::rvalue(nu, "nu", stan::model::index_uni(1)) *
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(i), stan::model::index_uni(1)))));
          } else {
            current_statement__ = 137;
            stan::math::validate_non_negative_index("lp", "first[i]",
                                                    stan::model::rvalue(
                                                      first, "first",
                                                      stan::model::index_uni(i)));
            Eigen::Matrix<local_scalar_t__, -1, 1> lp =
               Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(
                 stan::model::rvalue(first, "first",
                   stan::model::index_uni(i)), DUMMY_VAR__);
            current_statement__ = 139;
            stan::model::assign(lp,
              (((stan::math::bernoulli_lpmf<false>(1,
                   stan::model::rvalue(nu, "nu", stan::model::index_uni(1)))
                  +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(qp, "qp",
                        stan::model::index_min_max(1, (stan::model::rvalue(
                                                         first, "first",
                                                         stan::model::index_uni(i))
                                                        - 1)))))) +
                 stan::math::bernoulli_lpmf<false>(1,
                   stan::math::prod(
                     stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(i),
                         stan::model::index_min_max(1, (stan::model::rvalue(
                                                          first, "first",
                                                          stan::model::index_uni(i))
                                                         - 1)))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(i),
                      stan::model::index_uni(stan::model::rvalue(first,
                                               "first",
                                               stan::model::index_uni(i)))))),
              "assigning variable lp", stan::model::index_uni(1));
            current_statement__ = 141;
            for (int t = 2;
                 t <= (stan::model::rvalue(first, "first",
                         stan::model::index_uni(i)) - 1);
                 ++t) {
              current_statement__ = 140;
              stan::model::assign(lp,
                ((((stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(qnu, "qnu",
                          stan::model::index_min_max(1, (t - 1))))) +
                     stan::math::bernoulli_lpmf<false>(1,
                       stan::model::rvalue(nu, "nu",
                         stan::model::index_uni(t)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(qp, "qp",
                          stan::model::index_min_max(t, (stan::model::rvalue(
                                                           first, "first",
                                                           stan::model::index_uni(i))
                                                          - 1)))))) +
                   stan::math::bernoulli_lpmf<false>(1,
                     stan::math::prod(
                       stan::model::rvalue(phi, "phi",
                         stan::model::index_uni(i),
                           stan::model::index_min_max(t, (stan::model::rvalue(
                                                            first, "first",
                                                            stan::model::index_uni(i))
                                                           - 1)))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(i),
                        stan::model::index_uni(stan::model::rvalue(first,
                                                 "first",
                                                 stan::model::index_uni(i)))))),
                "assigning variable lp", stan::model::index_uni(t));
            }
            current_statement__ = 142;
            stan::model::assign(lp,
              ((stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(qnu, "qnu",
                      stan::model::index_min_max(1, (stan::model::rvalue(
                                                       first, "first",
                                                       stan::model::index_uni(i))
                                                      - 1))))) +
                 stan::math::bernoulli_lpmf<false>(1,
                   stan::model::rvalue(nu, "nu",
                     stan::model::index_uni(stan::model::rvalue(first,
                                              "first",
                                              stan::model::index_uni(i))))))
                +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(i),
                      stan::model::index_uni(stan::model::rvalue(first,
                                               "first",
                                               stan::model::index_uni(i)))))),
              "assigning variable lp", stan::model::index_uni(stan::model::rvalue(
                                                                first,
                                                                "first",
                                                                stan::model::index_uni(i))));
            current_statement__ = 143;
            lp_accum__.add(stan::math::log_sum_exp(lp));
          }
          current_statement__ = 151;
          for (int t = (stan::model::rvalue(first, "first",
                          stan::model::index_uni(i)) + 1);
               t <= stan::model::rvalue(last, "last",
                      stan::model::index_uni(i));
               ++t) {
            current_statement__ = 148;
            lp_accum__.add(
              stan::math::bernoulli_lpmf<propto__>(1,
                stan::model::rvalue(phi, "phi",
                  stan::model::index_uni(i), stan::model::index_uni((t - 1)))));
            current_statement__ = 149;
            lp_accum__.add(
              stan::math::bernoulli_lpmf<propto__>(
                stan::model::rvalue(y, "y",
                  stan::model::index_uni(i), stan::model::index_uni(t)),
                stan::model::rvalue(p, "p",
                  stan::model::index_uni(i), stan::model::index_uni(t))));
          }
          current_statement__ = 152;
          lp_accum__.add(
            stan::math::bernoulli_lpmf<propto__>(1,
              stan::model::rvalue(chi, "chi",
                stan::model::index_uni(i),
                  stan::model::index_uni(stan::model::rvalue(last, "last",
                                           stan::model::index_uni(i))))));
        } else {
          current_statement__ = 128;
          stan::math::validate_non_negative_index("lp", "n_occasions + 1",
                                                  (n_occasions + 1));
          Eigen::Matrix<local_scalar_t__, -1, 1> lp =
             Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(
               (n_occasions + 1), DUMMY_VAR__);
          current_statement__ = 130;
          stan::model::assign(lp,
            (((stan::math::bernoulli_lpmf<false>(1, psi) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(nu, "nu", stan::model::index_uni(1))))
               +
               stan::math::bernoulli_lpmf<false>(0,
                 stan::model::rvalue(p, "p",
                   stan::model::index_uni(i), stan::model::index_uni(1)))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(chi, "chi",
                  stan::model::index_uni(i), stan::model::index_uni(1)))),
            "assigning variable lp", stan::model::index_uni(1));
          current_statement__ = 132;
          for (int t = 2; t <= n_occasions; ++t) {
            current_statement__ = 131;
            stan::model::assign(lp,
              ((((stan::math::bernoulli_lpmf<false>(1, psi) +
                   stan::math::bernoulli_lpmf<false>(1,
                     stan::math::prod(
                       stan::model::rvalue(qnu, "qnu",
                         stan::model::index_min_max(1, (t - 1)))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(nu, "nu", stan::model::index_uni(t))))
                 +
                 stan::math::bernoulli_lpmf<false>(0,
                   stan::model::rvalue(p, "p",
                     stan::model::index_uni(i), stan::model::index_uni(t))))
                +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(chi, "chi",
                    stan::model::index_uni(i), stan::model::index_uni(t)))),
              "assigning variable lp", stan::model::index_uni(t));
          }
          current_statement__ = 133;
          stan::model::assign(lp, stan::math::bernoulli_lpmf<false>(0, psi),
            "assigning variable lp", stan::model::index_uni((n_occasions + 1)));
          current_statement__ = 134;
          lp_accum__.add(stan::math::log_sum_exp(lp));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int
first_capture_functor__::operator()(const std::vector<int>& y_i,
                                    std::ostream* pstream__)  const
{
  return first_capture(y_i, pstream__);
}

template <typename T0__, typename T1__,
          stan::require_eigen_matrix_dynamic_t<T0__>*,
          stan::require_eigen_matrix_dynamic_t<T1__>*>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>>, -1, -1>
prob_uncaptured_functor__::operator()(const T0__& p, const T1__& phi,
                                      std::ostream* pstream__)  const
{
  return prob_uncaptured(p, phi, pstream__);
}

int
last_capture_functor__::operator()(const std::vector<int>& y_i,
                                   std::ostream* pstream__)  const
{
  return last_capture(y_i, pstream__);
}

template <bool propto__, typename T3__, typename T4__, typename T5__,
          typename T6__, typename T7__, typename T_lp__,
          typename T_lp_accum__, stan::require_eigen_matrix_dynamic_t<T3__>*,
          stan::require_eigen_matrix_dynamic_t<T4__>*,
          stan::require_stan_scalar_t<T5__>*,
          stan::require_col_vector_t<T6__>*,
          stan::require_eigen_matrix_dynamic_t<T7__>*>
void
js_super_lp_functor__::operator()(const std::vector<std::vector<int>>& y,
                                  const std::vector<int>& first,
                                  const std::vector<int>& last,
                                  const T3__& p, const T4__& phi,
                                  const T5__& psi, const T6__& nu,
                                  const T7__& chi, T_lp__& lp__,
                                  T_lp_accum__& lp_accum__,
                                  std::ostream* pstream__)  const
{
  return js_super_lp<propto__>(y, first, last, p, phi, psi, nu, chi, lp__,
           lp_accum__, pstream__);
}


class expr_prop_fail6_model final : public model_base_crtp<expr_prop_fail6_model> {

 private:
  int M;
  int n_occasions;
  std::vector<std::vector<int>> y;
  std::vector<int> first;
  std::vector<int> last;
  int phi_2dim__; 
  
 
 public:
  ~expr_prop_fail6_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail6_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  expr_prop_fail6_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail6_model_namespace::expr_prop_fail6_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 68;
      context__.validate_dims("data initialization","M","int",
           std::vector<size_t>{});
      M = std::numeric_limits<int>::min();
      
      
      current_statement__ = 68;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 68;
      stan::math::check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 69;
      context__.validate_dims("data initialization","n_occasions","int",
           std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      
      
      current_statement__ = 69;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 69;
      stan::math::check_greater_or_equal(function__, "n_occasions",
                                            n_occasions, 0);
      current_statement__ = 70;
      stan::math::validate_non_negative_index("y", "M", M);
      current_statement__ = 71;
      stan::math::validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 72;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(M),
            static_cast<size_t>(n_occasions)});
      y = 
        std::vector<std::vector<int>>(M, 
          std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 72;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 72;
        pos__ = 1;
        current_statement__ = 72;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 72;
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            current_statement__ = 72;
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
            current_statement__ = 72;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 72;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 72;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 73;
      stan::math::validate_non_negative_index("first", "M", M);
      current_statement__ = 74;
      first = std::vector<int>(M, std::numeric_limits<int>::min());
      
      
      current_statement__ = 75;
      stan::math::validate_non_negative_index("last", "M", M);
      current_statement__ = 76;
      last = std::vector<int>(M, std::numeric_limits<int>::min());
      
      
      current_statement__ = 78;
      for (int i = 1; i <= M; ++i) {
        current_statement__ = 77;
        stan::model::assign(first,
          first_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(i)), pstream__),
          "assigning variable first", stan::model::index_uni(i));
      }
      current_statement__ = 80;
      for (int i = 1; i <= M; ++i) {
        current_statement__ = 79;
        stan::model::assign(last,
          last_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(i)), pstream__),
          "assigning variable last", stan::model::index_uni(i));
      }
      current_statement__ = 74;
      stan::math::check_greater_or_equal(function__, "first", first, 0);
      current_statement__ = 74;
      stan::math::check_less_or_equal(function__, "first", first, n_occasions);
      current_statement__ = 76;
      stan::math::check_greater_or_equal(function__, "last", last, 0);
      current_statement__ = 76;
      stan::math::check_less_or_equal(function__, "last", last, n_occasions);
      current_statement__ = 81;
      stan::math::validate_non_negative_index("beta", "n_occasions",
                                              n_occasions);
      current_statement__ = 82;
      stan::math::validate_non_negative_index("epsilon", "M", M);
      current_statement__ = 83;
      stan::math::validate_non_negative_index("phi", "M", M);
      current_statement__ = 84;
      phi_2dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 84;
      phi_2dim__ = (n_occasions - 1);
      current_statement__ = 84;
      stan::math::validate_non_negative_index("phi", "n_occasions - 1",
                                              phi_2dim__);
      current_statement__ = 85;
      stan::math::validate_non_negative_index("p", "M", M);
      current_statement__ = 86;
      stan::math::validate_non_negative_index("p", "n_occasions", n_occasions);
      current_statement__ = 87;
      stan::math::validate_non_negative_index("b", "n_occasions", n_occasions);
      current_statement__ = 88;
      stan::math::validate_non_negative_index("nu", "n_occasions",
                                              n_occasions);
      current_statement__ = 89;
      stan::math::validate_non_negative_index("chi", "M", M);
      current_statement__ = 90;
      stan::math::validate_non_negative_index("chi", "n_occasions",
                                              n_occasions);
      current_statement__ = 91;
      stan::math::validate_non_negative_index("N", "n_occasions", n_occasions);
      current_statement__ = 92;
      stan::math::validate_non_negative_index("B", "n_occasions", n_occasions);
      current_statement__ = 93;
      stan::math::validate_non_negative_index("z", "M", M);
      current_statement__ = 94;
      stan::math::validate_non_negative_index("z", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + n_occasions + M + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail6_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ mean_phi = DUMMY_VAR__;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ mean_p = DUMMY_VAR__;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, 
                 jacobian__>(0, 1, lp__);
      local_scalar_t__ psi = DUMMY_VAR__;
      current_statement__ = 3;
      psi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(0,
              1, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_occasions,
           DUMMY_VAR__);
      current_statement__ = 4;
      beta = in__.template read_constrain_lb<
               Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(0, lp__,
               n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 5;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(M);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 6;
      sigma = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 5, lp__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(M, phi_2dim__,
           DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(M, n_occasions,
           DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, 1> b =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_occasions,
           DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, 1> nu =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_occasions,
           DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(M, n_occasions,
           DUMMY_VAR__);
      current_statement__ = 12;
      stan::model::assign(phi,
        stan::math::rep_matrix(mean_phi, M, (n_occasions - 1)),
        "assigning variable phi");
      current_statement__ = 14;
      for (int t = 1; t <= n_occasions; ++t) {
        current_statement__ = 13;
        stan::model::assign(p,
          stan::math::inv_logit(
            stan::math::add(stan::math::logit(mean_p), epsilon)),
          "assigning variable p", stan::model::index_omni(),
                                    stan::model::index_uni(t));
      }
      current_statement__ = 15;
      stan::model::assign(b, stan::math::divide(beta, stan::math::sum(beta)),
        "assigning variable b");
      {
        local_scalar_t__ cum_b = DUMMY_VAR__;
        current_statement__ = 16;
        cum_b = stan::model::rvalue(b, "b", stan::model::index_uni(1));
        current_statement__ = 17;
        stan::model::assign(nu,
          stan::model::rvalue(b, "b", stan::model::index_uni(1)),
          "assigning variable nu", stan::model::index_uni(1));
        current_statement__ = 21;
        for (int t = 2; t <= (n_occasions - 1); ++t) {
          current_statement__ = 18;
          stan::model::assign(nu,
            (stan::model::rvalue(b, "b", stan::model::index_uni(t)) /
              (1.0 - cum_b)),
            "assigning variable nu", stan::model::index_uni(t));
          current_statement__ = 19;
          cum_b = (cum_b +
                    stan::model::rvalue(b, "b", stan::model::index_uni(t)));
        }
        current_statement__ = 22;
        stan::model::assign(nu, 1.0,
          "assigning variable nu", stan::model::index_uni(n_occasions));
      }
      current_statement__ = 24;
      stan::model::assign(chi, prob_uncaptured(p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 8;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 9;
      stan::math::check_simplex(function__, "b", b);
      current_statement__ = 10;
      stan::math::check_greater_or_equal(function__, "nu", nu, 0);
      current_statement__ = 10;
      stan::math::check_less_or_equal(function__, "nu", nu, 1);
      current_statement__ = 11;
      stan::math::check_greater_or_equal(function__, "chi", chi, 0);
      current_statement__ = 11;
      stan::math::check_less_or_equal(function__, "chi", chi, 1);
      {
        current_statement__ = 65;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(epsilon, 0, sigma));
        current_statement__ = 66;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(beta, 1, 1));
        current_statement__ = 67;
        js_super_lp<propto__>(y, first, last, p, phi, psi, nu,
          chi, lp__, lp_accum__, pstream__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail6_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double mean_phi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 1, lp__);
      double mean_p = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, 
                 jacobian__>(0, 1, lp__);
      double psi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      psi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(0,
              1, lp__);
      Eigen::Matrix<double, -1, 1> beta =
         Eigen::Matrix<double, -1, 1>::Constant(n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 4;
      beta = in__.template read_constrain_lb<
               Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(0, lp__,
               n_occasions);
      Eigen::Matrix<double, -1, 1> epsilon =
         Eigen::Matrix<double, -1, 1>::Constant(M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(M);
      double sigma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 6;
      sigma = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 5, lp__);
      Eigen::Matrix<double, -1, -1> phi =
         Eigen::Matrix<double, -1, -1>::Constant(M, phi_2dim__,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> p =
         Eigen::Matrix<double, -1, -1>::Constant(M, n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> b =
         Eigen::Matrix<double, -1, 1>::Constant(n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> nu =
         Eigen::Matrix<double, -1, 1>::Constant(n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> chi =
         Eigen::Matrix<double, -1, -1>::Constant(M, n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(mean_phi);
      out__.write(mean_p);
      out__.write(psi);
      out__.write(beta);
      out__.write(epsilon);
      out__.write(sigma);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 12;
      stan::model::assign(phi,
        stan::math::rep_matrix(mean_phi, M, (n_occasions - 1)),
        "assigning variable phi");
      current_statement__ = 14;
      for (int t = 1; t <= n_occasions; ++t) {
        current_statement__ = 13;
        stan::model::assign(p,
          stan::math::inv_logit(
            stan::math::add(stan::math::logit(mean_p), epsilon)),
          "assigning variable p", stan::model::index_omni(),
                                    stan::model::index_uni(t));
      }
      current_statement__ = 15;
      stan::model::assign(b, stan::math::divide(beta, stan::math::sum(beta)),
        "assigning variable b");
      {
        double cum_b = std::numeric_limits<double>::quiet_NaN();
        current_statement__ = 16;
        cum_b = stan::model::rvalue(b, "b", stan::model::index_uni(1));
        current_statement__ = 17;
        stan::model::assign(nu,
          stan::model::rvalue(b, "b", stan::model::index_uni(1)),
          "assigning variable nu", stan::model::index_uni(1));
        current_statement__ = 21;
        for (int t = 2; t <= (n_occasions - 1); ++t) {
          current_statement__ = 18;
          stan::model::assign(nu,
            (stan::model::rvalue(b, "b", stan::model::index_uni(t)) /
              (1.0 - cum_b)),
            "assigning variable nu", stan::model::index_uni(t));
          current_statement__ = 19;
          cum_b = (cum_b +
                    stan::model::rvalue(b, "b", stan::model::index_uni(t)));
        }
        current_statement__ = 22;
        stan::model::assign(nu, 1.0,
          "assigning variable nu", stan::model::index_uni(n_occasions));
      }
      current_statement__ = 24;
      stan::model::assign(chi, prob_uncaptured(p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 8;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 9;
      stan::math::check_simplex(function__, "b", b);
      current_statement__ = 10;
      stan::math::check_greater_or_equal(function__, "nu", nu, 0);
      current_statement__ = 10;
      stan::math::check_less_or_equal(function__, "nu", nu, 1);
      current_statement__ = 11;
      stan::math::check_greater_or_equal(function__, "chi", chi, 0);
      current_statement__ = 11;
      stan::math::check_less_or_equal(function__, "chi", chi, 1);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(b);
        out__.write(nu);
        out__.write(chi);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double sigma2 = std::numeric_limits<double>::quiet_NaN();
      int Nsuper = std::numeric_limits<int>::min();
      std::vector<int> N =
         std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      std::vector<int> B =
         std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      std::vector<std::vector<int>> z =
         std::vector<std::vector<int>>(M, 
           std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      current_statement__ = 30;
      sigma2 = stan::math::square(sigma);
      current_statement__ = 42;
      for (int i = 1; i <= M; ++i) {
        int q = std::numeric_limits<int>::min();
        current_statement__ = 31;
        q = 1;
        current_statement__ = 40;
        if (stan::math::bernoulli_rng(psi, base_rng__)) {
          current_statement__ = 34;
          stan::model::assign(z,
            stan::math::bernoulli_rng(
              stan::model::rvalue(nu, "nu", stan::model::index_uni(1)),
              base_rng__),
            "assigning variable z", stan::model::index_uni(i),
                                      stan::model::index_uni(1));
          current_statement__ = 38;
          for (int t = 2; t <= n_occasions; ++t) {
            current_statement__ = 35;
            q = (q *
                  (1 -
                    stan::model::rvalue(z, "z",
                      stan::model::index_uni(i),
                        stan::model::index_uni((t - 1)))));
            current_statement__ = 36;
            stan::model::assign(z,
              stan::math::bernoulli_rng(
                ((stan::model::rvalue(z, "z",
                    stan::model::index_uni(i),
                      stan::model::index_uni((t - 1))) *
                   stan::model::rvalue(phi, "phi",
                     stan::model::index_uni(i),
                       stan::model::index_uni((t - 1)))) +
                  (q *
                    stan::model::rvalue(nu, "nu", stan::model::index_uni(t)))),
                base_rng__),
              "assigning variable z", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          }
        } else {
          current_statement__ = 32;
          stan::model::assign(z, stan::math::rep_array(0, n_occasions),
            "assigning variable z", stan::model::index_uni(i),
                                      stan::model::index_omni());
        }
      }
      {
        current_statement__ = 43;
        stan::math::validate_non_negative_index("recruit", "M", M);
        current_statement__ = 44;
        stan::math::validate_non_negative_index("recruit", "n_occasions",
                                                n_occasions);
        std::vector<std::vector<int>> recruit =
           std::vector<std::vector<int>>(M, 
             std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
        current_statement__ = 45;
        stan::model::assign(recruit,
          stan::math::rep_array(0, M, n_occasions),
          "assigning variable recruit");
        current_statement__ = 46;
        stan::math::validate_non_negative_index("Nind", "M", M);
        std::vector<int> Nind =
           std::vector<int>(M, std::numeric_limits<int>::min());
        current_statement__ = 48;
        stan::math::validate_non_negative_index("Nalive", "M", M);
        std::vector<int> Nalive =
           std::vector<int>(M, std::numeric_limits<int>::min());
        current_statement__ = 54;
        for (int i = 1; i <= M; ++i) {
          int f = std::numeric_limits<int>::min();
          current_statement__ = 50;
          f = first_capture(
                stan::model::rvalue(z, "z",
                  stan::model::index_uni(i), stan::model::index_omni()), pstream__);
          current_statement__ = 52;
          if (stan::math::logical_gt(f, 0)) {
            current_statement__ = 51;
            stan::model::assign(recruit, 1,
              "assigning variable recruit", stan::model::index_uni(i),
                                              stan::model::index_uni(f));
          } 
        }
        current_statement__ = 58;
        for (int t = 1; t <= n_occasions; ++t) {
          current_statement__ = 55;
          stan::model::assign(N,
            stan::math::sum(
              stan::model::rvalue(z, "z",
                stan::model::index_omni(), stan::model::index_uni(t))),
            "assigning variable N", stan::model::index_uni(t));
          current_statement__ = 56;
          stan::model::assign(B,
            stan::math::sum(
              stan::model::rvalue(recruit, "recruit",
                stan::model::index_omni(), stan::model::index_uni(t))),
            "assigning variable B", stan::model::index_uni(t));
        }
        current_statement__ = 62;
        for (int i = 1; i <= M; ++i) {
          current_statement__ = 59;
          stan::model::assign(Nind,
            stan::math::sum(
              stan::model::rvalue(z, "z", stan::model::index_uni(i))),
            "assigning variable Nind", stan::model::index_uni(i));
          current_statement__ = 60;
          stan::model::assign(Nalive,
            stan::math::logical_gt(
              stan::model::rvalue(Nind, "Nind", stan::model::index_uni(i)),
              0), "assigning variable Nalive", stan::model::index_uni(i));
        }
        current_statement__ = 63;
        Nsuper = stan::math::sum(Nalive);
      }
      current_statement__ = 25;
      stan::math::check_greater_or_equal(function__, "sigma2", sigma2, 0);
      current_statement__ = 26;
      stan::math::check_greater_or_equal(function__, "Nsuper", Nsuper, 0);
      current_statement__ = 27;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 28;
      stan::math::check_greater_or_equal(function__, "B", B, 0);
      current_statement__ = 29;
      stan::math::check_greater_or_equal(function__, "z", z, 0);
      current_statement__ = 29;
      stan::math::check_less_or_equal(function__, "z", z, 1);
      out__.write(sigma2);
      out__.write(Nsuper);
      out__.write(N);
      out__.write(B);
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          out__.write(z[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ mean_phi = DUMMY_VAR__;
      mean_phi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p = DUMMY_VAR__;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      local_scalar_t__ psi = DUMMY_VAR__;
      psi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, psi);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_occasions,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        stan::model::assign(beta, in__.read<local_scalar_t__>(),
          "assigning variable beta", stan::model::index_uni(sym1__));
      }
      out__.write_free_lb(0, beta);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        stan::model::assign(epsilon, in__.read<local_scalar_t__>(),
          "assigning variable epsilon", stan::model::index_uni(sym1__));
      }
      out__.write(epsilon);
      local_scalar_t__ sigma = DUMMY_VAR__;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 5, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mean_phi", "mean_p", "psi", "beta",
      "epsilon", "sigma", "phi", "p", "b", "nu", "chi", "sigma2", "Nsuper",
      "N", "B", "z"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(M)}, std::vector<size_t>{
      },
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(phi_2dim__)},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(n_occasions)},
      std::vector<size_t>{}, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(n_occasions)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    param_names__.emplace_back(std::string() + "psi");
    for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= phi_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "nu" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "N" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "B" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    param_names__.emplace_back(std::string() + "psi");
    for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= phi_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= (n_occasions - 1); ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "nu" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "N" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "B" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(phi_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"nu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(phi_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((n_occasions - 1)) + "},\"block\":\"transformed_parameters\"},{\"name\":\"nu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((1 + 1) + 1) + n_occasions) + M) + 1);
      const size_t num_transformed = 
  (((((M * phi_2dim__) + (M * n_occasions)) + n_occasions) + n_occasions) +
    (M * n_occasions));
      const size_t num_gen_quantities = ((((1 + 1) +
                                                                    n_occasions)
                                                                   +
                                                                   n_occasions)
                                                                  +
                                                                  (M *
                                                                    n_occasions));
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((1 + 1) + 1) + n_occasions) + M) + 1);
      const size_t num_transformed = 
  (((((M * phi_2dim__) + (M * n_occasions)) + n_occasions) + n_occasions) +
    (M * n_occasions));
      const size_t num_gen_quantities = ((((1 + 1) +
                                                                    n_occasions)
                                                                   +
                                                                   n_occasions)
                                                                  +
                                                                  (M *
                                                                    n_occasions));
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 6> names__{"mean_phi", "mean_p",
      "psi", "beta", "epsilon", "sigma"};
      const std::array<Eigen::Index, 6> constrain_param_sizes__{1, 1, 
       1, n_occasions, M, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } 
using stan_model = expr_prop_fail6_model_namespace::expr_prop_fail6_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail6_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 expr-prop-fail7.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail7_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 39> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail7.stan', line 20, column 2 to column 16)",
 " (in 'expr-prop-fail7.stan', line 21, column 2 to column 31)",
 " (in 'expr-prop-fail7.stan', line 40, column 2 to column 30)",
 " (in 'expr-prop-fail7.stan', line 42, column 11 to column 12)",
 " (in 'expr-prop-fail7.stan', line 42, column 4 to column 30)",
 " (in 'expr-prop-fail7.stan', line 44, column 6 to column 52)",
 " (in 'expr-prop-fail7.stan', line 43, column 4 to line 44, column 52)",
 " (in 'expr-prop-fail7.stan', line 45, column 4 to column 45)",
 " (in 'expr-prop-fail7.stan', line 41, column 19 to line 46, column 3)",
 " (in 'expr-prop-fail7.stan', line 41, column 2 to line 46, column 3)",
 " (in 'expr-prop-fail7.stan', line 25, column 2 to column 24)",
 " (in 'expr-prop-fail7.stan', line 28, column 6 to column 39)",
 " (in 'expr-prop-fail7.stan', line 27, column 4 to line 28, column 39)",
 " (in 'expr-prop-fail7.stan', line 26, column 2 to line 28, column 39)",
 " (in 'expr-prop-fail7.stan', line 32, column 11 to column 12)",
 " (in 'expr-prop-fail7.stan', line 32, column 4 to column 30)",
 " (in 'expr-prop-fail7.stan', line 34, column 6 to column 54)",
 " (in 'expr-prop-fail7.stan', line 33, column 4 to line 34, column 54)",
 " (in 'expr-prop-fail7.stan', line 35, column 4 to column 33)",
 " (in 'expr-prop-fail7.stan', line 31, column 19 to line 36, column 3)",
 " (in 'expr-prop-fail7.stan', line 31, column 2 to line 36, column 3)",
 " (in 'expr-prop-fail7.stan', line 12, column 2 to column 17)",
 " (in 'expr-prop-fail7.stan', line 13, column 2 to column 17)",
 " (in 'expr-prop-fail7.stan', line 14, column 2 to column 17)",
 " (in 'expr-prop-fail7.stan', line 15, column 8 to column 9)",
 " (in 'expr-prop-fail7.stan', line 15, column 11 to column 12)",
 " (in 'expr-prop-fail7.stan', line 15, column 2 to column 38)",
 " (in 'expr-prop-fail7.stan', line 16, column 18 to column 19)",
 " (in 'expr-prop-fail7.stan', line 16, column 2 to column 27)",
 " (in 'expr-prop-fail7.stan', line 17, column 8 to column 9)",
 " (in 'expr-prop-fail7.stan', line 17, column 27 to column 28)",
 " (in 'expr-prop-fail7.stan', line 17, column 2 to column 35)",
 " (in 'expr-prop-fail7.stan', line 20, column 10 to column 11)",
 " (in 'expr-prop-fail7.stan', line 21, column 8 to column 9)",
 " (in 'expr-prop-fail7.stan', line 21, column 11 to column 12)",
 " (in 'expr-prop-fail7.stan', line 21, column 22 to column 23)",
 " (in 'expr-prop-fail7.stan', line 40, column 8 to column 9)",
 " (in 'expr-prop-fail7.stan', line 40, column 18 to column 19)"};




class expr_prop_fail7_model final : public model_base_crtp<expr_prop_fail7_model> {

 private:
  int K;
  int I;
  int J;
  std::vector<std::vector<int>> y;
  Eigen::Matrix<double, -1, 1> alpha__;
  std::vector<Eigen::Matrix<double, -1, 1>> beta; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> alpha{nullptr, 0};
 
 public:
  ~expr_prop_fail7_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail7_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  expr_prop_fail7_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail7_model_namespace::expr_prop_fail7_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 22;
      context__.validate_dims("data initialization","K","int",
           std::vector<size_t>{});
      K = std::numeric_limits<int>::min();
      
      
      current_statement__ = 22;
      K = context__.vals_i("K")[(1 - 1)];
      current_statement__ = 22;
      stan::math::check_greater_or_equal(function__, "K", K, 2);
      current_statement__ = 23;
      context__.validate_dims("data initialization","I","int",
           std::vector<size_t>{});
      I = std::numeric_limits<int>::min();
      
      
      current_statement__ = 23;
      I = context__.vals_i("I")[(1 - 1)];
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "I", I, 1);
      current_statement__ = 24;
      context__.validate_dims("data initialization","J","int",
           std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      
      
      current_statement__ = 24;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 24;
      stan::math::check_greater_or_equal(function__, "J", J, 1);
      current_statement__ = 25;
      stan::math::validate_non_negative_index("y", "I", I);
      current_statement__ = 26;
      stan::math::validate_non_negative_index("y", "J", J);
      current_statement__ = 27;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(I),
            static_cast<size_t>(J)});
      y = 
        std::vector<std::vector<int>>(I, 
          std::vector<int>(J, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 27;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 27;
        pos__ = 1;
        current_statement__ = 27;
        for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
          current_statement__ = 27;
          for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
            current_statement__ = 27;
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
            current_statement__ = 27;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 27;
      stan::math::check_greater_or_equal(function__, "y", y, 1);
      current_statement__ = 27;
      stan::math::check_less_or_equal(function__, "y", y, K);
      current_statement__ = 28;
      stan::math::validate_non_negative_index("alpha", "K", K);
      current_statement__ = 29;
      context__.validate_dims("data initialization","alpha","double",
           std::vector<size_t>{static_cast<size_t>(K)});
      alpha__ = 
        Eigen::Matrix<double, -1, 1>::Constant(K,
          std::numeric_limits<double>::quiet_NaN());
      new (&alpha) Eigen::Map<Eigen::Matrix<double, -1, 1>>(alpha__.data(), K);
        
      
      {
        std::vector<local_scalar_t__> alpha_flat__;
        current_statement__ = 29;
        alpha_flat__ = context__.vals_r("alpha");
        current_statement__ = 29;
        pos__ = 1;
        current_statement__ = 29;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 29;
          stan::model::assign(alpha, alpha_flat__[(pos__ - 1)],
            "assigning variable alpha", stan::model::index_uni(sym1__));
          current_statement__ = 29;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 29;
      stan::math::check_greater_or_equal(function__, "alpha", alpha, 0);
      current_statement__ = 30;
      stan::math::validate_non_negative_index("beta", "K", K);
      current_statement__ = 31;
      stan::math::validate_non_negative_index("beta", "K", K);
      current_statement__ = 32;
      context__.validate_dims("data initialization","beta","double",
           std::vector<size_t>{static_cast<size_t>(K),
            static_cast<size_t>(K)});
      beta = 
        std::vector<Eigen::Matrix<double, -1, 1>>(K, 
          Eigen::Matrix<double, -1, 1>::Constant(K,
            std::numeric_limits<double>::quiet_NaN()));
      
      
      {
        std::vector<local_scalar_t__> beta_flat__;
        current_statement__ = 32;
        beta_flat__ = context__.vals_r("beta");
        current_statement__ = 32;
        pos__ = 1;
        current_statement__ = 32;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 32;
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            current_statement__ = 32;
            stan::model::assign(beta, beta_flat__[(pos__ - 1)],
              "assigning variable beta", stan::model::index_uni(sym2__),
                                           stan::model::index_uni(sym1__));
            current_statement__ = 32;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 32;
      stan::math::check_greater_or_equal(function__, "beta", beta, 0);
      current_statement__ = 33;
      stan::math::validate_positive_index("pi", "K", K);
      current_statement__ = 34;
      stan::math::validate_non_negative_index("theta", "J", J);
      current_statement__ = 35;
      stan::math::validate_non_negative_index("theta", "K", K);
      current_statement__ = 36;
      stan::math::validate_positive_index("theta", "K", K);
      current_statement__ = 37;
      stan::math::validate_non_negative_index("log_Pr_z", "I", I);
      current_statement__ = 38;
      stan::math::validate_non_negative_index("log_Pr_z", "K", K);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (K - 1) + (J * K * (K - 1));
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail7_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> pi =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(K, DUMMY_VAR__);
      current_statement__ = 1;
      pi = in__.template read_constrain_simplex<
             Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(lp__, K);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> theta =
         std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(J, 
           std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, 
             Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(K, DUMMY_VAR__)));
      current_statement__ = 2;
      theta = in__.template read_constrain_simplex<
                std::vector<
                  std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>, 
                jacobian__>(lp__, J, K, K);
      {
        current_statement__ = 11;
        lp_accum__.add(stan::math::dirichlet_lpdf<propto__>(pi, alpha));
        current_statement__ = 14;
        for (int j = 1; j <= J; ++j) {
          current_statement__ = 13;
          for (int k = 1; k <= K; ++k) {
            current_statement__ = 12;
            lp_accum__.add(
              stan::math::dirichlet_lpdf<propto__>(
                stan::model::rvalue(theta, "theta",
                  stan::model::index_uni(j), stan::model::index_uni(k)),
                stan::model::rvalue(beta, "beta", stan::model::index_uni(k))));
          }
        }
        current_statement__ = 21;
        for (int i = 1; i <= I; ++i) {
          current_statement__ = 15;
          stan::math::validate_non_negative_index("log_q", "K", K);
          Eigen::Matrix<local_scalar_t__, -1, 1> log_q =
             Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(K, DUMMY_VAR__);
          current_statement__ = 16;
          stan::model::assign(log_q, stan::math::log(pi),
            "assigning variable log_q");
          current_statement__ = 18;
          for (int j = 1; j <= J; ++j) {
            current_statement__ = 17;
            stan::model::assign(log_q,
              stan::math::add(stan::model::deep_copy(log_q),
                stan::math::to_vector(
                  stan::math::log(
                    stan::model::rvalue(theta, "theta",
                      stan::model::index_uni(j), stan::model::index_omni(),
                        stan::model::index_uni(stan::model::rvalue(y, "y",
                                                 stan::model::index_uni(i),
                                                   stan::model::index_uni(j))))))),
              "assigning variable log_q");
          }
          current_statement__ = 19;
          lp_accum__.add(stan::math::log_sum_exp(log_q));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail7_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, 1> pi =
         Eigen::Matrix<double, -1, 1>::Constant(K,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      pi = in__.template read_constrain_simplex<
             Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(lp__, K);
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> theta =
         std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(J, 
           std::vector<Eigen::Matrix<double, -1, 1>>(K, 
             Eigen::Matrix<double, -1, 1>::Constant(K,
               std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 2;
      theta = in__.template read_constrain_simplex<
                std::vector<
                  std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>, 
                jacobian__>(lp__, J, K, K);
      out__.write(pi);
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= J; ++sym3__) {
            out__.write(theta[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      std::vector<Eigen::Matrix<double, -1, 1>> log_Pr_z =
         std::vector<Eigen::Matrix<double, -1, 1>>(I, 
           Eigen::Matrix<double, -1, 1>::Constant(K,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 10;
      for (int i = 1; i <= I; ++i) {
        current_statement__ = 4;
        stan::math::validate_non_negative_index("log_q", "K", K);
        Eigen::Matrix<double, -1, 1> log_q =
           Eigen::Matrix<double, -1, 1>::Constant(K,
             std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 5;
        stan::model::assign(log_q, stan::math::log(pi),
          "assigning variable log_q");
        current_statement__ = 7;
        for (int j = 1; j <= J; ++j) {
          current_statement__ = 6;
          stan::model::assign(log_q,
            stan::math::add(stan::model::deep_copy(log_q),
              stan::math::to_vector(
                stan::math::log(
                  stan::model::rvalue(theta, "theta",
                    stan::model::index_uni(j), stan::model::index_omni(),
                      stan::model::index_uni(stan::model::rvalue(y, "y",
                                               stan::model::index_uni(i),
                                                 stan::model::index_uni(j))))))),
            "assigning variable log_q");
        }
        current_statement__ = 8;
        stan::model::assign(log_Pr_z,
          stan::math::subtract(log_q, stan::math::log_sum_exp(log_q)),
          "assigning variable log_Pr_z", stan::model::index_uni(i));
      }
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
          out__.write(log_Pr_z[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, 1> pi =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(K, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        stan::model::assign(pi, in__.read<local_scalar_t__>(),
          "assigning variable pi", stan::model::index_uni(sym1__));
      }
      out__.write_free_simplex(pi);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> theta =
         std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(J, 
           std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, 
             Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(K, DUMMY_VAR__)));
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= J; ++sym3__) {
            stan::model::assign(theta, in__.read<local_scalar_t__>(),
              "assigning variable theta", stan::model::index_uni(sym3__),
                                            stan::model::index_uni(sym2__),
                                            stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write_free_simplex(theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"pi", "theta", "log_Pr_z"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(K)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(J), static_cast<size_t>(K),
                          static_cast<size_t>(K)},
      std::vector<size_t>{static_cast<size_t>(I), static_cast<size_t>(K)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pi" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= J; ++sym3__) {
              {
                param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              } 
            }
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "log_Pr_z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= (K - 1); ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pi" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= (K - 1); ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= J; ++sym3__) {
              {
                param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              } 
            }
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "log_Pr_z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"pi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}}},\"block\":\"parameters\"},{\"name\":\"log_Pr_z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(I) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"pi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((K - 1)) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(K) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string((K - 1)) + "}}},\"block\":\"parameters\"},{\"name\":\"log_Pr_z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(I) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (K + ((J * K) * K));
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 
  (I * K);
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (K + ((J * K) * K));
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 
  (I * K);
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"pi", "theta"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{K,
       (J * K * K)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail7_model_namespace::expr_prop_fail7_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail7_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 expr-prop-fail8.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail8_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 25> locations_array__ = 
{" (found before start of program)",
 " (in 'expr-prop-fail8.stan', line 11, column 2 to column 13)",
 " (in 'expr-prop-fail8.stan', line 12, column 2 to column 13)",
 " (in 'expr-prop-fail8.stan', line 14, column 2 to column 26)",
 " (in 'expr-prop-fail8.stan', line 15, column 2 to column 24)",
 " (in 'expr-prop-fail8.stan', line 17, column 2 to column 22)",
 " (in 'expr-prop-fail8.stan', line 18, column 2 to column 24)",
 " (in 'expr-prop-fail8.stan', line 21, column 2 to column 47)",
 " (in 'expr-prop-fail8.stan', line 22, column 2 to column 16)",
 " (in 'expr-prop-fail8.stan', line 23, column 2 to column 27)",
 " (in 'expr-prop-fail8.stan', line 24, column 2 to column 24)",
 " (in 'expr-prop-fail8.stan', line 27, column 2 to column 33)",
 " (in 'expr-prop-fail8.stan', line 2, column 2 to column 17)",
 " (in 'expr-prop-fail8.stan', line 3, column 2 to column 23)",
 " (in 'expr-prop-fail8.stan', line 4, column 8 to column 15)",
 " (in 'expr-prop-fail8.stan', line 4, column 2 to column 45)",
 " (in 'expr-prop-fail8.stan', line 5, column 8 to column 15)",
 " (in 'expr-prop-fail8.stan', line 5, column 2 to column 45)",
 " (in 'expr-prop-fail8.stan', line 7, column 8 to column 9)",
 " (in 'expr-prop-fail8.stan', line 7, column 2 to column 26)",
 " (in 'expr-prop-fail8.stan', line 8, column 9 to column 10)",
 " (in 'expr-prop-fail8.stan', line 8, column 2 to column 14)",
 " (in 'expr-prop-fail8.stan', line 17, column 9 to column 10)",
 " (in 'expr-prop-fail8.stan', line 18, column 9 to column 10)",
 " (in 'expr-prop-fail8.stan', line 22, column 9 to column 10)"};




class expr_prop_fail8_model final : public model_base_crtp<expr_prop_fail8_model> {

 private:
  int N;
  int N_edges;
  std::vector<int> node1;
  std::vector<int> node2;
  std::vector<int> y;
  Eigen::Matrix<double, -1, 1> x__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> x{nullptr, 0};
 
 public:
  ~expr_prop_fail8_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail8_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  expr_prop_fail8_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail8_model_namespace::expr_prop_fail8_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 12;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      
      current_statement__ = 12;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 12;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 13;
      context__.validate_dims("data initialization","N_edges","int",
           std::vector<size_t>{});
      N_edges = std::numeric_limits<int>::min();
      
      
      current_statement__ = 13;
      N_edges = context__.vals_i("N_edges")[(1 - 1)];
      current_statement__ = 13;
      stan::math::check_greater_or_equal(function__, "N_edges", N_edges, 0);
      current_statement__ = 14;
      stan::math::validate_non_negative_index("node1", "N_edges", N_edges);
      current_statement__ = 15;
      context__.validate_dims("data initialization","node1","int",
           std::vector<size_t>{static_cast<size_t>(N_edges)});
      node1 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      
      
      current_statement__ = 15;
      node1 = context__.vals_i("node1");
      current_statement__ = 15;
      stan::math::check_greater_or_equal(function__, "node1", node1, 1);
      current_statement__ = 15;
      stan::math::check_less_or_equal(function__, "node1", node1, N);
      current_statement__ = 16;
      stan::math::validate_non_negative_index("node2", "N_edges", N_edges);
      current_statement__ = 17;
      context__.validate_dims("data initialization","node2","int",
           std::vector<size_t>{static_cast<size_t>(N_edges)});
      node2 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      
      
      current_statement__ = 17;
      node2 = context__.vals_i("node2");
      current_statement__ = 17;
      stan::math::check_greater_or_equal(function__, "node2", node2, 1);
      current_statement__ = 17;
      stan::math::check_less_or_equal(function__, "node2", node2, N);
      current_statement__ = 18;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 19;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 19;
      y = context__.vals_i("y");
      current_statement__ = 19;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 20;
      stan::math::validate_non_negative_index("x", "N", N);
      current_statement__ = 21;
      context__.validate_dims("data initialization","x","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      x__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&x) Eigen::Map<Eigen::Matrix<double, -1, 1>>(x__.data(), N);
      
      {
        std::vector<local_scalar_t__> x_flat__;
        current_statement__ = 21;
        x_flat__ = context__.vals_r("x");
        current_statement__ = 21;
        pos__ = 1;
        current_statement__ = 21;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 21;
          stan::model::assign(x, x_flat__[(pos__ - 1)],
            "assigning variable x", stan::model::index_uni(sym1__));
          current_statement__ = 21;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 22;
      stan::math::validate_non_negative_index("theta_std", "N", N);
      current_statement__ = 23;
      stan::math::validate_non_negative_index("phi_std_raw", "N", N);
      current_statement__ = 24;
      stan::math::validate_non_negative_index("phi", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + N + N;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail8_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ beta0 = DUMMY_VAR__;
      current_statement__ = 1;
      beta0 = in__.template read<local_scalar_t__>();
      local_scalar_t__ beta1 = DUMMY_VAR__;
      current_statement__ = 2;
      beta1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ tau_theta = DUMMY_VAR__;
      current_statement__ = 3;
      tau_theta = in__.template read_constrain_lb<local_scalar_t__, 
                    jacobian__>(0, lp__);
      local_scalar_t__ tau_phi = DUMMY_VAR__;
      current_statement__ = 4;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__, 
                  jacobian__>(0, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> theta_std =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 5;
      theta_std = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                    N);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_std_raw =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 6;
      phi_std_raw = in__.template read<
                      Eigen::Matrix<local_scalar_t__, -1, 1>>(N);
      local_scalar_t__ sigma_phi = DUMMY_VAR__;
      current_statement__ = 7;
      sigma_phi = stan::math::inv(stan::math::sqrt(tau_phi));
      Eigen::Matrix<local_scalar_t__, -1, 1> phi =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 9;
      stan::model::assign(phi, phi_std_raw,
        "assigning variable phi", stan::model::index_min_max(1, N));
      current_statement__ = 10;
      stan::model::assign(phi,
        stan::math::multiply(stan::model::deep_copy(phi), sigma_phi),
        "assigning variable phi");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "sigma_phi", sigma_phi,
                                            0);
      {
        current_statement__ = 11;
        lp_accum__.add(
          stan::math::dot_self(
            stan::model::rvalue(phi, "phi", stan::model::index_multi(node1))));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "expr_prop_fail8_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double beta0 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      beta0 = in__.template read<local_scalar_t__>();
      double beta1 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      beta1 = in__.template read<local_scalar_t__>();
      double tau_theta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      tau_theta = in__.template read_constrain_lb<local_scalar_t__, 
                    jacobian__>(0, lp__);
      double tau_phi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      tau_phi = in__.template read_constrain_lb<local_scalar_t__, 
                  jacobian__>(0, lp__);
      Eigen::Matrix<double, -1, 1> theta_std =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      theta_std = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                    N);
      Eigen::Matrix<double, -1, 1> phi_std_raw =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 6;
      phi_std_raw = in__.template read<
                      Eigen::Matrix<local_scalar_t__, -1, 1>>(N);
      double sigma_phi = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double, -1, 1> phi =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(beta0);
      out__.write(beta1);
      out__.write(tau_theta);
      out__.write(tau_phi);
      out__.write(theta_std);
      out__.write(phi_std_raw);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 7;
      sigma_phi = stan::math::inv(stan::math::sqrt(tau_phi));
      current_statement__ = 9;
      stan::model::assign(phi, phi_std_raw,
        "assigning variable phi", stan::model::index_min_max(1, N));
      current_statement__ = 10;
      stan::model::assign(phi,
        stan::math::multiply(stan::model::deep_copy(phi), sigma_phi),
        "assigning variable phi");
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "sigma_phi", sigma_phi,
                                            0);
      if (emit_transformed_parameters__) {
        out__.write(sigma_phi);
        out__.write(phi);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ beta0 = DUMMY_VAR__;
      beta0 = in__.read<local_scalar_t__>();
      out__.write(beta0);
      local_scalar_t__ beta1 = DUMMY_VAR__;
      beta1 = in__.read<local_scalar_t__>();
      out__.write(beta1);
      local_scalar_t__ tau_theta = DUMMY_VAR__;
      tau_theta = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau_theta);
      local_scalar_t__ tau_phi = DUMMY_VAR__;
      tau_phi = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau_phi);
      Eigen::Matrix<local_scalar_t__, -1, 1> theta_std =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(theta_std, in__.read<local_scalar_t__>(),
          "assigning variable theta_std", stan::model::index_uni(sym1__));
      }
      out__.write(theta_std);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_std_raw =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(phi_std_raw, in__.read<local_scalar_t__>(),
          "assigning variable phi_std_raw", stan::model::index_uni(sym1__));
      }
      out__.write(phi_std_raw);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"beta0", "beta1", "tau_theta",
      "tau_phi", "theta_std", "phi_std_raw", "sigma_phi", "phi"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)}, std::vector<size_t>{
      }, std::vector<size_t>{static_cast<size_t>(N)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta0");
    param_names__.emplace_back(std::string() + "beta1");
    param_names__.emplace_back(std::string() + "tau_theta");
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta_std" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta0");
    param_names__.emplace_back(std::string() + "beta1");
    param_names__.emplace_back(std::string() + "tau_theta");
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta_std" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((1 + 1) + 1) + 1) + N) + N);
      const size_t num_transformed = 
  (1 + N);
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((1 + 1) + 1) + 1) + N) + N);
      const size_t num_transformed = 
  (1 + N);
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 6> names__{"beta0", "beta1",
      "tau_theta", "tau_phi", "theta_std", "phi_std_raw"};
      const std::array<Eigen::Index, 6> constrain_param_sizes__{1, 1, 
       1, 1, N, N};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = expr_prop_fail8_model_namespace::expr_prop_fail8_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail8_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 fails-test.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace fails_test_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 76> locations_array__ = 
{" (found before start of program)",
 " (in 'fails-test.stan', line 68, column 2 to column 32)",
 " (in 'fails-test.stan', line 69, column 2 to column 41)",
 " (in 'fails-test.stan', line 72, column 2 to column 52)",
 " (in 'fails-test.stan', line 73, column 2 to column 50)",
 " (in 'fails-test.stan', line 74, column 2 to column 50)",
 " (in 'fails-test.stan', line 79, column 6 to column 20)",
 " (in 'fails-test.stan', line 80, column 6 to column 18)",
 " (in 'fails-test.stan', line 78, column 34 to line 81, column 5)",
 " (in 'fails-test.stan', line 78, column 4 to line 81, column 5)",
 " (in 'fails-test.stan', line 83, column 6 to column 32)",
 " (in 'fails-test.stan', line 84, column 6 to column 23)",
 " (in 'fails-test.stan', line 82, column 40 to line 85, column 5)",
 " (in 'fails-test.stan', line 82, column 4 to line 85, column 5)",
 " (in 'fails-test.stan', line 77, column 22 to line 86, column 3)",
 " (in 'fails-test.stan', line 77, column 2 to line 86, column 3)",
 " (in 'fails-test.stan', line 88, column 2 to column 51)",
 " (in 'fails-test.stan', line 100, column 8 to column 37)",
 " (in 'fails-test.stan', line 101, column 8 to column 41)",
 " (in 'fails-test.stan', line 99, column 42 to line 102, column 7)",
 " (in 'fails-test.stan', line 99, column 6 to line 102, column 7)",
 " (in 'fails-test.stan', line 103, column 6 to column 37)",
 " (in 'fails-test.stan', line 98, column 22 to line 104, column 5)",
 " (in 'fails-test.stan', line 98, column 4 to line 104, column 5)",
 " (in 'fails-test.stan', line 97, column 22 to line 105, column 3)",
 " (in 'fails-test.stan', line 97, column 2 to line 105, column 3)",
 " (in 'fails-test.stan', line 49, column 2 to column 20)",
 " (in 'fails-test.stan', line 50, column 2 to column 27)",
 " (in 'fails-test.stan', line 51, column 8 to column 12)",
 " (in 'fails-test.stan', line 51, column 14 to column 25)",
 " (in 'fails-test.stan', line 51, column 2 to column 51)",
 " (in 'fails-test.stan', line 52, column 2 to column 23)",
 " (in 'fails-test.stan', line 53, column 8 to column 12)",
 " (in 'fails-test.stan', line 53, column 14 to column 29)",
 " (in 'fails-test.stan', line 53, column 2 to column 61)",
 " (in 'fails-test.stan', line 56, column 2 to column 38)",
 " (in 'fails-test.stan', line 58, column 8 to column 12)",
 " (in 'fails-test.stan', line 58, column 2 to column 52)",
 " (in 'fails-test.stan', line 59, column 8 to column 12)",
 " (in 'fails-test.stan', line 59, column 2 to column 51)",
 " (in 'fails-test.stan', line 63, column 4 to column 35)",
 " (in 'fails-test.stan', line 62, column 2 to line 63, column 35)",
 " (in 'fails-test.stan', line 65, column 4 to column 33)",
 " (in 'fails-test.stan', line 64, column 2 to line 65, column 33)",
 " (in 'fails-test.stan', line 69, column 27 to column 34)",
 " (in 'fails-test.stan', line 72, column 27 to column 31)",
 " (in 'fails-test.stan', line 72, column 33 to column 46)",
 " (in 'fails-test.stan', line 73, column 27 to column 31)",
 " (in 'fails-test.stan', line 73, column 33 to column 46)",
 " (in 'fails-test.stan', line 74, column 27 to column 31)",
 " (in 'fails-test.stan', line 74, column 33 to column 44)",
 " (in 'fails-test.stan', line 8, column 8 to column 17)",
 " (in 'fails-test.stan', line 7, column 6 to line 8, column 17)",
 " (in 'fails-test.stan', line 6, column 4 to line 8, column 17)",
 " (in 'fails-test.stan', line 9, column 4 to column 13)",
 " (in 'fails-test.stan', line 5, column 37 to line 10, column 3)",
 " (in 'fails-test.stan', line 15, column 6 to column 32)",
 " (in 'fails-test.stan', line 19, column 8 to column 17)",
 " (in 'fails-test.stan', line 18, column 6 to line 19, column 17)",
 " (in 'fails-test.stan', line 13, column 39 to line 20, column 5)",
 " (in 'fails-test.stan', line 13, column 4 to line 20, column 5)",
 " (in 'fails-test.stan', line 21, column 4 to column 13)",
 " (in 'fails-test.stan', line 12, column 36 to line 22, column 3)",
 " (in 'fails-test.stan', line 25, column 11 to column 15)",
 " (in 'fails-test.stan', line 25, column 17 to column 28)",
 " (in 'fails-test.stan', line 25, column 4 to column 34)",
 " (in 'fails-test.stan', line 28, column 6 to column 32)",
 " (in 'fails-test.stan', line 31, column 8 to column 37)",
 " (in 'fails-test.stan', line 32, column 8 to column 32)",
 " (in 'fails-test.stan', line 40, column 8 to line 42, column 44)",
 " (in 'fails-test.stan', line 29, column 39 to line 43, column 7)",
 " (in 'fails-test.stan', line 29, column 6 to line 43, column 7)",
 " (in 'fails-test.stan', line 27, column 24 to line 44, column 5)",
 " (in 'fails-test.stan', line 27, column 4 to line 44, column 5)",
 " (in 'fails-test.stan', line 45, column 4 to column 15)",
 " (in 'fails-test.stan', line 24, column 74 to line 46, column 3)"};

struct first_capture_functor__ {
  int
  operator()(const std::vector<int>& y_i, std::ostream* pstream__) const;
};
struct prob_uncaptured_functor__ {
  template <typename T2__, typename T3__,
            stan::require_eigen_matrix_dynamic_t<T2__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>, stan::value_type_t<T3__>>, -1, -1>
  operator()(const int& nind, const int& n_occasions, const T2__& p,
             const T3__& phi, std::ostream* pstream__) const;
};
struct last_capture_functor__ {
  int
  operator()(const std::vector<int>& y_i, std::ostream* pstream__) const;
};

int first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 53;
      for (int k = 1; k <= stan::math::size(y_i); ++k) {
        current_statement__ = 52;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
          current_statement__ = 51;
          return k;
        } 
      }
      current_statement__ = 54;
      return 0;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 60;
      for (int k_rev = 0; k_rev <= (stan::math::size(y_i) - 1); ++k_rev) {
        int k = std::numeric_limits<int>::min();
        current_statement__ = 56;
        k = (stan::math::size(y_i) - k_rev);
        current_statement__ = 58;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
          current_statement__ = 57;
          return k;
        } 
      }
      current_statement__ = 61;
      return 0;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T2__, typename T3__,
          stan::require_eigen_matrix_dynamic_t<T2__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>, stan::value_type_t<T3__>>, -1, -1>
  prob_uncaptured(const int& nind, const int& n_occasions,
                  const T2__& p_arg__, const T3__& phi_arg__,
                  std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<stan::value_type_t<T2__>,
                                 stan::value_type_t<T3__>>;
    int current_statement__ = 0; 
    const auto& p = stan::math::to_ref(p_arg__);
    const auto& phi = stan::math::to_ref(phi_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 63;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 64;
      stan::math::validate_non_negative_index("chi", "n_occasions",
                                              n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind, n_occasions,
           DUMMY_VAR__);
      current_statement__ = 73;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 66;
        stan::model::assign(chi, 1.0,
          "assigning variable chi", stan::model::index_uni(i),
                                      stan::model::index_uni(n_occasions));
        current_statement__ = 71;
        for (int t = 1; t <= (n_occasions - 1); ++t) {
          int t_curr = std::numeric_limits<int>::min();
          current_statement__ = 67;
          t_curr = (n_occasions - t);
          int t_next = std::numeric_limits<int>::min();
          current_statement__ = 68;
          t_next = (t_curr + 1);
          current_statement__ = 69;
          stan::model::assign(chi,
            ((1 -
               stan::model::rvalue(phi, "phi",
                 stan::model::index_uni(i), stan::model::index_uni(t_curr)))
              +
              ((stan::model::rvalue(phi, "phi",
                  stan::model::index_uni(i), stan::model::index_uni(t_curr))
                 *
                 (1 -
                   stan::model::rvalue(p, "p",
                     stan::model::index_uni(i),
                       stan::model::index_uni((t_next - 1))))) *
                stan::model::rvalue(chi, "chi",
                  stan::model::index_uni(i), stan::model::index_uni(t_next)))),
            "assigning variable chi", stan::model::index_uni(i),
                                        stan::model::index_uni(t_curr));
        }
      }
      current_statement__ = 74;
      return chi;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int
first_capture_functor__::operator()(const std::vector<int>& y_i,
                                    std::ostream* pstream__)  const
{
  return first_capture(y_i, pstream__);
}

template <typename T2__, typename T3__,
          stan::require_eigen_matrix_dynamic_t<T2__>*,
          stan::require_eigen_matrix_dynamic_t<T3__>*>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>, stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured_functor__::operator()(const int& nind,
                                      const int& n_occasions, const T2__& p,
                                      const T3__& phi,
                                      std::ostream* pstream__)  const
{
  return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}

int
last_capture_functor__::operator()(const std::vector<int>& y_i,
                                   std::ostream* pstream__)  const
{
  return last_capture(y_i, pstream__);
}

 class fails_test_model final : public model_base_crtp<fails_test_model> {

 private:
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int max_age;
  std::vector<std::vector<int>> x;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last; 
  
 
 public:
  ~fails_test_model() { }
  
  inline std::string model_name() const final { return "fails_test_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  fails_test_model(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "fails_test_model_namespace::fails_test_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 26;
      context__.validate_dims("data initialization","nind","int",
           std::vector<size_t>{});
      nind = std::numeric_limits<int>::min();
      
      
      current_statement__ = 26;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 26;
      stan::math::check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 27;
      context__.validate_dims("data initialization","n_occasions","int",
           std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      
      
      current_statement__ = 27;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 27;
      stan::math::check_greater_or_equal(function__, "n_occasions",
                                            n_occasions, 2);
      current_statement__ = 28;
      stan::math::validate_non_negative_index("y", "nind", nind);
      current_statement__ = 29;
      stan::math::validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 30;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(nind),
            static_cast<size_t>(n_occasions)});
      y = 
        std::vector<std::vector<int>>(nind, 
          std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 30;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 30;
        pos__ = 1;
        current_statement__ = 30;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 30;
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            current_statement__ = 30;
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
            current_statement__ = 30;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 30;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 31;
      context__.validate_dims("data initialization","max_age","int",
           std::vector<size_t>{});
      max_age = std::numeric_limits<int>::min();
      
      
      current_statement__ = 31;
      max_age = context__.vals_i("max_age")[(1 - 1)];
      current_statement__ = 31;
      stan::math::check_greater_or_equal(function__, "max_age", max_age, 1);
      current_statement__ = 32;
      stan::math::validate_non_negative_index("x", "nind", nind);
      current_statement__ = 33;
      stan::math::validate_non_negative_index("x", "n_occasions - 1",
                                              (n_occasions - 1));
      current_statement__ = 34;
      context__.validate_dims("data initialization","x","int",
           std::vector<size_t>{static_cast<size_t>(nind),
            static_cast<size_t>((n_occasions - 1))});
      x = 
        std::vector<std::vector<int>>(nind, 
          std::vector<int>((n_occasions - 1), 
            std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> x_flat__;
        current_statement__ = 34;
        x_flat__ = context__.vals_i("x");
        current_statement__ = 34;
        pos__ = 1;
        current_statement__ = 34;
        for (int sym1__ = 1; sym1__ <= (n_occasions - 1); ++sym1__) {
          current_statement__ = 34;
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            current_statement__ = 34;
            stan::model::assign(x, x_flat__[(pos__ - 1)],
              "assigning variable x", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
            current_statement__ = 34;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 34;
      stan::math::check_greater_or_equal(function__, "x", x, 0);
      current_statement__ = 34;
      stan::math::check_less_or_equal(function__, "x", x, max_age);
      current_statement__ = 35;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      
      
      current_statement__ = 35;
      n_occ_minus_1 = (n_occasions - 1);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("first", "nind", nind);
      current_statement__ = 37;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      
      current_statement__ = 38;
      stan::math::validate_non_negative_index("last", "nind", nind);
      current_statement__ = 39;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      
      current_statement__ = 41;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 40;
        stan::model::assign(first,
          first_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(i)), pstream__),
          "assigning variable first", stan::model::index_uni(i));
      }
      current_statement__ = 43;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 42;
        stan::model::assign(last,
          last_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(i)), pstream__),
          "assigning variable last", stan::model::index_uni(i));
      }
      current_statement__ = 37;
      stan::math::check_greater_or_equal(function__, "first", first, 0);
      current_statement__ = 37;
      stan::math::check_less_or_equal(function__, "first", first, n_occasions);
      current_statement__ = 39;
      stan::math::check_greater_or_equal(function__, "last", last, 0);
      current_statement__ = 39;
      stan::math::check_less_or_equal(function__, "last", last, n_occasions);
      current_statement__ = 44;
      stan::math::validate_non_negative_index("beta", "max_age", max_age);
      current_statement__ = 45;
      stan::math::validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 46;
      stan::math::validate_non_negative_index("phi", "n_occ_minus_1",
                                              n_occ_minus_1);
      current_statement__ = 47;
      stan::math::validate_non_negative_index("p", "nind", nind);
      current_statement__ = 48;
      stan::math::validate_non_negative_index("p", "n_occ_minus_1",
                                              n_occ_minus_1);
      current_statement__ = 49;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("chi", "n_occasions",
                                              n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + max_age;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "fails_test_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ mean_p = DUMMY_VAR__;
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, 
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(max_age,
           DUMMY_VAR__);
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(0, 1,
               lp__, max_age);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind,
           n_occ_minus_1, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind,
           n_occ_minus_1, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind, n_occasions,
           DUMMY_VAR__);
      current_statement__ = 15;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 9;
        for (int t = 1;
             t <= (stan::model::rvalue(first, "first",
                     stan::model::index_uni(i)) - 1);
             ++t) {
          current_statement__ = 6;
          stan::model::assign(phi, 0,
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 7;
          stan::model::assign(p, 0,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
        current_statement__ = 13;
        for (int t = stan::model::rvalue(first, "first",
                       stan::model::index_uni(i));
             t <= n_occ_minus_1; ++t) {
          current_statement__ = 10;
          stan::model::assign(phi,
            stan::model::rvalue(beta, "beta",
              stan::model::index_uni(stan::model::rvalue(x, "x",
                                       stan::model::index_uni(i),
                                         stan::model::index_uni(t)))),
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 11;
          stan::model::assign(p, mean_p,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
      }
      current_statement__ = 16;
      stan::model::assign(chi,
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi", chi, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi", chi, 1);
      {
        current_statement__ = 25;
        for (int i = 1; i <= nind; ++i) {
          current_statement__ = 23;
          if (stan::math::logical_gt(
                stan::model::rvalue(first, "first",
                  stan::model::index_uni(i)), 0)) {
            current_statement__ = 20;
            for (int t = (stan::model::rvalue(first, "first",
                            stan::model::index_uni(i)) + 1);
                 t <= stan::model::rvalue(last, "last",
                        stan::model::index_uni(i));
                 ++t) {
              current_statement__ = 17;
              lp_accum__.add(
                stan::math::bernoulli_lpmf<propto__>(1,
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(i),
                      stan::model::index_uni((t - 1)))));
              current_statement__ = 18;
              lp_accum__.add(
                stan::math::bernoulli_lpmf<propto__>(
                  stan::model::rvalue(y, "y",
                    stan::model::index_uni(i), stan::model::index_uni(t)),
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(i),
                      stan::model::index_uni((t - 1)))));
            }
            current_statement__ = 21;
            lp_accum__.add(
              stan::math::bernoulli_lpmf<propto__>(1,
                stan::model::rvalue(chi, "chi",
                  stan::model::index_uni(i),
                    stan::model::index_uni(stan::model::rvalue(last, "last",
                                             stan::model::index_uni(i))))));
          } 
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "fails_test_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double mean_p = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, 
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<double, -1, 1> beta =
         Eigen::Matrix<double, -1, 1>::Constant(max_age,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      beta = in__.template read_constrain_lub<
               Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(0, 1,
               lp__, max_age);
      Eigen::Matrix<double, -1, -1> phi =
         Eigen::Matrix<double, -1, -1>::Constant(nind, n_occ_minus_1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> p =
         Eigen::Matrix<double, -1, -1>::Constant(nind, n_occ_minus_1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> chi =
         Eigen::Matrix<double, -1, -1>::Constant(nind, n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(mean_p);
      out__.write(beta);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 15;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 9;
        for (int t = 1;
             t <= (stan::model::rvalue(first, "first",
                     stan::model::index_uni(i)) - 1);
             ++t) {
          current_statement__ = 6;
          stan::model::assign(phi, 0,
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 7;
          stan::model::assign(p, 0,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
        current_statement__ = 13;
        for (int t = stan::model::rvalue(first, "first",
                       stan::model::index_uni(i));
             t <= n_occ_minus_1; ++t) {
          current_statement__ = 10;
          stan::model::assign(phi,
            stan::model::rvalue(beta, "beta",
              stan::model::index_uni(stan::model::rvalue(x, "x",
                                       stan::model::index_uni(i),
                                         stan::model::index_uni(t)))),
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 11;
          stan::model::assign(p, mean_p,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
      }
      current_statement__ = 16;
      stan::model::assign(chi,
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi", chi, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi", chi, 1);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(chi);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ mean_p = DUMMY_VAR__;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(max_age,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
        stan::model::assign(beta, in__.read<local_scalar_t__>(),
          "assigning variable beta", stan::model::index_uni(sym1__));
      }
      out__.write_free_lub(0, 1, beta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mean_p", "beta", "phi", "p", "chi"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(max_age)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occasions)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(max_age) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(max_age) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + max_age);
      const size_t num_transformed = (((nind *
                                                          n_occ_minus_1) +
                                                         (nind *
                                                           n_occ_minus_1)) +
                                                        (nind * n_occasions));
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + max_age);
      const size_t num_transformed = (((nind *
                                                          n_occ_minus_1) +
                                                         (nind *
                                                           n_occ_minus_1)) +
                                                        (nind * n_occasions));
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"mean_p", "beta"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{1, max_age};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } using stan_model = fails_test_model_namespace::fails_test_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return fails_test_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 inlining-fail2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace inlining_fail2_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 158> locations_array__ = 
{" (found before start of program)",
 " (in 'inlining-fail2.stan', line 175, column 2 to column 34)",
 " (in 'inlining-fail2.stan', line 176, column 2 to column 32)",
 " (in 'inlining-fail2.stan', line 177, column 2 to column 46)",
 " (in 'inlining-fail2.stan', line 178, column 2 to column 34)",
 " (in 'inlining-fail2.stan', line 179, column 2 to column 31)",
 " (in 'inlining-fail2.stan', line 184, column 2 to column 51)",
 " (in 'inlining-fail2.stan', line 185, column 2 to column 45)",
 " (in 'inlining-fail2.stan', line 186, column 2 to column 47)",
 " (in 'inlining-fail2.stan', line 191, column 6 to column 58)",
 " (in 'inlining-fail2.stan', line 190, column 4 to line 191, column 58)",
 " (in 'inlining-fail2.stan', line 189, column 2 to line 191, column 58)",
 " (in 'inlining-fail2.stan', line 192, column 2 to column 41)",
 " (in 'inlining-fail2.stan', line 195, column 2 to column 32)",
 " (in 'inlining-fail2.stan', line 208, column 2 to column 14)",
 " (in 'inlining-fail2.stan', line 209, column 2 to column 11)",
 " (in 'inlining-fail2.stan', line 210, column 2 to column 24)",
 " (in 'inlining-fail2.stan', line 211, column 2 to column 13)",
 " (in 'inlining-fail2.stan', line 212, column 2 to column 27)",
 " (in 'inlining-fail2.stan', line 213, column 2 to column 27)",
 " (in 'inlining-fail2.stan', line 214, column 2 to column 30)",
 " (in 'inlining-fail2.stan', line 218, column 4 to column 14)",
 " (in 'inlining-fail2.stan', line 219, column 4 to column 13)",
 " (in 'inlining-fail2.stan', line 221, column 4 to column 38)",
 " (in 'inlining-fail2.stan', line 223, column 6 to column 32)",
 " (in 'inlining-fail2.stan', line 224, column 6 to column 55)",
 " (in 'inlining-fail2.stan', line 225, column 6 to column 35)",
 " (in 'inlining-fail2.stan', line 222, column 31 to line 226, column 5)",
 " (in 'inlining-fail2.stan', line 222, column 4 to line 226, column 5)",
 " (in 'inlining-fail2.stan', line 217, column 19 to line 227, column 3)",
 " (in 'inlining-fail2.stan', line 217, column 2 to line 227, column 3)",
 " (in 'inlining-fail2.stan', line 231, column 11 to column 22)",
 " (in 'inlining-fail2.stan', line 231, column 4 to column 49)",
 " (in 'inlining-fail2.stan', line 232, column 10 to column 11)",
 " (in 'inlining-fail2.stan', line 232, column 13 to column 24)",
 " (in 'inlining-fail2.stan', line 232, column 4 to column 69)",
 " (in 'inlining-fail2.stan', line 233, column 10 to column 11)",
 " (in 'inlining-fail2.stan', line 233, column 4 to column 22)",
 " (in 'inlining-fail2.stan', line 234, column 10 to column 11)",
 " (in 'inlining-fail2.stan', line 234, column 4 to column 24)",
 " (in 'inlining-fail2.stan', line 236, column 4 to column 27)",
 " (in 'inlining-fail2.stan', line 237, column 4 to column 21)",
 " (in 'inlining-fail2.stan', line 238, column 4 to column 20)",
 " (in 'inlining-fail2.stan', line 241, column 6 to column 39)",
 " (in 'inlining-fail2.stan', line 244, column 8 to column 26)",
 " (in 'inlining-fail2.stan', line 243, column 6 to line 244, column 26)",
 " (in 'inlining-fail2.stan', line 240, column 21 to line 245, column 5)",
 " (in 'inlining-fail2.stan', line 240, column 4 to line 245, column 5)",
 " (in 'inlining-fail2.stan', line 247, column 6 to column 28)",
 " (in 'inlining-fail2.stan', line 248, column 6 to column 34)",
 " (in 'inlining-fail2.stan', line 246, column 31 to line 249, column 5)",
 " (in 'inlining-fail2.stan', line 246, column 4 to line 249, column 5)",
 " (in 'inlining-fail2.stan', line 251, column 6 to column 26)",
 " (in 'inlining-fail2.stan', line 252, column 6 to column 31)",
 " (in 'inlining-fail2.stan', line 250, column 21 to line 253, column 5)",
 " (in 'inlining-fail2.stan', line 250, column 4 to line 253, column 5)",
 " (in 'inlining-fail2.stan', line 254, column 4 to column 25)",
 " (in 'inlining-fail2.stan', line 230, column 2 to line 255, column 3)",
 " (in 'inlining-fail2.stan', line 202, column 2 to column 29)",
 " (in 'inlining-fail2.stan', line 205, column 2 to column 53)",
 " (in 'inlining-fail2.stan', line 161, column 2 to column 17)",
 " (in 'inlining-fail2.stan', line 162, column 2 to column 27)",
 " (in 'inlining-fail2.stan', line 163, column 8 to column 9)",
 " (in 'inlining-fail2.stan', line 163, column 11 to column 22)",
 " (in 'inlining-fail2.stan', line 163, column 2 to column 48)",
 " (in 'inlining-fail2.stan', line 166, column 8 to column 9)",
 " (in 'inlining-fail2.stan', line 166, column 2 to column 49)",
 " (in 'inlining-fail2.stan', line 167, column 8 to column 9)",
 " (in 'inlining-fail2.stan', line 167, column 2 to column 48)",
 " (in 'inlining-fail2.stan', line 170, column 4 to column 35)",
 " (in 'inlining-fail2.stan', line 169, column 2 to line 170, column 35)",
 " (in 'inlining-fail2.stan', line 172, column 4 to column 33)",
 " (in 'inlining-fail2.stan', line 171, column 2 to line 172, column 33)",
 " (in 'inlining-fail2.stan', line 177, column 27 to column 38)",
 " (in 'inlining-fail2.stan', line 178, column 9 to column 24)",
 " (in 'inlining-fail2.stan', line 184, column 27 to column 28)",
 " (in 'inlining-fail2.stan', line 184, column 30 to column 45)",
 " (in 'inlining-fail2.stan', line 185, column 27 to column 28)",
 " (in 'inlining-fail2.stan', line 185, column 30 to column 41)",
 " (in 'inlining-fail2.stan', line 186, column 27 to column 28)",
 " (in 'inlining-fail2.stan', line 186, column 30 to column 41)",
 " (in 'inlining-fail2.stan', line 210, column 9 to column 20)",
 " (in 'inlining-fail2.stan', line 212, column 8 to column 19)",
 " (in 'inlining-fail2.stan', line 213, column 8 to column 19)",
 " (in 'inlining-fail2.stan', line 214, column 8 to column 9)",
 " (in 'inlining-fail2.stan', line 214, column 11 to column 22)",
 " (in 'inlining-fail2.stan', line 17, column 8 to column 17)",
 " (in 'inlining-fail2.stan', line 16, column 6 to line 17, column 17)",
 " (in 'inlining-fail2.stan', line 15, column 4 to line 17, column 17)",
 " (in 'inlining-fail2.stan', line 18, column 4 to column 13)",
 " (in 'inlining-fail2.stan', line 14, column 37 to line 19, column 3)",
 " (in 'inlining-fail2.stan', line 30, column 6 to column 32)",
 " (in 'inlining-fail2.stan', line 33, column 8 to column 17)",
 " (in 'inlining-fail2.stan', line 32, column 6 to line 33, column 17)",
 " (in 'inlining-fail2.stan', line 29, column 39 to line 34, column 5)",
 " (in 'inlining-fail2.stan', line 29, column 4 to line 34, column 5)",
 " (in 'inlining-fail2.stan', line 35, column 4 to column 13)",
 " (in 'inlining-fail2.stan', line 28, column 36 to line 36, column 3)",
 " (in 'inlining-fail2.stan', line 49, column 4 to column 24)",
 " (in 'inlining-fail2.stan', line 50, column 4 to column 30)",
 " (in 'inlining-fail2.stan', line 51, column 11 to column 16)",
 " (in 'inlining-fail2.stan', line 51, column 18 to column 29)",
 " (in 'inlining-fail2.stan', line 51, column 4 to column 35)",
 " (in 'inlining-fail2.stan', line 54, column 6 to column 32)",
 " (in 'inlining-fail2.stan', line 56, column 8 to column 37)",
 " (in 'inlining-fail2.stan', line 57, column 8 to column 32)",
 " (in 'inlining-fail2.stan', line 59, column 8 to line 61, column 44)",
 " (in 'inlining-fail2.stan', line 55, column 39 to line 62, column 7)",
 " (in 'inlining-fail2.stan', line 55, column 6 to line 62, column 7)",
 " (in 'inlining-fail2.stan', line 53, column 25 to line 63, column 5)",
 " (in 'inlining-fail2.stan', line 53, column 4 to line 63, column 5)",
 " (in 'inlining-fail2.stan', line 64, column 4 to column 15)",
 " (in 'inlining-fail2.stan', line 48, column 47 to line 65, column 3)",
 " (in 'inlining-fail2.stan', line 80, column 4 to column 27)",
 " (in 'inlining-fail2.stan', line 81, column 4 to column 33)",
 " (in 'inlining-fail2.stan', line 82, column 11 to column 22)",
 " (in 'inlining-fail2.stan', line 82, column 4 to column 45)",
 " (in 'inlining-fail2.stan', line 85, column 13 to column 24)",
 " (in 'inlining-fail2.stan', line 85, column 6 to column 43)",
 " (in 'inlining-fail2.stan', line 121, column 15 to column 30)",
 " (in 'inlining-fail2.stan', line 121, column 8 to column 35)",
 " (in 'inlining-fail2.stan', line 124, column 8 to line 125, column 48)",
 " (in 'inlining-fail2.stan', line 128, column 10 to line 131, column 50)",
 " (in 'inlining-fail2.stan', line 127, column 8 to line 131, column 50)",
 " (in 'inlining-fail2.stan', line 133, column 8 to column 63)",
 " (in 'inlining-fail2.stan', line 134, column 8 to column 34)",
 " (in 'inlining-fail2.stan', line 119, column 13 to line 135, column 7)",
 " (in 'inlining-fail2.stan', line 93, column 17 to column 25)",
 " (in 'inlining-fail2.stan', line 93, column 10 to column 30)",
 " (in 'inlining-fail2.stan', line 96, column 10 to line 99, column 55)",
 " (in 'inlining-fail2.stan', line 102, column 12 to line 106, column 57)",
 " (in 'inlining-fail2.stan', line 101, column 10 to line 106, column 57)",
 " (in 'inlining-fail2.stan', line 107, column 10 to line 109, column 62)",
 " (in 'inlining-fail2.stan', line 110, column 10 to column 36)",
 " (in 'inlining-fail2.stan', line 92, column 15 to line 111, column 9)",
 " (in 'inlining-fail2.stan', line 91, column 10 to column 44)",
 " (in 'inlining-fail2.stan', line 90, column 27 to line 92, column 9)",
 " (in 'inlining-fail2.stan', line 90, column 8 to line 111, column 9)",
 " (in 'inlining-fail2.stan', line 114, column 10 to column 39)",
 " (in 'inlining-fail2.stan', line 115, column 10 to column 39)",
 " (in 'inlining-fail2.stan', line 113, column 44 to line 116, column 9)",
 " (in 'inlining-fail2.stan', line 113, column 8 to line 116, column 9)",
 " (in 'inlining-fail2.stan', line 118, column 8 to column 39)",
 " (in 'inlining-fail2.stan', line 87, column 20 to line 119, column 7)",
 " (in 'inlining-fail2.stan', line 87, column 6 to line 135, column 7)",
 " (in 'inlining-fail2.stan', line 84, column 25 to line 136, column 5)",
 " (in 'inlining-fail2.stan', line 84, column 4 to line 136, column 5)",
 " (in 'inlining-fail2.stan', line 79, column 70 to line 137, column 3)",
 " (in 'inlining-fail2.stan', line 149, column 4 to column 24)",
 " (in 'inlining-fail2.stan', line 150, column 11 to column 12)",
 " (in 'inlining-fail2.stan', line 150, column 4 to column 24)",
 " (in 'inlining-fail2.stan', line 151, column 4 to column 31)",
 " (in 'inlining-fail2.stan', line 154, column 6 to column 55)",
 " (in 'inlining-fail2.stan', line 155, column 6 to column 64)",
 " (in 'inlining-fail2.stan', line 153, column 21 to line 156, column 5)",
 " (in 'inlining-fail2.stan', line 153, column 4 to line 156, column 5)",
 " (in 'inlining-fail2.stan', line 157, column 4 to column 26)",
 " (in 'inlining-fail2.stan', line 148, column 33 to line 158, column 3)"};

struct jolly_seber_lp_functor__ {
  template <bool propto__, typename T3__, typename T4__, typename T5__,
            typename T6__, typename T_lp__, typename T_lp_accum__,
            stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T4__>* = nullptr,
            stan::require_col_vector_t<T5__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T6__>* = nullptr>
  void
  operator()(const std::vector<std::vector<int>>& y,
             const std::vector<int>& first, const std::vector<int>& last,
             const T3__& p, const T4__& phi, const T5__& gamma,
             const T6__& chi, T_lp__& lp__, T_lp_accum__& lp_accum__,
             std::ostream* pstream__) const;
};
struct last_capture_functor__ {
  int
  operator()(const std::vector<int>& y_i, std::ostream* pstream__) const;
};
struct seq_cprob_functor__ {
  template <typename T0__, stan::require_col_vector_t<T0__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
  operator()(const T0__& gamma, std::ostream* pstream__) const;
};
struct first_capture_functor__ {
  int
  operator()(const std::vector<int>& y_i, std::ostream* pstream__) const;
};
struct prob_uncaptured_functor__ {
  template <typename T0__, typename T1__,
            stan::require_eigen_matrix_dynamic_t<T0__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T1__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>>, -1, -1>
  operator()(const T0__& p, const T1__& phi, std::ostream* pstream__) const;
};

int first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 88;
      for (int k = 1; k <= stan::math::size(y_i); ++k) {
        current_statement__ = 87;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
          current_statement__ = 86;
          return k;
        } 
      }
      current_statement__ = 89;
      return 0;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 95;
      for (int k_rev = 0; k_rev <= (stan::math::size(y_i) - 1); ++k_rev) {
        int k = std::numeric_limits<int>::min();
        current_statement__ = 91;
        k = (stan::math::size(y_i) - k_rev);
        current_statement__ = 93;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
          current_statement__ = 92;
          return k;
        } 
      }
      current_statement__ = 96;
      return 0;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, typename T1__,
          stan::require_eigen_matrix_dynamic_t<T0__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T1__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>>, -1, -1>
  prob_uncaptured(const T0__& p_arg__, const T1__& phi_arg__,
                  std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<stan::value_type_t<T0__>,
                                 stan::value_type_t<T1__>>;
    int current_statement__ = 0; 
    const auto& p = stan::math::to_ref(p_arg__);
    const auto& phi = stan::math::to_ref(phi_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int n_ind = std::numeric_limits<int>::min();
      current_statement__ = 98;
      n_ind = stan::math::rows(p);
      int n_occasions = std::numeric_limits<int>::min();
      current_statement__ = 99;
      n_occasions = stan::math::cols(p);
      current_statement__ = 100;
      stan::math::validate_non_negative_index("chi", "n_ind", n_ind);
      current_statement__ = 101;
      stan::math::validate_non_negative_index("chi", "n_occasions",
                                              n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(n_ind,
           n_occasions, DUMMY_VAR__);
      current_statement__ = 110;
      for (int i = 1; i <= n_ind; ++i) {
        current_statement__ = 103;
        stan::model::assign(chi, 1.0,
          "assigning variable chi", stan::model::index_uni(i),
                                      stan::model::index_uni(n_occasions));
        current_statement__ = 108;
        for (int t = 1; t <= (n_occasions - 1); ++t) {
          int t_curr = std::numeric_limits<int>::min();
          current_statement__ = 104;
          t_curr = (n_occasions - t);
          int t_next = std::numeric_limits<int>::min();
          current_statement__ = 105;
          t_next = (t_curr + 1);
          current_statement__ = 106;
          stan::model::assign(chi,
            ((1 -
               stan::model::rvalue(phi, "phi",
                 stan::model::index_uni(i), stan::model::index_uni(t_curr)))
              +
              ((stan::model::rvalue(phi, "phi",
                  stan::model::index_uni(i), stan::model::index_uni(t_curr))
                 *
                 (1 -
                   stan::model::rvalue(p, "p",
                     stan::model::index_uni(i),
                       stan::model::index_uni(t_next)))) *
                stan::model::rvalue(chi, "chi",
                  stan::model::index_uni(i), stan::model::index_uni(t_next)))),
            "assigning variable chi", stan::model::index_uni(i),
                                        stan::model::index_uni(t_curr));
        }
      }
      current_statement__ = 111;
      return chi;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <bool propto__, typename T3__, typename T4__, typename T5__,
          typename T6__, typename T_lp__, typename T_lp_accum__,
          stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T4__>* = nullptr,
          stan::require_col_vector_t<T5__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T6__>* = nullptr> void
  jolly_seber_lp(const std::vector<std::vector<int>>& y,
                 const std::vector<int>& first, const std::vector<int>& last,
                 const T3__& p_arg__, const T4__& phi_arg__,
                 const T5__& gamma_arg__, const T6__& chi_arg__,
                 T_lp__& lp__, T_lp_accum__& lp_accum__,
                 std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<stan::value_type_t<T3__>,
                                 stan::value_type_t<T4__>,
                                 stan::value_type_t<T5__>,
                                 stan::value_type_t<T6__>>;
    int current_statement__ = 0; 
    const auto& p = stan::math::to_ref(p_arg__);
    const auto& phi = stan::math::to_ref(phi_arg__);
    const auto& gamma = stan::math::to_ref(gamma_arg__);
    const auto& chi = stan::math::to_ref(chi_arg__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int n_ind = std::numeric_limits<int>::min();
      current_statement__ = 113;
      n_ind = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                stan::model::index_uni(1));
      int n_occasions = std::numeric_limits<int>::min();
      current_statement__ = 114;
      n_occasions = stan::model::rvalue(stan::math::dims(y), "dims(y)",
                      stan::model::index_uni(2));
      current_statement__ = 115;
      stan::math::validate_non_negative_index("qgamma", "n_occasions",
                                              n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> qgamma =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_occasions,
           DUMMY_VAR__);
      current_statement__ = 116;
      stan::model::assign(qgamma, stan::math::subtract(1.0, gamma),
        "assigning variable qgamma");
      current_statement__ = 146;
      for (int i = 1; i <= n_ind; ++i) {
        current_statement__ = 117;
        stan::math::validate_non_negative_index("qp", "n_occasions",
                                                n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, 1> qp =
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_occasions,
             DUMMY_VAR__);
        current_statement__ = 118;
        stan::model::assign(qp,
          stan::math::subtract(1.0,
            stan::math::transpose(
              stan::model::rvalue(p, "p", stan::model::index_uni(i)))),
          "assigning variable qp");
        current_statement__ = 144;
        if (stan::model::rvalue(first, "first", stan::model::index_uni(i))) {
          current_statement__ = 137;
          if (stan::math::logical_eq(
                stan::model::rvalue(first, "first",
                  stan::model::index_uni(i)), 1)) {
            current_statement__ = 135;
            lp_accum__.add(
              stan::math::bernoulli_lpmf<propto__>(1,
                (stan::model::rvalue(gamma, "gamma",
                   stan::model::index_uni(1)) *
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(i), stan::model::index_uni(1)))));
          } else {
            current_statement__ = 127;
            stan::math::validate_non_negative_index("lp", "first[i]",
                                                    stan::model::rvalue(
                                                      first, "first",
                                                      stan::model::index_uni(i)));
            Eigen::Matrix<local_scalar_t__, -1, 1> lp =
               Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(
                 stan::model::rvalue(first, "first",
                   stan::model::index_uni(i)), DUMMY_VAR__);
            current_statement__ = 129;
            stan::model::assign(lp,
              (((stan::math::bernoulli_lpmf<false>(1,
                   stan::model::rvalue(gamma, "gamma",
                     stan::model::index_uni(1))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::math::prod(
                      stan::model::rvalue(qp, "qp",
                        stan::model::index_min_max(1, (stan::model::rvalue(
                                                         first, "first",
                                                         stan::model::index_uni(i))
                                                        - 1)))))) +
                 stan::math::bernoulli_lpmf<false>(1,
                   stan::math::prod(
                     stan::model::rvalue(phi, "phi",
                       stan::model::index_uni(i),
                         stan::model::index_min_max(1, (stan::model::rvalue(
                                                          first, "first",
                                                          stan::model::index_uni(i))
                                                         - 1)))))) +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(i),
                      stan::model::index_uni(stan::model::rvalue(first,
                                               "first",
                                               stan::model::index_uni(i)))))),
              "assigning variable lp", stan::model::index_uni(1));
            current_statement__ = 131;
            for (int t = 2;
                 t <= (stan::model::rvalue(first, "first",
                         stan::model::index_uni(i)) - 1);
                 ++t) {
              current_statement__ = 130;
              stan::model::assign(lp,
                ((((stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(qgamma, "qgamma",
                          stan::model::index_min_max(1, (t - 1))))) +
                     stan::math::bernoulli_lpmf<false>(1,
                       stan::model::rvalue(gamma, "gamma",
                         stan::model::index_uni(t)))) +
                    stan::math::bernoulli_lpmf<false>(1,
                      stan::math::prod(
                        stan::model::rvalue(qp, "qp",
                          stan::model::index_min_max(t, (stan::model::rvalue(
                                                           first, "first",
                                                           stan::model::index_uni(i))
                                                          - 1)))))) +
                   stan::math::bernoulli_lpmf<false>(1,
                     stan::math::prod(
                       stan::model::rvalue(phi, "phi",
                         stan::model::index_uni(i),
                           stan::model::index_min_max(t, (stan::model::rvalue(
                                                            first, "first",
                                                            stan::model::index_uni(i))
                                                           - 1)))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(p, "p",
                      stan::model::index_uni(i),
                        stan::model::index_uni(stan::model::rvalue(first,
                                                 "first",
                                                 stan::model::index_uni(i)))))),
                "assigning variable lp", stan::model::index_uni(t));
            }
            current_statement__ = 132;
            stan::model::assign(lp,
              ((stan::math::bernoulli_lpmf<false>(1,
                  stan::math::prod(
                    stan::model::rvalue(qgamma, "qgamma",
                      stan::model::index_min_max(1, (stan::model::rvalue(
                                                       first, "first",
                                                       stan::model::index_uni(i))
                                                      - 1))))) +
                 stan::math::bernoulli_lpmf<false>(1,
                   stan::model::rvalue(gamma, "gamma",
                     stan::model::index_uni(stan::model::rvalue(first,
                                              "first",
                                              stan::model::index_uni(i))))))
                +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(i),
                      stan::model::index_uni(stan::model::rvalue(first,
                                               "first",
                                               stan::model::index_uni(i)))))),
              "assigning variable lp", stan::model::index_uni(stan::model::rvalue(
                                                                first,
                                                                "first",
                                                                stan::model::index_uni(i))));
            current_statement__ = 133;
            lp_accum__.add(stan::math::log_sum_exp(lp));
          }
          current_statement__ = 141;
          for (int t = (stan::model::rvalue(first, "first",
                          stan::model::index_uni(i)) + 1);
               t <= stan::model::rvalue(last, "last",
                      stan::model::index_uni(i));
               ++t) {
            current_statement__ = 138;
            lp_accum__.add(
              stan::math::bernoulli_lpmf<propto__>(1,
                stan::model::rvalue(phi, "phi",
                  stan::model::index_uni(i), stan::model::index_uni((t - 1)))));
            current_statement__ = 139;
            lp_accum__.add(
              stan::math::bernoulli_lpmf<propto__>(
                stan::model::rvalue(y, "y",
                  stan::model::index_uni(i), stan::model::index_uni(t)),
                stan::model::rvalue(p, "p",
                  stan::model::index_uni(i), stan::model::index_uni(t))));
          }
          current_statement__ = 142;
          lp_accum__.add(
            stan::math::bernoulli_lpmf<propto__>(1,
              stan::model::rvalue(chi, "chi",
                stan::model::index_uni(i),
                  stan::model::index_uni(stan::model::rvalue(last, "last",
                                           stan::model::index_uni(i))))));
        } else {
          current_statement__ = 119;
          stan::math::validate_non_negative_index("lp", "n_occasions + 1",
                                                  (n_occasions + 1));
          Eigen::Matrix<local_scalar_t__, -1, 1> lp =
             Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(
               (n_occasions + 1), DUMMY_VAR__);
          current_statement__ = 121;
          stan::model::assign(lp,
            ((stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(gamma, "gamma",
                  stan::model::index_uni(1))) +
               stan::math::bernoulli_lpmf<false>(0,
                 stan::model::rvalue(p, "p",
                   stan::model::index_uni(i), stan::model::index_uni(1)))) +
              stan::math::bernoulli_lpmf<false>(1,
                stan::model::rvalue(chi, "chi",
                  stan::model::index_uni(i), stan::model::index_uni(1)))),
            "assigning variable lp", stan::model::index_uni(1));
          current_statement__ = 123;
          for (int t = 2; t <= n_occasions; ++t) {
            current_statement__ = 122;
            stan::model::assign(lp,
              (((stan::math::bernoulli_lpmf<false>(1,
                   stan::math::prod(
                     stan::model::rvalue(qgamma, "qgamma",
                       stan::model::index_min_max(1, (t - 1))))) +
                  stan::math::bernoulli_lpmf<false>(1,
                    stan::model::rvalue(gamma, "gamma",
                      stan::model::index_uni(t)))) +
                 stan::math::bernoulli_lpmf<false>(0,
                   stan::model::rvalue(p, "p",
                     stan::model::index_uni(i), stan::model::index_uni(t))))
                +
                stan::math::bernoulli_lpmf<false>(1,
                  stan::model::rvalue(chi, "chi",
                    stan::model::index_uni(i), stan::model::index_uni(t)))),
              "assigning variable lp", stan::model::index_uni(t));
          }
          current_statement__ = 124;
          stan::model::assign(lp,
            stan::math::bernoulli_lpmf<false>(1, stan::math::prod(qgamma)),
            "assigning variable lp", stan::model::index_uni((n_occasions + 1)));
          current_statement__ = 125;
          lp_accum__.add(stan::math::log_sum_exp(lp));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, stan::require_col_vector_t<T0__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
  seq_cprob(const T0__& gamma_arg__, std::ostream* pstream__) {
    using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
    int current_statement__ = 0; 
    const auto& gamma = stan::math::to_ref(gamma_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int N = std::numeric_limits<int>::min();
      current_statement__ = 148;
      N = stan::math::rows(gamma);
      current_statement__ = 149;
      stan::math::validate_non_negative_index("log_cprob", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> log_cprob =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      local_scalar_t__ log_residual_prob = DUMMY_VAR__;
      current_statement__ = 151;
      log_residual_prob = 0;
      current_statement__ = 155;
      for (int n = 1; n <= N; ++n) {
        current_statement__ = 152;
        stan::model::assign(log_cprob,
          (stan::math::log(
             stan::model::rvalue(gamma, "gamma", stan::model::index_uni(n)))
            + log_residual_prob),
          "assigning variable log_cprob", stan::model::index_uni(n));
        current_statement__ = 153;
        log_residual_prob = (log_residual_prob +
                              stan::math::log(
                                (1 -
                                  stan::model::rvalue(gamma, "gamma",
                                    stan::model::index_uni(n)))));
      }
      current_statement__ = 156;
      return stan::math::exp(log_cprob);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <bool propto__, typename T3__, typename T4__, typename T5__,
          typename T6__, typename T_lp__, typename T_lp_accum__,
          stan::require_eigen_matrix_dynamic_t<T3__>*,
          stan::require_eigen_matrix_dynamic_t<T4__>*,
          stan::require_col_vector_t<T5__>*,
          stan::require_eigen_matrix_dynamic_t<T6__>*>
void
jolly_seber_lp_functor__::operator()(const std::vector<std::vector<int>>& y,
                                     const std::vector<int>& first,
                                     const std::vector<int>& last,
                                     const T3__& p, const T4__& phi,
                                     const T5__& gamma, const T6__& chi,
                                     T_lp__& lp__, T_lp_accum__& lp_accum__,
                                     std::ostream* pstream__)  const
{
  return jolly_seber_lp<propto__>(y, first, last, p, phi, gamma, chi, lp__,
           lp_accum__, pstream__);
}

int
last_capture_functor__::operator()(const std::vector<int>& y_i,
                                   std::ostream* pstream__)  const
{
  return last_capture(y_i, pstream__);
}

template <typename T0__, stan::require_col_vector_t<T0__>*>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
seq_cprob_functor__::operator()(const T0__& gamma, std::ostream* pstream__) 
const
{
  return seq_cprob(gamma, pstream__);
}

int
first_capture_functor__::operator()(const std::vector<int>& y_i,
                                    std::ostream* pstream__)  const
{
  return first_capture(y_i, pstream__);
}

template <typename T0__, typename T1__,
          stan::require_eigen_matrix_dynamic_t<T0__>*,
          stan::require_eigen_matrix_dynamic_t<T1__>*>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>>, -1, -1>
prob_uncaptured_functor__::operator()(const T0__& p, const T1__& phi,
                                      std::ostream* pstream__)  const
{
  return prob_uncaptured(p, phi, pstream__);
}


class inlining_fail2_model final : public model_base_crtp<inlining_fail2_model> {

 private:
  int M;
  int n_occasions;
  std::vector<std::vector<int>> y;
  std::vector<int> first;
  std::vector<int> last;
  int epsilon_1dim__;
  int phi_2dim__; 
  
 
 public:
  ~inlining_fail2_model() { }
  
  inline std::string model_name() const final { return "inlining_fail2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  inlining_fail2_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "inlining_fail2_model_namespace::inlining_fail2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 60;
      context__.validate_dims("data initialization","M","int",
           std::vector<size_t>{});
      M = std::numeric_limits<int>::min();
      
      
      current_statement__ = 60;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 60;
      stan::math::check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 61;
      context__.validate_dims("data initialization","n_occasions","int",
           std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      
      
      current_statement__ = 61;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 61;
      stan::math::check_greater_or_equal(function__, "n_occasions",
                                            n_occasions, 0);
      current_statement__ = 62;
      stan::math::validate_non_negative_index("y", "M", M);
      current_statement__ = 63;
      stan::math::validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 64;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(M),
            static_cast<size_t>(n_occasions)});
      y = 
        std::vector<std::vector<int>>(M, 
          std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 64;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 64;
        pos__ = 1;
        current_statement__ = 64;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 64;
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            current_statement__ = 64;
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
            current_statement__ = 64;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 64;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 64;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 65;
      stan::math::validate_non_negative_index("first", "M", M);
      current_statement__ = 66;
      first = std::vector<int>(M, std::numeric_limits<int>::min());
      
      
      current_statement__ = 67;
      stan::math::validate_non_negative_index("last", "M", M);
      current_statement__ = 68;
      last = std::vector<int>(M, std::numeric_limits<int>::min());
      
      
      current_statement__ = 70;
      for (int i = 1; i <= M; ++i) {
        current_statement__ = 69;
        stan::model::assign(first,
          first_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(i)), pstream__),
          "assigning variable first", stan::model::index_uni(i));
      }
      current_statement__ = 72;
      for (int i = 1; i <= M; ++i) {
        current_statement__ = 71;
        stan::model::assign(last,
          last_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(i)), pstream__),
          "assigning variable last", stan::model::index_uni(i));
      }
      current_statement__ = 66;
      stan::math::check_greater_or_equal(function__, "first", first, 0);
      current_statement__ = 66;
      stan::math::check_less_or_equal(function__, "first", first, n_occasions);
      current_statement__ = 68;
      stan::math::check_greater_or_equal(function__, "last", last, 0);
      current_statement__ = 68;
      stan::math::check_less_or_equal(function__, "last", last, n_occasions);
      current_statement__ = 73;
      stan::math::validate_non_negative_index("gamma", "n_occasions",
                                              n_occasions);
      current_statement__ = 74;
      epsilon_1dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 74;
      epsilon_1dim__ = (n_occasions - 1);
      current_statement__ = 74;
      stan::math::validate_non_negative_index("epsilon", "n_occasions - 1",
                                              epsilon_1dim__);
      current_statement__ = 75;
      stan::math::validate_non_negative_index("phi", "M", M);
      current_statement__ = 76;
      phi_2dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 76;
      phi_2dim__ = (n_occasions - 1);
      current_statement__ = 76;
      stan::math::validate_non_negative_index("phi", "n_occasions - 1",
                                              phi_2dim__);
      current_statement__ = 77;
      stan::math::validate_non_negative_index("p", "M", M);
      current_statement__ = 78;
      stan::math::validate_non_negative_index("p", "n_occasions", n_occasions);
      current_statement__ = 79;
      stan::math::validate_non_negative_index("chi", "M", M);
      current_statement__ = 80;
      stan::math::validate_non_negative_index("chi", "n_occasions",
                                              n_occasions);
      current_statement__ = 81;
      stan::math::validate_non_negative_index("b", "n_occasions", n_occasions);
      current_statement__ = 82;
      stan::math::validate_non_negative_index("N", "n_occasions", n_occasions);
      current_statement__ = 83;
      stan::math::validate_non_negative_index("B", "n_occasions", n_occasions);
      current_statement__ = 84;
      stan::math::validate_non_negative_index("z", "M", M);
      current_statement__ = 85;
      stan::math::validate_non_negative_index("z", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + n_occasions + epsilon_1dim__ + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "inlining_fail2_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ mean_phi = DUMMY_VAR__;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ mean_p = DUMMY_VAR__;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, 
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> gamma =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_occasions,
           DUMMY_VAR__);
      current_statement__ = 3;
      gamma = in__.template read_constrain_lub<
                Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(0, 1,
                lp__, n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(epsilon_1dim__,
           DUMMY_VAR__);
      current_statement__ = 4;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  epsilon_1dim__);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 5;
      sigma = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 5, lp__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(M, phi_2dim__,
           DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(M, n_occasions,
           DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(M, n_occasions,
           DUMMY_VAR__);
      current_statement__ = 11;
      for (int t = 1; t <= (n_occasions - 1); ++t) {
        current_statement__ = 10;
        for (int i = 1; i <= M; ++i) {
          current_statement__ = 9;
          stan::model::assign(phi,
            stan::math::inv_logit(
              (stan::math::logit(mean_phi) +
                stan::model::rvalue(epsilon, "epsilon",
                  stan::model::index_uni(t)))),
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
        }
      }
      current_statement__ = 12;
      stan::model::assign(p, stan::math::rep_matrix(mean_p, M, n_occasions),
        "assigning variable p");
      current_statement__ = 13;
      stan::model::assign(chi, prob_uncaptured(p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 6;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 6;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "chi", chi, 0);
      current_statement__ = 8;
      stan::math::check_less_or_equal(function__, "chi", chi, 1);
      {
        current_statement__ = 58;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(epsilon, 0, sigma));
        current_statement__ = 59;
        jolly_seber_lp<propto__>(y, first, last, p, phi, gamma,
          chi, lp__, lp_accum__, pstream__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "inlining_fail2_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double mean_phi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 1, lp__);
      double mean_p = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, 
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<double, -1, 1> gamma =
         Eigen::Matrix<double, -1, 1>::Constant(n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      gamma = in__.template read_constrain_lub<
                Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(0, 1,
                lp__, n_occasions);
      Eigen::Matrix<double, -1, 1> epsilon =
         Eigen::Matrix<double, -1, 1>::Constant(epsilon_1dim__,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 4;
      epsilon = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  epsilon_1dim__);
      double sigma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      sigma = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(
                0, 5, lp__);
      Eigen::Matrix<double, -1, -1> phi =
         Eigen::Matrix<double, -1, -1>::Constant(M, phi_2dim__,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> p =
         Eigen::Matrix<double, -1, -1>::Constant(M, n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> chi =
         Eigen::Matrix<double, -1, -1>::Constant(M, n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(mean_phi);
      out__.write(mean_p);
      out__.write(gamma);
      out__.write(epsilon);
      out__.write(sigma);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 11;
      for (int t = 1; t <= (n_occasions - 1); ++t) {
        current_statement__ = 10;
        for (int i = 1; i <= M; ++i) {
          current_statement__ = 9;
          stan::model::assign(phi,
            stan::math::inv_logit(
              (stan::math::logit(mean_phi) +
                stan::model::rvalue(epsilon, "epsilon",
                  stan::model::index_uni(t)))),
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
        }
      }
      current_statement__ = 12;
      stan::model::assign(p, stan::math::rep_matrix(mean_p, M, n_occasions),
        "assigning variable p");
      current_statement__ = 13;
      stan::model::assign(chi, prob_uncaptured(p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 6;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 6;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 7;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "chi", chi, 0);
      current_statement__ = 8;
      stan::math::check_less_or_equal(function__, "chi", chi, 1);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(chi);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double sigma2 = std::numeric_limits<double>::quiet_NaN();
      double psi = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double, -1, 1> b =
         Eigen::Matrix<double, -1, 1>::Constant(n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      int Nsuper = std::numeric_limits<int>::min();
      std::vector<int> N =
         std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      std::vector<int> B =
         std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      std::vector<std::vector<int>> z =
         std::vector<std::vector<int>>(M, 
           std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      current_statement__ = 30;
      for (int i = 1; i <= M; ++i) {
        int q = std::numeric_limits<int>::min();
        current_statement__ = 21;
        q = 1;
        double mu2 = std::numeric_limits<double>::quiet_NaN();
        current_statement__ = 23;
        stan::model::assign(z,
          stan::math::bernoulli_rng(
            stan::model::rvalue(gamma, "gamma", stan::model::index_uni(1)),
            base_rng__),
          "assigning variable z", stan::model::index_uni(i),
                                    stan::model::index_uni(1));
        current_statement__ = 28;
        for (int t = 2; t <= n_occasions; ++t) {
          current_statement__ = 24;
          q = (q *
                (1 -
                  stan::model::rvalue(z, "z",
                    stan::model::index_uni(i),
                      stan::model::index_uni((t - 1)))));
          current_statement__ = 25;
          mu2 = ((stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(i),
                      stan::model::index_uni((t - 1))) *
                   stan::model::rvalue(z, "z",
                     stan::model::index_uni(i),
                       stan::model::index_uni((t - 1)))) +
                  (stan::model::rvalue(gamma, "gamma",
                     stan::model::index_uni(t)) * q));
          current_statement__ = 26;
          stan::model::assign(z, stan::math::bernoulli_rng(mu2, base_rng__),
            "assigning variable z", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
      }
      {
        current_statement__ = 31;
        stan::math::validate_non_negative_index("cprob", "n_occasions",
                                                n_occasions);
        Eigen::Matrix<double, -1, 1> cprob =
           Eigen::Matrix<double, -1, 1>::Constant(n_occasions,
             std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 32;
        stan::model::assign(cprob, seq_cprob(gamma, pstream__),
          "assigning variable cprob");
        current_statement__ = 33;
        stan::math::validate_non_negative_index("recruit", "M", M);
        current_statement__ = 34;
        stan::math::validate_non_negative_index("recruit", "n_occasions",
                                                n_occasions);
        std::vector<std::vector<int>> recruit =
           std::vector<std::vector<int>>(M, 
             std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
        current_statement__ = 35;
        stan::model::assign(recruit,
          stan::math::rep_array(0, M, n_occasions),
          "assigning variable recruit");
        current_statement__ = 36;
        stan::math::validate_non_negative_index("Nind", "M", M);
        std::vector<int> Nind =
           std::vector<int>(M, std::numeric_limits<int>::min());
        current_statement__ = 38;
        stan::math::validate_non_negative_index("Nalive", "M", M);
        std::vector<int> Nalive =
           std::vector<int>(M, std::numeric_limits<int>::min());
        current_statement__ = 40;
        sigma2 = stan::math::square(sigma);
        current_statement__ = 41;
        psi = stan::math::sum(cprob);
        current_statement__ = 42;
        stan::model::assign(b, stan::math::divide(cprob, psi),
          "assigning variable b");
        current_statement__ = 47;
        for (int i = 1; i <= M; ++i) {
          int f = std::numeric_limits<int>::min();
          current_statement__ = 43;
          f = first_capture(
                stan::model::rvalue(z, "z",
                  stan::model::index_uni(i), stan::model::index_omni()), pstream__);
          current_statement__ = 45;
          if (stan::math::logical_gt(f, 0)) {
            current_statement__ = 44;
            stan::model::assign(recruit, 1,
              "assigning variable recruit", stan::model::index_uni(i),
                                              stan::model::index_uni(f));
          } 
        }
        current_statement__ = 51;
        for (int t = 1; t <= n_occasions; ++t) {
          current_statement__ = 48;
          stan::model::assign(N,
            stan::math::sum(
              stan::model::rvalue(z, "z",
                stan::model::index_omni(), stan::model::index_uni(t))),
            "assigning variable N", stan::model::index_uni(t));
          current_statement__ = 49;
          stan::model::assign(B,
            stan::math::sum(
              stan::model::rvalue(recruit, "recruit",
                stan::model::index_omni(), stan::model::index_uni(t))),
            "assigning variable B", stan::model::index_uni(t));
        }
        current_statement__ = 55;
        for (int i = 1; i <= M; ++i) {
          current_statement__ = 52;
          stan::model::assign(Nind,
            stan::math::sum(
              stan::model::rvalue(z, "z", stan::model::index_uni(i))),
            "assigning variable Nind", stan::model::index_uni(i));
          current_statement__ = 53;
          stan::model::assign(Nalive,
            (1 -
              stan::math::logical_negation(
                stan::model::rvalue(Nind, "Nind", stan::model::index_uni(i)))),
            "assigning variable Nalive", stan::model::index_uni(i));
        }
        current_statement__ = 56;
        Nsuper = stan::math::sum(Nalive);
      }
      out__.write(sigma2);
      out__.write(psi);
      out__.write(b);
      out__.write(Nsuper);
      out__.write(N);
      out__.write(B);
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          out__.write(z[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ mean_phi = DUMMY_VAR__;
      mean_phi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p = DUMMY_VAR__;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
      Eigen::Matrix<local_scalar_t__, -1, 1> gamma =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_occasions,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        stan::model::assign(gamma, in__.read<local_scalar_t__>(),
          "assigning variable gamma", stan::model::index_uni(sym1__));
      }
      out__.write_free_lub(0, 1, gamma);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(epsilon_1dim__,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= epsilon_1dim__; ++sym1__) {
        stan::model::assign(epsilon, in__.read<local_scalar_t__>(),
          "assigning variable epsilon", stan::model::index_uni(sym1__));
      }
      out__.write(epsilon);
      local_scalar_t__ sigma = DUMMY_VAR__;
      sigma = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 5, sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mean_phi", "mean_p", "gamma",
      "epsilon", "sigma", "phi", "p", "chi", "sigma2", "psi", "b", "Nsuper",
      "N", "B", "z"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(epsilon_1dim__)},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(phi_2dim__)},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(n_occasions)},
      std::vector<size_t>{}, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(n_occasions)},
      std::vector<size_t>{static_cast<size_t>(M),
                          static_cast<size_t>(n_occasions)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "gamma" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= epsilon_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= phi_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "psi");
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
        } 
      }
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "N" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "B" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "gamma" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= epsilon_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= phi_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "psi");
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
        } 
      }
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "N" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "B" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(epsilon_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(phi_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(epsilon_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(phi_2dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(M) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_occasions) + "},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(M) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_occasions) + ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((1 + 1) + n_occasions) + epsilon_1dim__) + 1);
      const size_t num_transformed = 
  (((M * phi_2dim__) + (M * n_occasions)) + (M * n_occasions));
      const size_t num_gen_quantities = 
  ((((((1 + 1) + n_occasions) + 1) + n_occasions) + n_occasions) +
    (M * n_occasions));
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((1 + 1) + n_occasions) + epsilon_1dim__) + 1);
      const size_t num_transformed = 
  (((M * phi_2dim__) + (M * n_occasions)) + (M * n_occasions));
      const size_t num_gen_quantities = 
  ((((((1 + 1) + n_occasions) + 1) + n_occasions) + n_occasions) +
    (M * n_occasions));
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 5> names__{"mean_phi", "mean_p",
      "gamma", "epsilon", "sigma"};
      const std::array<Eigen::Index, 5> constrain_param_sizes__{1, 1,
       n_occasions, epsilon_1dim__, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } 
using stan_model = inlining_fail2_model_namespace::inlining_fail2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return inlining_fail2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 lcm-experiment.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_experiment_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 8> locations_array__ = 
{" (found before start of program)",
 " (in 'lcm-experiment.stan', line 2, column 2 to column 8)",
 " (in 'lcm-experiment.stan', line 5, column 2 to column 13)",
 " (in 'lcm-experiment.stan', line 6, column 2 to column 9)",
 " (in 'lcm-experiment.stan', line 8, column 4 to column 27)",
 " (in 'lcm-experiment.stan', line 9, column 4 to column 35)",
 " (in 'lcm-experiment.stan', line 7, column 2 to line 10, column 3)",
 " (in 'lcm-experiment.stan', line 11, column 2 to column 38)"};




class lcm_experiment_model final : public model_base_crtp<lcm_experiment_model> {

 private:
  int j;
  double z;
  double x;
  double i; 
  
 
 public:
  ~lcm_experiment_model() { }
  
  inline std::string model_name() const final { return "lcm_experiment_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  lcm_experiment_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_experiment_model_namespace::lcm_experiment_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 1;
      context__.validate_dims("data initialization","j","int",
           std::vector<size_t>{});
      j = std::numeric_limits<int>::min();
      
      
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      current_statement__ = 2;
      z = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 2;
      z = 1;
      current_statement__ = 3;
      x = std::numeric_limits<double>::quiet_NaN();
      
      
      {
        current_statement__ = 4;
        x = stan::math::normal_rng(123, 1, base_rng__);
        current_statement__ = 5;
        z = stan::math::normal_rng(((stan::math::sqrt(j) * 2) + 1), 1,
              base_rng__);
      }
      current_statement__ = 7;
      i = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 7;
      i = stan::math::normal_rng(((stan::math::sqrt(j) * 2) + 1), 1,
            base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_experiment_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_experiment_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 0> names__{};
      const std::array<Eigen::Index, 0> constrain_param_sizes__{};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = lcm_experiment_model_namespace::lcm_experiment_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lcm_experiment_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 lcm-experiment2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_experiment2_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 9> locations_array__ = 
{" (found before start of program)",
 " (in 'lcm-experiment2.stan', line 2, column 2 to column 9)",
 " (in 'lcm-experiment2.stan', line 5, column 2 to column 18)",
 " (in 'lcm-experiment2.stan', line 7, column 4 to column 11)",
 " (in 'lcm-experiment2.stan', line 6, column 17 to line 8, column 3)",
 " (in 'lcm-experiment2.stan', line 6, column 2 to line 8, column 3)",
 " (in 'lcm-experiment2.stan', line 10, column 4 to column 11)",
 " (in 'lcm-experiment2.stan', line 9, column 2 to line 10, column 11)",
 " (in 'lcm-experiment2.stan', line 11, column 2 to column 14)"};




class lcm_experiment2_model final : public model_base_crtp<lcm_experiment2_model> {

 private:
   
  
 
 public:
  ~lcm_experiment2_model() { }
  
  inline std::string model_name() const final { return "lcm_experiment2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  lcm_experiment2_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_experiment2_model_namespace::lcm_experiment2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_experiment2_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ x = DUMMY_VAR__;
      current_statement__ = 1;
      x = in__.template read<local_scalar_t__>();
      {
        local_scalar_t__ y = DUMMY_VAR__;
        current_statement__ = 2;
        y = stan::math::log(x);
        current_statement__ = 5;
        for (int j = 1; j <= 1; ++j) { current_statement__ = 3;
                                       y = (y + 1);}
        current_statement__ = 7;
        if (stan::math::logical_gt(1, 0)) {
          current_statement__ = 6;
          y = (y + 1);
        } 
        current_statement__ = 8;
        lp_accum__.add(y);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_experiment2_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double x = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      x = in__.template read<local_scalar_t__>();
      out__.write(x);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ x = DUMMY_VAR__;
      x = in__.read<local_scalar_t__>();
      out__.write(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"x"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 1;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 1;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 1> names__{"x"};
      const std::array<Eigen::Index, 1> constrain_param_sizes__{1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = lcm_experiment2_model_namespace::lcm_experiment2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lcm_experiment2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 lcm-fails.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_fails_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 7> locations_array__ = 
{" (found before start of program)",
 " (in 'lcm-fails.stan', line 6, column 2 to column 22)",
 " (in 'lcm-fails.stan', line 9, column 2 to column 23)",
 " (in 'lcm-fails.stan', line 2, column 2 to column 17)",
 " (in 'lcm-fails.stan', line 3, column 8 to column 9)",
 " (in 'lcm-fails.stan', line 3, column 2 to column 18)",
 " (in 'lcm-fails.stan', line 6, column 8 to column 9)"};




class lcm_fails_model final : public model_base_crtp<lcm_fails_model> {

 private:
  int J;
  std::vector<double> y; 
  
 
 public:
  ~lcm_fails_model() { }
  
  inline std::string model_name() const final { return "lcm_fails_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  lcm_fails_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_fails_model_namespace::lcm_fails_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 3;
      context__.validate_dims("data initialization","J","int",
           std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      
      
      current_statement__ = 3;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 4;
      stan::math::validate_non_negative_index("y", "J", J);
      current_statement__ = 5;
      context__.validate_dims("data initialization","y","double",
           std::vector<size_t>{static_cast<size_t>(J)});
      y = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 5;
      y = context__.vals_r("y");
      current_statement__ = 6;
      stan::math::validate_non_negative_index("theta", "J", J);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = J;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_fails_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      std::vector<local_scalar_t__> theta =
         std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      current_statement__ = 1;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      {
        current_statement__ = 2;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, theta, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_fails_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      std::vector<double> theta =
         std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      theta = in__.template read<std::vector<local_scalar_t__>>(J);
      out__.write(theta);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      std::vector<local_scalar_t__> theta =
         std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        theta[(sym1__ - 1)] = in__.read<local_scalar_t__>();
      }
      out__.write(theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"theta"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(J)
                                                                   }};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(J) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = J;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = J;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 1> names__{"theta"};
      const std::array<Eigen::Index, 1> constrain_param_sizes__{J};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = lcm_fails_model_namespace::lcm_fails_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lcm_fails_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 lcm-fails2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_fails2_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 71> locations_array__ = 
{" (found before start of program)",
 " (in 'lcm-fails2.stan', line 66, column 2 to column 34)",
 " (in 'lcm-fails2.stan', line 67, column 2 to column 32)",
 " (in 'lcm-fails2.stan', line 70, column 2 to column 52)",
 " (in 'lcm-fails2.stan', line 71, column 2 to column 50)",
 " (in 'lcm-fails2.stan', line 72, column 2 to column 50)",
 " (in 'lcm-fails2.stan', line 77, column 6 to column 20)",
 " (in 'lcm-fails2.stan', line 78, column 6 to column 18)",
 " (in 'lcm-fails2.stan', line 76, column 34 to line 79, column 5)",
 " (in 'lcm-fails2.stan', line 76, column 4 to line 79, column 5)",
 " (in 'lcm-fails2.stan', line 81, column 6 to column 27)",
 " (in 'lcm-fails2.stan', line 82, column 6 to column 23)",
 " (in 'lcm-fails2.stan', line 80, column 40 to line 83, column 5)",
 " (in 'lcm-fails2.stan', line 80, column 4 to line 83, column 5)",
 " (in 'lcm-fails2.stan', line 75, column 22 to line 84, column 3)",
 " (in 'lcm-fails2.stan', line 75, column 2 to line 84, column 3)",
 " (in 'lcm-fails2.stan', line 86, column 2 to column 51)",
 " (in 'lcm-fails2.stan', line 98, column 8 to column 37)",
 " (in 'lcm-fails2.stan', line 99, column 8 to column 41)",
 " (in 'lcm-fails2.stan', line 97, column 42 to line 100, column 7)",
 " (in 'lcm-fails2.stan', line 97, column 6 to line 100, column 7)",
 " (in 'lcm-fails2.stan', line 101, column 6 to column 37)",
 " (in 'lcm-fails2.stan', line 96, column 22 to line 102, column 5)",
 " (in 'lcm-fails2.stan', line 96, column 4 to line 102, column 5)",
 " (in 'lcm-fails2.stan', line 95, column 22 to line 103, column 3)",
 " (in 'lcm-fails2.stan', line 95, column 2 to line 103, column 3)",
 " (in 'lcm-fails2.stan', line 49, column 2 to column 20)",
 " (in 'lcm-fails2.stan', line 50, column 2 to column 27)",
 " (in 'lcm-fails2.stan', line 51, column 8 to column 12)",
 " (in 'lcm-fails2.stan', line 51, column 14 to column 25)",
 " (in 'lcm-fails2.stan', line 51, column 2 to column 51)",
 " (in 'lcm-fails2.stan', line 54, column 2 to column 38)",
 " (in 'lcm-fails2.stan', line 56, column 8 to column 12)",
 " (in 'lcm-fails2.stan', line 56, column 2 to column 52)",
 " (in 'lcm-fails2.stan', line 57, column 8 to column 12)",
 " (in 'lcm-fails2.stan', line 57, column 2 to column 51)",
 " (in 'lcm-fails2.stan', line 61, column 4 to column 35)",
 " (in 'lcm-fails2.stan', line 60, column 2 to line 61, column 35)",
 " (in 'lcm-fails2.stan', line 63, column 4 to column 33)",
 " (in 'lcm-fails2.stan', line 62, column 2 to line 63, column 33)",
 " (in 'lcm-fails2.stan', line 70, column 27 to column 31)",
 " (in 'lcm-fails2.stan', line 70, column 33 to column 46)",
 " (in 'lcm-fails2.stan', line 71, column 27 to column 31)",
 " (in 'lcm-fails2.stan', line 71, column 33 to column 46)",
 " (in 'lcm-fails2.stan', line 72, column 27 to column 31)",
 " (in 'lcm-fails2.stan', line 72, column 33 to column 44)",
 " (in 'lcm-fails2.stan', line 8, column 8 to column 17)",
 " (in 'lcm-fails2.stan', line 7, column 6 to line 8, column 17)",
 " (in 'lcm-fails2.stan', line 6, column 4 to line 8, column 17)",
 " (in 'lcm-fails2.stan', line 9, column 4 to column 13)",
 " (in 'lcm-fails2.stan', line 5, column 37 to line 10, column 3)",
 " (in 'lcm-fails2.stan', line 15, column 6 to column 32)",
 " (in 'lcm-fails2.stan', line 19, column 8 to column 17)",
 " (in 'lcm-fails2.stan', line 18, column 6 to line 19, column 17)",
 " (in 'lcm-fails2.stan', line 13, column 39 to line 20, column 5)",
 " (in 'lcm-fails2.stan', line 13, column 4 to line 20, column 5)",
 " (in 'lcm-fails2.stan', line 21, column 4 to column 13)",
 " (in 'lcm-fails2.stan', line 12, column 36 to line 22, column 3)",
 " (in 'lcm-fails2.stan', line 25, column 11 to column 15)",
 " (in 'lcm-fails2.stan', line 25, column 17 to column 28)",
 " (in 'lcm-fails2.stan', line 25, column 4 to column 34)",
 " (in 'lcm-fails2.stan', line 28, column 6 to column 32)",
 " (in 'lcm-fails2.stan', line 31, column 8 to column 37)",
 " (in 'lcm-fails2.stan', line 32, column 8 to column 32)",
 " (in 'lcm-fails2.stan', line 40, column 8 to line 42, column 44)",
 " (in 'lcm-fails2.stan', line 29, column 39 to line 43, column 7)",
 " (in 'lcm-fails2.stan', line 29, column 6 to line 43, column 7)",
 " (in 'lcm-fails2.stan', line 27, column 24 to line 44, column 5)",
 " (in 'lcm-fails2.stan', line 27, column 4 to line 44, column 5)",
 " (in 'lcm-fails2.stan', line 45, column 4 to column 15)",
 " (in 'lcm-fails2.stan', line 24, column 74 to line 46, column 3)"};

struct first_capture_functor__ {
  int
  operator()(const std::vector<int>& y_i, std::ostream* pstream__) const;
};
struct prob_uncaptured_functor__ {
  template <typename T2__, typename T3__,
            stan::require_eigen_matrix_dynamic_t<T2__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>, stan::value_type_t<T3__>>, -1, -1>
  operator()(const int& nind, const int& n_occasions, const T2__& p,
             const T3__& phi, std::ostream* pstream__) const;
};
struct last_capture_functor__ {
  int
  operator()(const std::vector<int>& y_i, std::ostream* pstream__) const;
};

int first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 48;
      for (int k = 1; k <= stan::math::size(y_i); ++k) {
        current_statement__ = 47;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
          current_statement__ = 46;
          return k;
        } 
      }
      current_statement__ = 49;
      return 0;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 55;
      for (int k_rev = 0; k_rev <= (stan::math::size(y_i) - 1); ++k_rev) {
        int k = std::numeric_limits<int>::min();
        current_statement__ = 51;
        k = (stan::math::size(y_i) - k_rev);
        current_statement__ = 53;
        if (stan::model::rvalue(y_i, "y_i", stan::model::index_uni(k))) {
          current_statement__ = 52;
          return k;
        } 
      }
      current_statement__ = 56;
      return 0;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T2__, typename T3__,
          stan::require_eigen_matrix_dynamic_t<T2__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>, stan::value_type_t<T3__>>, -1, -1>
  prob_uncaptured(const int& nind, const int& n_occasions,
                  const T2__& p_arg__, const T3__& phi_arg__,
                  std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<stan::value_type_t<T2__>,
                                 stan::value_type_t<T3__>>;
    int current_statement__ = 0; 
    const auto& p = stan::math::to_ref(p_arg__);
    const auto& phi = stan::math::to_ref(phi_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 58;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 59;
      stan::math::validate_non_negative_index("chi", "n_occasions",
                                              n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind, n_occasions,
           DUMMY_VAR__);
      current_statement__ = 68;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 61;
        stan::model::assign(chi, 1.0,
          "assigning variable chi", stan::model::index_uni(i),
                                      stan::model::index_uni(n_occasions));
        current_statement__ = 66;
        for (int t = 1; t <= (n_occasions - 1); ++t) {
          int t_curr = std::numeric_limits<int>::min();
          current_statement__ = 62;
          t_curr = (n_occasions - t);
          int t_next = std::numeric_limits<int>::min();
          current_statement__ = 63;
          t_next = (t_curr + 1);
          current_statement__ = 64;
          stan::model::assign(chi,
            ((1 -
               stan::model::rvalue(phi, "phi",
                 stan::model::index_uni(i), stan::model::index_uni(t_curr)))
              +
              ((stan::model::rvalue(phi, "phi",
                  stan::model::index_uni(i), stan::model::index_uni(t_curr))
                 *
                 (1 -
                   stan::model::rvalue(p, "p",
                     stan::model::index_uni(i),
                       stan::model::index_uni((t_next - 1))))) *
                stan::model::rvalue(chi, "chi",
                  stan::model::index_uni(i), stan::model::index_uni(t_next)))),
            "assigning variable chi", stan::model::index_uni(i),
                                        stan::model::index_uni(t_curr));
        }
      }
      current_statement__ = 69;
      return chi;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int
first_capture_functor__::operator()(const std::vector<int>& y_i,
                                    std::ostream* pstream__)  const
{
  return first_capture(y_i, pstream__);
}

template <typename T2__, typename T3__,
          stan::require_eigen_matrix_dynamic_t<T2__>*,
          stan::require_eigen_matrix_dynamic_t<T3__>*>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>, stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured_functor__::operator()(const int& nind,
                                      const int& n_occasions, const T2__& p,
                                      const T3__& phi,
                                      std::ostream* pstream__)  const
{
  return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}

int
last_capture_functor__::operator()(const std::vector<int>& y_i,
                                   std::ostream* pstream__)  const
{
  return last_capture(y_i, pstream__);
}

 class lcm_fails2_model final : public model_base_crtp<lcm_fails2_model> {

 private:
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last; 
  
 
 public:
  ~lcm_fails2_model() { }
  
  inline std::string model_name() const final { return "lcm_fails2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  lcm_fails2_model(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_fails2_model_namespace::lcm_fails2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 26;
      context__.validate_dims("data initialization","nind","int",
           std::vector<size_t>{});
      nind = std::numeric_limits<int>::min();
      
      
      current_statement__ = 26;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 26;
      stan::math::check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 27;
      context__.validate_dims("data initialization","n_occasions","int",
           std::vector<size_t>{});
      n_occasions = std::numeric_limits<int>::min();
      
      
      current_statement__ = 27;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 27;
      stan::math::check_greater_or_equal(function__, "n_occasions",
                                            n_occasions, 2);
      current_statement__ = 28;
      stan::math::validate_non_negative_index("y", "nind", nind);
      current_statement__ = 29;
      stan::math::validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 30;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(nind),
            static_cast<size_t>(n_occasions)});
      y = 
        std::vector<std::vector<int>>(nind, 
          std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 30;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 30;
        pos__ = 1;
        current_statement__ = 30;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 30;
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            current_statement__ = 30;
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
            current_statement__ = 30;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 30;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 31;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      
      
      current_statement__ = 31;
      n_occ_minus_1 = (n_occasions - 1);
      current_statement__ = 32;
      stan::math::validate_non_negative_index("first", "nind", nind);
      current_statement__ = 33;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      
      current_statement__ = 34;
      stan::math::validate_non_negative_index("last", "nind", nind);
      current_statement__ = 35;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      
      current_statement__ = 37;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 36;
        stan::model::assign(first,
          first_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(i)), pstream__),
          "assigning variable first", stan::model::index_uni(i));
      }
      current_statement__ = 39;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 38;
        stan::model::assign(last,
          last_capture(
            stan::model::rvalue(y, "y", stan::model::index_uni(i)), pstream__),
          "assigning variable last", stan::model::index_uni(i));
      }
      current_statement__ = 33;
      stan::math::check_greater_or_equal(function__, "first", first, 0);
      current_statement__ = 33;
      stan::math::check_less_or_equal(function__, "first", first, n_occasions);
      current_statement__ = 35;
      stan::math::check_greater_or_equal(function__, "last", last, 0);
      current_statement__ = 35;
      stan::math::check_less_or_equal(function__, "last", last, n_occasions);
      current_statement__ = 40;
      stan::math::validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 41;
      stan::math::validate_non_negative_index("phi", "n_occ_minus_1",
                                              n_occ_minus_1);
      current_statement__ = 42;
      stan::math::validate_non_negative_index("p", "nind", nind);
      current_statement__ = 43;
      stan::math::validate_non_negative_index("p", "n_occ_minus_1",
                                              n_occ_minus_1);
      current_statement__ = 44;
      stan::math::validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 45;
      stan::math::validate_non_negative_index("chi", "n_occasions",
                                              n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_fails2_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ mean_phi = DUMMY_VAR__;
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ mean_p = DUMMY_VAR__;
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, 
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind,
           n_occ_minus_1, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind,
           n_occ_minus_1, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nind, n_occasions,
           DUMMY_VAR__);
      current_statement__ = 15;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 9;
        for (int t = 1;
             t <= (stan::model::rvalue(first, "first",
                     stan::model::index_uni(i)) - 1);
             ++t) {
          current_statement__ = 6;
          stan::model::assign(phi, 0,
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 7;
          stan::model::assign(p, 0,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
        current_statement__ = 13;
        for (int t = stan::model::rvalue(first, "first",
                       stan::model::index_uni(i));
             t <= n_occ_minus_1; ++t) {
          current_statement__ = 10;
          stan::model::assign(phi, mean_phi,
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 11;
          stan::model::assign(p, mean_p,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
      }
      current_statement__ = 16;
      stan::model::assign(chi,
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi", chi, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi", chi, 1);
      {
        current_statement__ = 25;
        for (int i = 1; i <= nind; ++i) {
          current_statement__ = 23;
          if (stan::math::logical_gt(
                stan::model::rvalue(first, "first",
                  stan::model::index_uni(i)), 0)) {
            current_statement__ = 20;
            for (int t = (stan::model::rvalue(first, "first",
                            stan::model::index_uni(i)) + 1);
                 t <= stan::model::rvalue(last, "last",
                        stan::model::index_uni(i));
                 ++t) {
              current_statement__ = 17;
              lp_accum__.add(
                stan::math::bernoulli_lpmf<propto__>(1,
                  stan::model::rvalue(phi, "phi",
                    stan::model::index_uni(i),
                      stan::model::index_uni((t - 1)))));
              current_statement__ = 18;
              lp_accum__.add(
                stan::math::bernoulli_lpmf<propto__>(
                  stan::model::rvalue(y, "y",
                    stan::model::index_uni(i), stan::model::index_uni(t)),
                  stan::model::rvalue(p, "p",
                    stan::model::index_uni(i),
                      stan::model::index_uni((t - 1)))));
            }
            current_statement__ = 21;
            lp_accum__.add(
              stan::math::bernoulli_lpmf<propto__>(1,
                stan::model::rvalue(chi, "chi",
                  stan::model::index_uni(i),
                    stan::model::index_uni(stan::model::rvalue(last, "last",
                                             stan::model::index_uni(i))))));
          } 
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lcm_fails2_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double mean_phi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      mean_phi = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 1, lp__);
      double mean_p = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      mean_p = in__.template read_constrain_lub<local_scalar_t__, 
                 jacobian__>(0, 1, lp__);
      Eigen::Matrix<double, -1, -1> phi =
         Eigen::Matrix<double, -1, -1>::Constant(nind, n_occ_minus_1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> p =
         Eigen::Matrix<double, -1, -1>::Constant(nind, n_occ_minus_1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> chi =
         Eigen::Matrix<double, -1, -1>::Constant(nind, n_occasions,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(mean_phi);
      out__.write(mean_p);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 15;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 9;
        for (int t = 1;
             t <= (stan::model::rvalue(first, "first",
                     stan::model::index_uni(i)) - 1);
             ++t) {
          current_statement__ = 6;
          stan::model::assign(phi, 0,
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 7;
          stan::model::assign(p, 0,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
        current_statement__ = 13;
        for (int t = stan::model::rvalue(first, "first",
                       stan::model::index_uni(i));
             t <= n_occ_minus_1; ++t) {
          current_statement__ = 10;
          stan::model::assign(phi, mean_phi,
            "assigning variable phi", stan::model::index_uni(i),
                                        stan::model::index_uni(t));
          current_statement__ = 11;
          stan::model::assign(p, mean_p,
            "assigning variable p", stan::model::index_uni(i),
                                      stan::model::index_uni(t));
        }
      }
      current_statement__ = 16;
      stan::model::assign(chi,
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 3;
      stan::math::check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      stan::math::check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      stan::math::check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      stan::math::check_greater_or_equal(function__, "chi", chi, 0);
      current_statement__ = 5;
      stan::math::check_less_or_equal(function__, "chi", chi, 1);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(p);
        out__.write(chi);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ mean_phi = DUMMY_VAR__;
      mean_phi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_phi);
      local_scalar_t__ mean_p = DUMMY_VAR__;
      mean_p = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, mean_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mean_phi", "mean_p", "phi", "p",
      "chi"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occ_minus_1)},
      std::vector<size_t>{static_cast<size_t>(nind),
                          static_cast<size_t>(n_occasions)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occ_minus_1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nind) + ",\"cols\":" + std::to_string(n_occasions) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + 1);
      const size_t num_transformed = (((nind * n_occ_minus_1) +
                                                   (nind * n_occ_minus_1)) +
                                                  (nind * n_occasions));
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + 1);
      const size_t num_transformed = (((nind * n_occ_minus_1) +
                                                   (nind * n_occ_minus_1)) +
                                                  (nind * n_occasions));
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"mean_phi", "mean_p"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } using stan_model = lcm_fails2_model_namespace::lcm_fails2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lcm_fails2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 lupdf-inlining.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lupdf_inlining_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 14> locations_array__ = 
{" (found before start of program)",
 " (in 'lupdf-inlining.stan', line 16, column 4 to column 12)",
 " (in 'lupdf-inlining.stan', line 19, column 4 to column 32)",
 " (in 'lupdf-inlining.stan', line 26, column 4 to column 30)",
 " (in 'lupdf-inlining.stan', line 27, column 4 to column 31)",
 " (in 'lupdf-inlining.stan', line 22, column 4 to column 29)",
 " (in 'lupdf-inlining.stan', line 23, column 4 to column 31)",
 " (in 'lupdf-inlining.stan', line 13, column 4 to column 10)",
 " (in 'lupdf-inlining.stan', line 3, column 8 to column 36)",
 " (in 'lupdf-inlining.stan', line 2, column 35 to line 4, column 5)",
 " (in 'lupdf-inlining.stan', line 6, column 8 to column 35)",
 " (in 'lupdf-inlining.stan', line 5, column 34 to line 7, column 5)",
 " (in 'lupdf-inlining.stan', line 9, column 8 to column 32)",
 " (in 'lupdf-inlining.stan', line 8, column 26 to line 10, column 5)"};

struct baz_lpdf_functor__ {
  template <bool propto__, typename T0__,
            stan::require_stan_scalar_t<T0__>* = nullptr>
  stan::promote_args_t<T0__>
  operator()(const T0__& x, std::ostream* pstream__) const;
};
struct bar_lpmf_functor__ {
  template <bool propto__, typename T1__,
            stan::require_stan_scalar_t<T1__>* = nullptr>
  stan::promote_args_t<T1__>
  operator()(const int& n, const T1__& mu, std::ostream* pstream__) const;
};
struct foo_lpdf_functor__ {
  template <bool propto__, typename T0__, typename T1__,
            stan::require_stan_scalar_t<T0__>* = nullptr,
            stan::require_stan_scalar_t<T1__>* = nullptr>
  stan::promote_args_t<T0__, T1__>
  operator()(const T0__& x, const T1__& mu, std::ostream* pstream__) const;
};

template <bool propto__, typename T0__, typename T1__,
          stan::require_stan_scalar_t<T0__>* = nullptr,
          stan::require_stan_scalar_t<T1__>* = nullptr>
  stan::promote_args_t<T0__, T1__>
  foo_lpdf(const T0__& x, const T1__& mu, std::ostream* pstream__) {
    using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
    int current_statement__ = 0; 
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 8;
      return stan::math::normal_lpdf<propto__>(x, mu, 1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <bool propto__, typename T1__,
          stan::require_stan_scalar_t<T1__>* = nullptr>
  stan::promote_args_t<T1__>
  bar_lpmf(const int& n, const T1__& mu, std::ostream* pstream__) {
    using local_scalar_t__ = stan::promote_args_t<T1__>;
    int current_statement__ = 0; 
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 10;
      return stan::math::poisson_lpmf<propto__>(n, mu);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <bool propto__, typename T0__,
          stan::require_stan_scalar_t<T0__>* = nullptr>
  stan::promote_args_t<T0__>
  baz_lpdf(const T0__& x, std::ostream* pstream__) {
    using local_scalar_t__ = stan::promote_args_t<T0__>;
    int current_statement__ = 0; 
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 12;
      return foo_lpdf<propto__>(x, 0.5, pstream__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <bool propto__, typename T0__, stan::require_stan_scalar_t<T0__>*>
stan::promote_args_t<T0__>
baz_lpdf_functor__::operator()(const T0__& x, std::ostream* pstream__)  const
{
  return baz_lpdf<propto__>(x, pstream__);
}

template <bool propto__, typename T1__, stan::require_stan_scalar_t<T1__>*>
stan::promote_args_t<T1__>
bar_lpmf_functor__::operator()(const int& n, const T1__& mu,
                               std::ostream* pstream__)  const
{
  return bar_lpmf<propto__>(n, mu, pstream__);
}

template <bool propto__, typename T0__, typename T1__,
          stan::require_stan_scalar_t<T0__>*,
          stan::require_stan_scalar_t<T1__>*>
stan::promote_args_t<T0__, T1__>
foo_lpdf_functor__::operator()(const T0__& x, const T1__& mu,
                               std::ostream* pstream__)  const
{
  return foo_lpdf<propto__>(x, mu, pstream__);
}


class lupdf_inlining_model final : public model_base_crtp<lupdf_inlining_model> {

 private:
  int n; 
  
 
 public:
  ~lupdf_inlining_model() { }
  
  inline std::string model_name() const final { return "lupdf_inlining_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  lupdf_inlining_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "lupdf_inlining_model_namespace::lupdf_inlining_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 7;
      context__.validate_dims("data initialization","n","int",
           std::vector<size_t>{});
      n = std::numeric_limits<int>::min();
      
      
      current_statement__ = 7;
      n = context__.vals_i("n")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lupdf_inlining_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ mu = DUMMY_VAR__;
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      local_scalar_t__ tp = DUMMY_VAR__;
      current_statement__ = 2;
      tp = foo_lpdf<false>(mu, 1.0, pstream__);
      {
        current_statement__ = 5;
        lp_accum__.add(baz_lpdf<propto__>(mu, pstream__));
        current_statement__ = 6;
        lp_accum__.add(bar_lpmf<propto__>(n, mu, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lupdf_inlining_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double mu = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      mu = in__.template read<local_scalar_t__>();
      double tp = std::numeric_limits<double>::quiet_NaN();
      out__.write(mu);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 2;
      tp = foo_lpdf<false>(mu, 1.0, pstream__);
      if (emit_transformed_parameters__) {
        out__.write(tp);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double lbaz = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      lbaz = baz_lpdf<false>(mu, pstream__);
      double lbar = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      lbar = bar_lpmf<false>(n, mu, pstream__);
      out__.write(lbaz);
      out__.write(lbar);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ mu = DUMMY_VAR__;
      mu = in__.read<local_scalar_t__>();
      out__.write(mu);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"mu", "tp", "lbaz", "lbar"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "lbaz");
      param_names__.emplace_back(std::string() + "lbar");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "lbaz");
      param_names__.emplace_back(std::string() + "lbar");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tp\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"lbaz\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"lbar\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tp\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"lbaz\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"lbar\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 1;
      const size_t num_transformed = 1;
      const size_t num_gen_quantities = 
  (1 + 1);
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 1;
      const size_t num_transformed = 1;
      const size_t num_gen_quantities = 
  (1 + 1);
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 1> names__{"mu"};
      const std::array<Eigen::Index, 1> constrain_param_sizes__{1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } 
using stan_model = lupdf_inlining_model_namespace::lupdf_inlining_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lupdf_inlining_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 off-dce.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace off_dce_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 55> locations_array__ = 
{" (found before start of program)",
 " (in 'off-dce.stan', line 21, column 2 to column 17)",
 " (in 'off-dce.stan', line 22, column 2 to column 16)",
 " (in 'off-dce.stan', line 23, column 2 to column 15)",
 " (in 'off-dce.stan', line 24, column 2 to column 14)",
 " (in 'off-dce.stan', line 27, column 2 to column 22)",
 " (in 'off-dce.stan', line 28, column 2 to column 23)",
 " (in 'off-dce.stan', line 30, column 2 to column 39)",
 " (in 'off-dce.stan', line 31, column 2 to column 48)",
 " (in 'off-dce.stan', line 54, column 2 to column 13)",
 " (in 'off-dce.stan', line 55, column 2 to column 24)",
 " (in 'off-dce.stan', line 56, column 2 to column 17)",
 " (in 'off-dce.stan', line 68, column 6 to column 21)",
 " (in 'off-dce.stan', line 69, column 6 to column 15)",
 " (in 'off-dce.stan', line 66, column 11 to line 70, column 5)",
 " (in 'off-dce.stan', line 61, column 6 to column 41)",
 " (in 'off-dce.stan', line 62, column 13 to column 14)",
 " (in 'off-dce.stan', line 62, column 6 to column 44)",
 " (in 'off-dce.stan', line 63, column 6 to column 29)",
 " (in 'off-dce.stan', line 64, column 6 to column 55)",
 " (in 'off-dce.stan', line 65, column 6 to column 39)",
 " (in 'off-dce.stan', line 59, column 23 to line 66, column 5)",
 " (in 'off-dce.stan', line 59, column 4 to line 70, column 5)",
 " (in 'off-dce.stan', line 58, column 19 to line 71, column 3)",
 " (in 'off-dce.stan', line 58, column 2 to line 71, column 3)",
 " (in 'off-dce.stan', line 72, column 2 to column 18)",
 " (in 'off-dce.stan', line 46, column 6 to line 49, column 68)",
 " (in 'off-dce.stan', line 44, column 11 to line 50, column 5)",
 " (in 'off-dce.stan', line 42, column 6 to column 40)",
 " (in 'off-dce.stan', line 43, column 6 to column 41)",
 " (in 'off-dce.stan', line 40, column 18 to line 44, column 5)",
 " (in 'off-dce.stan', line 40, column 4 to line 50, column 5)",
 " (in 'off-dce.stan', line 39, column 19 to line 51, column 3)",
 " (in 'off-dce.stan', line 39, column 2 to line 51, column 3)",
 " (in 'off-dce.stan', line 4, column 2 to column 17)",
 " (in 'off-dce.stan', line 5, column 2 to column 17)",
 " (in 'off-dce.stan', line 6, column 8 to column 9)",
 " (in 'off-dce.stan', line 6, column 11 to column 12)",
 " (in 'off-dce.stan', line 6, column 2 to column 38)",
 " (in 'off-dce.stan', line 7, column 9 to column 10)",
 " (in 'off-dce.stan', line 7, column 2 to column 14)",
 " (in 'off-dce.stan', line 10, column 8 to column 9)",
 " (in 'off-dce.stan', line 10, column 2 to column 39)",
 " (in 'off-dce.stan', line 11, column 2 to column 32)",
 " (in 'off-dce.stan', line 13, column 2 to column 14)",
 " (in 'off-dce.stan', line 15, column 4 to column 25)",
 " (in 'off-dce.stan', line 17, column 6 to column 28)",
 " (in 'off-dce.stan', line 16, column 4 to line 17, column 28)",
 " (in 'off-dce.stan', line 14, column 19 to line 18, column 3)",
 " (in 'off-dce.stan', line 14, column 2 to line 18, column 3)",
 " (in 'off-dce.stan', line 27, column 9 to column 10)",
 " (in 'off-dce.stan', line 28, column 9 to column 10)",
 " (in 'off-dce.stan', line 28, column 12 to column 13)",
 " (in 'off-dce.stan', line 55, column 8 to column 9)",
 " (in 'off-dce.stan', line 56, column 8 to column 9)"};




class off_dce_model final : public model_base_crtp<off_dce_model> {

 private:
  int R;
  int T;
  std::vector<std::vector<int>> y;
  Eigen::Matrix<double, -1, 1> X__;
  std::vector<int> sum_y;
  int occ_obs; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> X{nullptr, 0};
 
 public:
  ~off_dce_model() { }
  
  inline std::string model_name() const final { return "off_dce_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  off_dce_model(stan::io::var_context& context__,
                unsigned int random_seed__ = 0,
                std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "off_dce_model_namespace::off_dce_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 34;
      context__.validate_dims("data initialization","R","int",
           std::vector<size_t>{});
      R = std::numeric_limits<int>::min();
      
      
      current_statement__ = 34;
      R = context__.vals_i("R")[(1 - 1)];
      current_statement__ = 34;
      stan::math::check_greater_or_equal(function__, "R", R, 1);
      current_statement__ = 35;
      context__.validate_dims("data initialization","T","int",
           std::vector<size_t>{});
      T = std::numeric_limits<int>::min();
      
      
      current_statement__ = 35;
      T = context__.vals_i("T")[(1 - 1)];
      current_statement__ = 35;
      stan::math::check_greater_or_equal(function__, "T", T, 1);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("y", "R", R);
      current_statement__ = 37;
      stan::math::validate_non_negative_index("y", "T", T);
      current_statement__ = 38;
      context__.validate_dims("data initialization","y","int",
           std::vector<size_t>{static_cast<size_t>(R),
            static_cast<size_t>(T)});
      y = 
        std::vector<std::vector<int>>(R, 
          std::vector<int>(T, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 38;
        y_flat__ = context__.vals_i("y");
        current_statement__ = 38;
        pos__ = 1;
        current_statement__ = 38;
        for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
          current_statement__ = 38;
          for (int sym2__ = 1; sym2__ <= R; ++sym2__) {
            current_statement__ = 38;
            stan::model::assign(y, y_flat__[(pos__ - 1)],
              "assigning variable y", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
            current_statement__ = 38;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 38;
      stan::math::check_greater_or_equal(function__, "y", y, 0);
      current_statement__ = 38;
      stan::math::check_less_or_equal(function__, "y", y, 1);
      current_statement__ = 39;
      stan::math::validate_non_negative_index("X", "R", R);
      current_statement__ = 40;
      context__.validate_dims("data initialization","X","double",
           std::vector<size_t>{static_cast<size_t>(R)});
      X__ = 
        Eigen::Matrix<double, -1, 1>::Constant(R,
          std::numeric_limits<double>::quiet_NaN());
      new (&X) Eigen::Map<Eigen::Matrix<double, -1, 1>>(X__.data(), R);
      
      {
        std::vector<local_scalar_t__> X_flat__;
        current_statement__ = 40;
        X_flat__ = context__.vals_r("X");
        current_statement__ = 40;
        pos__ = 1;
        current_statement__ = 40;
        for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
          current_statement__ = 40;
          stan::model::assign(X, X_flat__[(pos__ - 1)],
            "assigning variable X", stan::model::index_uni(sym1__));
          current_statement__ = 40;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 41;
      stan::math::validate_non_negative_index("sum_y", "R", R);
      current_statement__ = 42;
      sum_y = std::vector<int>(R, std::numeric_limits<int>::min());
      
      
      current_statement__ = 43;
      occ_obs = std::numeric_limits<int>::min();
      
      
      current_statement__ = 44;
      occ_obs = 0;
      current_statement__ = 49;
      for (int i = 1; i <= R; ++i) {
        current_statement__ = 45;
        stan::model::assign(sum_y,
          stan::math::sum(
            stan::model::rvalue(y, "y", stan::model::index_uni(i))),
          "assigning variable sum_y", stan::model::index_uni(i));
        current_statement__ = 47;
        if (stan::model::rvalue(sum_y, "sum_y", stan::model::index_uni(i))) {
          current_statement__ = 46;
          occ_obs = (occ_obs + 1);
        } 
      }
      current_statement__ = 42;
      stan::math::check_greater_or_equal(function__, "sum_y", sum_y, 0);
      current_statement__ = 42;
      stan::math::check_less_or_equal(function__, "sum_y", sum_y, T);
      current_statement__ = 43;
      stan::math::check_greater_or_equal(function__, "occ_obs", occ_obs, 0);
      current_statement__ = 43;
      stan::math::check_less_or_equal(function__, "occ_obs", occ_obs, R);
      current_statement__ = 50;
      stan::math::validate_non_negative_index("logit_psi", "R", R);
      current_statement__ = 51;
      stan::math::validate_non_negative_index("logit_p", "R", R);
      current_statement__ = 52;
      stan::math::validate_non_negative_index("logit_p", "T", T);
      current_statement__ = 53;
      stan::math::validate_non_negative_index("psi_con", "R", R);
      current_statement__ = 54;
      stan::math::validate_non_negative_index("z", "R", R);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "off_dce_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ alpha_occ = DUMMY_VAR__;
      current_statement__ = 1;
      alpha_occ = in__.template read<local_scalar_t__>();
      local_scalar_t__ beta_occ = DUMMY_VAR__;
      current_statement__ = 2;
      beta_occ = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha_p = DUMMY_VAR__;
      current_statement__ = 3;
      alpha_p = in__.template read<local_scalar_t__>();
      local_scalar_t__ beta_p = DUMMY_VAR__;
      current_statement__ = 4;
      beta_p = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__, -1, 1> logit_psi =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(R, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, -1> logit_p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(R, T, DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(logit_psi,
        stan::math::add(alpha_occ, stan::math::multiply(beta_occ, X)),
        "assigning variable logit_psi");
      current_statement__ = 8;
      stan::model::assign(logit_p,
        stan::math::rep_matrix(
          stan::math::add(alpha_p, stan::math::multiply(beta_p, X)), T),
        "assigning variable logit_p");
      {
        current_statement__ = 33;
        for (int i = 1; i <= R; ++i) {
          current_statement__ = 31;
          if (stan::model::rvalue(sum_y, "sum_y", stan::model::index_uni(i))) {
            current_statement__ = 28;
            lp_accum__.add(
              stan::math::bernoulli_logit_lpmf<propto__>(1,
                stan::model::rvalue(logit_psi, "logit_psi",
                  stan::model::index_uni(i))));
            current_statement__ = 29;
            lp_accum__.add(
              stan::math::bernoulli_logit_lpmf<propto__>(
                stan::model::rvalue(y, "y", stan::model::index_uni(i)),
                stan::model::rvalue(logit_p, "logit_p",
                  stan::model::index_uni(i))));
          } else {
            current_statement__ = 26;
            lp_accum__.add(
              stan::math::log_sum_exp(
                (stan::math::bernoulli_logit_lpmf<false>(1,
                   stan::model::rvalue(logit_psi, "logit_psi",
                     stan::model::index_uni(i))) +
                  stan::math::bernoulli_logit_lpmf<false>(0,
                    stan::model::rvalue(logit_p, "logit_p",
                      stan::model::index_uni(i)))),
                stan::math::bernoulli_logit_lpmf<false>(0,
                  stan::model::rvalue(logit_psi, "logit_psi",
                    stan::model::index_uni(i)))));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "off_dce_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double alpha_occ = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      alpha_occ = in__.template read<local_scalar_t__>();
      double beta_occ = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      beta_occ = in__.template read<local_scalar_t__>();
      double alpha_p = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      alpha_p = in__.template read<local_scalar_t__>();
      double beta_p = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      beta_p = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, 1> logit_psi =
         Eigen::Matrix<double, -1, 1>::Constant(R,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> logit_p =
         Eigen::Matrix<double, -1, -1>::Constant(R, T,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(alpha_occ);
      out__.write(beta_occ);
      out__.write(alpha_p);
      out__.write(beta_p);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 7;
      stan::model::assign(logit_psi,
        stan::math::add(alpha_occ, stan::math::multiply(beta_occ, X)),
        "assigning variable logit_psi");
      current_statement__ = 8;
      stan::model::assign(logit_p,
        stan::math::rep_matrix(
          stan::math::add(alpha_p, stan::math::multiply(beta_p, X)), T),
        "assigning variable logit_p");
      if (emit_transformed_parameters__) {
        out__.write(logit_psi);
        out__.write(logit_p);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      int occ_fs = std::numeric_limits<int>::min();
      std::vector<double> psi_con =
         std::vector<double>(R, std::numeric_limits<double>::quiet_NaN());
      std::vector<int> z =
         std::vector<int>(R, std::numeric_limits<int>::min());
      current_statement__ = 24;
      for (int i = 1; i <= R; ++i) {
        current_statement__ = 22;
        if (stan::math::logical_eq(
              stan::model::rvalue(sum_y, "sum_y", stan::model::index_uni(i)),
              0)) {
          double psi = std::numeric_limits<double>::quiet_NaN();
          current_statement__ = 15;
          psi = stan::math::inv_logit(
                  stan::model::rvalue(logit_psi, "logit_psi",
                    stan::model::index_uni(i)));
          current_statement__ = 16;
          stan::math::validate_non_negative_index("q", "T", T);
          Eigen::Matrix<double, -1, 1> q =
             Eigen::Matrix<double, -1, 1>::Constant(T,
               std::numeric_limits<double>::quiet_NaN());
          current_statement__ = 17;
          stan::model::assign(q,
            stan::math::transpose(
              stan::math::inv_logit(
                stan::math::minus(
                  stan::model::rvalue(logit_p, "logit_p",
                    stan::model::index_uni(i))))), "assigning variable q");
          double qT = std::numeric_limits<double>::quiet_NaN();
          current_statement__ = 18;
          qT = stan::math::prod(
                 stan::model::rvalue(q, "q", stan::model::index_omni()));
          current_statement__ = 19;
          stan::model::assign(psi_con,
            ((psi * qT) / ((psi * qT) + (1 - psi))),
            "assigning variable psi_con", stan::model::index_uni(i));
          current_statement__ = 20;
          stan::model::assign(z,
            stan::math::bernoulli_rng(
              stan::model::rvalue(psi_con, "psi_con",
                stan::model::index_uni(i)), base_rng__),
            "assigning variable z", stan::model::index_uni(i));
        } else {
          current_statement__ = 12;
          stan::model::assign(psi_con, 1,
            "assigning variable psi_con", stan::model::index_uni(i));
          current_statement__ = 13;
          stan::model::assign(z, 1,
            "assigning variable z", stan::model::index_uni(i));
        }
      }
      current_statement__ = 25;
      occ_fs = stan::math::sum(z);
      out__.write(occ_fs);
      out__.write(psi_con);
      out__.write(z);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ alpha_occ = DUMMY_VAR__;
      alpha_occ = in__.read<local_scalar_t__>();
      out__.write(alpha_occ);
      local_scalar_t__ beta_occ = DUMMY_VAR__;
      beta_occ = in__.read<local_scalar_t__>();
      out__.write(beta_occ);
      local_scalar_t__ alpha_p = DUMMY_VAR__;
      alpha_p = in__.read<local_scalar_t__>();
      out__.write(alpha_p);
      local_scalar_t__ beta_p = DUMMY_VAR__;
      beta_p = in__.read<local_scalar_t__>();
      out__.write(beta_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"alpha_occ", "beta_occ", "alpha_p",
      "beta_p", "logit_psi", "logit_p", "occ_fs", "psi_con", "z"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{static_cast<size_t>(R)},
      std::vector<size_t>{static_cast<size_t>(R), static_cast<size_t>(T)},
      std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(R)},
      std::vector<size_t>{static_cast<size_t>(R)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha_occ");
    param_names__.emplace_back(std::string() + "beta_occ");
    param_names__.emplace_back(std::string() + "alpha_p");
    param_names__.emplace_back(std::string() + "beta_p");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "logit_psi" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= R; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "logit_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "occ_fs");
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "psi_con" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha_occ");
    param_names__.emplace_back(std::string() + "beta_occ");
    param_names__.emplace_back(std::string() + "alpha_p");
    param_names__.emplace_back(std::string() + "beta_p");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "logit_psi" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= R; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "logit_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "occ_fs");
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "psi_con" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"logit_psi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(R) + "},\"block\":\"transformed_parameters\"},{\"name\":\"logit_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(R) + ",\"cols\":" + std::to_string(T) + "},\"block\":\"transformed_parameters\"},{\"name\":\"occ_fs\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"psi_con\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(R) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(R) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"logit_psi\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(R) + "},\"block\":\"transformed_parameters\"},{\"name\":\"logit_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(R) + ",\"cols\":" + std::to_string(T) + "},\"block\":\"transformed_parameters\"},{\"name\":\"occ_fs\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"psi_con\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(R) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(R) + ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((1 + 1) + 1) + 1);
      const size_t num_transformed = (R + (R * T));
      const size_t num_gen_quantities = 
  ((1 + R) + R);
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((1 + 1) + 1) + 1);
      const size_t num_transformed = (R + (R * T));
      const size_t num_gen_quantities = 
  ((1 + R) + R);
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 4> names__{"alpha_occ", "beta_occ",
      "alpha_p", "beta_p"};
      const std::array<Eigen::Index, 4> constrain_param_sizes__{1, 1, 1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = off_dce_model_namespace::off_dce_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return off_dce_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 off-small.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace off_small_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 37> locations_array__ = 
{" (found before start of program)",
 " (in 'off-small.stan', line 10, column 2 to column 12)",
 " (in 'off-small.stan', line 11, column 2 to column 17)",
 " (in 'off-small.stan', line 12, column 2 to column 17)",
 " (in 'off-small.stan', line 13, column 2 to column 13)",
 " (in 'off-small.stan', line 14, column 2 to column 13)",
 " (in 'off-small.stan', line 15, column 2 to column 36)",
 " (in 'off-small.stan', line 16, column 2 to column 36)",
 " (in 'off-small.stan', line 17, column 2 to column 35)",
 " (in 'off-small.stan', line 20, column 2 to column 15)",
 " (in 'off-small.stan', line 21, column 2 to column 15)",
 " (in 'off-small.stan', line 22, column 2 to column 18)",
 " (in 'off-small.stan', line 24, column 2 to column 36)",
 " (in 'off-small.stan', line 25, column 2 to column 37)",
 " (in 'off-small.stan', line 28, column 4 to line 29, column 41)",
 " (in 'off-small.stan', line 27, column 2 to line 29, column 41)",
 " (in 'off-small.stan', line 32, column 2 to column 23)",
 " (in 'off-small.stan', line 33, column 2 to column 22)",
 " (in 'off-small.stan', line 34, column 2 to column 23)",
 " (in 'off-small.stan', line 35, column 2 to column 22)",
 " (in 'off-small.stan', line 37, column 2 to column 22)",
 " (in 'off-small.stan', line 39, column 2 to column 29)",
 " (in 'off-small.stan', line 2, column 2 to column 17)",
 " (in 'off-small.stan', line 3, column 2 to column 17)",
 " (in 'off-small.stan', line 4, column 8 to column 9)",
 " (in 'off-small.stan', line 4, column 2 to column 40)",
 " (in 'off-small.stan', line 5, column 9 to column 10)",
 " (in 'off-small.stan', line 5, column 2 to column 17)",
 " (in 'off-small.stan', line 6, column 9 to column 10)",
 " (in 'off-small.stan', line 6, column 2 to column 22)",
 " (in 'off-small.stan', line 7, column 9 to column 10)",
 " (in 'off-small.stan', line 7, column 2 to column 14)",
 " (in 'off-small.stan', line 11, column 9 to column 10)",
 " (in 'off-small.stan', line 12, column 9 to column 10)",
 " (in 'off-small.stan', line 20, column 9 to column 10)",
 " (in 'off-small.stan', line 21, column 9 to column 10)",
 " (in 'off-small.stan', line 22, column 9 to column 10)"};




class off_small_model final : public model_base_crtp<off_small_model> {

 private:
  int J;
  int N;
  std::vector<int> person;
  Eigen::Matrix<double, -1, 1> time__;
  Eigen::Matrix<double, -1, 1> treatment__;
  Eigen::Matrix<double, -1, 1> y__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> time{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> treatment{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> y{nullptr, 0};
 
 public:
  ~off_small_model() { }
  
  inline std::string model_name() const final { return "off_small_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  off_small_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "off_small_model_namespace::off_small_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 22;
      context__.validate_dims("data initialization","J","int",
           std::vector<size_t>{});
      J = std::numeric_limits<int>::min();
      
      
      current_statement__ = 22;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 22;
      stan::math::check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 23;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      
      current_statement__ = 23;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 24;
      stan::math::validate_non_negative_index("person", "N", N);
      current_statement__ = 25;
      context__.validate_dims("data initialization","person","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      person = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 25;
      person = context__.vals_i("person");
      current_statement__ = 25;
      stan::math::check_greater_or_equal(function__, "person", person, 1);
      current_statement__ = 25;
      stan::math::check_less_or_equal(function__, "person", person, J);
      current_statement__ = 26;
      stan::math::validate_non_negative_index("time", "N", N);
      current_statement__ = 27;
      context__.validate_dims("data initialization","time","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      time__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&time) Eigen::Map<Eigen::Matrix<double, -1, 1>>(time__.data(), N);
      
      {
        std::vector<local_scalar_t__> time_flat__;
        current_statement__ = 27;
        time_flat__ = context__.vals_r("time");
        current_statement__ = 27;
        pos__ = 1;
        current_statement__ = 27;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 27;
          stan::model::assign(time, time_flat__[(pos__ - 1)],
            "assigning variable time", stan::model::index_uni(sym1__));
          current_statement__ = 27;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 28;
      stan::math::validate_non_negative_index("treatment", "N", N);
      current_statement__ = 29;
      context__.validate_dims("data initialization","treatment","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      treatment__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&treatment) Eigen::Map<Eigen::Matrix<double, -1, 1>>(treatment__.data(), N);
        
      
      {
        std::vector<local_scalar_t__> treatment_flat__;
        current_statement__ = 29;
        treatment_flat__ = context__.vals_r("treatment");
        current_statement__ = 29;
        pos__ = 1;
        current_statement__ = 29;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 29;
          stan::model::assign(treatment, treatment_flat__[(pos__ - 1)],
            "assigning variable treatment", stan::model::index_uni(sym1__));
          current_statement__ = 29;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 30;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 31;
      context__.validate_dims("data initialization","y","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      y__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&y) Eigen::Map<Eigen::Matrix<double, -1, 1>>(y__.data(), N);
      
      {
        std::vector<local_scalar_t__> y_flat__;
        current_statement__ = 31;
        y_flat__ = context__.vals_r("y");
        current_statement__ = 31;
        pos__ = 1;
        current_statement__ = 31;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 31;
          stan::model::assign(y, y_flat__[(pos__ - 1)],
            "assigning variable y", stan::model::index_uni(sym1__));
          current_statement__ = 31;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 32;
      stan::math::validate_non_negative_index("eta1", "J", J);
      current_statement__ = 33;
      stan::math::validate_non_negative_index("eta2", "J", J);
      current_statement__ = 34;
      stan::math::validate_non_negative_index("a1", "J", J);
      current_statement__ = 35;
      stan::math::validate_non_negative_index("a2", "J", J);
      current_statement__ = 36;
      stan::math::validate_non_negative_index("y_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + J + J + 1 + 1 + 1 + 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "off_small_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ beta = DUMMY_VAR__;
      current_statement__ = 1;
      beta = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__, -1, 1> eta1 =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(J, DUMMY_VAR__);
      current_statement__ = 2;
      eta1 = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(J);
      Eigen::Matrix<local_scalar_t__, -1, 1> eta2 =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(J, DUMMY_VAR__);
      current_statement__ = 3;
      eta2 = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(J);
      local_scalar_t__ mu_a1 = DUMMY_VAR__;
      current_statement__ = 4;
      mu_a1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ mu_a2 = DUMMY_VAR__;
      current_statement__ = 5;
      mu_a2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma_a1 = DUMMY_VAR__;
      current_statement__ = 6;
      sigma_a1 = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_a2 = DUMMY_VAR__;
      current_statement__ = 7;
      sigma_a2 = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_y = DUMMY_VAR__;
      current_statement__ = 8;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> a1 =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(J, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, 1> a2 =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(J, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 12;
      stan::model::assign(a1,
        stan::math::add((10 * mu_a1), stan::math::multiply(sigma_a1, eta1)),
        "assigning variable a1");
      current_statement__ = 13;
      stan::model::assign(a2,
        stan::math::add((0.1 * mu_a2), stan::math::multiply(sigma_a2, eta2)),
        "assigning variable a2");
      current_statement__ = 15;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 14;
        stan::model::assign(y_hat,
          ((((beta *
               stan::model::rvalue(time, "time", stan::model::index_uni(i)))
              *
              stan::model::rvalue(treatment, "treatment",
                stan::model::index_uni(i))) +
             stan::model::rvalue(a1, "a1",
               stan::model::index_uni(stan::model::rvalue(person, "person",
                                        stan::model::index_uni(i))))) +
            (stan::model::rvalue(a2, "a2",
               stan::model::index_uni(stan::model::rvalue(person, "person",
                                        stan::model::index_uni(i)))) *
              stan::model::rvalue(time, "time", stan::model::index_uni(i)))),
          "assigning variable y_hat", stan::model::index_uni(i));
      }
      {
        current_statement__ = 16;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu_a1, 0, 1));
        current_statement__ = 17;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(eta1, 0, 1));
        current_statement__ = 18;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu_a2, 0, 1));
        current_statement__ = 19;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(eta2, 0, 1));
        current_statement__ = 20;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(beta, 0, 1));
        current_statement__ = 21;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, y_hat, sigma_y));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "off_small_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double beta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      beta = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, 1> eta1 =
         Eigen::Matrix<double, -1, 1>::Constant(J,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      eta1 = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(J);
      Eigen::Matrix<double, -1, 1> eta2 =
         Eigen::Matrix<double, -1, 1>::Constant(J,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      eta2 = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(J);
      double mu_a1 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      mu_a1 = in__.template read<local_scalar_t__>();
      double mu_a2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      mu_a2 = in__.template read<local_scalar_t__>();
      double sigma_a1 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 6;
      sigma_a1 = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 100, lp__);
      double sigma_a2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 7;
      sigma_a2 = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 100, lp__);
      double sigma_y = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 8;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<double, -1, 1> a1 =
         Eigen::Matrix<double, -1, 1>::Constant(J,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> a2 =
         Eigen::Matrix<double, -1, 1>::Constant(J,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> y_hat =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(beta);
      out__.write(eta1);
      out__.write(eta2);
      out__.write(mu_a1);
      out__.write(mu_a2);
      out__.write(sigma_a1);
      out__.write(sigma_a2);
      out__.write(sigma_y);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 12;
      stan::model::assign(a1,
        stan::math::add((10 * mu_a1), stan::math::multiply(sigma_a1, eta1)),
        "assigning variable a1");
      current_statement__ = 13;
      stan::model::assign(a2,
        stan::math::add((0.1 * mu_a2), stan::math::multiply(sigma_a2, eta2)),
        "assigning variable a2");
      current_statement__ = 15;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 14;
        stan::model::assign(y_hat,
          ((((beta *
               stan::model::rvalue(time, "time", stan::model::index_uni(i)))
              *
              stan::model::rvalue(treatment, "treatment",
                stan::model::index_uni(i))) +
             stan::model::rvalue(a1, "a1",
               stan::model::index_uni(stan::model::rvalue(person, "person",
                                        stan::model::index_uni(i))))) +
            (stan::model::rvalue(a2, "a2",
               stan::model::index_uni(stan::model::rvalue(person, "person",
                                        stan::model::index_uni(i)))) *
              stan::model::rvalue(time, "time", stan::model::index_uni(i)))),
          "assigning variable y_hat", stan::model::index_uni(i));
      }
      if (emit_transformed_parameters__) {
        out__.write(a1);
        out__.write(a2);
        out__.write(y_hat);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ beta = DUMMY_VAR__;
      beta = in__.read<local_scalar_t__>();
      out__.write(beta);
      Eigen::Matrix<local_scalar_t__, -1, 1> eta1 =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(J, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        stan::model::assign(eta1, in__.read<local_scalar_t__>(),
          "assigning variable eta1", stan::model::index_uni(sym1__));
      }
      out__.write(eta1);
      Eigen::Matrix<local_scalar_t__, -1, 1> eta2 =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(J, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        stan::model::assign(eta2, in__.read<local_scalar_t__>(),
          "assigning variable eta2", stan::model::index_uni(sym1__));
      }
      out__.write(eta2);
      local_scalar_t__ mu_a1 = DUMMY_VAR__;
      mu_a1 = in__.read<local_scalar_t__>();
      out__.write(mu_a1);
      local_scalar_t__ mu_a2 = DUMMY_VAR__;
      mu_a2 = in__.read<local_scalar_t__>();
      out__.write(mu_a2);
      local_scalar_t__ sigma_a1 = DUMMY_VAR__;
      sigma_a1 = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_a1);
      local_scalar_t__ sigma_a2 = DUMMY_VAR__;
      sigma_a2 = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_a2);
      local_scalar_t__ sigma_y = DUMMY_VAR__;
      sigma_y = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"beta", "eta1", "eta2", "mu_a1",
      "mu_a2", "sigma_a1", "sigma_a2", "sigma_y", "a1", "a2", "y_hat"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(J)},
      std::vector<size_t>{static_cast<size_t>(J)}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(J)},
      std::vector<size_t>{static_cast<size_t>(J)},
      std::vector<size_t>{static_cast<size_t>(N)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "eta1" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "eta2" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "mu_a1");
    param_names__.emplace_back(std::string() + "mu_a2");
    param_names__.emplace_back(std::string() + "sigma_a1");
    param_names__.emplace_back(std::string() + "sigma_a2");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "a1" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "a2" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "eta1" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "eta2" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "mu_a1");
    param_names__.emplace_back(std::string() + "mu_a2");
    param_names__.emplace_back(std::string() + "sigma_a1");
    param_names__.emplace_back(std::string() + "sigma_a2");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "a1" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "a2" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eta1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"eta2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"mu_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eta1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"eta2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"parameters\"},{\"name\":\"mu_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(J) + "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((((1 + J) + J) + 1) + 1) + 1) + 1) + 1);
      const size_t num_transformed = 
  ((J + J) + N);
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((((1 + J) + J) + 1) + 1) + 1) + 1) + 1);
      const size_t num_transformed = 
  ((J + J) + N);
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 8> names__{"beta", "eta1", "eta2",
      "mu_a1", "mu_a2", "sigma_a1", "sigma_a2", "sigma_y"};
      const std::array<Eigen::Index, 8> constrain_param_sizes__{1, J, 
       J, 1, 1, 1, 1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = off_small_model_namespace::off_small_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return off_small_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 optimizations.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace optimizations_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 146> locations_array__ = 
{" (found before start of program)",
 " (in 'optimizations.stan', line 20, column 4 to column 15)",
 " (in 'optimizations.stan', line 21, column 4 to column 13)",
 " (in 'optimizations.stan', line 22, column 4 to column 26)",
 " (in 'optimizations.stan', line 23, column 4 to column 23)",
 " (in 'optimizations.stan', line 24, column 4 to column 24)",
 " (in 'optimizations.stan', line 27, column 4 to column 11)",
 " (in 'optimizations.stan', line 28, column 4 to column 19)",
 " (in 'optimizations.stan', line 29, column 4 to column 19)",
 " (in 'optimizations.stan', line 30, column 17 to column 28)",
 " (in 'optimizations.stan', line 30, column 4 to column 28)",
 " (in 'optimizations.stan', line 32, column 6 to column 24)",
 " (in 'optimizations.stan', line 33, column 6 to column 22)",
 " (in 'optimizations.stan', line 31, column 33 to line 34, column 5)",
 " (in 'optimizations.stan', line 31, column 4 to line 34, column 5)",
 " (in 'optimizations.stan', line 36, column 8 to column 21)",
 " (in 'optimizations.stan', line 35, column 21 to line 37, column 5)",
 " (in 'optimizations.stan', line 35, column 4 to line 37, column 5)",
 " (in 'optimizations.stan', line 41, column 16 to column 29)",
 " (in 'optimizations.stan', line 40, column 12 to line 41, column 29)",
 " (in 'optimizations.stan', line 39, column 8 to line 41, column 29)",
 " (in 'optimizations.stan', line 38, column 4 to line 41, column 29)",
 " (in 'optimizations.stan', line 44, column 10 to column 16)",
 " (in 'optimizations.stan', line 43, column 8 to line 44, column 16)",
 " (in 'optimizations.stan', line 45, column 8 to column 20)",
 " (in 'optimizations.stan', line 42, column 21 to line 46, column 5)",
 " (in 'optimizations.stan', line 42, column 4 to line 46, column 5)",
 " (in 'optimizations.stan', line 49, column 10 to column 19)",
 " (in 'optimizations.stan', line 48, column 8 to line 49, column 19)",
 " (in 'optimizations.stan', line 50, column 8 to column 20)",
 " (in 'optimizations.stan', line 47, column 21 to line 51, column 5)",
 " (in 'optimizations.stan', line 47, column 4 to line 51, column 5)",
 " (in 'optimizations.stan', line 54, column 10 to column 19)",
 " (in 'optimizations.stan', line 53, column 8 to line 54, column 19)",
 " (in 'optimizations.stan', line 55, column 8 to column 20)",
 " (in 'optimizations.stan', line 52, column 21 to line 56, column 5)",
 " (in 'optimizations.stan', line 52, column 4 to line 56, column 5)",
 " (in 'optimizations.stan', line 57, column 4 to column 10)",
 " (in 'optimizations.stan', line 58, column 4 to column 16)",
 " (in 'optimizations.stan', line 60, column 6 to column 12)",
 " (in 'optimizations.stan', line 59, column 4 to line 60, column 12)",
 " (in 'optimizations.stan', line 61, column 4 to column 16)",
 " (in 'optimizations.stan', line 62, column 4 to column 11)",
 " (in 'optimizations.stan', line 63, column 4 to column 12)",
 " (in 'optimizations.stan', line 64, column 4 to column 16)",
 " (in 'optimizations.stan', line 65, column 4 to column 16)",
 " (in 'optimizations.stan', line 66, column 4 to column 16)",
 " (in 'optimizations.stan', line 68, column 6 to column 19)",
 " (in 'optimizations.stan', line 67, column 4 to line 68, column 19)",
 " (in 'optimizations.stan', line 69, column 4 to column 16)",
 " (in 'optimizations.stan', line 70, column 4 to column 11)",
 " (in 'optimizations.stan', line 71, column 4 to column 10)",
 " (in 'optimizations.stan', line 72, column 4 to column 16)",
 " (in 'optimizations.stan', line 74, column 6 to column 12)",
 " (in 'optimizations.stan', line 73, column 4 to line 74, column 12)",
 " (in 'optimizations.stan', line 75, column 4 to column 16)",
 " (in 'optimizations.stan', line 77, column 6 to column 9)",
 " (in 'optimizations.stan', line 76, column 4 to line 77, column 9)",
 " (in 'optimizations.stan', line 78, column 4 to column 16)",
 " (in 'optimizations.stan', line 80, column 8 to column 19)",
 " (in 'optimizations.stan', line 81, column 8 to column 15)",
 " (in 'optimizations.stan', line 82, column 8 to column 20)",
 " (in 'optimizations.stan', line 79, column 4 to line 83, column 5)",
 " (in 'optimizations.stan', line 85, column 8 to column 20)",
 " (in 'optimizations.stan', line 86, column 8 to column 16)",
 " (in 'optimizations.stan', line 87, column 8 to column 20)",
 " (in 'optimizations.stan', line 84, column 4 to line 88, column 5)",
 " (in 'optimizations.stan', line 89, column 11 to column 25)",
 " (in 'optimizations.stan', line 89, column 4 to column 25)",
 " (in 'optimizations.stan', line 90, column 11 to column 23)",
 " (in 'optimizations.stan', line 90, column 4 to column 23)",
 " (in 'optimizations.stan', line 91, column 25 to column 28)",
 " (in 'optimizations.stan', line 91, column 16 to column 19)",
 " (in 'optimizations.stan', line 91, column 4 to column 28)",
 " (in 'optimizations.stan', line 92, column 23 to column 24)",
 " (in 'optimizations.stan', line 92, column 16 to column 17)",
 " (in 'optimizations.stan', line 92, column 4 to column 24)",
 " (in 'optimizations.stan', line 93, column 16 to column 19)",
 " (in 'optimizations.stan', line 93, column 4 to column 19)",
 " (in 'optimizations.stan', line 94, column 16 to column 17)",
 " (in 'optimizations.stan', line 94, column 4 to column 17)",
 " (in 'optimizations.stan', line 95, column 26 to column 27)",
 " (in 'optimizations.stan', line 95, column 19 to column 20)",
 " (in 'optimizations.stan', line 95, column 4 to column 27)",
 " (in 'optimizations.stan', line 96, column 16 to column 30)",
 " (in 'optimizations.stan', line 96, column 14 to column 32)",
 " (in 'optimizations.stan', line 96, column 4 to column 32)",
 " (in 'optimizations.stan', line 97, column 20 to column 26)",
 " (in 'optimizations.stan', line 97, column 4 to column 26)",
 " (in 'optimizations.stan', line 98, column 22 to column 28)",
 " (in 'optimizations.stan', line 98, column 4 to column 28)",
 " (in 'optimizations.stan', line 100, column 6 to column 15)",
 " (in 'optimizations.stan', line 99, column 4 to line 100, column 15)",
 " (in 'optimizations.stan', line 102, column 6 to column 12)",
 " (in 'optimizations.stan', line 101, column 4 to line 102, column 12)",
 " (in 'optimizations.stan', line 104, column 6 to column 7)",
 " (in 'optimizations.stan', line 103, column 4 to line 104, column 7)",
 " (in 'optimizations.stan', line 106, column 6 to column 15)",
 " (in 'optimizations.stan', line 105, column 4 to line 106, column 15)",
 " (in 'optimizations.stan', line 108, column 6 to column 12)",
 " (in 'optimizations.stan', line 107, column 4 to line 108, column 12)",
 " (in 'optimizations.stan', line 110, column 6 to column 7)",
 " (in 'optimizations.stan', line 109, column 4 to line 110, column 7)",
 " (in 'optimizations.stan', line 112, column 8 to column 20)",
 " (in 'optimizations.stan', line 113, column 8 to column 9)",
 " (in 'optimizations.stan', line 114, column 8 to column 9)",
 " (in 'optimizations.stan', line 115, column 8 to column 21)",
 " (in 'optimizations.stan', line 111, column 4 to line 116, column 5)",
 " (in 'optimizations.stan', line 119, column 12 to column 24)",
 " (in 'optimizations.stan', line 120, column 12 to column 13)",
 " (in 'optimizations.stan', line 118, column 8 to line 121, column 9)",
 " (in 'optimizations.stan', line 122, column 8 to column 9)",
 " (in 'optimizations.stan', line 124, column 12 to column 13)",
 " (in 'optimizations.stan', line 123, column 8 to line 125, column 9)",
 " (in 'optimizations.stan', line 126, column 8 to column 10)",
 " (in 'optimizations.stan', line 117, column 4 to line 127, column 5)",
 " (in 'optimizations.stan', line 128, column 4 to column 14)",
 " (in 'optimizations.stan', line 132, column 6 to column 21)",
 " (in 'optimizations.stan', line 130, column 6 to column 19)",
 " (in 'optimizations.stan', line 129, column 4 to line 132, column 21)",
 " (in 'optimizations.stan', line 133, column 4 to column 17)",
 " (in 'optimizations.stan', line 134, column 4 to column 15)",
 " (in 'optimizations.stan', line 136, column 8 to column 22)",
 " (in 'optimizations.stan', line 137, column 8 to column 23)",
 " (in 'optimizations.stan', line 138, column 8 to column 24)",
 " (in 'optimizations.stan', line 135, column 21 to line 139, column 5)",
 " (in 'optimizations.stan', line 135, column 4 to line 139, column 5)",
 " (in 'optimizations.stan', line 140, column 4 to column 25)",
 " (in 'optimizations.stan', line 142, column 6 to column 27)",
 " (in 'optimizations.stan', line 141, column 4 to line 142, column 27)",
 " (in 'optimizations.stan', line 143, column 4 to column 26)",
 " (in 'optimizations.stan', line 144, column 4 to column 22)",
 " (in 'optimizations.stan', line 146, column 6 to column 28)",
 " (in 'optimizations.stan', line 145, column 4 to line 146, column 28)",
 " (in 'optimizations.stan', line 147, column 4 to column 23)",
 " (in 'optimizations.stan', line 4, column 10 to column 17)",
 " (in 'optimizations.stan', line 3, column 8 to line 4, column 17)",
 " (in 'optimizations.stan', line 5, column 8 to column 20)",
 " (in 'optimizations.stan', line 2, column 33 to line 6, column 5)",
 " (in 'optimizations.stan', line 10, column 12 to column 26)",
 " (in 'optimizations.stan', line 9, column 8 to line 10, column 26)",
 " (in 'optimizations.stan', line 11, column 8 to column 21)",
 " (in 'optimizations.stan', line 8, column 20 to line 12, column 5)",
 " (in 'optimizations.stan', line 15, column 8 to column 20)",
 " (in 'optimizations.stan', line 16, column 8 to column 18)",
 " (in 'optimizations.stan', line 14, column 18 to line 17, column 5)"};

struct rfun_functor__ {
  int
  operator()(const int& y, std::ostream* pstream__) const;
};
struct rfun_lp_functor__ {
  template <bool propto__, typename T_lp__, typename T_lp_accum__>
  int
  operator()(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__) const;
};
struct nrfun_lp_functor__ {
  template <bool propto__, typename T0__, typename T_lp__,
            typename T_lp_accum__,
            stan::require_stan_scalar_t<T0__>* = nullptr>
  void
  operator()(const T0__& x, const int& y, T_lp__& lp__,
             T_lp_accum__& lp_accum__, std::ostream* pstream__) const;
};

template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__, stan::require_stan_scalar_t<T0__>* = nullptr>
  void
  nrfun_lp(const T0__& x, const int& y, T_lp__& lp__,
           T_lp_accum__& lp_accum__, std::ostream* pstream__) {
    using local_scalar_t__ = stan::promote_args_t<T0__>;
    int current_statement__ = 0; 
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 136;
      if (stan::math::logical_gt(x, 342)) {
        current_statement__ = 135;
        return ;
      } 
      current_statement__ = 137;
      lp_accum__.add(y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int rfun(const int& y, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 140;
      if (stan::math::logical_gt(y, 2)) {
        current_statement__ = 139;
        return (y + 24);
      } 
      current_statement__ = 141;
      return (y + 2);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <bool propto__, typename T_lp__, typename T_lp_accum__> int
  rfun_lp(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 143;
      lp_accum__.add(2);
      current_statement__ = 144;
      return 24;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int rfun_functor__::operator()(const int& y, std::ostream* pstream__)  const
{
  return rfun(y, pstream__);
}

template <bool propto__, typename T_lp__, typename T_lp_accum__>
int
rfun_lp_functor__::operator()(T_lp__& lp__, T_lp_accum__& lp_accum__,
                              std::ostream* pstream__)  const
{
  return rfun_lp<propto__>(lp__, lp_accum__, pstream__);
}

template <bool propto__, typename T0__, typename T_lp__,
          typename T_lp_accum__, stan::require_stan_scalar_t<T0__>*>
void
nrfun_lp_functor__::operator()(const T0__& x, const int& y, T_lp__& lp__,
                               T_lp_accum__& lp_accum__,
                               std::ostream* pstream__)  const
{
  return nrfun_lp<propto__>(x, y, lp__, lp_accum__, pstream__);
}


class optimizations_model final : public model_base_crtp<optimizations_model> {

 private:
   
  
 
 public:
  ~optimizations_model() { }
  
  inline std::string model_name() const final { return "optimizations_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  optimizations_model(stan::io::var_context& context__,
                      unsigned int random_seed__ = 0,
                      std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "optimizations_model_namespace::optimizations_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + (3 * 2) + 2 + (2 + ((2 * (2 - 1)) / 2));
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "optimizations_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ theta = DUMMY_VAR__;
      current_statement__ = 1;
      theta = in__.template read<local_scalar_t__>();
      local_scalar_t__ phi = DUMMY_VAR__;
      current_statement__ = 2;
      phi = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__, -1, -1> x_matrix =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(3, 2, DUMMY_VAR__);
      current_statement__ = 3;
      x_matrix = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                   3, 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> x_vector =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 4;
      x_vector = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                   2);
      Eigen::Matrix<local_scalar_t__, -1, -1> x_cov =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(2, 2, DUMMY_VAR__);
      current_statement__ = 5;
      x_cov = in__.template read_constrain_cov_matrix<
                Eigen::Matrix<local_scalar_t__, -1, -1>, jacobian__>(lp__, 2);
      {
        local_scalar_t__ x = DUMMY_VAR__;
        current_statement__ = 7;
        nrfun_lp<propto__>(4, 3, lp__, lp_accum__, pstream__);
        current_statement__ = 8;
        if (pstream__) {
          stan::math::stan_print(pstream__, rfun(3, pstream__));
          stan::math::stan_print(pstream__, "\n");
        }
        current_statement__ = 10;
        if (rfun(4, pstream__)) {
          current_statement__ = 9;
          if (pstream__) {
            stan::math::stan_print(pstream__, "a");
            stan::math::stan_print(pstream__, "\n");
          }
        } 
        current_statement__ = 14;
        for (int i = rfun(7, pstream__); i <= rfun(5, pstream__); ++i) {
          current_statement__ = 11;
          lp_accum__.add(rfun(8, pstream__));
          current_statement__ = 12;
          nrfun_lp<propto__>(34, 3, lp__, lp_accum__, pstream__);
        }
        current_statement__ = 17;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 15;
          lp_accum__.add(53);
        }
        current_statement__ = 21;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 20;
          for (int j = i; j <= (i + 2); ++j) {
            current_statement__ = 19;
            for (int k = j; k <= (j * 2); ++k) {
              current_statement__ = 18;
              lp_accum__.add(53);
            }
          }
        }
        current_statement__ = 26;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 23;
          if (stan::math::logical_gt(i, 4)) {
            break;
          } 
          current_statement__ = 24;
          lp_accum__.add(2);
        }
        current_statement__ = 31;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 28;
          if (stan::math::logical_gt(i, 4)) {
            continue;
          } 
          current_statement__ = 29;
          lp_accum__.add(2);
        }
        current_statement__ = 36;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 33;
          if (stan::math::logical_gt(i, 4)) {
            continue;
          } 
          current_statement__ = 34;
          lp_accum__.add(2);
        }
        current_statement__ = 37;
        x = 3;
        current_statement__ = 38;
        lp_accum__.add(x);
        current_statement__ = 40;
        if (stan::math::logical_gt(theta, 2)) {
          current_statement__ = 39;
          x = 2;
        } 
        current_statement__ = 41;
        lp_accum__.add(x);
        current_statement__ = 42;
        x = 24;
        current_statement__ = 43;
        x = 247;
        current_statement__ = 44;
        lp_accum__.add(x);
        current_statement__ = 45;
        x = (24 * 24);
        current_statement__ = 46;
        lp_accum__.add(x);
        current_statement__ = 48;
        if (stan::math::logical_gt(theta, 46)) {
          current_statement__ = 47;
          x = (24 * 245);
        } 
        current_statement__ = 49;
        lp_accum__.add(x);
        local_scalar_t__ z = DUMMY_VAR__;
        current_statement__ = 51;
        z = x;
        current_statement__ = 52;
        lp_accum__.add(z);
        current_statement__ = 54;
        if (stan::math::logical_gt(theta, 46)) {
          current_statement__ = 53;
          z = x;
        } 
        current_statement__ = 55;
        lp_accum__.add(z);
        current_statement__ = 57;
        for (int i = 14; i <= 35; ++i) { }
        current_statement__ = 58;
        lp_accum__.add(2);
        {
          local_scalar_t__ y = DUMMY_VAR__;
          current_statement__ = 59;
          y = 2;
          current_statement__ = 60;
          y = 24;
          current_statement__ = 61;
          lp_accum__.add(y);
        }
        {
          local_scalar_t__ y = DUMMY_VAR__;
          current_statement__ = 63;
          y = 22;
          current_statement__ = 64;
          y = 245;
          current_statement__ = 65;
          lp_accum__.add(y);
        }
        current_statement__ = 68;
        if (0) {
          current_statement__ = 67;
          lp_accum__.add(235);
        } 
        current_statement__ = 70;
        if (1) {
          current_statement__ = 69;
          lp_accum__.add(2);
        } 
        current_statement__ = 73;
        if ((24 * 2)) {
          
        } else {
          
        }
        current_statement__ = 76;
        if ((24 * 2)) {
          ;
        } else {
          ;
        }
        current_statement__ = 78;
        if ((24 * 2)) {
          
        } 
        current_statement__ = 80;
        if ((20 * 2)) {
          ;
        } 
        current_statement__ = 83;
        if (rfun_lp<propto__>(lp__, lp_accum__, pstream__)) {
          ;
        } else {
          ;
        }
        current_statement__ = 86;
        while (0) {
          current_statement__ = 84;
          lp_accum__.add(325);
        }
        current_statement__ = 88;
        while ((24 * 24)) {
          break;
        }
        current_statement__ = 90;
        while (rfun_lp<propto__>(lp__, lp_accum__, pstream__)) {
          break;
        }
        current_statement__ = 92;
        for (int i = 31; i <= 225; ++i) { continue;}
        current_statement__ = 94;
        for (int i = 31; i <= 225; ++i) { break;}
        current_statement__ = 96;
        for (int i = 31; i <= 225; ++i) { ;}
        current_statement__ = 98;
        for (int i = rfun_lp<propto__>(lp__, lp_accum__, pstream__);
             i <= 225; ++i) {
          continue;
        }
        current_statement__ = 100;
        for (int i = rfun_lp<propto__>(lp__, lp_accum__, pstream__);
             i <= 225; ++i) {
          break;
        }
        current_statement__ = 102;
        for (int i = rfun_lp<propto__>(lp__, lp_accum__, pstream__);
             i <= 225; ++i) {
          ;
        }
        {
          current_statement__ = 103;
          lp_accum__.add(1);
          ;
          ;
          current_statement__ = 106;
          lp_accum__.add(24);
        }
        {
          {
            current_statement__ = 108;
            lp_accum__.add(1);
            ;
          }
          ;
          {
            ;
          }
          {
            
          }
        }
        local_scalar_t__ temp = DUMMY_VAR__;
        current_statement__ = 119;
        if (stan::math::logical_gt(2, 3)) {
          current_statement__ = 118;
          temp = (2 * 2);
        } else {
          current_statement__ = 117;
          if (pstream__) {
            stan::math::stan_print(pstream__, "hello");
            stan::math::stan_print(pstream__, "\n");
          }
        }
        current_statement__ = 120;
        temp = (2 * 2);
        local_scalar_t__ temp2 = DUMMY_VAR__;
        current_statement__ = 126;
        for (int i = 2; i <= 3; ++i) {
          current_statement__ = 122;
          temp2 = (2 * 3);
          current_statement__ = 123;
          lp_accum__.add(temp);
          current_statement__ = 124;
          lp_accum__.add(temp2);
        }
        local_scalar_t__ dataonlyvar = DUMMY_VAR__;
        current_statement__ = 127;
        dataonlyvar = 3;
        current_statement__ = 129;
        if (stan::math::logical_gt(3, 4)) {
          current_statement__ = 128;
          dataonlyvar = (3 * 53);
        } 
        current_statement__ = 130;
        lp_accum__.add(dataonlyvar);
        local_scalar_t__ paramvar = DUMMY_VAR__;
        current_statement__ = 131;
        paramvar = 3;
        current_statement__ = 133;
        if (stan::math::logical_gt(42, 1)) {
          current_statement__ = 132;
          paramvar = (theta * 34);
        } 
        current_statement__ = 134;
        lp_accum__.add(paramvar);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "optimizations_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double theta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      theta = in__.template read<local_scalar_t__>();
      double phi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      phi = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, -1> x_matrix =
         Eigen::Matrix<double, -1, -1>::Constant(3, 2,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      x_matrix = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                   3, 2);
      Eigen::Matrix<double, -1, 1> x_vector =
         Eigen::Matrix<double, -1, 1>::Constant(2,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 4;
      x_vector = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                   2);
      Eigen::Matrix<double, -1, -1> x_cov =
         Eigen::Matrix<double, -1, -1>::Constant(2, 2,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      x_cov = in__.template read_constrain_cov_matrix<
                Eigen::Matrix<local_scalar_t__, -1, -1>, jacobian__>(lp__, 2);
      out__.write(theta);
      out__.write(phi);
      out__.write(x_matrix);
      out__.write(x_vector);
      out__.write(x_cov);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ theta = DUMMY_VAR__;
      theta = in__.read<local_scalar_t__>();
      out__.write(theta);
      local_scalar_t__ phi = DUMMY_VAR__;
      phi = in__.read<local_scalar_t__>();
      out__.write(phi);
      Eigen::Matrix<local_scalar_t__, -1, -1> x_matrix =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(3, 2, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          stan::model::assign(x_matrix, in__.read<local_scalar_t__>(),
            "assigning variable x_matrix", stan::model::index_uni(sym2__),
                                             stan::model::index_uni(sym1__));
        }
      }
      out__.write(x_matrix);
      Eigen::Matrix<local_scalar_t__, -1, 1> x_vector =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(2, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        stan::model::assign(x_vector, in__.read<local_scalar_t__>(),
          "assigning variable x_vector", stan::model::index_uni(sym1__));
      }
      out__.write(x_vector);
      Eigen::Matrix<local_scalar_t__, -1, -1> x_cov =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(2, 2, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          stan::model::assign(x_cov, in__.read<local_scalar_t__>(),
            "assigning variable x_cov", stan::model::index_uni(sym2__),
                                          stan::model::index_uni(sym1__));
        }
      }
      out__.write_free_cov_matrix(x_cov);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"theta", "phi", "x_matrix",
      "x_vector", "x_cov"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(3), static_cast<size_t>(2)},
      std::vector<size_t>{static_cast<size_t>(2)},
      std::vector<size_t>{static_cast<size_t>(2), static_cast<size_t>(2)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "theta");
    param_names__.emplace_back(std::string() + "phi");
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "x_matrix" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x_vector" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "x_cov" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "theta");
    param_names__.emplace_back(std::string() + "phi");
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "x_matrix" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x_vector" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= (2 + ((2 * (2 - 1)) / 2)); ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x_cov" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_matrix\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"x_vector\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"x_cov\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(2) + "},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_matrix\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(3) + ",\"cols\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"x_vector\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"x_cov\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((2 + ((2 * (2 - 1)) / 2))) + "},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((1 + 1) + (3 * 2)) + 2) + (2 * 2));
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((1 + 1) + (3 * 2)) + 2) + (2 * 2));
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 5> names__{"theta", "phi", "x_matrix",
      "x_vector", "x_cov"};
      const std::array<Eigen::Index, 5> constrain_param_sizes__{1, 1, 
       (3 * 2), 2, (2 * 2)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } 
using stan_model = optimizations_model_namespace::optimizations_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return optimizations_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 overloaded-fn.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace overloaded_fn_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 6> locations_array__ = 
{" (found before start of program)",
 " (in 'overloaded-fn.stan', line 13, column 2 to column 22)",
 " (in 'overloaded-fn.stan', line 3, column 5 to column 20)",
 " (in 'overloaded-fn.stan', line 2, column 20 to line 4, column 4)",
 " (in 'overloaded-fn.stan', line 7, column 5 to column 20)",
 " (in 'overloaded-fn.stan', line 6, column 19 to line 8, column 4)"};

struct dumb_functor__ {
  double
  operator()(const int& x, std::ostream* pstream__) const;
  template <typename T0__, stan::require_stan_scalar_t<T0__>* = nullptr>
  stan::promote_args_t<T0__>
  operator()(const T0__& x, std::ostream* pstream__) const;
};

template <typename T0__, stan::require_stan_scalar_t<T0__>* = nullptr>
  stan::promote_args_t<T0__> dumb(const T0__& x, std::ostream* pstream__) {
    using local_scalar_t__ = stan::promote_args_t<T0__>;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 2;
      return (x + 0.5);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
double dumb(const int& x, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 4;
      return (x - 0.5);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
double dumb_functor__::operator()(const int& x, std::ostream* pstream__) 
const
{
  return dumb(x, pstream__);
}

template <typename T0__, stan::require_stan_scalar_t<T0__>*>
stan::promote_args_t<T0__>
dumb_functor__::operator()(const T0__& x, std::ostream* pstream__)  const
{
  return dumb(x, pstream__);
}


class overloaded_fn_model final : public model_base_crtp<overloaded_fn_model> {

 private:
   
  
 
 public:
  ~overloaded_fn_model() { }
  
  inline std::string model_name() const final { return "overloaded_fn_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  overloaded_fn_model(stan::io::var_context& context__,
                      unsigned int random_seed__ = 0,
                      std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "overloaded_fn_model_namespace::overloaded_fn_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "overloaded_fn_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      {
        current_statement__ = 1;
        lp_accum__.add(dumb(1.0, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "overloaded_fn_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 0> names__{};
      const std::array<Eigen::Index, 0> constrain_param_sizes__{};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } 
using stan_model = overloaded_fn_model_namespace::overloaded_fn_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return overloaded_fn_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 partial-eval.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace partial_eval_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 25> locations_array__ = 
{" (found before start of program)",
 " (in 'partial-eval.stan', line 10, column 2 to column 19)",
 " (in 'partial-eval.stan', line 11, column 2 to column 17)",
 " (in 'partial-eval.stan', line 12, column 2 to column 12)",
 " (in 'partial-eval.stan', line 13, column 2 to column 35)",
 " (in 'partial-eval.stan', line 14, column 2 to column 35)",
 " (in 'partial-eval.stan', line 17, column 2 to column 18)",
 " (in 'partial-eval.stan', line 20, column 4 to column 75)",
 " (in 'partial-eval.stan', line 19, column 2 to line 20, column 75)",
 " (in 'partial-eval.stan', line 23, column 2 to column 22)",
 " (in 'partial-eval.stan', line 24, column 2 to column 34)",
 " (in 'partial-eval.stan', line 25, column 2 to column 24)",
 " (in 'partial-eval.stan', line 26, column 2 to column 29)",
 " (in 'partial-eval.stan', line 2, column 2 to column 17)",
 " (in 'partial-eval.stan', line 3, column 2 to column 22)",
 " (in 'partial-eval.stan', line 4, column 8 to column 9)",
 " (in 'partial-eval.stan', line 4, column 2 to column 43)",
 " (in 'partial-eval.stan', line 5, column 9 to column 10)",
 " (in 'partial-eval.stan', line 5, column 2 to column 21)",
 " (in 'partial-eval.stan', line 6, column 27 to column 28)",
 " (in 'partial-eval.stan', line 6, column 2 to column 40)",
 " (in 'partial-eval.stan', line 7, column 9 to column 10)",
 " (in 'partial-eval.stan', line 7, column 2 to column 14)",
 " (in 'partial-eval.stan', line 10, column 9 to column 15)",
 " (in 'partial-eval.stan', line 17, column 9 to column 10)"};




class partial_eval_model final : public model_base_crtp<partial_eval_model> {

 private:
  int N;
  int n_pair;
  std::vector<int> pair;
  Eigen::Matrix<double, -1, 1> pre_test__;
  Eigen::Matrix<double, -1, 1> treatment__;
  Eigen::Matrix<double, -1, 1> y__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> pre_test{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> treatment{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> y{nullptr, 0};
 
 public:
  ~partial_eval_model() { }
  
  inline std::string model_name() const final { return "partial_eval_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  partial_eval_model(stan::io::var_context& context__,
                     unsigned int random_seed__ = 0,
                     std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "partial_eval_model_namespace::partial_eval_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 13;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      
      current_statement__ = 13;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 13;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 14;
      context__.validate_dims("data initialization","n_pair","int",
           std::vector<size_t>{});
      n_pair = std::numeric_limits<int>::min();
      
      
      current_statement__ = 14;
      n_pair = context__.vals_i("n_pair")[(1 - 1)];
      current_statement__ = 14;
      stan::math::check_greater_or_equal(function__, "n_pair", n_pair, 0);
      current_statement__ = 15;
      stan::math::validate_non_negative_index("pair", "N", N);
      current_statement__ = 16;
      context__.validate_dims("data initialization","pair","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      pair = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 16;
      pair = context__.vals_i("pair");
      current_statement__ = 16;
      stan::math::check_greater_or_equal(function__, "pair", pair, 1);
      current_statement__ = 16;
      stan::math::check_less_or_equal(function__, "pair", pair, n_pair);
      current_statement__ = 17;
      stan::math::validate_non_negative_index("pre_test", "N", N);
      current_statement__ = 18;
      context__.validate_dims("data initialization","pre_test","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      pre_test__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&pre_test) Eigen::Map<Eigen::Matrix<double, -1, 1>>(pre_test__.data(), N);
        
      
      {
        std::vector<local_scalar_t__> pre_test_flat__;
        current_statement__ = 18;
        pre_test_flat__ = context__.vals_r("pre_test");
        current_statement__ = 18;
        pos__ = 1;
        current_statement__ = 18;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 18;
          stan::model::assign(pre_test, pre_test_flat__[(pos__ - 1)],
            "assigning variable pre_test", stan::model::index_uni(sym1__));
          current_statement__ = 18;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 19;
      stan::math::validate_non_negative_index("treatment", "N", N);
      current_statement__ = 20;
      context__.validate_dims("data initialization","treatment","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      treatment__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&treatment) Eigen::Map<Eigen::Matrix<double, -1, 1>>(treatment__.data(), N);
        
      
      {
        std::vector<local_scalar_t__> treatment_flat__;
        current_statement__ = 20;
        treatment_flat__ = context__.vals_r("treatment");
        current_statement__ = 20;
        pos__ = 1;
        current_statement__ = 20;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 20;
          stan::model::assign(treatment, treatment_flat__[(pos__ - 1)],
            "assigning variable treatment", stan::model::index_uni(sym1__));
          current_statement__ = 20;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 20;
      stan::math::check_greater_or_equal(function__, "treatment", treatment,
                                            0);
      current_statement__ = 20;
      stan::math::check_less_or_equal(function__, "treatment", treatment, 1);
      current_statement__ = 21;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 22;
      context__.validate_dims("data initialization","y","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      y__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&y) Eigen::Map<Eigen::Matrix<double, -1, 1>>(y__.data(), N);
      
      {
        std::vector<local_scalar_t__> y_flat__;
        current_statement__ = 22;
        y_flat__ = context__.vals_r("y");
        current_statement__ = 22;
        pos__ = 1;
        current_statement__ = 22;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 22;
          stan::model::assign(y, y_flat__[(pos__ - 1)],
            "assigning variable y", stan::model::index_uni(sym1__));
          current_statement__ = 22;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 23;
      stan::math::validate_non_negative_index("a", "n_pair", n_pair);
      current_statement__ = 24;
      stan::math::validate_non_negative_index("y_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = n_pair + 2 + 1 + 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "partial_eval_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_pair,
           DUMMY_VAR__);
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_pair);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 2;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(2);
      local_scalar_t__ mu_a = DUMMY_VAR__;
      current_statement__ = 3;
      mu_a = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma_a = DUMMY_VAR__;
      current_statement__ = 4;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      local_scalar_t__ sigma_y = DUMMY_VAR__;
      current_statement__ = 5;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 8;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 7;
        stan::model::assign(y_hat,
          ((stan::model::rvalue(a, "a",
              stan::model::index_uni(stan::model::rvalue(pair, "pair",
                                       stan::model::index_uni(i)))) +
             (stan::model::rvalue(beta, "beta", stan::model::index_uni(1)) *
               stan::model::rvalue(treatment, "treatment",
                 stan::model::index_uni(i)))) +
            (stan::model::rvalue(beta, "beta", stan::model::index_uni(2)) *
              stan::model::rvalue(pre_test, "pre_test",
                stan::model::index_uni(i)))),
          "assigning variable y_hat", stan::model::index_uni(i));
      }
      {
        current_statement__ = 9;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(mu_a, 0, 1));
        current_statement__ = 10;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(a, (100 * mu_a), sigma_a));
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(beta, 0, 100));
        current_statement__ = 12;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y, y_hat, sigma_y));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "partial_eval_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, 1> a =
         Eigen::Matrix<double, -1, 1>::Constant(n_pair,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_pair);
      Eigen::Matrix<double, -1, 1> beta =
         Eigen::Matrix<double, -1, 1>::Constant(2,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(2);
      double mu_a = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      mu_a = in__.template read<local_scalar_t__>();
      double sigma_a = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      sigma_a = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      double sigma_y = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      sigma_y = in__.template read_constrain_lub<local_scalar_t__, 
                  jacobian__>(0, 100, lp__);
      Eigen::Matrix<double, -1, 1> y_hat =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(a);
      out__.write(beta);
      out__.write(mu_a);
      out__.write(sigma_a);
      out__.write(sigma_y);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 8;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 7;
        stan::model::assign(y_hat,
          ((stan::model::rvalue(a, "a",
              stan::model::index_uni(stan::model::rvalue(pair, "pair",
                                       stan::model::index_uni(i)))) +
             (stan::model::rvalue(beta, "beta", stan::model::index_uni(1)) *
               stan::model::rvalue(treatment, "treatment",
                 stan::model::index_uni(i)))) +
            (stan::model::rvalue(beta, "beta", stan::model::index_uni(2)) *
              stan::model::rvalue(pre_test, "pre_test",
                stan::model::index_uni(i)))),
          "assigning variable y_hat", stan::model::index_uni(i));
      }
      if (emit_transformed_parameters__) {
        out__.write(y_hat);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, 1> a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(n_pair,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= n_pair; ++sym1__) {
        stan::model::assign(a, in__.read<local_scalar_t__>(),
          "assigning variable a", stan::model::index_uni(sym1__));
      }
      out__.write(a);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(2, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        stan::model::assign(beta, in__.read<local_scalar_t__>(),
          "assigning variable beta", stan::model::index_uni(sym1__));
      }
      out__.write(beta);
      local_scalar_t__ mu_a = DUMMY_VAR__;
      mu_a = in__.read<local_scalar_t__>();
      out__.write(mu_a);
      local_scalar_t__ sigma_a = DUMMY_VAR__;
      sigma_a = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_a);
      local_scalar_t__ sigma_y = DUMMY_VAR__;
      sigma_y = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 100, sigma_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"a", "beta", "mu_a", "sigma_a",
      "sigma_y", "y_hat"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(n_pair)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(2)}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(N)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= n_pair; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "mu_a");
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= n_pair; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "mu_a");
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_pair) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"mu_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_pair) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"mu_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((n_pair + 2) + 1) + 1) + 1);
      const size_t num_transformed = N;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((n_pair + 2) + 1) + 1) + 1);
      const size_t num_transformed = N;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 5> names__{"a", "beta", "mu_a",
      "sigma_a", "sigma_y"};
      const std::array<Eigen::Index, 5> constrain_param_sizes__{n_pair, 
       2, 1, 1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = partial_eval_model_namespace::partial_eval_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return partial_eval_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 partial_eval_multiply.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace partial_eval_multiply_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 11> locations_array__ = 
{" (found before start of program)",
 " (in 'partial_eval_multiply.stan', line 8, column 2 to column 20)",
 " (in 'partial_eval_multiply.stan', line 9, column 2 to column 20)",
 " (in 'partial_eval_multiply.stan', line 12, column 2 to column 52)",
 " (in 'partial_eval_multiply.stan', line 13, column 2 to column 36)",
 " (in 'partial_eval_multiply.stan', line 14, column 2 to column 36)",
 " (in 'partial_eval_multiply.stan', line 15, column 2 to column 40)",
 " (in 'partial_eval_multiply.stan', line 2, column 2 to column 20)",
 " (in 'partial_eval_multiply.stan', line 3, column 2 to column 20)",
 " (in 'partial_eval_multiply.stan', line 4, column 2 to column 20)",
 " (in 'partial_eval_multiply.stan', line 5, column 2 to column 20)"};




class partial_eval_multiply_model final : public model_base_crtp<partial_eval_multiply_model> {

 private:
  Eigen::Matrix<double, -1, -1> m1__;
  Eigen::Matrix<double, -1, -1> m4__;
  std::vector<int> idx;
  std::vector<int> idy; 
  Eigen::Map<Eigen::Matrix<double, -1, -1>> m1{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double, -1, -1>> m4{nullptr, 0, 0};
 
 public:
  ~partial_eval_multiply_model() { }
  
  inline std::string model_name() const final { return "partial_eval_multiply_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  partial_eval_multiply_model(stan::io::var_context& context__,
                              unsigned int random_seed__ = 0,
                              std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "partial_eval_multiply_model_namespace::partial_eval_multiply_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 7;
      context__.validate_dims("data initialization","m1","double",
           std::vector<size_t>{static_cast<size_t>(10),
            static_cast<size_t>(10)});
      m1__ = 
        Eigen::Matrix<double, -1, -1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      new (&m1) Eigen::Map<Eigen::Matrix<double, -1, -1>>(m1__.data(), 10, 10);
        
      
      {
        std::vector<local_scalar_t__> m1_flat__;
        current_statement__ = 7;
        m1_flat__ = context__.vals_r("m1");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          current_statement__ = 7;
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            current_statement__ = 7;
            stan::model::assign(m1, m1_flat__[(pos__ - 1)],
              "assigning variable m1", stan::model::index_uni(sym2__),
                                         stan::model::index_uni(sym1__));
            current_statement__ = 7;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 8;
      context__.validate_dims("data initialization","m4","double",
           std::vector<size_t>{static_cast<size_t>(10),
            static_cast<size_t>(10)});
      m4__ = 
        Eigen::Matrix<double, -1, -1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      new (&m4) Eigen::Map<Eigen::Matrix<double, -1, -1>>(m4__.data(), 10, 10);
        
      
      {
        std::vector<local_scalar_t__> m4_flat__;
        current_statement__ = 8;
        m4_flat__ = context__.vals_r("m4");
        current_statement__ = 8;
        pos__ = 1;
        current_statement__ = 8;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          current_statement__ = 8;
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            current_statement__ = 8;
            stan::model::assign(m4, m4_flat__[(pos__ - 1)],
              "assigning variable m4", stan::model::index_uni(sym2__),
                                         stan::model::index_uni(sym1__));
            current_statement__ = 8;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 9;
      context__.validate_dims("data initialization","idx","int",
           std::vector<size_t>{static_cast<size_t>(10)});
      idx = std::vector<int>(10, std::numeric_limits<int>::min());
      
      
      current_statement__ = 9;
      idx = context__.vals_i("idx");
      current_statement__ = 10;
      context__.validate_dims("data initialization","idy","int",
           std::vector<size_t>{static_cast<size_t>(10)});
      idy = std::vector<int>(10, std::numeric_limits<int>::min());
      
      
      current_statement__ = 10;
      idy = context__.vals_i("idy");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (10 * 10) + (10 * 10);
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "partial_eval_multiply_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, -1> m2 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 1;
      m2 = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
             10);
      Eigen::Matrix<local_scalar_t__, -1, -1> m3 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 2;
      m3 = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
             10);
      {
        Eigen::Matrix<local_scalar_t__, -1, -1> m5 =
           Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
             DUMMY_VAR__);
        current_statement__ = 3;
        stan::model::assign(m5,
          stan::math::add(
            stan::math::multiply(m1,
              stan::math::elt_multiply(m2,
                stan::model::rvalue(m3, "m3",
                  stan::model::index_multi(idx),
                    stan::model::index_multi(idy)))), m4),
          "assigning variable m5");
        Eigen::Matrix<local_scalar_t__, -1, -1> m6 =
           Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
             DUMMY_VAR__);
        current_statement__ = 4;
        stan::model::assign(m6,
          stan::math::add(stan::math::elt_multiply(m1, m2), m4),
          "assigning variable m6");
        Eigen::Matrix<local_scalar_t__, -1, -1> m7 =
           Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
             DUMMY_VAR__);
        current_statement__ = 5;
        stan::model::assign(m7,
          stan::math::add(m4, stan::math::elt_multiply(m1, m2)),
          "assigning variable m7");
        current_statement__ = 6;
        lp_accum__.add(
          ((stan::math::sum(m5) + stan::math::sum(m6)) + stan::math::sum(m7)));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "partial_eval_multiply_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, -1> m2 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      m2 = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
             10);
      Eigen::Matrix<double, -1, -1> m3 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      m3 = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
             10);
      out__.write(m2);
      out__.write(m3);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, -1> m2 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          stan::model::assign(m2, in__.read<local_scalar_t__>(),
            "assigning variable m2", stan::model::index_uni(sym2__),
                                       stan::model::index_uni(sym1__));
        }
      }
      out__.write(m2);
      Eigen::Matrix<local_scalar_t__, -1, -1> m3 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          stan::model::assign(m3, in__.read<local_scalar_t__>(),
            "assigning variable m3", stan::model::index_uni(sym2__),
                                       stan::model::index_uni(sym1__));
        }
      }
      out__.write(m3);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"m2", "m3"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(10)
                                                                   ,
                                                                   static_cast<size_t>(10)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "m2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "m3" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "m2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "m3" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"m2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"m3\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"m2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"m3\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((10 * 10) + (10 * 10));
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((10 * 10) + (10 * 10));
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"m2", "m3"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{(10 * 10),
       (10 * 10)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}

using stan_model = partial_eval_multiply_model_namespace::partial_eval_multiply_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return partial_eval_multiply_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 stalled1-failure.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace stalled1_failure_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 34> locations_array__ = 
{" (found before start of program)",
 " (in 'stalled1-failure.stan', line 27, column 2 to column 14)",
 " (in 'stalled1-failure.stan', line 28, column 2 to column 14)",
 " (in 'stalled1-failure.stan', line 29, column 2 to column 14)",
 " (in 'stalled1-failure.stan', line 30, column 2 to column 15)",
 " (in 'stalled1-failure.stan', line 31, column 2 to column 20)",
 " (in 'stalled1-failure.stan', line 32, column 2 to column 23)",
 " (in 'stalled1-failure.stan', line 35, column 2 to column 13)",
 " (in 'stalled1-failure.stan', line 36, column 2 to column 24)",
 " (in 'stalled1-failure.stan', line 39, column 2 to column 30)",
 " (in 'stalled1-failure.stan', line 40, column 2 to column 30)",
 " (in 'stalled1-failure.stan', line 41, column 2 to column 30)",
 " (in 'stalled1-failure.stan', line 42, column 2 to column 31)",
 " (in 'stalled1-failure.stan', line 43, column 2 to column 30)",
 " (in 'stalled1-failure.stan', line 45, column 4 to column 30)",
 " (in 'stalled1-failure.stan', line 46, column 4 to line 48, column 54)",
 " (in 'stalled1-failure.stan', line 44, column 19 to line 49, column 3)",
 " (in 'stalled1-failure.stan', line 44, column 2 to line 49, column 3)",
 " (in 'stalled1-failure.stan', line 14, column 2 to column 17)",
 " (in 'stalled1-failure.stan', line 15, column 8 to column 9)",
 " (in 'stalled1-failure.stan', line 15, column 2 to column 26)",
 " (in 'stalled1-failure.stan', line 16, column 8 to column 9)",
 " (in 'stalled1-failure.stan', line 16, column 2 to column 26)",
 " (in 'stalled1-failure.stan', line 17, column 9 to column 10)",
 " (in 'stalled1-failure.stan', line 17, column 2 to column 15)",
 " (in 'stalled1-failure.stan', line 18, column 9 to column 10)",
 " (in 'stalled1-failure.stan', line 18, column 2 to column 15)",
 " (in 'stalled1-failure.stan', line 21, column 2 to column 8)",
 " (in 'stalled1-failure.stan', line 22, column 9 to column 10)",
 " (in 'stalled1-failure.stan', line 22, column 2 to column 17)",
 " (in 'stalled1-failure.stan', line 23, column 2 to column 8)",
 " (in 'stalled1-failure.stan', line 24, column 2 to column 18)",
 " (in 'stalled1-failure.stan', line 32, column 8 to column 9)",
 " (in 'stalled1-failure.stan', line 32, column 18 to column 19)"};




class stalled1_failure_model final : public model_base_crtp<stalled1_failure_model> {

 private:
  int I;
  std::vector<int> n;
  std::vector<int> N;
  Eigen::Matrix<double, -1, 1> x1__;
  Eigen::Matrix<double, -1, 1> x2__;
  int K;
  Eigen::Matrix<double, -1, 1> x1x2__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> x1{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> x2{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> x1x2{nullptr, 0};
 
 public:
  ~stalled1_failure_model() { }
  
  inline std::string model_name() const final { return "stalled1_failure_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  stalled1_failure_model(stan::io::var_context& context__,
                         unsigned int random_seed__ = 0,
                         std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "stalled1_failure_model_namespace::stalled1_failure_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 18;
      context__.validate_dims("data initialization","I","int",
           std::vector<size_t>{});
      I = std::numeric_limits<int>::min();
      
      
      current_statement__ = 18;
      I = context__.vals_i("I")[(1 - 1)];
      current_statement__ = 18;
      stan::math::check_greater_or_equal(function__, "I", I, 0);
      current_statement__ = 19;
      stan::math::validate_non_negative_index("n", "I", I);
      current_statement__ = 20;
      context__.validate_dims("data initialization","n","int",
           std::vector<size_t>{static_cast<size_t>(I)});
      n = std::vector<int>(I, std::numeric_limits<int>::min());
      
      
      current_statement__ = 20;
      n = context__.vals_i("n");
      current_statement__ = 20;
      stan::math::check_greater_or_equal(function__, "n", n, 0);
      current_statement__ = 21;
      stan::math::validate_non_negative_index("N", "I", I);
      current_statement__ = 22;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{static_cast<size_t>(I)});
      N = std::vector<int>(I, std::numeric_limits<int>::min());
      
      
      current_statement__ = 22;
      N = context__.vals_i("N");
      current_statement__ = 22;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 23;
      stan::math::validate_non_negative_index("x1", "I", I);
      current_statement__ = 24;
      context__.validate_dims("data initialization","x1","double",
           std::vector<size_t>{static_cast<size_t>(I)});
      x1__ = 
        Eigen::Matrix<double, -1, 1>::Constant(I,
          std::numeric_limits<double>::quiet_NaN());
      new (&x1) Eigen::Map<Eigen::Matrix<double, -1, 1>>(x1__.data(), I);
      
      {
        std::vector<local_scalar_t__> x1_flat__;
        current_statement__ = 24;
        x1_flat__ = context__.vals_r("x1");
        current_statement__ = 24;
        pos__ = 1;
        current_statement__ = 24;
        for (int sym1__ = 1; sym1__ <= I; ++sym1__) {
          current_statement__ = 24;
          stan::model::assign(x1, x1_flat__[(pos__ - 1)],
            "assigning variable x1", stan::model::index_uni(sym1__));
          current_statement__ = 24;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 25;
      stan::math::validate_non_negative_index("x2", "I", I);
      current_statement__ = 26;
      context__.validate_dims("data initialization","x2","double",
           std::vector<size_t>{static_cast<size_t>(I)});
      x2__ = 
        Eigen::Matrix<double, -1, 1>::Constant(I,
          std::numeric_limits<double>::quiet_NaN());
      new (&x2) Eigen::Map<Eigen::Matrix<double, -1, 1>>(x2__.data(), I);
      
      {
        std::vector<local_scalar_t__> x2_flat__;
        current_statement__ = 26;
        x2_flat__ = context__.vals_r("x2");
        current_statement__ = 26;
        pos__ = 1;
        current_statement__ = 26;
        for (int sym1__ = 1; sym1__ <= I; ++sym1__) {
          current_statement__ = 26;
          stan::model::assign(x2, x2_flat__[(pos__ - 1)],
            "assigning variable x2", stan::model::index_uni(sym1__));
          current_statement__ = 26;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 27;
      K = std::numeric_limits<int>::min();
      
      
      current_statement__ = 28;
      stan::math::validate_non_negative_index("x1x2", "I", I);
      current_statement__ = 29;
      x1x2__ = 
        Eigen::Matrix<double, -1, 1>::Constant(I,
          std::numeric_limits<double>::quiet_NaN());
      new (&x1x2) Eigen::Map<Eigen::Matrix<double, -1, 1>>(x1x2__.data(), I);
      
      current_statement__ = 30;
      K = 8;
      current_statement__ = 31;
      stan::model::assign(x1x2, stan::math::elt_multiply(x1, x2),
        "assigning variable x1x2");
      current_statement__ = 32;
      stan::math::validate_non_negative_index("b", "I", I);
      current_statement__ = 33;
      stan::math::validate_non_negative_index("b", "K", K);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + 1 + (I * K);
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "stalled1_failure_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ alpha0 = DUMMY_VAR__;
      current_statement__ = 1;
      alpha0 = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha1 = DUMMY_VAR__;
      current_statement__ = 2;
      alpha1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha2 = DUMMY_VAR__;
      current_statement__ = 3;
      alpha2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ alpha12 = DUMMY_VAR__;
      current_statement__ = 4;
      alpha12 = in__.template read<local_scalar_t__>();
      local_scalar_t__ tau = DUMMY_VAR__;
      current_statement__ = 5;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> b =
         std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(I, 
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(K, DUMMY_VAR__));
      current_statement__ = 6;
      b = in__.template read<
            std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(I, K);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 8;
      sigma = (1 / stan::math::sqrt(tau));
      {
        current_statement__ = 9;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha0, 0.0, 1.0E3));
        current_statement__ = 10;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha1, 0.0, 1.0E3));
        current_statement__ = 11;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha2, 0.0, 1.0E3));
        current_statement__ = 12;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha12, 0.0, 1.0E3));
        current_statement__ = 13;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(tau, 1.0E-3, 1.0E-3));
        current_statement__ = 17;
        for (int i = 1; i <= I; ++i) {
          current_statement__ = 14;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(
              stan::model::rvalue(b, "b", stan::model::index_uni(i)), 0.0,
              sigma));
          current_statement__ = 15;
          lp_accum__.add(
            stan::math::binomial_logit_lpmf<propto__>(
              stan::model::rvalue(n, "n", stan::model::index_uni(i)),
              stan::model::rvalue(N, "N", stan::model::index_uni(i)),
              stan::math::add(
                (((alpha0 +
                    (alpha1 *
                      stan::model::rvalue(x1, "x1",
                        stan::model::index_uni(i)))) +
                   (alpha2 *
                     stan::model::rvalue(x2, "x2", stan::model::index_uni(i))))
                  +
                  (alpha12 *
                    stan::model::rvalue(x1x2, "x1x2",
                      stan::model::index_uni(i)))),
                stan::model::rvalue(b, "b", stan::model::index_uni(i)))));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "stalled1_failure_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double alpha0 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      alpha0 = in__.template read<local_scalar_t__>();
      double alpha1 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      alpha1 = in__.template read<local_scalar_t__>();
      double alpha2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      alpha2 = in__.template read<local_scalar_t__>();
      double alpha12 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      alpha12 = in__.template read<local_scalar_t__>();
      double tau = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
              lp__);
      std::vector<Eigen::Matrix<double, -1, 1>> b =
         std::vector<Eigen::Matrix<double, -1, 1>>(I, 
           Eigen::Matrix<double, -1, 1>::Constant(K,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 6;
      b = in__.template read<
            std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(I, K);
      double sigma = std::numeric_limits<double>::quiet_NaN();
      out__.write(alpha0);
      out__.write(alpha1);
      out__.write(alpha2);
      out__.write(alpha12);
      out__.write(tau);
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
          out__.write(b[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 8;
      sigma = (1 / stan::math::sqrt(tau));
      if (emit_transformed_parameters__) {
        out__.write(sigma);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ alpha0 = DUMMY_VAR__;
      alpha0 = in__.read<local_scalar_t__>();
      out__.write(alpha0);
      local_scalar_t__ alpha1 = DUMMY_VAR__;
      alpha1 = in__.read<local_scalar_t__>();
      out__.write(alpha1);
      local_scalar_t__ alpha2 = DUMMY_VAR__;
      alpha2 = in__.read<local_scalar_t__>();
      out__.write(alpha2);
      local_scalar_t__ alpha12 = DUMMY_VAR__;
      alpha12 = in__.read<local_scalar_t__>();
      out__.write(alpha12);
      local_scalar_t__ tau = DUMMY_VAR__;
      tau = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, tau);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> b =
         std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(I, 
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(K, DUMMY_VAR__));
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
          stan::model::assign(b, in__.read<local_scalar_t__>(),
            "assigning variable b", stan::model::index_uni(sym2__),
                                      stan::model::index_uni(sym1__));
        }
      }
      out__.write(b);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"alpha0", "alpha1", "alpha2",
      "alpha12", "tau", "b", "sigma"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(I), static_cast<size_t>(K)},
      std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha0");
    param_names__.emplace_back(std::string() + "alpha1");
    param_names__.emplace_back(std::string() + "alpha2");
    param_names__.emplace_back(std::string() + "alpha12");
    param_names__.emplace_back(std::string() + "tau");
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha0");
    param_names__.emplace_back(std::string() + "alpha1");
    param_names__.emplace_back(std::string() + "alpha2");
    param_names__.emplace_back(std::string() + "alpha12");
    param_names__.emplace_back(std::string() + "tau");
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha12\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(I) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha12\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(I) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((1 + 1) + 1) + 1) + 1) + (I * K));
      const size_t num_transformed = 1;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((1 + 1) + 1) + 1) + 1) + (I * K));
      const size_t num_transformed = 1;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 6> names__{"alpha0", "alpha1",
      "alpha2", "alpha12", "tau", "b"};
      const std::array<Eigen::Index, 6> constrain_param_sizes__{1, 1, 
       1, 1, 1, (I * K)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = stalled1_failure_model_namespace::stalled1_failure_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return stalled1_failure_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 unenforce-initialize.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace unenforce_initialize_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 14> locations_array__ = 
{" (found before start of program)",
 " (in 'unenforce-initialize.stan', line 2, column 2 to column 9)",
 " (in 'unenforce-initialize.stan', line 5, column 2 to column 15)",
 " (in 'unenforce-initialize.stan', line 6, column 2 to column 33)",
 " (in 'unenforce-initialize.stan', line 7, column 2 to column 39)",
 " (in 'unenforce-initialize.stan', line 8, column 2 to column 33)",
 " (in 'unenforce-initialize.stan', line 9, column 2 to column 18)",
 " (in 'unenforce-initialize.stan', line 13, column 2 to column 20)",
 " (in 'unenforce-initialize.stan', line 11, column 4 to column 21)",
 " (in 'unenforce-initialize.stan', line 10, column 14 to line 12, column 3)",
 " (in 'unenforce-initialize.stan', line 10, column 2 to line 12, column 3)",
 " (in 'unenforce-initialize.stan', line 15, column 4 to column 21)",
 " (in 'unenforce-initialize.stan', line 14, column 18 to line 16, column 3)",
 " (in 'unenforce-initialize.stan', line 14, column 2 to line 16, column 3)"};




class unenforce_initialize_model final : public model_base_crtp<unenforce_initialize_model> {

 private:
   
  
 
 public:
  ~unenforce_initialize_model() { }
  
  inline std::string model_name() const final { return "unenforce_initialize_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  unenforce_initialize_model(stan::io::var_context& context__,
                             unsigned int random_seed__ = 0,
                             std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "unenforce_initialize_model_namespace::unenforce_initialize_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "unenforce_initialize_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ y = DUMMY_VAR__;
      current_statement__ = 1;
      y = in__.template read<local_scalar_t__>();
      local_scalar_t__ no_init = DUMMY_VAR__;
      local_scalar_t__ init_from_param = DUMMY_VAR__;
      current_statement__ = 3;
      init_from_param = (y * 5.0);
      local_scalar_t__ dependent_no_init = DUMMY_VAR__;
      current_statement__ = 4;
      dependent_no_init = (no_init * y);
      local_scalar_t__ used_on_lhs = DUMMY_VAR__;
      current_statement__ = 5;
      used_on_lhs = used_on_lhs;
      local_scalar_t__ no_init_if = DUMMY_VAR__;
      current_statement__ = 10;
      if (stan::math::logical_eq(1, 1)) {
        current_statement__ = 8;
        no_init_if = 1.0;
      } 
      local_scalar_t__ for_loop_var = DUMMY_VAR__;
      current_statement__ = 13;
      for (int i = 1; i <= 10; ++i) {
        current_statement__ = 11;
        for_loop_var = 1;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "unenforce_initialize_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double y = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      y = in__.template read<local_scalar_t__>();
      double no_init = std::numeric_limits<double>::quiet_NaN();
      double init_from_param = std::numeric_limits<double>::quiet_NaN();
      double dependent_no_init = std::numeric_limits<double>::quiet_NaN();
      double used_on_lhs = std::numeric_limits<double>::quiet_NaN();
      double no_init_if = std::numeric_limits<double>::quiet_NaN();
      double for_loop_var = std::numeric_limits<double>::quiet_NaN();
      out__.write(y);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 3;
      init_from_param = (y * 5.0);
      current_statement__ = 4;
      dependent_no_init = (no_init * y);
      current_statement__ = 5;
      used_on_lhs = used_on_lhs;
      current_statement__ = 10;
      if (stan::math::logical_eq(1, 1)) {
        current_statement__ = 8;
        no_init_if = 1.0;
      } 
      current_statement__ = 13;
      for (int i = 1; i <= 10; ++i) {
        current_statement__ = 11;
        for_loop_var = 1;
      }
      if (emit_transformed_parameters__) {
        out__.write(no_init);
        out__.write(init_from_param);
        out__.write(dependent_no_init);
        out__.write(used_on_lhs);
        out__.write(no_init_if);
        out__.write(for_loop_var);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ y = DUMMY_VAR__;
      y = in__.read<local_scalar_t__>();
      out__.write(y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"y", "no_init", "init_from_param",
      "dependent_no_init", "used_on_lhs", "no_init_if", "for_loop_var"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{},
      std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "y");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "no_init");
      param_names__.emplace_back(std::string() + "init_from_param");
      param_names__.emplace_back(std::string() + "dependent_no_init");
      param_names__.emplace_back(std::string() + "used_on_lhs");
      param_names__.emplace_back(std::string() + "no_init_if");
      param_names__.emplace_back(std::string() + "for_loop_var");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "y");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "no_init");
      param_names__.emplace_back(std::string() + "init_from_param");
      param_names__.emplace_back(std::string() + "dependent_no_init");
      param_names__.emplace_back(std::string() + "used_on_lhs");
      param_names__.emplace_back(std::string() + "no_init_if");
      param_names__.emplace_back(std::string() + "for_loop_var");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"no_init\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"init_from_param\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"dependent_no_init\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"used_on_lhs\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"no_init_if\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"for_loop_var\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"no_init\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"init_from_param\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"dependent_no_init\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"used_on_lhs\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"no_init_if\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"for_loop_var\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 1;
      const size_t num_transformed = 
  (((((1 + 1) + 1) + 1) + 1) + 1);
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 1;
      const size_t num_transformed = 
  (((((1 + 1) + 1) + 1) + 1) + 1);
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 1> names__{"y"};
      const std::array<Eigen::Index, 1> constrain_param_sizes__{1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}

using stan_model = unenforce_initialize_model_namespace::unenforce_initialize_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return unenforce_initialize_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --print-cpp --O0 unroll-limit.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace unroll_limit_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 17> locations_array__ = 
{" (found before start of program)",
 " (in 'unroll-limit.stan', line 2, column 2 to column 8)",
 " (in 'unroll-limit.stan', line 4, column 4 to column 15)",
 " (in 'unroll-limit.stan', line 3, column 19 to line 5, column 3)",
 " (in 'unroll-limit.stan', line 3, column 2 to line 5, column 3)",
 " (in 'unroll-limit.stan', line 7, column 4 to column 15)",
 " (in 'unroll-limit.stan', line 6, column 18 to line 8, column 3)",
 " (in 'unroll-limit.stan', line 6, column 2 to line 8, column 3)",
 " (in 'unroll-limit.stan', line 10, column 4 to column 15)",
 " (in 'unroll-limit.stan', line 9, column 19 to line 11, column 3)",
 " (in 'unroll-limit.stan', line 9, column 2 to line 11, column 3)",
 " (in 'unroll-limit.stan', line 13, column 4 to column 15)",
 " (in 'unroll-limit.stan', line 12, column 20 to line 14, column 3)",
 " (in 'unroll-limit.stan', line 12, column 2 to line 14, column 3)",
 " (in 'unroll-limit.stan', line 16, column 4 to column 15)",
 " (in 'unroll-limit.stan', line 15, column 20 to line 17, column 3)",
 " (in 'unroll-limit.stan', line 15, column 2 to line 17, column 3)"};




class unroll_limit_model final : public model_base_crtp<unroll_limit_model> {

 private:
   
  
 
 public:
  ~unroll_limit_model() { }
  
  inline std::string model_name() const final { return "unroll_limit_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --print-cpp --O0"};
  }
  
  
  unroll_limit_model(stan::io::var_context& context__,
                     unsigned int random_seed__ = 0,
                     std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "unroll_limit_model_namespace::unroll_limit_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 0U;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "unroll_limit_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "unroll_limit_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      int x = std::numeric_limits<int>::min();
      current_statement__ = 4;
      for (int i = 1; i <= 100; ++i) {
        current_statement__ = 2;
        x = (x + (1 + i));
      }
      current_statement__ = 7;
      for (int i = 1; i <= 20; ++i) {
        current_statement__ = 5;
        x = (x + (2 + i));
      }
      current_statement__ = 10;
      for (int i = 50; i <= 70; ++i) {
        current_statement__ = 8;
        x = (x + (3 + i));
      }
      current_statement__ = 13;
      for (int i = -10; i <= 10; ++i) {
        current_statement__ = 11;
        x = (x + (4 + i));
      }
      current_statement__ = 16;
      for (int i = -10; i <= 40; ++i) {
        current_statement__ = 14;
        x = (x + (5 + i));
      }
      out__.write(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"x"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "x");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "x");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"x\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 1;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 0;
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 1;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 0> names__{};
      const std::array<Eigen::Index, 0> constrain_param_sizes__{};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = unroll_limit_model_namespace::unroll_limit_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return unroll_limit_model_namespace::profiles__;
}

#endif



