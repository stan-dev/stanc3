  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp ad_scalar_data_matrix.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace ad_scalar_data_matrix_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 42> locations_array__ =
  {" (found before start of program)",
  " (in 'ad_scalar_data_matrix.stan', line 7, column 2 to column 13)",
  " (in 'ad_scalar_data_matrix.stan', line 8, column 2 to column 13)",
  " (in 'ad_scalar_data_matrix.stan', line 9, column 2 to column 17)",
  " (in 'ad_scalar_data_matrix.stan', line 12, column 9 to column 10)",
  " (in 'ad_scalar_data_matrix.stan', line 12, column 2 to column 58)",
  " (in 'ad_scalar_data_matrix.stan', line 13, column 9 to column 10)",
  " (in 'ad_scalar_data_matrix.stan', line 13, column 2 to column 51)",
  " (in 'ad_scalar_data_matrix.stan', line 14, column 9 to column 10)",
  " (in 'ad_scalar_data_matrix.stan', line 14, column 2 to column 84)",
  " (in 'ad_scalar_data_matrix.stan', line 15, column 9 to column 10)",
  " (in 'ad_scalar_data_matrix.stan', line 15, column 2 to column 65)",
  " (in 'ad_scalar_data_matrix.stan', line 16, column 9 to column 10)",
  " (in 'ad_scalar_data_matrix.stan', line 16, column 2 to column 55)",
  " (in 'ad_scalar_data_matrix.stan', line 17, column 9 to column 10)",
  " (in 'ad_scalar_data_matrix.stan', line 17, column 2 to column 83)",
  " (in 'ad_scalar_data_matrix.stan', line 18, column 9 to column 10)",
  " (in 'ad_scalar_data_matrix.stan', line 18, column 12 to column 13)",
  " (in 'ad_scalar_data_matrix.stan', line 18, column 2 to column 108)",
  " (in 'ad_scalar_data_matrix.stan', line 19, column 9 to column 10)",
  " (in 'ad_scalar_data_matrix.stan', line 19, column 12 to column 13)",
  " (in 'ad_scalar_data_matrix.stan', line 19, column 2 to column 104)",
  " (in 'ad_scalar_data_matrix.stan', line 20, column 9 to column 10)",
  " (in 'ad_scalar_data_matrix.stan', line 20, column 12 to column 13)",
  " (in 'ad_scalar_data_matrix.stan', line 20, column 2 to column 90)",
  " (in 'ad_scalar_data_matrix.stan', line 21, column 2 to column 76)",
  " (in 'ad_scalar_data_matrix.stan', line 22, column 2 to column 40)",
  " (in 'ad_scalar_data_matrix.stan', line 23, column 2 to column 30)",
  " (in 'ad_scalar_data_matrix.stan', line 24, column 2 to column 31)",
  " (in 'ad_scalar_data_matrix.stan', line 25, column 2 to column 30)",
  " (in 'ad_scalar_data_matrix.stan', line 26, column 2 to column 25)",
  " (in 'ad_scalar_data_matrix.stan', line 27, column 2 to column 29)",
  " (in 'ad_scalar_data_matrix.stan', line 28, column 2 to column 33)",
  " (in 'ad_scalar_data_matrix.stan', line 29, column 2 to column 29)",
  " (in 'ad_scalar_data_matrix.stan', line 30, column 2 to column 35)",
  " (in 'ad_scalar_data_matrix.stan', line 2, column 2 to column 8)",
  " (in 'ad_scalar_data_matrix.stan', line 3, column 9 to column 10)",
  " (in 'ad_scalar_data_matrix.stan', line 3, column 12 to column 13)",
  " (in 'ad_scalar_data_matrix.stan', line 3, column 2 to column 22)",
  " (in 'ad_scalar_data_matrix.stan', line 4, column 9 to column 10)",
  " (in 'ad_scalar_data_matrix.stan', line 4, column 2 to column 19)",
  " (in 'ad_scalar_data_matrix.stan', line 9, column 9 to column 10)"};
class ad_scalar_data_matrix_model final : public model_base_crtp<ad_scalar_data_matrix_model> {
 private:
  int N;
  Eigen::Matrix<double,-1,-1> X_data_data__;
  Eigen::Matrix<double,-1,1> y_data_data__;
  Eigen::Map<Eigen::Matrix<double,-1,-1>> X_data{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> y_data{nullptr, 0};
 public:
  ~ad_scalar_data_matrix_model() {}
  ad_scalar_data_matrix_model(stan::io::var_context& context__, unsigned int
                              random_seed__ = 0, std::ostream*
                              pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "ad_scalar_data_matrix_model_namespace::ad_scalar_data_matrix_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 35;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 35;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 36;
      stan::math::validate_non_negative_index("X_data", "N", N);
      current_statement__ = 37;
      stan::math::validate_non_negative_index("X_data", "N", N);
      current_statement__ = 38;
      context__.validate_dims("data initialization", "X_data", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      X_data_data__ = Eigen::Matrix<double,-1,-1>::Constant(N, N,
                        std::numeric_limits<double>::quiet_NaN());
      new (&X_data)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_data_data__.data(), N, N);
      {
        std::vector<local_scalar_t__> X_data_flat__;
        current_statement__ = 38;
        X_data_flat__ = context__.vals_r("X_data");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(X_data, X_data_flat__[(pos__ - 1)],
              "assigning variable X_data", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 39;
      stan::math::validate_non_negative_index("y_data", "N", N);
      current_statement__ = 40;
      context__.validate_dims("data initialization", "y_data", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      y_data_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                        std::numeric_limits<double>::quiet_NaN());
      new (&y_data)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(y_data_data__.data(), N);
      {
        std::vector<local_scalar_t__> y_data_flat__;
        current_statement__ = 40;
        y_data_flat__ = context__.vals_r("y_data");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(y_data, y_data_flat__[(pos__ - 1)],
            "assigning variable y_data", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 41;
      stan::math::validate_non_negative_index("beta", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + N;
  }
  inline std::string model_name() const final {
    return "ad_scalar_data_matrix_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = -fsoa --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "ad_scalar_data_matrix_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 2;
      sigma = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 3;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      {
        current_statement__ = 4;
        stan::math::validate_non_negative_index("soa_simple", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> soa_simple =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 5;
        stan::model::assign(soa_simple,
          stan::math::add(
            stan::math::add(alpha, stan::math::rep_vector(0.0, N)), beta),
          "assigning variable soa_simple");
        current_statement__ = 6;
        stan::math::validate_non_negative_index("aos_deep", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> aos_deep =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 7;
        stan::model::assign(aos_deep,
          stan::math::subtract(
            stan::math::multiply(2,
              stan::math::Phi(stan::math::divide(y_data, sigma))), 1),
          "assigning variable aos_deep");
        current_statement__ = 8;
        stan::math::validate_non_negative_index("soa_dual_rep", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> soa_dual_rep =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 9;
        stan::model::assign(soa_dual_rep,
          stan::math::add(
            stan::math::transpose(stan::math::rep_row_vector(0.0, N)),
            stan::math::rep_vector(sigma, N)),
          "assigning variable soa_dual_rep");
        current_statement__ = 10;
        stan::math::validate_non_negative_index("soa_data_rep", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> soa_data_rep =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 11;
        stan::model::assign(soa_data_rep,
          stan::math::add(stan::math::rep_vector(0.0, N),
            stan::math::rep_vector(N, N)), "assigning variable soa_data_rep");
        current_statement__ = 12;
        stan::math::validate_non_negative_index("soa_mix", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> soa_mix =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 13;
        stan::model::assign(soa_mix,
          stan::math::add(stan::math::Phi(stan::math::divide(y_data, sigma)),
            soa_simple), "assigning variable soa_mix");
        current_statement__ = 14;
        stan::math::validate_non_negative_index("aos_from_data", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> aos_from_data =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 15;
        stan::model::assign(aos_from_data,
          stan::math::subtract(
            stan::math::subtract(
              stan::math::add((alpha + (sigma * alpha)), y_data), alpha),
            (sigma * alpha)), "assigning variable aos_from_data");
        current_statement__ = 16;
        stan::math::validate_non_negative_index("soa_mat_rep", "N", N);
        current_statement__ = 17;
        stan::math::validate_non_negative_index("soa_mat_rep", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,-1> soa_mat_rep =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
        current_statement__ = 18;
        stan::model::assign(soa_mat_rep,
          stan::math::add(
            stan::math::transpose(stan::math::rep_matrix(2.0, N, N)),
            stan::math::rep_matrix(
              stan::math::sum(stan::math::rep_vector(sigma, N)), N, N)),
          "assigning variable soa_mat_rep");
        current_statement__ = 19;
        stan::math::validate_non_negative_index("soa_mat_rep_vec", "N", N);
        current_statement__ = 20;
        stan::math::validate_non_negative_index("soa_mat_rep_vec", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,-1> soa_mat_rep_vec =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
        current_statement__ = 21;
        stan::model::assign(soa_mat_rep_vec,
          stan::math::add(
            stan::math::transpose(stan::math::rep_matrix(2.0, N, N)),
            stan::math::rep_matrix(stan::math::rep_vector(sigma, N), N)),
          "assigning variable soa_mat_rep_vec");
        current_statement__ = 22;
        stan::math::validate_non_negative_index("aos_mat_rep", "N", N);
        current_statement__ = 23;
        stan::math::validate_non_negative_index("aos_mat_rep", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,-1> aos_mat_rep =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
        current_statement__ = 24;
        stan::model::assign(aos_mat_rep,
          stan::math::add(
            stan::math::transpose(stan::math::rep_matrix(aos_deep, N)),
            stan::math::rep_matrix(aos_deep, N)),
          "assigning variable aos_mat_rep");
        Eigen::Matrix<local_scalar_t__,-1,-1> aos_mat_from_vecs =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__);
        current_statement__ = 25;
        stan::model::assign(aos_mat_from_vecs,
          stan::math::to_matrix(
            std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                                 stan::math::pow(
                                                                   alpha, 2),
                                                                sigma).finished(),
              (Eigen::Matrix<local_scalar_t__,1,-1>(2) << alpha,
                                                         stan::math::pow(
                                                           sigma, 2)).finished()}),
          "assigning variable aos_mat_from_vecs");
        current_statement__ = 26;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y_data, soa_simple,
                         aos_deep));
        current_statement__ = 27;
        lp_accum__.add(stan::math::sum(soa_dual_rep));
        current_statement__ = 28;
        lp_accum__.add(stan::math::sum(aos_from_data));
        current_statement__ = 29;
        lp_accum__.add(stan::math::sum(soa_data_rep));
        current_statement__ = 30;
        lp_accum__.add(stan::math::sum(soa_mix));
        current_statement__ = 31;
        lp_accum__.add(stan::math::sum(soa_mat_rep));
        current_statement__ = 32;
        lp_accum__.add(stan::math::sum(soa_mat_rep_vec));
        current_statement__ = 33;
        lp_accum__.add(stan::math::sum(aos_mat_rep));
        current_statement__ = 34;
        lp_accum__.add(stan::math::sum(aos_mat_from_vecs));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "ad_scalar_data_matrix_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 2;
      sigma = in__.template read<local_scalar_t__>();
      stan::math::var_value<Eigen::Matrix<double,-1,1>> beta =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 3;
      beta = in__.template read<
               stan::math::var_value<Eigen::Matrix<double,-1,1>>>(N);
      {
        current_statement__ = 4;
        stan::math::validate_non_negative_index("soa_simple", "N", N);
        stan::math::var_value<Eigen::Matrix<double,-1,1>> soa_simple =
          stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                )));
        current_statement__ = 5;
        stan::model::assign(soa_simple,
          stan::math::add(
            stan::math::add(alpha, stan::math::rep_vector(0.0, N)), beta),
          "assigning variable soa_simple");
        current_statement__ = 6;
        stan::math::validate_non_negative_index("aos_deep", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> aos_deep =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 7;
        stan::model::assign(aos_deep,
          stan::math::subtract(
            stan::math::multiply(2,
              stan::math::Phi(stan::math::divide(y_data, sigma))), 1),
          "assigning variable aos_deep");
        current_statement__ = 8;
        stan::math::validate_non_negative_index("soa_dual_rep", "N", N);
        stan::math::var_value<Eigen::Matrix<double,-1,1>> soa_dual_rep =
          stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                )));
        current_statement__ = 9;
        stan::model::assign(soa_dual_rep,
          stan::math::add(
            stan::math::transpose(stan::math::rep_row_vector(0.0, N)),
            stan::math::rep_vector<
              stan::math::var_value<Eigen::Matrix<double,-1,1>>>(sigma, N)),
          "assigning variable soa_dual_rep");
        current_statement__ = 10;
        stan::math::validate_non_negative_index("soa_data_rep", "N", N);
        stan::math::var_value<Eigen::Matrix<double,-1,1>> soa_data_rep =
          stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                )));
        current_statement__ = 11;
        stan::model::assign(soa_data_rep,
          stan::math::add(stan::math::rep_vector(0.0, N),
            stan::math::rep_vector(N, N)), "assigning variable soa_data_rep");
        current_statement__ = 12;
        stan::math::validate_non_negative_index("soa_mix", "N", N);
        stan::math::var_value<Eigen::Matrix<double,-1,1>> soa_mix =
          stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                )));
        current_statement__ = 13;
        stan::model::assign(soa_mix,
          stan::math::add(stan::math::Phi(stan::math::divide(y_data, sigma)),
            soa_simple), "assigning variable soa_mix");
        current_statement__ = 14;
        stan::math::validate_non_negative_index("aos_from_data", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> aos_from_data =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 15;
        stan::model::assign(aos_from_data,
          stan::math::subtract(
            stan::math::subtract(
              stan::math::add((alpha + (sigma * alpha)), y_data), alpha),
            (sigma * alpha)), "assigning variable aos_from_data");
        current_statement__ = 16;
        stan::math::validate_non_negative_index("soa_mat_rep", "N", N);
        current_statement__ = 17;
        stan::math::validate_non_negative_index("soa_mat_rep", "N", N);
        stan::math::var_value<Eigen::Matrix<double,-1,-1>> soa_mat_rep =
          stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(N,
                                                               N,
                                                               std::numeric_limits<double>::quiet_NaN(
                                                                 )));
        current_statement__ = 18;
        stan::model::assign(soa_mat_rep,
          stan::math::add(
            stan::math::transpose(stan::math::rep_matrix(2.0, N, N)),
            stan::math::rep_matrix<
              stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(
              stan::math::sum(
                stan::math::rep_vector<
                  stan::math::var_value<Eigen::Matrix<double,-1,1>>>(sigma, N)),
              N, N)), "assigning variable soa_mat_rep");
        current_statement__ = 19;
        stan::math::validate_non_negative_index("soa_mat_rep_vec", "N", N);
        current_statement__ = 20;
        stan::math::validate_non_negative_index("soa_mat_rep_vec", "N", N);
        stan::math::var_value<Eigen::Matrix<double,-1,-1>> soa_mat_rep_vec =
          stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(N,
                                                               N,
                                                               std::numeric_limits<double>::quiet_NaN(
                                                                 )));
        current_statement__ = 21;
        stan::model::assign(soa_mat_rep_vec,
          stan::math::add(
            stan::math::transpose(stan::math::rep_matrix(2.0, N, N)),
            stan::math::rep_matrix<
              stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(
              stan::math::rep_vector<
                stan::math::var_value<Eigen::Matrix<double,-1,1>>>(sigma, N),
              N)), "assigning variable soa_mat_rep_vec");
        current_statement__ = 22;
        stan::math::validate_non_negative_index("aos_mat_rep", "N", N);
        current_statement__ = 23;
        stan::math::validate_non_negative_index("aos_mat_rep", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,-1> aos_mat_rep =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
        current_statement__ = 24;
        stan::model::assign(aos_mat_rep,
          stan::math::add(
            stan::math::transpose(stan::math::rep_matrix(aos_deep, N)),
            stan::math::rep_matrix(aos_deep, N)),
          "assigning variable aos_mat_rep");
        Eigen::Matrix<local_scalar_t__,-1,-1> aos_mat_from_vecs =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__);
        current_statement__ = 25;
        stan::model::assign(aos_mat_from_vecs,
          stan::math::to_matrix(
            std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                                 stan::math::pow(
                                                                   alpha, 2),
                                                                sigma).finished(),
              (Eigen::Matrix<local_scalar_t__,1,-1>(2) << alpha,
                                                         stan::math::pow(
                                                           sigma, 2)).finished()}),
          "assigning variable aos_mat_from_vecs");
        current_statement__ = 26;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y_data, soa_simple,
                         aos_deep));
        current_statement__ = 27;
        lp_accum__.add(stan::math::sum(soa_dual_rep));
        current_statement__ = 28;
        lp_accum__.add(stan::math::sum(aos_from_data));
        current_statement__ = 29;
        lp_accum__.add(stan::math::sum(soa_data_rep));
        current_statement__ = 30;
        lp_accum__.add(stan::math::sum(soa_mix));
        current_statement__ = 31;
        lp_accum__.add(stan::math::sum(soa_mat_rep));
        current_statement__ = 32;
        lp_accum__.add(stan::math::sum(soa_mat_rep_vec));
        current_statement__ = 33;
        lp_accum__.add(stan::math::sum(aos_mat_rep));
        current_statement__ = 34;
        lp_accum__.add(stan::math::sum(aos_mat_from_vecs));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "ad_scalar_data_matrix_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double alpha = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      double sigma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      sigma = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,1> beta =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      beta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      out__.write(alpha);
      out__.write(sigma);
      out__.write(beta);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.read<local_scalar_t__>();
      out__.write(alpha);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 2;
      sigma = in__.read<local_scalar_t__>();
      out__.write(sigma);
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(beta,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable beta");
      out__.write(beta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "alpha", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "sigma", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "beta", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = context__.vals_r("alpha")[(1 - 1)];
      out__.write(alpha);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 2;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      out__.write(sigma);
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> beta_flat__;
        current_statement__ = 3;
        beta_flat__ = context__.vals_r("beta");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(beta, beta_flat__[(pos__ - 1)],
            "assigning variable beta", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(beta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"alpha", "sigma", "beta"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(N)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha");
    param_names__.emplace_back(std::string() + "sigma");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha");
    param_names__.emplace_back(std::string() + "sigma");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "beta" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((1 + 1) + N);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((1 + 1) + N);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = ad_scalar_data_matrix_model_namespace::ad_scalar_data_matrix_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return ad_scalar_data_matrix_model_namespace::profiles__;
}
#endif
  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp complex-fails.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace complex_fails_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 3> locations_array__ =
  {" (found before start of program)",
  " (in 'complex-fails.stan', line 2, column 4 to column 23)",
  " (in 'complex-fails.stan', line 6, column 3 to column 45)"};
class complex_fails_model final : public model_base_crtp<complex_fails_model> {
 private:
  
 public:
  ~complex_fails_model() {}
  complex_fails_model(stan::io::var_context& context__, unsigned int
                      random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "complex_fails_model_namespace::complex_fails_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = (10 * 10);
  }
  inline std::string model_name() const final {
    return "complex_fails_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = -fsoa --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "complex_fails_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> A_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 1;
      A_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<std::complex<local_scalar_t__>,-1,-1> A_complex_tp =
        Eigen::Matrix<std::complex<local_scalar_t__>,-1,-1>::Constant(10, 10,
          std::complex<local_scalar_t__>(DUMMY_VAR__, DUMMY_VAR__));
      current_statement__ = 2;
      stan::model::assign(A_complex_tp, A_p,
        "assigning variable A_complex_tp");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "complex_fails_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> A_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 1;
      A_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<std::complex<local_scalar_t__>,-1,-1> A_complex_tp =
        Eigen::Matrix<std::complex<local_scalar_t__>,-1,-1>::Constant(10, 10,
          std::complex<local_scalar_t__>(DUMMY_VAR__, DUMMY_VAR__));
      current_statement__ = 2;
      stan::model::assign(A_complex_tp, A_p,
        "assigning variable A_complex_tp");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "complex_fails_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> A_p =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      A_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<std::complex<double>,-1,-1> A_complex_tp =
        Eigen::Matrix<std::complex<double>,-1,-1>::Constant(10, 10,
          std::complex<double>(std::numeric_limits<double>::quiet_NaN(),
            std::numeric_limits<double>::quiet_NaN()));
      out__.write(A_p);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 2;
      stan::model::assign(A_complex_tp, A_p,
        "assigning variable A_complex_tp");
      if (emit_transformed_parameters__) {
        out__.write(A_complex_tp);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> A_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(A_p,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10),
        "assigning variable A_p");
      out__.write(A_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "A_p", "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,-1> A_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> A_p_flat__;
        current_statement__ = 1;
        A_p_flat__ = context__.vals_r("A_p");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            stan::model::assign(A_p, A_p_flat__[(pos__ - 1)],
              "assigning variable A_p", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(A_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"A_p"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"A_complex_tp"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    10),
                                                 static_cast<size_t>(10)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10), static_cast<size_t>(2)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "A_p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "A_complex_tp" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__) + '.' +
            "real");
          param_names__.emplace_back(std::string() + "A_complex_tp" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__) + '.' +
            "imag");
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "A_p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "A_complex_tp" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__) + '.' +
            "real");
          param_names__.emplace_back(std::string() + "A_complex_tp" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__) + '.' +
            "imag");
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"A_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"A_complex_tp\",\"type\":{\"name\":\"complex_matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"A_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"A_complex_tp\",\"type\":{\"name\":\"complex_matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (10 * 10);
    const size_t num_transformed = emit_transformed_parameters * ((10 * (10 *
      2)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (10 * 10);
    const size_t num_transformed = emit_transformed_parameters * ((10 * (10 *
      2)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = complex_fails_model_namespace::complex_fails_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return complex_fails_model_namespace::profiles__;
}
#endif
  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp constraints.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace constraints_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 92> locations_array__ =
  {" (found before start of program)",
  " (in 'constraints.stan', line 20, column 2 to column 66)",
  " (in 'constraints.stan', line 21, column 2 to column 14)",
  " (in 'constraints.stan', line 22, column 2 to column 15)",
  " (in 'constraints.stan', line 23, column 2 to column 15)",
  " (in 'constraints.stan', line 24, column 2 to column 10)",
  " (in 'constraints.stan', line 25, column 2 to column 33)",
  " (in 'constraints.stan', line 26, column 2 to column 23)",
  " (in 'constraints.stan', line 27, column 2 to column 17)",
  " (in 'constraints.stan', line 28, column 2 to column 23)",
  " (in 'constraints.stan', line 29, column 2 to column 35)",
  " (in 'constraints.stan', line 30, column 2 to column 13)",
  " (in 'constraints.stan', line 31, column 2 to column 33)",
  " (in 'constraints.stan', line 32, column 2 to column 66)",
  " (in 'constraints.stan', line 33, column 2 to column 80)",
  " (in 'constraints.stan', line 34, column 2 to column 72)",
  " (in 'constraints.stan', line 35, column 2 to column 26)",
  " (in 'constraints.stan', line 36, column 2 to column 31)",
  " (in 'constraints.stan', line 37, column 2 to column 39)",
  " (in 'constraints.stan', line 38, column 2 to column 34)",
  " (in 'constraints.stan', line 39, column 2 to column 32)",
  " (in 'constraints.stan', line 40, column 2 to column 43)",
  " (in 'constraints.stan', line 41, column 2 to column 45)",
  " (in 'constraints.stan', line 47, column 2 to column 56)",
  " (in 'constraints.stan', line 48, column 2 to column 37)",
  " (in 'constraints.stan', line 50, column 2 to column 46)",
  " (in 'constraints.stan', line 51, column 2 to column 59)",
  " (in 'constraints.stan', line 52, column 2 to column 40)",
  " (in 'constraints.stan', line 54, column 2 to column 17)",
  " (in 'constraints.stan', line 61, column 2 to column 22)",
  " (in 'constraints.stan', line 62, column 2 to column 32)",
  " (in 'constraints.stan', line 67, column 2 to column 70)",
  " (in 'constraints.stan', line 56, column 2 to column 25)",
  " (in 'constraints.stan', line 57, column 2 to column 67)",
  " (in 'constraints.stan', line 58, column 2 to column 46)",
  " (in 'constraints.stan', line 59, column 2 to column 25)",
  " (in 'constraints.stan', line 63, column 2 to column 20)",
  " (in 'constraints.stan', line 64, column 2 to column 44)",
  " (in 'constraints.stan', line 65, column 2 to column 46)",
  " (in 'constraints.stan', line 66, column 2 to column 71)",
  " (in 'constraints.stan', line 72, column 2 to column 34)",
  " (in 'constraints.stan', line 73, column 2 to column 50)",
  " (in 'constraints.stan', line 74, column 2 to column 44)",
  " (in 'constraints.stan', line 75, column 2 to column 54)",
  " (in 'constraints.stan', line 76, column 2 to column 21)",
  " (in 'constraints.stan', line 77, column 2 to column 21)",
  " (in 'constraints.stan', line 78, column 2 to column 34)",
  " (in 'constraints.stan', line 79, column 2 to column 35)",
  " (in 'constraints.stan', line 80, column 2 to column 54)",
  " (in 'constraints.stan', line 81, column 2 to column 43)",
  " (in 'constraints.stan', line 82, column 2 to column 36)",
  " (in 'constraints.stan', line 3, column 2 to column 17)",
  " (in 'constraints.stan', line 4, column 2 to column 17)",
  " (in 'constraints.stan', line 5, column 9 to column 10)",
  " (in 'constraints.stan', line 5, column 2 to column 25)",
  " (in 'constraints.stan', line 6, column 9 to column 10)",
  " (in 'constraints.stan', line 6, column 2 to column 26)",
  " (in 'constraints.stan', line 7, column 9 to column 10)",
  " (in 'constraints.stan', line 7, column 2 to column 22)",
  " (in 'constraints.stan', line 8, column 9 to column 10)",
  " (in 'constraints.stan', line 8, column 12 to column 13)",
  " (in 'constraints.stan', line 8, column 2 to column 21)",
  " (in 'constraints.stan', line 9, column 2 to column 28)",
  " (in 'constraints.stan', line 10, column 2 to column 28)",
  " (in 'constraints.stan', line 11, column 2 to column 19)",
  " (in 'constraints.stan', line 12, column 2 to column 31)",
  " (in 'constraints.stan', line 13, column 2 to column 34)",
  " (in 'constraints.stan', line 14, column 2 to column 33)",
  " (in 'constraints.stan', line 17, column 2 to column 17)",
  " (in 'constraints.stan', line 20, column 50 to column 51)",
  " (in 'constraints.stan', line 21, column 9 to column 10)",
  " (in 'constraints.stan', line 22, column 9 to column 11)",
  " (in 'constraints.stan', line 28, column 9 to column 10)",
  " (in 'constraints.stan', line 29, column 20 to column 21)",
  " (in 'constraints.stan', line 31, column 19 to column 20)",
  " (in 'constraints.stan', line 32, column 46 to column 47)",
  " (in 'constraints.stan', line 33, column 52 to column 53)",
  " (in 'constraints.stan', line 34, column 52 to column 53)",
  " (in 'constraints.stan', line 35, column 10 to column 11)",
  " (in 'constraints.stan', line 36, column 14 to column 15)",
  " (in 'constraints.stan', line 37, column 19 to column 20)",
  " (in 'constraints.stan', line 38, column 14 to column 15)",
  " (in 'constraints.stan', line 39, column 13 to column 14)",
  " (in 'constraints.stan', line 40, column 22 to column 23)",
  " (in 'constraints.stan', line 41, column 23 to column 24)",
  " (in 'constraints.stan', line 50, column 9 to column 10)",
  " (in 'constraints.stan', line 51, column 9 to column 11)",
  " (in 'constraints.stan', line 52, column 9 to column 11)",
  " (in 'constraints.stan', line 54, column 9 to column 11)",
  " (in 'constraints.stan', line 61, column 9 to column 11)",
  " (in 'constraints.stan', line 62, column 18 to column 20)",
  " (in 'constraints.stan', line 67, column 9 to column 11)"};
class constraints_model final : public model_base_crtp<constraints_model> {
 private:
  int N;
  int K;
  Eigen::Matrix<double,-1,1> diff_low_mid_data__;
  Eigen::Matrix<double,-1,1> diff_high_mid_data__;
  Eigen::Matrix<double,-1,1> mid_price_data__;
  Eigen::Matrix<double,-1,-1> X_all_data__;
  double phi_prior_a;
  double phi_prior_b;
  double mu_prior_mu;
  double mu_prior_sigma;
  double sigma_prior_shape;
  double sigma_prior_rate;
  int Nr;
  Eigen::Map<Eigen::Matrix<double,-1,1>> diff_low_mid{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> diff_high_mid{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> mid_price{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> X_all{nullptr, 0, 0};
 public:
  ~constraints_model() {}
  constraints_model(stan::io::var_context& context__, unsigned int
                    random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "constraints_model_namespace::constraints_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 51;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 51;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 51;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 52;
      context__.validate_dims("data initialization", "K", "int",
        std::vector<size_t>{});
      K = std::numeric_limits<int>::min();
      current_statement__ = 52;
      K = context__.vals_i("K")[(1 - 1)];
      current_statement__ = 52;
      stan::math::check_greater_or_equal(function__, "K", K, 1);
      current_statement__ = 53;
      stan::math::validate_non_negative_index("diff_low_mid", "N", N);
      current_statement__ = 54;
      context__.validate_dims("data initialization", "diff_low_mid",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      diff_low_mid_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                              std::numeric_limits<double>::quiet_NaN());
      new (&diff_low_mid)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(diff_low_mid_data__.data(), N);
      {
        std::vector<local_scalar_t__> diff_low_mid_flat__;
        current_statement__ = 54;
        diff_low_mid_flat__ = context__.vals_r("diff_low_mid");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(diff_low_mid, diff_low_mid_flat__[(pos__ - 1)],
            "assigning variable diff_low_mid", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 55;
      stan::math::validate_non_negative_index("diff_high_mid", "N", N);
      current_statement__ = 56;
      context__.validate_dims("data initialization", "diff_high_mid",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      diff_high_mid_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                               std::numeric_limits<double>::quiet_NaN());
      new (&diff_high_mid)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(diff_high_mid_data__.data(),
        N);
      {
        std::vector<local_scalar_t__> diff_high_mid_flat__;
        current_statement__ = 56;
        diff_high_mid_flat__ = context__.vals_r("diff_high_mid");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(diff_high_mid, diff_high_mid_flat__[(pos__ -
            1)], "assigning variable diff_high_mid",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 57;
      stan::math::validate_non_negative_index("mid_price", "N", N);
      current_statement__ = 58;
      context__.validate_dims("data initialization", "mid_price", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      mid_price_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                           std::numeric_limits<double>::quiet_NaN());
      new (&mid_price)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(mid_price_data__.data(), N);
      {
        std::vector<local_scalar_t__> mid_price_flat__;
        current_statement__ = 58;
        mid_price_flat__ = context__.vals_r("mid_price");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(mid_price, mid_price_flat__[(pos__ - 1)],
            "assigning variable mid_price", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 59;
      stan::math::validate_non_negative_index("X_all", "N", N);
      current_statement__ = 60;
      stan::math::validate_non_negative_index("X_all", "K", K);
      current_statement__ = 61;
      context__.validate_dims("data initialization", "X_all", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(K)});
      X_all_data__ = Eigen::Matrix<double,-1,-1>::Constant(N, K,
                       std::numeric_limits<double>::quiet_NaN());
      new (&X_all)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_all_data__.data(), N, K);
      {
        std::vector<local_scalar_t__> X_all_flat__;
        current_statement__ = 61;
        X_all_flat__ = context__.vals_r("X_all");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(X_all, X_all_flat__[(pos__ - 1)],
              "assigning variable X_all", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 62;
      context__.validate_dims("data initialization", "phi_prior_a", "double",
        std::vector<size_t>{});
      phi_prior_a = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 62;
      phi_prior_a = context__.vals_r("phi_prior_a")[(1 - 1)];
      current_statement__ = 62;
      stan::math::check_greater_or_equal(function__, "phi_prior_a",
        phi_prior_a, 0);
      current_statement__ = 63;
      context__.validate_dims("data initialization", "phi_prior_b", "double",
        std::vector<size_t>{});
      phi_prior_b = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 63;
      phi_prior_b = context__.vals_r("phi_prior_b")[(1 - 1)];
      current_statement__ = 63;
      stan::math::check_greater_or_equal(function__, "phi_prior_b",
        phi_prior_b, 0);
      current_statement__ = 64;
      context__.validate_dims("data initialization", "mu_prior_mu", "double",
        std::vector<size_t>{});
      mu_prior_mu = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 64;
      mu_prior_mu = context__.vals_r("mu_prior_mu")[(1 - 1)];
      current_statement__ = 65;
      context__.validate_dims("data initialization", "mu_prior_sigma",
        "double", std::vector<size_t>{});
      mu_prior_sigma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 65;
      mu_prior_sigma = context__.vals_r("mu_prior_sigma")[(1 - 1)];
      current_statement__ = 65;
      stan::math::check_greater_or_equal(function__, "mu_prior_sigma",
        mu_prior_sigma, 0);
      current_statement__ = 66;
      context__.validate_dims("data initialization", "sigma_prior_shape",
        "double", std::vector<size_t>{});
      sigma_prior_shape = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 66;
      sigma_prior_shape = context__.vals_r("sigma_prior_shape")[(1 - 1)];
      current_statement__ = 66;
      stan::math::check_greater_or_equal(function__, "sigma_prior_shape",
        sigma_prior_shape, 0);
      current_statement__ = 67;
      context__.validate_dims("data initialization", "sigma_prior_rate",
        "double", std::vector<size_t>{});
      sigma_prior_rate = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 67;
      sigma_prior_rate = context__.vals_r("sigma_prior_rate")[(1 - 1)];
      current_statement__ = 67;
      stan::math::check_greater_or_equal(function__, "sigma_prior_rate",
        sigma_prior_rate, 0);
      current_statement__ = 68;
      Nr = std::numeric_limits<int>::min();
      current_statement__ = 68;
      Nr = (N - 1);
      current_statement__ = 69;
      stan::math::validate_non_negative_index("high_low_est", "N", N);
      current_statement__ = 70;
      stan::math::validate_non_negative_index("b", "K", K);
      current_statement__ = 71;
      stan::math::validate_non_negative_index("h", "Nr", Nr);
      current_statement__ = 72;
      stan::math::validate_non_negative_index("mean_price", "N", N);
      current_statement__ = 73;
      stan::math::validate_non_negative_index("sigma_price", "N", N);
      current_statement__ = 74;
      stan::math::validate_non_negative_index("upper_test", "N", N);
      current_statement__ = 75;
      stan::math::validate_non_negative_index("lower_upper_test", "N", N);
      current_statement__ = 76;
      stan::math::validate_non_negative_index("row_vec_lower_upper_test",
        "N", N);
      current_statement__ = 77;
      stan::math::validate_non_negative_index("offset_mult_test", "N", N);
      current_statement__ = 78;
      stan::math::validate_non_negative_index("ordered_test", "N", N);
      current_statement__ = 79;
      stan::math::validate_unit_vector_index("unit_vec_test", "N", N);
      current_statement__ = 80;
      stan::math::validate_non_negative_index("pos_ordered_test", "N", N);
      current_statement__ = 81;
      stan::math::validate_non_negative_index("corr_matrix_test", "N", N);
      current_statement__ = 81;
      stan::math::validate_non_negative_index("corr_matrix_test", "N", N);
      current_statement__ = 82;
      stan::math::validate_non_negative_index("cov_matrix_test", "N", N);
      current_statement__ = 82;
      stan::math::validate_non_negative_index("cov_matrix_test", "N", N);
      current_statement__ = 83;
      stan::math::validate_non_negative_index("chol_fac_cov_test", "K", K);
      current_statement__ = 83;
      stan::math::validate_non_negative_index("chol_fac_cov_test", "K", K);
      current_statement__ = 83;
      stan::math::check_greater_or_equal(
        "cholesky_factor_cov chol_fac_cov_test",
        "num rows (must be greater or equal to num cols)", K, K);
      current_statement__ = 84;
      stan::math::validate_non_negative_index("chol_fac_corr_test", "K", K);
      current_statement__ = 84;
      stan::math::validate_non_negative_index("chol_fac_corr_test", "K", K);
      current_statement__ = 85;
      stan::math::validate_non_negative_index("prices", "N", N);
      current_statement__ = 86;
      stan::math::validate_non_negative_index("prices_diff", "Nr", Nr);
      current_statement__ = 87;
      stan::math::validate_non_negative_index("mu", "Nr", Nr);
      current_statement__ = 88;
      stan::math::validate_non_negative_index("err", "Nr", Nr);
      current_statement__ = 89;
      stan::math::validate_non_negative_index("h_i_mean", "Nr", Nr);
      current_statement__ = 90;
      stan::math::validate_non_negative_index("h_i_sigma", "Nr", Nr);
      current_statement__ = 91;
      stan::math::validate_non_negative_index("h_sigma", "Nr", Nr);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = N + K + Nr + 2 + 1 + 1 + 1 + 1 + N + N + 1 + N + N + N +
      N + N + N + N + ((N * (N - 1)) / 2) + (N + ((N * (N - 1)) / 2)) + ((((K
      * (K - 1)) / 2) + K) + ((K - K) * K)) + ((K * (K - 1)) / 2);
  }
  inline std::string model_name() const final {
    return "constraints_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = -fsoa --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "constraints_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> high_low_est =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 1;
      high_low_est = in__.template read_constrain_lub<
                       Eigen::Matrix<local_scalar_t__,-1,1>,
                       jacobian__>(diff_low_mid, diff_high_mid, lp__, N);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "high_low_est",
        high_low_est, "lower", diff_low_mid);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "high_low_est",
        high_low_est, "upper", diff_high_mid);
      Eigen::Matrix<local_scalar_t__,-1,1> b =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
      current_statement__ = 2;
      b = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
      Eigen::Matrix<local_scalar_t__,-1,1> h =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(Nr, DUMMY_VAR__);
      current_statement__ = 3;
      h = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(Nr);
      Eigen::Matrix<local_scalar_t__,-1,1> ar =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 4;
      ar = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      local_scalar_t__ ma = DUMMY_VAR__;
      current_statement__ = 5;
      ma = in__.template read<local_scalar_t__>();
      local_scalar_t__ phi_beta = DUMMY_VAR__;
      current_statement__ = 6;
      phi_beta = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ sigma2 = DUMMY_VAR__;
      current_statement__ = 7;
      sigma2 = in__.template read_constrain_lb<local_scalar_t__,
                 jacobian__>(0, lp__);
      local_scalar_t__ Intercept = DUMMY_VAR__;
      current_statement__ = 8;
      Intercept = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> mean_price =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 9;
      mean_price = in__.template read<
                     Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<local_scalar_t__,-1,1> sigma_price =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 10;
      sigma_price = in__.template read_constrain_lb<
                      Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0.0,
                      lp__, N);
      local_scalar_t__ theta = DUMMY_VAR__;
      current_statement__ = 11;
      theta = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> upper_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 12;
      upper_test = in__.template read_constrain_ub<
                     Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(ma,
                     lp__, N);
      Eigen::Matrix<local_scalar_t__,-1,1> lower_upper_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 13;
      lower_upper_test = in__.template read_constrain_lub<
                           Eigen::Matrix<local_scalar_t__,-1,1>,
                           jacobian__>(sigma_price, upper_test, lp__, N);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "lower_upper_test",
        lower_upper_test, "lower", sigma_price);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "lower_upper_test",
        lower_upper_test, "upper", upper_test);
      Eigen::Matrix<local_scalar_t__,1,-1> row_vec_lower_upper_test =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 14;
      row_vec_lower_upper_test = in__.template read_constrain_lub<
                                   Eigen::Matrix<local_scalar_t__,1,-1>,
                                   jacobian__>(stan::math::transpose(
                                                 sigma_price),
                                   stan::math::transpose(upper_test), lp__,
                                   N);
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint",
        "row_vec_lower_upper_test", row_vec_lower_upper_test, "lower",
        stan::math::transpose(sigma_price));
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint",
        "row_vec_lower_upper_test", row_vec_lower_upper_test, "upper",
        stan::math::transpose(upper_test));
      Eigen::Matrix<local_scalar_t__,-1,1> offset_mult_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 15;
      offset_mult_test = in__.template read_constrain_offset_multiplier<
                           Eigen::Matrix<local_scalar_t__,-1,1>,
                           jacobian__>(mean_price, sigma_price, lp__, N);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "offset_mult_test",
        offset_mult_test, "offset", mean_price);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "offset_mult_test",
        offset_mult_test, "multiplier", sigma_price);
      Eigen::Matrix<local_scalar_t__,-1,1> ordered_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 16;
      ordered_test = in__.template read_constrain_ordered<
                       Eigen::Matrix<local_scalar_t__,-1,1>,
                       jacobian__>(lp__, N);
      Eigen::Matrix<local_scalar_t__,-1,1> unit_vec_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 17;
      unit_vec_test = in__.template read_constrain_unit_vector<
                        Eigen::Matrix<local_scalar_t__,-1,1>,
                        jacobian__>(lp__, N);
      Eigen::Matrix<local_scalar_t__,-1,1> pos_ordered_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 18;
      pos_ordered_test = in__.template read_constrain_positive_ordered<
                           Eigen::Matrix<local_scalar_t__,-1,1>,
                           jacobian__>(lp__, N);
      Eigen::Matrix<local_scalar_t__,-1,-1> corr_matrix_test =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      current_statement__ = 19;
      corr_matrix_test = in__.template read_constrain_corr_matrix<
                           Eigen::Matrix<local_scalar_t__,-1,-1>,
                           jacobian__>(lp__, N);
      Eigen::Matrix<local_scalar_t__,-1,-1> cov_matrix_test =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      current_statement__ = 20;
      cov_matrix_test = in__.template read_constrain_cov_matrix<
                          Eigen::Matrix<local_scalar_t__,-1,-1>,
                          jacobian__>(lp__, N);
      Eigen::Matrix<local_scalar_t__,-1,-1> chol_fac_cov_test =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(K, K, DUMMY_VAR__);
      current_statement__ = 21;
      chol_fac_cov_test = in__.template read_constrain_cholesky_factor_cov<
                            Eigen::Matrix<local_scalar_t__,-1,-1>,
                            jacobian__>(lp__, K, K);
      Eigen::Matrix<local_scalar_t__,-1,-1> chol_fac_corr_test =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(K, K, DUMMY_VAR__);
      current_statement__ = 22;
      chol_fac_corr_test = in__.template read_constrain_cholesky_factor_corr<
                             Eigen::Matrix<local_scalar_t__,-1,-1>,
                             jacobian__>(lp__, K);
      local_scalar_t__ phi = DUMMY_VAR__;
      current_statement__ = 23;
      phi = stan::math::fma(phi_beta, 2.0, -(1.0));
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 24;
      sigma = stan::math::sqrt(sigma2);
      Eigen::Matrix<local_scalar_t__,-1,1> prices =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 25;
      stan::model::assign(prices, stan::math::add(mid_price, high_low_est),
        "assigning variable prices");
      Eigen::Matrix<local_scalar_t__,-1,1> prices_diff =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(Nr, DUMMY_VAR__);
      current_statement__ = 26;
      stan::model::assign(prices_diff,
        stan::math::subtract(
          stan::model::rvalue(prices, "prices",
            stan::model::index_min_max(2, N)),
          stan::model::rvalue(prices, "prices",
            stan::model::index_min_max(1, (N - 1)))),
        "assigning variable prices_diff");
      Eigen::Matrix<local_scalar_t__,-1,1> mu =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(Nr, DUMMY_VAR__);
      current_statement__ = 27;
      stan::model::assign(mu,
        stan::math::add(Intercept, stan::math::multiply(X_all, b)),
        "assigning variable mu");
      Eigen::Matrix<local_scalar_t__,-1,1> err =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(Nr, DUMMY_VAR__);
      current_statement__ = 32;
      stan::model::assign(err, stan::math::subtract(prices_diff, mu),
        "assigning variable err");
      current_statement__ = 33;
      stan::model::assign(mu,
        stan::math::add(
          stan::model::deep_copy(
            stan::model::rvalue(mu, "mu", stan::model::index_min_max(2, Nr))),
          stan::math::add(
            stan::math::multiply(
              stan::model::rvalue(err, "err",
                stan::model::index_min_max(1, (Nr - 1))), ma),
            stan::math::multiply(
              stan::model::rvalue(prices_diff, "prices_diff",
                stan::model::index_min_max(1, (Nr - 1))),
              stan::model::rvalue(ar, "ar", stan::model::index_uni(1))))),
        "assigning variable mu", stan::model::index_min_max(2, Nr));
      current_statement__ = 34;
      stan::model::assign(mu,
        stan::math::add(
          stan::model::deep_copy(
            stan::model::rvalue(mu, "mu", stan::model::index_min_max(3, Nr))),
          stan::math::multiply(
            stan::model::rvalue(prices_diff, "prices_diff",
              stan::model::index_min_max(1, (Nr - 2))),
            stan::model::rvalue(ar, "ar", stan::model::index_uni(2)))),
        "assigning variable mu", stan::model::index_min_max(3, Nr));
      current_statement__ = 35;
      stan::model::assign(err, stan::math::subtract(prices_diff, mu),
        "assigning variable err");
      Eigen::Matrix<local_scalar_t__,-1,1> h_i_mean =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(Nr, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> h_i_sigma =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(Nr, DUMMY_VAR__);
      current_statement__ = 36;
      stan::model::assign(h_i_mean, 0.0, "assigning variable h_i_mean",
        stan::model::index_uni(1));
      current_statement__ = 37;
      stan::model::assign(h_i_sigma,
        stan::math::pow((1 - stan::math::square(phi)), -(0.5)),
        "assigning variable h_i_sigma", stan::model::index_uni(1));
      current_statement__ = 38;
      stan::model::assign(h_i_sigma, stan::math::rep_vector(1.0, (Nr - 1)),
        "assigning variable h_i_sigma", stan::model::index_min_max(2, Nr));
      current_statement__ = 39;
      stan::model::assign(h_i_mean,
        stan::math::add(
          stan::math::multiply(phi,
            stan::model::rvalue(h, "h",
              stan::model::index_min_max(1, (Nr - 1)))),
          stan::math::multiply(theta,
            stan::math::square(
              stan::model::rvalue(err, "err",
                stan::model::index_min_max(1, (Nr - 1)))))),
        "assigning variable h_i_mean", stan::model::index_min_max(2, Nr));
      Eigen::Matrix<local_scalar_t__,-1,1> h_sigma =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(Nr, DUMMY_VAR__);
      current_statement__ = 31;
      stan::model::assign(h_sigma,
        stan::math::add(
          stan::math::exp(
            stan::math::add(stan::math::multiply(h, (0.5 * sigma)),
              stan::math::multiply(0.5, mu))), 0.000001),
        "assigning variable h_sigma");
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "phi", phi, -(1));
      current_statement__ = 23;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 24;
      stan::math::check_greater_or_equal(function__, "sigma", sigma, 0);
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "h_i_sigma", h_i_sigma,
        0);
      {
        current_statement__ = 40;
        lp_accum__.add(stan::math::multiply(-(2),
                         stan::math::log(sigma_price)));
        current_statement__ = 41;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(Intercept,
                         mu_prior_mu, mu_prior_sigma));
        current_statement__ = 42;
        lp_accum__.add(stan::math::beta_lpdf<propto__>(phi_beta, phi_prior_a,
                         phi_prior_b));
        current_statement__ = 43;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(sigma2,
                         sigma_prior_shape, sigma_prior_rate));
        current_statement__ = 44;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(ar, 0, .2));
        current_statement__ = 45;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(ma, 0, .2));
        current_statement__ = 46;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(h, h_i_mean,
                         h_i_sigma));
        current_statement__ = 47;
        lp_accum__.add(stan::math::student_t_lpdf<propto__>(sigma_price, 3,
                         1, 1));
        current_statement__ = 48;
        lp_accum__.add(stan::math::uniform_lpdf<propto__>(high_low_est,
                         diff_low_mid, diff_high_mid));
        current_statement__ = 49;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(prices, mean_price,
                         sigma_price));
        current_statement__ = 50;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(prices_diff, mu,
                         h_sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "constraints_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      stan::math::var_value<Eigen::Matrix<double,-1,1>> high_low_est =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 1;
      high_low_est = in__.template read_constrain_lub<
                       stan::math::var_value<Eigen::Matrix<double,-1,1>>,
                       jacobian__>(diff_low_mid, diff_high_mid, lp__, N);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "high_low_est",
        high_low_est, "lower", diff_low_mid);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "high_low_est",
        high_low_est, "upper", diff_high_mid);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> b =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(K,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 2;
      b = in__.template read<
            stan::math::var_value<Eigen::Matrix<double,-1,1>>>(K);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> h =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(Nr,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 3;
      h = in__.template read<
            stan::math::var_value<Eigen::Matrix<double,-1,1>>>(Nr);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> ar =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(2,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 4;
      ar = in__.template read<
             stan::math::var_value<Eigen::Matrix<double,-1,1>>>(2);
      local_scalar_t__ ma = DUMMY_VAR__;
      current_statement__ = 5;
      ma = in__.template read<local_scalar_t__>();
      local_scalar_t__ phi_beta = DUMMY_VAR__;
      current_statement__ = 6;
      phi_beta = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ sigma2 = DUMMY_VAR__;
      current_statement__ = 7;
      sigma2 = in__.template read_constrain_lb<local_scalar_t__,
                 jacobian__>(0, lp__);
      local_scalar_t__ Intercept = DUMMY_VAR__;
      current_statement__ = 8;
      Intercept = in__.template read<local_scalar_t__>();
      stan::math::var_value<Eigen::Matrix<double,-1,1>> mean_price =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 9;
      mean_price = in__.template read<
                     stan::math::var_value<Eigen::Matrix<double,-1,1>>>(N);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> sigma_price =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 10;
      sigma_price = in__.template read_constrain_lb<
                      stan::math::var_value<Eigen::Matrix<double,-1,1>>,
                      jacobian__>(0.0, lp__, N);
      local_scalar_t__ theta = DUMMY_VAR__;
      current_statement__ = 11;
      theta = in__.template read<local_scalar_t__>();
      stan::math::var_value<Eigen::Matrix<double,-1,1>> upper_test =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 12;
      upper_test = in__.template read_constrain_ub<
                     stan::math::var_value<Eigen::Matrix<double,-1,1>>,
                     jacobian__>(ma, lp__, N);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> lower_upper_test =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 13;
      lower_upper_test = in__.template read_constrain_lub<
                           stan::math::var_value<Eigen::Matrix<double,-1,1>>,
                           jacobian__>(sigma_price, upper_test, lp__, N);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "lower_upper_test",
        lower_upper_test, "lower", sigma_price);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "lower_upper_test",
        lower_upper_test, "upper", upper_test);
      stan::math::var_value<Eigen::Matrix<double,1,-1>>
        row_vec_lower_upper_test =
        stan::math::var_value<Eigen::Matrix<double,1,-1>>(Eigen::Matrix<double,1,-1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 14;
      row_vec_lower_upper_test = in__.template read_constrain_lub<
                                   stan::math::var_value<Eigen::Matrix<double,1,-1>>,
                                   jacobian__>(stan::math::transpose(
                                                 sigma_price),
                                   stan::math::transpose(upper_test), lp__,
                                   N);
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint",
        "row_vec_lower_upper_test", row_vec_lower_upper_test, "lower",
        stan::math::transpose(sigma_price));
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint",
        "row_vec_lower_upper_test", row_vec_lower_upper_test, "upper",
        stan::math::transpose(upper_test));
      stan::math::var_value<Eigen::Matrix<double,-1,1>> offset_mult_test =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 15;
      offset_mult_test = in__.template read_constrain_offset_multiplier<
                           stan::math::var_value<Eigen::Matrix<double,-1,1>>,
                           jacobian__>(mean_price, sigma_price, lp__, N);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "offset_mult_test",
        offset_mult_test, "offset", mean_price);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "offset_mult_test",
        offset_mult_test, "multiplier", sigma_price);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> ordered_test =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 16;
      ordered_test = in__.template read_constrain_ordered<
                       stan::math::var_value<Eigen::Matrix<double,-1,1>>,
                       jacobian__>(lp__, N);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> unit_vec_test =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 17;
      unit_vec_test = in__.template read_constrain_unit_vector<
                        stan::math::var_value<Eigen::Matrix<double,-1,1>>,
                        jacobian__>(lp__, N);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> pos_ordered_test =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 18;
      pos_ordered_test = in__.template read_constrain_positive_ordered<
                           stan::math::var_value<Eigen::Matrix<double,-1,1>>,
                           jacobian__>(lp__, N);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> corr_matrix_test =
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(N,
                                                             N,
                                                             std::numeric_limits<double>::quiet_NaN(
                                                               )));
      current_statement__ = 19;
      corr_matrix_test = in__.template read_constrain_corr_matrix<
                           stan::math::var_value<Eigen::Matrix<double,-1,-1>>,
                           jacobian__>(lp__, N);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> cov_matrix_test =
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(N,
                                                             N,
                                                             std::numeric_limits<double>::quiet_NaN(
                                                               )));
      current_statement__ = 20;
      cov_matrix_test = in__.template read_constrain_cov_matrix<
                          stan::math::var_value<Eigen::Matrix<double,-1,-1>>,
                          jacobian__>(lp__, N);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> chol_fac_cov_test =
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(K,
                                                             K,
                                                             std::numeric_limits<double>::quiet_NaN(
                                                               )));
      current_statement__ = 21;
      chol_fac_cov_test = in__.template read_constrain_cholesky_factor_cov<
                            stan::math::var_value<Eigen::Matrix<double,-1,-1>>,
                            jacobian__>(lp__, K, K);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> chol_fac_corr_test =
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(K,
                                                             K,
                                                             std::numeric_limits<double>::quiet_NaN(
                                                               )));
      current_statement__ = 22;
      chol_fac_corr_test = in__.template read_constrain_cholesky_factor_corr<
                             stan::math::var_value<Eigen::Matrix<double,-1,-1>>,
                             jacobian__>(lp__, K);
      local_scalar_t__ phi = DUMMY_VAR__;
      current_statement__ = 23;
      phi = stan::math::fma(phi_beta, 2.0, -(1.0));
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 24;
      sigma = stan::math::sqrt(sigma2);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> prices =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 25;
      stan::model::assign(prices, stan::math::add(mid_price, high_low_est),
        "assigning variable prices");
      stan::math::var_value<Eigen::Matrix<double,-1,1>> prices_diff =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(Nr,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 26;
      stan::model::assign(prices_diff,
        stan::math::subtract(
          stan::model::rvalue(prices, "prices",
            stan::model::index_min_max(2, N)),
          stan::model::rvalue(prices, "prices",
            stan::model::index_min_max(1, (N - 1)))),
        "assigning variable prices_diff");
      stan::math::var_value<Eigen::Matrix<double,-1,1>> mu =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(Nr,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 27;
      stan::model::assign(mu,
        stan::math::add(Intercept, stan::math::multiply(X_all, b)),
        "assigning variable mu");
      stan::math::var_value<Eigen::Matrix<double,-1,1>> err =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(Nr,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 32;
      stan::model::assign(err, stan::math::subtract(prices_diff, mu),
        "assigning variable err");
      current_statement__ = 33;
      stan::model::assign(mu,
        stan::math::add(
          stan::model::deep_copy(
            stan::model::rvalue(mu, "mu", stan::model::index_min_max(2, Nr))),
          stan::math::add(
            stan::math::multiply(
              stan::model::rvalue(err, "err",
                stan::model::index_min_max(1, (Nr - 1))), ma),
            stan::math::multiply(
              stan::model::rvalue(prices_diff, "prices_diff",
                stan::model::index_min_max(1, (Nr - 1))),
              stan::model::rvalue(ar, "ar", stan::model::index_uni(1))))),
        "assigning variable mu", stan::model::index_min_max(2, Nr));
      current_statement__ = 34;
      stan::model::assign(mu,
        stan::math::add(
          stan::model::deep_copy(
            stan::model::rvalue(mu, "mu", stan::model::index_min_max(3, Nr))),
          stan::math::multiply(
            stan::model::rvalue(prices_diff, "prices_diff",
              stan::model::index_min_max(1, (Nr - 2))),
            stan::model::rvalue(ar, "ar", stan::model::index_uni(2)))),
        "assigning variable mu", stan::model::index_min_max(3, Nr));
      current_statement__ = 35;
      stan::model::assign(err, stan::math::subtract(prices_diff, mu),
        "assigning variable err");
      stan::math::var_value<Eigen::Matrix<double,-1,1>> h_i_mean =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(Nr,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      stan::math::var_value<Eigen::Matrix<double,-1,1>> h_i_sigma =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(Nr,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 36;
      stan::model::assign(h_i_mean, 0.0, "assigning variable h_i_mean",
        stan::model::index_uni(1));
      current_statement__ = 37;
      stan::model::assign(h_i_sigma,
        stan::math::pow((1 - stan::math::square(phi)), -(0.5)),
        "assigning variable h_i_sigma", stan::model::index_uni(1));
      current_statement__ = 38;
      stan::model::assign(h_i_sigma, stan::math::rep_vector(1.0, (Nr - 1)),
        "assigning variable h_i_sigma", stan::model::index_min_max(2, Nr));
      current_statement__ = 39;
      stan::model::assign(h_i_mean,
        stan::math::add(
          stan::math::multiply(phi,
            stan::model::rvalue(h, "h",
              stan::model::index_min_max(1, (Nr - 1)))),
          stan::math::multiply(theta,
            stan::math::square(
              stan::model::rvalue(err, "err",
                stan::model::index_min_max(1, (Nr - 1)))))),
        "assigning variable h_i_mean", stan::model::index_min_max(2, Nr));
      stan::math::var_value<Eigen::Matrix<double,-1,1>> h_sigma =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(Nr,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 31;
      stan::model::assign(h_sigma,
        stan::math::add(
          stan::math::exp(
            stan::math::add(stan::math::multiply(h, (0.5 * sigma)),
              stan::math::multiply(0.5, mu))), 0.000001),
        "assigning variable h_sigma");
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "phi", phi, -(1));
      current_statement__ = 23;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 24;
      stan::math::check_greater_or_equal(function__, "sigma", sigma, 0);
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "h_i_sigma", h_i_sigma,
        0);
      {
        current_statement__ = 40;
        lp_accum__.add(stan::math::multiply(-(2),
                         stan::math::log(sigma_price)));
        current_statement__ = 41;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(Intercept,
                         mu_prior_mu, mu_prior_sigma));
        current_statement__ = 42;
        lp_accum__.add(stan::math::beta_lpdf<propto__>(phi_beta, phi_prior_a,
                         phi_prior_b));
        current_statement__ = 43;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(sigma2,
                         sigma_prior_shape, sigma_prior_rate));
        current_statement__ = 44;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(ar, 0, .2));
        current_statement__ = 45;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(ma, 0, .2));
        current_statement__ = 46;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(h, h_i_mean,
                         h_i_sigma));
        current_statement__ = 47;
        lp_accum__.add(stan::math::student_t_lpdf<propto__>(sigma_price, 3,
                         1, 1));
        current_statement__ = 48;
        lp_accum__.add(stan::math::uniform_lpdf<propto__>(high_low_est,
                         diff_low_mid, diff_high_mid));
        current_statement__ = 49;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(prices, mean_price,
                         sigma_price));
        current_statement__ = 50;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(prices_diff, mu,
                         h_sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "constraints_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,1> high_low_est =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      high_low_est = in__.template read_constrain_lub<
                       Eigen::Matrix<local_scalar_t__,-1,1>,
                       jacobian__>(diff_low_mid, diff_high_mid, lp__, N);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "high_low_est",
        high_low_est, "lower", diff_low_mid);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "high_low_est",
        high_low_est, "upper", diff_high_mid);
      Eigen::Matrix<double,-1,1> b =
        Eigen::Matrix<double,-1,1>::Constant(K,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      b = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
      Eigen::Matrix<double,-1,1> h =
        Eigen::Matrix<double,-1,1>::Constant(Nr,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      h = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(Nr);
      Eigen::Matrix<double,-1,1> ar =
        Eigen::Matrix<double,-1,1>::Constant(2,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 4;
      ar = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(2);
      double ma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      ma = in__.template read<local_scalar_t__>();
      double phi_beta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 6;
      phi_beta = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0, 1, lp__);
      double sigma2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 7;
      sigma2 = in__.template read_constrain_lb<local_scalar_t__,
                 jacobian__>(0, lp__);
      double Intercept = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 8;
      Intercept = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,1> mean_price =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 9;
      mean_price = in__.template read<
                     Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<double,-1,1> sigma_price =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 10;
      sigma_price = in__.template read_constrain_lb<
                      Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0.0,
                      lp__, N);
      double theta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 11;
      theta = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,1> upper_test =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 12;
      upper_test = in__.template read_constrain_ub<
                     Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(ma,
                     lp__, N);
      Eigen::Matrix<double,-1,1> lower_upper_test =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 13;
      lower_upper_test = in__.template read_constrain_lub<
                           Eigen::Matrix<local_scalar_t__,-1,1>,
                           jacobian__>(sigma_price, upper_test, lp__, N);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "lower_upper_test",
        lower_upper_test, "lower", sigma_price);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "lower_upper_test",
        lower_upper_test, "upper", upper_test);
      Eigen::Matrix<double,1,-1> row_vec_lower_upper_test =
        Eigen::Matrix<double,1,-1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 14;
      row_vec_lower_upper_test = in__.template read_constrain_lub<
                                   Eigen::Matrix<local_scalar_t__,1,-1>,
                                   jacobian__>(stan::math::transpose(
                                                 sigma_price),
                                   stan::math::transpose(upper_test), lp__,
                                   N);
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint",
        "row_vec_lower_upper_test", row_vec_lower_upper_test, "lower",
        stan::math::transpose(sigma_price));
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint",
        "row_vec_lower_upper_test", row_vec_lower_upper_test, "upper",
        stan::math::transpose(upper_test));
      Eigen::Matrix<double,-1,1> offset_mult_test =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 15;
      offset_mult_test = in__.template read_constrain_offset_multiplier<
                           Eigen::Matrix<local_scalar_t__,-1,1>,
                           jacobian__>(mean_price, sigma_price, lp__, N);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "offset_mult_test",
        offset_mult_test, "offset", mean_price);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "offset_mult_test",
        offset_mult_test, "multiplier", sigma_price);
      Eigen::Matrix<double,-1,1> ordered_test =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 16;
      ordered_test = in__.template read_constrain_ordered<
                       Eigen::Matrix<local_scalar_t__,-1,1>,
                       jacobian__>(lp__, N);
      Eigen::Matrix<double,-1,1> unit_vec_test =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 17;
      unit_vec_test = in__.template read_constrain_unit_vector<
                        Eigen::Matrix<local_scalar_t__,-1,1>,
                        jacobian__>(lp__, N);
      Eigen::Matrix<double,-1,1> pos_ordered_test =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 18;
      pos_ordered_test = in__.template read_constrain_positive_ordered<
                           Eigen::Matrix<local_scalar_t__,-1,1>,
                           jacobian__>(lp__, N);
      Eigen::Matrix<double,-1,-1> corr_matrix_test =
        Eigen::Matrix<double,-1,-1>::Constant(N, N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 19;
      corr_matrix_test = in__.template read_constrain_corr_matrix<
                           Eigen::Matrix<local_scalar_t__,-1,-1>,
                           jacobian__>(lp__, N);
      Eigen::Matrix<double,-1,-1> cov_matrix_test =
        Eigen::Matrix<double,-1,-1>::Constant(N, N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 20;
      cov_matrix_test = in__.template read_constrain_cov_matrix<
                          Eigen::Matrix<local_scalar_t__,-1,-1>,
                          jacobian__>(lp__, N);
      Eigen::Matrix<double,-1,-1> chol_fac_cov_test =
        Eigen::Matrix<double,-1,-1>::Constant(K, K,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 21;
      chol_fac_cov_test = in__.template read_constrain_cholesky_factor_cov<
                            Eigen::Matrix<local_scalar_t__,-1,-1>,
                            jacobian__>(lp__, K, K);
      Eigen::Matrix<double,-1,-1> chol_fac_corr_test =
        Eigen::Matrix<double,-1,-1>::Constant(K, K,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 22;
      chol_fac_corr_test = in__.template read_constrain_cholesky_factor_corr<
                             Eigen::Matrix<local_scalar_t__,-1,-1>,
                             jacobian__>(lp__, K);
      double phi = std::numeric_limits<double>::quiet_NaN();
      double sigma = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double,-1,1> prices =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> prices_diff =
        Eigen::Matrix<double,-1,1>::Constant(Nr,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> mu =
        Eigen::Matrix<double,-1,1>::Constant(Nr,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> err =
        Eigen::Matrix<double,-1,1>::Constant(Nr,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> h_i_mean =
        Eigen::Matrix<double,-1,1>::Constant(Nr,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> h_i_sigma =
        Eigen::Matrix<double,-1,1>::Constant(Nr,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> h_sigma =
        Eigen::Matrix<double,-1,1>::Constant(Nr,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(high_low_est);
      out__.write(b);
      out__.write(h);
      out__.write(ar);
      out__.write(ma);
      out__.write(phi_beta);
      out__.write(sigma2);
      out__.write(Intercept);
      out__.write(mean_price);
      out__.write(sigma_price);
      out__.write(theta);
      out__.write(upper_test);
      out__.write(lower_upper_test);
      out__.write(row_vec_lower_upper_test);
      out__.write(offset_mult_test);
      out__.write(ordered_test);
      out__.write(unit_vec_test);
      out__.write(pos_ordered_test);
      out__.write(corr_matrix_test);
      out__.write(cov_matrix_test);
      out__.write(chol_fac_cov_test);
      out__.write(chol_fac_corr_test);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 23;
      phi = stan::math::fma(phi_beta, 2.0, -(1.0));
      current_statement__ = 24;
      sigma = stan::math::sqrt(sigma2);
      current_statement__ = 25;
      stan::model::assign(prices, stan::math::add(mid_price, high_low_est),
        "assigning variable prices");
      current_statement__ = 26;
      stan::model::assign(prices_diff,
        stan::math::subtract(
          stan::model::rvalue(prices, "prices",
            stan::model::index_min_max(2, N)),
          stan::model::rvalue(prices, "prices",
            stan::model::index_min_max(1, (N - 1)))),
        "assigning variable prices_diff");
      current_statement__ = 27;
      stan::model::assign(mu,
        stan::math::add(Intercept, stan::math::multiply(X_all, b)),
        "assigning variable mu");
      current_statement__ = 32;
      stan::model::assign(err, stan::math::subtract(prices_diff, mu),
        "assigning variable err");
      current_statement__ = 33;
      stan::model::assign(mu,
        stan::math::add(
          stan::model::deep_copy(
            stan::model::rvalue(mu, "mu", stan::model::index_min_max(2, Nr))),
          stan::math::add(
            stan::math::multiply(
              stan::model::rvalue(err, "err",
                stan::model::index_min_max(1, (Nr - 1))), ma),
            stan::math::multiply(
              stan::model::rvalue(prices_diff, "prices_diff",
                stan::model::index_min_max(1, (Nr - 1))),
              stan::model::rvalue(ar, "ar", stan::model::index_uni(1))))),
        "assigning variable mu", stan::model::index_min_max(2, Nr));
      current_statement__ = 34;
      stan::model::assign(mu,
        stan::math::add(
          stan::model::deep_copy(
            stan::model::rvalue(mu, "mu", stan::model::index_min_max(3, Nr))),
          stan::math::multiply(
            stan::model::rvalue(prices_diff, "prices_diff",
              stan::model::index_min_max(1, (Nr - 2))),
            stan::model::rvalue(ar, "ar", stan::model::index_uni(2)))),
        "assigning variable mu", stan::model::index_min_max(3, Nr));
      current_statement__ = 35;
      stan::model::assign(err, stan::math::subtract(prices_diff, mu),
        "assigning variable err");
      current_statement__ = 36;
      stan::model::assign(h_i_mean, 0.0, "assigning variable h_i_mean",
        stan::model::index_uni(1));
      current_statement__ = 37;
      stan::model::assign(h_i_sigma,
        stan::math::pow((1 - stan::math::square(phi)), -(0.5)),
        "assigning variable h_i_sigma", stan::model::index_uni(1));
      current_statement__ = 38;
      stan::model::assign(h_i_sigma, stan::math::rep_vector(1.0, (Nr - 1)),
        "assigning variable h_i_sigma", stan::model::index_min_max(2, Nr));
      current_statement__ = 39;
      stan::model::assign(h_i_mean,
        stan::math::add(
          stan::math::multiply(phi,
            stan::model::rvalue(h, "h",
              stan::model::index_min_max(1, (Nr - 1)))),
          stan::math::multiply(theta,
            stan::math::square(
              stan::model::rvalue(err, "err",
                stan::model::index_min_max(1, (Nr - 1)))))),
        "assigning variable h_i_mean", stan::model::index_min_max(2, Nr));
      current_statement__ = 31;
      stan::model::assign(h_sigma,
        stan::math::add(
          stan::math::exp(
            stan::math::add(stan::math::multiply(h, (0.5 * sigma)),
              stan::math::multiply(0.5, mu))), 0.000001),
        "assigning variable h_sigma");
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "phi", phi, -(1));
      current_statement__ = 23;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 24;
      stan::math::check_greater_or_equal(function__, "sigma", sigma, 0);
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "h_i_sigma", h_i_sigma,
        0);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(sigma);
        out__.write(prices);
        out__.write(prices_diff);
        out__.write(mu);
        out__.write(err);
        out__.write(h_i_mean);
        out__.write(h_i_sigma);
        out__.write(h_sigma);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> high_low_est =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(high_low_est,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable high_low_est");
      out__.write_free_lub(diff_low_mid, diff_high_mid, high_low_est);
      Eigen::Matrix<local_scalar_t__,-1,1> b =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(b,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(K),
        "assigning variable b");
      out__.write(b);
      Eigen::Matrix<local_scalar_t__,-1,1> h =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(Nr, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(h,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(Nr),
        "assigning variable h");
      out__.write(h);
      Eigen::Matrix<local_scalar_t__,-1,1> ar =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(ar,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(2),
        "assigning variable ar");
      out__.write(ar);
      local_scalar_t__ ma = DUMMY_VAR__;
      current_statement__ = 5;
      ma = in__.read<local_scalar_t__>();
      out__.write(ma);
      local_scalar_t__ phi_beta = DUMMY_VAR__;
      current_statement__ = 6;
      phi_beta = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, phi_beta);
      local_scalar_t__ sigma2 = DUMMY_VAR__;
      current_statement__ = 7;
      sigma2 = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma2);
      local_scalar_t__ Intercept = DUMMY_VAR__;
      current_statement__ = 8;
      Intercept = in__.read<local_scalar_t__>();
      out__.write(Intercept);
      Eigen::Matrix<local_scalar_t__,-1,1> mean_price =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 9;
      stan::model::assign(mean_price,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable mean_price");
      out__.write(mean_price);
      Eigen::Matrix<local_scalar_t__,-1,1> sigma_price =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 10;
      stan::model::assign(sigma_price,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable sigma_price");
      out__.write_free_lb(0.0, sigma_price);
      local_scalar_t__ theta = DUMMY_VAR__;
      current_statement__ = 11;
      theta = in__.read<local_scalar_t__>();
      out__.write(theta);
      Eigen::Matrix<local_scalar_t__,-1,1> upper_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 12;
      stan::model::assign(upper_test,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable upper_test");
      out__.write_free_ub(ma, upper_test);
      Eigen::Matrix<local_scalar_t__,-1,1> lower_upper_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 13;
      stan::model::assign(lower_upper_test,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable lower_upper_test");
      out__.write_free_lub(sigma_price, upper_test, lower_upper_test);
      Eigen::Matrix<local_scalar_t__,1,-1> row_vec_lower_upper_test =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 14;
      stan::model::assign(row_vec_lower_upper_test,
        in__.read<Eigen::Matrix<local_scalar_t__,1,-1>>(N),
        "assigning variable row_vec_lower_upper_test");
      out__.write_free_lub(stan::math::transpose(sigma_price),
        stan::math::transpose(upper_test), row_vec_lower_upper_test);
      Eigen::Matrix<local_scalar_t__,-1,1> offset_mult_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 15;
      stan::model::assign(offset_mult_test,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable offset_mult_test");
      out__.write_free_offset_multiplier(mean_price, sigma_price,
        offset_mult_test);
      Eigen::Matrix<local_scalar_t__,-1,1> ordered_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 16;
      stan::model::assign(ordered_test,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable ordered_test");
      out__.write_free_ordered(ordered_test);
      Eigen::Matrix<local_scalar_t__,-1,1> unit_vec_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 17;
      stan::model::assign(unit_vec_test,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable unit_vec_test");
      out__.write_free_unit_vector(unit_vec_test);
      Eigen::Matrix<local_scalar_t__,-1,1> pos_ordered_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 18;
      stan::model::assign(pos_ordered_test,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable pos_ordered_test");
      out__.write_free_positive_ordered(pos_ordered_test);
      Eigen::Matrix<local_scalar_t__,-1,-1> corr_matrix_test =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      current_statement__ = 19;
      stan::model::assign(corr_matrix_test,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N),
        "assigning variable corr_matrix_test");
      out__.write_free_corr_matrix(corr_matrix_test);
      Eigen::Matrix<local_scalar_t__,-1,-1> cov_matrix_test =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      current_statement__ = 20;
      stan::model::assign(cov_matrix_test,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, N),
        "assigning variable cov_matrix_test");
      out__.write_free_cov_matrix(cov_matrix_test);
      Eigen::Matrix<local_scalar_t__,-1,-1> chol_fac_cov_test =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(K, K, DUMMY_VAR__);
      current_statement__ = 21;
      stan::model::assign(chol_fac_cov_test,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(K, K),
        "assigning variable chol_fac_cov_test");
      out__.write_free_cholesky_factor_cov(chol_fac_cov_test);
      Eigen::Matrix<local_scalar_t__,-1,-1> chol_fac_corr_test =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(K, K, DUMMY_VAR__);
      current_statement__ = 22;
      stan::model::assign(chol_fac_corr_test,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(K, K),
        "assigning variable chol_fac_corr_test");
      out__.write_free_cholesky_factor_corr(chol_fac_corr_test);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "high_low_est",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "b", "double",
        std::vector<size_t>{static_cast<size_t>(K)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "h", "double",
        std::vector<size_t>{static_cast<size_t>(Nr)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "ar", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "ma", "double",
        std::vector<size_t>{});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "phi_beta",
        "double", std::vector<size_t>{});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "sigma2", "double",
        std::vector<size_t>{});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization", "Intercept",
        "double", std::vector<size_t>{});
      current_statement__ = 9;
      context__.validate_dims("parameter initialization", "mean_price",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 10;
      context__.validate_dims("parameter initialization", "sigma_price",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 11;
      context__.validate_dims("parameter initialization", "theta", "double",
        std::vector<size_t>{});
      current_statement__ = 12;
      context__.validate_dims("parameter initialization", "upper_test",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 13;
      context__.validate_dims("parameter initialization", "lower_upper_test",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 14;
      context__.validate_dims("parameter initialization",
        "row_vec_lower_upper_test", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 15;
      context__.validate_dims("parameter initialization", "offset_mult_test",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 16;
      context__.validate_dims("parameter initialization", "ordered_test",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 17;
      context__.validate_dims("parameter initialization", "unit_vec_test",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 18;
      context__.validate_dims("parameter initialization", "pos_ordered_test",
        "double", std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 19;
      context__.validate_dims("parameter initialization", "corr_matrix_test",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 20;
      context__.validate_dims("parameter initialization", "cov_matrix_test",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)});
      current_statement__ = 21;
      context__.validate_dims("parameter initialization",
        "chol_fac_cov_test", "double",
        std::vector<size_t>{static_cast<size_t>(K), static_cast<size_t>(K)});
      current_statement__ = 22;
      context__.validate_dims("parameter initialization",
        "chol_fac_corr_test", "double",
        std::vector<size_t>{static_cast<size_t>(K), static_cast<size_t>(K)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> high_low_est =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> high_low_est_flat__;
        current_statement__ = 1;
        high_low_est_flat__ = context__.vals_r("high_low_est");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(high_low_est, high_low_est_flat__[(pos__ - 1)],
            "assigning variable high_low_est", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lub(diff_low_mid, diff_high_mid, high_low_est);
      Eigen::Matrix<local_scalar_t__,-1,1> b =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> b_flat__;
        current_statement__ = 2;
        b_flat__ = context__.vals_r("b");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          stan::model::assign(b, b_flat__[(pos__ - 1)],
            "assigning variable b", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(b);
      Eigen::Matrix<local_scalar_t__,-1,1> h =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(Nr, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> h_flat__;
        current_statement__ = 3;
        h_flat__ = context__.vals_r("h");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
          stan::model::assign(h, h_flat__[(pos__ - 1)],
            "assigning variable h", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(h);
      Eigen::Matrix<local_scalar_t__,-1,1> ar =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> ar_flat__;
        current_statement__ = 4;
        ar_flat__ = context__.vals_r("ar");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          stan::model::assign(ar, ar_flat__[(pos__ - 1)],
            "assigning variable ar", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(ar);
      local_scalar_t__ ma = DUMMY_VAR__;
      current_statement__ = 5;
      ma = context__.vals_r("ma")[(1 - 1)];
      out__.write(ma);
      local_scalar_t__ phi_beta = DUMMY_VAR__;
      current_statement__ = 6;
      phi_beta = context__.vals_r("phi_beta")[(1 - 1)];
      out__.write_free_lub(0, 1, phi_beta);
      local_scalar_t__ sigma2 = DUMMY_VAR__;
      current_statement__ = 7;
      sigma2 = context__.vals_r("sigma2")[(1 - 1)];
      out__.write_free_lb(0, sigma2);
      local_scalar_t__ Intercept = DUMMY_VAR__;
      current_statement__ = 8;
      Intercept = context__.vals_r("Intercept")[(1 - 1)];
      out__.write(Intercept);
      Eigen::Matrix<local_scalar_t__,-1,1> mean_price =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> mean_price_flat__;
        current_statement__ = 9;
        mean_price_flat__ = context__.vals_r("mean_price");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(mean_price, mean_price_flat__[(pos__ - 1)],
            "assigning variable mean_price", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(mean_price);
      Eigen::Matrix<local_scalar_t__,-1,1> sigma_price =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> sigma_price_flat__;
        current_statement__ = 10;
        sigma_price_flat__ = context__.vals_r("sigma_price");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(sigma_price, sigma_price_flat__[(pos__ - 1)],
            "assigning variable sigma_price", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lb(0.0, sigma_price);
      local_scalar_t__ theta = DUMMY_VAR__;
      current_statement__ = 11;
      theta = context__.vals_r("theta")[(1 - 1)];
      out__.write(theta);
      Eigen::Matrix<local_scalar_t__,-1,1> upper_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> upper_test_flat__;
        current_statement__ = 12;
        upper_test_flat__ = context__.vals_r("upper_test");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(upper_test, upper_test_flat__[(pos__ - 1)],
            "assigning variable upper_test", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_ub(ma, upper_test);
      Eigen::Matrix<local_scalar_t__,-1,1> lower_upper_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> lower_upper_test_flat__;
        current_statement__ = 13;
        lower_upper_test_flat__ = context__.vals_r("lower_upper_test");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(lower_upper_test,
            lower_upper_test_flat__[(pos__ - 1)],
            "assigning variable lower_upper_test",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lub(sigma_price, upper_test, lower_upper_test);
      Eigen::Matrix<local_scalar_t__,1,-1> row_vec_lower_upper_test =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> row_vec_lower_upper_test_flat__;
        current_statement__ = 14;
        row_vec_lower_upper_test_flat__ = context__.vals_r("row_vec_lower_upper_test");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(row_vec_lower_upper_test,
            row_vec_lower_upper_test_flat__[(pos__ - 1)],
            "assigning variable row_vec_lower_upper_test",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lub(stan::math::transpose(sigma_price),
        stan::math::transpose(upper_test), row_vec_lower_upper_test);
      Eigen::Matrix<local_scalar_t__,-1,1> offset_mult_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> offset_mult_test_flat__;
        current_statement__ = 15;
        offset_mult_test_flat__ = context__.vals_r("offset_mult_test");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(offset_mult_test,
            offset_mult_test_flat__[(pos__ - 1)],
            "assigning variable offset_mult_test",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_offset_multiplier(mean_price, sigma_price,
        offset_mult_test);
      Eigen::Matrix<local_scalar_t__,-1,1> ordered_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> ordered_test_flat__;
        current_statement__ = 16;
        ordered_test_flat__ = context__.vals_r("ordered_test");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(ordered_test, ordered_test_flat__[(pos__ - 1)],
            "assigning variable ordered_test", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_ordered(ordered_test);
      Eigen::Matrix<local_scalar_t__,-1,1> unit_vec_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> unit_vec_test_flat__;
        current_statement__ = 17;
        unit_vec_test_flat__ = context__.vals_r("unit_vec_test");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(unit_vec_test, unit_vec_test_flat__[(pos__ -
            1)], "assigning variable unit_vec_test",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_unit_vector(unit_vec_test);
      Eigen::Matrix<local_scalar_t__,-1,1> pos_ordered_test =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> pos_ordered_test_flat__;
        current_statement__ = 18;
        pos_ordered_test_flat__ = context__.vals_r("pos_ordered_test");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(pos_ordered_test,
            pos_ordered_test_flat__[(pos__ - 1)],
            "assigning variable pos_ordered_test",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_positive_ordered(pos_ordered_test);
      Eigen::Matrix<local_scalar_t__,-1,-1> corr_matrix_test =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> corr_matrix_test_flat__;
        current_statement__ = 19;
        corr_matrix_test_flat__ = context__.vals_r("corr_matrix_test");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(corr_matrix_test,
              corr_matrix_test_flat__[(pos__ - 1)],
              "assigning variable corr_matrix_test",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_corr_matrix(corr_matrix_test);
      Eigen::Matrix<local_scalar_t__,-1,-1> cov_matrix_test =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> cov_matrix_test_flat__;
        current_statement__ = 20;
        cov_matrix_test_flat__ = context__.vals_r("cov_matrix_test");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(cov_matrix_test,
              cov_matrix_test_flat__[(pos__ - 1)],
              "assigning variable cov_matrix_test",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_cov_matrix(cov_matrix_test);
      Eigen::Matrix<local_scalar_t__,-1,-1> chol_fac_cov_test =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(K, K, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> chol_fac_cov_test_flat__;
        current_statement__ = 21;
        chol_fac_cov_test_flat__ = context__.vals_r("chol_fac_cov_test");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            stan::model::assign(chol_fac_cov_test,
              chol_fac_cov_test_flat__[(pos__ - 1)],
              "assigning variable chol_fac_cov_test",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_cholesky_factor_cov(chol_fac_cov_test);
      Eigen::Matrix<local_scalar_t__,-1,-1> chol_fac_corr_test =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(K, K, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> chol_fac_corr_test_flat__;
        current_statement__ = 22;
        chol_fac_corr_test_flat__ = context__.vals_r("chol_fac_corr_test");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            stan::model::assign(chol_fac_corr_test,
              chol_fac_corr_test_flat__[(pos__ - 1)],
              "assigning variable chol_fac_corr_test",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_cholesky_factor_corr(chol_fac_corr_test);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"high_low_est", "b", "h", "ar", "ma",
                "phi_beta", "sigma2", "Intercept", "mean_price",
                "sigma_price", "theta", "upper_test", "lower_upper_test",
                "row_vec_lower_upper_test", "offset_mult_test",
                "ordered_test", "unit_vec_test", "pos_ordered_test",
                "corr_matrix_test", "cov_matrix_test", "chol_fac_cov_test",
                "chol_fac_corr_test"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"phi", "sigma", "prices", "prices_diff", "mu", "err",
             "h_i_mean", "h_i_sigma", "h_sigma"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(K)},
                std::vector<size_t>{static_cast<size_t>(Nr)},
                std::vector<size_t>{static_cast<size_t>(2)},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(K),
                  static_cast<size_t>(K)},
                std::vector<size_t>{static_cast<size_t>(K),
                  static_cast<size_t>(K)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(N)},
             std::vector<size_t>{static_cast<size_t>(Nr)},
             std::vector<size_t>{static_cast<size_t>(Nr)},
             std::vector<size_t>{static_cast<size_t>(Nr)},
             std::vector<size_t>{static_cast<size_t>(Nr)},
             std::vector<size_t>{static_cast<size_t>(Nr)},
             std::vector<size_t>{static_cast<size_t>(Nr)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "high_low_est" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      param_names__.emplace_back(std::string() + "b" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
      param_names__.emplace_back(std::string() + "h" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "ar" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "ma");
    param_names__.emplace_back(std::string() + "phi_beta");
    param_names__.emplace_back(std::string() + "sigma2");
    param_names__.emplace_back(std::string() + "Intercept");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "mean_price" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "sigma_price" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "theta");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "upper_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "lower_upper_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "row_vec_lower_upper_test" +
        '.' + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "offset_mult_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "ordered_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "unit_vec_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "pos_ordered_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "corr_matrix_test" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "cov_matrix_test" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
        param_names__.emplace_back(std::string() + "chol_fac_cov_test" + '.'
          + std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
        param_names__.emplace_back(std::string() + "chol_fac_corr_test" + '.'
          + std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "phi");
      param_names__.emplace_back(std::string() + "sigma");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "prices" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        param_names__.emplace_back(std::string() + "prices_diff" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        param_names__.emplace_back(std::string() + "mu" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        param_names__.emplace_back(std::string() + "err" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        param_names__.emplace_back(std::string() + "h_i_mean" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        param_names__.emplace_back(std::string() + "h_i_sigma" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        param_names__.emplace_back(std::string() + "h_sigma" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "high_low_est" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      param_names__.emplace_back(std::string() + "b" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
      param_names__.emplace_back(std::string() + "h" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      param_names__.emplace_back(std::string() + "ar" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "ma");
    param_names__.emplace_back(std::string() + "phi_beta");
    param_names__.emplace_back(std::string() + "sigma2");
    param_names__.emplace_back(std::string() + "Intercept");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "mean_price" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "sigma_price" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "theta");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "upper_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "lower_upper_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "row_vec_lower_upper_test" +
        '.' + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "offset_mult_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "ordered_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "unit_vec_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "pos_ordered_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= ((N * (N - 1)) / 2); ++sym1__) {
      param_names__.emplace_back(std::string() + "corr_matrix_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= (N + ((N * (N - 1)) / 2)); ++sym1__) {
      param_names__.emplace_back(std::string() + "cov_matrix_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= ((((K * (K - 1)) / 2) + K) + ((K - K) *
         K)); ++sym1__) {
      param_names__.emplace_back(std::string() + "chol_fac_cov_test" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= ((K * (K - 1)) / 2); ++sym1__) {
      param_names__.emplace_back(std::string() + "chol_fac_corr_test" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "phi");
      param_names__.emplace_back(std::string() + "sigma");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        param_names__.emplace_back(std::string() + "prices" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        param_names__.emplace_back(std::string() + "prices_diff" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        param_names__.emplace_back(std::string() + "mu" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        param_names__.emplace_back(std::string() + "err" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        param_names__.emplace_back(std::string() + "h_i_mean" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        param_names__.emplace_back(std::string() + "h_i_sigma" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        param_names__.emplace_back(std::string() + "h_sigma" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"high_low_est\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"h\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"parameters\"},{\"name\":\"ar\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"ma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_price\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"sigma_price\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"upper_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"lower_upper_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"row_vec_lower_upper_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"offset_mult_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"ordered_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"unit_vec_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"pos_ordered_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"corr_matrix_test\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"cov_matrix_test\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"chol_fac_cov_test\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(K) + ",\"cols\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"chol_fac_corr_test\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(K) + ",\"cols\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"prices\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"prices_diff\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"err\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"h_i_mean\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"h_i_sigma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"h_sigma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"high_low_est\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"h\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"parameters\"},{\"name\":\"ar\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"ma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_price\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"sigma_price\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"upper_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"lower_upper_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"row_vec_lower_upper_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"offset_mult_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"ordered_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"unit_vec_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"pos_ordered_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"corr_matrix_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((N * (N - 1)) /2)) + "},\"block\":\"parameters\"},{\"name\":\"cov_matrix_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((N + ((N * (N - 1)) /2))) + "},\"block\":\"parameters\"},{\"name\":\"chol_fac_cov_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((((K * (K - 1)) / 2) + K) + ((K - K) *K))) + "},\"block\":\"parameters\"},{\"name\":\"chol_fac_corr_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((K * (K - 1)) /2)) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"prices\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"prices_diff\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"err\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"h_i_mean\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"h_i_sigma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"h_sigma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((((((((((((((((N + K) + Nr) + 2) + 1) +
      1) + 1) + 1) + N) + N) + 1) + N) + N) + N) + N) + N) + N) + N) + (N *
      N)) + (N * N)) + (K * K)) + (K * K));
    const size_t num_transformed = emit_transformed_parameters * (((((((((1 +
      1) + N) + Nr) + Nr) + Nr) + Nr) + Nr) + Nr));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((((((((((((((((N + K) + Nr) + 2) + 1) +
      1) + 1) + 1) + N) + N) + 1) + N) + N) + N) + N) + N) + N) + N) + (N *
      N)) + (N * N)) + (K * K)) + (K * K));
    const size_t num_transformed = emit_transformed_parameters * (((((((((1 +
      1) + N) + Nr) + Nr) + Nr) + Nr) + Nr) + Nr));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = constraints_model_namespace::constraints_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return constraints_model_namespace::profiles__;
}
#endif
  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp deep_dependence.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace deep_dependence_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 14> locations_array__ =
  {" (found before start of program)",
  " (in 'deep_dependence.stan', line 6, column 4 to column 23)",
  " (in 'deep_dependence.stan', line 10, column 4 to column 36)",
  " (in 'deep_dependence.stan', line 11, column 4 to column 38)",
  " (in 'deep_dependence.stan', line 12, column 4 to column 38)",
  " (in 'deep_dependence.stan', line 13, column 4 to column 38)",
  " (in 'deep_dependence.stan', line 14, column 4 to column 38)",
  " (in 'deep_dependence.stan', line 15, column 4 to column 38)",
  " (in 'deep_dependence.stan', line 16, column 4 to column 38)",
  " (in 'deep_dependence.stan', line 19, column 12 to column 43)",
  " (in 'deep_dependence.stan', line 18, column 23 to line 20, column 9)",
  " (in 'deep_dependence.stan', line 18, column 8 to line 20, column 9)",
  " (in 'deep_dependence.stan', line 17, column 19 to line 21, column 5)",
  " (in 'deep_dependence.stan', line 17, column 4 to line 21, column 5)"};
class deep_dependence_model final : public model_base_crtp<deep_dependence_model> {
 private:
  
 public:
  ~deep_dependence_model() {}
  deep_dependence_model(stan::io::var_context& context__, unsigned int
                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "deep_dependence_model_namespace::deep_dependence_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = (10 * 10);
  }
  inline std::string model_name() const final {
    return "deep_dependence_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = -fsoa --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "deep_dependence_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(X_tp1, stan::math::exp(X_p),
        "assigning variable X_tp1");
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp2 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(X_tp2, stan::math::exp(X_tp1),
        "assigning variable X_tp2");
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp3 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(X_tp3, stan::math::exp(X_tp2),
        "assigning variable X_tp3");
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp4 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(X_tp4, stan::math::exp(X_tp3),
        "assigning variable X_tp4");
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp5 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(X_tp5, stan::math::exp(X_tp4),
        "assigning variable X_tp5");
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp6 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(X_tp6, stan::math::exp(X_tp5),
        "assigning variable X_tp6");
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp7 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(X_tp7, stan::math::exp(X_tp6),
        "assigning variable X_tp7");
      current_statement__ = 13;
      for (int i = 1; i <= 5; ++i) {
        current_statement__ = 11;
        for (int j = 1; j <= 5; ++j) {
          current_statement__ = 9;
          stan::model::assign(X_tp7,
            stan::math::exp(
              stan::model::rvalue(X_tp7, "X_tp7", stan::model::index_uni(i),
                stan::model::index_uni(j))), "assigning variable X_tp7",
            stan::model::index_uni(i), stan::model::index_uni(j));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "deep_dependence_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(X_tp1, stan::math::exp(X_p),
        "assigning variable X_tp1");
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp2 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(X_tp2, stan::math::exp(X_tp1),
        "assigning variable X_tp2");
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp3 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(X_tp3, stan::math::exp(X_tp2),
        "assigning variable X_tp3");
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp4 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(X_tp4, stan::math::exp(X_tp3),
        "assigning variable X_tp4");
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp5 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(X_tp5, stan::math::exp(X_tp4),
        "assigning variable X_tp5");
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp6 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(X_tp6, stan::math::exp(X_tp5),
        "assigning variable X_tp6");
      Eigen::Matrix<local_scalar_t__,-1,-1> X_tp7 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(X_tp7, stan::math::exp(X_tp6),
        "assigning variable X_tp7");
      current_statement__ = 13;
      for (int i = 1; i <= 5; ++i) {
        current_statement__ = 11;
        for (int j = 1; j <= 5; ++j) {
          current_statement__ = 9;
          stan::model::assign(X_tp7,
            stan::math::exp(
              stan::model::rvalue(X_tp7, "X_tp7", stan::model::index_uni(i),
                stan::model::index_uni(j))), "assigning variable X_tp7",
            stan::model::index_uni(i), stan::model::index_uni(j));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "deep_dependence_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> X_p =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<double,-1,-1> X_tp1 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp2 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp3 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp4 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp5 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp6 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> X_tp7 =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(X_p);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 2;
      stan::model::assign(X_tp1, stan::math::exp(X_p),
        "assigning variable X_tp1");
      current_statement__ = 3;
      stan::model::assign(X_tp2, stan::math::exp(X_tp1),
        "assigning variable X_tp2");
      current_statement__ = 4;
      stan::model::assign(X_tp3, stan::math::exp(X_tp2),
        "assigning variable X_tp3");
      current_statement__ = 5;
      stan::model::assign(X_tp4, stan::math::exp(X_tp3),
        "assigning variable X_tp4");
      current_statement__ = 6;
      stan::model::assign(X_tp5, stan::math::exp(X_tp4),
        "assigning variable X_tp5");
      current_statement__ = 7;
      stan::model::assign(X_tp6, stan::math::exp(X_tp5),
        "assigning variable X_tp6");
      current_statement__ = 8;
      stan::model::assign(X_tp7, stan::math::exp(X_tp6),
        "assigning variable X_tp7");
      current_statement__ = 13;
      for (int i = 1; i <= 5; ++i) {
        current_statement__ = 11;
        for (int j = 1; j <= 5; ++j) {
          current_statement__ = 9;
          stan::model::assign(X_tp7,
            stan::math::exp(
              stan::model::rvalue(X_tp7, "X_tp7", stan::model::index_uni(i),
                stan::model::index_uni(j))), "assigning variable X_tp7",
            stan::model::index_uni(i), stan::model::index_uni(j));
        }
      }
      if (emit_transformed_parameters__) {
        out__.write(X_tp1);
        out__.write(X_tp2);
        out__.write(X_tp3);
        out__.write(X_tp4);
        out__.write(X_tp5);
        out__.write(X_tp6);
        out__.write(X_tp7);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(X_p,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10),
        "assigning variable X_p");
      out__.write(X_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "X_p", "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,-1> X_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> X_p_flat__;
        current_statement__ = 1;
        X_p_flat__ = context__.vals_r("X_p");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            stan::model::assign(X_p, X_p_flat__[(pos__ - 1)],
              "assigning variable X_p", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(X_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"X_p"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"X_tp1", "X_tp2", "X_tp3", "X_tp4", "X_tp5", "X_tp6", "X_tp7"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    10),
                                                 static_cast<size_t>(10)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "X_p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp1" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp2" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp3" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp4" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp5" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp6" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp7" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "X_p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp1" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp2" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp3" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp4" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp5" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp6" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "X_tp7" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"X_tp1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp3\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp4\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp5\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp6\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp7\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"X_tp1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp3\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp4\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp5\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp6\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp7\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (10 * 10);
    const size_t num_transformed = emit_transformed_parameters * ((((((((10 *
      10) + (10 * 10)) + (10 * 10)) + (10 * 10)) + (10 * 10)) + (10 * 10)) +
      (10 * 10)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (10 * 10);
    const size_t num_transformed = emit_transformed_parameters * ((((((((10 *
      10) + (10 * 10)) + (10 * 10)) + (10 * 10)) + (10 * 10)) + (10 * 10)) +
      (10 * 10)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = deep_dependence_model_namespace::deep_dependence_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return deep_dependence_model_namespace::profiles__;
}
#endif
  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp indexing.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace indexing_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 116> locations_array__ =
  {" (found before start of program)",
  " (in 'indexing.stan', line 19, column 2 to column 13)",
  " (in 'indexing.stan', line 21, column 2 to column 24)",
  " (in 'indexing.stan', line 22, column 2 to column 25)",
  " (in 'indexing.stan', line 23, column 2 to column 38)",
  " (in 'indexing.stan', line 24, column 2 to column 36)",
  " (in 'indexing.stan', line 25, column 2 to column 30)",
  " (in 'indexing.stan', line 26, column 2 to column 41)",
  " (in 'indexing.stan', line 27, column 2 to column 35)",
  " (in 'indexing.stan', line 28, column 2 to column 31)",
  " (in 'indexing.stan', line 29, column 2 to column 48)",
  " (in 'indexing.stan', line 30, column 2 to column 47)",
  " (in 'indexing.stan', line 33, column 2 to column 38)",
  " (in 'indexing.stan', line 35, column 2 to column 38)",
  " (in 'indexing.stan', line 37, column 2 to column 37)",
  " (in 'indexing.stan', line 39, column 2 to column 43)",
  " (in 'indexing.stan', line 40, column 2 to column 41)",
  " (in 'indexing.stan', line 43, column 2 to column 25)",
  " (in 'indexing.stan', line 45, column 2 to column 57)",
  " (in 'indexing.stan', line 46, column 2 to column 57)",
  " (in 'indexing.stan', line 49, column 2 to column 43)",
  " (in 'indexing.stan', line 50, column 2 to column 43)",
  " (in 'indexing.stan', line 56, column 2 to column 41)",
  " (in 'indexing.stan', line 59, column 2 to column 62)",
  " (in 'indexing.stan', line 61, column 2 to column 37)",
  " (in 'indexing.stan', line 66, column 2 to column 63)",
  " (in 'indexing.stan', line 70, column 2 to column 44)",
  " (in 'indexing.stan', line 62, column 2 to column 49)",
  " (in 'indexing.stan', line 63, column 2 to column 70)",
  " (in 'indexing.stan', line 68, column 2 to column 45)",
  " (in 'indexing.stan', line 71, column 2 to column 75)",
  " (in 'indexing.stan', line 75, column 9 to column 10)",
  " (in 'indexing.stan', line 75, column 2 to column 108)",
  " (in 'indexing.stan', line 76, column 2 to column 95)",
  " (in 'indexing.stan', line 77, column 2 to column 56)",
  " (in 'indexing.stan', line 78, column 2 to column 62)",
  " (in 'indexing.stan', line 79, column 2 to column 79)",
  " (in 'indexing.stan', line 80, column 2 to column 85)",
  " (in 'indexing.stan', line 81, column 2 to column 89)",
  " (in 'indexing.stan', line 82, column 2 to column 98)",
  " (in 'indexing.stan', line 83, column 2 to column 110)",
  " (in 'indexing.stan', line 86, column 9 to column 10)",
  " (in 'indexing.stan', line 86, column 2 to column 33)",
  " (in 'indexing.stan', line 87, column 2 to column 32)",
  " (in 'indexing.stan', line 88, column 9 to column 10)",
  " (in 'indexing.stan', line 88, column 2 to column 42)",
  " (in 'indexing.stan', line 89, column 2 to column 86)",
  " (in 'indexing.stan', line 93, column 4 to column 57)",
  " (in 'indexing.stan', line 94, column 4 to column 69)",
  " (in 'indexing.stan', line 95, column 4 to column 69)",
  " (in 'indexing.stan', line 96, column 4 to column 70)",
  " (in 'indexing.stan', line 97, column 4 to column 73)",
  " (in 'indexing.stan', line 98, column 4 to column 69)",
  " (in 'indexing.stan', line 99, column 4 to column 88)",
  " (in 'indexing.stan', line 100, column 4 to line 101, column 82)",
  " (in 'indexing.stan', line 102, column 4 to line 103, column 46)",
  " (in 'indexing.stan', line 92, column 18 to line 104, column 3)",
  " (in 'indexing.stan', line 92, column 2 to line 104, column 3)",
  " (in 'indexing.stan', line 107, column 9 to column 10)",
  " (in 'indexing.stan', line 107, column 2 to column 38)",
  " (in 'indexing.stan', line 108, column 9 to column 10)",
  " (in 'indexing.stan', line 108, column 2 to column 44)",
  " (in 'indexing.stan', line 111, column 4 to column 84)",
  " (in 'indexing.stan', line 112, column 4 to column 102)",
  " (in 'indexing.stan', line 114, column 4 to column 70)",
  " (in 'indexing.stan', line 115, column 4 to column 75)",
  " (in 'indexing.stan', line 116, column 4 to line 117, column 40)",
  " (in 'indexing.stan', line 109, column 17 to line 119, column 3)",
  " (in 'indexing.stan', line 109, column 2 to line 119, column 3)",
  " (in 'indexing.stan', line 11, column 1 to column 7)",
  " (in 'indexing.stan', line 12, column 1 to column 7)",
  " (in 'indexing.stan', line 13, column 8 to column 9)",
  " (in 'indexing.stan', line 13, column 11 to column 12)",
  " (in 'indexing.stan', line 13, column 1 to column 20)",
  " (in 'indexing.stan', line 14, column 8 to column 9)",
  " (in 'indexing.stan', line 14, column 1 to column 13)",
  " (in 'indexing.stan', line 15, column 7 to column 8)",
  " (in 'indexing.stan', line 15, column 1 to column 25)",
  " (in 'indexing.stan', line 21, column 9 to column 10)",
  " (in 'indexing.stan', line 22, column 9 to column 10)",
  " (in 'indexing.stan', line 22, column 12 to column 13)",
  " (in 'indexing.stan', line 23, column 19 to column 20)",
  " (in 'indexing.stan', line 24, column 9 to column 10)",
  " (in 'indexing.stan', line 24, column 11 to column 12)",
  " (in 'indexing.stan', line 25, column 9 to column 10)",
  " (in 'indexing.stan', line 26, column 9 to column 10)",
  " (in 'indexing.stan', line 26, column 11 to column 12)",
  " (in 'indexing.stan', line 27, column 13 to column 14)",
  " (in 'indexing.stan', line 28, column 9 to column 10)",
  " (in 'indexing.stan', line 29, column 9 to column 10)",
  " (in 'indexing.stan', line 30, column 9 to column 10)",
  " (in 'indexing.stan', line 30, column 11 to column 12)",
  " (in 'indexing.stan', line 33, column 9 to column 10)",
  " (in 'indexing.stan', line 35, column 9 to column 10)",
  " (in 'indexing.stan', line 37, column 9 to column 10)",
  " (in 'indexing.stan', line 39, column 9 to column 10)",
  " (in 'indexing.stan', line 40, column 9 to column 10)",
  " (in 'indexing.stan', line 40, column 11 to column 12)",
  " (in 'indexing.stan', line 43, column 9 to column 10)",
  " (in 'indexing.stan', line 43, column 12 to column 13)",
  " (in 'indexing.stan', line 45, column 9 to column 10)",
  " (in 'indexing.stan', line 45, column 12 to column 13)",
  " (in 'indexing.stan', line 46, column 9 to column 10)",
  " (in 'indexing.stan', line 46, column 12 to column 13)",
  " (in 'indexing.stan', line 49, column 9 to column 10)",
  " (in 'indexing.stan', line 49, column 12 to column 13)",
  " (in 'indexing.stan', line 50, column 9 to column 10)",
  " (in 'indexing.stan', line 50, column 12 to column 13)",
  " (in 'indexing.stan', line 59, column 9 to column 10)",
  " (in 'indexing.stan', line 61, column 9 to column 10)",
  " (in 'indexing.stan', line 66, column 9 to column 10)",
  " (in 'indexing.stan', line 70, column 9 to column 10)",
  " (in 'indexing.stan', line 3, column 4 to column 13)",
  " (in 'indexing.stan', line 2, column 22 to line 4, column 3)",
  " (in 'indexing.stan', line 6, column 4 to column 13)",
  " (in 'indexing.stan', line 5, column 27 to line 7, column 3)"};
int mask_fun(const int& i, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
udf_fun(const T0__& A_arg__, std::ostream* pstream__);
int mask_fun(const int& i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 112;
    return i;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
udf_fun(const T0__& A_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 114;
    return A;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class indexing_model final : public model_base_crtp<indexing_model> {
 private:
  int N;
  int M;
  Eigen::Matrix<double,-1,-1> dat_x_data__;
  Eigen::Matrix<double,-1,1> y_data__;
  std::vector<int> idx_tester;
  Eigen::Map<Eigen::Matrix<double,-1,-1>> dat_x{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> y{nullptr, 0};
 public:
  ~indexing_model() {}
  indexing_model(stan::io::var_context& context__, unsigned int
                 random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "indexing_model_namespace::indexing_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 69;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 69;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 70;
      context__.validate_dims("data initialization", "M", "int",
        std::vector<size_t>{});
      M = std::numeric_limits<int>::min();
      current_statement__ = 70;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 71;
      stan::math::validate_non_negative_index("dat_x", "N", N);
      current_statement__ = 72;
      stan::math::validate_non_negative_index("dat_x", "M", M);
      current_statement__ = 73;
      context__.validate_dims("data initialization", "dat_x", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)});
      dat_x_data__ = Eigen::Matrix<double,-1,-1>::Constant(N, M,
                       std::numeric_limits<double>::quiet_NaN());
      new (&dat_x)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(dat_x_data__.data(), N, M);
      {
        std::vector<local_scalar_t__> dat_x_flat__;
        current_statement__ = 73;
        dat_x_flat__ = context__.vals_r("dat_x");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(dat_x, dat_x_flat__[(pos__ - 1)],
              "assigning variable dat_x", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 74;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 75;
      context__.validate_dims("data initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      y_data__ = Eigen::Matrix<double,-1,1>::Constant(N,
                   std::numeric_limits<double>::quiet_NaN());
      new (&y) Eigen::Map<Eigen::Matrix<double,-1,1>>(y_data__.data(), N);
      {
        std::vector<local_scalar_t__> y_flat__;
        current_statement__ = 75;
        y_flat__ = context__.vals_r("y");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(y, y_flat__[(pos__ - 1)],
            "assigning variable y", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 76;
      stan::math::validate_non_negative_index("idx_tester", "N", N);
      current_statement__ = 77;
      context__.validate_dims("data initialization", "idx_tester", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      idx_tester = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 77;
      idx_tester = context__.vals_i("idx_tester");
      current_statement__ = 78;
      stan::math::validate_non_negative_index("p_soa_vec_v", "M", M);
      current_statement__ = 79;
      stan::math::validate_non_negative_index("p_soa_mat", "N", N);
      current_statement__ = 80;
      stan::math::validate_non_negative_index("p_soa_mat", "M", M);
      current_statement__ = 81;
      stan::math::validate_non_negative_index("p_soa_arr_vec_v", "N", N);
      current_statement__ = 82;
      stan::math::validate_non_negative_index("p_soa_mat_uni_col_idx", "N", N);
      current_statement__ = 83;
      stan::math::validate_non_negative_index("p_soa_mat_uni_col_idx", "M", M);
      current_statement__ = 84;
      stan::math::validate_non_negative_index("p_soa_vec_uni_idx", "N", N);
      current_statement__ = 85;
      stan::math::validate_non_negative_index("p_soa_loop_mat_uni_col_idx",
        "N", N);
      current_statement__ = 86;
      stan::math::validate_non_negative_index("p_soa_loop_mat_uni_col_idx",
        "M", M);
      current_statement__ = 87;
      stan::math::validate_non_negative_index("p_soa_lhs_loop_mul", "N", N);
      current_statement__ = 88;
      stan::math::validate_non_negative_index("p_soa_rhs_loop_mul", "N", N);
      current_statement__ = 89;
      stan::math::validate_non_negative_index(
        "p_soa_used_with_aos_in_excluded_fun", "N", N);
      current_statement__ = 90;
      stan::math::validate_non_negative_index(
        "p_soa_loop_mat_multi_uni_uni_idx", "N", N);
      current_statement__ = 91;
      stan::math::validate_non_negative_index(
        "p_soa_loop_mat_multi_uni_uni_idx", "M", M);
      current_statement__ = 92;
      stan::math::validate_non_negative_index("p_aos_vec_v_assign_to_aos",
        "M", M);
      current_statement__ = 93;
      stan::math::validate_non_negative_index("p_aos_vec_v_tp_fails_func",
        "M", M);
      current_statement__ = 94;
      stan::math::validate_non_negative_index("p_aos_loop_vec_v_uni_idx",
        "M", M);
      current_statement__ = 95;
      stan::math::validate_non_negative_index(
        "p_aos_fail_assign_from_top_idx", "M", M);
      current_statement__ = 96;
      stan::math::validate_non_negative_index("p_aos_loop_mat_uni_uni_idx",
        "N", N);
      current_statement__ = 97;
      stan::math::validate_non_negative_index("p_aos_loop_mat_uni_uni_idx",
        "M", M);
      current_statement__ = 98;
      stan::math::validate_non_negative_index("p_aos_mat", "N", N);
      current_statement__ = 99;
      stan::math::validate_non_negative_index("p_aos_mat", "M", M);
      current_statement__ = 100;
      stan::math::validate_non_negative_index(
        "p_aos_mat_pass_func_outer_single_indexed1", "N", N);
      current_statement__ = 101;
      stan::math::validate_non_negative_index(
        "p_aos_mat_pass_func_outer_single_indexed1", "M", M);
      current_statement__ = 102;
      stan::math::validate_non_negative_index(
        "p_aos_mat_pass_func_outer_single_indexed2", "N", N);
      current_statement__ = 103;
      stan::math::validate_non_negative_index(
        "p_aos_mat_pass_func_outer_single_indexed2", "M", M);
      current_statement__ = 104;
      stan::math::validate_non_negative_index("p_aos_mat_fail_uni_uni_idx1",
        "N", N);
      current_statement__ = 105;
      stan::math::validate_non_negative_index("p_aos_mat_fail_uni_uni_idx1",
        "M", M);
      current_statement__ = 106;
      stan::math::validate_non_negative_index("p_aos_mat_fail_uni_uni_idx2",
        "N", N);
      current_statement__ = 107;
      stan::math::validate_non_negative_index("p_aos_mat_fail_uni_uni_idx2",
        "M", M);
      current_statement__ = 108;
      stan::math::validate_non_negative_index("tp_aos_vec_v", "M", M);
      current_statement__ = 109;
      stan::math::validate_non_negative_index("tp_soa_single_idx_uninit",
        "M", M);
      current_statement__ = 110;
      stan::math::validate_non_negative_index("tp_aos_fail_func_vec_v", "M",
        M);
      current_statement__ = 111;
      stan::math::validate_non_negative_index(
        "tp_aos_fail_assign_from_top_idx", "M", M);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + M + (N * M) + (10 * N) + (N * M) + N + (N * M) + N +
      N + N + (N * M) + M + M + M + M + (N * M) + (N * M) + (N * M) + (N * M)
      + (N * M) + (N * M);
  }
  inline std::string model_name() const final {
    return "indexing_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = -fsoa --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "indexing_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> p_soa_vec_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 2;
      p_soa_vec_v = in__.template read<
                      Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_soa_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 3;
      p_soa_mat = in__.template read<
                    Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> p_soa_arr_vec_v =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(10,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 4;
      p_soa_arr_vec_v = in__.template read<
                          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(10,
                          N);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_soa_mat_uni_col_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 5;
      p_soa_mat_uni_col_idx = in__.template read<
                                Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M);
      Eigen::Matrix<local_scalar_t__,-1,1> p_soa_vec_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 6;
      p_soa_vec_uni_idx = in__.template read<
                            Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_soa_loop_mat_uni_col_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 7;
      p_soa_loop_mat_uni_col_idx = in__.template read<
                                     Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                     M);
      Eigen::Matrix<local_scalar_t__,1,-1> p_soa_lhs_loop_mul =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 8;
      p_soa_lhs_loop_mul = in__.template read<
                             Eigen::Matrix<local_scalar_t__,1,-1>>(N);
      Eigen::Matrix<local_scalar_t__,-1,1> p_soa_rhs_loop_mul =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 9;
      p_soa_rhs_loop_mul = in__.template read<
                             Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<local_scalar_t__,-1,1>
        p_soa_used_with_aos_in_excluded_fun =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 10;
      p_soa_used_with_aos_in_excluded_fun = in__.template read<
                                              Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<local_scalar_t__,-1,-1>
        p_soa_loop_mat_multi_uni_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 11;
      p_soa_loop_mat_multi_uni_uni_idx = in__.template read<
                                           Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                           M);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_vec_v_assign_to_aos =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 12;
      p_aos_vec_v_assign_to_aos = in__.template read<
                                    Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_vec_v_tp_fails_func =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 13;
      p_aos_vec_v_tp_fails_func = in__.template read<
                                    Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_loop_vec_v_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 14;
      p_aos_loop_vec_v_uni_idx = in__.template read<
                                   Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_fail_assign_from_top_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 15;
      p_aos_fail_assign_from_top_idx = in__.template read<
                                         Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_loop_mat_uni_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 16;
      p_aos_loop_mat_uni_uni_idx = in__.template read<
                                     Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                     M);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 17;
      p_aos_mat = in__.template read<
                    Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M);
      Eigen::Matrix<local_scalar_t__,-1,-1>
        p_aos_mat_pass_func_outer_single_indexed1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 18;
      p_aos_mat_pass_func_outer_single_indexed1 = in__.template read<
                                                    Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                                    M);
      Eigen::Matrix<local_scalar_t__,-1,-1>
        p_aos_mat_pass_func_outer_single_indexed2 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 19;
      p_aos_mat_pass_func_outer_single_indexed2 = in__.template read<
                                                    Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                                    M);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_mat_fail_uni_uni_idx1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 20;
      p_aos_mat_fail_uni_uni_idx1 = in__.template read<
                                      Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                      M);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_mat_fail_uni_uni_idx2 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 21;
      p_aos_mat_fail_uni_uni_idx2 = in__.template read<
                                      Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                      M);
      local_scalar_t__ tp_real_from_aos = DUMMY_VAR__;
      current_statement__ = 22;
      tp_real_from_aos = stan::model::rvalue(p_soa_vec_v, "p_soa_vec_v",
                           stan::model::index_uni(1));
      Eigen::Matrix<local_scalar_t__,-1,1> tp_aos_vec_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 23;
      stan::model::assign(tp_aos_vec_v,
        udf_fun(p_aos_vec_v_assign_to_aos, pstream__),
        "assigning variable tp_aos_vec_v");
      Eigen::Matrix<local_scalar_t__,-1,1> tp_soa_single_idx_uninit =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 27;
      stan::model::assign(tp_soa_single_idx_uninit, tp_real_from_aos,
        "assigning variable tp_soa_single_idx_uninit",
        stan::model::index_uni(1));
      current_statement__ = 28;
      stan::model::assign(tp_soa_single_idx_uninit,
        stan::math::rep_vector(tp_real_from_aos, (M - 1)),
        "assigning variable tp_soa_single_idx_uninit",
        stan::model::index_min_max(2, M));
      Eigen::Matrix<local_scalar_t__,-1,1> tp_aos_fail_func_vec_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 25;
      stan::model::assign(tp_aos_fail_func_vec_v, p_aos_vec_v_tp_fails_func,
        "assigning variable tp_aos_fail_func_vec_v");
      current_statement__ = 29;
      stan::model::assign(tp_aos_fail_func_vec_v,
        stan::model::rvalue(p_soa_vec_v, "p_soa_vec_v",
          stan::model::index_uni(1)),
        "assigning variable tp_aos_fail_func_vec_v",
        stan::model::index_uni(1));
      Eigen::Matrix<local_scalar_t__,-1,1> tp_aos_fail_assign_from_top_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 30;
      stan::model::assign(tp_aos_fail_assign_from_top_idx,
        stan::model::rvalue(p_aos_fail_assign_from_top_idx,
          "p_aos_fail_assign_from_top_idx", stan::model::index_min(1)),
        "assigning variable tp_aos_fail_assign_from_top_idx",
        stan::model::index_min(1));
      {
        current_statement__ = 31;
        stan::math::validate_non_negative_index(
          "tp_soa_used_with_aos_in_excluded_fun", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1>
          tp_soa_used_with_aos_in_excluded_fun =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 32;
        stan::model::assign(tp_soa_used_with_aos_in_excluded_fun,
          stan::math::multiply(p_soa_used_with_aos_in_excluded_fun,
            stan::math::size(tp_aos_vec_v)),
          "assigning variable tp_soa_used_with_aos_in_excluded_fun");
        current_statement__ = 33;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::add(alpha,
                           stan::math::multiply(dat_x,
                             stan::math::add(p_soa_vec_v,
                               tp_soa_used_with_aos_in_excluded_fun))), 1.0));
        current_statement__ = 34;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::add(alpha,
                           stan::math::multiply(dat_x, p_soa_vec_v)), 1.0));
        current_statement__ = 35;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(dat_x,
                           stan::model::rvalue(p_soa_mat_uni_col_idx,
                             "p_soa_mat_uni_col_idx",
                             stan::model::index_omni(),
                             stan::model::index_uni(N))), 1.0));
        current_statement__ = 36;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(dat_x,
                           stan::model::rvalue(p_soa_mat_uni_col_idx,
                             "p_soa_mat_uni_col_idx",
                             stan::model::index_omni(),
                             stan::model::index_uni(N))),
                         stan::model::rvalue(p_soa_vec_uni_idx,
                           "p_soa_vec_uni_idx", stan::model::index_uni(N))));
        current_statement__ = 37;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(dat_x,
                           udf_fun(tp_aos_fail_func_vec_v, pstream__)),
                         stan::model::rvalue(p_soa_vec_uni_idx,
                           "p_soa_vec_uni_idx", stan::model::index_uni(N))));
        current_statement__ = 38;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(p_soa_mat,
                           udf_fun(tp_aos_fail_func_vec_v, pstream__)),
                         stan::model::rvalue(p_soa_vec_uni_idx,
                           "p_soa_vec_uni_idx", stan::model::index_uni(N))));
        current_statement__ = 39;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(p_soa_mat,
                           udf_fun(tp_aos_fail_assign_from_top_idx, pstream__)),
                         stan::model::rvalue(p_soa_vec_uni_idx,
                           "p_soa_vec_uni_idx", stan::model::index_uni(N))));
        current_statement__ = 40;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(p_soa_mat,
                           udf_fun(
                             stan::math::multiply(p_aos_mat,
                               tp_aos_fail_func_vec_v), pstream__)),
                         stan::model::rvalue(p_soa_vec_uni_idx,
                           "p_soa_vec_uni_idx", stan::model::index_uni(N))));
        current_statement__ = 41;
        stan::math::validate_non_negative_index("tp_soa_single_assign", "N",
          N);
        Eigen::Matrix<local_scalar_t__,-1,1> tp_soa_single_assign =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 43;
        stan::model::assign(tp_soa_single_assign, 2.0,
          "assigning variable tp_soa_single_assign",
          stan::model::index_uni(1));
        current_statement__ = 44;
        stan::math::validate_non_negative_index(
          "tp_soa_single_assign_from_soa", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> tp_soa_single_assign_from_soa =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 46;
        stan::model::assign(tp_soa_single_assign_from_soa,
          stan::math::multiply(p_soa_lhs_loop_mul, p_soa_rhs_loop_mul),
          "assigning variable tp_soa_single_assign_from_soa",
          stan::model::index_uni(2));
        current_statement__ = 57;
        for (int i = 1; i <= 10; ++i) {
          current_statement__ = 47;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(dat_x,
                             stan::model::rvalue(p_soa_arr_vec_v,
                               "p_soa_arr_vec_v", stan::model::index_uni(i))),
                           1.0));
          current_statement__ = 48;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(dat_x,
                             stan::model::rvalue(p_soa_loop_mat_uni_col_idx,
                               "p_soa_loop_mat_uni_col_idx",
                               stan::model::index_omni(),
                               stan::model::index_uni(i))), 1.0));
          current_statement__ = 49;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(
                             stan::model::rvalue(p_soa_loop_mat_uni_col_idx,
                               "p_soa_loop_mat_uni_col_idx",
                               stan::model::index_uni(i),
                               stan::model::index_omni()), dat_x), 1.0));
          current_statement__ = 50;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(dat_x,
                             stan::math::transpose(
                               stan::model::rvalue(
                                 p_soa_loop_mat_uni_col_idx,
                                 "p_soa_loop_mat_uni_col_idx",
                                 stan::model::index_uni(i),
                                 stan::model::index_omni()))), 1.0));
          current_statement__ = 51;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(dat_x,
                             stan::model::rvalue(p_soa_loop_mat_uni_col_idx,
                               "p_soa_loop_mat_uni_col_idx",
                               stan::model::index_min_max(1, N),
                               stan::model::index_uni(1))), 1.0));
          current_statement__ = 52;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(dat_x,
                             stan::math::transpose(
                               stan::model::rvalue(
                                 p_soa_loop_mat_uni_col_idx,
                                 "p_soa_loop_mat_uni_col_idx",
                                 stan::model::index_uni(i)))), 1.0));
          current_statement__ = 53;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(dat_x,
                             stan::math::transpose(
                               stan::model::rvalue(
                                 p_soa_loop_mat_multi_uni_uni_idx,
                                 "p_soa_loop_mat_multi_uni_uni_idx",
                                 stan::model::index_uni(
                                   stan::model::rvalue(idx_tester,
                                     "idx_tester", stan::model::index_uni(i))),
                                 stan::model::index_omni()))), 1.0));
          current_statement__ = 54;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(
                             stan::model::rvalue(dat_x, "dat_x",
                               stan::model::index_omni(),
                               stan::model::index_uni(i)),
                             stan::model::rvalue(
                               stan::math::transpose(
                                 stan::math::multiply(
                                   p_aos_mat_pass_func_outer_single_indexed1,
                                   p_aos_mat_pass_func_outer_single_indexed2)),
                               "transpose(multiply(p_aos_mat_pass_func_outer_single_indexed1,\n                   p_aos_mat_pass_func_outer_single_indexed2))",
                               stan::model::index_uni(mask_fun(i, pstream__)),
                               stan::model::index_uni(mask_fun(i, pstream__)))),
                           1.0));
          current_statement__ = 55;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(
                             stan::model::rvalue(dat_x, "dat_x",
                               stan::model::index_omni(),
                               stan::model::index_uni(i)),
                             (stan::model::rvalue(
                                p_aos_mat_fail_uni_uni_idx1,
                                "p_aos_mat_fail_uni_uni_idx1",
                                stan::model::index_uni(i),
                                stan::model::index_uni(i)) *
                             stan::model::rvalue(p_aos_mat_fail_uni_uni_idx2,
                               "p_aos_mat_fail_uni_uni_idx2",
                               stan::model::index_uni(i),
                               stan::model::index_uni(i)))), 1.0));
        }
        current_statement__ = 58;
        stan::math::validate_non_negative_index("tp_aos_loop_vec_v_uni_idx",
          "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> tp_aos_loop_vec_v_uni_idx =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 60;
        stan::math::validate_non_negative_index(
          "tp_aos_loop_vec_v_multi_uni_idx", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1>
          tp_aos_loop_vec_v_multi_uni_idx =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 68;
        for (int i = 1; i <= N; ++i) {
          current_statement__ = 62;
          stan::model::assign(tp_aos_loop_vec_v_uni_idx,
            stan::math::multiply(p_soa_lhs_loop_mul, p_soa_rhs_loop_mul),
            "assigning variable tp_aos_loop_vec_v_uni_idx",
            stan::model::index_uni(i));
          current_statement__ = 63;
          stan::model::assign(tp_aos_loop_vec_v_multi_uni_idx,
            stan::math::multiply(p_soa_lhs_loop_mul, p_soa_rhs_loop_mul),
            "assigning variable tp_aos_loop_vec_v_multi_uni_idx",
            stan::model::index_uni(
              stan::model::rvalue(idx_tester, "idx_tester",
                stan::model::index_uni(i))));
          current_statement__ = 64;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(
                             stan::model::rvalue(dat_x, "dat_x",
                               stan::model::index_omni(),
                               stan::model::index_uni(i)),
                             stan::model::rvalue(p_aos_loop_vec_v_uni_idx,
                               "p_aos_loop_vec_v_uni_idx",
                               stan::model::index_uni(i))), 1.0));
          current_statement__ = 65;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(
                             stan::model::rvalue(dat_x, "dat_x",
                               stan::model::index_omni(),
                               stan::model::index_uni(i)),
                             stan::model::rvalue(p_aos_loop_mat_uni_uni_idx,
                               "p_aos_loop_mat_uni_uni_idx",
                               stan::model::index_uni(i),
                               stan::model::index_uni(i))), 1.0));
          current_statement__ = 66;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::model::rvalue(dat_x, "dat_x",
                             stan::model::index_omni(),
                             stan::model::index_uni(i)),
                           (stan::model::rvalue(p_aos_mat_fail_uni_uni_idx1,
                              "p_aos_mat_fail_uni_uni_idx1",
                              stan::model::index_uni(i),
                              stan::model::index_uni(i)) *
                           stan::model::rvalue(p_aos_mat_fail_uni_uni_idx2,
                             "p_aos_mat_fail_uni_uni_idx2",
                             stan::model::index_uni(i),
                             stan::model::index_uni(i)))));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "indexing_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      stan::math::var_value<Eigen::Matrix<double,-1,1>> p_soa_vec_v =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(M,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 2;
      p_soa_vec_v = in__.template read<
                      stan::math::var_value<Eigen::Matrix<double,-1,1>>>(M);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> p_soa_mat =
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(N,
                                                             M,
                                                             std::numeric_limits<double>::quiet_NaN(
                                                               )));
      current_statement__ = 3;
      p_soa_mat = in__.template read<
                    stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(N, M);
      std::vector<stan::math::var_value<Eigen::Matrix<double,-1,1>>>
        p_soa_arr_vec_v =
        std::vector<stan::math::var_value<Eigen::Matrix<double,-1,1>>>(10,
          stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                ))));
      current_statement__ = 4;
      p_soa_arr_vec_v = in__.template read<
                          std::vector<
                            stan::math::var_value<Eigen::Matrix<double,-1,1>>>>(10,
                          N);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>>
        p_soa_mat_uni_col_idx =
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(N,
                                                             M,
                                                             std::numeric_limits<double>::quiet_NaN(
                                                               )));
      current_statement__ = 5;
      p_soa_mat_uni_col_idx = in__.template read<
                                stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(N,
                                M);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> p_soa_vec_uni_idx =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 6;
      p_soa_vec_uni_idx = in__.template read<
                            stan::math::var_value<Eigen::Matrix<double,-1,1>>>(N);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>>
        p_soa_loop_mat_uni_col_idx =
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(N,
                                                             M,
                                                             std::numeric_limits<double>::quiet_NaN(
                                                               )));
      current_statement__ = 7;
      p_soa_loop_mat_uni_col_idx = in__.template read<
                                     stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(N,
                                     M);
      stan::math::var_value<Eigen::Matrix<double,1,-1>> p_soa_lhs_loop_mul =
        stan::math::var_value<Eigen::Matrix<double,1,-1>>(Eigen::Matrix<double,1,-1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 8;
      p_soa_lhs_loop_mul = in__.template read<
                             stan::math::var_value<Eigen::Matrix<double,1,-1>>>(N);
      stan::math::var_value<Eigen::Matrix<double,-1,1>> p_soa_rhs_loop_mul =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 9;
      p_soa_rhs_loop_mul = in__.template read<
                             stan::math::var_value<Eigen::Matrix<double,-1,1>>>(N);
      stan::math::var_value<Eigen::Matrix<double,-1,1>>
        p_soa_used_with_aos_in_excluded_fun =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 10;
      p_soa_used_with_aos_in_excluded_fun = in__.template read<
                                              stan::math::var_value<Eigen::Matrix<double,-1,1>>>(N);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>>
        p_soa_loop_mat_multi_uni_uni_idx =
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(N,
                                                             M,
                                                             std::numeric_limits<double>::quiet_NaN(
                                                               )));
      current_statement__ = 11;
      p_soa_loop_mat_multi_uni_uni_idx = in__.template read<
                                           stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(N,
                                           M);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_vec_v_assign_to_aos =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 12;
      p_aos_vec_v_assign_to_aos = in__.template read<
                                    Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_vec_v_tp_fails_func =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 13;
      p_aos_vec_v_tp_fails_func = in__.template read<
                                    Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_loop_vec_v_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 14;
      p_aos_loop_vec_v_uni_idx = in__.template read<
                                   Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_fail_assign_from_top_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 15;
      p_aos_fail_assign_from_top_idx = in__.template read<
                                         Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_loop_mat_uni_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 16;
      p_aos_loop_mat_uni_uni_idx = in__.template read<
                                     Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                     M);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 17;
      p_aos_mat = in__.template read<
                    Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M);
      Eigen::Matrix<local_scalar_t__,-1,-1>
        p_aos_mat_pass_func_outer_single_indexed1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 18;
      p_aos_mat_pass_func_outer_single_indexed1 = in__.template read<
                                                    Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                                    M);
      Eigen::Matrix<local_scalar_t__,-1,-1>
        p_aos_mat_pass_func_outer_single_indexed2 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 19;
      p_aos_mat_pass_func_outer_single_indexed2 = in__.template read<
                                                    Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                                    M);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_mat_fail_uni_uni_idx1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 20;
      p_aos_mat_fail_uni_uni_idx1 = in__.template read<
                                      Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                      M);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_mat_fail_uni_uni_idx2 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 21;
      p_aos_mat_fail_uni_uni_idx2 = in__.template read<
                                      Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                      M);
      local_scalar_t__ tp_real_from_aos = DUMMY_VAR__;
      current_statement__ = 22;
      tp_real_from_aos = stan::model::rvalue(p_soa_vec_v, "p_soa_vec_v",
                           stan::model::index_uni(1));
      Eigen::Matrix<local_scalar_t__,-1,1> tp_aos_vec_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 23;
      stan::model::assign(tp_aos_vec_v,
        udf_fun(p_aos_vec_v_assign_to_aos, pstream__),
        "assigning variable tp_aos_vec_v");
      stan::math::var_value<Eigen::Matrix<double,-1,1>>
        tp_soa_single_idx_uninit =
        stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(M,
                                                            std::numeric_limits<double>::quiet_NaN(
                                                              )));
      current_statement__ = 27;
      stan::model::assign(tp_soa_single_idx_uninit, tp_real_from_aos,
        "assigning variable tp_soa_single_idx_uninit",
        stan::model::index_uni(1));
      current_statement__ = 28;
      stan::model::assign(tp_soa_single_idx_uninit,
        stan::math::rep_vector<
          stan::math::var_value<Eigen::Matrix<double,-1,1>>>(
          tp_real_from_aos, (M - 1)),
        "assigning variable tp_soa_single_idx_uninit",
        stan::model::index_min_max(2, M));
      Eigen::Matrix<local_scalar_t__,-1,1> tp_aos_fail_func_vec_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 25;
      stan::model::assign(tp_aos_fail_func_vec_v, p_aos_vec_v_tp_fails_func,
        "assigning variable tp_aos_fail_func_vec_v");
      current_statement__ = 29;
      stan::model::assign(tp_aos_fail_func_vec_v,
        stan::model::rvalue(p_soa_vec_v, "p_soa_vec_v",
          stan::model::index_uni(1)),
        "assigning variable tp_aos_fail_func_vec_v",
        stan::model::index_uni(1));
      Eigen::Matrix<local_scalar_t__,-1,1> tp_aos_fail_assign_from_top_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 30;
      stan::model::assign(tp_aos_fail_assign_from_top_idx,
        stan::model::rvalue(p_aos_fail_assign_from_top_idx,
          "p_aos_fail_assign_from_top_idx", stan::model::index_min(1)),
        "assigning variable tp_aos_fail_assign_from_top_idx",
        stan::model::index_min(1));
      {
        current_statement__ = 31;
        stan::math::validate_non_negative_index(
          "tp_soa_used_with_aos_in_excluded_fun", "N", N);
        stan::math::var_value<Eigen::Matrix<double,-1,1>>
          tp_soa_used_with_aos_in_excluded_fun =
          stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                )));
        current_statement__ = 32;
        stan::model::assign(tp_soa_used_with_aos_in_excluded_fun,
          stan::math::multiply(p_soa_used_with_aos_in_excluded_fun,
            stan::math::size(tp_aos_vec_v)),
          "assigning variable tp_soa_used_with_aos_in_excluded_fun");
        current_statement__ = 33;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::add(alpha,
                           stan::math::multiply(dat_x,
                             stan::math::add(p_soa_vec_v,
                               tp_soa_used_with_aos_in_excluded_fun))), 1.0));
        current_statement__ = 34;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::add(alpha,
                           stan::math::multiply(dat_x, p_soa_vec_v)), 1.0));
        current_statement__ = 35;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(dat_x,
                           stan::model::rvalue(p_soa_mat_uni_col_idx,
                             "p_soa_mat_uni_col_idx",
                             stan::model::index_omni(),
                             stan::model::index_uni(N))), 1.0));
        current_statement__ = 36;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(dat_x,
                           stan::model::rvalue(p_soa_mat_uni_col_idx,
                             "p_soa_mat_uni_col_idx",
                             stan::model::index_omni(),
                             stan::model::index_uni(N))),
                         stan::model::rvalue(p_soa_vec_uni_idx,
                           "p_soa_vec_uni_idx", stan::model::index_uni(N))));
        current_statement__ = 37;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(dat_x,
                           udf_fun(tp_aos_fail_func_vec_v, pstream__)),
                         stan::model::rvalue(p_soa_vec_uni_idx,
                           "p_soa_vec_uni_idx", stan::model::index_uni(N))));
        current_statement__ = 38;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(p_soa_mat,
                           udf_fun(tp_aos_fail_func_vec_v, pstream__)),
                         stan::model::rvalue(p_soa_vec_uni_idx,
                           "p_soa_vec_uni_idx", stan::model::index_uni(N))));
        current_statement__ = 39;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(p_soa_mat,
                           udf_fun(tp_aos_fail_assign_from_top_idx, pstream__)),
                         stan::model::rvalue(p_soa_vec_uni_idx,
                           "p_soa_vec_uni_idx", stan::model::index_uni(N))));
        current_statement__ = 40;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                         stan::math::multiply(p_soa_mat,
                           udf_fun(
                             stan::math::multiply(p_aos_mat,
                               tp_aos_fail_func_vec_v), pstream__)),
                         stan::model::rvalue(p_soa_vec_uni_idx,
                           "p_soa_vec_uni_idx", stan::model::index_uni(N))));
        current_statement__ = 41;
        stan::math::validate_non_negative_index("tp_soa_single_assign", "N",
          N);
        stan::math::var_value<Eigen::Matrix<double,-1,1>>
          tp_soa_single_assign =
          stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                )));
        current_statement__ = 43;
        stan::model::assign(tp_soa_single_assign, 2.0,
          "assigning variable tp_soa_single_assign",
          stan::model::index_uni(1));
        current_statement__ = 44;
        stan::math::validate_non_negative_index(
          "tp_soa_single_assign_from_soa", "N", N);
        stan::math::var_value<Eigen::Matrix<double,-1,1>>
          tp_soa_single_assign_from_soa =
          stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                )));
        current_statement__ = 46;
        stan::model::assign(tp_soa_single_assign_from_soa,
          stan::math::multiply(p_soa_lhs_loop_mul, p_soa_rhs_loop_mul),
          "assigning variable tp_soa_single_assign_from_soa",
          stan::model::index_uni(2));
        current_statement__ = 57;
        for (int i = 1; i <= 10; ++i) {
          current_statement__ = 47;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(dat_x,
                             stan::model::rvalue(p_soa_arr_vec_v,
                               "p_soa_arr_vec_v", stan::model::index_uni(i))),
                           1.0));
          current_statement__ = 48;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(dat_x,
                             stan::model::rvalue(p_soa_loop_mat_uni_col_idx,
                               "p_soa_loop_mat_uni_col_idx",
                               stan::model::index_omni(),
                               stan::model::index_uni(i))), 1.0));
          current_statement__ = 49;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(
                             stan::model::rvalue(p_soa_loop_mat_uni_col_idx,
                               "p_soa_loop_mat_uni_col_idx",
                               stan::model::index_uni(i),
                               stan::model::index_omni()), dat_x), 1.0));
          current_statement__ = 50;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(dat_x,
                             stan::math::transpose(
                               stan::model::rvalue(
                                 p_soa_loop_mat_uni_col_idx,
                                 "p_soa_loop_mat_uni_col_idx",
                                 stan::model::index_uni(i),
                                 stan::model::index_omni()))), 1.0));
          current_statement__ = 51;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(dat_x,
                             stan::model::rvalue(p_soa_loop_mat_uni_col_idx,
                               "p_soa_loop_mat_uni_col_idx",
                               stan::model::index_min_max(1, N),
                               stan::model::index_uni(1))), 1.0));
          current_statement__ = 52;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(dat_x,
                             stan::math::transpose(
                               stan::model::rvalue(
                                 p_soa_loop_mat_uni_col_idx,
                                 "p_soa_loop_mat_uni_col_idx",
                                 stan::model::index_uni(i)))), 1.0));
          current_statement__ = 53;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(dat_x,
                             stan::math::transpose(
                               stan::model::rvalue(
                                 p_soa_loop_mat_multi_uni_uni_idx,
                                 "p_soa_loop_mat_multi_uni_uni_idx",
                                 stan::model::index_uni(
                                   stan::model::rvalue(idx_tester,
                                     "idx_tester", stan::model::index_uni(i))),
                                 stan::model::index_omni()))), 1.0));
          current_statement__ = 54;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(
                             stan::model::rvalue(dat_x, "dat_x",
                               stan::model::index_omni(),
                               stan::model::index_uni(i)),
                             stan::model::rvalue(
                               stan::math::transpose(
                                 stan::math::multiply(
                                   p_aos_mat_pass_func_outer_single_indexed1,
                                   p_aos_mat_pass_func_outer_single_indexed2)),
                               "transpose(multiply(p_aos_mat_pass_func_outer_single_indexed1,\n                   p_aos_mat_pass_func_outer_single_indexed2))",
                               stan::model::index_uni(mask_fun(i, pstream__)),
                               stan::model::index_uni(mask_fun(i, pstream__)))),
                           1.0));
          current_statement__ = 55;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(
                             stan::model::rvalue(dat_x, "dat_x",
                               stan::model::index_omni(),
                               stan::model::index_uni(i)),
                             (stan::model::rvalue(
                                p_aos_mat_fail_uni_uni_idx1,
                                "p_aos_mat_fail_uni_uni_idx1",
                                stan::model::index_uni(i),
                                stan::model::index_uni(i)) *
                             stan::model::rvalue(p_aos_mat_fail_uni_uni_idx2,
                               "p_aos_mat_fail_uni_uni_idx2",
                               stan::model::index_uni(i),
                               stan::model::index_uni(i)))), 1.0));
        }
        current_statement__ = 58;
        stan::math::validate_non_negative_index("tp_aos_loop_vec_v_uni_idx",
          "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1> tp_aos_loop_vec_v_uni_idx =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 60;
        stan::math::validate_non_negative_index(
          "tp_aos_loop_vec_v_multi_uni_idx", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1>
          tp_aos_loop_vec_v_multi_uni_idx =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 68;
        for (int i = 1; i <= N; ++i) {
          current_statement__ = 62;
          stan::model::assign(tp_aos_loop_vec_v_uni_idx,
            stan::math::multiply(p_soa_lhs_loop_mul, p_soa_rhs_loop_mul),
            "assigning variable tp_aos_loop_vec_v_uni_idx",
            stan::model::index_uni(i));
          current_statement__ = 63;
          stan::model::assign(tp_aos_loop_vec_v_multi_uni_idx,
            stan::math::multiply(p_soa_lhs_loop_mul, p_soa_rhs_loop_mul),
            "assigning variable tp_aos_loop_vec_v_multi_uni_idx",
            stan::model::index_uni(
              stan::model::rvalue(idx_tester, "idx_tester",
                stan::model::index_uni(i))));
          current_statement__ = 64;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(
                             stan::model::rvalue(dat_x, "dat_x",
                               stan::model::index_omni(),
                               stan::model::index_uni(i)),
                             stan::model::rvalue(p_aos_loop_vec_v_uni_idx,
                               "p_aos_loop_vec_v_uni_idx",
                               stan::model::index_uni(i))), 1.0));
          current_statement__ = 65;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::math::multiply(
                             stan::model::rvalue(dat_x, "dat_x",
                               stan::model::index_omni(),
                               stan::model::index_uni(i)),
                             stan::model::rvalue(p_aos_loop_mat_uni_uni_idx,
                               "p_aos_loop_mat_uni_uni_idx",
                               stan::model::index_uni(i),
                               stan::model::index_uni(i))), 1.0));
          current_statement__ = 66;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(y,
                           stan::model::rvalue(dat_x, "dat_x",
                             stan::model::index_omni(),
                             stan::model::index_uni(i)),
                           (stan::model::rvalue(p_aos_mat_fail_uni_uni_idx1,
                              "p_aos_mat_fail_uni_uni_idx1",
                              stan::model::index_uni(i),
                              stan::model::index_uni(i)) *
                           stan::model::rvalue(p_aos_mat_fail_uni_uni_idx2,
                             "p_aos_mat_fail_uni_uni_idx2",
                             stan::model::index_uni(i),
                             stan::model::index_uni(i)))));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "indexing_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double alpha = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,1> p_soa_vec_v =
        Eigen::Matrix<double,-1,1>::Constant(M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      p_soa_vec_v = in__.template read<
                      Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<double,-1,-1> p_soa_mat =
        Eigen::Matrix<double,-1,-1>::Constant(N, M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      p_soa_mat = in__.template read<
                    Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M);
      std::vector<Eigen::Matrix<double,-1,1>> p_soa_arr_vec_v =
        std::vector<Eigen::Matrix<double,-1,1>>(10,
          Eigen::Matrix<double,-1,1>::Constant(N,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 4;
      p_soa_arr_vec_v = in__.template read<
                          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(10,
                          N);
      Eigen::Matrix<double,-1,-1> p_soa_mat_uni_col_idx =
        Eigen::Matrix<double,-1,-1>::Constant(N, M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      p_soa_mat_uni_col_idx = in__.template read<
                                Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M);
      Eigen::Matrix<double,-1,1> p_soa_vec_uni_idx =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 6;
      p_soa_vec_uni_idx = in__.template read<
                            Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<double,-1,-1> p_soa_loop_mat_uni_col_idx =
        Eigen::Matrix<double,-1,-1>::Constant(N, M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 7;
      p_soa_loop_mat_uni_col_idx = in__.template read<
                                     Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                     M);
      Eigen::Matrix<double,1,-1> p_soa_lhs_loop_mul =
        Eigen::Matrix<double,1,-1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 8;
      p_soa_lhs_loop_mul = in__.template read<
                             Eigen::Matrix<local_scalar_t__,1,-1>>(N);
      Eigen::Matrix<double,-1,1> p_soa_rhs_loop_mul =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 9;
      p_soa_rhs_loop_mul = in__.template read<
                             Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<double,-1,1> p_soa_used_with_aos_in_excluded_fun =
        Eigen::Matrix<double,-1,1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 10;
      p_soa_used_with_aos_in_excluded_fun = in__.template read<
                                              Eigen::Matrix<local_scalar_t__,-1,1>>(N);
      Eigen::Matrix<double,-1,-1> p_soa_loop_mat_multi_uni_uni_idx =
        Eigen::Matrix<double,-1,-1>::Constant(N, M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 11;
      p_soa_loop_mat_multi_uni_uni_idx = in__.template read<
                                           Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                           M);
      Eigen::Matrix<double,-1,1> p_aos_vec_v_assign_to_aos =
        Eigen::Matrix<double,-1,1>::Constant(M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 12;
      p_aos_vec_v_assign_to_aos = in__.template read<
                                    Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<double,-1,1> p_aos_vec_v_tp_fails_func =
        Eigen::Matrix<double,-1,1>::Constant(M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 13;
      p_aos_vec_v_tp_fails_func = in__.template read<
                                    Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<double,-1,1> p_aos_loop_vec_v_uni_idx =
        Eigen::Matrix<double,-1,1>::Constant(M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 14;
      p_aos_loop_vec_v_uni_idx = in__.template read<
                                   Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<double,-1,1> p_aos_fail_assign_from_top_idx =
        Eigen::Matrix<double,-1,1>::Constant(M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 15;
      p_aos_fail_assign_from_top_idx = in__.template read<
                                         Eigen::Matrix<local_scalar_t__,-1,1>>(M);
      Eigen::Matrix<double,-1,-1> p_aos_loop_mat_uni_uni_idx =
        Eigen::Matrix<double,-1,-1>::Constant(N, M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 16;
      p_aos_loop_mat_uni_uni_idx = in__.template read<
                                     Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                     M);
      Eigen::Matrix<double,-1,-1> p_aos_mat =
        Eigen::Matrix<double,-1,-1>::Constant(N, M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 17;
      p_aos_mat = in__.template read<
                    Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M);
      Eigen::Matrix<double,-1,-1> p_aos_mat_pass_func_outer_single_indexed1 =
        Eigen::Matrix<double,-1,-1>::Constant(N, M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 18;
      p_aos_mat_pass_func_outer_single_indexed1 = in__.template read<
                                                    Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                                    M);
      Eigen::Matrix<double,-1,-1> p_aos_mat_pass_func_outer_single_indexed2 =
        Eigen::Matrix<double,-1,-1>::Constant(N, M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 19;
      p_aos_mat_pass_func_outer_single_indexed2 = in__.template read<
                                                    Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                                    M);
      Eigen::Matrix<double,-1,-1> p_aos_mat_fail_uni_uni_idx1 =
        Eigen::Matrix<double,-1,-1>::Constant(N, M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 20;
      p_aos_mat_fail_uni_uni_idx1 = in__.template read<
                                      Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                      M);
      Eigen::Matrix<double,-1,-1> p_aos_mat_fail_uni_uni_idx2 =
        Eigen::Matrix<double,-1,-1>::Constant(N, M,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 21;
      p_aos_mat_fail_uni_uni_idx2 = in__.template read<
                                      Eigen::Matrix<local_scalar_t__,-1,-1>>(N,
                                      M);
      double tp_real_from_aos = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double,-1,1> tp_aos_vec_v =
        Eigen::Matrix<double,-1,1>::Constant(M,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> tp_soa_single_idx_uninit =
        Eigen::Matrix<double,-1,1>::Constant(M,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> tp_aos_fail_func_vec_v =
        Eigen::Matrix<double,-1,1>::Constant(M,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> tp_aos_fail_assign_from_top_idx =
        Eigen::Matrix<double,-1,1>::Constant(M,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(alpha);
      out__.write(p_soa_vec_v);
      out__.write(p_soa_mat);
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          out__.write(p_soa_arr_vec_v[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      out__.write(p_soa_mat_uni_col_idx);
      out__.write(p_soa_vec_uni_idx);
      out__.write(p_soa_loop_mat_uni_col_idx);
      out__.write(p_soa_lhs_loop_mul);
      out__.write(p_soa_rhs_loop_mul);
      out__.write(p_soa_used_with_aos_in_excluded_fun);
      out__.write(p_soa_loop_mat_multi_uni_uni_idx);
      out__.write(p_aos_vec_v_assign_to_aos);
      out__.write(p_aos_vec_v_tp_fails_func);
      out__.write(p_aos_loop_vec_v_uni_idx);
      out__.write(p_aos_fail_assign_from_top_idx);
      out__.write(p_aos_loop_mat_uni_uni_idx);
      out__.write(p_aos_mat);
      out__.write(p_aos_mat_pass_func_outer_single_indexed1);
      out__.write(p_aos_mat_pass_func_outer_single_indexed2);
      out__.write(p_aos_mat_fail_uni_uni_idx1);
      out__.write(p_aos_mat_fail_uni_uni_idx2);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 22;
      tp_real_from_aos = stan::model::rvalue(p_soa_vec_v, "p_soa_vec_v",
                           stan::model::index_uni(1));
      current_statement__ = 23;
      stan::model::assign(tp_aos_vec_v,
        udf_fun(p_aos_vec_v_assign_to_aos, pstream__),
        "assigning variable tp_aos_vec_v");
      current_statement__ = 27;
      stan::model::assign(tp_soa_single_idx_uninit, tp_real_from_aos,
        "assigning variable tp_soa_single_idx_uninit",
        stan::model::index_uni(1));
      current_statement__ = 28;
      stan::model::assign(tp_soa_single_idx_uninit,
        stan::math::rep_vector(tp_real_from_aos, (M - 1)),
        "assigning variable tp_soa_single_idx_uninit",
        stan::model::index_min_max(2, M));
      current_statement__ = 25;
      stan::model::assign(tp_aos_fail_func_vec_v, p_aos_vec_v_tp_fails_func,
        "assigning variable tp_aos_fail_func_vec_v");
      current_statement__ = 29;
      stan::model::assign(tp_aos_fail_func_vec_v,
        stan::model::rvalue(p_soa_vec_v, "p_soa_vec_v",
          stan::model::index_uni(1)),
        "assigning variable tp_aos_fail_func_vec_v",
        stan::model::index_uni(1));
      current_statement__ = 30;
      stan::model::assign(tp_aos_fail_assign_from_top_idx,
        stan::model::rvalue(p_aos_fail_assign_from_top_idx,
          "p_aos_fail_assign_from_top_idx", stan::model::index_min(1)),
        "assigning variable tp_aos_fail_assign_from_top_idx",
        stan::model::index_min(1));
      if (emit_transformed_parameters__) {
        out__.write(tp_real_from_aos);
        out__.write(tp_aos_vec_v);
        out__.write(tp_soa_single_idx_uninit);
        out__.write(tp_aos_fail_func_vec_v);
        out__.write(tp_aos_fail_assign_from_top_idx);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.read<local_scalar_t__>();
      out__.write(alpha);
      Eigen::Matrix<local_scalar_t__,-1,1> p_soa_vec_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(p_soa_vec_v,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(M),
        "assigning variable p_soa_vec_v");
      out__.write(p_soa_vec_v);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_soa_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(p_soa_mat,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M),
        "assigning variable p_soa_mat");
      out__.write(p_soa_mat);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> p_soa_arr_vec_v =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(10,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          current_statement__ = 4;
          stan::model::assign(p_soa_arr_vec_v, in__.read<local_scalar_t__>(),
            "assigning variable p_soa_arr_vec_v",
            stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_soa_arr_vec_v);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_soa_mat_uni_col_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(p_soa_mat_uni_col_idx,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M),
        "assigning variable p_soa_mat_uni_col_idx");
      out__.write(p_soa_mat_uni_col_idx);
      Eigen::Matrix<local_scalar_t__,-1,1> p_soa_vec_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(p_soa_vec_uni_idx,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable p_soa_vec_uni_idx");
      out__.write(p_soa_vec_uni_idx);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_soa_loop_mat_uni_col_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(p_soa_loop_mat_uni_col_idx,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M),
        "assigning variable p_soa_loop_mat_uni_col_idx");
      out__.write(p_soa_loop_mat_uni_col_idx);
      Eigen::Matrix<local_scalar_t__,1,-1> p_soa_lhs_loop_mul =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(p_soa_lhs_loop_mul,
        in__.read<Eigen::Matrix<local_scalar_t__,1,-1>>(N),
        "assigning variable p_soa_lhs_loop_mul");
      out__.write(p_soa_lhs_loop_mul);
      Eigen::Matrix<local_scalar_t__,-1,1> p_soa_rhs_loop_mul =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 9;
      stan::model::assign(p_soa_rhs_loop_mul,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable p_soa_rhs_loop_mul");
      out__.write(p_soa_rhs_loop_mul);
      Eigen::Matrix<local_scalar_t__,-1,1>
        p_soa_used_with_aos_in_excluded_fun =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      current_statement__ = 10;
      stan::model::assign(p_soa_used_with_aos_in_excluded_fun,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(N),
        "assigning variable p_soa_used_with_aos_in_excluded_fun");
      out__.write(p_soa_used_with_aos_in_excluded_fun);
      Eigen::Matrix<local_scalar_t__,-1,-1>
        p_soa_loop_mat_multi_uni_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 11;
      stan::model::assign(p_soa_loop_mat_multi_uni_uni_idx,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M),
        "assigning variable p_soa_loop_mat_multi_uni_uni_idx");
      out__.write(p_soa_loop_mat_multi_uni_uni_idx);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_vec_v_assign_to_aos =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 12;
      stan::model::assign(p_aos_vec_v_assign_to_aos,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(M),
        "assigning variable p_aos_vec_v_assign_to_aos");
      out__.write(p_aos_vec_v_assign_to_aos);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_vec_v_tp_fails_func =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 13;
      stan::model::assign(p_aos_vec_v_tp_fails_func,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(M),
        "assigning variable p_aos_vec_v_tp_fails_func");
      out__.write(p_aos_vec_v_tp_fails_func);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_loop_vec_v_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 14;
      stan::model::assign(p_aos_loop_vec_v_uni_idx,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(M),
        "assigning variable p_aos_loop_vec_v_uni_idx");
      out__.write(p_aos_loop_vec_v_uni_idx);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_fail_assign_from_top_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 15;
      stan::model::assign(p_aos_fail_assign_from_top_idx,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(M),
        "assigning variable p_aos_fail_assign_from_top_idx");
      out__.write(p_aos_fail_assign_from_top_idx);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_loop_mat_uni_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 16;
      stan::model::assign(p_aos_loop_mat_uni_uni_idx,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M),
        "assigning variable p_aos_loop_mat_uni_uni_idx");
      out__.write(p_aos_loop_mat_uni_uni_idx);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 17;
      stan::model::assign(p_aos_mat,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M),
        "assigning variable p_aos_mat");
      out__.write(p_aos_mat);
      Eigen::Matrix<local_scalar_t__,-1,-1>
        p_aos_mat_pass_func_outer_single_indexed1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 18;
      stan::model::assign(p_aos_mat_pass_func_outer_single_indexed1,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M),
        "assigning variable p_aos_mat_pass_func_outer_single_indexed1");
      out__.write(p_aos_mat_pass_func_outer_single_indexed1);
      Eigen::Matrix<local_scalar_t__,-1,-1>
        p_aos_mat_pass_func_outer_single_indexed2 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 19;
      stan::model::assign(p_aos_mat_pass_func_outer_single_indexed2,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M),
        "assigning variable p_aos_mat_pass_func_outer_single_indexed2");
      out__.write(p_aos_mat_pass_func_outer_single_indexed2);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_mat_fail_uni_uni_idx1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 20;
      stan::model::assign(p_aos_mat_fail_uni_uni_idx1,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M),
        "assigning variable p_aos_mat_fail_uni_uni_idx1");
      out__.write(p_aos_mat_fail_uni_uni_idx1);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_mat_fail_uni_uni_idx2 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 21;
      stan::model::assign(p_aos_mat_fail_uni_uni_idx2,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(N, M),
        "assigning variable p_aos_mat_fail_uni_uni_idx2");
      out__.write(p_aos_mat_fail_uni_uni_idx2);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "alpha", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "p_soa_vec_v",
        "double", std::vector<size_t>{static_cast<size_t>(M)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "p_soa_mat",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "p_soa_arr_vec_v",
        "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(N)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization",
        "p_soa_mat_uni_col_idx", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization",
        "p_soa_vec_uni_idx", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization",
        "p_soa_loop_mat_uni_col_idx", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization",
        "p_soa_lhs_loop_mul", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 9;
      context__.validate_dims("parameter initialization",
        "p_soa_rhs_loop_mul", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 10;
      context__.validate_dims("parameter initialization",
        "p_soa_used_with_aos_in_excluded_fun", "double",
        std::vector<size_t>{static_cast<size_t>(N)});
      current_statement__ = 11;
      context__.validate_dims("parameter initialization",
        "p_soa_loop_mat_multi_uni_uni_idx", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)});
      current_statement__ = 12;
      context__.validate_dims("parameter initialization",
        "p_aos_vec_v_assign_to_aos", "double",
        std::vector<size_t>{static_cast<size_t>(M)});
      current_statement__ = 13;
      context__.validate_dims("parameter initialization",
        "p_aos_vec_v_tp_fails_func", "double",
        std::vector<size_t>{static_cast<size_t>(M)});
      current_statement__ = 14;
      context__.validate_dims("parameter initialization",
        "p_aos_loop_vec_v_uni_idx", "double",
        std::vector<size_t>{static_cast<size_t>(M)});
      current_statement__ = 15;
      context__.validate_dims("parameter initialization",
        "p_aos_fail_assign_from_top_idx", "double",
        std::vector<size_t>{static_cast<size_t>(M)});
      current_statement__ = 16;
      context__.validate_dims("parameter initialization",
        "p_aos_loop_mat_uni_uni_idx", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)});
      current_statement__ = 17;
      context__.validate_dims("parameter initialization", "p_aos_mat",
        "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)});
      current_statement__ = 18;
      context__.validate_dims("parameter initialization",
        "p_aos_mat_pass_func_outer_single_indexed1", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)});
      current_statement__ = 19;
      context__.validate_dims("parameter initialization",
        "p_aos_mat_pass_func_outer_single_indexed2", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)});
      current_statement__ = 20;
      context__.validate_dims("parameter initialization",
        "p_aos_mat_fail_uni_uni_idx1", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)});
      current_statement__ = 21;
      context__.validate_dims("parameter initialization",
        "p_aos_mat_fail_uni_uni_idx2", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = context__.vals_r("alpha")[(1 - 1)];
      out__.write(alpha);
      Eigen::Matrix<local_scalar_t__,-1,1> p_soa_vec_v =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_soa_vec_v_flat__;
        current_statement__ = 2;
        p_soa_vec_v_flat__ = context__.vals_r("p_soa_vec_v");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          stan::model::assign(p_soa_vec_v, p_soa_vec_v_flat__[(pos__ - 1)],
            "assigning variable p_soa_vec_v", stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(p_soa_vec_v);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_soa_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_soa_mat_flat__;
        current_statement__ = 3;
        p_soa_mat_flat__ = context__.vals_r("p_soa_mat");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_soa_mat, p_soa_mat_flat__[(pos__ - 1)],
              "assigning variable p_soa_mat", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_soa_mat);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> p_soa_arr_vec_v =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(10,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> p_soa_arr_vec_v_flat__;
        current_statement__ = 4;
        p_soa_arr_vec_v_flat__ = context__.vals_r("p_soa_arr_vec_v");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            stan::model::assign(p_soa_arr_vec_v,
              p_soa_arr_vec_v_flat__[(pos__ - 1)],
              "assigning variable p_soa_arr_vec_v",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_soa_arr_vec_v);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_soa_mat_uni_col_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_soa_mat_uni_col_idx_flat__;
        current_statement__ = 5;
        p_soa_mat_uni_col_idx_flat__ = context__.vals_r("p_soa_mat_uni_col_idx");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_soa_mat_uni_col_idx,
              p_soa_mat_uni_col_idx_flat__[(pos__ - 1)],
              "assigning variable p_soa_mat_uni_col_idx",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_soa_mat_uni_col_idx);
      Eigen::Matrix<local_scalar_t__,-1,1> p_soa_vec_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_soa_vec_uni_idx_flat__;
        current_statement__ = 6;
        p_soa_vec_uni_idx_flat__ = context__.vals_r("p_soa_vec_uni_idx");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(p_soa_vec_uni_idx,
            p_soa_vec_uni_idx_flat__[(pos__ - 1)],
            "assigning variable p_soa_vec_uni_idx",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(p_soa_vec_uni_idx);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_soa_loop_mat_uni_col_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_soa_loop_mat_uni_col_idx_flat__;
        current_statement__ = 7;
        p_soa_loop_mat_uni_col_idx_flat__ = context__.vals_r("p_soa_loop_mat_uni_col_idx");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_soa_loop_mat_uni_col_idx,
              p_soa_loop_mat_uni_col_idx_flat__[(pos__ - 1)],
              "assigning variable p_soa_loop_mat_uni_col_idx",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_soa_loop_mat_uni_col_idx);
      Eigen::Matrix<local_scalar_t__,1,-1> p_soa_lhs_loop_mul =
        Eigen::Matrix<local_scalar_t__,1,-1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_soa_lhs_loop_mul_flat__;
        current_statement__ = 8;
        p_soa_lhs_loop_mul_flat__ = context__.vals_r("p_soa_lhs_loop_mul");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(p_soa_lhs_loop_mul,
            p_soa_lhs_loop_mul_flat__[(pos__ - 1)],
            "assigning variable p_soa_lhs_loop_mul",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(p_soa_lhs_loop_mul);
      Eigen::Matrix<local_scalar_t__,-1,1> p_soa_rhs_loop_mul =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_soa_rhs_loop_mul_flat__;
        current_statement__ = 9;
        p_soa_rhs_loop_mul_flat__ = context__.vals_r("p_soa_rhs_loop_mul");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(p_soa_rhs_loop_mul,
            p_soa_rhs_loop_mul_flat__[(pos__ - 1)],
            "assigning variable p_soa_rhs_loop_mul",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(p_soa_rhs_loop_mul);
      Eigen::Matrix<local_scalar_t__,-1,1>
        p_soa_used_with_aos_in_excluded_fun =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__>
          p_soa_used_with_aos_in_excluded_fun_flat__;
        current_statement__ = 10;
        p_soa_used_with_aos_in_excluded_fun_flat__ = context__.vals_r("p_soa_used_with_aos_in_excluded_fun");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          stan::model::assign(p_soa_used_with_aos_in_excluded_fun,
            p_soa_used_with_aos_in_excluded_fun_flat__[(pos__ - 1)],
            "assigning variable p_soa_used_with_aos_in_excluded_fun",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(p_soa_used_with_aos_in_excluded_fun);
      Eigen::Matrix<local_scalar_t__,-1,-1>
        p_soa_loop_mat_multi_uni_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_soa_loop_mat_multi_uni_uni_idx_flat__;
        current_statement__ = 11;
        p_soa_loop_mat_multi_uni_uni_idx_flat__ = context__.vals_r("p_soa_loop_mat_multi_uni_uni_idx");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_soa_loop_mat_multi_uni_uni_idx,
              p_soa_loop_mat_multi_uni_uni_idx_flat__[(pos__ - 1)],
              "assigning variable p_soa_loop_mat_multi_uni_uni_idx",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_soa_loop_mat_multi_uni_uni_idx);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_vec_v_assign_to_aos =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_aos_vec_v_assign_to_aos_flat__;
        current_statement__ = 12;
        p_aos_vec_v_assign_to_aos_flat__ = context__.vals_r("p_aos_vec_v_assign_to_aos");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          stan::model::assign(p_aos_vec_v_assign_to_aos,
            p_aos_vec_v_assign_to_aos_flat__[(pos__ - 1)],
            "assigning variable p_aos_vec_v_assign_to_aos",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(p_aos_vec_v_assign_to_aos);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_vec_v_tp_fails_func =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_aos_vec_v_tp_fails_func_flat__;
        current_statement__ = 13;
        p_aos_vec_v_tp_fails_func_flat__ = context__.vals_r("p_aos_vec_v_tp_fails_func");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          stan::model::assign(p_aos_vec_v_tp_fails_func,
            p_aos_vec_v_tp_fails_func_flat__[(pos__ - 1)],
            "assigning variable p_aos_vec_v_tp_fails_func",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(p_aos_vec_v_tp_fails_func);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_loop_vec_v_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_aos_loop_vec_v_uni_idx_flat__;
        current_statement__ = 14;
        p_aos_loop_vec_v_uni_idx_flat__ = context__.vals_r("p_aos_loop_vec_v_uni_idx");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          stan::model::assign(p_aos_loop_vec_v_uni_idx,
            p_aos_loop_vec_v_uni_idx_flat__[(pos__ - 1)],
            "assigning variable p_aos_loop_vec_v_uni_idx",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(p_aos_loop_vec_v_uni_idx);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_fail_assign_from_top_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_aos_fail_assign_from_top_idx_flat__;
        current_statement__ = 15;
        p_aos_fail_assign_from_top_idx_flat__ = context__.vals_r("p_aos_fail_assign_from_top_idx");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          stan::model::assign(p_aos_fail_assign_from_top_idx,
            p_aos_fail_assign_from_top_idx_flat__[(pos__ - 1)],
            "assigning variable p_aos_fail_assign_from_top_idx",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(p_aos_fail_assign_from_top_idx);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_loop_mat_uni_uni_idx =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_aos_loop_mat_uni_uni_idx_flat__;
        current_statement__ = 16;
        p_aos_loop_mat_uni_uni_idx_flat__ = context__.vals_r("p_aos_loop_mat_uni_uni_idx");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_aos_loop_mat_uni_uni_idx,
              p_aos_loop_mat_uni_uni_idx_flat__[(pos__ - 1)],
              "assigning variable p_aos_loop_mat_uni_uni_idx",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_aos_loop_mat_uni_uni_idx);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_aos_mat_flat__;
        current_statement__ = 17;
        p_aos_mat_flat__ = context__.vals_r("p_aos_mat");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_aos_mat, p_aos_mat_flat__[(pos__ - 1)],
              "assigning variable p_aos_mat", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_aos_mat);
      Eigen::Matrix<local_scalar_t__,-1,-1>
        p_aos_mat_pass_func_outer_single_indexed1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__>
          p_aos_mat_pass_func_outer_single_indexed1_flat__;
        current_statement__ = 18;
        p_aos_mat_pass_func_outer_single_indexed1_flat__ = context__.vals_r("p_aos_mat_pass_func_outer_single_indexed1");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_aos_mat_pass_func_outer_single_indexed1,
              p_aos_mat_pass_func_outer_single_indexed1_flat__[(pos__ - 1)],
              "assigning variable p_aos_mat_pass_func_outer_single_indexed1",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_aos_mat_pass_func_outer_single_indexed1);
      Eigen::Matrix<local_scalar_t__,-1,-1>
        p_aos_mat_pass_func_outer_single_indexed2 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__>
          p_aos_mat_pass_func_outer_single_indexed2_flat__;
        current_statement__ = 19;
        p_aos_mat_pass_func_outer_single_indexed2_flat__ = context__.vals_r("p_aos_mat_pass_func_outer_single_indexed2");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_aos_mat_pass_func_outer_single_indexed2,
              p_aos_mat_pass_func_outer_single_indexed2_flat__[(pos__ - 1)],
              "assigning variable p_aos_mat_pass_func_outer_single_indexed2",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_aos_mat_pass_func_outer_single_indexed2);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_mat_fail_uni_uni_idx1 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_aos_mat_fail_uni_uni_idx1_flat__;
        current_statement__ = 20;
        p_aos_mat_fail_uni_uni_idx1_flat__ = context__.vals_r("p_aos_mat_fail_uni_uni_idx1");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_aos_mat_fail_uni_uni_idx1,
              p_aos_mat_fail_uni_uni_idx1_flat__[(pos__ - 1)],
              "assigning variable p_aos_mat_fail_uni_uni_idx1",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_aos_mat_fail_uni_uni_idx1);
      Eigen::Matrix<local_scalar_t__,-1,-1> p_aos_mat_fail_uni_uni_idx2 =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, M, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_aos_mat_fail_uni_uni_idx2_flat__;
        current_statement__ = 21;
        p_aos_mat_fail_uni_uni_idx2_flat__ = context__.vals_r("p_aos_mat_fail_uni_uni_idx2");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            stan::model::assign(p_aos_mat_fail_uni_uni_idx2,
              p_aos_mat_fail_uni_uni_idx2_flat__[(pos__ - 1)],
              "assigning variable p_aos_mat_fail_uni_uni_idx2",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(p_aos_mat_fail_uni_uni_idx2);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"alpha", "p_soa_vec_v", "p_soa_mat",
                "p_soa_arr_vec_v", "p_soa_mat_uni_col_idx",
                "p_soa_vec_uni_idx", "p_soa_loop_mat_uni_col_idx",
                "p_soa_lhs_loop_mul", "p_soa_rhs_loop_mul",
                "p_soa_used_with_aos_in_excluded_fun",
                "p_soa_loop_mat_multi_uni_uni_idx",
                "p_aos_vec_v_assign_to_aos", "p_aos_vec_v_tp_fails_func",
                "p_aos_loop_vec_v_uni_idx", "p_aos_fail_assign_from_top_idx",
                "p_aos_loop_mat_uni_uni_idx", "p_aos_mat",
                "p_aos_mat_pass_func_outer_single_indexed1",
                "p_aos_mat_pass_func_outer_single_indexed2",
                "p_aos_mat_fail_uni_uni_idx1", "p_aos_mat_fail_uni_uni_idx2"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"tp_real_from_aos", "tp_aos_vec_v", "tp_soa_single_idx_uninit",
             "tp_aos_fail_func_vec_v", "tp_aos_fail_assign_from_top_idx"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(10),
                  static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M)},
                std::vector<size_t>{static_cast<size_t>(N),
                  static_cast<size_t>(M)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(M)},
             std::vector<size_t>{static_cast<size_t>(M)},
             std::vector<size_t>{static_cast<size_t>(M)},
             std::vector<size_t>{static_cast<size_t>(M)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha");
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_soa_vec_v" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_soa_mat" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_soa_arr_vec_v" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_soa_mat_uni_col_idx" +
          '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_soa_vec_uni_idx" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_soa_loop_mat_uni_col_idx" + '.' + std::to_string(sym2__) + '.' +
          std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_soa_lhs_loop_mul" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_soa_rhs_loop_mul" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() +
        "p_soa_used_with_aos_in_excluded_fun" + '.' + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_soa_loop_mat_multi_uni_uni_idx" + '.' + std::to_string(sym2__) +
          '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_aos_vec_v_assign_to_aos"
        + '.' + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_aos_vec_v_tp_fails_func"
        + '.' + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_aos_loop_vec_v_uni_idx" +
        '.' + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      param_names__.emplace_back(std::string() +
        "p_aos_fail_assign_from_top_idx" + '.' + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_aos_loop_mat_uni_uni_idx" + '.' + std::to_string(sym2__) + '.' +
          std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_aos_mat" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_aos_mat_pass_func_outer_single_indexed1" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_aos_mat_pass_func_outer_single_indexed2" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_aos_mat_fail_uni_uni_idx1" + '.' + std::to_string(sym2__) + '.'
          + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_aos_mat_fail_uni_uni_idx2" + '.' + std::to_string(sym2__) + '.'
          + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp_real_from_aos");
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_aos_vec_v" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_soa_single_idx_uninit"
          + '.' + std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_aos_fail_func_vec_v" +
          '.' + std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        param_names__.emplace_back(std::string() +
          "tp_aos_fail_assign_from_top_idx" + '.' + std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha");
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_soa_vec_v" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_soa_mat" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_soa_arr_vec_v" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_soa_mat_uni_col_idx" +
          '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_soa_vec_uni_idx" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_soa_loop_mat_uni_col_idx" + '.' + std::to_string(sym2__) + '.' +
          std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_soa_lhs_loop_mul" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_soa_rhs_loop_mul" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      param_names__.emplace_back(std::string() +
        "p_soa_used_with_aos_in_excluded_fun" + '.' + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_soa_loop_mat_multi_uni_uni_idx" + '.' + std::to_string(sym2__) +
          '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_aos_vec_v_assign_to_aos"
        + '.' + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_aos_vec_v_tp_fails_func"
        + '.' + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_aos_loop_vec_v_uni_idx" +
        '.' + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      param_names__.emplace_back(std::string() +
        "p_aos_fail_assign_from_top_idx" + '.' + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_aos_loop_mat_uni_uni_idx" + '.' + std::to_string(sym2__) + '.' +
          std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() + "p_aos_mat" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_aos_mat_pass_func_outer_single_indexed1" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_aos_mat_pass_func_outer_single_indexed2" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_aos_mat_fail_uni_uni_idx1" + '.' + std::to_string(sym2__) + '.'
          + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
        param_names__.emplace_back(std::string() +
          "p_aos_mat_fail_uni_uni_idx2" + '.' + std::to_string(sym2__) + '.'
          + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp_real_from_aos");
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_aos_vec_v" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_soa_single_idx_uninit"
          + '.' + std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        param_names__.emplace_back(std::string() + "tp_aos_fail_func_vec_v" +
          '.' + std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        param_names__.emplace_back(std::string() +
          "tp_aos_fail_assign_from_top_idx" + '.' + std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"p_soa_vec_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_arr_vec_v\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(10) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"p_soa_mat_uni_col_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_vec_uni_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_loop_mat_uni_col_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_lhs_loop_mul\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_rhs_loop_mul\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_used_with_aos_in_excluded_fun\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_loop_mat_multi_uni_uni_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_vec_v_assign_to_aos\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_vec_v_tp_fails_func\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_loop_vec_v_uni_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_fail_assign_from_top_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_loop_mat_uni_uni_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_pass_func_outer_single_indexed1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_pass_func_outer_single_indexed2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_fail_uni_uni_idx1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_fail_uni_uni_idx2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_from_aos\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"tp_aos_vec_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_soa_single_idx_uninit\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_aos_fail_func_vec_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_aos_fail_assign_from_top_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"p_soa_vec_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_arr_vec_v\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(10) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"p_soa_mat_uni_col_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_vec_uni_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_loop_mat_uni_col_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_lhs_loop_mul\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_rhs_loop_mul\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_used_with_aos_in_excluded_fun\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_loop_mat_multi_uni_uni_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_vec_v_assign_to_aos\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_vec_v_tp_fails_func\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_loop_vec_v_uni_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_fail_assign_from_top_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_loop_mat_uni_uni_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_pass_func_outer_single_indexed1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_pass_func_outer_single_indexed2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_fail_uni_uni_idx1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_fail_uni_uni_idx2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_from_aos\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"tp_aos_vec_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_soa_single_idx_uninit\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_aos_fail_func_vec_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_aos_fail_assign_from_top_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((((((((((((((1 + M) + (N * M)) + (10 *
      N)) + (N * M)) + N) + (N * M)) + N) + N) + N) + (N * M)) + M) + M) + M)
      + M) + (N * M)) + (N * M)) + (N * M)) + (N * M)) + (N * M)) + (N * M));
    const size_t num_transformed = emit_transformed_parameters * (((((1 + M)
      + M) + M) + M));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((((((((((((((1 + M) + (N * M)) + (10 *
      N)) + (N * M)) + N) + (N * M)) + N) + N) + N) + (N * M)) + M) + M) + M)
      + M) + (N * M)) + (N * M)) + (N * M)) + (N * M)) + (N * M)) + (N * M));
    const size_t num_transformed = emit_transformed_parameters * (((((1 + M)
      + M) + M) + M));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = indexing_model_namespace::indexing_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return indexing_model_namespace::profiles__;
}
#endif
  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp indexing2.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace indexing2_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 17> locations_array__ =
  {" (found before start of program)",
  " (in 'indexing2.stan', line 8, column 2 to column 13)",
  " (in 'indexing2.stan', line 9, column 2 to column 35)",
  " (in 'indexing2.stan', line 13, column 9 to column 10)",
  " (in 'indexing2.stan', line 13, column 2 to column 67)",
  " (in 'indexing2.stan', line 16, column 4 to column 97)",
  " (in 'indexing2.stan', line 15, column 18 to line 17, column 3)",
  " (in 'indexing2.stan', line 15, column 2 to line 17, column 3)",
  " (in 'indexing2.stan', line 18, column 9 to column 10)",
  " (in 'indexing2.stan', line 18, column 2 to column 44)",
  " (in 'indexing2.stan', line 20, column 2 to column 77)",
  " (in 'indexing2.stan', line 19, column 17 to line 21, column 3)",
  " (in 'indexing2.stan', line 19, column 2 to line 21, column 3)",
  " (in 'indexing2.stan', line 2, column 1 to column 7)",
  " (in 'indexing2.stan', line 3, column 1 to column 7)",
  " (in 'indexing2.stan', line 4, column 7 to column 8)",
  " (in 'indexing2.stan', line 4, column 1 to column 18)"};
class indexing2_model final : public model_base_crtp<indexing2_model> {
 private:
  int N;
  int M;
  std::vector<int> Idx;
 public:
  ~indexing2_model() {}
  indexing2_model(stan::io::var_context& context__, unsigned int
                  random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "indexing2_model_namespace::indexing2_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 13;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 13;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 14;
      context__.validate_dims("data initialization", "M", "int",
        std::vector<size_t>{});
      M = std::numeric_limits<int>::min();
      current_statement__ = 14;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 15;
      stan::math::validate_non_negative_index("Idx", "N", N);
      current_statement__ = 16;
      context__.validate_dims("data initialization", "Idx", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      Idx = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 16;
      Idx = context__.vals_i("Idx");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 10;
  }
  inline std::string model_name() const final {
    return "indexing2_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = -fsoa --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "indexing2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_loop_single_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(10, DUMMY_VAR__);
      current_statement__ = 2;
      p_aos_loop_single_idx = in__.template read<
                                Eigen::Matrix<local_scalar_t__,-1,1>>(10);
      {
        current_statement__ = 3;
        stan::math::validate_non_negative_index(
          "tp_soa_multi_idx_assign_in_loop", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1>
          tp_soa_multi_idx_assign_in_loop =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 4;
        stan::model::assign(tp_soa_multi_idx_assign_in_loop,
          stan::math::rep_vector(alpha, N),
          "assigning variable tp_soa_multi_idx_assign_in_loop");
        current_statement__ = 7;
        for (int i = 1; i <= 10; ++i) {
          current_statement__ = 5;
          stan::model::assign(tp_soa_multi_idx_assign_in_loop,
            stan::math::multiply(
              stan::model::deep_copy(tp_soa_multi_idx_assign_in_loop),
              stan::model::rvalue(p_aos_loop_single_idx,
                "p_aos_loop_single_idx", stan::model::index_uni(i))),
            "assigning variable tp_soa_multi_idx_assign_in_loop");
        }
        current_statement__ = 8;
        stan::math::validate_non_negative_index(
          "tp_soa_single_idx_in_upfrom_idx", "N", N);
        Eigen::Matrix<local_scalar_t__,-1,1>
          tp_soa_single_idx_in_upfrom_idx =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 12;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 10;
          stan::model::assign(tp_soa_single_idx_in_upfrom_idx,
            stan::model::rvalue(tp_soa_multi_idx_assign_in_loop,
              "tp_soa_multi_idx_assign_in_loop",
              stan::model::index_min(
                stan::model::rvalue(Idx, "Idx", stan::model::index_uni(i)))),
            "assigning variable tp_soa_single_idx_in_upfrom_idx");
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "indexing2_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_loop_single_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(10, DUMMY_VAR__);
      current_statement__ = 2;
      p_aos_loop_single_idx = in__.template read<
                                Eigen::Matrix<local_scalar_t__,-1,1>>(10);
      {
        current_statement__ = 3;
        stan::math::validate_non_negative_index(
          "tp_soa_multi_idx_assign_in_loop", "N", N);
        stan::math::var_value<Eigen::Matrix<double,-1,1>>
          tp_soa_multi_idx_assign_in_loop =
          stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                )));
        current_statement__ = 4;
        stan::model::assign(tp_soa_multi_idx_assign_in_loop,
          stan::math::rep_vector<
            stan::math::var_value<Eigen::Matrix<double,-1,1>>>(alpha, N),
          "assigning variable tp_soa_multi_idx_assign_in_loop");
        current_statement__ = 7;
        for (int i = 1; i <= 10; ++i) {
          current_statement__ = 5;
          stan::model::assign(tp_soa_multi_idx_assign_in_loop,
            stan::math::multiply(
              stan::model::deep_copy(tp_soa_multi_idx_assign_in_loop),
              stan::model::rvalue(p_aos_loop_single_idx,
                "p_aos_loop_single_idx", stan::model::index_uni(i))),
            "assigning variable tp_soa_multi_idx_assign_in_loop");
        }
        current_statement__ = 8;
        stan::math::validate_non_negative_index(
          "tp_soa_single_idx_in_upfrom_idx", "N", N);
        stan::math::var_value<Eigen::Matrix<double,-1,1>>
          tp_soa_single_idx_in_upfrom_idx =
          stan::math::var_value<Eigen::Matrix<double,-1,1>>(Eigen::Matrix<double,-1,1>::Constant(N,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                )));
        current_statement__ = 12;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 10;
          stan::model::assign(tp_soa_single_idx_in_upfrom_idx,
            stan::model::rvalue(tp_soa_multi_idx_assign_in_loop,
              "tp_soa_multi_idx_assign_in_loop",
              stan::model::index_min(
                stan::model::rvalue(Idx, "Idx", stan::model::index_uni(i)))),
            "assigning variable tp_soa_single_idx_in_upfrom_idx");
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "indexing2_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double alpha = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double,-1,1> p_aos_loop_single_idx =
        Eigen::Matrix<double,-1,1>::Constant(10,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      p_aos_loop_single_idx = in__.template read<
                                Eigen::Matrix<local_scalar_t__,-1,1>>(10);
      out__.write(alpha);
      out__.write(p_aos_loop_single_idx);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.read<local_scalar_t__>();
      out__.write(alpha);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_loop_single_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(10, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(p_aos_loop_single_idx,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(10),
        "assigning variable p_aos_loop_single_idx");
      out__.write(p_aos_loop_single_idx);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "alpha", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization",
        "p_aos_loop_single_idx", "double",
        std::vector<size_t>{static_cast<size_t>(10)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = context__.vals_r("alpha")[(1 - 1)];
      out__.write(alpha);
      Eigen::Matrix<local_scalar_t__,-1,1> p_aos_loop_single_idx =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(10, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> p_aos_loop_single_idx_flat__;
        current_statement__ = 2;
        p_aos_loop_single_idx_flat__ = context__.vals_r("p_aos_loop_single_idx");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          stan::model::assign(p_aos_loop_single_idx,
            p_aos_loop_single_idx_flat__[(pos__ - 1)],
            "assigning variable p_aos_loop_single_idx",
            stan::model::index_uni(sym1__));
          pos__ = (pos__ + 1);
        }
      }
      out__.write(p_aos_loop_single_idx);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"alpha", "p_aos_loop_single_idx"};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(10)}};
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha");
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_aos_loop_single_idx" +
        '.' + std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "alpha");
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      param_names__.emplace_back(std::string() + "p_aos_loop_single_idx" +
        '.' + std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {}
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"p_aos_loop_single_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(10) + "},\"block\":\"parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"p_aos_loop_single_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(10) + "},\"block\":\"parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + 10);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (1 + 10);
    const size_t num_transformed = emit_transformed_parameters * (0);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = indexing2_model_namespace::indexing2_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return indexing2_model_namespace::profiles__;
}
#endif
  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp reductions_allowed.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace reductions_allowed_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 12> locations_array__ =
  {" (found before start of program)",
  " (in 'reductions_allowed.stan', line 16, column 4 to column 25)",
  " (in 'reductions_allowed.stan', line 17, column 4 to column 25)",
  " (in 'reductions_allowed.stan', line 18, column 4 to column 25)",
  " (in 'reductions_allowed.stan', line 22, column 4 to column 56)",
  " (in 'reductions_allowed.stan', line 23, column 4 to column 93)",
  " (in 'reductions_allowed.stan', line 24, column 4 to column 85)",
  " (in 'reductions_allowed.stan', line 12, column 4 to column 16)",
  " (in 'reductions_allowed.stan', line 3, column 8 to column 17)",
  " (in 'reductions_allowed.stan', line 2, column 31 to line 4, column 5)",
  " (in 'reductions_allowed.stan', line 7, column 8 to column 25)",
  " (in 'reductions_allowed.stan', line 6, column 48 to line 8, column 5)"};
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
nono_func(const T0__& x_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>>,-1,-1>
okay_reduction(const T0__& sum_x, const T1__& y_arg__, std::ostream*
               pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
nono_func(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& x = stan::math::to_ref(x_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 8;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>>,-1,-1>
okay_reduction(const T0__& sum_x, const T1__& y_arg__, std::ostream*
               pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& y = stan::math::to_ref(y_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 10;
    return stan::math::add(sum_x, y);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class reductions_allowed_model final : public model_base_crtp<reductions_allowed_model> {
 private:
  double data_r;
 public:
  ~reductions_allowed_model() {}
  reductions_allowed_model(stan::io::var_context& context__, unsigned int
                           random_seed__ = 0, std::ostream*
                           pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "reductions_allowed_model_namespace::reductions_allowed_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 7;
      context__.validate_dims("data initialization", "data_r", "double",
        std::vector<size_t>{});
      data_r = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 7;
      data_r = context__.vals_r("data_r")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (5 * 10) + (5 * 10) + (5 * 10);
  }
  inline std::string model_name() const final {
    return "reductions_allowed_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = -fsoa --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "reductions_allowed_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> soa_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 1;
      soa_x = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
                10);
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 2;
      aos_x = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
                10);
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_y =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 3;
      aos_y = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
                10);
      local_scalar_t__ tp_real_from_soa = DUMMY_VAR__;
      current_statement__ = 4;
      tp_real_from_soa = (stan::math::logical_gt(5, 0) ? data_r : stan::math::sum(
                                                                    soa_x));
      Eigen::Matrix<local_scalar_t__,-1,-1> tp_matrix_aos_from_mix =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(tp_matrix_aos_from_mix,
        (stan::math::logical_gt(stan::math::sum(soa_x), 0) ? stan::math::eval(
                                                               nono_func(
                                                                 stan::math::add(
                                                                   aos_x,
                                                                   aos_y),
                                                                 pstream__)) : 
        stan::math::eval(aos_y)), "assigning variable tp_matrix_aos_from_mix");
      Eigen::Matrix<local_scalar_t__,-1,-1> tp_matrix_from_udf_reduced_soa =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(tp_matrix_from_udf_reduced_soa,
        okay_reduction(stan::math::sum(soa_x), aos_x, pstream__),
        "assigning variable tp_matrix_from_udf_reduced_soa");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "reductions_allowed_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> soa_x =
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(5,
                                                             10,
                                                             std::numeric_limits<double>::quiet_NaN(
                                                               )));
      current_statement__ = 1;
      soa_x = in__.template read<
                stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(5, 10);
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 2;
      aos_x = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
                10);
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_y =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 3;
      aos_y = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
                10);
      local_scalar_t__ tp_real_from_soa = DUMMY_VAR__;
      current_statement__ = 4;
      tp_real_from_soa = (stan::math::logical_gt(5, 0) ? data_r : stan::math::sum(
                                                                    soa_x));
      Eigen::Matrix<local_scalar_t__,-1,-1> tp_matrix_aos_from_mix =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(tp_matrix_aos_from_mix,
        (stan::math::logical_gt(stan::math::sum(soa_x), 0) ? stan::math::eval(
                                                               nono_func(
                                                                 stan::math::add(
                                                                   aos_x,
                                                                   aos_y),
                                                                 pstream__)) : 
        stan::math::eval(aos_y)), "assigning variable tp_matrix_aos_from_mix");
      Eigen::Matrix<local_scalar_t__,-1,-1> tp_matrix_from_udf_reduced_soa =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(tp_matrix_from_udf_reduced_soa,
        okay_reduction(stan::math::sum(soa_x), aos_x, pstream__),
        "assigning variable tp_matrix_from_udf_reduced_soa");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "reductions_allowed_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> soa_x =
        Eigen::Matrix<double,-1,-1>::Constant(5, 10,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      soa_x = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
                10);
      Eigen::Matrix<double,-1,-1> aos_x =
        Eigen::Matrix<double,-1,-1>::Constant(5, 10,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      aos_x = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
                10);
      Eigen::Matrix<double,-1,-1> aos_y =
        Eigen::Matrix<double,-1,-1>::Constant(5, 10,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      aos_y = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
                10);
      double tp_real_from_soa = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double,-1,-1> tp_matrix_aos_from_mix =
        Eigen::Matrix<double,-1,-1>::Constant(5, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> tp_matrix_from_udf_reduced_soa =
        Eigen::Matrix<double,-1,-1>::Constant(5, 10,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(soa_x);
      out__.write(aos_x);
      out__.write(aos_y);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 4;
      tp_real_from_soa = (stan::math::logical_gt(5, 0) ? data_r : stan::math::sum(
                                                                    soa_x));
      current_statement__ = 5;
      stan::model::assign(tp_matrix_aos_from_mix,
        (stan::math::logical_gt(stan::math::sum(soa_x), 0) ? stan::math::eval(
                                                               nono_func(
                                                                 stan::math::add(
                                                                   aos_x,
                                                                   aos_y),
                                                                 pstream__)) : 
        stan::math::eval(aos_y)), "assigning variable tp_matrix_aos_from_mix");
      current_statement__ = 6;
      stan::model::assign(tp_matrix_from_udf_reduced_soa,
        okay_reduction(stan::math::sum(soa_x), aos_x, pstream__),
        "assigning variable tp_matrix_from_udf_reduced_soa");
      if (emit_transformed_parameters__) {
        out__.write(tp_real_from_soa);
        out__.write(tp_matrix_aos_from_mix);
        out__.write(tp_matrix_from_udf_reduced_soa);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> soa_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(soa_x,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 10),
        "assigning variable soa_x");
      out__.write(soa_x);
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(aos_x,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 10),
        "assigning variable aos_x");
      out__.write(aos_x);
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_y =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(aos_y,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 10),
        "assigning variable aos_y");
      out__.write(aos_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "soa_x", "double",
        std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(10)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "aos_x", "double",
        std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(10)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "aos_y", "double",
        std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(10)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,-1> soa_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> soa_x_flat__;
        current_statement__ = 1;
        soa_x_flat__ = context__.vals_r("soa_x");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            stan::model::assign(soa_x, soa_x_flat__[(pos__ - 1)],
              "assigning variable soa_x", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(soa_x);
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> aos_x_flat__;
        current_statement__ = 2;
        aos_x_flat__ = context__.vals_r("aos_x");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            stan::model::assign(aos_x, aos_x_flat__[(pos__ - 1)],
              "assigning variable aos_x", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(aos_x);
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_y =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> aos_y_flat__;
        current_statement__ = 3;
        aos_y_flat__ = context__.vals_r("aos_y");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            stan::model::assign(aos_y, aos_y_flat__[(pos__ - 1)],
              "assigning variable aos_y", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(aos_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"soa_x", "aos_x", "aos_y"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"tp_real_from_soa", "tp_matrix_aos_from_mix",
             "tp_matrix_from_udf_reduced_soa"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(5),
                                                 static_cast<size_t>(10)},
                std::vector<size_t>{static_cast<size_t>(5),
                  static_cast<size_t>(10)},
                std::vector<size_t>{static_cast<size_t>(5),
                  static_cast<size_t>(10)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(5),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(5),
               static_cast<size_t>(10)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "soa_x" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "aos_x" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "aos_y" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp_real_from_soa");
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_matrix_aos_from_mix"
            + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          param_names__.emplace_back(std::string() +
            "tp_matrix_from_udf_reduced_soa" + '.' + std::to_string(sym2__) +
            '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "soa_x" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "aos_x" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "aos_y" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp_real_from_soa");
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_matrix_aos_from_mix"
            + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          param_names__.emplace_back(std::string() +
            "tp_matrix_from_udf_reduced_soa" + '.' + std::to_string(sym2__) +
            '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"soa_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"aos_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"aos_y\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_from_soa\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"tp_matrix_aos_from_mix\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_matrix_from_udf_reduced_soa\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"soa_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"aos_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"aos_y\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_from_soa\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"tp_matrix_aos_from_mix\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_matrix_from_udf_reduced_soa\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((5 * 10) + (5 * 10)) + (5 * 10));
    const size_t num_transformed = emit_transformed_parameters * (((1 + (5 *
      10)) + (5 * 10)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((5 * 10) + (5 * 10)) + (5 * 10));
    const size_t num_transformed = emit_transformed_parameters * (((1 + (5 *
      10)) + (5 * 10)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = reductions_allowed_model_namespace::reductions_allowed_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return reductions_allowed_model_namespace::profiles__;
}
#endif
  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp return_types_and_udfs_demotes.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace return_types_and_udfs_demotes_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 13> locations_array__ =
  {" (found before start of program)",
  " (in 'return_types_and_udfs_demotes.stan', line 20, column 4 to column 27)",
  " (in 'return_types_and_udfs_demotes.stan', line 21, column 4 to column 33)",
  " (in 'return_types_and_udfs_demotes.stan', line 25, column 4 to column 68)",
  " (in 'return_types_and_udfs_demotes.stan', line 26, column 4 to column 59)",
  " (in 'return_types_and_udfs_demotes.stan', line 27, column 4 to column 90)",
  " (in 'return_types_and_udfs_demotes.stan', line 28, column 4 to column 73)",
  " (in 'return_types_and_udfs_demotes.stan', line 29, column 4 to column 92)",
  " (in 'return_types_and_udfs_demotes.stan', line 11, column 8 to column 32)",
  " (in 'return_types_and_udfs_demotes.stan', line 12, column 8 to column 24)",
  " (in 'return_types_and_udfs_demotes.stan', line 10, column 29 to line 13, column 5)",
  " (in 'return_types_and_udfs_demotes.stan', line 15, column 8 to column 17)",
  " (in 'return_types_and_udfs_demotes.stan', line 14, column 39 to line 16, column 5)"};
Eigen::Matrix<double,-1,-1> empty_user_func(std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
mat_ret_user_func(const T0__& A_arg__, std::ostream* pstream__);
Eigen::Matrix<double,-1,-1> empty_user_func(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    Eigen::Matrix<local_scalar_t__,-1,-1> some_mat =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
    current_statement__ = 9;
    return some_mat;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
mat_ret_user_func(const T0__& A_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 11;
    return A;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class return_types_and_udfs_demotes_model final : public model_base_crtp<return_types_and_udfs_demotes_model> {
 private:
  
 public:
  ~return_types_and_udfs_demotes_model() {}
  return_types_and_udfs_demotes_model(stan::io::var_context& context__,
                                      unsigned int random_seed__ = 0,
                                      std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "return_types_and_udfs_demotes_model_namespace::return_types_and_udfs_demotes_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = (10 * 10) + (10 * 10);
  }
  inline std::string model_name() const final {
    return "return_types_and_udfs_demotes_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = -fsoa --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "return_types_and_udfs_demotes_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> row_soa =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 1;
      row_soa = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10,
                  10);
      Eigen::Matrix<local_scalar_t__,-1,-1> udf_input_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 2;
      udf_input_aos = in__.template read<
                        Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<local_scalar_t__,-1,-1> user_func_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(user_func_aos,
        mat_ret_user_func(udf_input_aos, pstream__),
        "assigning variable user_func_aos");
      Eigen::Matrix<local_scalar_t__,-1,-1> empty_user_func_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(empty_user_func_aos, empty_user_func(pstream__),
        "assigning variable empty_user_func_aos");
      Eigen::Matrix<local_scalar_t__,-1,-1> inner_empty_user_func_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(inner_empty_user_func_aos,
        stan::math::multiply(udf_input_aos, empty_user_func(pstream__)),
        "assigning variable inner_empty_user_func_aos");
      Eigen::Matrix<local_scalar_t__,-1,-1> int_aos_mul_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(int_aos_mul_aos,
        stan::math::multiply(stan::math::rows(row_soa), empty_user_func_aos),
        "assigning variable int_aos_mul_aos");
      Eigen::Matrix<local_scalar_t__,-1,-1> mul_two_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(mul_two_aos,
        stan::math::multiply(
          stan::math::multiply(stan::math::cols(row_soa),
            stan::math::transpose(int_aos_mul_aos)), user_func_aos),
        "assigning variable mul_two_aos");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "return_types_and_udfs_demotes_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> row_soa =
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(10,
                                                             10,
                                                             std::numeric_limits<double>::quiet_NaN(
                                                               )));
      current_statement__ = 1;
      row_soa = in__.template read<
                  stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(10, 10);
      Eigen::Matrix<local_scalar_t__,-1,-1> udf_input_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 2;
      udf_input_aos = in__.template read<
                        Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<local_scalar_t__,-1,-1> user_func_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(user_func_aos,
        mat_ret_user_func(udf_input_aos, pstream__),
        "assigning variable user_func_aos");
      Eigen::Matrix<local_scalar_t__,-1,-1> empty_user_func_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(empty_user_func_aos, empty_user_func(pstream__),
        "assigning variable empty_user_func_aos");
      Eigen::Matrix<local_scalar_t__,-1,-1> inner_empty_user_func_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(inner_empty_user_func_aos,
        stan::math::multiply(udf_input_aos, empty_user_func(pstream__)),
        "assigning variable inner_empty_user_func_aos");
      Eigen::Matrix<local_scalar_t__,-1,-1> int_aos_mul_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(int_aos_mul_aos,
        stan::math::multiply(stan::math::rows(row_soa), empty_user_func_aos),
        "assigning variable int_aos_mul_aos");
      Eigen::Matrix<local_scalar_t__,-1,-1> mul_two_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(mul_two_aos,
        stan::math::multiply(
          stan::math::multiply(stan::math::cols(row_soa),
            stan::math::transpose(int_aos_mul_aos)), user_func_aos),
        "assigning variable mul_two_aos");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "return_types_and_udfs_demotes_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> row_soa =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      row_soa = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10,
                  10);
      Eigen::Matrix<double,-1,-1> udf_input_aos =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      udf_input_aos = in__.template read<
                        Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10);
      Eigen::Matrix<double,-1,-1> user_func_aos =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> empty_user_func_aos =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> inner_empty_user_func_aos =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> int_aos_mul_aos =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> mul_two_aos =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(row_soa);
      out__.write(udf_input_aos);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 3;
      stan::model::assign(user_func_aos,
        mat_ret_user_func(udf_input_aos, pstream__),
        "assigning variable user_func_aos");
      current_statement__ = 4;
      stan::model::assign(empty_user_func_aos, empty_user_func(pstream__),
        "assigning variable empty_user_func_aos");
      current_statement__ = 5;
      stan::model::assign(inner_empty_user_func_aos,
        stan::math::multiply(udf_input_aos, empty_user_func(pstream__)),
        "assigning variable inner_empty_user_func_aos");
      current_statement__ = 6;
      stan::model::assign(int_aos_mul_aos,
        stan::math::multiply(stan::math::rows(row_soa), empty_user_func_aos),
        "assigning variable int_aos_mul_aos");
      current_statement__ = 7;
      stan::model::assign(mul_two_aos,
        stan::math::multiply(
          stan::math::multiply(stan::math::cols(row_soa),
            stan::math::transpose(int_aos_mul_aos)), user_func_aos),
        "assigning variable mul_two_aos");
      if (emit_transformed_parameters__) {
        out__.write(user_func_aos);
        out__.write(empty_user_func_aos);
        out__.write(inner_empty_user_func_aos);
        out__.write(int_aos_mul_aos);
        out__.write(mul_two_aos);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> row_soa =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(row_soa,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10),
        "assigning variable row_soa");
      out__.write(row_soa);
      Eigen::Matrix<local_scalar_t__,-1,-1> udf_input_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(udf_input_aos,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10),
        "assigning variable udf_input_aos");
      out__.write(udf_input_aos);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "row_soa",
        "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "udf_input_aos",
        "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,-1> row_soa =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> row_soa_flat__;
        current_statement__ = 1;
        row_soa_flat__ = context__.vals_r("row_soa");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            stan::model::assign(row_soa, row_soa_flat__[(pos__ - 1)],
              "assigning variable row_soa", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(row_soa);
      Eigen::Matrix<local_scalar_t__,-1,-1> udf_input_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> udf_input_aos_flat__;
        current_statement__ = 2;
        udf_input_aos_flat__ = context__.vals_r("udf_input_aos");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            stan::model::assign(udf_input_aos, udf_input_aos_flat__[(pos__ -
              1)], "assigning variable udf_input_aos",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(udf_input_aos);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"row_soa", "udf_input_aos"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"user_func_aos", "empty_user_func_aos",
             "inner_empty_user_func_aos", "int_aos_mul_aos", "mul_two_aos"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    10),
                                                 static_cast<size_t>(10)},
                std::vector<size_t>{static_cast<size_t>(10),
                  static_cast<size_t>(10)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)},
             std::vector<size_t>{static_cast<size_t>(10),
               static_cast<size_t>(10)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "row_soa" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "udf_input_aos" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "user_func_aos" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "empty_user_func_aos" +
            '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() +
            "inner_empty_user_func_aos" + '.' + std::to_string(sym2__) + '.'
            + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "int_aos_mul_aos" + '.'
            + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "mul_two_aos" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "row_soa" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "udf_input_aos" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "user_func_aos" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "empty_user_func_aos" +
            '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() +
            "inner_empty_user_func_aos" + '.' + std::to_string(sym2__) + '.'
            + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "int_aos_mul_aos" + '.'
            + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          param_names__.emplace_back(std::string() + "mul_two_aos" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"row_soa\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"udf_input_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"user_func_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"empty_user_func_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"inner_empty_user_func_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"int_aos_mul_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mul_two_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"row_soa\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"udf_input_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"user_func_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"empty_user_func_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"inner_empty_user_func_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"int_aos_mul_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mul_two_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((10 * 10) + (10 * 10));
    const size_t num_transformed = emit_transformed_parameters * ((((((10 *
      10) + (10 * 10)) + (10 * 10)) + (10 * 10)) + (10 * 10)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((10 * 10) + (10 * 10));
    const size_t num_transformed = emit_transformed_parameters * ((((((10 *
      10) + (10 * 10)) + (10 * 10)) + (10 * 10)) + (10 * 10)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = return_types_and_udfs_demotes_model_namespace::return_types_and_udfs_demotes_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return return_types_and_udfs_demotes_model_namespace::profiles__;
}
#endif
  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp single_indexing.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace single_indexing_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 8> locations_array__ =
  {" (found before start of program)",
  " (in 'single_indexing.stan', line 6, column 3 to column 24)",
  " (in 'single_indexing.stan', line 7, column 3 to column 24)",
  " (in 'single_indexing.stan', line 11, column 5 to column 41)",
  " (in 'single_indexing.stan', line 14, column 7 to column 78)",
  " (in 'single_indexing.stan', line 16, column 7 to column 77)",
  " (in 'single_indexing.stan', line 12, column 21 to line 17, column 6)",
  " (in 'single_indexing.stan', line 12, column 5 to line 17, column 6)"};
class single_indexing_model final : public model_base_crtp<single_indexing_model> {
 private:
  
 public:
  ~single_indexing_model() {}
  single_indexing_model(stan::io::var_context& context__, unsigned int
                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "single_indexing_model_namespace::single_indexing_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    num_params_r__ = (10 * 10) + (10 * 10);
  }
  inline std::string model_name() const final {
    return "single_indexing_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = -fsoa --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "single_indexing_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 1;
      aos_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10,
                10);
      Eigen::Matrix<local_scalar_t__,-1,-1> soa_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 2;
      soa_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10,
                10);
      local_scalar_t__ tp_real_from_soa = DUMMY_VAR__;
      current_statement__ = 3;
      tp_real_from_soa = stan::model::rvalue(soa_p, "soa_p",
                           stan::model::index_uni(1),
                           stan::model::index_uni(1));
      current_statement__ = 7;
      for (int i = 1; i <= 10; ++i) {
        Eigen::Matrix<local_scalar_t__,1,-1> tp_row_vector_from_soa_loop =
          Eigen::Matrix<local_scalar_t__,1,-1>::Constant(10, DUMMY_VAR__);
        current_statement__ = 4;
        stan::model::assign(tp_row_vector_from_soa_loop,
          stan::math::multiply(
            stan::model::rvalue(soa_p, "soa_p", stan::model::index_uni(i)),
            soa_p), "assigning variable tp_row_vector_from_soa_loop");
        Eigen::Matrix<local_scalar_t__,-1,-1> tp_matrix_from_soa_loop =
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10,
            DUMMY_VAR__);
        current_statement__ = 5;
        stan::model::assign(tp_matrix_from_soa_loop,
          stan::math::multiply(
            stan::model::rvalue(aos_p, "aos_p", stan::model::index_uni(i),
              stan::model::index_uni(i)), soa_p),
          "assigning variable tp_matrix_from_soa_loop");
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "single_indexing_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 1;
      aos_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10,
                10);
      stan::math::var_value<Eigen::Matrix<double,-1,-1>> soa_p =
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(10,
                                                             10,
                                                             std::numeric_limits<double>::quiet_NaN(
                                                               )));
      current_statement__ = 2;
      soa_p = in__.template read<
                stan::math::var_value<Eigen::Matrix<double,-1,-1>>>(10, 10);
      local_scalar_t__ tp_real_from_soa = DUMMY_VAR__;
      current_statement__ = 3;
      tp_real_from_soa = stan::model::rvalue(soa_p, "soa_p",
                           stan::model::index_uni(1),
                           stan::model::index_uni(1));
      current_statement__ = 7;
      for (int i = 1; i <= 10; ++i) {
        stan::math::var_value<Eigen::Matrix<double,1,-1>>
          tp_row_vector_from_soa_loop =
          stan::math::var_value<Eigen::Matrix<double,1,-1>>(Eigen::Matrix<double,1,-1>::Constant(10,
                                                              std::numeric_limits<double>::quiet_NaN(
                                                                )));
        current_statement__ = 4;
        stan::model::assign(tp_row_vector_from_soa_loop,
          stan::math::multiply(
            stan::model::rvalue(soa_p, "soa_p", stan::model::index_uni(i)),
            soa_p), "assigning variable tp_row_vector_from_soa_loop");
        stan::math::var_value<Eigen::Matrix<double,-1,-1>>
          tp_matrix_from_soa_loop =
          stan::math::var_value<Eigen::Matrix<double,-1,-1>>(Eigen::Matrix<double,-1,-1>::Constant(10,
                                                               10,
                                                               std::numeric_limits<double>::quiet_NaN(
                                                                 )));
        current_statement__ = 5;
        stan::model::assign(tp_matrix_from_soa_loop,
          stan::math::multiply(
            stan::model::rvalue(aos_p, "aos_p", stan::model::index_uni(i),
              stan::model::index_uni(i)), soa_p),
          "assigning variable tp_matrix_from_soa_loop");
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "single_indexing_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> aos_p =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      aos_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10,
                10);
      Eigen::Matrix<double,-1,-1> soa_p =
        Eigen::Matrix<double,-1,-1>::Constant(10, 10,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      soa_p = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10,
                10);
      double tp_real_from_soa = std::numeric_limits<double>::quiet_NaN();
      out__.write(aos_p);
      out__.write(soa_p);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 3;
      tp_real_from_soa = stan::model::rvalue(soa_p, "soa_p",
                           stan::model::index_uni(1),
                           stan::model::index_uni(1));
      current_statement__ = 7;
      for (int i = 1; i <= 10; ++i) {
        Eigen::Matrix<double,1,-1> tp_row_vector_from_soa_loop =
          Eigen::Matrix<double,1,-1>::Constant(10,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 4;
        stan::model::assign(tp_row_vector_from_soa_loop,
          stan::math::multiply(
            stan::model::rvalue(soa_p, "soa_p", stan::model::index_uni(i)),
            soa_p), "assigning variable tp_row_vector_from_soa_loop");
        Eigen::Matrix<double,-1,-1> tp_matrix_from_soa_loop =
          Eigen::Matrix<double,-1,-1>::Constant(10, 10,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 5;
        stan::model::assign(tp_matrix_from_soa_loop,
          stan::math::multiply(
            stan::model::rvalue(aos_p, "aos_p", stan::model::index_uni(i),
              stan::model::index_uni(i)), soa_p),
          "assigning variable tp_matrix_from_soa_loop");
      }
      if (emit_transformed_parameters__) {
        out__.write(tp_real_from_soa);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(aos_p,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10),
        "assigning variable aos_p");
      out__.write(aos_p);
      Eigen::Matrix<local_scalar_t__,-1,-1> soa_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(soa_p,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(10, 10),
        "assigning variable soa_p");
      out__.write(soa_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "aos_p", "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "soa_p", "double",
        std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> aos_p_flat__;
        current_statement__ = 1;
        aos_p_flat__ = context__.vals_r("aos_p");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            stan::model::assign(aos_p, aos_p_flat__[(pos__ - 1)],
              "assigning variable aos_p", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(aos_p);
      Eigen::Matrix<local_scalar_t__,-1,-1> soa_p =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(10, 10, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> soa_p_flat__;
        current_statement__ = 2;
        soa_p_flat__ = context__.vals_r("soa_p");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            stan::model::assign(soa_p, soa_p_flat__[(pos__ - 1)],
              "assigning variable soa_p", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(soa_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"aos_p", "soa_p"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"tp_real_from_soa"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    10),
                                                 static_cast<size_t>(10)},
                std::vector<size_t>{static_cast<size_t>(10),
                  static_cast<size_t>(10)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>> temp{std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "aos_p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "soa_p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp_real_from_soa");
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "aos_p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
        param_names__.emplace_back(std::string() + "soa_p" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp_real_from_soa");
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"aos_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"soa_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_from_soa\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"aos_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"soa_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_from_soa\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((10 * 10) + (10 * 10));
    const size_t num_transformed = emit_transformed_parameters * (1);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((10 * 10) + (10 * 10));
    const size_t num_transformed = emit_transformed_parameters * (1);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = single_indexing_model_namespace::single_indexing_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return single_indexing_model_namespace::profiles__;
}
#endif
  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp tp_reused.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace tp_reused_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 10> locations_array__ =
  {" (found before start of program)",
  " (in 'tp_reused.stan', line 16, column 4 to column 36)",
  " (in 'tp_reused.stan', line 17, column 4 to column 25)",
  " (in 'tp_reused.stan', line 21, column 4 to column 51)",
  " (in 'tp_reused.stan', line 22, column 4 to column 37)",
  " (in 'tp_reused.stan', line 12, column 4 to column 16)",
  " (in 'tp_reused.stan', line 3, column 8 to column 17)",
  " (in 'tp_reused.stan', line 2, column 31 to line 4, column 5)",
  " (in 'tp_reused.stan', line 7, column 8 to column 25)",
  " (in 'tp_reused.stan', line 6, column 48 to line 8, column 5)"};
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
nono_func(const T0__& x_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>>,-1,-1>
okay_reduction(const T0__& sum_x, const T1__& y_arg__, std::ostream*
               pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
nono_func(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& x = stan::math::to_ref(x_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 6;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>>,-1,-1>
okay_reduction(const T0__& sum_x, const T1__& y_arg__, std::ostream*
               pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& y = stan::math::to_ref(y_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 8;
    return stan::math::add(sum_x, y);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
class tp_reused_model final : public model_base_crtp<tp_reused_model> {
 private:
  double data_r;
 public:
  ~tp_reused_model() {}
  tp_reused_model(stan::io::var_context& context__, unsigned int
                  random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "tp_reused_model_namespace::tp_reused_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 5;
      context__.validate_dims("data initialization", "data_r", "double",
        std::vector<size_t>{});
      data_r = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      data_r = context__.vals_r("data_r")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (5 * 10) + (5 * 10);
  }
  inline std::string model_name() const final {
    return "tp_reused_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = -fsoa --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "tp_reused_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> first_pass_soa_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 1;
      first_pass_soa_x = in__.template read<
                           Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 10);
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 2;
      aos_x = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
                10);
      Eigen::Matrix<local_scalar_t__,-1,-1> tp_matrix_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(tp_matrix_aos, first_pass_soa_x,
        "assigning variable tp_matrix_aos");
      current_statement__ = 4;
      stan::model::assign(tp_matrix_aos, nono_func(aos_x, pstream__),
        "assigning variable tp_matrix_aos");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "tp_reused_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> first_pass_soa_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 1;
      first_pass_soa_x = in__.template read<
                           Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 10);
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 2;
      aos_x = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
                10);
      Eigen::Matrix<local_scalar_t__,-1,-1> tp_matrix_aos =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(tp_matrix_aos, first_pass_soa_x,
        "assigning variable tp_matrix_aos");
      current_statement__ = 4;
      stan::model::assign(tp_matrix_aos, nono_func(aos_x, pstream__),
        "assigning variable tp_matrix_aos");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "tp_reused_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,-1> first_pass_soa_x =
        Eigen::Matrix<double,-1,-1>::Constant(5, 10,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      first_pass_soa_x = in__.template read<
                           Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 10);
      Eigen::Matrix<double,-1,-1> aos_x =
        Eigen::Matrix<double,-1,-1>::Constant(5, 10,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      aos_x = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5,
                10);
      Eigen::Matrix<double,-1,-1> tp_matrix_aos =
        Eigen::Matrix<double,-1,-1>::Constant(5, 10,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(first_pass_soa_x);
      out__.write(aos_x);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 3;
      stan::model::assign(tp_matrix_aos, first_pass_soa_x,
        "assigning variable tp_matrix_aos");
      current_statement__ = 4;
      stan::model::assign(tp_matrix_aos, nono_func(aos_x, pstream__),
        "assigning variable tp_matrix_aos");
      if (emit_transformed_parameters__) {
        out__.write(tp_matrix_aos);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,-1> first_pass_soa_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(first_pass_soa_x,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 10),
        "assigning variable first_pass_soa_x");
      out__.write(first_pass_soa_x);
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(aos_x,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(5, 10),
        "assigning variable aos_x");
      out__.write(aos_x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "first_pass_soa_x",
        "double",
        std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(10)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "aos_x", "double",
        std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(10)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,-1> first_pass_soa_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> first_pass_soa_x_flat__;
        current_statement__ = 1;
        first_pass_soa_x_flat__ = context__.vals_r("first_pass_soa_x");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            stan::model::assign(first_pass_soa_x,
              first_pass_soa_x_flat__[(pos__ - 1)],
              "assigning variable first_pass_soa_x",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(first_pass_soa_x);
      Eigen::Matrix<local_scalar_t__,-1,-1> aos_x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(5, 10, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> aos_x_flat__;
        current_statement__ = 2;
        aos_x_flat__ = context__.vals_r("aos_x");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            stan::model::assign(aos_x, aos_x_flat__[(pos__ - 1)],
              "assigning variable aos_x", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(aos_x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"first_pass_soa_x", "aos_x"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"tp_matrix_aos"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(5),
                                                 static_cast<size_t>(10)},
                std::vector<size_t>{static_cast<size_t>(5),
                  static_cast<size_t>(10)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(5),
               static_cast<size_t>(10)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "first_pass_soa_x" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "aos_x" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_matrix_aos" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "first_pass_soa_x" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
        param_names__.emplace_back(std::string() + "aos_x" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          param_names__.emplace_back(std::string() + "tp_matrix_aos" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"first_pass_soa_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"aos_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"tp_matrix_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"first_pass_soa_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"aos_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"tp_matrix_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((5 * 10) + (5 * 10));
    const size_t num_transformed = emit_transformed_parameters * ((5 * 10));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((5 * 10) + (5 * 10));
    const size_t num_transformed = emit_transformed_parameters * ((5 * 10));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = tp_reused_model_namespace::tp_reused_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return tp_reused_model_namespace::profiles__;
}
#endif
  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp tuple_test.stan
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace tuple_test_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 10> locations_array__ =
  {" (found before start of program)",
  " (in 'tuple_test.stan', line 3, column 4 to column 61)",
  " (in 'tuple_test.stan', line 6, column 4 to column 28)",
  " (in 'tuple_test.stan', line 3, column 16 to column 17)",
  " (in 'tuple_test.stan', line 3, column 26 to column 27)",
  " (in 'tuple_test.stan', line 3, column 28 to column 29)",
  " (in 'tuple_test.stan', line 3, column 39 to column 40)",
  " (in 'tuple_test.stan', line 3, column 52 to column 53)",
  " (in 'tuple_test.stan', line 6, column 11 to column 12)",
  " (in 'tuple_test.stan', line 6, column 13 to column 14)"};
class tuple_test_model final : public model_base_crtp<tuple_test_model> {
 private:
  
 public:
  ~tuple_test_model() {}
  tuple_test_model(stan::io::var_context& context__, unsigned int
                   random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "tuple_test_model_namespace::tuple_test_model";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 3;
      stan::math::validate_non_negative_index("xx.1", "1", 1);
      current_statement__ = 4;
      stan::math::validate_non_negative_index("xx.1", "1", 1);
      current_statement__ = 5;
      stan::math::validate_non_negative_index("xx.1", "1", 1);
      current_statement__ = 6;
      stan::math::validate_non_negative_index("xx.2", "1", 1);
      current_statement__ = 7;
      stan::math::validate_non_negative_index("xx.3", "1", 1);
      current_statement__ = 8;
      stan::math::validate_non_negative_index("x", "1", 1);
      current_statement__ = 9;
      stan::math::validate_non_negative_index("x", "1", 1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (((1 * (1 * 1)) + (1 * 2)) + (1 * 3));
  }
  inline std::string model_name() const final {
    return "tuple_test_model";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%",
             "stancflags = -fsoa --print-cpp"};
  }
  // Base log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_not_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "tuple_test_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::tuple<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
        Eigen::Matrix<local_scalar_t__,-1,-1>,
        Eigen::Matrix<local_scalar_t__,-1,-1>> xx =
        std::tuple<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
          Eigen::Matrix<local_scalar_t__,-1,-1>,
          Eigen::Matrix<local_scalar_t__,-1,-1>>{std::vector<
                                                   Eigen::Matrix<local_scalar_t__,-1,-1>>(1,
                                                   Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1,
                                                     1, DUMMY_VAR__)),
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1, 2, DUMMY_VAR__),
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1, 3, DUMMY_VAR__)};
      current_statement__ = 1;
      std::get<0>(xx) = in__.template read<
                          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(1,
                          1, 1);
      current_statement__ = 1;
      std::get<1>(xx) = in__.template read<
                          Eigen::Matrix<local_scalar_t__,-1,-1>>(1, 2);
      current_statement__ = 1;
      std::get<2>(xx) = in__.template read<
                          Eigen::Matrix<local_scalar_t__,-1,-1>>(1, 3);
      Eigen::Matrix<local_scalar_t__,-1,-1> x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1, 1, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(x,
        stan::model::rvalue(std::get<0>(xx), "xx.1",
          stan::model::index_uni(1)), "assigning variable x");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  // Reverse mode autodiff log prob
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr,
            stan::require_st_var<VecR>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "tuple_test_model_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::tuple<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
        Eigen::Matrix<local_scalar_t__,-1,-1>,
        Eigen::Matrix<local_scalar_t__,-1,-1>> xx =
        std::tuple<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
          Eigen::Matrix<local_scalar_t__,-1,-1>,
          Eigen::Matrix<local_scalar_t__,-1,-1>>{std::vector<
                                                   Eigen::Matrix<local_scalar_t__,-1,-1>>(1,
                                                   Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1,
                                                     1, DUMMY_VAR__)),
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1, 2, DUMMY_VAR__),
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1, 3, DUMMY_VAR__)};
      current_statement__ = 1;
      std::get<0>(xx) = in__.template read<
                          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(1,
                          1, 1);
      current_statement__ = 1;
      std::get<1>(xx) = in__.template read<
                          Eigen::Matrix<local_scalar_t__,-1,-1>>(1, 2);
      current_statement__ = 1;
      std::get<2>(xx) = in__.template read<
                          Eigen::Matrix<local_scalar_t__,-1,-1>>(1, 3);
      Eigen::Matrix<local_scalar_t__,-1,-1> x =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1, 1, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(x,
        stan::model::rvalue(std::get<0>(xx), "xx.1",
          stan::model::index_uni(1)), "assigning variable x");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    // suppress unused var warning
    (void) jacobian__;
    static constexpr const char* function__ =
      "tuple_test_model_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      std::tuple<std::vector<Eigen::Matrix<double,-1,-1>>,
        Eigen::Matrix<double,-1,-1>, Eigen::Matrix<double,-1,-1>> xx =
        std::tuple<std::vector<Eigen::Matrix<double,-1,-1>>,
          Eigen::Matrix<double,-1,-1>, Eigen::Matrix<double,-1,-1>>{std::vector<
                                                                    Eigen::Matrix<double,-1,-1>>(1,
                                                                    Eigen::Matrix<double,-1,-1>::Constant(1,
                                                                    1,
                                                                    std::numeric_limits<double>::quiet_NaN(
                                                                    ))),
          Eigen::Matrix<double,-1,-1>::Constant(1, 2,
            std::numeric_limits<double>::quiet_NaN()),
          Eigen::Matrix<double,-1,-1>::Constant(1, 3,
            std::numeric_limits<double>::quiet_NaN())};
      current_statement__ = 1;
      std::get<0>(xx) = in__.template read<
                          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>>(1,
                          1, 1);
      current_statement__ = 1;
      std::get<1>(xx) = in__.template read<
                          Eigen::Matrix<local_scalar_t__,-1,-1>>(1, 2);
      current_statement__ = 1;
      std::get<2>(xx) = in__.template read<
                          Eigen::Matrix<local_scalar_t__,-1,-1>>(1, 3);
      Eigen::Matrix<double,-1,-1> x =
        Eigen::Matrix<double,-1,-1>::Constant(1, 1,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 1; ++sym3__) {
            out__.write(stan::model::rvalue(std::get<0>(xx), "xx.1",
                          stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      out__.write(std::get<1>(xx));
      out__.write(std::get<2>(xx));
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 2;
      stan::model::assign(x,
        stan::model::rvalue(std::get<0>(xx), "xx.1",
          stan::model::index_uni(1)), "assigning variable x");
      if (emit_transformed_parameters__) {
        out__.write(x);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      std::tuple<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
        Eigen::Matrix<local_scalar_t__,-1,-1>,
        Eigen::Matrix<local_scalar_t__,-1,-1>> xx =
        std::tuple<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
          Eigen::Matrix<local_scalar_t__,-1,-1>,
          Eigen::Matrix<local_scalar_t__,-1,-1>>{std::vector<
                                                   Eigen::Matrix<local_scalar_t__,-1,-1>>(1,
                                                   Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1,
                                                     1, DUMMY_VAR__)),
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1, 2, DUMMY_VAR__),
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1, 3, DUMMY_VAR__)};
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 1; ++sym3__) {
            current_statement__ = 1;
            stan::model::assign(std::get<0>(xx),
              in__.read<local_scalar_t__>(), "assigning variable xx.1",
              stan::model::index_uni(sym3__), stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
          }
        }
      }
      current_statement__ = 1;
      stan::model::assign(std::get<1>(xx),
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(1, 2),
        "assigning variable xx.2");
      current_statement__ = 1;
      stan::model::assign(std::get<2>(xx),
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(1, 3),
        "assigning variable xx.3");
      out__.write(std::get<0>(xx));
      out__.write(std::get<1>(xx));
      out__.write(std::get<2>(xx));
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "xx.1", "double",
        std::vector<size_t>{static_cast<size_t>(1), static_cast<size_t>(1),
          static_cast<size_t>(1)});
      context__.validate_dims("parameter initialization", "xx.2", "double",
        std::vector<size_t>{static_cast<size_t>(1), static_cast<size_t>(2)});
      context__.validate_dims("parameter initialization", "xx.3", "double",
        std::vector<size_t>{static_cast<size_t>(1), static_cast<size_t>(3)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      std::tuple<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
        Eigen::Matrix<local_scalar_t__,-1,-1>,
        Eigen::Matrix<local_scalar_t__,-1,-1>> xx =
        std::tuple<std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
          Eigen::Matrix<local_scalar_t__,-1,-1>,
          Eigen::Matrix<local_scalar_t__,-1,-1>>{std::vector<
                                                   Eigen::Matrix<local_scalar_t__,-1,-1>>(1,
                                                   Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1,
                                                     1, DUMMY_VAR__)),
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1, 2, DUMMY_VAR__),
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(1, 3, DUMMY_VAR__)};
      {
        std::vector<local_scalar_t__> xx_dot_1_flat__;
        current_statement__ = 1;
        xx_dot_1_flat__ = context__.vals_r("xx.1");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= 1; ++sym3__) {
              stan::model::assign(std::get<0>(xx), xx_dot_1_flat__[(pos__ -
                1)], "assigning variable xx.1",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      {
        std::vector<local_scalar_t__> xx_dot_2_flat__;
        xx_dot_2_flat__ = context__.vals_r("xx.2");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
            stan::model::assign(std::get<1>(xx), xx_dot_2_flat__[(pos__ -
              1)], "assigning variable xx.2", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      {
        std::vector<local_scalar_t__> xx_dot_3_flat__;
        xx_dot_3_flat__ = context__.vals_r("xx.3");
        pos__ = 1;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
            stan::model::assign(std::get<2>(xx), xx_dot_3_flat__[(pos__ -
              1)], "assigning variable xx.3", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(std::get<0>(xx));
      out__.write(std::get<1>(xx));
      out__.write(std::get<2>(xx));
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"xx.1", "xx.2", "xx.3"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"x"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(1),
                                                 static_cast<size_t>(1),
                                                 static_cast<size_t>(1)},
                std::vector<size_t>{static_cast<size_t>(1),
                  static_cast<size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(1),
                  static_cast<size_t>(3)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(1),
               static_cast<size_t>(1)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= 1; ++sym3__) {
          param_names__.emplace_back(std::string() + "xx" + ':' +
            std::to_string(1) + '.' + std::to_string(sym3__) + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
        param_names__.emplace_back(std::string() + "xx" + ':' +
          std::to_string(2) + '.' + std::to_string(sym2__) + '.' +
          std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
        param_names__.emplace_back(std::string() + "xx" + ':' +
          std::to_string(3) + '.' + std::to_string(sym2__) + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
          param_names__.emplace_back(std::string() + "x" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= 1; ++sym3__) {
          param_names__.emplace_back(std::string() + "xx" + ':' +
            std::to_string(1) + '.' + std::to_string(sym3__) + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
        param_names__.emplace_back(std::string() + "xx" + ':' +
          std::to_string(2) + '.' + std::to_string(sym2__) + '.' +
          std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
        param_names__.emplace_back(std::string() + "xx" + ':' +
          std::to_string(3) + '.' + std::to_string(sym2__) + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
          param_names__.emplace_back(std::string() + "x" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"xx\",\"type\":{\"name\":\"tuple\",\"num_elements\":\"3\",\"element_types\":[{\"name\":\"array\",\"length\":" + std::to_string(1) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(1) + ",\"cols\":" + std::to_string(1) + "}},{\"name\":\"matrix\",\"rows\":" + std::to_string(1) + ",\"cols\":" + std::to_string(2) + "},{\"name\":\"matrix\",\"rows\":" + std::to_string(1) + ",\"cols\":" + std::to_string(3) + "}]},\"block\":\"parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(1) + ",\"cols\":" + std::to_string(1) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"xx\",\"type\":{\"name\":\"tuple\",\"num_elements\":\"3\",\"element_types\":[{\"name\":\"array\",\"length\":" + std::to_string(1) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(1) + ",\"cols\":" + std::to_string(1) + "}},{\"name\":\"matrix\",\"rows\":" + std::to_string(1) + ",\"cols\":" + std::to_string(2) + "},{\"name\":\"matrix\",\"rows\":" + std::to_string(1) + ",\"cols\":" + std::to_string(3) + "}]},\"block\":\"parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(1) + ",\"cols\":" + std::to_string(1) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((1 * (1 * 1)) + (1 * 2)) + (1 * 3));
    const size_t num_transformed = emit_transformed_parameters * ((1 * 1));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((1 * (1 * 1)) + (1 * 2)) + (1 * 3));
    const size_t num_transformed = emit_transformed_parameters * ((1 * 1));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = tuple_test_model_namespace::tuple_test_model;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return tuple_test_model_namespace::profiles__;
}
#endif
