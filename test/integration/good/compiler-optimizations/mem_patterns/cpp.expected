  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp constraints.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace constraints_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 92> locations_array__ = 
{" (found before start of program)",
 " (in 'constraints.stan', line 20, column 2 to column 66)",
 " (in 'constraints.stan', line 21, column 2 to column 14)",
 " (in 'constraints.stan', line 22, column 2 to column 15)",
 " (in 'constraints.stan', line 23, column 2 to column 15)",
 " (in 'constraints.stan', line 24, column 2 to column 10)",
 " (in 'constraints.stan', line 25, column 2 to column 33)",
 " (in 'constraints.stan', line 26, column 2 to column 23)",
 " (in 'constraints.stan', line 27, column 2 to column 17)",
 " (in 'constraints.stan', line 28, column 2 to column 23)",
 " (in 'constraints.stan', line 29, column 2 to column 35)",
 " (in 'constraints.stan', line 30, column 2 to column 13)",
 " (in 'constraints.stan', line 31, column 2 to column 33)",
 " (in 'constraints.stan', line 32, column 2 to column 66)",
 " (in 'constraints.stan', line 33, column 2 to column 80)",
 " (in 'constraints.stan', line 34, column 2 to column 72)",
 " (in 'constraints.stan', line 35, column 2 to column 26)",
 " (in 'constraints.stan', line 36, column 2 to column 31)",
 " (in 'constraints.stan', line 37, column 2 to column 39)",
 " (in 'constraints.stan', line 38, column 2 to column 34)",
 " (in 'constraints.stan', line 39, column 2 to column 32)",
 " (in 'constraints.stan', line 40, column 2 to column 43)",
 " (in 'constraints.stan', line 41, column 2 to column 45)",
 " (in 'constraints.stan', line 47, column 2 to column 56)",
 " (in 'constraints.stan', line 48, column 2 to column 37)",
 " (in 'constraints.stan', line 50, column 2 to column 46)",
 " (in 'constraints.stan', line 51, column 2 to column 59)",
 " (in 'constraints.stan', line 52, column 2 to column 40)",
 " (in 'constraints.stan', line 54, column 2 to column 17)",
 " (in 'constraints.stan', line 61, column 2 to column 22)",
 " (in 'constraints.stan', line 62, column 2 to column 32)",
 " (in 'constraints.stan', line 67, column 2 to column 70)",
 " (in 'constraints.stan', line 56, column 2 to column 25)",
 " (in 'constraints.stan', line 57, column 2 to column 67)",
 " (in 'constraints.stan', line 58, column 2 to column 46)",
 " (in 'constraints.stan', line 59, column 2 to column 25)",
 " (in 'constraints.stan', line 63, column 2 to column 20)",
 " (in 'constraints.stan', line 64, column 2 to column 44)",
 " (in 'constraints.stan', line 65, column 2 to column 46)",
 " (in 'constraints.stan', line 66, column 2 to column 71)",
 " (in 'constraints.stan', line 72, column 2 to column 34)",
 " (in 'constraints.stan', line 73, column 2 to column 50)",
 " (in 'constraints.stan', line 74, column 2 to column 44)",
 " (in 'constraints.stan', line 75, column 2 to column 54)",
 " (in 'constraints.stan', line 76, column 2 to column 21)",
 " (in 'constraints.stan', line 77, column 2 to column 21)",
 " (in 'constraints.stan', line 78, column 2 to column 34)",
 " (in 'constraints.stan', line 79, column 2 to column 35)",
 " (in 'constraints.stan', line 80, column 2 to column 54)",
 " (in 'constraints.stan', line 81, column 2 to column 43)",
 " (in 'constraints.stan', line 82, column 2 to column 36)",
 " (in 'constraints.stan', line 3, column 2 to column 17)",
 " (in 'constraints.stan', line 4, column 2 to column 17)",
 " (in 'constraints.stan', line 5, column 9 to column 10)",
 " (in 'constraints.stan', line 5, column 2 to column 25)",
 " (in 'constraints.stan', line 6, column 9 to column 10)",
 " (in 'constraints.stan', line 6, column 2 to column 26)",
 " (in 'constraints.stan', line 7, column 9 to column 10)",
 " (in 'constraints.stan', line 7, column 2 to column 22)",
 " (in 'constraints.stan', line 8, column 9 to column 10)",
 " (in 'constraints.stan', line 8, column 12 to column 13)",
 " (in 'constraints.stan', line 8, column 2 to column 21)",
 " (in 'constraints.stan', line 9, column 2 to column 28)",
 " (in 'constraints.stan', line 10, column 2 to column 28)",
 " (in 'constraints.stan', line 11, column 2 to column 19)",
 " (in 'constraints.stan', line 12, column 2 to column 31)",
 " (in 'constraints.stan', line 13, column 2 to column 34)",
 " (in 'constraints.stan', line 14, column 2 to column 33)",
 " (in 'constraints.stan', line 17, column 2 to column 17)",
 " (in 'constraints.stan', line 20, column 50 to column 51)",
 " (in 'constraints.stan', line 21, column 9 to column 10)",
 " (in 'constraints.stan', line 22, column 9 to column 11)",
 " (in 'constraints.stan', line 28, column 9 to column 10)",
 " (in 'constraints.stan', line 29, column 20 to column 21)",
 " (in 'constraints.stan', line 31, column 19 to column 20)",
 " (in 'constraints.stan', line 32, column 46 to column 47)",
 " (in 'constraints.stan', line 33, column 52 to column 53)",
 " (in 'constraints.stan', line 34, column 52 to column 53)",
 " (in 'constraints.stan', line 35, column 10 to column 11)",
 " (in 'constraints.stan', line 36, column 14 to column 15)",
 " (in 'constraints.stan', line 37, column 19 to column 20)",
 " (in 'constraints.stan', line 38, column 14 to column 15)",
 " (in 'constraints.stan', line 39, column 13 to column 14)",
 " (in 'constraints.stan', line 40, column 22 to column 23)",
 " (in 'constraints.stan', line 41, column 23 to column 24)",
 " (in 'constraints.stan', line 50, column 9 to column 10)",
 " (in 'constraints.stan', line 51, column 9 to column 11)",
 " (in 'constraints.stan', line 52, column 9 to column 11)",
 " (in 'constraints.stan', line 54, column 9 to column 11)",
 " (in 'constraints.stan', line 61, column 9 to column 11)",
 " (in 'constraints.stan', line 62, column 18 to column 20)",
 " (in 'constraints.stan', line 67, column 9 to column 11)"};




class constraints_model final : public model_base_crtp<constraints_model> {

 private:
  int N;
  int K;
  Eigen::Matrix<double, -1, 1> diff_low_mid__;
  Eigen::Matrix<double, -1, 1> diff_high_mid__;
  Eigen::Matrix<double, -1, 1> mid_price__;
  Eigen::Matrix<double, -1, -1> X_all__;
  double phi_prior_a;
  double phi_prior_b;
  double mu_prior_mu;
  double mu_prior_sigma;
  double sigma_prior_shape;
  double sigma_prior_rate;
  int Nr; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> diff_low_mid{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> diff_high_mid{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> mid_price{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, -1>> X_all{nullptr, 0, 0};
 
 public:
  ~constraints_model() { }
  
  inline std::string model_name() const final { return "constraints_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = -fsoa --print-cpp"};
  }
  
  
  constraints_model(stan::io::var_context& context__,
                    unsigned int random_seed__ = 0,
                    std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "constraints_model_namespace::constraints_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 51;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      
      current_statement__ = 51;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 51;
      stan::math::check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 52;
      context__.validate_dims("data initialization","K","int",
           std::vector<size_t>{});
      K = std::numeric_limits<int>::min();
      
      
      current_statement__ = 52;
      K = context__.vals_i("K")[(1 - 1)];
      current_statement__ = 52;
      stan::math::check_greater_or_equal(function__, "K", K, 1);
      current_statement__ = 53;
      stan::math::validate_non_negative_index("diff_low_mid", "N", N);
      current_statement__ = 54;
      context__.validate_dims("data initialization","diff_low_mid","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      diff_low_mid__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&diff_low_mid) Eigen::Map<Eigen::Matrix<double, -1, 1>>(diff_low_mid__.data(), N);
        
      
      {
        std::vector<local_scalar_t__> diff_low_mid_flat__;
        current_statement__ = 54;
        diff_low_mid_flat__ = context__.vals_r("diff_low_mid");
        current_statement__ = 54;
        pos__ = 1;
        current_statement__ = 54;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 54;
          stan::model::assign(diff_low_mid, diff_low_mid_flat__[(pos__ - 1)],
            "assigning variable diff_low_mid", stan::model::index_uni(sym1__));
          current_statement__ = 54;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 55;
      stan::math::validate_non_negative_index("diff_high_mid", "N", N);
      current_statement__ = 56;
      context__.validate_dims("data initialization","diff_high_mid","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      diff_high_mid__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&diff_high_mid) Eigen::Map<Eigen::Matrix<double, -1, 1>>(diff_high_mid__.data(), N);
        
      
      {
        std::vector<local_scalar_t__> diff_high_mid_flat__;
        current_statement__ = 56;
        diff_high_mid_flat__ = context__.vals_r("diff_high_mid");
        current_statement__ = 56;
        pos__ = 1;
        current_statement__ = 56;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 56;
          stan::model::assign(diff_high_mid,
            diff_high_mid_flat__[(pos__ - 1)],
            "assigning variable diff_high_mid", stan::model::index_uni(sym1__));
          current_statement__ = 56;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 57;
      stan::math::validate_non_negative_index("mid_price", "N", N);
      current_statement__ = 58;
      context__.validate_dims("data initialization","mid_price","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      mid_price__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&mid_price) Eigen::Map<Eigen::Matrix<double, -1, 1>>(mid_price__.data(), N);
        
      
      {
        std::vector<local_scalar_t__> mid_price_flat__;
        current_statement__ = 58;
        mid_price_flat__ = context__.vals_r("mid_price");
        current_statement__ = 58;
        pos__ = 1;
        current_statement__ = 58;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 58;
          stan::model::assign(mid_price, mid_price_flat__[(pos__ - 1)],
            "assigning variable mid_price", stan::model::index_uni(sym1__));
          current_statement__ = 58;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 59;
      stan::math::validate_non_negative_index("X_all", "N", N);
      current_statement__ = 60;
      stan::math::validate_non_negative_index("X_all", "K", K);
      current_statement__ = 61;
      context__.validate_dims("data initialization","X_all","double",
           std::vector<size_t>{static_cast<size_t>(N),
            static_cast<size_t>(K)});
      X_all__ = 
        Eigen::Matrix<double, -1, -1>::Constant(N, K,
          std::numeric_limits<double>::quiet_NaN());
      new (&X_all) Eigen::Map<Eigen::Matrix<double, -1, -1>>(X_all__.data(), N, K);
        
      
      {
        std::vector<local_scalar_t__> X_all_flat__;
        current_statement__ = 61;
        X_all_flat__ = context__.vals_r("X_all");
        current_statement__ = 61;
        pos__ = 1;
        current_statement__ = 61;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 61;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 61;
            stan::model::assign(X_all, X_all_flat__[(pos__ - 1)],
              "assigning variable X_all", stan::model::index_uni(sym2__),
                                            stan::model::index_uni(sym1__));
            current_statement__ = 61;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 62;
      context__.validate_dims("data initialization","phi_prior_a","double",
           std::vector<size_t>{});
      phi_prior_a = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 62;
      phi_prior_a = context__.vals_r("phi_prior_a")[(1 - 1)];
      current_statement__ = 62;
      stan::math::check_greater_or_equal(function__, "phi_prior_a",
                                            phi_prior_a, 0);
      current_statement__ = 63;
      context__.validate_dims("data initialization","phi_prior_b","double",
           std::vector<size_t>{});
      phi_prior_b = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 63;
      phi_prior_b = context__.vals_r("phi_prior_b")[(1 - 1)];
      current_statement__ = 63;
      stan::math::check_greater_or_equal(function__, "phi_prior_b",
                                            phi_prior_b, 0);
      current_statement__ = 64;
      context__.validate_dims("data initialization","mu_prior_mu","double",
           std::vector<size_t>{});
      mu_prior_mu = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 64;
      mu_prior_mu = context__.vals_r("mu_prior_mu")[(1 - 1)];
      current_statement__ = 65;
      context__.validate_dims("data initialization","mu_prior_sigma",
          "double", std::vector<size_t>{});
      mu_prior_sigma = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 65;
      mu_prior_sigma = context__.vals_r("mu_prior_sigma")[(1 - 1)];
      current_statement__ = 65;
      stan::math::check_greater_or_equal(function__, "mu_prior_sigma",
                                            mu_prior_sigma, 0);
      current_statement__ = 66;
      context__.validate_dims("data initialization","sigma_prior_shape",
          "double", std::vector<size_t>{});
      sigma_prior_shape = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 66;
      sigma_prior_shape = context__.vals_r("sigma_prior_shape")[(1 - 1)];
      current_statement__ = 66;
      stan::math::check_greater_or_equal(function__, "sigma_prior_shape",
                                            sigma_prior_shape, 0);
      current_statement__ = 67;
      context__.validate_dims("data initialization","sigma_prior_rate",
          "double", std::vector<size_t>{});
      sigma_prior_rate = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 67;
      sigma_prior_rate = context__.vals_r("sigma_prior_rate")[(1 - 1)];
      current_statement__ = 67;
      stan::math::check_greater_or_equal(function__, "sigma_prior_rate",
                                            sigma_prior_rate, 0);
      current_statement__ = 68;
      Nr = std::numeric_limits<int>::min();
      
      
      current_statement__ = 68;
      Nr = (N - 1);
      current_statement__ = 69;
      stan::math::validate_non_negative_index("high_low_est", "N", N);
      current_statement__ = 70;
      stan::math::validate_non_negative_index("b", "K", K);
      current_statement__ = 71;
      stan::math::validate_non_negative_index("h", "Nr", Nr);
      current_statement__ = 72;
      stan::math::validate_non_negative_index("mean_price", "N", N);
      current_statement__ = 73;
      stan::math::validate_non_negative_index("sigma_price", "N", N);
      current_statement__ = 74;
      stan::math::validate_non_negative_index("upper_test", "N", N);
      current_statement__ = 75;
      stan::math::validate_non_negative_index("lower_upper_test", "N", N);
      current_statement__ = 76;
      stan::math::validate_non_negative_index("row_vec_lower_upper_test",
                                              "N", N);
      current_statement__ = 77;
      stan::math::validate_non_negative_index("offset_mult_test", "N", N);
      current_statement__ = 78;
      stan::math::validate_non_negative_index("ordered_test", "N", N);
      current_statement__ = 79;
      stan::math::validate_unit_vector_index("unit_vec_test", "N", N);
      current_statement__ = 80;
      stan::math::validate_non_negative_index("pos_ordered_test", "N", N);
      current_statement__ = 81;
      stan::math::validate_non_negative_index("corr_matrix_test", "N", N);
      current_statement__ = 81;
      stan::math::validate_non_negative_index("corr_matrix_test", "N", N);
      current_statement__ = 82;
      stan::math::validate_non_negative_index("cov_matrix_test", "N", N);
      current_statement__ = 82;
      stan::math::validate_non_negative_index("cov_matrix_test", "N", N);
      current_statement__ = 83;
      stan::math::validate_non_negative_index("chol_fac_cov_test", "K", K);
      current_statement__ = 83;
      stan::math::validate_non_negative_index("chol_fac_cov_test", "K", K);
      current_statement__ = 83;
      stan::math::check_greater_or_equal("cholesky_factor_cov chol_fac_cov_test",
                                         "num rows (must be greater or equal to num cols)",
                                         K, K);
      current_statement__ = 84;
      stan::math::validate_non_negative_index("chol_fac_corr_test", "K", K);
      current_statement__ = 84;
      stan::math::validate_non_negative_index("chol_fac_corr_test", "K", K);
      current_statement__ = 85;
      stan::math::validate_non_negative_index("prices", "N", N);
      current_statement__ = 86;
      stan::math::validate_non_negative_index("prices_diff", "Nr", Nr);
      current_statement__ = 87;
      stan::math::validate_non_negative_index("mu", "Nr", Nr);
      current_statement__ = 88;
      stan::math::validate_non_negative_index("err", "Nr", Nr);
      current_statement__ = 89;
      stan::math::validate_non_negative_index("h_i_mean", "Nr", Nr);
      current_statement__ = 90;
      stan::math::validate_non_negative_index("h_i_sigma", "Nr", Nr);
      current_statement__ = 91;
      stan::math::validate_non_negative_index("h_sigma", "Nr", Nr);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = N + K + Nr + 2 + 1 + 1 + 1 + 1 + N + N + 1 + N + 
      N + N + N + N + N + N + ((N * (N - 1)) / 2) + (N + ((N * (N - 1)) / 2))
       + ((((K * (K - 1)) / 2) + K) + ((K - K) * K)) + ((K * (K - 1)) / 2);
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "constraints_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> high_low_est =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 1;
      high_low_est = in__.template read_constrain_lub<
                       stan::conditional_var_value_t<local_scalar_t__, 
                         Eigen::Matrix<local_scalar_t__, -1, 1>>, 
                       jacobian__>(diff_low_mid, diff_high_mid, lp__, N);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "high_low_est",
                                      high_low_est, "lower", diff_low_mid);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "high_low_est",
                                      high_low_est, "upper", diff_high_mid);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> b =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(K,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 2;
      b = in__.template read<
            stan::conditional_var_value_t<local_scalar_t__, 
              Eigen::Matrix<local_scalar_t__, -1, 1>>>(K);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> h =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(Nr,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 3;
      h = in__.template read<
            stan::conditional_var_value_t<local_scalar_t__, 
              Eigen::Matrix<local_scalar_t__, -1, 1>>>(Nr);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> ar =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(2,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 4;
      ar = in__.template read<
             stan::conditional_var_value_t<local_scalar_t__, 
               Eigen::Matrix<local_scalar_t__, -1, 1>>>(2);
      local_scalar_t__ ma = DUMMY_VAR__;
      current_statement__ = 5;
      ma = in__.template read<local_scalar_t__>();
      local_scalar_t__ phi_beta = DUMMY_VAR__;
      current_statement__ = 6;
      phi_beta = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 1, lp__);
      local_scalar_t__ sigma2 = DUMMY_VAR__;
      current_statement__ = 7;
      sigma2 = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                 0, lp__);
      local_scalar_t__ Intercept = DUMMY_VAR__;
      current_statement__ = 8;
      Intercept = in__.template read<local_scalar_t__>();
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> mean_price =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 9;
      mean_price = in__.template read<
                     stan::conditional_var_value_t<local_scalar_t__, 
                       Eigen::Matrix<local_scalar_t__, -1, 1>>>(N);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> sigma_price =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 10;
      sigma_price = in__.template read_constrain_lb<
                      stan::conditional_var_value_t<local_scalar_t__, 
                        Eigen::Matrix<local_scalar_t__, -1, 1>>, jacobian__>(
                      0.0, lp__, N);
      local_scalar_t__ theta = DUMMY_VAR__;
      current_statement__ = 11;
      theta = in__.template read<local_scalar_t__>();
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> upper_test =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 12;
      upper_test = in__.template read_constrain_ub<
                     stan::conditional_var_value_t<local_scalar_t__, 
                       Eigen::Matrix<local_scalar_t__, -1, 1>>, jacobian__>(
                     ma, lp__, N);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> lower_upper_test =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 13;
      lower_upper_test = in__.template read_constrain_lub<
                           stan::conditional_var_value_t<local_scalar_t__, 
                             Eigen::Matrix<local_scalar_t__, -1, 1>>, 
                           jacobian__>(sigma_price, upper_test, lp__, N);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "lower_upper_test",
                                      lower_upper_test, "lower", sigma_price);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "lower_upper_test",
                                      lower_upper_test, "upper", upper_test);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, 1, -1>> row_vec_lower_upper_test =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, 1, -1>>(
           Eigen::Matrix<double, 1, -1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 14;
      row_vec_lower_upper_test = in__.template read_constrain_lub<
                                   stan::conditional_var_value_t<local_scalar_t__,
                                     Eigen::Matrix<local_scalar_t__, 1, -1>>, 
                                   jacobian__>(
                                   stan::math::transpose(sigma_price),
                                   stan::math::transpose(upper_test), lp__,
                                   N);
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint",
                                      "row_vec_lower_upper_test",
                                      row_vec_lower_upper_test, "lower",
                                      stan::math::transpose(sigma_price));
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint",
                                      "row_vec_lower_upper_test",
                                      row_vec_lower_upper_test, "upper",
                                      stan::math::transpose(upper_test));
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> offset_mult_test =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 15;
      offset_mult_test = in__.template read_constrain_offset_multiplier<
                           stan::conditional_var_value_t<local_scalar_t__, 
                             Eigen::Matrix<local_scalar_t__, -1, 1>>, 
                           jacobian__>(mean_price, sigma_price, lp__, N);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "offset_mult_test",
                                      offset_mult_test, "offset", mean_price);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "offset_mult_test",
                                      offset_mult_test, "multiplier",
                                      sigma_price);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> ordered_test =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 16;
      ordered_test = in__.template read_constrain_ordered<
                       stan::conditional_var_value_t<local_scalar_t__, 
                         Eigen::Matrix<local_scalar_t__, -1, 1>>, 
                       jacobian__>(lp__, N);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> unit_vec_test =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 17;
      unit_vec_test = in__.template read_constrain_unit_vector<
                        stan::conditional_var_value_t<local_scalar_t__, 
                          Eigen::Matrix<local_scalar_t__, -1, 1>>, 
                        jacobian__>(lp__, N);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> pos_ordered_test =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 18;
      pos_ordered_test = in__.template read_constrain_positive_ordered<
                           stan::conditional_var_value_t<local_scalar_t__, 
                             Eigen::Matrix<local_scalar_t__, -1, 1>>, 
                           jacobian__>(lp__, N);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, -1>> corr_matrix_test =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, -1>>(
           Eigen::Matrix<double, -1, -1>::Constant(N, N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 19;
      corr_matrix_test = in__.template read_constrain_corr_matrix<
                           stan::conditional_var_value_t<local_scalar_t__, 
                             Eigen::Matrix<local_scalar_t__, -1, -1>>, 
                           jacobian__>(lp__, N);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, -1>> cov_matrix_test =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, -1>>(
           Eigen::Matrix<double, -1, -1>::Constant(N, N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 20;
      cov_matrix_test = in__.template read_constrain_cov_matrix<
                          stan::conditional_var_value_t<local_scalar_t__, 
                            Eigen::Matrix<local_scalar_t__, -1, -1>>, 
                          jacobian__>(lp__, N);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, -1>> chol_fac_cov_test =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, -1>>(
           Eigen::Matrix<double, -1, -1>::Constant(K, K,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 21;
      chol_fac_cov_test = in__.template read_constrain_cholesky_factor_cov<
                            stan::conditional_var_value_t<local_scalar_t__, 
                              Eigen::Matrix<local_scalar_t__, -1, -1>>, 
                            jacobian__>(lp__, K, K);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, -1>> chol_fac_corr_test =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, -1>>(
           Eigen::Matrix<double, -1, -1>::Constant(K, K,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 22;
      chol_fac_corr_test = in__.template read_constrain_cholesky_factor_corr<
                             stan::conditional_var_value_t<local_scalar_t__, 
                               Eigen::Matrix<local_scalar_t__, -1, -1>>, 
                             jacobian__>(lp__, K);
      local_scalar_t__ phi = DUMMY_VAR__;
      current_statement__ = 23;
      phi = stan::math::fma(phi_beta, 2.0, -1.0);
      local_scalar_t__ sigma = DUMMY_VAR__;
      current_statement__ = 24;
      sigma = stan::math::sqrt(sigma2);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> prices =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 25;
      stan::model::assign(prices, stan::math::add(mid_price, high_low_est),
        "assigning variable prices");
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> prices_diff =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(Nr,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 26;
      stan::model::assign(prices_diff,
        stan::math::subtract(
          stan::model::rvalue(prices, "prices",
            stan::model::index_min_max(2, N)),
          stan::model::rvalue(prices, "prices",
            stan::model::index_min_max(1, (N - 1)))),
        "assigning variable prices_diff");
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> mu =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(Nr,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 27;
      stan::model::assign(mu,
        stan::math::add(Intercept, stan::math::multiply(X_all, b)),
        "assigning variable mu");
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> err =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(Nr,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 32;
      stan::model::assign(err, stan::math::subtract(prices_diff, mu),
        "assigning variable err");
      current_statement__ = 33;
      stan::model::assign(mu,
        stan::math::add(
          stan::model::deep_copy(
            stan::model::rvalue(mu, "mu", stan::model::index_min_max(2, Nr))),
          stan::math::add(
            stan::math::multiply(
              stan::model::rvalue(err, "err",
                stan::model::index_min_max(1, (Nr - 1))), ma),
            stan::math::multiply(
              stan::model::rvalue(prices_diff, "prices_diff",
                stan::model::index_min_max(1, (Nr - 1))),
              stan::model::rvalue(ar, "ar", stan::model::index_uni(1))))),
        "assigning variable mu", stan::model::index_min_max(2, Nr));
      current_statement__ = 34;
      stan::model::assign(mu,
        stan::math::add(
          stan::model::deep_copy(
            stan::model::rvalue(mu, "mu", stan::model::index_min_max(3, Nr))),
          stan::math::multiply(
            stan::model::rvalue(prices_diff, "prices_diff",
              stan::model::index_min_max(1, (Nr - 2))),
            stan::model::rvalue(ar, "ar", stan::model::index_uni(2)))),
        "assigning variable mu", stan::model::index_min_max(3, Nr));
      current_statement__ = 35;
      stan::model::assign(err, stan::math::subtract(prices_diff, mu),
        "assigning variable err");
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> h_i_mean =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(Nr,
             std::numeric_limits<double>::quiet_NaN()));
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> h_i_sigma =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(Nr,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 36;
      stan::model::assign(h_i_mean, 0.0,
        "assigning variable h_i_mean", stan::model::index_uni(1));
      current_statement__ = 37;
      stan::model::assign(h_i_sigma,
        stan::math::pow((1 - stan::math::square(phi)), -0.5),
        "assigning variable h_i_sigma", stan::model::index_uni(1));
      current_statement__ = 38;
      stan::model::assign(h_i_sigma, rep_vector(1.0, (Nr - 1)),
        "assigning variable h_i_sigma", stan::model::index_min_max(2, Nr));
      current_statement__ = 39;
      stan::model::assign(h_i_mean,
        stan::math::add(
          stan::math::multiply(phi,
            stan::model::rvalue(h, "h",
              stan::model::index_min_max(1, (Nr - 1)))),
          stan::math::multiply(theta,
            stan::math::square(
              stan::model::rvalue(err, "err",
                stan::model::index_min_max(1, (Nr - 1)))))),
        "assigning variable h_i_mean", stan::model::index_min_max(2, Nr));
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> h_sigma =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(Nr,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 31;
      stan::model::assign(h_sigma,
        stan::math::add(
          stan::math::exp(
            stan::math::add(stan::math::multiply(h, (0.5 * sigma)),
              stan::math::multiply(0.5, mu))), 0.000001),
        "assigning variable h_sigma");
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "phi", phi, -1);
      current_statement__ = 23;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 24;
      stan::math::check_greater_or_equal(function__, "sigma", sigma, 0);
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "h_i_sigma", h_i_sigma,
                                            0);
      {
        current_statement__ = 40;
        lp_accum__.add(stan::math::multiply(-2, stan::math::log(sigma_price)));
        current_statement__ = 41;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(Intercept, mu_prior_mu,
            mu_prior_sigma));
        current_statement__ = 42;
        lp_accum__.add(
          stan::math::beta_lpdf<propto__>(phi_beta, phi_prior_a, phi_prior_b));
        current_statement__ = 43;
        lp_accum__.add(
          stan::math::gamma_lpdf<propto__>(sigma2, sigma_prior_shape,
            sigma_prior_rate));
        current_statement__ = 44;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(ar, 0, .2));
        current_statement__ = 45;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(ma, 0, .2));
        current_statement__ = 46;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(h, h_i_mean, h_i_sigma));
        current_statement__ = 47;
        lp_accum__.add(
          stan::math::student_t_lpdf<propto__>(sigma_price, 3, 1, 1));
        current_statement__ = 48;
        lp_accum__.add(
          stan::math::uniform_lpdf<propto__>(high_low_est, diff_low_mid,
            diff_high_mid));
        current_statement__ = 49;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(prices, mean_price, sigma_price));
        current_statement__ = 50;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(prices_diff, mu, h_sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "constraints_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, 1> high_low_est =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      high_low_est = in__.template read_constrain_lub<
                       Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                       diff_low_mid, diff_high_mid, lp__, N);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "high_low_est",
                                      high_low_est, "lower", diff_low_mid);
      current_statement__ = 1;
      stan::math::check_matching_dims("constraint", "high_low_est",
                                      high_low_est, "upper", diff_high_mid);
      Eigen::Matrix<double, -1, 1> b =
         Eigen::Matrix<double, -1, 1>::Constant(K,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(K);
      Eigen::Matrix<double, -1, 1> h =
         Eigen::Matrix<double, -1, 1>::Constant(Nr,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      h = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(Nr);
      Eigen::Matrix<double, -1, 1> ar =
         Eigen::Matrix<double, -1, 1>::Constant(2,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 4;
      ar = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(2);
      double ma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      ma = in__.template read<local_scalar_t__>();
      double phi_beta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 6;
      phi_beta = in__.template read_constrain_lub<local_scalar_t__, 
                   jacobian__>(0, 1, lp__);
      double sigma2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 7;
      sigma2 = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                 0, lp__);
      double Intercept = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 8;
      Intercept = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, 1> mean_price =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 9;
      mean_price = in__.template read<
                     Eigen::Matrix<local_scalar_t__, -1, 1>>(N);
      Eigen::Matrix<double, -1, 1> sigma_price =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 10;
      sigma_price = in__.template read_constrain_lb<
                      Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                      0.0, lp__, N);
      double theta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 11;
      theta = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, 1> upper_test =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 12;
      upper_test = in__.template read_constrain_ub<
                     Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(ma,
                     lp__, N);
      Eigen::Matrix<double, -1, 1> lower_upper_test =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 13;
      lower_upper_test = in__.template read_constrain_lub<
                           Eigen::Matrix<local_scalar_t__, -1, 1>, 
                           jacobian__>(sigma_price, upper_test, lp__, N);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "lower_upper_test",
                                      lower_upper_test, "lower", sigma_price);
      current_statement__ = 13;
      stan::math::check_matching_dims("constraint", "lower_upper_test",
                                      lower_upper_test, "upper", upper_test);
      Eigen::Matrix<double, 1, -1> row_vec_lower_upper_test =
         Eigen::Matrix<double, 1, -1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 14;
      row_vec_lower_upper_test = in__.template read_constrain_lub<
                                   Eigen::Matrix<local_scalar_t__, 1, -1>, 
                                   jacobian__>(
                                   stan::math::transpose(sigma_price),
                                   stan::math::transpose(upper_test), lp__,
                                   N);
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint",
                                      "row_vec_lower_upper_test",
                                      row_vec_lower_upper_test, "lower",
                                      stan::math::transpose(sigma_price));
      current_statement__ = 14;
      stan::math::check_matching_dims("constraint",
                                      "row_vec_lower_upper_test",
                                      row_vec_lower_upper_test, "upper",
                                      stan::math::transpose(upper_test));
      Eigen::Matrix<double, -1, 1> offset_mult_test =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 15;
      offset_mult_test = in__.template read_constrain_offset_multiplier<
                           Eigen::Matrix<local_scalar_t__, -1, 1>, 
                           jacobian__>(mean_price, sigma_price, lp__, N);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "offset_mult_test",
                                      offset_mult_test, "offset", mean_price);
      current_statement__ = 15;
      stan::math::check_matching_dims("constraint", "offset_mult_test",
                                      offset_mult_test, "multiplier",
                                      sigma_price);
      Eigen::Matrix<double, -1, 1> ordered_test =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 16;
      ordered_test = in__.template read_constrain_ordered<
                       Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                       lp__, N);
      Eigen::Matrix<double, -1, 1> unit_vec_test =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 17;
      unit_vec_test = in__.template read_constrain_unit_vector<
                        Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                        lp__, N);
      Eigen::Matrix<double, -1, 1> pos_ordered_test =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 18;
      pos_ordered_test = in__.template read_constrain_positive_ordered<
                           Eigen::Matrix<local_scalar_t__, -1, 1>, 
                           jacobian__>(lp__, N);
      Eigen::Matrix<double, -1, -1> corr_matrix_test =
         Eigen::Matrix<double, -1, -1>::Constant(N, N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 19;
      corr_matrix_test = in__.template read_constrain_corr_matrix<
                           Eigen::Matrix<local_scalar_t__, -1, -1>, 
                           jacobian__>(lp__, N);
      Eigen::Matrix<double, -1, -1> cov_matrix_test =
         Eigen::Matrix<double, -1, -1>::Constant(N, N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 20;
      cov_matrix_test = in__.template read_constrain_cov_matrix<
                          Eigen::Matrix<local_scalar_t__, -1, -1>, 
                          jacobian__>(lp__, N);
      Eigen::Matrix<double, -1, -1> chol_fac_cov_test =
         Eigen::Matrix<double, -1, -1>::Constant(K, K,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 21;
      chol_fac_cov_test = in__.template read_constrain_cholesky_factor_cov<
                            Eigen::Matrix<local_scalar_t__, -1, -1>, 
                            jacobian__>(lp__, K, K);
      Eigen::Matrix<double, -1, -1> chol_fac_corr_test =
         Eigen::Matrix<double, -1, -1>::Constant(K, K,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 22;
      chol_fac_corr_test = in__.template read_constrain_cholesky_factor_corr<
                             Eigen::Matrix<local_scalar_t__, -1, -1>, 
                             jacobian__>(lp__, K);
      double phi = std::numeric_limits<double>::quiet_NaN();
      double sigma = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double, -1, 1> prices =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> prices_diff =
         Eigen::Matrix<double, -1, 1>::Constant(Nr,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> mu =
         Eigen::Matrix<double, -1, 1>::Constant(Nr,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> err =
         Eigen::Matrix<double, -1, 1>::Constant(Nr,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> h_i_mean =
         Eigen::Matrix<double, -1, 1>::Constant(Nr,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> h_i_sigma =
         Eigen::Matrix<double, -1, 1>::Constant(Nr,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> h_sigma =
         Eigen::Matrix<double, -1, 1>::Constant(Nr,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(high_low_est);
      out__.write(b);
      out__.write(h);
      out__.write(ar);
      out__.write(ma);
      out__.write(phi_beta);
      out__.write(sigma2);
      out__.write(Intercept);
      out__.write(mean_price);
      out__.write(sigma_price);
      out__.write(theta);
      out__.write(upper_test);
      out__.write(lower_upper_test);
      out__.write(row_vec_lower_upper_test);
      out__.write(offset_mult_test);
      out__.write(ordered_test);
      out__.write(unit_vec_test);
      out__.write(pos_ordered_test);
      out__.write(corr_matrix_test);
      out__.write(cov_matrix_test);
      out__.write(chol_fac_cov_test);
      out__.write(chol_fac_corr_test);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 23;
      phi = stan::math::fma(phi_beta, 2.0, -1.0);
      current_statement__ = 24;
      sigma = stan::math::sqrt(sigma2);
      current_statement__ = 25;
      stan::model::assign(prices, stan::math::add(mid_price, high_low_est),
        "assigning variable prices");
      current_statement__ = 26;
      stan::model::assign(prices_diff,
        stan::math::subtract(
          stan::model::rvalue(prices, "prices",
            stan::model::index_min_max(2, N)),
          stan::model::rvalue(prices, "prices",
            stan::model::index_min_max(1, (N - 1)))),
        "assigning variable prices_diff");
      current_statement__ = 27;
      stan::model::assign(mu,
        stan::math::add(Intercept, stan::math::multiply(X_all, b)),
        "assigning variable mu");
      current_statement__ = 32;
      stan::model::assign(err, stan::math::subtract(prices_diff, mu),
        "assigning variable err");
      current_statement__ = 33;
      stan::model::assign(mu,
        stan::math::add(
          stan::model::deep_copy(
            stan::model::rvalue(mu, "mu", stan::model::index_min_max(2, Nr))),
          stan::math::add(
            stan::math::multiply(
              stan::model::rvalue(err, "err",
                stan::model::index_min_max(1, (Nr - 1))), ma),
            stan::math::multiply(
              stan::model::rvalue(prices_diff, "prices_diff",
                stan::model::index_min_max(1, (Nr - 1))),
              stan::model::rvalue(ar, "ar", stan::model::index_uni(1))))),
        "assigning variable mu", stan::model::index_min_max(2, Nr));
      current_statement__ = 34;
      stan::model::assign(mu,
        stan::math::add(
          stan::model::deep_copy(
            stan::model::rvalue(mu, "mu", stan::model::index_min_max(3, Nr))),
          stan::math::multiply(
            stan::model::rvalue(prices_diff, "prices_diff",
              stan::model::index_min_max(1, (Nr - 2))),
            stan::model::rvalue(ar, "ar", stan::model::index_uni(2)))),
        "assigning variable mu", stan::model::index_min_max(3, Nr));
      current_statement__ = 35;
      stan::model::assign(err, stan::math::subtract(prices_diff, mu),
        "assigning variable err");
      current_statement__ = 36;
      stan::model::assign(h_i_mean, 0.0,
        "assigning variable h_i_mean", stan::model::index_uni(1));
      current_statement__ = 37;
      stan::model::assign(h_i_sigma,
        stan::math::pow((1 - stan::math::square(phi)), -0.5),
        "assigning variable h_i_sigma", stan::model::index_uni(1));
      current_statement__ = 38;
      stan::model::assign(h_i_sigma, stan::math::rep_vector(1.0, (Nr - 1)),
        "assigning variable h_i_sigma", stan::model::index_min_max(2, Nr));
      current_statement__ = 39;
      stan::model::assign(h_i_mean,
        stan::math::add(
          stan::math::multiply(phi,
            stan::model::rvalue(h, "h",
              stan::model::index_min_max(1, (Nr - 1)))),
          stan::math::multiply(theta,
            stan::math::square(
              stan::model::rvalue(err, "err",
                stan::model::index_min_max(1, (Nr - 1)))))),
        "assigning variable h_i_mean", stan::model::index_min_max(2, Nr));
      current_statement__ = 31;
      stan::model::assign(h_sigma,
        stan::math::add(
          stan::math::exp(
            stan::math::add(stan::math::multiply(h, (0.5 * sigma)),
              stan::math::multiply(0.5, mu))), 0.000001),
        "assigning variable h_sigma");
      current_statement__ = 23;
      stan::math::check_greater_or_equal(function__, "phi", phi, -1);
      current_statement__ = 23;
      stan::math::check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 24;
      stan::math::check_greater_or_equal(function__, "sigma", sigma, 0);
      current_statement__ = 30;
      stan::math::check_greater_or_equal(function__, "h_i_sigma", h_i_sigma,
                                            0);
      if (emit_transformed_parameters__) {
        out__.write(phi);
        out__.write(sigma);
        out__.write(prices);
        out__.write(prices_diff);
        out__.write(mu);
        out__.write(err);
        out__.write(h_i_mean);
        out__.write(h_i_sigma);
        out__.write(h_sigma);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, 1> high_low_est =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(high_low_est, in__.read<local_scalar_t__>(),
          "assigning variable high_low_est", stan::model::index_uni(sym1__));
      }
      out__.write_free_lub(diff_low_mid, diff_high_mid, high_low_est);
      Eigen::Matrix<local_scalar_t__, -1, 1> b =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(K, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        stan::model::assign(b, in__.read<local_scalar_t__>(),
          "assigning variable b", stan::model::index_uni(sym1__));
      }
      out__.write(b);
      Eigen::Matrix<local_scalar_t__, -1, 1> h =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(Nr, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        stan::model::assign(h, in__.read<local_scalar_t__>(),
          "assigning variable h", stan::model::index_uni(sym1__));
      }
      out__.write(h);
      Eigen::Matrix<local_scalar_t__, -1, 1> ar =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(2, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        stan::model::assign(ar, in__.read<local_scalar_t__>(),
          "assigning variable ar", stan::model::index_uni(sym1__));
      }
      out__.write(ar);
      local_scalar_t__ ma = DUMMY_VAR__;
      ma = in__.read<local_scalar_t__>();
      out__.write(ma);
      local_scalar_t__ phi_beta = DUMMY_VAR__;
      phi_beta = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, phi_beta);
      local_scalar_t__ sigma2 = DUMMY_VAR__;
      sigma2 = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigma2);
      local_scalar_t__ Intercept = DUMMY_VAR__;
      Intercept = in__.read<local_scalar_t__>();
      out__.write(Intercept);
      Eigen::Matrix<local_scalar_t__, -1, 1> mean_price =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(mean_price, in__.read<local_scalar_t__>(),
          "assigning variable mean_price", stan::model::index_uni(sym1__));
      }
      out__.write(mean_price);
      Eigen::Matrix<local_scalar_t__, -1, 1> sigma_price =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(sigma_price, in__.read<local_scalar_t__>(),
          "assigning variable sigma_price", stan::model::index_uni(sym1__));
      }
      out__.write_free_lb(0.0, sigma_price);
      local_scalar_t__ theta = DUMMY_VAR__;
      theta = in__.read<local_scalar_t__>();
      out__.write(theta);
      Eigen::Matrix<local_scalar_t__, -1, 1> upper_test =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(upper_test, in__.read<local_scalar_t__>(),
          "assigning variable upper_test", stan::model::index_uni(sym1__));
      }
      out__.write_free_ub(ma, upper_test);
      Eigen::Matrix<local_scalar_t__, -1, 1> lower_upper_test =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(lower_upper_test, in__.read<local_scalar_t__>(),
          "assigning variable lower_upper_test", stan::model::index_uni(sym1__));
      }
      out__.write_free_lub(sigma_price, upper_test, lower_upper_test);
      Eigen::Matrix<local_scalar_t__, 1, -1> row_vec_lower_upper_test =
         Eigen::Matrix<local_scalar_t__, 1, -1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(row_vec_lower_upper_test,
          in__.read<local_scalar_t__>(),
          "assigning variable row_vec_lower_upper_test", stan::model::index_uni(sym1__));
      }
      out__.write_free_lub(stan::math::transpose(sigma_price),
        stan::math::transpose(upper_test), row_vec_lower_upper_test);
      Eigen::Matrix<local_scalar_t__, -1, 1> offset_mult_test =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(offset_mult_test, in__.read<local_scalar_t__>(),
          "assigning variable offset_mult_test", stan::model::index_uni(sym1__));
      }
      out__.write_free_offset_multiplier(mean_price, sigma_price,
        offset_mult_test);
      Eigen::Matrix<local_scalar_t__, -1, 1> ordered_test =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(ordered_test, in__.read<local_scalar_t__>(),
          "assigning variable ordered_test", stan::model::index_uni(sym1__));
      }
      out__.write_free_ordered(ordered_test);
      Eigen::Matrix<local_scalar_t__, -1, 1> unit_vec_test =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(unit_vec_test, in__.read<local_scalar_t__>(),
          "assigning variable unit_vec_test", stan::model::index_uni(sym1__));
      }
      out__.write_free_unit_vector(unit_vec_test);
      Eigen::Matrix<local_scalar_t__, -1, 1> pos_ordered_test =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(pos_ordered_test, in__.read<local_scalar_t__>(),
          "assigning variable pos_ordered_test", stan::model::index_uni(sym1__));
      }
      out__.write_free_positive_ordered(pos_ordered_test);
      Eigen::Matrix<local_scalar_t__, -1, -1> corr_matrix_test =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          stan::model::assign(corr_matrix_test,
            in__.read<local_scalar_t__>(),
            "assigning variable corr_matrix_test", stan::model::index_uni(sym2__),
                                                     stan::model::index_uni(sym1__));
        }
      }
      out__.write_free_corr_matrix(corr_matrix_test);
      Eigen::Matrix<local_scalar_t__, -1, -1> cov_matrix_test =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          stan::model::assign(cov_matrix_test, in__.read<local_scalar_t__>(),
            "assigning variable cov_matrix_test", stan::model::index_uni(sym2__),
                                                    stan::model::index_uni(sym1__));
        }
      }
      out__.write_free_cov_matrix(cov_matrix_test);
      Eigen::Matrix<local_scalar_t__, -1, -1> chol_fac_cov_test =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(K, K, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          stan::model::assign(chol_fac_cov_test,
            in__.read<local_scalar_t__>(),
            "assigning variable chol_fac_cov_test", stan::model::index_uni(sym2__),
                                                      stan::model::index_uni(sym1__));
        }
      }
      out__.write_free_cholesky_factor_cov(chol_fac_cov_test);
      Eigen::Matrix<local_scalar_t__, -1, -1> chol_fac_corr_test =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(K, K, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          stan::model::assign(chol_fac_corr_test,
            in__.read<local_scalar_t__>(),
            "assigning variable chol_fac_corr_test", stan::model::index_uni(sym2__),
                                                       stan::model::index_uni(sym1__));
        }
      }
      out__.write_free_cholesky_factor_corr(chol_fac_corr_test);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"high_low_est", "b", "h", "ar", "ma",
      "phi_beta", "sigma2", "Intercept", "mean_price", "sigma_price",
      "theta", "upper_test", "lower_upper_test", "row_vec_lower_upper_test",
      "offset_mult_test", "ordered_test", "unit_vec_test",
      "pos_ordered_test", "corr_matrix_test", "cov_matrix_test",
      "chol_fac_cov_test", "chol_fac_corr_test", "phi", "sigma", "prices",
      "prices_diff", "mu", "err", "h_i_mean", "h_i_sigma", "h_sigma"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(N)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(K)},
      std::vector<size_t>{static_cast<size_t>(Nr)},
      std::vector<size_t>{static_cast<size_t>(2)}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)}, std::vector<size_t>{
      }, std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(K), static_cast<size_t>(K)},
      std::vector<size_t>{static_cast<size_t>(K), static_cast<size_t>(K)},
      std::vector<size_t>{}, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(Nr)},
      std::vector<size_t>{static_cast<size_t>(Nr)},
      std::vector<size_t>{static_cast<size_t>(Nr)},
      std::vector<size_t>{static_cast<size_t>(Nr)},
      std::vector<size_t>{static_cast<size_t>(Nr)},
      std::vector<size_t>{static_cast<size_t>(Nr)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "high_low_est" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "h" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "ar" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "ma");
    param_names__.emplace_back(std::string() + "phi_beta");
    param_names__.emplace_back(std::string() + "sigma2");
    param_names__.emplace_back(std::string() + "Intercept");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "mean_price" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma_price" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "theta");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "upper_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "lower_upper_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "row_vec_lower_upper_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "offset_mult_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "ordered_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "unit_vec_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pos_ordered_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "corr_matrix_test" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "cov_matrix_test" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "chol_fac_cov_test" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "chol_fac_corr_test" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "phi");
      param_names__.emplace_back(std::string() + "sigma");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "prices" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "prices_diff" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "mu" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "err" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "h_i_mean" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "h_i_sigma" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "h_sigma" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "high_low_est" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "h" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "ar" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "ma");
    param_names__.emplace_back(std::string() + "phi_beta");
    param_names__.emplace_back(std::string() + "sigma2");
    param_names__.emplace_back(std::string() + "Intercept");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "mean_price" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma_price" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "theta");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "upper_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "lower_upper_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "row_vec_lower_upper_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "offset_mult_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "ordered_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "unit_vec_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pos_ordered_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= ((N * (N - 1)) / 2); ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "corr_matrix_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= (N + ((N * (N - 1)) / 2)); ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "cov_matrix_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1;
         sym1__ <= ((((K * (K - 1)) / 2) + K) + ((K - K) * K)); ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "chol_fac_cov_test" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= ((K * (K - 1)) / 2); ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "chol_fac_corr_test" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "phi");
      param_names__.emplace_back(std::string() + "sigma");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "prices" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "prices_diff" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "mu" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "err" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "h_i_mean" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "h_i_sigma" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= Nr; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "h_sigma" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"high_low_est\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"h\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"parameters\"},{\"name\":\"ar\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"ma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_price\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"sigma_price\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"upper_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"lower_upper_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"row_vec_lower_upper_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"offset_mult_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"ordered_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"unit_vec_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"pos_ordered_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"corr_matrix_test\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"cov_matrix_test\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"chol_fac_cov_test\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(K) + ",\"cols\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"chol_fac_corr_test\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(K) + ",\"cols\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"prices\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"prices_diff\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"err\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"h_i_mean\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"h_i_sigma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"h_sigma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"high_low_est\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"h\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"parameters\"},{\"name\":\"ar\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "},\"block\":\"parameters\"},{\"name\":\"ma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_price\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"sigma_price\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"upper_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"lower_upper_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"row_vec_lower_upper_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"offset_mult_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"ordered_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"unit_vec_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"pos_ordered_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"corr_matrix_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((N * (N - 1)) / 2)) + "},\"block\":\"parameters\"},{\"name\":\"cov_matrix_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((N + ((N * (N - 1)) / 2))) + "},\"block\":\"parameters\"},{\"name\":\"chol_fac_cov_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((((K * (K - 1)) / 2) + K) + ((K - K) * K))) + "},\"block\":\"parameters\"},{\"name\":\"chol_fac_corr_test\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((K * (K - 1)) / 2)) + "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"prices\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"transformed_parameters\"},{\"name\":\"prices_diff\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"err\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"h_i_mean\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"h_i_sigma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"},{\"name\":\"h_sigma\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(Nr) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((((((((((((((((((N + K) + Nr) + 2) + 1) + 1) + 1) + 1) + N) + N) + 1) +
              N) + N) + N) + N) + N) + N) + N) + (N * N)) + (N * N)) +
     (K * K)) + (K * K));
      const size_t num_transformed = ((((((((1 + 1)
                                                                    + N) +
                                                                    Nr) + Nr)
                                                                    + Nr) +
                                                                   Nr) + Nr)
                                                                 + Nr);
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((((((((((((((((((((N + K) + Nr) + 2) + 1) + 1) + 1) + 1) + N) + N) + 1) +
              N) + N) + N) + N) + N) + N) + N) + (N * N)) + (N * N)) +
     (K * K)) + (K * K));
      const size_t num_transformed = ((((((((1 + 1)
                                                                    + N) +
                                                                    Nr) + Nr)
                                                                    + Nr) +
                                                                   Nr) + Nr)
                                                                 + Nr);
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 22> names__{"high_low_est", "b", "h",
      "ar", "ma", "phi_beta", "sigma2", "Intercept", "mean_price",
      "sigma_price", "theta", "upper_test", "lower_upper_test",
      "row_vec_lower_upper_test", "offset_mult_test", "ordered_test",
      "unit_vec_test", "pos_ordered_test", "corr_matrix_test",
      "cov_matrix_test", "chol_fac_cov_test", "chol_fac_corr_test"};
      const std::array<Eigen::Index, 22> constrain_param_sizes__{N, K, 
       Nr, 2, 1, 1, 1, 1, N, N, 1, N, N, N, N, N, N, N, (N * N), (N * N),
       (K * K), (K * K)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = constraints_model_namespace::constraints_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return constraints_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp deep_dependence.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace deep_dependence_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 14> locations_array__ = 
{" (found before start of program)",
 " (in 'deep_dependence.stan', line 6, column 4 to column 23)",
 " (in 'deep_dependence.stan', line 10, column 4 to column 36)",
 " (in 'deep_dependence.stan', line 11, column 4 to column 38)",
 " (in 'deep_dependence.stan', line 12, column 4 to column 38)",
 " (in 'deep_dependence.stan', line 13, column 4 to column 38)",
 " (in 'deep_dependence.stan', line 14, column 4 to column 38)",
 " (in 'deep_dependence.stan', line 15, column 4 to column 38)",
 " (in 'deep_dependence.stan', line 16, column 4 to column 38)",
 " (in 'deep_dependence.stan', line 19, column 12 to column 43)",
 " (in 'deep_dependence.stan', line 18, column 23 to line 20, column 9)",
 " (in 'deep_dependence.stan', line 18, column 8 to line 20, column 9)",
 " (in 'deep_dependence.stan', line 17, column 19 to line 21, column 5)",
 " (in 'deep_dependence.stan', line 17, column 4 to line 21, column 5)"};




class deep_dependence_model final : public model_base_crtp<deep_dependence_model> {

 private:
   
  
 
 public:
  ~deep_dependence_model() { }
  
  inline std::string model_name() const final { return "deep_dependence_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = -fsoa --print-cpp"};
  }
  
  
  deep_dependence_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "deep_dependence_model_namespace::deep_dependence_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (10 * 10);
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "deep_dependence_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, -1> X_p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
              10);
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp1 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(X_tp1, stan::math::exp(X_p),
        "assigning variable X_tp1");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp2 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(X_tp2, stan::math::exp(X_tp1),
        "assigning variable X_tp2");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp3 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(X_tp3, stan::math::exp(X_tp2),
        "assigning variable X_tp3");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp4 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(X_tp4, stan::math::exp(X_tp3),
        "assigning variable X_tp4");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp5 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(X_tp5, stan::math::exp(X_tp4),
        "assigning variable X_tp5");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp6 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(X_tp6, stan::math::exp(X_tp5),
        "assigning variable X_tp6");
      Eigen::Matrix<local_scalar_t__, -1, -1> X_tp7 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(X_tp7, stan::math::exp(X_tp6),
        "assigning variable X_tp7");
      current_statement__ = 13;
      for (int i = 1; i <= 5; ++i) {
        current_statement__ = 11;
        for (int j = 1; j <= 5; ++j) {
          current_statement__ = 9;
          stan::model::assign(X_tp7,
            stan::math::exp(
              stan::model::rvalue(X_tp7, "X_tp7",
                stan::model::index_uni(i), stan::model::index_uni(j))),
            "assigning variable X_tp7", stan::model::index_uni(i),
                                          stan::model::index_uni(j));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "deep_dependence_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, -1> X_p =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      X_p = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
              10);
      Eigen::Matrix<double, -1, -1> X_tp1 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp2 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp3 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp4 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp5 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp6 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> X_tp7 =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(X_p);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 2;
      stan::model::assign(X_tp1, stan::math::exp(X_p),
        "assigning variable X_tp1");
      current_statement__ = 3;
      stan::model::assign(X_tp2, stan::math::exp(X_tp1),
        "assigning variable X_tp2");
      current_statement__ = 4;
      stan::model::assign(X_tp3, stan::math::exp(X_tp2),
        "assigning variable X_tp3");
      current_statement__ = 5;
      stan::model::assign(X_tp4, stan::math::exp(X_tp3),
        "assigning variable X_tp4");
      current_statement__ = 6;
      stan::model::assign(X_tp5, stan::math::exp(X_tp4),
        "assigning variable X_tp5");
      current_statement__ = 7;
      stan::model::assign(X_tp6, stan::math::exp(X_tp5),
        "assigning variable X_tp6");
      current_statement__ = 8;
      stan::model::assign(X_tp7, stan::math::exp(X_tp6),
        "assigning variable X_tp7");
      current_statement__ = 13;
      for (int i = 1; i <= 5; ++i) {
        current_statement__ = 11;
        for (int j = 1; j <= 5; ++j) {
          current_statement__ = 9;
          stan::model::assign(X_tp7,
            stan::math::exp(
              stan::model::rvalue(X_tp7, "X_tp7",
                stan::model::index_uni(i), stan::model::index_uni(j))),
            "assigning variable X_tp7", stan::model::index_uni(i),
                                          stan::model::index_uni(j));
        }
      }
      if (emit_transformed_parameters__) {
        out__.write(X_tp1);
        out__.write(X_tp2);
        out__.write(X_tp3);
        out__.write(X_tp4);
        out__.write(X_tp5);
        out__.write(X_tp6);
        out__.write(X_tp7);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, -1> X_p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          stan::model::assign(X_p, in__.read<local_scalar_t__>(),
            "assigning variable X_p", stan::model::index_uni(sym2__),
                                        stan::model::index_uni(sym1__));
        }
      }
      out__.write(X_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"X_p", "X_tp1", "X_tp2", "X_tp3",
      "X_tp4", "X_tp5", "X_tp6", "X_tp7"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(10)
                                                                   ,
                                                                   static_cast<size_t>(10)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "X_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp3" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp4" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp5" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp6" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp7" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "X_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp3" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp4" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp5" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp6" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "X_tp7" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"X_tp1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp3\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp4\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp5\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp6\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp7\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"X_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"X_tp1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp3\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp4\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp5\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp6\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"X_tp7\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (10 * 10);
      const size_t num_transformed = (((((((10 * 10) +
                                                         (10 * 10)) +
                                                        (10 * 10)) +
                                                       (10 * 10)) +
                                                      (10 * 10)) + (10 * 10))
                                                    + (10 * 10));
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (10 * 10);
      const size_t num_transformed = (((((((10 * 10) +
                                                         (10 * 10)) +
                                                        (10 * 10)) +
                                                       (10 * 10)) +
                                                      (10 * 10)) + (10 * 10))
                                                    + (10 * 10));
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 1> names__{"X_p"};
      const std::array<Eigen::Index, 1> constrain_param_sizes__{(10 * 10)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = deep_dependence_model_namespace::deep_dependence_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return deep_dependence_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp indexing.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace indexing_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 116> locations_array__ = 
{" (found before start of program)",
 " (in 'indexing.stan', line 19, column 2 to column 13)",
 " (in 'indexing.stan', line 21, column 2 to column 24)",
 " (in 'indexing.stan', line 22, column 2 to column 25)",
 " (in 'indexing.stan', line 23, column 2 to column 38)",
 " (in 'indexing.stan', line 24, column 2 to column 36)",
 " (in 'indexing.stan', line 25, column 2 to column 30)",
 " (in 'indexing.stan', line 26, column 2 to column 41)",
 " (in 'indexing.stan', line 27, column 2 to column 35)",
 " (in 'indexing.stan', line 28, column 2 to column 31)",
 " (in 'indexing.stan', line 29, column 2 to column 48)",
 " (in 'indexing.stan', line 30, column 2 to column 47)",
 " (in 'indexing.stan', line 33, column 2 to column 38)",
 " (in 'indexing.stan', line 35, column 2 to column 38)",
 " (in 'indexing.stan', line 37, column 2 to column 37)",
 " (in 'indexing.stan', line 39, column 2 to column 43)",
 " (in 'indexing.stan', line 40, column 2 to column 41)",
 " (in 'indexing.stan', line 43, column 2 to column 25)",
 " (in 'indexing.stan', line 45, column 2 to column 57)",
 " (in 'indexing.stan', line 46, column 2 to column 57)",
 " (in 'indexing.stan', line 49, column 2 to column 43)",
 " (in 'indexing.stan', line 50, column 2 to column 43)",
 " (in 'indexing.stan', line 56, column 2 to column 41)",
 " (in 'indexing.stan', line 59, column 2 to column 62)",
 " (in 'indexing.stan', line 61, column 2 to column 37)",
 " (in 'indexing.stan', line 66, column 2 to column 63)",
 " (in 'indexing.stan', line 70, column 2 to column 44)",
 " (in 'indexing.stan', line 62, column 2 to column 49)",
 " (in 'indexing.stan', line 63, column 2 to column 70)",
 " (in 'indexing.stan', line 68, column 2 to column 45)",
 " (in 'indexing.stan', line 71, column 2 to column 75)",
 " (in 'indexing.stan', line 75, column 9 to column 10)",
 " (in 'indexing.stan', line 75, column 2 to column 108)",
 " (in 'indexing.stan', line 76, column 2 to column 95)",
 " (in 'indexing.stan', line 77, column 2 to column 56)",
 " (in 'indexing.stan', line 78, column 2 to column 62)",
 " (in 'indexing.stan', line 79, column 2 to column 79)",
 " (in 'indexing.stan', line 80, column 2 to column 85)",
 " (in 'indexing.stan', line 81, column 2 to column 89)",
 " (in 'indexing.stan', line 82, column 2 to column 98)",
 " (in 'indexing.stan', line 83, column 2 to column 110)",
 " (in 'indexing.stan', line 86, column 9 to column 10)",
 " (in 'indexing.stan', line 86, column 2 to column 33)",
 " (in 'indexing.stan', line 87, column 2 to column 32)",
 " (in 'indexing.stan', line 88, column 9 to column 10)",
 " (in 'indexing.stan', line 88, column 2 to column 42)",
 " (in 'indexing.stan', line 89, column 2 to column 86)",
 " (in 'indexing.stan', line 93, column 4 to column 57)",
 " (in 'indexing.stan', line 94, column 4 to column 69)",
 " (in 'indexing.stan', line 95, column 4 to column 69)",
 " (in 'indexing.stan', line 96, column 4 to column 70)",
 " (in 'indexing.stan', line 97, column 4 to column 73)",
 " (in 'indexing.stan', line 98, column 4 to column 69)",
 " (in 'indexing.stan', line 99, column 4 to column 88)",
 " (in 'indexing.stan', line 100, column 4 to line 101, column 82)",
 " (in 'indexing.stan', line 102, column 4 to line 103, column 46)",
 " (in 'indexing.stan', line 92, column 18 to line 104, column 3)",
 " (in 'indexing.stan', line 92, column 2 to line 104, column 3)",
 " (in 'indexing.stan', line 107, column 9 to column 10)",
 " (in 'indexing.stan', line 107, column 2 to column 38)",
 " (in 'indexing.stan', line 108, column 9 to column 10)",
 " (in 'indexing.stan', line 108, column 2 to column 44)",
 " (in 'indexing.stan', line 111, column 4 to column 84)",
 " (in 'indexing.stan', line 112, column 4 to column 102)",
 " (in 'indexing.stan', line 114, column 4 to column 70)",
 " (in 'indexing.stan', line 115, column 4 to column 75)",
 " (in 'indexing.stan', line 116, column 4 to line 117, column 40)",
 " (in 'indexing.stan', line 109, column 17 to line 119, column 3)",
 " (in 'indexing.stan', line 109, column 2 to line 119, column 3)",
 " (in 'indexing.stan', line 11, column 1 to column 7)",
 " (in 'indexing.stan', line 12, column 1 to column 7)",
 " (in 'indexing.stan', line 13, column 8 to column 9)",
 " (in 'indexing.stan', line 13, column 11 to column 12)",
 " (in 'indexing.stan', line 13, column 1 to column 20)",
 " (in 'indexing.stan', line 14, column 8 to column 9)",
 " (in 'indexing.stan', line 14, column 1 to column 13)",
 " (in 'indexing.stan', line 15, column 7 to column 8)",
 " (in 'indexing.stan', line 15, column 1 to column 25)",
 " (in 'indexing.stan', line 21, column 9 to column 10)",
 " (in 'indexing.stan', line 22, column 9 to column 10)",
 " (in 'indexing.stan', line 22, column 12 to column 13)",
 " (in 'indexing.stan', line 23, column 19 to column 20)",
 " (in 'indexing.stan', line 24, column 9 to column 10)",
 " (in 'indexing.stan', line 24, column 11 to column 12)",
 " (in 'indexing.stan', line 25, column 9 to column 10)",
 " (in 'indexing.stan', line 26, column 9 to column 10)",
 " (in 'indexing.stan', line 26, column 11 to column 12)",
 " (in 'indexing.stan', line 27, column 13 to column 14)",
 " (in 'indexing.stan', line 28, column 9 to column 10)",
 " (in 'indexing.stan', line 29, column 9 to column 10)",
 " (in 'indexing.stan', line 30, column 9 to column 10)",
 " (in 'indexing.stan', line 30, column 11 to column 12)",
 " (in 'indexing.stan', line 33, column 9 to column 10)",
 " (in 'indexing.stan', line 35, column 9 to column 10)",
 " (in 'indexing.stan', line 37, column 9 to column 10)",
 " (in 'indexing.stan', line 39, column 9 to column 10)",
 " (in 'indexing.stan', line 40, column 9 to column 10)",
 " (in 'indexing.stan', line 40, column 11 to column 12)",
 " (in 'indexing.stan', line 43, column 9 to column 10)",
 " (in 'indexing.stan', line 43, column 12 to column 13)",
 " (in 'indexing.stan', line 45, column 9 to column 10)",
 " (in 'indexing.stan', line 45, column 12 to column 13)",
 " (in 'indexing.stan', line 46, column 9 to column 10)",
 " (in 'indexing.stan', line 46, column 12 to column 13)",
 " (in 'indexing.stan', line 49, column 9 to column 10)",
 " (in 'indexing.stan', line 49, column 12 to column 13)",
 " (in 'indexing.stan', line 50, column 9 to column 10)",
 " (in 'indexing.stan', line 50, column 12 to column 13)",
 " (in 'indexing.stan', line 59, column 9 to column 10)",
 " (in 'indexing.stan', line 61, column 9 to column 10)",
 " (in 'indexing.stan', line 66, column 9 to column 10)",
 " (in 'indexing.stan', line 70, column 9 to column 10)",
 " (in 'indexing.stan', line 3, column 4 to column 13)",
 " (in 'indexing.stan', line 2, column 22 to line 4, column 3)",
 " (in 'indexing.stan', line 6, column 4 to column 13)",
 " (in 'indexing.stan', line 5, column 27 to line 7, column 3)"};

struct mask_fun_functor__ {
  int
  operator()(const int& i, std::ostream* pstream__) const;
};
struct udf_fun_functor__ {
  template <typename T0__, stan::require_col_vector_t<T0__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
  operator()(const T0__& A, std::ostream* pstream__) const;
};

int mask_fun(const int& i, std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 112;
      return i;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, stan::require_col_vector_t<T0__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
  udf_fun(const T0__& A_arg__, std::ostream* pstream__) {
    using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
    int current_statement__ = 0; 
    const auto& A = stan::math::to_ref(A_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 114;
      return A;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
int mask_fun_functor__::operator()(const int& i, std::ostream* pstream__) 
const
{
  return mask_fun(i, pstream__);
}

template <typename T0__, stan::require_col_vector_t<T0__>*>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
udf_fun_functor__::operator()(const T0__& A, std::ostream* pstream__)  const
{
  return udf_fun(A, pstream__);
}

 class indexing_model final : public model_base_crtp<indexing_model> {

 private:
  int N;
  int M;
  Eigen::Matrix<double, -1, -1> dat_x__;
  Eigen::Matrix<double, -1, 1> y__;
  std::vector<int> idx_tester; 
  Eigen::Map<Eigen::Matrix<double, -1, -1>> dat_x{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> y{nullptr, 0};
 
 public:
  ~indexing_model() { }
  
  inline std::string model_name() const final { return "indexing_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = -fsoa --print-cpp"};
  }
  
  
  indexing_model(stan::io::var_context& context__,
                 unsigned int random_seed__ = 0,
                 std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "indexing_model_namespace::indexing_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 69;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      
      current_statement__ = 69;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 70;
      context__.validate_dims("data initialization","M","int",
           std::vector<size_t>{});
      M = std::numeric_limits<int>::min();
      
      
      current_statement__ = 70;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 71;
      stan::math::validate_non_negative_index("dat_x", "N", N);
      current_statement__ = 72;
      stan::math::validate_non_negative_index("dat_x", "M", M);
      current_statement__ = 73;
      context__.validate_dims("data initialization","dat_x","double",
           std::vector<size_t>{static_cast<size_t>(N),
            static_cast<size_t>(M)});
      dat_x__ = 
        Eigen::Matrix<double, -1, -1>::Constant(N, M,
          std::numeric_limits<double>::quiet_NaN());
      new (&dat_x) Eigen::Map<Eigen::Matrix<double, -1, -1>>(dat_x__.data(), N, M);
        
      
      {
        std::vector<local_scalar_t__> dat_x_flat__;
        current_statement__ = 73;
        dat_x_flat__ = context__.vals_r("dat_x");
        current_statement__ = 73;
        pos__ = 1;
        current_statement__ = 73;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          current_statement__ = 73;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 73;
            stan::model::assign(dat_x, dat_x_flat__[(pos__ - 1)],
              "assigning variable dat_x", stan::model::index_uni(sym2__),
                                            stan::model::index_uni(sym1__));
            current_statement__ = 73;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 74;
      stan::math::validate_non_negative_index("y", "N", N);
      current_statement__ = 75;
      context__.validate_dims("data initialization","y","double",
           std::vector<size_t>{static_cast<size_t>(N)});
      y__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N,
          std::numeric_limits<double>::quiet_NaN());
      new (&y) Eigen::Map<Eigen::Matrix<double, -1, 1>>(y__.data(), N);
      
      {
        std::vector<local_scalar_t__> y_flat__;
        current_statement__ = 75;
        y_flat__ = context__.vals_r("y");
        current_statement__ = 75;
        pos__ = 1;
        current_statement__ = 75;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 75;
          stan::model::assign(y, y_flat__[(pos__ - 1)],
            "assigning variable y", stan::model::index_uni(sym1__));
          current_statement__ = 75;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 76;
      stan::math::validate_non_negative_index("idx_tester", "N", N);
      current_statement__ = 77;
      context__.validate_dims("data initialization","idx_tester","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      idx_tester = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 77;
      idx_tester = context__.vals_i("idx_tester");
      current_statement__ = 78;
      stan::math::validate_non_negative_index("p_soa_vec_v", "M", M);
      current_statement__ = 79;
      stan::math::validate_non_negative_index("p_soa_mat", "N", N);
      current_statement__ = 80;
      stan::math::validate_non_negative_index("p_soa_mat", "M", M);
      current_statement__ = 81;
      stan::math::validate_non_negative_index("p_soa_arr_vec_v", "N", N);
      current_statement__ = 82;
      stan::math::validate_non_negative_index("p_soa_mat_uni_col_idx", "N", N);
      current_statement__ = 83;
      stan::math::validate_non_negative_index("p_soa_mat_uni_col_idx", "M", M);
      current_statement__ = 84;
      stan::math::validate_non_negative_index("p_soa_vec_uni_idx", "N", N);
      current_statement__ = 85;
      stan::math::validate_non_negative_index("p_soa_loop_mat_uni_col_idx",
                                              "N", N);
      current_statement__ = 86;
      stan::math::validate_non_negative_index("p_soa_loop_mat_uni_col_idx",
                                              "M", M);
      current_statement__ = 87;
      stan::math::validate_non_negative_index("p_soa_lhs_loop_mul", "N", N);
      current_statement__ = 88;
      stan::math::validate_non_negative_index("p_soa_rhs_loop_mul", "N", N);
      current_statement__ = 89;
      stan::math::validate_non_negative_index("p_soa_used_with_aos_in_excluded_fun",
                                              "N", N);
      current_statement__ = 90;
      stan::math::validate_non_negative_index("p_soa_loop_mat_multi_uni_uni_idx",
                                              "N", N);
      current_statement__ = 91;
      stan::math::validate_non_negative_index("p_soa_loop_mat_multi_uni_uni_idx",
                                              "M", M);
      current_statement__ = 92;
      stan::math::validate_non_negative_index("p_aos_vec_v_assign_to_aos",
                                              "M", M);
      current_statement__ = 93;
      stan::math::validate_non_negative_index("p_aos_vec_v_tp_fails_func",
                                              "M", M);
      current_statement__ = 94;
      stan::math::validate_non_negative_index("p_aos_loop_vec_v_uni_idx",
                                              "M", M);
      current_statement__ = 95;
      stan::math::validate_non_negative_index("p_aos_fail_assign_from_top_idx",
                                              "M", M);
      current_statement__ = 96;
      stan::math::validate_non_negative_index("p_aos_loop_mat_uni_uni_idx",
                                              "N", N);
      current_statement__ = 97;
      stan::math::validate_non_negative_index("p_aos_loop_mat_uni_uni_idx",
                                              "M", M);
      current_statement__ = 98;
      stan::math::validate_non_negative_index("p_aos_mat", "N", N);
      current_statement__ = 99;
      stan::math::validate_non_negative_index("p_aos_mat", "M", M);
      current_statement__ = 100;
      stan::math::validate_non_negative_index("p_aos_mat_pass_func_outer_single_indexed1",
                                              "N", N);
      current_statement__ = 101;
      stan::math::validate_non_negative_index("p_aos_mat_pass_func_outer_single_indexed1",
                                              "M", M);
      current_statement__ = 102;
      stan::math::validate_non_negative_index("p_aos_mat_pass_func_outer_single_indexed2",
                                              "N", N);
      current_statement__ = 103;
      stan::math::validate_non_negative_index("p_aos_mat_pass_func_outer_single_indexed2",
                                              "M", M);
      current_statement__ = 104;
      stan::math::validate_non_negative_index("p_aos_mat_fail_uni_uni_idx1",
                                              "N", N);
      current_statement__ = 105;
      stan::math::validate_non_negative_index("p_aos_mat_fail_uni_uni_idx1",
                                              "M", M);
      current_statement__ = 106;
      stan::math::validate_non_negative_index("p_aos_mat_fail_uni_uni_idx2",
                                              "N", N);
      current_statement__ = 107;
      stan::math::validate_non_negative_index("p_aos_mat_fail_uni_uni_idx2",
                                              "M", M);
      current_statement__ = 108;
      stan::math::validate_non_negative_index("tp_aos_vec_v", "M", M);
      current_statement__ = 109;
      stan::math::validate_non_negative_index("tp_soa_single_idx_uninit",
                                              "M", M);
      current_statement__ = 110;
      stan::math::validate_non_negative_index("tp_aos_fail_func_vec_v", "M",
                                              M);
      current_statement__ = 111;
      stan::math::validate_non_negative_index("tp_aos_fail_assign_from_top_idx",
                                              "M", M);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + M + (N * M) + (10 * N) + (N * M) + N + (N * M) + 
      N + N + N + (N * M) + M + M + M + M + (N * M) + (N * M) + (N * M)
       + (N * M) + (N * M) + (N * M);
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "indexing_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> p_soa_vec_v =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(M,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 2;
      p_soa_vec_v = in__.template read<
                      stan::conditional_var_value_t<local_scalar_t__, 
                        Eigen::Matrix<local_scalar_t__, -1, 1>>>(M);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, -1>> p_soa_mat =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, -1>>(
           Eigen::Matrix<double, -1, -1>::Constant(N, M,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 3;
      p_soa_mat = in__.template read<
                    stan::conditional_var_value_t<local_scalar_t__, 
                      Eigen::Matrix<local_scalar_t__, -1, -1>>>(N, M);
      std::vector<
        stan::conditional_var_value_t<local_scalar_t__, 
          Eigen::Matrix<local_scalar_t__, -1, 1>>> p_soa_arr_vec_v =
         std::vector<
           stan::conditional_var_value_t<local_scalar_t__, 
             Eigen::Matrix<local_scalar_t__, -1, 1>>>(10, 
           stan::conditional_var_value_t<local_scalar_t__, 
             Eigen::Matrix<local_scalar_t__, -1, 1>>(
             Eigen::Matrix<double, -1, 1>::Constant(N,
               std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 4;
      p_soa_arr_vec_v = in__.template read<
                          std::vector<
                            stan::conditional_var_value_t<local_scalar_t__, 
                              Eigen::Matrix<local_scalar_t__, -1, 1>>>>(10,
                          N);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, -1>> p_soa_mat_uni_col_idx =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, -1>>(
           Eigen::Matrix<double, -1, -1>::Constant(N, M,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 5;
      p_soa_mat_uni_col_idx = in__.template read<
                                stan::conditional_var_value_t<local_scalar_t__,
                                  Eigen::Matrix<local_scalar_t__, -1, -1>>>(
                                N, M);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> p_soa_vec_uni_idx =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 6;
      p_soa_vec_uni_idx = in__.template read<
                            stan::conditional_var_value_t<local_scalar_t__, 
                              Eigen::Matrix<local_scalar_t__, -1, 1>>>(N);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, -1>> p_soa_loop_mat_uni_col_idx =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, -1>>(
           Eigen::Matrix<double, -1, -1>::Constant(N, M,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 7;
      p_soa_loop_mat_uni_col_idx = in__.template read<
                                     stan::conditional_var_value_t<local_scalar_t__,
                                       
                                       Eigen::Matrix<local_scalar_t__, -1, -1>>>(
                                     N, M);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, 1, -1>> p_soa_lhs_loop_mul =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, 1, -1>>(
           Eigen::Matrix<double, 1, -1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 8;
      p_soa_lhs_loop_mul = in__.template read<
                             stan::conditional_var_value_t<local_scalar_t__, 
                               Eigen::Matrix<local_scalar_t__, 1, -1>>>(N);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> p_soa_rhs_loop_mul =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 9;
      p_soa_rhs_loop_mul = in__.template read<
                             stan::conditional_var_value_t<local_scalar_t__, 
                               Eigen::Matrix<local_scalar_t__, -1, 1>>>(N);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> p_soa_used_with_aos_in_excluded_fun =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 10;
      p_soa_used_with_aos_in_excluded_fun = in__.template read<
                                              stan::conditional_var_value_t<local_scalar_t__,
                                                
                                                Eigen::Matrix<local_scalar_t__, -1, 1>>>(
                                              N);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, -1>> p_soa_loop_mat_multi_uni_uni_idx =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, -1>>(
           Eigen::Matrix<double, -1, -1>::Constant(N, M,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 11;
      p_soa_loop_mat_multi_uni_uni_idx = in__.template read<
                                           stan::conditional_var_value_t<local_scalar_t__,
                                             
                                             Eigen::Matrix<local_scalar_t__, -1, -1>>>(
                                           N, M);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_aos_vec_v_assign_to_aos =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 12;
      p_aos_vec_v_assign_to_aos = in__.template read<
                                    Eigen::Matrix<local_scalar_t__, -1, 1>>(
                                    M);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_aos_vec_v_tp_fails_func =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 13;
      p_aos_vec_v_tp_fails_func = in__.template read<
                                    Eigen::Matrix<local_scalar_t__, -1, 1>>(
                                    M);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_aos_loop_vec_v_uni_idx =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 14;
      p_aos_loop_vec_v_uni_idx = in__.template read<
                                   Eigen::Matrix<local_scalar_t__, -1, 1>>(M);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_aos_fail_assign_from_top_idx =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 15;
      p_aos_fail_assign_from_top_idx = in__.template read<
                                         Eigen::Matrix<local_scalar_t__, -1, 1>>(
                                         M);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_aos_loop_mat_uni_uni_idx =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 16;
      p_aos_loop_mat_uni_uni_idx = in__.template read<
                                     Eigen::Matrix<local_scalar_t__, -1, -1>>(
                                     N, M);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_aos_mat =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 17;
      p_aos_mat = in__.template read<
                    Eigen::Matrix<local_scalar_t__, -1, -1>>(N, M);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_aos_mat_pass_func_outer_single_indexed1 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 18;
      p_aos_mat_pass_func_outer_single_indexed1 = in__.template read<
                                                    Eigen::Matrix<local_scalar_t__, -1, -1>>(
                                                    N, M);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_aos_mat_pass_func_outer_single_indexed2 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 19;
      p_aos_mat_pass_func_outer_single_indexed2 = in__.template read<
                                                    Eigen::Matrix<local_scalar_t__, -1, -1>>(
                                                    N, M);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_aos_mat_fail_uni_uni_idx1 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 20;
      p_aos_mat_fail_uni_uni_idx1 = in__.template read<
                                      Eigen::Matrix<local_scalar_t__, -1, -1>>(
                                      N, M);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_aos_mat_fail_uni_uni_idx2 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      current_statement__ = 21;
      p_aos_mat_fail_uni_uni_idx2 = in__.template read<
                                      Eigen::Matrix<local_scalar_t__, -1, -1>>(
                                      N, M);
      local_scalar_t__ tp_real_from_aos = DUMMY_VAR__;
      current_statement__ = 22;
      tp_real_from_aos = stan::model::rvalue(p_soa_vec_v, "p_soa_vec_v",
                           stan::model::index_uni(1));
      Eigen::Matrix<local_scalar_t__, -1, 1> tp_aos_vec_v =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 23;
      stan::model::assign(tp_aos_vec_v,
        udf_fun(p_aos_vec_v_assign_to_aos, pstream__),
        "assigning variable tp_aos_vec_v");
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, 1>> tp_soa_single_idx_uninit =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, 1>>(
           Eigen::Matrix<double, -1, 1>::Constant(M,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 27;
      stan::model::assign(tp_soa_single_idx_uninit, tp_real_from_aos,
        "assigning variable tp_soa_single_idx_uninit", stan::model::index_uni(1));
      current_statement__ = 28;
      stan::model::assign(tp_soa_single_idx_uninit,
        rep_vector<stan::conditional_var_value_t<local_scalar_t__, 
                     Eigen::Matrix<local_scalar_t__, -1, 1>>>(
          tp_real_from_aos, (M - 1)),
        "assigning variable tp_soa_single_idx_uninit", stan::model::index_min_max(2, M));
      Eigen::Matrix<local_scalar_t__, -1, 1> tp_aos_fail_func_vec_v =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 25;
      stan::model::assign(tp_aos_fail_func_vec_v, p_aos_vec_v_tp_fails_func,
        "assigning variable tp_aos_fail_func_vec_v");
      current_statement__ = 29;
      stan::model::assign(tp_aos_fail_func_vec_v,
        stan::model::rvalue(p_soa_vec_v, "p_soa_vec_v",
          stan::model::index_uni(1)),
        "assigning variable tp_aos_fail_func_vec_v", stan::model::index_uni(1));
      Eigen::Matrix<local_scalar_t__, -1, 1> tp_aos_fail_assign_from_top_idx =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      current_statement__ = 30;
      stan::model::assign(tp_aos_fail_assign_from_top_idx,
        stan::model::rvalue(p_aos_fail_assign_from_top_idx,
          "p_aos_fail_assign_from_top_idx", stan::model::index_min(1)),
        "assigning variable tp_aos_fail_assign_from_top_idx", stan::model::index_min(1));
      {
        current_statement__ = 31;
        stan::math::validate_non_negative_index("tp_soa_used_with_aos_in_excluded_fun",
                                                "N", N);
        stan::conditional_var_value_t<local_scalar_t__, 
          Eigen::Matrix<local_scalar_t__, -1, 1>> tp_soa_used_with_aos_in_excluded_fun =
           stan::conditional_var_value_t<local_scalar_t__, 
             Eigen::Matrix<local_scalar_t__, -1, 1>>(
             Eigen::Matrix<double, -1, 1>::Constant(N,
               std::numeric_limits<double>::quiet_NaN()));
        current_statement__ = 32;
        stan::model::assign(tp_soa_used_with_aos_in_excluded_fun,
          stan::math::multiply(p_soa_used_with_aos_in_excluded_fun,
            stan::math::size(tp_aos_vec_v)),
          "assigning variable tp_soa_used_with_aos_in_excluded_fun");
        current_statement__ = 33;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(y,
            stan::math::add(alpha,
              stan::math::multiply(dat_x,
                stan::math::add(p_soa_vec_v,
                  tp_soa_used_with_aos_in_excluded_fun))), 1.0));
        current_statement__ = 34;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(y,
            stan::math::add(alpha, stan::math::multiply(dat_x, p_soa_vec_v)),
            1.0));
        current_statement__ = 35;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(y,
            stan::math::multiply(dat_x,
              stan::model::rvalue(p_soa_mat_uni_col_idx,
                "p_soa_mat_uni_col_idx",
                stan::model::index_omni(), stan::model::index_uni(N))), 1.0));
        current_statement__ = 36;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(y,
            stan::math::multiply(dat_x,
              stan::model::rvalue(p_soa_mat_uni_col_idx,
                "p_soa_mat_uni_col_idx",
                stan::model::index_omni(), stan::model::index_uni(N))),
            stan::model::rvalue(p_soa_vec_uni_idx, "p_soa_vec_uni_idx",
              stan::model::index_uni(N))));
        current_statement__ = 37;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(y,
            stan::math::multiply(dat_x,
              udf_fun(tp_aos_fail_func_vec_v, pstream__)),
            stan::model::rvalue(p_soa_vec_uni_idx, "p_soa_vec_uni_idx",
              stan::model::index_uni(N))));
        current_statement__ = 38;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(y,
            stan::math::multiply(p_soa_mat,
              udf_fun(tp_aos_fail_func_vec_v, pstream__)),
            stan::model::rvalue(p_soa_vec_uni_idx, "p_soa_vec_uni_idx",
              stan::model::index_uni(N))));
        current_statement__ = 39;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(y,
            stan::math::multiply(p_soa_mat,
              udf_fun(tp_aos_fail_assign_from_top_idx, pstream__)),
            stan::model::rvalue(p_soa_vec_uni_idx, "p_soa_vec_uni_idx",
              stan::model::index_uni(N))));
        current_statement__ = 40;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(y,
            stan::math::multiply(p_soa_mat,
              udf_fun(
                stan::math::multiply(p_aos_mat, tp_aos_fail_func_vec_v), pstream__)),
            stan::model::rvalue(p_soa_vec_uni_idx, "p_soa_vec_uni_idx",
              stan::model::index_uni(N))));
        current_statement__ = 41;
        stan::math::validate_non_negative_index("tp_soa_single_assign", "N",
                                                N);
        stan::conditional_var_value_t<local_scalar_t__, 
          Eigen::Matrix<local_scalar_t__, -1, 1>> tp_soa_single_assign =
           stan::conditional_var_value_t<local_scalar_t__, 
             Eigen::Matrix<local_scalar_t__, -1, 1>>(
             Eigen::Matrix<double, -1, 1>::Constant(N,
               std::numeric_limits<double>::quiet_NaN()));
        current_statement__ = 43;
        stan::model::assign(tp_soa_single_assign, 2.0,
          "assigning variable tp_soa_single_assign", stan::model::index_uni(1));
        current_statement__ = 44;
        stan::math::validate_non_negative_index("tp_soa_single_assign_from_soa",
                                                "N", N);
        stan::conditional_var_value_t<local_scalar_t__, 
          Eigen::Matrix<local_scalar_t__, -1, 1>> tp_soa_single_assign_from_soa =
           stan::conditional_var_value_t<local_scalar_t__, 
             Eigen::Matrix<local_scalar_t__, -1, 1>>(
             Eigen::Matrix<double, -1, 1>::Constant(N,
               std::numeric_limits<double>::quiet_NaN()));
        current_statement__ = 46;
        stan::model::assign(tp_soa_single_assign_from_soa,
          stan::math::multiply(p_soa_lhs_loop_mul, p_soa_rhs_loop_mul),
          "assigning variable tp_soa_single_assign_from_soa", stan::model::index_uni(2));
        current_statement__ = 57;
        for (int i = 1; i <= 10; ++i) {
          current_statement__ = 47;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(y,
              stan::math::multiply(dat_x,
                stan::model::rvalue(p_soa_arr_vec_v, "p_soa_arr_vec_v",
                  stan::model::index_uni(i))), 1.0));
          current_statement__ = 48;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(y,
              stan::math::multiply(dat_x,
                stan::model::rvalue(p_soa_loop_mat_uni_col_idx,
                  "p_soa_loop_mat_uni_col_idx",
                  stan::model::index_omni(), stan::model::index_uni(i))),
              1.0));
          current_statement__ = 49;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(y,
              stan::math::multiply(
                stan::model::rvalue(p_soa_loop_mat_uni_col_idx,
                  "p_soa_loop_mat_uni_col_idx",
                  stan::model::index_uni(i), stan::model::index_omni()),
                dat_x), 1.0));
          current_statement__ = 50;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(y,
              stan::math::multiply(dat_x,
                stan::math::transpose(
                  stan::model::rvalue(p_soa_loop_mat_uni_col_idx,
                    "p_soa_loop_mat_uni_col_idx",
                    stan::model::index_uni(i), stan::model::index_omni()))),
              1.0));
          current_statement__ = 51;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(y,
              stan::math::multiply(dat_x,
                stan::model::rvalue(p_soa_loop_mat_uni_col_idx,
                  "p_soa_loop_mat_uni_col_idx",
                  stan::model::index_min_max(1, N), stan::model::index_uni(1))),
              1.0));
          current_statement__ = 52;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(y,
              stan::math::multiply(dat_x,
                stan::math::transpose(
                  stan::model::rvalue(p_soa_loop_mat_uni_col_idx,
                    "p_soa_loop_mat_uni_col_idx", stan::model::index_uni(i)))),
              1.0));
          current_statement__ = 53;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(y,
              stan::math::multiply(dat_x,
                stan::math::transpose(
                  stan::model::rvalue(p_soa_loop_mat_multi_uni_uni_idx,
                    "p_soa_loop_mat_multi_uni_uni_idx",
                    stan::model::index_uni(stan::model::rvalue(idx_tester,
                                             "idx_tester",
                                             stan::model::index_uni(i))),
                      stan::model::index_omni()))), 1.0));
          current_statement__ = 54;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(y,
              stan::math::multiply(
                stan::model::rvalue(dat_x, "dat_x",
                  stan::model::index_omni(), stan::model::index_uni(i)),
                stan::model::rvalue(
                  stan::math::transpose(
  stan::math::multiply(p_aos_mat_pass_func_outer_single_indexed1,
    p_aos_mat_pass_func_outer_single_indexed2)),
                  "transpose(multiply(p_aos_mat_pass_func_outer_single_indexed1,\np_aos_mat_pass_func_outer_single_indexed2))",
                  stan::model::index_uni(mask_fun(i, pstream__)),
                    stan::model::index_uni(mask_fun(i, pstream__)))), 1.0));
          current_statement__ = 55;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(y,
              stan::math::multiply(
                stan::model::rvalue(dat_x, "dat_x",
                  stan::model::index_omni(), stan::model::index_uni(i)),
                (stan::model::rvalue(p_aos_mat_fail_uni_uni_idx1,
                   "p_aos_mat_fail_uni_uni_idx1",
                   stan::model::index_uni(i), stan::model::index_uni(i)) *
                  stan::model::rvalue(p_aos_mat_fail_uni_uni_idx2,
                    "p_aos_mat_fail_uni_uni_idx2",
                    stan::model::index_uni(i), stan::model::index_uni(i)))),
              1.0));
        }
        current_statement__ = 58;
        stan::math::validate_non_negative_index("tp_aos_loop_vec_v_uni_idx",
                                                "N", N);
        Eigen::Matrix<local_scalar_t__, -1, 1> tp_aos_loop_vec_v_uni_idx =
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 60;
        stan::math::validate_non_negative_index("tp_aos_loop_vec_v_multi_uni_idx",
                                                "N", N);
        Eigen::Matrix<local_scalar_t__, -1, 1> tp_aos_loop_vec_v_multi_uni_idx =
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
        current_statement__ = 68;
        for (int i = 1; i <= N; ++i) {
          current_statement__ = 62;
          stan::model::assign(tp_aos_loop_vec_v_uni_idx,
            stan::math::multiply(p_soa_lhs_loop_mul, p_soa_rhs_loop_mul),
            "assigning variable tp_aos_loop_vec_v_uni_idx", stan::model::index_uni(i));
          current_statement__ = 63;
          stan::model::assign(tp_aos_loop_vec_v_multi_uni_idx,
            stan::math::multiply(p_soa_lhs_loop_mul, p_soa_rhs_loop_mul),
            "assigning variable tp_aos_loop_vec_v_multi_uni_idx", stan::model::index_uni(
                                                                    stan::model::rvalue(
                                                                    idx_tester,
                                                                    "idx_tester",
                                                                    stan::model::index_uni(i))));
          current_statement__ = 64;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(y,
              stan::math::multiply(
                stan::model::rvalue(dat_x, "dat_x",
                  stan::model::index_omni(), stan::model::index_uni(i)),
                stan::model::rvalue(p_aos_loop_vec_v_uni_idx,
                  "p_aos_loop_vec_v_uni_idx", stan::model::index_uni(i))),
              1.0));
          current_statement__ = 65;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(y,
              stan::math::multiply(
                stan::model::rvalue(dat_x, "dat_x",
                  stan::model::index_omni(), stan::model::index_uni(i)),
                stan::model::rvalue(p_aos_loop_mat_uni_uni_idx,
                  "p_aos_loop_mat_uni_uni_idx",
                  stan::model::index_uni(i), stan::model::index_uni(i))),
              1.0));
          current_statement__ = 66;
          lp_accum__.add(
            stan::math::normal_lpdf<propto__>(y,
              stan::model::rvalue(dat_x, "dat_x",
                stan::model::index_omni(), stan::model::index_uni(i)),
              (stan::model::rvalue(p_aos_mat_fail_uni_uni_idx1,
                 "p_aos_mat_fail_uni_uni_idx1",
                 stan::model::index_uni(i), stan::model::index_uni(i)) *
                stan::model::rvalue(p_aos_mat_fail_uni_uni_idx2,
                  "p_aos_mat_fail_uni_uni_idx2",
                  stan::model::index_uni(i), stan::model::index_uni(i)))));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "indexing_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double alpha = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, 1> p_soa_vec_v =
         Eigen::Matrix<double, -1, 1>::Constant(M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      p_soa_vec_v = in__.template read<
                      Eigen::Matrix<local_scalar_t__, -1, 1>>(M);
      Eigen::Matrix<double, -1, -1> p_soa_mat =
         Eigen::Matrix<double, -1, -1>::Constant(N, M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      p_soa_mat = in__.template read<
                    Eigen::Matrix<local_scalar_t__, -1, -1>>(N, M);
      std::vector<Eigen::Matrix<double, -1, 1>> p_soa_arr_vec_v =
         std::vector<Eigen::Matrix<double, -1, 1>>(10, 
           Eigen::Matrix<double, -1, 1>::Constant(N,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 4;
      p_soa_arr_vec_v = in__.template read<
                          std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(
                          10, N);
      Eigen::Matrix<double, -1, -1> p_soa_mat_uni_col_idx =
         Eigen::Matrix<double, -1, -1>::Constant(N, M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      p_soa_mat_uni_col_idx = in__.template read<
                                Eigen::Matrix<local_scalar_t__, -1, -1>>(N,
                                M);
      Eigen::Matrix<double, -1, 1> p_soa_vec_uni_idx =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 6;
      p_soa_vec_uni_idx = in__.template read<
                            Eigen::Matrix<local_scalar_t__, -1, 1>>(N);
      Eigen::Matrix<double, -1, -1> p_soa_loop_mat_uni_col_idx =
         Eigen::Matrix<double, -1, -1>::Constant(N, M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 7;
      p_soa_loop_mat_uni_col_idx = in__.template read<
                                     Eigen::Matrix<local_scalar_t__, -1, -1>>(
                                     N, M);
      Eigen::Matrix<double, 1, -1> p_soa_lhs_loop_mul =
         Eigen::Matrix<double, 1, -1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 8;
      p_soa_lhs_loop_mul = in__.template read<
                             Eigen::Matrix<local_scalar_t__, 1, -1>>(N);
      Eigen::Matrix<double, -1, 1> p_soa_rhs_loop_mul =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 9;
      p_soa_rhs_loop_mul = in__.template read<
                             Eigen::Matrix<local_scalar_t__, -1, 1>>(N);
      Eigen::Matrix<double, -1, 1> p_soa_used_with_aos_in_excluded_fun =
         Eigen::Matrix<double, -1, 1>::Constant(N,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 10;
      p_soa_used_with_aos_in_excluded_fun = in__.template read<
                                              Eigen::Matrix<local_scalar_t__, -1, 1>>(
                                              N);
      Eigen::Matrix<double, -1, -1> p_soa_loop_mat_multi_uni_uni_idx =
         Eigen::Matrix<double, -1, -1>::Constant(N, M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 11;
      p_soa_loop_mat_multi_uni_uni_idx = in__.template read<
                                           Eigen::Matrix<local_scalar_t__, -1, -1>>(
                                           N, M);
      Eigen::Matrix<double, -1, 1> p_aos_vec_v_assign_to_aos =
         Eigen::Matrix<double, -1, 1>::Constant(M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 12;
      p_aos_vec_v_assign_to_aos = in__.template read<
                                    Eigen::Matrix<local_scalar_t__, -1, 1>>(
                                    M);
      Eigen::Matrix<double, -1, 1> p_aos_vec_v_tp_fails_func =
         Eigen::Matrix<double, -1, 1>::Constant(M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 13;
      p_aos_vec_v_tp_fails_func = in__.template read<
                                    Eigen::Matrix<local_scalar_t__, -1, 1>>(
                                    M);
      Eigen::Matrix<double, -1, 1> p_aos_loop_vec_v_uni_idx =
         Eigen::Matrix<double, -1, 1>::Constant(M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 14;
      p_aos_loop_vec_v_uni_idx = in__.template read<
                                   Eigen::Matrix<local_scalar_t__, -1, 1>>(M);
      Eigen::Matrix<double, -1, 1> p_aos_fail_assign_from_top_idx =
         Eigen::Matrix<double, -1, 1>::Constant(M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 15;
      p_aos_fail_assign_from_top_idx = in__.template read<
                                         Eigen::Matrix<local_scalar_t__, -1, 1>>(
                                         M);
      Eigen::Matrix<double, -1, -1> p_aos_loop_mat_uni_uni_idx =
         Eigen::Matrix<double, -1, -1>::Constant(N, M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 16;
      p_aos_loop_mat_uni_uni_idx = in__.template read<
                                     Eigen::Matrix<local_scalar_t__, -1, -1>>(
                                     N, M);
      Eigen::Matrix<double, -1, -1> p_aos_mat =
         Eigen::Matrix<double, -1, -1>::Constant(N, M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 17;
      p_aos_mat = in__.template read<
                    Eigen::Matrix<local_scalar_t__, -1, -1>>(N, M);
      Eigen::Matrix<double, -1, -1> p_aos_mat_pass_func_outer_single_indexed1 =
         Eigen::Matrix<double, -1, -1>::Constant(N, M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 18;
      p_aos_mat_pass_func_outer_single_indexed1 = in__.template read<
                                                    Eigen::Matrix<local_scalar_t__, -1, -1>>(
                                                    N, M);
      Eigen::Matrix<double, -1, -1> p_aos_mat_pass_func_outer_single_indexed2 =
         Eigen::Matrix<double, -1, -1>::Constant(N, M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 19;
      p_aos_mat_pass_func_outer_single_indexed2 = in__.template read<
                                                    Eigen::Matrix<local_scalar_t__, -1, -1>>(
                                                    N, M);
      Eigen::Matrix<double, -1, -1> p_aos_mat_fail_uni_uni_idx1 =
         Eigen::Matrix<double, -1, -1>::Constant(N, M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 20;
      p_aos_mat_fail_uni_uni_idx1 = in__.template read<
                                      Eigen::Matrix<local_scalar_t__, -1, -1>>(
                                      N, M);
      Eigen::Matrix<double, -1, -1> p_aos_mat_fail_uni_uni_idx2 =
         Eigen::Matrix<double, -1, -1>::Constant(N, M,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 21;
      p_aos_mat_fail_uni_uni_idx2 = in__.template read<
                                      Eigen::Matrix<local_scalar_t__, -1, -1>>(
                                      N, M);
      double tp_real_from_aos = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double, -1, 1> tp_aos_vec_v =
         Eigen::Matrix<double, -1, 1>::Constant(M,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> tp_soa_single_idx_uninit =
         Eigen::Matrix<double, -1, 1>::Constant(M,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> tp_aos_fail_func_vec_v =
         Eigen::Matrix<double, -1, 1>::Constant(M,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> tp_aos_fail_assign_from_top_idx =
         Eigen::Matrix<double, -1, 1>::Constant(M,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(alpha);
      out__.write(p_soa_vec_v);
      out__.write(p_soa_mat);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          out__.write(p_soa_arr_vec_v[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      out__.write(p_soa_mat_uni_col_idx);
      out__.write(p_soa_vec_uni_idx);
      out__.write(p_soa_loop_mat_uni_col_idx);
      out__.write(p_soa_lhs_loop_mul);
      out__.write(p_soa_rhs_loop_mul);
      out__.write(p_soa_used_with_aos_in_excluded_fun);
      out__.write(p_soa_loop_mat_multi_uni_uni_idx);
      out__.write(p_aos_vec_v_assign_to_aos);
      out__.write(p_aos_vec_v_tp_fails_func);
      out__.write(p_aos_loop_vec_v_uni_idx);
      out__.write(p_aos_fail_assign_from_top_idx);
      out__.write(p_aos_loop_mat_uni_uni_idx);
      out__.write(p_aos_mat);
      out__.write(p_aos_mat_pass_func_outer_single_indexed1);
      out__.write(p_aos_mat_pass_func_outer_single_indexed2);
      out__.write(p_aos_mat_fail_uni_uni_idx1);
      out__.write(p_aos_mat_fail_uni_uni_idx2);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 22;
      tp_real_from_aos = stan::model::rvalue(p_soa_vec_v, "p_soa_vec_v",
                           stan::model::index_uni(1));
      current_statement__ = 23;
      stan::model::assign(tp_aos_vec_v,
        udf_fun(p_aos_vec_v_assign_to_aos, pstream__),
        "assigning variable tp_aos_vec_v");
      current_statement__ = 27;
      stan::model::assign(tp_soa_single_idx_uninit, tp_real_from_aos,
        "assigning variable tp_soa_single_idx_uninit", stan::model::index_uni(1));
      current_statement__ = 28;
      stan::model::assign(tp_soa_single_idx_uninit,
        stan::math::rep_vector(tp_real_from_aos, (M - 1)),
        "assigning variable tp_soa_single_idx_uninit", stan::model::index_min_max(2, M));
      current_statement__ = 25;
      stan::model::assign(tp_aos_fail_func_vec_v, p_aos_vec_v_tp_fails_func,
        "assigning variable tp_aos_fail_func_vec_v");
      current_statement__ = 29;
      stan::model::assign(tp_aos_fail_func_vec_v,
        stan::model::rvalue(p_soa_vec_v, "p_soa_vec_v",
          stan::model::index_uni(1)),
        "assigning variable tp_aos_fail_func_vec_v", stan::model::index_uni(1));
      current_statement__ = 30;
      stan::model::assign(tp_aos_fail_assign_from_top_idx,
        stan::model::rvalue(p_aos_fail_assign_from_top_idx,
          "p_aos_fail_assign_from_top_idx", stan::model::index_min(1)),
        "assigning variable tp_aos_fail_assign_from_top_idx", stan::model::index_min(1));
      if (emit_transformed_parameters__) {
        out__.write(tp_real_from_aos);
        out__.write(tp_aos_vec_v);
        out__.write(tp_soa_single_idx_uninit);
        out__.write(tp_aos_fail_func_vec_v);
        out__.write(tp_aos_fail_assign_from_top_idx);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ alpha = DUMMY_VAR__;
      alpha = in__.read<local_scalar_t__>();
      out__.write(alpha);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_soa_vec_v =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        stan::model::assign(p_soa_vec_v, in__.read<local_scalar_t__>(),
          "assigning variable p_soa_vec_v", stan::model::index_uni(sym1__));
      }
      out__.write(p_soa_vec_v);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_soa_mat =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          stan::model::assign(p_soa_mat, in__.read<local_scalar_t__>(),
            "assigning variable p_soa_mat", stan::model::index_uni(sym2__),
                                              stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_soa_mat);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> p_soa_arr_vec_v =
         std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(10, 
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__));
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          stan::model::assign(p_soa_arr_vec_v, in__.read<local_scalar_t__>(),
            "assigning variable p_soa_arr_vec_v", stan::model::index_uni(sym2__),
                                                    stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_soa_arr_vec_v);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_soa_mat_uni_col_idx =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          stan::model::assign(p_soa_mat_uni_col_idx,
            in__.read<local_scalar_t__>(),
            "assigning variable p_soa_mat_uni_col_idx", stan::model::index_uni(sym2__),
                                                          stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_soa_mat_uni_col_idx);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_soa_vec_uni_idx =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(p_soa_vec_uni_idx, in__.read<local_scalar_t__>(),
          "assigning variable p_soa_vec_uni_idx", stan::model::index_uni(sym1__));
      }
      out__.write(p_soa_vec_uni_idx);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_soa_loop_mat_uni_col_idx =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          stan::model::assign(p_soa_loop_mat_uni_col_idx,
            in__.read<local_scalar_t__>(),
            "assigning variable p_soa_loop_mat_uni_col_idx", stan::model::index_uni(sym2__),
                                                               stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_soa_loop_mat_uni_col_idx);
      Eigen::Matrix<local_scalar_t__, 1, -1> p_soa_lhs_loop_mul =
         Eigen::Matrix<local_scalar_t__, 1, -1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(p_soa_lhs_loop_mul,
          in__.read<local_scalar_t__>(),
          "assigning variable p_soa_lhs_loop_mul", stan::model::index_uni(sym1__));
      }
      out__.write(p_soa_lhs_loop_mul);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_soa_rhs_loop_mul =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(p_soa_rhs_loop_mul,
          in__.read<local_scalar_t__>(),
          "assigning variable p_soa_rhs_loop_mul", stan::model::index_uni(sym1__));
      }
      out__.write(p_soa_rhs_loop_mul);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_soa_used_with_aos_in_excluded_fun =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        stan::model::assign(p_soa_used_with_aos_in_excluded_fun,
          in__.read<local_scalar_t__>(),
          "assigning variable p_soa_used_with_aos_in_excluded_fun", stan::model::index_uni(sym1__));
      }
      out__.write(p_soa_used_with_aos_in_excluded_fun);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_soa_loop_mat_multi_uni_uni_idx =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          stan::model::assign(p_soa_loop_mat_multi_uni_uni_idx,
            in__.read<local_scalar_t__>(),
            "assigning variable p_soa_loop_mat_multi_uni_uni_idx", stan::model::index_uni(sym2__),
                                                                    stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_soa_loop_mat_multi_uni_uni_idx);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_aos_vec_v_assign_to_aos =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        stan::model::assign(p_aos_vec_v_assign_to_aos,
          in__.read<local_scalar_t__>(),
          "assigning variable p_aos_vec_v_assign_to_aos", stan::model::index_uni(sym1__));
      }
      out__.write(p_aos_vec_v_assign_to_aos);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_aos_vec_v_tp_fails_func =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        stan::model::assign(p_aos_vec_v_tp_fails_func,
          in__.read<local_scalar_t__>(),
          "assigning variable p_aos_vec_v_tp_fails_func", stan::model::index_uni(sym1__));
      }
      out__.write(p_aos_vec_v_tp_fails_func);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_aos_loop_vec_v_uni_idx =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        stan::model::assign(p_aos_loop_vec_v_uni_idx,
          in__.read<local_scalar_t__>(),
          "assigning variable p_aos_loop_vec_v_uni_idx", stan::model::index_uni(sym1__));
      }
      out__.write(p_aos_loop_vec_v_uni_idx);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_aos_fail_assign_from_top_idx =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        stan::model::assign(p_aos_fail_assign_from_top_idx,
          in__.read<local_scalar_t__>(),
          "assigning variable p_aos_fail_assign_from_top_idx", stan::model::index_uni(sym1__));
      }
      out__.write(p_aos_fail_assign_from_top_idx);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_aos_loop_mat_uni_uni_idx =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          stan::model::assign(p_aos_loop_mat_uni_uni_idx,
            in__.read<local_scalar_t__>(),
            "assigning variable p_aos_loop_mat_uni_uni_idx", stan::model::index_uni(sym2__),
                                                               stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_aos_loop_mat_uni_uni_idx);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_aos_mat =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          stan::model::assign(p_aos_mat, in__.read<local_scalar_t__>(),
            "assigning variable p_aos_mat", stan::model::index_uni(sym2__),
                                              stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_aos_mat);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_aos_mat_pass_func_outer_single_indexed1 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          stan::model::assign(p_aos_mat_pass_func_outer_single_indexed1,
            in__.read<local_scalar_t__>(),
            "assigning variable p_aos_mat_pass_func_outer_single_indexed1", 
            stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_aos_mat_pass_func_outer_single_indexed1);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_aos_mat_pass_func_outer_single_indexed2 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          stan::model::assign(p_aos_mat_pass_func_outer_single_indexed2,
            in__.read<local_scalar_t__>(),
            "assigning variable p_aos_mat_pass_func_outer_single_indexed2", 
            stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_aos_mat_pass_func_outer_single_indexed2);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_aos_mat_fail_uni_uni_idx1 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          stan::model::assign(p_aos_mat_fail_uni_uni_idx1,
            in__.read<local_scalar_t__>(),
            "assigning variable p_aos_mat_fail_uni_uni_idx1", stan::model::index_uni(sym2__),
                                                                stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_aos_mat_fail_uni_uni_idx1);
      Eigen::Matrix<local_scalar_t__, -1, -1> p_aos_mat_fail_uni_uni_idx2 =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(N, M, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          stan::model::assign(p_aos_mat_fail_uni_uni_idx2,
            in__.read<local_scalar_t__>(),
            "assigning variable p_aos_mat_fail_uni_uni_idx2", stan::model::index_uni(sym2__),
                                                                stan::model::index_uni(sym1__));
        }
      }
      out__.write(p_aos_mat_fail_uni_uni_idx2);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"alpha", "p_soa_vec_v", "p_soa_mat",
      "p_soa_arr_vec_v", "p_soa_mat_uni_col_idx", "p_soa_vec_uni_idx",
      "p_soa_loop_mat_uni_col_idx", "p_soa_lhs_loop_mul",
      "p_soa_rhs_loop_mul", "p_soa_used_with_aos_in_excluded_fun",
      "p_soa_loop_mat_multi_uni_uni_idx", "p_aos_vec_v_assign_to_aos",
      "p_aos_vec_v_tp_fails_func", "p_aos_loop_vec_v_uni_idx",
      "p_aos_fail_assign_from_top_idx", "p_aos_loop_mat_uni_uni_idx",
      "p_aos_mat", "p_aos_mat_pass_func_outer_single_indexed1",
      "p_aos_mat_pass_func_outer_single_indexed2",
      "p_aos_mat_fail_uni_uni_idx1", "p_aos_mat_fail_uni_uni_idx2",
      "tp_real_from_aos", "tp_aos_vec_v", "tp_soa_single_idx_uninit",
      "tp_aos_fail_func_vec_v", "tp_aos_fail_assign_from_top_idx"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N)},
      std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(M)},
      std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(M)},
      std::vector<size_t>{static_cast<size_t>(M)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha");
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_soa_vec_v" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_soa_mat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_soa_arr_vec_v" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_soa_mat_uni_col_idx" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_soa_vec_uni_idx" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_soa_loop_mat_uni_col_idx" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_soa_lhs_loop_mul" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_soa_rhs_loop_mul" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_soa_used_with_aos_in_excluded_fun" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_soa_loop_mat_multi_uni_uni_idx" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_aos_vec_v_assign_to_aos" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_aos_vec_v_tp_fails_func" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_aos_loop_vec_v_uni_idx" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_aos_fail_assign_from_top_idx" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_aos_loop_mat_uni_uni_idx" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_aos_mat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_aos_mat_pass_func_outer_single_indexed1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_aos_mat_pass_func_outer_single_indexed2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_aos_mat_fail_uni_uni_idx1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_aos_mat_fail_uni_uni_idx2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp_real_from_aos");
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "tp_aos_vec_v" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "tp_soa_single_idx_uninit" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "tp_aos_fail_func_vec_v" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "tp_aos_fail_assign_from_top_idx" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha");
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_soa_vec_v" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_soa_mat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_soa_arr_vec_v" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_soa_mat_uni_col_idx" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_soa_vec_uni_idx" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_soa_loop_mat_uni_col_idx" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_soa_lhs_loop_mul" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_soa_rhs_loop_mul" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_soa_used_with_aos_in_excluded_fun" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_soa_loop_mat_multi_uni_uni_idx" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_aos_vec_v_assign_to_aos" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_aos_vec_v_tp_fails_func" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_aos_loop_vec_v_uni_idx" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_aos_fail_assign_from_top_idx" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_aos_loop_mat_uni_uni_idx" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_aos_mat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_aos_mat_pass_func_outer_single_indexed1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_aos_mat_pass_func_outer_single_indexed2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_aos_mat_fail_uni_uni_idx1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "p_aos_mat_fail_uni_uni_idx2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp_real_from_aos");
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "tp_aos_vec_v" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "tp_soa_single_idx_uninit" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "tp_aos_fail_func_vec_v" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "tp_aos_fail_assign_from_top_idx" + '.' + std::to_string(sym1__));
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"p_soa_vec_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_arr_vec_v\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(10) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"p_soa_mat_uni_col_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_vec_uni_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_loop_mat_uni_col_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_lhs_loop_mul\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_rhs_loop_mul\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_used_with_aos_in_excluded_fun\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_loop_mat_multi_uni_uni_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_vec_v_assign_to_aos\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_vec_v_tp_fails_func\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_loop_vec_v_uni_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_fail_assign_from_top_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_loop_mat_uni_uni_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_pass_func_outer_single_indexed1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_pass_func_outer_single_indexed2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_fail_uni_uni_idx1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_fail_uni_uni_idx2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_from_aos\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"tp_aos_vec_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_soa_single_idx_uninit\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_aos_fail_func_vec_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_aos_fail_assign_from_top_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"p_soa_vec_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_arr_vec_v\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(10) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "}},\"block\":\"parameters\"},{\"name\":\"p_soa_mat_uni_col_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_vec_uni_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_loop_mat_uni_col_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_lhs_loop_mul\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_rhs_loop_mul\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_used_with_aos_in_excluded_fun\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N) + "},\"block\":\"parameters\"},{\"name\":\"p_soa_loop_mat_multi_uni_uni_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_vec_v_assign_to_aos\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_vec_v_tp_fails_func\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_loop_vec_v_uni_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_fail_assign_from_top_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_loop_mat_uni_uni_idx\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_pass_func_outer_single_indexed1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_pass_func_outer_single_indexed2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_fail_uni_uni_idx1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"p_aos_mat_fail_uni_uni_idx2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(M) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_from_aos\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"tp_aos_vec_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_soa_single_idx_uninit\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_aos_fail_func_vec_v\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_aos_fail_assign_from_top_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(M) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((((((((((((((((((1 + M) + (N * M)) + (10 * N)) + (N * M)) + N) +
                  (N * M)) + N) + N) + N) + (N * M)) + M) + M) + M) + M) +
         (N * M)) + (N * M)) + (N * M)) + (N * M)) + (N * M)) + (N * M));
      const size_t num_transformed = 
  ((((1 + M) + M) + M) + M);
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((((((((((((((((((1 + M) + (N * M)) + (10 * N)) + (N * M)) + N) +
                  (N * M)) + N) + N) + N) + (N * M)) + M) + M) + M) + M) +
         (N * M)) + (N * M)) + (N * M)) + (N * M)) + (N * M)) + (N * M));
      const size_t num_transformed = 
  ((((1 + M) + M) + M) + M);
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 21> names__{"alpha", "p_soa_vec_v",
      "p_soa_mat", "p_soa_arr_vec_v", "p_soa_mat_uni_col_idx",
      "p_soa_vec_uni_idx", "p_soa_loop_mat_uni_col_idx",
      "p_soa_lhs_loop_mul", "p_soa_rhs_loop_mul",
      "p_soa_used_with_aos_in_excluded_fun",
      "p_soa_loop_mat_multi_uni_uni_idx", "p_aos_vec_v_assign_to_aos",
      "p_aos_vec_v_tp_fails_func", "p_aos_loop_vec_v_uni_idx",
      "p_aos_fail_assign_from_top_idx", "p_aos_loop_mat_uni_uni_idx",
      "p_aos_mat", "p_aos_mat_pass_func_outer_single_indexed1",
      "p_aos_mat_pass_func_outer_single_indexed2",
      "p_aos_mat_fail_uni_uni_idx1", "p_aos_mat_fail_uni_uni_idx2"};
      const std::array<Eigen::Index, 21> constrain_param_sizes__{1, M,
       (N * M), (10 * N), (N * M), N, (N * M), N, N, N, (N * M), M, M, 
       M, M, (N * M), (N * M), (N * M), (N * M), (N * M), (N * M)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } using stan_model = indexing_model_namespace::indexing_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return indexing_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp indexing2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace indexing2_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 17> locations_array__ = 
{" (found before start of program)",
 " (in 'indexing2.stan', line 8, column 2 to column 13)",
 " (in 'indexing2.stan', line 9, column 2 to column 35)",
 " (in 'indexing2.stan', line 13, column 9 to column 10)",
 " (in 'indexing2.stan', line 13, column 2 to column 67)",
 " (in 'indexing2.stan', line 16, column 4 to column 97)",
 " (in 'indexing2.stan', line 15, column 18 to line 17, column 3)",
 " (in 'indexing2.stan', line 15, column 2 to line 17, column 3)",
 " (in 'indexing2.stan', line 18, column 9 to column 10)",
 " (in 'indexing2.stan', line 18, column 2 to column 44)",
 " (in 'indexing2.stan', line 20, column 2 to column 77)",
 " (in 'indexing2.stan', line 19, column 17 to line 21, column 3)",
 " (in 'indexing2.stan', line 19, column 2 to line 21, column 3)",
 " (in 'indexing2.stan', line 2, column 1 to column 7)",
 " (in 'indexing2.stan', line 3, column 1 to column 7)",
 " (in 'indexing2.stan', line 4, column 7 to column 8)",
 " (in 'indexing2.stan', line 4, column 1 to column 18)"};




class indexing2_model final : public model_base_crtp<indexing2_model> {

 private:
  int N;
  int M;
  std::vector<int> Idx; 
  
 
 public:
  ~indexing2_model() { }
  
  inline std::string model_name() const final { return "indexing2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = -fsoa --print-cpp"};
  }
  
  
  indexing2_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "indexing2_model_namespace::indexing2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 13;
      context__.validate_dims("data initialization","N","int",
           std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      
      
      current_statement__ = 13;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 14;
      context__.validate_dims("data initialization","M","int",
           std::vector<size_t>{});
      M = std::numeric_limits<int>::min();
      
      
      current_statement__ = 14;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 15;
      stan::math::validate_non_negative_index("Idx", "N", N);
      current_statement__ = 16;
      context__.validate_dims("data initialization","Idx","int",
           std::vector<size_t>{static_cast<size_t>(N)});
      Idx = std::vector<int>(N, std::numeric_limits<int>::min());
      
      
      current_statement__ = 16;
      Idx = context__.vals_i("Idx");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 10;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "indexing2_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ alpha = DUMMY_VAR__;
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__, -1, 1> p_aos_loop_single_idx =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(10, DUMMY_VAR__);
      current_statement__ = 2;
      p_aos_loop_single_idx = in__.template read<
                                Eigen::Matrix<local_scalar_t__, -1, 1>>(10);
      {
        current_statement__ = 3;
        stan::math::validate_non_negative_index("tp_soa_multi_idx_assign_in_loop",
                                                "N", N);
        stan::conditional_var_value_t<local_scalar_t__, 
          Eigen::Matrix<local_scalar_t__, -1, 1>> tp_soa_multi_idx_assign_in_loop =
           stan::conditional_var_value_t<local_scalar_t__, 
             Eigen::Matrix<local_scalar_t__, -1, 1>>(
             Eigen::Matrix<double, -1, 1>::Constant(N,
               std::numeric_limits<double>::quiet_NaN()));
        current_statement__ = 4;
        stan::model::assign(tp_soa_multi_idx_assign_in_loop,
          rep_vector<stan::conditional_var_value_t<local_scalar_t__, 
                       Eigen::Matrix<local_scalar_t__, -1, 1>>>(alpha, N),
          "assigning variable tp_soa_multi_idx_assign_in_loop");
        current_statement__ = 7;
        for (int i = 1; i <= 10; ++i) {
          current_statement__ = 5;
          stan::model::assign(tp_soa_multi_idx_assign_in_loop,
            stan::math::multiply(
              stan::model::deep_copy(tp_soa_multi_idx_assign_in_loop),
              stan::model::rvalue(p_aos_loop_single_idx,
                "p_aos_loop_single_idx", stan::model::index_uni(i))),
            "assigning variable tp_soa_multi_idx_assign_in_loop");
        }
        current_statement__ = 8;
        stan::math::validate_non_negative_index("tp_soa_single_idx_in_upfrom_idx",
                                                "N", N);
        stan::conditional_var_value_t<local_scalar_t__, 
          Eigen::Matrix<local_scalar_t__, -1, 1>> tp_soa_single_idx_in_upfrom_idx =
           stan::conditional_var_value_t<local_scalar_t__, 
             Eigen::Matrix<local_scalar_t__, -1, 1>>(
             Eigen::Matrix<double, -1, 1>::Constant(N,
               std::numeric_limits<double>::quiet_NaN()));
        current_statement__ = 12;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 10;
          stan::model::assign(tp_soa_single_idx_in_upfrom_idx,
            stan::model::rvalue(tp_soa_multi_idx_assign_in_loop,
              "tp_soa_multi_idx_assign_in_loop",
              stan::model::index_min(stan::model::rvalue(Idx, "Idx",
                                       stan::model::index_uni(i)))),
            "assigning variable tp_soa_single_idx_in_upfrom_idx");
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "indexing2_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double alpha = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      alpha = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, 1> p_aos_loop_single_idx =
         Eigen::Matrix<double, -1, 1>::Constant(10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      p_aos_loop_single_idx = in__.template read<
                                Eigen::Matrix<local_scalar_t__, -1, 1>>(10);
      out__.write(alpha);
      out__.write(p_aos_loop_single_idx);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ alpha = DUMMY_VAR__;
      alpha = in__.read<local_scalar_t__>();
      out__.write(alpha);
      Eigen::Matrix<local_scalar_t__, -1, 1> p_aos_loop_single_idx =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(10, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        stan::model::assign(p_aos_loop_single_idx,
          in__.read<local_scalar_t__>(),
          "assigning variable p_aos_loop_single_idx", stan::model::index_uni(sym1__));
      }
      out__.write(p_aos_loop_single_idx);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"alpha", "p_aos_loop_single_idx"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(10)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha");
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_aos_loop_single_idx" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha");
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "p_aos_loop_single_idx" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"p_aos_loop_single_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(10) + "},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"p_aos_loop_single_idx\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(10) + "},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + 10);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (1 + 10);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"alpha",
      "p_aos_loop_single_idx"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{1, 10};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = indexing2_model_namespace::indexing2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return indexing2_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp reductions_allowed.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace reductions_allowed_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 12> locations_array__ = 
{" (found before start of program)",
 " (in 'reductions_allowed.stan', line 16, column 4 to column 25)",
 " (in 'reductions_allowed.stan', line 17, column 4 to column 25)",
 " (in 'reductions_allowed.stan', line 18, column 4 to column 25)",
 " (in 'reductions_allowed.stan', line 22, column 4 to column 56)",
 " (in 'reductions_allowed.stan', line 23, column 4 to column 93)",
 " (in 'reductions_allowed.stan', line 24, column 4 to column 85)",
 " (in 'reductions_allowed.stan', line 12, column 4 to column 16)",
 " (in 'reductions_allowed.stan', line 3, column 8 to column 17)",
 " (in 'reductions_allowed.stan', line 2, column 31 to line 4, column 5)",
 " (in 'reductions_allowed.stan', line 7, column 8 to column 25)",
 " (in 'reductions_allowed.stan', line 6, column 48 to line 8, column 5)"};

struct okay_reduction_functor__ {
  template <typename T0__, typename T1__,
            stan::require_stan_scalar_t<T0__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T1__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T1__>>, -1, -1>
  operator()(const T0__& sum_x, const T1__& y, std::ostream* pstream__) const;
};
struct nono_func_functor__ {
  template <typename T0__,
            stan::require_eigen_matrix_dynamic_t<T0__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
  operator()(const T0__& x, std::ostream* pstream__) const;
};

template <typename T0__,
          stan::require_eigen_matrix_dynamic_t<T0__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
  nono_func(const T0__& x_arg__, std::ostream* pstream__) {
    using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
    int current_statement__ = 0; 
    const auto& x = stan::math::to_ref(x_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 8;
      return x;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, typename T1__,
          stan::require_stan_scalar_t<T0__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T1__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T1__>>, -1, -1>
  okay_reduction(const T0__& sum_x, const T1__& y_arg__,
                 std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<T0__, stan::value_type_t<T1__>>;
    int current_statement__ = 0; 
    const auto& y = stan::math::to_ref(y_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 10;
      return stan::math::add(sum_x, y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, typename T1__, stan::require_stan_scalar_t<T0__>*,
          stan::require_eigen_matrix_dynamic_t<T1__>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T1__>>, -1, -1>
okay_reduction_functor__::operator()(const T0__& sum_x, const T1__& y,
                                     std::ostream* pstream__)  const
{
  return okay_reduction(sum_x, y, pstream__);
}

template <typename T0__, stan::require_eigen_matrix_dynamic_t<T0__>*>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
nono_func_functor__::operator()(const T0__& x, std::ostream* pstream__) 
const
{
  return nono_func(x, pstream__);
}


class reductions_allowed_model final : public model_base_crtp<reductions_allowed_model> {

 private:
  double data_r; 
  
 
 public:
  ~reductions_allowed_model() { }
  
  inline std::string model_name() const final { return "reductions_allowed_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = -fsoa --print-cpp"};
  }
  
  
  reductions_allowed_model(stan::io::var_context& context__,
                           unsigned int random_seed__ = 0,
                           std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "reductions_allowed_model_namespace::reductions_allowed_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 7;
      context__.validate_dims("data initialization","data_r","double",
           std::vector<size_t>{});
      data_r = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 7;
      data_r = context__.vals_r("data_r")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (5 * 10) + (5 * 10) + (5 * 10);
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "reductions_allowed_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, -1>> soa_x =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, -1>>(
           Eigen::Matrix<double, -1, -1>::Constant(5, 10,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 1;
      soa_x = in__.template read<
                stan::conditional_var_value_t<local_scalar_t__, 
                  Eigen::Matrix<local_scalar_t__, -1, -1>>>(5, 10);
      Eigen::Matrix<local_scalar_t__, -1, -1> aos_x =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(5, 10,
           DUMMY_VAR__);
      current_statement__ = 2;
      aos_x = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(5,
                10);
      Eigen::Matrix<local_scalar_t__, -1, -1> aos_y =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(5, 10,
           DUMMY_VAR__);
      current_statement__ = 3;
      aos_y = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(5,
                10);
      local_scalar_t__ tp_real_from_soa = DUMMY_VAR__;
      current_statement__ = 4;
      tp_real_from_soa = (stan::math::logical_gt(5, 0) ? data_r :
                            stan::math::sum(soa_x));
      Eigen::Matrix<local_scalar_t__, -1, -1> tp_matrix_aos_from_mix =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(5, 10,
           DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(tp_matrix_aos_from_mix,
        (stan::math::logical_gt(stan::math::sum(soa_x), 0) ?
           stan::math::eval(nono_func(
                              stan::math::add(aos_x, aos_y), pstream__)) :
           stan::math::eval(aos_y)),
        "assigning variable tp_matrix_aos_from_mix");
      Eigen::Matrix<local_scalar_t__, -1, -1> tp_matrix_from_udf_reduced_soa =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(5, 10,
           DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(tp_matrix_from_udf_reduced_soa,
        okay_reduction(stan::math::sum(soa_x), aos_x, pstream__),
        "assigning variable tp_matrix_from_udf_reduced_soa");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "reductions_allowed_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, -1> soa_x =
         Eigen::Matrix<double, -1, -1>::Constant(5, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      soa_x = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(5,
                10);
      Eigen::Matrix<double, -1, -1> aos_x =
         Eigen::Matrix<double, -1, -1>::Constant(5, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      aos_x = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(5,
                10);
      Eigen::Matrix<double, -1, -1> aos_y =
         Eigen::Matrix<double, -1, -1>::Constant(5, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      aos_y = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(5,
                10);
      double tp_real_from_soa = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double, -1, -1> tp_matrix_aos_from_mix =
         Eigen::Matrix<double, -1, -1>::Constant(5, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> tp_matrix_from_udf_reduced_soa =
         Eigen::Matrix<double, -1, -1>::Constant(5, 10,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(soa_x);
      out__.write(aos_x);
      out__.write(aos_y);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 4;
      tp_real_from_soa = (stan::math::logical_gt(5, 0) ? data_r :
                            stan::math::sum(soa_x));
      current_statement__ = 5;
      stan::model::assign(tp_matrix_aos_from_mix,
        (stan::math::logical_gt(stan::math::sum(soa_x), 0) ?
           stan::math::eval(nono_func(
                              stan::math::add(aos_x, aos_y), pstream__)) :
           stan::math::eval(aos_y)),
        "assigning variable tp_matrix_aos_from_mix");
      current_statement__ = 6;
      stan::model::assign(tp_matrix_from_udf_reduced_soa,
        okay_reduction(stan::math::sum(soa_x), aos_x, pstream__),
        "assigning variable tp_matrix_from_udf_reduced_soa");
      if (emit_transformed_parameters__) {
        out__.write(tp_real_from_soa);
        out__.write(tp_matrix_aos_from_mix);
        out__.write(tp_matrix_from_udf_reduced_soa);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, -1> soa_x =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(5, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          stan::model::assign(soa_x, in__.read<local_scalar_t__>(),
            "assigning variable soa_x", stan::model::index_uni(sym2__),
                                          stan::model::index_uni(sym1__));
        }
      }
      out__.write(soa_x);
      Eigen::Matrix<local_scalar_t__, -1, -1> aos_x =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(5, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          stan::model::assign(aos_x, in__.read<local_scalar_t__>(),
            "assigning variable aos_x", stan::model::index_uni(sym2__),
                                          stan::model::index_uni(sym1__));
        }
      }
      out__.write(aos_x);
      Eigen::Matrix<local_scalar_t__, -1, -1> aos_y =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(5, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          stan::model::assign(aos_y, in__.read<local_scalar_t__>(),
            "assigning variable aos_y", stan::model::index_uni(sym2__),
                                          stan::model::index_uni(sym1__));
        }
      }
      out__.write(aos_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"soa_x", "aos_x", "aos_y",
      "tp_real_from_soa", "tp_matrix_aos_from_mix",
      "tp_matrix_from_udf_reduced_soa"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(5)
                                                                   ,
                                                                   static_cast<size_t>(10)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(10)},
      std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(10)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "soa_x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "aos_x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "aos_y" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp_real_from_soa");
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "tp_matrix_aos_from_mix" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "tp_matrix_from_udf_reduced_soa" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "soa_x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "aos_x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "aos_y" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp_real_from_soa");
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "tp_matrix_aos_from_mix" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "tp_matrix_from_udf_reduced_soa" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"soa_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"aos_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"aos_y\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_from_soa\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"tp_matrix_aos_from_mix\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_matrix_from_udf_reduced_soa\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"soa_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"aos_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"aos_y\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_from_soa\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"tp_matrix_aos_from_mix\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tp_matrix_from_udf_reduced_soa\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((5 * 10) + (5 * 10)) + (5 * 10));
      const size_t num_transformed = 
  ((1 + (5 * 10)) + (5 * 10));
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  (((5 * 10) + (5 * 10)) + (5 * 10));
      const size_t num_transformed = 
  ((1 + (5 * 10)) + (5 * 10));
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 3> names__{"soa_x", "aos_x", "aos_y"};
      const std::array<Eigen::Index, 3> constrain_param_sizes__{(5 * 10),
       (5 * 10), (5 * 10)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } 
using stan_model = reductions_allowed_model_namespace::reductions_allowed_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return reductions_allowed_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp return_types_and_udfs_demotes.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace return_types_and_udfs_demotes_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 13> locations_array__ = 
{" (found before start of program)",
 " (in 'return_types_and_udfs_demotes.stan', line 20, column 4 to column 27)",
 " (in 'return_types_and_udfs_demotes.stan', line 21, column 4 to column 33)",
 " (in 'return_types_and_udfs_demotes.stan', line 25, column 4 to column 68)",
 " (in 'return_types_and_udfs_demotes.stan', line 26, column 4 to column 59)",
 " (in 'return_types_and_udfs_demotes.stan', line 27, column 4 to column 90)",
 " (in 'return_types_and_udfs_demotes.stan', line 28, column 4 to column 73)",
 " (in 'return_types_and_udfs_demotes.stan', line 29, column 4 to column 92)",
 " (in 'return_types_and_udfs_demotes.stan', line 11, column 8 to column 32)",
 " (in 'return_types_and_udfs_demotes.stan', line 12, column 8 to column 24)",
 " (in 'return_types_and_udfs_demotes.stan', line 10, column 29 to line 13, column 5)",
 " (in 'return_types_and_udfs_demotes.stan', line 15, column 8 to column 17)",
 " (in 'return_types_and_udfs_demotes.stan', line 14, column 39 to line 16, column 5)"};

struct empty_user_func_functor__ {
  Eigen::Matrix<double, -1, -1>
  operator()(std::ostream* pstream__) const;
};
struct mat_ret_user_func_functor__ {
  template <typename T0__,
            stan::require_eigen_matrix_dynamic_t<T0__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
  operator()(const T0__& A, std::ostream* pstream__) const;
};

Eigen::Matrix<double, -1, -1> empty_user_func(std::ostream* pstream__) {
    using local_scalar_t__ = double;
    int current_statement__ = 0; 
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      Eigen::Matrix<local_scalar_t__, -1, -1> some_mat =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 9;
      return some_mat;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__,
          stan::require_eigen_matrix_dynamic_t<T0__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
  mat_ret_user_func(const T0__& A_arg__, std::ostream* pstream__) {
    using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
    int current_statement__ = 0; 
    const auto& A = stan::math::to_ref(A_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 11;
      return A;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
Eigen::Matrix<double, -1, -1>
empty_user_func_functor__::operator()(std::ostream* pstream__)  const
{
  return empty_user_func(pstream__);
}

template <typename T0__, stan::require_eigen_matrix_dynamic_t<T0__>*>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
mat_ret_user_func_functor__::operator()(const T0__& A,
                                        std::ostream* pstream__)  const
{
  return mat_ret_user_func(A, pstream__);
}


class return_types_and_udfs_demotes_model final : public model_base_crtp<return_types_and_udfs_demotes_model> {

 private:
   
  
 
 public:
  ~return_types_and_udfs_demotes_model() { }
  
  inline std::string model_name() const final { return "return_types_and_udfs_demotes_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = -fsoa --print-cpp"};
  }
  
  
  return_types_and_udfs_demotes_model(stan::io::var_context& context__,
                                      unsigned int random_seed__ = 0,
                                      std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "return_types_and_udfs_demotes_model_namespace::return_types_and_udfs_demotes_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (10 * 10) + (10 * 10);
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "return_types_and_udfs_demotes_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, -1>> row_soa =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, -1>>(
           Eigen::Matrix<double, -1, -1>::Constant(10, 10,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 1;
      row_soa = in__.template read<
                  stan::conditional_var_value_t<local_scalar_t__, 
                    Eigen::Matrix<local_scalar_t__, -1, -1>>>(10, 10);
      Eigen::Matrix<local_scalar_t__, -1, -1> udf_input_aos =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 2;
      udf_input_aos = in__.template read<
                        Eigen::Matrix<local_scalar_t__, -1, -1>>(10, 10);
      Eigen::Matrix<local_scalar_t__, -1, -1> user_func_aos =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(user_func_aos,
        mat_ret_user_func(udf_input_aos, pstream__),
        "assigning variable user_func_aos");
      Eigen::Matrix<local_scalar_t__, -1, -1> empty_user_func_aos =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(empty_user_func_aos, empty_user_func(pstream__),
        "assigning variable empty_user_func_aos");
      Eigen::Matrix<local_scalar_t__, -1, -1> inner_empty_user_func_aos =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(inner_empty_user_func_aos,
        stan::math::multiply(udf_input_aos, empty_user_func(pstream__)),
        "assigning variable inner_empty_user_func_aos");
      Eigen::Matrix<local_scalar_t__, -1, -1> int_aos_mul_aos =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(int_aos_mul_aos,
        stan::math::multiply(stan::math::rows(row_soa), empty_user_func_aos),
        "assigning variable int_aos_mul_aos");
      Eigen::Matrix<local_scalar_t__, -1, -1> mul_two_aos =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(mul_two_aos,
        stan::math::multiply(
          stan::math::multiply(stan::math::cols(row_soa),
            stan::math::transpose(int_aos_mul_aos)), user_func_aos),
        "assigning variable mul_two_aos");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "return_types_and_udfs_demotes_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, -1> row_soa =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      row_soa = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                  10, 10);
      Eigen::Matrix<double, -1, -1> udf_input_aos =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      udf_input_aos = in__.template read<
                        Eigen::Matrix<local_scalar_t__, -1, -1>>(10, 10);
      Eigen::Matrix<double, -1, -1> user_func_aos =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> empty_user_func_aos =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> inner_empty_user_func_aos =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> int_aos_mul_aos =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> mul_two_aos =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(row_soa);
      out__.write(udf_input_aos);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 3;
      stan::model::assign(user_func_aos,
        mat_ret_user_func(udf_input_aos, pstream__),
        "assigning variable user_func_aos");
      current_statement__ = 4;
      stan::model::assign(empty_user_func_aos, empty_user_func(pstream__),
        "assigning variable empty_user_func_aos");
      current_statement__ = 5;
      stan::model::assign(inner_empty_user_func_aos,
        stan::math::multiply(udf_input_aos, empty_user_func(pstream__)),
        "assigning variable inner_empty_user_func_aos");
      current_statement__ = 6;
      stan::model::assign(int_aos_mul_aos,
        stan::math::multiply(stan::math::rows(row_soa), empty_user_func_aos),
        "assigning variable int_aos_mul_aos");
      current_statement__ = 7;
      stan::model::assign(mul_two_aos,
        stan::math::multiply(
          stan::math::multiply(stan::math::cols(row_soa),
            stan::math::transpose(int_aos_mul_aos)), user_func_aos),
        "assigning variable mul_two_aos");
      if (emit_transformed_parameters__) {
        out__.write(user_func_aos);
        out__.write(empty_user_func_aos);
        out__.write(inner_empty_user_func_aos);
        out__.write(int_aos_mul_aos);
        out__.write(mul_two_aos);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, -1> row_soa =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          stan::model::assign(row_soa, in__.read<local_scalar_t__>(),
            "assigning variable row_soa", stan::model::index_uni(sym2__),
                                            stan::model::index_uni(sym1__));
        }
      }
      out__.write(row_soa);
      Eigen::Matrix<local_scalar_t__, -1, -1> udf_input_aos =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          stan::model::assign(udf_input_aos, in__.read<local_scalar_t__>(),
            "assigning variable udf_input_aos", stan::model::index_uni(sym2__),
                                                  stan::model::index_uni(sym1__));
        }
      }
      out__.write(udf_input_aos);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"row_soa", "udf_input_aos",
      "user_func_aos", "empty_user_func_aos", "inner_empty_user_func_aos",
      "int_aos_mul_aos", "mul_two_aos"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(10)
                                                                   ,
                                                                   static_cast<size_t>(10)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "row_soa" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "udf_input_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "user_func_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "empty_user_func_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "inner_empty_user_func_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "int_aos_mul_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "mul_two_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "row_soa" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "udf_input_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "user_func_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "empty_user_func_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "inner_empty_user_func_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "int_aos_mul_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "mul_two_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"row_soa\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"udf_input_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"user_func_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"empty_user_func_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"inner_empty_user_func_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"int_aos_mul_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mul_two_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"row_soa\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"udf_input_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"user_func_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"empty_user_func_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"inner_empty_user_func_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"int_aos_mul_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"},{\"name\":\"mul_two_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((10 * 10) + (10 * 10));
      const size_t num_transformed = (((((10 * 10)
                                                                    +
                                                                    (10 * 10))
                                                                    +
                                                                    (10 * 10))
                                                                   +
                                                                   (10 * 10))
                                                                  +
                                                                  (10 * 10));
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((10 * 10) + (10 * 10));
      const size_t num_transformed = (((((10 * 10)
                                                                    +
                                                                    (10 * 10))
                                                                    +
                                                                    (10 * 10))
                                                                   +
                                                                   (10 * 10))
                                                                  +
                                                                  (10 * 10));
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"row_soa",
      "udf_input_aos"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{(10 * 10),
       (10 * 10)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } 
using stan_model = return_types_and_udfs_demotes_model_namespace::return_types_and_udfs_demotes_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return return_types_and_udfs_demotes_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp single_indexing.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace single_indexing_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 8> locations_array__ = 
{" (found before start of program)",
 " (in 'single_indexing.stan', line 6, column 3 to column 24)",
 " (in 'single_indexing.stan', line 7, column 3 to column 24)",
 " (in 'single_indexing.stan', line 11, column 5 to column 41)",
 " (in 'single_indexing.stan', line 14, column 7 to column 78)",
 " (in 'single_indexing.stan', line 16, column 7 to column 77)",
 " (in 'single_indexing.stan', line 12, column 21 to line 17, column 6)",
 " (in 'single_indexing.stan', line 12, column 5 to line 17, column 6)"};




class single_indexing_model final : public model_base_crtp<single_indexing_model> {

 private:
   
  
 
 public:
  ~single_indexing_model() { }
  
  inline std::string model_name() const final { return "single_indexing_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = -fsoa --print-cpp"};
  }
  
  
  single_indexing_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "single_indexing_model_namespace::single_indexing_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (10 * 10) + (10 * 10);
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "single_indexing_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, -1> aos_p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      current_statement__ = 1;
      aos_p = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
                10);
      stan::conditional_var_value_t<local_scalar_t__, 
        Eigen::Matrix<local_scalar_t__, -1, -1>> soa_p =
         stan::conditional_var_value_t<local_scalar_t__, 
           Eigen::Matrix<local_scalar_t__, -1, -1>>(
           Eigen::Matrix<double, -1, -1>::Constant(10, 10,
             std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 2;
      soa_p = in__.template read<
                stan::conditional_var_value_t<local_scalar_t__, 
                  Eigen::Matrix<local_scalar_t__, -1, -1>>>(10, 10);
      local_scalar_t__ tp_real_from_soa = DUMMY_VAR__;
      current_statement__ = 3;
      tp_real_from_soa = stan::model::rvalue(soa_p, "soa_p",
                           stan::model::index_uni(1),
                             stan::model::index_uni(1));
      current_statement__ = 7;
      for (int i = 1; i <= 10; ++i) {
        stan::conditional_var_value_t<local_scalar_t__, 
          Eigen::Matrix<local_scalar_t__, 1, -1>> tp_row_vector_from_soa_loop =
           stan::conditional_var_value_t<local_scalar_t__, 
             Eigen::Matrix<local_scalar_t__, 1, -1>>(
             Eigen::Matrix<double, 1, -1>::Constant(10,
               std::numeric_limits<double>::quiet_NaN()));
        current_statement__ = 4;
        stan::model::assign(tp_row_vector_from_soa_loop,
          stan::math::multiply(
            stan::model::rvalue(soa_p, "soa_p", stan::model::index_uni(i)),
            soa_p), "assigning variable tp_row_vector_from_soa_loop");
        stan::conditional_var_value_t<local_scalar_t__, 
          Eigen::Matrix<local_scalar_t__, -1, -1>> tp_matrix_from_soa_loop =
           stan::conditional_var_value_t<local_scalar_t__, 
             Eigen::Matrix<local_scalar_t__, -1, -1>>(
             Eigen::Matrix<double, -1, -1>::Constant(10, 10,
               std::numeric_limits<double>::quiet_NaN()));
        current_statement__ = 5;
        stan::model::assign(tp_matrix_from_soa_loop,
          stan::math::multiply(
            stan::model::rvalue(aos_p, "aos_p",
              stan::model::index_uni(i), stan::model::index_uni(i)), soa_p),
          "assigning variable tp_matrix_from_soa_loop");
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "single_indexing_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, -1> aos_p =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      aos_p = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
                10);
      Eigen::Matrix<double, -1, -1> soa_p =
         Eigen::Matrix<double, -1, -1>::Constant(10, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      soa_p = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(10,
                10);
      double tp_real_from_soa = std::numeric_limits<double>::quiet_NaN();
      out__.write(aos_p);
      out__.write(soa_p);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 3;
      tp_real_from_soa = stan::model::rvalue(soa_p, "soa_p",
                           stan::model::index_uni(1),
                             stan::model::index_uni(1));
      current_statement__ = 7;
      for (int i = 1; i <= 10; ++i) {
        Eigen::Matrix<double, 1, -1> tp_row_vector_from_soa_loop =
           Eigen::Matrix<double, 1, -1>::Constant(10,
             std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 4;
        stan::model::assign(tp_row_vector_from_soa_loop,
          stan::math::multiply(
            stan::model::rvalue(soa_p, "soa_p", stan::model::index_uni(i)),
            soa_p), "assigning variable tp_row_vector_from_soa_loop");
        Eigen::Matrix<double, -1, -1> tp_matrix_from_soa_loop =
           Eigen::Matrix<double, -1, -1>::Constant(10, 10,
             std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 5;
        stan::model::assign(tp_matrix_from_soa_loop,
          stan::math::multiply(
            stan::model::rvalue(aos_p, "aos_p",
              stan::model::index_uni(i), stan::model::index_uni(i)), soa_p),
          "assigning variable tp_matrix_from_soa_loop");
      }
      if (emit_transformed_parameters__) {
        out__.write(tp_real_from_soa);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, -1> aos_p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          stan::model::assign(aos_p, in__.read<local_scalar_t__>(),
            "assigning variable aos_p", stan::model::index_uni(sym2__),
                                          stan::model::index_uni(sym1__));
        }
      }
      out__.write(aos_p);
      Eigen::Matrix<local_scalar_t__, -1, -1> soa_p =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(10, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          stan::model::assign(soa_p, in__.read<local_scalar_t__>(),
            "assigning variable soa_p", stan::model::index_uni(sym2__),
                                          stan::model::index_uni(sym1__));
        }
      }
      out__.write(soa_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"aos_p", "soa_p", "tp_real_from_soa"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(10)
                                                                   ,
                                                                   static_cast<size_t>(10)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(10), static_cast<size_t>(10)},
      std::vector<size_t>{}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "aos_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "soa_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp_real_from_soa");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "aos_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 10; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "soa_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp_real_from_soa");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"aos_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"soa_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_from_soa\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"aos_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"soa_p\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(10) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"tp_real_from_soa\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((10 * 10) + (10 * 10));
      const size_t num_transformed = 1;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((10 * 10) + (10 * 10));
      const size_t num_transformed = 1;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"aos_p", "soa_p"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{(10 * 10),
       (10 * 10)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
    
};
}
using stan_model = single_indexing_model_namespace::single_indexing_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return single_indexing_model_namespace::profiles__;
}

#endif



  $ ../../../../../../install/default/bin/stanc -fsoa --print-cpp tp_reused.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace tp_reused_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 10> locations_array__ = 
{" (found before start of program)",
 " (in 'tp_reused.stan', line 16, column 4 to column 36)",
 " (in 'tp_reused.stan', line 17, column 4 to column 25)",
 " (in 'tp_reused.stan', line 21, column 4 to column 51)",
 " (in 'tp_reused.stan', line 22, column 4 to column 37)",
 " (in 'tp_reused.stan', line 12, column 4 to column 16)",
 " (in 'tp_reused.stan', line 3, column 8 to column 17)",
 " (in 'tp_reused.stan', line 2, column 31 to line 4, column 5)",
 " (in 'tp_reused.stan', line 7, column 8 to column 25)",
 " (in 'tp_reused.stan', line 6, column 48 to line 8, column 5)"};

struct okay_reduction_functor__ {
  template <typename T0__, typename T1__,
            stan::require_stan_scalar_t<T0__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T1__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T1__>>, -1, -1>
  operator()(const T0__& sum_x, const T1__& y, std::ostream* pstream__) const;
};
struct nono_func_functor__ {
  template <typename T0__,
            stan::require_eigen_matrix_dynamic_t<T0__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
  operator()(const T0__& x, std::ostream* pstream__) const;
};

template <typename T0__,
          stan::require_eigen_matrix_dynamic_t<T0__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
  nono_func(const T0__& x_arg__, std::ostream* pstream__) {
    using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
    int current_statement__ = 0; 
    const auto& x = stan::math::to_ref(x_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 6;
      return x;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, typename T1__,
          stan::require_stan_scalar_t<T0__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T1__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T1__>>, -1, -1>
  okay_reduction(const T0__& sum_x, const T1__& y_arg__,
                 std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<T0__, stan::value_type_t<T1__>>;
    int current_statement__ = 0; 
    const auto& y = stan::math::to_ref(y_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 8;
      return stan::math::add(sum_x, y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, typename T1__, stan::require_stan_scalar_t<T0__>*,
          stan::require_eigen_matrix_dynamic_t<T1__>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T1__>>, -1, -1>
okay_reduction_functor__::operator()(const T0__& sum_x, const T1__& y,
                                     std::ostream* pstream__)  const
{
  return okay_reduction(sum_x, y, pstream__);
}

template <typename T0__, stan::require_eigen_matrix_dynamic_t<T0__>*>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
nono_func_functor__::operator()(const T0__& x, std::ostream* pstream__) 
const
{
  return nono_func(x, pstream__);
}

 class tp_reused_model final : public model_base_crtp<tp_reused_model> {

 private:
  double data_r; 
  
 
 public:
  ~tp_reused_model() { }
  
  inline std::string model_name() const final { return "tp_reused_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = -fsoa --print-cpp"};
  }
  
  
  tp_reused_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "tp_reused_model_namespace::tp_reused_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 5;
      context__.validate_dims("data initialization","data_r","double",
           std::vector<size_t>{});
      data_r = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 5;
      data_r = context__.vals_r("data_r")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (5 * 10) + (5 * 10);
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "tp_reused_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, -1> first_pass_soa_x =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(5, 10,
           DUMMY_VAR__);
      current_statement__ = 1;
      first_pass_soa_x = in__.template read<
                           Eigen::Matrix<local_scalar_t__, -1, -1>>(5, 10);
      Eigen::Matrix<local_scalar_t__, -1, -1> aos_x =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(5, 10,
           DUMMY_VAR__);
      current_statement__ = 2;
      aos_x = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(5,
                10);
      Eigen::Matrix<local_scalar_t__, -1, -1> tp_matrix_aos =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(5, 10,
           DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(tp_matrix_aos, first_pass_soa_x,
        "assigning variable tp_matrix_aos");
      current_statement__ = 4;
      stan::model::assign(tp_matrix_aos, nono_func(aos_x, pstream__),
        "assigning variable tp_matrix_aos");
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "tp_reused_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, -1> first_pass_soa_x =
         Eigen::Matrix<double, -1, -1>::Constant(5, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      first_pass_soa_x = in__.template read<
                           Eigen::Matrix<local_scalar_t__, -1, -1>>(5, 10);
      Eigen::Matrix<double, -1, -1> aos_x =
         Eigen::Matrix<double, -1, -1>::Constant(5, 10,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      aos_x = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(5,
                10);
      Eigen::Matrix<double, -1, -1> tp_matrix_aos =
         Eigen::Matrix<double, -1, -1>::Constant(5, 10,
           std::numeric_limits<double>::quiet_NaN());
      out__.write(first_pass_soa_x);
      out__.write(aos_x);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 3;
      stan::model::assign(tp_matrix_aos, first_pass_soa_x,
        "assigning variable tp_matrix_aos");
      current_statement__ = 4;
      stan::model::assign(tp_matrix_aos, nono_func(aos_x, pstream__),
        "assigning variable tp_matrix_aos");
      if (emit_transformed_parameters__) {
        out__.write(tp_matrix_aos);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, -1> first_pass_soa_x =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(5, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          stan::model::assign(first_pass_soa_x,
            in__.read<local_scalar_t__>(),
            "assigning variable first_pass_soa_x", stan::model::index_uni(sym2__),
                                                     stan::model::index_uni(sym1__));
        }
      }
      out__.write(first_pass_soa_x);
      Eigen::Matrix<local_scalar_t__, -1, -1> aos_x =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(5, 10,
           DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          stan::model::assign(aos_x, in__.read<local_scalar_t__>(),
            "assigning variable aos_x", stan::model::index_uni(sym2__),
                                          stan::model::index_uni(sym1__));
        }
      }
      out__.write(aos_x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"first_pass_soa_x", "aos_x",
      "tp_matrix_aos"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(5)
                                                                   ,
                                                                   static_cast<size_t>(10)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(10)},
      std::vector<size_t>{static_cast<size_t>(5), static_cast<size_t>(10)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "first_pass_soa_x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "aos_x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "tp_matrix_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "first_pass_soa_x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "aos_x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 10; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 5; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "tp_matrix_aos" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"first_pass_soa_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"aos_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"tp_matrix_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"first_pass_soa_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"aos_x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"parameters\"},{\"name\":\"tp_matrix_aos\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(5) + ",\"cols\":" + std::to_string(10) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((5 * 10) + (5 * 10));
      const size_t num_transformed = (5 * 10);
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((5 * 10) + (5 * 10));
      const size_t num_transformed = (5 * 10);
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 2> names__{"first_pass_soa_x",
      "aos_x"};
      const std::array<Eigen::Index, 2> constrain_param_sizes__{(5 * 10),
       (5 * 10)};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } using stan_model = tp_reused_model_namespace::tp_reused_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return tp_reused_model_namespace::profiles__;
}

#endif



