<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>core_ideas (stanc.core_ideas)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['db.js','../sherlodoc.js'];
</script><script src="../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="../index.html">Index</a> &#x00BB; <a href="index.html">stanc</a> &#x00BB; core_ideas</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1 id="core-ideas"><a href="#core-ideas" class="anchor"></a>Core Ideas</h1><p>This is not meant to be tutorial on the OCaml language itself, but rather on some of the features and libraries of Stanc3 which may not be familiar to developers who do have some OCaml exposure.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#the-jane-street-standard-library">The Jane Street standard library</a><ul><li><a href="#deriving-functions">Deriving functions</a></li></ul></li><li><a href="#&quot;two-level-types&quot;">&quot;Two Level Types&quot;</a></li><li><a href="#the-fmt-library-and-pretty-printing">The <code>Fmt</code> library and pretty-printing</a></li></ul></nav></div><div class="odoc-content"><h2 id="the-jane-street-standard-library"><a href="#the-jane-street-standard-library" class="anchor"></a>The Jane Street standard library</h2><p>We use Jane Street's <a href="https://ocaml.janestreet.com/ocaml-core/v0.14/doc/core/index.html">Core</a> standard library. There are a few differences from the OCaml standard library which are instantly noticeable:</p><ul><li><p>Most higher-order functions such as <code>List.map</code> take a <i>named</i> function argument.</p><p>This means a call like <code>List.map square [1;2;3]</code> will look like <code>List.map ~f:square [1;2;3]</code>.</p></li><li><p>Core defaults to safe operations which return <i>options</i> rather than possibly erring.</p><p>In &quot;normal&quot; OCaml, <code>List.hd</code> has type <code>'a list -&gt; 'a</code>. A call <code>List.hd []</code> will throw an exception. By contrast, in the Jane Street libraries, the same function has type <code>'a list -&gt; 'a option</code>.</p><p>Usually, a function with the suffix <code>_exn</code> recovers the original signature, e.g. <code>List.hd_exn : 'a list -&gt; 'a </code>.</p></li></ul><p>If for some reason you <em>need</em> functionality from the OCaml standard library that is not available in Jane Street (be sure to triple check), you can use the modules <code>Stdlib</code> and <code>Caml</code> to access the built-in versions. Currently there is only one such usage in the compiler, to use the standard definition of <code>!=</code> in the Menhir parser.</p><p>There are a few other things we gain from these libraries. The most important idea to understand is <b>deriving</b>.</p><h3 id="deriving-functions"><a href="#deriving-functions" class="anchor"></a>Deriving functions</h3><p>If you look at a type declaration of something like <code>Ast.typed_expression</code>, you'll notice something curious after the declaration:</p><pre class="language-ocaml"><code>type typed_expression = (typed_expr_meta, fun_kind) expr_with
[@@deriving sexp, compare, map, hash, fold]</code></pre><p>When using an editor that supports code completion, you may notice that the <code>Ast</code> module suggests functions which are not defined in the actual source text. This is because these functions are created at compile time by <a href="https://github.com/ocaml-ppx/ppx_deriving"><code>ppx_deriving</code></a>.The above syntax <code>[@@deriving ...]</code> indicates which functions we would like to be generated.</p><p>These are very helpful - if a type derives <code>hash</code>, it can automatically be used as keys in Jane Street's hash tables, and a type which derives <code>sexp</code> can be serialized to Lisp-style S-Expressions. Most of our major types derive at least one function.</p><h2 id="&quot;two-level-types&quot;"><a href="#&quot;two-level-types&quot;" class="anchor"></a>&quot;Two Level Types&quot;</h2><p>The other curious thing about the types we define in our AST and MIR is that they use a trick known as &quot;two level types&quot;. This allows re-using the same type structure with different amounts of metadata attached (e.g., before type checking we have an <code>untyped_program</code> which only has nodes and their source locations, after type checking we have <code>typed_program</code> which features nodes, locations, <i>and</i> types, in the same basic tree structure.</p><p>The way that this is implemented is a bit non-obvious at first. Essentially, many of the tree variant types are parameterized by something that ends up being a placeholder not for just metadata but for the recursive type including metadata, sometimes called the fixed point. So instead of recursively referencing <code>expression</code>, you would instead reference type parameter <code>'e</code>, which will later be filled in with something like <code>type expr_with_meta = metadata expression</code>.</p><p>This takes some getting used to, and also can lead to some unhelpful type signatures in editors such as VSCode, because abbreviations are not always used in hover-over text. For example, <code>Expr.Typed.t</code>, the MIR's typed expression type, actually has a signature of <code>Expr.Typed.Meta.t Expr.t</code>.</p><h2 id="the-fmt-library-and-pretty-printing"><a href="#the-fmt-library-and-pretty-printing" class="anchor"></a>The <code>Fmt</code> library and pretty-printing</h2><p>We extensively use the <a href="https://erratique.ch/software/fmt">Fmt</a> library for our pretty-printing and code generation. We have an existing guide on the <a href="https://github.com/stan-dev/stanc3/wiki/Format---Fmt-code-generation-quickstart">wiki</a> which covers the core ideas.</p></div></body></html>
