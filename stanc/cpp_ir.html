<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>cpp_ir (stanc.cpp_ir)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['db.js','../sherlodoc.js'];
</script><script src="../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="../index.html">Index</a> &#x00BB; <a href="index.html">stanc</a> &#x00BB; cpp_ir</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1 id="c++-code-generation"><a href="#c++-code-generation" class="anchor"></a>C++ Code Generation</h1><p>The main backend of the compiler is the &quot;Stan Math&quot; (C++) backend. We represent C++ code with a data types and functions found in <a href="Stan_math_backend/Cpp/index.html"><code>Stan_math_backend.Cpp</code></a>.</p><p>We also define a sort of miniature embedded domain specific language (DSL) for using these types. These helper functions and operators are all in sub-modules of <a href="Stan_math_backend/Cpp/index.html"><code>Stan_math_backend.Cpp</code></a>, for example <a href="Stan_math_backend/Cpp/DSL/index.html"><code>Stan_math_backend.Cpp.DSL</code></a>.</p><p>These allow writing OCaml code which looks or feels more like the C++ it will generate. These constructs should be used when they improve clarity, and avoided when they make the code harder to read. When combined with good variable names, this can lead to code like <code> lp_accum__.@?((&quot;add&quot;, [Var &quot;lp__&quot;])) </code>, which hopefully reads quite clearly as equivalent to the C++ <code>lp_accum__.add(lp__)</code>.</p><p>After a Stan program is lowered to this type, it can be printed to C++ using <a href="Stan_math_backend/Cpp/Printing/index.html"><code>Stan_math_backend.Cpp.Printing</code></a>. This module uses <code>Fmt</code>, but keeps the question of how C++ should be formatted separate from the question of what the generated C++ <em>is</em>.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#dsl-example">DSL Example</a></li></ul></nav></div><div class="odoc-content"><h2 id="dsl-example"><a href="#dsl-example" class="anchor"></a>DSL Example</h2><p>For example, lets say one wanted to generate the expression</p><pre class="language-ocaml"><code>(Eigen::Matrix&lt;double,1,-1&gt;(3) &lt;&lt; 1, a, 3).finished()</code></pre><p>This could be written down as the literal OCaml type it is:</p><pre class="language-ocaml"><code>(MethodCall (Parens (StreamInsertion (Constructor (Matrix (Double, 1, -1), [Literal &quot;3&quot;]), [Literal &quot;1&quot;; Var &quot;a&quot;; Literal &quot;3&quot;]), &quot;finished&quot;, [], [])</code></pre><p>Or, using the DSL constructs, the same expression could be written</p><pre class="language-ocaml"><code>let open Cpp.DSL in
let open Types in
let vector = (row_vector Double).:{Literal &quot;3&quot;} in
let values = [Literal &quot;1&quot;; Var &quot;a&quot;; Literal &quot;3&quot;] in
(vector &lt;&lt; values).@!(&quot;finished&quot;)</code></pre></div></body></html>
