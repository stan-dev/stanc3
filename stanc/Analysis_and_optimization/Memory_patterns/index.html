<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Memory_patterns (stanc.Analysis_and_optimization.Memory_patterns)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">stanc</a> &#x00BB; <a href="../index.html">Analysis_and_optimization</a> &#x00BB; Memory_patterns</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Analysis_and_optimization.Memory_patterns</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-demotion"><a href="#type-demotion" class="anchor"></a><code><span><span class="keyword">type</span> demotion</span><span> = int * <a href="../../Middle/Mem_pattern/index.html#type-t">Middle.Mem_pattern.t</a> * string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_demotion"><a href="#val-compare_demotion" class="anchor"></a><code><span><span class="keyword">val</span> compare_demotion : <span><a href="#type-demotion">demotion</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-demotion">demotion</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-demotion_reasons"><a href="#val-demotion_reasons" class="anchor"></a><code><span><span class="keyword">val</span> demotion_reasons : <span><span><a href="#type-demotion">demotion</a> list</span> <span class="xref-unresolved">Core</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_warnings"><a href="#val-get_warnings" class="anchor"></a><code><span><span class="keyword">val</span> get_warnings : <span>unit <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-user_warning_op"><a href="#val-user_warning_op" class="anchor"></a><code><span><span class="keyword">val</span> user_warning_op : <span><a href="../../Middle/Mem_pattern/index.html#type-t">Middle.Mem_pattern.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-concat_set_str"><a href="#val-concat_set_str" class="anchor"></a><code><span><span class="keyword">val</span> concat_set_str : <span><span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-matrix_set"><a href="#val-matrix_set" class="anchor"></a><code><span><span class="keyword">val</span> matrix_set : 
  <span><span><a href="../../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../../Middle/Expr/index.html#type-t">Middle.Expr.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Dataflow_types/index.html#type-vexpr">Dataflow_types.vexpr</a> * <a href="../../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>)</span> <span class="xref-unresolved">Core</span>.Set.Poly.t</span></span></code></div><div class="spec-doc"><p>Return a Var expression of the name for each type containing an eigen matrix</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-query_var_eigen_names"><a href="#val-query_var_eigen_names" class="anchor"></a><code><span><span class="keyword">val</span> query_var_eigen_names : <span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span></span></code></div><div class="spec-doc"><p>Return a set of all types containing autodiffable Eigen matrices in an expression.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_nonzero_subset"><a href="#val-is_nonzero_subset" class="anchor"></a><code><span><span class="keyword">val</span> is_nonzero_subset : 
  <span><span class="label">set</span>:<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Core</span>.Set.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">subset</span>:<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Core</span>.Set.t</span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p>Check whether one set is a nonzero subset of another set.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-count_single_idx"><a href="#val-count_single_idx" class="anchor"></a><code><span><span class="keyword">val</span> count_single_idx : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../../Middle/Index/index.html#type-t">Middle.Index.t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Check an Index to count how many times we see a single index.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">acc</span> <p>An accumulator from previous folds of multiple expressions.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">idx</span> <p>An Index to match. For Single types this adds 1 to the acc. For Upfrom and MultiIndex types we check the inner expression for a Single index. All and Between cannot be Single cell access and so pass acc along.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_uni_eigen_loop_indexing"><a href="#val-is_uni_eigen_loop_indexing" class="anchor"></a><code><span><span class="keyword">val</span> is_uni_eigen_loop_indexing : 
  <span>bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../../Middle/Index/index.html#type-t">Middle.Index.t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p>Find indices on Matrix and Vector types that perform single cell access. Returns true if it finds a vector, row vector, matrix, or matrix with single cell access as well as an array of any of the above that is accessing the inner matrix types cell.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">ut</span> <p>An UnsizedType to match against.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">index</span> <p>This list is checked for Single cell access either at the top level or within the <code>Index</code> types of the list.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-query_stan_math_mem_pattern_support"><a href="#val-query_stan_math_mem_pattern_support" class="anchor"></a><code><span><span class="keyword">val</span> query_stan_math_mem_pattern_support : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Middle/UnsizedType/index.html#type-argumentlist">Middle.UnsizedType.argumentlist</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_fun_soa_supported"><a href="#val-is_fun_soa_supported" class="anchor"></a><code><span><span class="keyword">val</span> is_fun_soa_supported : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Validate whether a function can support SoA matrices</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-query_initial_demotable_expr"><a href="#val-query_initial_demotable_expr" class="anchor"></a><code><span><span class="keyword">val</span> query_initial_demotable_expr : 
  <span>bool <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">acc</span>:<span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span></span></code></div><div class="spec-doc"><p>Query to find the initial set of objects that cannot be SoA. This is mostly recursing over expressions, with the exceptions being functions and indexing expressions. For the logic on functions see the docs for <code>query_initial_demotable_funs</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">in_loop</span> <p>a boolean to signify if the expression exists inside of a loop. If so, the names of matrix and vector like objects will be returned if the matrix or vector is accessed by single cell indexing.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-query_initial_demotable_funs"><a href="#val-query_initial_demotable_funs" class="anchor"></a><code><span><span class="keyword">val</span> query_initial_demotable_funs : 
  <span>bool <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../../Middle/Expr/index.html#type-t">Middle.Expr.t</a></span> <a href="../../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span></span></code></div><div class="spec-doc"><p>Query a function to detect if it or any of its used expression's objects or expressions should be demoted to AoS.</p><p>The logic here demotes the expressions in a function to AoS if the function's inner expression returns has a meta type containing a matrix and either of :</p><ol><li>The function is user defined and the UDFs inputs are matrices.</li><li>The Stan math function cannot support AoS</li></ol><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">in_loop</span> <p>A boolean to specify the logic of indexing expressions. See <code>query_initial_demotable_expr</code> for an explanation of the logic.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">kind</span> <p>The function type, for StanLib functions we check if the function supports SoA and for UserDefined functions we always fail and return back all of the names of the objects passed in expressions to the UDF. exprs The expression list passed to the functions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-extract_nonderived_admatrix_types"><a href="#val-extract_nonderived_admatrix_types" class="anchor"></a><code><span><span class="keyword">val</span> extract_nonderived_admatrix_types : 
  <span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Middle/UnsizedType/index.html#type-autodifftype">Middle.UnsizedType.autodifftype</a> * <a href="../../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a>)</span> list</span></span></code></div><div class="spec-doc"><p>Recurse through subexpressions and return a list of Unsized types. Recursion continues until</p><ol><li>A non-autodiffable type is found</li><li>An autodiffable scalar is found</li><li>A `Var` type is found that is an autodiffable matrix</li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-extract_nonderived_admatrix_types_fun"><a href="#val-extract_nonderived_admatrix_types_fun" class="anchor"></a><code><span><span class="keyword">val</span> extract_nonderived_admatrix_types_fun : 
  <span><span><span><a href="../../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../../Middle/Expr/index.html#type-t">Middle.Expr.t</a></span> <a href="../../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Middle/UnsizedType/index.html#type-autodifftype">Middle.UnsizedType.autodifftype</a> * <a href="../../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a>)</span> list</span></span></code></div><div class="spec-doc"><p>Recurse through functions to find nonderived ad matrix types. Special cases for StanLib functions are for</p><ul><li>`check_matching_dims`: compiler function that has no effect on optimization</li><li>`rep_*vector` These are templated in the C++ to cast up to `Var&lt;Matrix&gt;` types</li><li>`rep_matrix`. When it's only a scalar being propagated an math library overload can upcast to `Var&lt;Matrix&gt;`</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contains_at_least_one_ad_matrix_or_all_data"><a href="#val-contains_at_least_one_ad_matrix_or_all_data" class="anchor"></a><code><span><span class="keyword">val</span> contains_at_least_one_ad_matrix_or_all_data : 
  <span><a href="../../Middle/UnsizedType/index.html#type-argumentlist">Middle.UnsizedType.argumentlist</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p>Checks if a list of types contains at least on ad matrix or if everything is derived from data</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-query_initial_demotable_stmt"><a href="#val-query_initial_demotable_stmt" class="anchor"></a><code><span><span class="keyword">val</span> query_initial_demotable_stmt : 
  <span>bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>, <a href="../../Middle/Stmt/Located/Meta/index.html#type-t">Middle.Stmt.Located.Meta.t</a>)</span> <a href="../../Middle/Stmt/index.html#type-t">Middle.Stmt.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span></span></code></div><div class="spec-doc"><p>Query to find the initial set of objects in statements that cannot be SoA. This is mostly recursive over expressions and statements, with the exception of functions and Assignments. For assignments: We demote the LHS variable if any of the following are true:</p><ol><li>A single cell of the LHS is being assigned within a loop.</li><li>The top level expression on the RHS is a combination of only data matrices and scalar types. Operations on data matrix and scalar values in Stan math will return a AoS matrix. We currently have no way to tell Stan math to return a SoA matrix.</li><li>None of the RHS's functions are able to accept SoA matrices and the rhs is not an internal compiler function.</li></ol><p>We demote RHS variables if any of the following are true:</p><ol><li>The LHS variable has previously or through this iteration been marked AoS.</li><li>The LHS is a tuple projection</li></ol><p>For functions see the documentation for <code>query_initial_demotable_funs</code> for the logic on demotion rules.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">in_loop</span> <p>A boolean to specify the logic of indexing expressions. See <code>query_initial_demotable_expr</code> for an explanation of the logic.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-query_demotable_stmt"><a href="#val-query_demotable_stmt" class="anchor"></a><code><span><span class="keyword">val</span> query_demotable_stmt : 
  <span><span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Middle/Stmt/Located/Non_recursive/index.html#type-t">Middle.Stmt.Located.Non_recursive.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span></span></code></div><div class="spec-doc"><p>Look through a statement to see whether the objects used in it need to be modified from SoA to AoS. Returns the set of object names that need demoted in a statement, if any. This function looks at Assignment statements, and returns back the set of top level object names given:</p><ol><li>If the name of the lhs assignee is in the <code>aos_exits</code>, all the names of the expressions with a type containing a matrix are returned.</li><li>If the names of the rhs objects containing matrix types are in the subset of aos_exits.</li></ol><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">aos_exits</span> <p>A set of variables that can be demoted.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pattern</span> <p>The Stmt pattern to query.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-modify_kind"><a href="#val-modify_kind" class="anchor"></a><code><span><span class="keyword">val</span> modify_kind : 
  <span><span class="optlabel">?force_demotion</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> * <span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span></span></code></div><div class="spec-doc"><p>Modify a function and it's subexpressions from SoA &lt;-&gt; AoS and vice versa. This performs demotion for sub expressions recursively. The top level expression and it's sub expressions are demoted to SoA if</p><ol><li>The names of the variables in the subexpressions returning objects holding matrices are all in the modifiable set.</li><li>The function does not support SoA 3. The <code>force</code> argument is <code>true</code></li></ol><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">force_demotion</span> <p>If true, forces an expression and it's sub-expressions to be AoS.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">modifiable_set</span> <p>The set of names that are either demotable to AoS or promotable to SoA.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">kind</span> <p>A <code>Fun_kind.t</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">exprs</span> <p>A list of expressions going into the function. *</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-modify_expr_pattern"><a href="#val-modify_expr_pattern" class="anchor"></a><code><span><span class="keyword">val</span> modify_expr_pattern : 
  <span><span class="optlabel">?force_demotion</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../../Middle/Expr/Pattern/index.html#type-t">Middle.Expr.Pattern.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../../Middle/Expr/Pattern/index.html#type-t">Middle.Expr.Pattern.t</a></span></span></code></div><div class="spec-doc"><p>Modify an expression and it's subexpressions from SoA &lt;-&gt; AoS and vice versa. The only real paths in the below is on the functions and ternary expressions. The logic for functions is defined in <code>modify_kind</code>. <code>TernaryIf</code> is forcefully demoted to AoS if the type of the expression contains a matrix.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">force_demotion</span> <p>If true, forces an expression and it's sub-expressions to be AoS.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">modifiable_set</span> <p>The name of the variables whose associated expressions we want to modify.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pattern</span> <p>The expression to modify.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-modify_expr"><a href="#val-modify_expr" class="anchor"></a><code><span><span class="keyword">val</span> modify_expr : 
  <span><span class="optlabel">?force_demotion</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a></span></code></div><div class="spec-doc"><p>Given a Set of strings containing the names of objects that can be modified from AoS &lt;-&gt; SoA and vice versa, modify them within the expression.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">mem_pattern</span> <p>The memory pattern to change expressions to.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">modifiable_set</span> <p>The name of the variables whose associated expressions we want to modify.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">expr</span> <p>the expression to modify.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-modify_stmt_pattern"><a href="#val-modify_stmt_pattern" class="anchor"></a><code><span><span class="keyword">val</span> modify_stmt_pattern : 
  <span><span><span>(<a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>, <a href="../../Middle/Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a>)</span> <a href="../../Middle/Stmt/Pattern/index.html#type-t">Middle.Stmt.Pattern.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>, <a href="../../Middle/Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a>)</span> <a href="../../Middle/Stmt/Pattern/index.html#type-t">Middle.Stmt.Pattern.t</a></span></span></code></div><div class="spec-doc"><p>Modify statement patterns in the MIR from AoS &lt;-&gt; SoA and vice versa For <code>Decl</code> and <code>Assignment</code>'s reading in parameters, we demote to AoS if the <code>decl_id</code> (or assign name) is in the modifiable set and otherwise promote the statement to <code>SoA</code>. For general <code>Assignment</code> statements, we check if the assignee is in the demotable set. If so, we force demotion of all of the rhs expressions. All other statements recurse over their statements and expressions. *</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pattern</span> <p>The statement pattern to modify</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">modifiable_set</span> <p>The name of the variable we are searching for.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-modify_stmt"><a href="#val-modify_stmt" class="anchor"></a><code><span><span class="keyword">val</span> modify_stmt : 
  <span><a href="../../Middle/Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <span class="xref-unresolved">Core</span>.Set.Poly.t</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Middle/Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a></span></code></div><div class="spec-doc"><p>Modify statement patterns in the MIR from AoS &lt;-&gt; SoA and vice versa</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">mem_pattern</span> <p>A mem_pattern to modify expressions to. For the given memory pattern, this modifies statement patterns and expressions to it.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">stmt</span> <p>The statement to modify.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">modifiable_set</span> <p>The name of the variable we are searching for.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-collect_mem_pattern_variables"><a href="#val-collect_mem_pattern_variables" class="anchor"></a><code><span><span class="keyword">val</span> collect_mem_pattern_variables : 
  <span><span><a href="../../Middle/Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a> <span class="xref-unresolved">Core</span>.List.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(string * <span><span><a href="../../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../../Middle/Expr/index.html#type-t">Middle.Expr.t</a></span> <a href="../../Middle/SizedType/index.html#type-t">Middle.SizedType.t</a></span>)</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_mem_patterns"><a href="#val-pp_mem_patterns" class="anchor"></a><code><span><span class="keyword">val</span> pp_mem_patterns : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Middle/Program/Typed/index.html#type-t">Middle.Program.Typed.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></div></body></html>
