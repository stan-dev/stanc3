<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>parser_messages (stanc.parser_messages)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['db.js','../sherlodoc.js'];
</script><script src="../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="../index.html">Index</a> &#x00BB; <a href="index.html">stanc</a> &#x00BB; parser_messages</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1 id="adding-or-changing-the-syntax-error-messages"><a href="#adding-or-changing-the-syntax-error-messages" class="anchor"></a>Adding or changing the syntax error messages</h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#background">Background</a></li><li><a href="#modifying-an-existing-message">Modifying an existing message</a><ul><li><a href="#example">Example</a></li></ul></li><li><a href="#adding-new-messages-after-the-parser-has-been-changed">Adding new messages after the parser has been changed</a></li><li><a href="#adding-new-parser-states">Adding new parser states</a></li><li><a href="#styling-error-messages">Styling error messages</a></li></ul></nav></div><div class="odoc-content"><h2 id="background"><a href="#background" class="anchor"></a>Background</h2><p>Stanc3 uses Menhir's Incremental API to provide custom error messages for when the parser detects an error. Menhir and the Incremental API are documented in the <a href="http://gallium.inria.fr/~fpottier/menhir/">reference manual</a>. We write the custom error messages in src/frontend/parser.messages file, which follows Menhir's messages format (documented <a href="http://gallium.inria.fr/~fpottier/menhir/manual.html#sec68">here</a>. Those messages are automatically integrated into the parser by the build rules defined in <code>src/frontend/dune</code>.</p><p>This process is less obvious than it seems and has some important to understand caveats. Please read the above section of the Menhir manual before making changes to the parser or syntax errors.</p><p>Each rule in parser.messages indicates the error state it corresponds to by specifying <em>any</em> stack of tokens which result in that error state.</p><p><b>There may be many such stacks of tokens which could correspond to the same error</b>. Menhir will point out if there are two rules defined for the same error, but it will only show you one of them.</p><h2 id="modifying-an-existing-message"><a href="#modifying-an-existing-message" class="anchor"></a>Modifying an existing message</h2><ol><li><p>Find the existing error message for the parser error in question by either:</p><ul><li>Searching the message file for the current error message test,</li><li>Compiling a stan program which throws the error message with the `--debug-parse` flag, then search for the error state number</li><li>OR a new rule to parser.messages corresponding to *any* stack of tokens which could trigger the error you're interested in, then let Menhir tell you the line number of the existing rule the new rule collides with</li></ul></li><li>Update the message of the existing rule</li></ol><h3 id="example"><a href="#example" class="anchor"></a>Example</h3><p>Suppose I want to change the error message for when the program is missing a <code>{</code> after the <code>model</code> keyword.</p><p>I write an example Stan program that has the error:</p><pre class="language-ocaml"><code>    parameters {
      real x;
    }
    model
      x ~ normal(0, 1);
    }</code></pre><p>Now I compile this program with stanc3 using the <code>--debug-parse</code> option. The result:</p><pre class="language-ocaml"><code>    ...
    Expected &quot;{&quot; after &quot;model&quot;.
    (Parse error state 685)</code></pre><p>The parse error state I'm looking for is 685. I search the parser.messages file for &quot;685&quot; (perhaps with the command `grep -n 685 src/frontend/parser.messages`), and I find:</p><pre class="language-ocaml"><code>    program: MODELBLOCK WHILE
    ##
    ## Ends in an error in state: 685.
    ##
    ## model_block -&gt; MODELBLOCK . LBRACE list(vardecl_or_statement) RBRACE [ GENERATEDQUANTITIESBLOCK EOF ]
    ##
    ## The known suffix of the stack is as follows:
    ## MODELBLOCK
    ##

    Expected &quot;{&quot; after &quot;model&quot;.</code></pre><p>I can now replace this message with my new version</p><h2 id="adding-new-messages-after-the-parser-has-been-changed"><a href="#adding-new-messages-after-the-parser-has-been-changed" class="anchor"></a>Adding new messages after the parser has been changed</h2><p>Often a new language feature will need new syntax messages. The build will add dummy error messages to <code>parser.messages</code> that you can replace.</p><p>It is crucial to understand that the example programs Menhir provides in this file may not represent all possible programs leading to this state. See <a href="http://gallium.inria.fr/~fpottier/menhir/manual.html#sec%3Aerrors%3Adiagnostics">this section of the Menhir manual</a> for specific advice.</p><h2 id="adding-new-parser-states"><a href="#adding-new-parser-states" class="anchor"></a>Adding new parser states</h2><p>Sometimes it is desirable to give a more specific error message than is possible with the default construction of the parser. One way around this is to add an additional state to the parser which matches the desired structure, followed by a token which cannot ever be reached. We define <code>UNREACHABLE</code> for this purpose.</p><p>Suppose I actually wanted to add a new message that would only show when a more specific error is made; maybe I want a special message for when <code>model</code> followed by a declaration. To do this I need to change the parser grammar in <code>src/frontent/parser.mly</code> to split off a new error state for the situation I want to catch. It is important to make sure not to change the behavior of the parser, so I should guarantee that he new rule will never successfully be built by terminating it with a token that can never occur. For example, I could change <code>model = MODELBLOCK LBRACE ...</code> to <code>model = MODELBLOCK LBRACE ... | MODELBLOCK REAL UNREACHABLE</code>.</p><p>This is enough to create a new parser state with a different error message.</p><p>Much like after a change to the parser for a new feature, after creating a new parser state, you should build the compiler to check the new entry and generate an error template in <code>parser.messages</code>.</p><h2 id="styling-error-messages"><a href="#styling-error-messages" class="anchor"></a>Styling error messages</h2><p>The messages in <code>parser.messages</code> are interpreted by our error reporting system as <code>Format</code> strings with no placeholders. In particular, this means you can use <a href="https://ocaml.org/manual/5.3/api/Format.html#tags">Format semantic tags</a> like <code>@{&lt;bold&gt;Text@}</code> to provide optional styling to the error messages. See the current messages file for examples and conventions we use here.</p></div></body></html>
